<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Asymptotically Optimal Validated Asynchronous Byzantine Agreement</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ittai</forename><surname>Abraham</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">VMware Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dahlia</forename><surname>Malkhi</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">VMware Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Spiegelman</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">VMware Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Asymptotically Optimal Validated Asynchronous Byzantine Agreement</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">29A7A8102B7B96EE39AC42571C4E0510</idno>
					<idno type="DOI">10.1145/3293611.3331612</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>byzantine agreement</term>
					<term>optimal protocol</term>
					<term>asynchronous</term>
					<term>validated</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We provide a new protocol for Validated Asynchronous Byzantine Agreement in the authenticated setting. Validated (multi-valued) Asynchronous Byzantine Agreement is a key building block in constructing Atomic Broadcast and fault-tolerant state machine replication in the asynchronous setting. Our protocol has optimal resilience of f &lt; n/3 Byzantine failures and asymptotically optimal expected O(1) running time to reach agreement. Honest parties in our protocol send only an expected O(n 2 ) messages where each message contains a value and a constant number of signatures. Hence our total expected communication is O(n 2 ) words. The best previous result of Cachin et al. from 2001 solves Validated Byzantine Agreement with optimal resilience and O(1) expected time but with O(n 3 ) expected word communication. Our work addresses an open question of Cachin et al. from 2001 and improves the expected word communication from O(n 3 ) to asymptotically optimal O(n 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS CONCEPTS</head><p>• Theory of computation → Distributed algorithms; • Security and privacy → Cryptography.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>replication in the asynchronous setting <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b26">27]</ref>. In this model, Cachin et al. <ref type="bibr" target="#b9">[10]</ref> defined the problems of Atomic Broadcast and Validated Asynchronous Byzantine Agreement (VABA) to guarantee a decision on some party's input, provided it satisfies a globally verifiable external validity condition. They show how to solve VABA in the authenticated setting, namely there is a trusted setup phase and security depends on computational hardness assumptions and the random oracle model. Their solution achieves optimal resilience n = 3f + 1, asymptotically optimal time O(1), and O(n 3 ) expected word communication. Improving the expected word communication for VABA in this model from O(n 3 ) to the O(n 2 ) is an open problem stated in <ref type="bibr" target="#b9">[10]</ref> and has been open for almost 20 years.</p><p>This paper presents the first VABA solution with optimal resilience, asymptotically optimal time whose expected word communication is O(n 2 ), thus closing this gap. More precisely, we prove the following theorem: Theorem 1. There exists a protocol among n parties that solves VABA in the authenticated setting and is secure against an adaptive adversary that controls up to f &lt; n/3 parties, with expected O(n 2 ) word communication and expected constant running time.</p><p>Complexity Measures. Bracha <ref type="bibr" target="#b8">[9]</ref> shows that even strictly weaker primitives than Asynchronous Byzantine agreement can only be solved when the number of parties n is larger than 3f where f is the maximum number of parties the adversary can corrupt. We therefore say that a solution has optimal resilience if it solves Byzantine agreement for n = 3f + 1. A theorem of Fischer, Lynch and Paterson <ref type="bibr" target="#b18">[19]</ref> states that any protocol solving Asynchronous Agreement must have a non-terminating execution even in the face of a single (benign) failure. Ben-Or <ref type="bibr" target="#b6">[7]</ref> shows that randomization can be used to make such non-terminating executions become events with probability 0. Feldman and Micali <ref type="bibr" target="#b17">[18]</ref> show that Asynchronous Byzantine Agreement can be solved with optimal resilience n = 3f + 1 and with an expected O(1) asynchronous running time (where running time is the maximum duration as defined by Canetti and Rabin <ref type="bibr" target="#b12">[13]</ref> and is essentially the number of steps when the protocol is embedded into a lock-step timing model). We therefore say that a solution has asymptotically optimal time if it solves Byzantine agreement using an expected O(1) running time. We show in the full paper <ref type="bibr" target="#b1">[2]</ref> that a recent lower bound of Abraham et al. <ref type="bibr" target="#b0">[1]</ref> implies that any protocol solving Asynchronous Byzantine Agreement against an adaptive adversary (and without a constant error probability) must have the honest parties send expected Ω(n 2 ) messages. We therefore say that a solution has asymptotically optimal word communication if it solves Byzantine agreement using an expected O(n 2 ) messages and each message contains just a single word where we assume a word contains a constant number of signatures and domain values. Multi-valued Agreement. A simplified version of the agreement problem is the binary agreement problem in which the inputs of the parties are restricted to the set {0, 1}. A fundamental work by Cachin, Kursawe, and Shoup <ref type="bibr" target="#b10">[11]</ref> was the first to give an optimal algorithm in terms of time, resilience, and word communication in the random oracle model, which they formalized to fit the distributed settings. In particular, the algorithm withstands up to f &lt; n/3 Byzantine failures, runs in constant expected number of asynchronous views (rounds), and the expected communication cost is O(n<ref type="foot" target="#foot_1">2</ref> ) messages of the size of one or two RSA signatures <ref type="bibr" target="#b32">[33]</ref>. A more recent work by Mostéfaoui et al. <ref type="bibr" target="#b27">[28]</ref> shows how to achieve optimality without any cryptographic assumptions besides the existence of a common random coin <ref type="foot" target="#foot_0">1</ref> .</p><p>As for the multi-valued Byzantine agreement, the original problem specification due to Lamport et al. <ref type="bibr" target="#b30">[31]</ref> was motivated by the following setting: Four computers in control of a space-shuttle cockpit need to reach agreement on a sensor reading, despite one being potentially faulty. The problem was captured via the following condition: Definition 1 (Weak validity <ref type="bibr" target="#b14">[15]</ref>). If all honest parties propose a value v, then every honest party that terminates decides v.</p><p>Note that while the Weak Validity condition is well defined, it says nothing about a situation in which parties propose different values, allowing them to (1) return some default value ⊥ that indicates that no agreement was reached or (2) agree on a value proposed by a corrupted party. Mostéfaoui et al. <ref type="bibr" target="#b28">[29]</ref> consider a slightly stronger property in which only a value proposed by an honest party or ⊥ are allowed to be returned 2 . However, honest parties may still decide ⊥ if they initially disagree. In particular, it is not clear how this slightly stronger validity property can be used to solve Atomic Broadcast <ref type="bibr" target="#b9">[10]</ref>.</p><p>Cachin et al. formulated in <ref type="bibr" target="#b9">[10]</ref> a problem specification that captures the practical settings where parties propose updates to a replicated state. Agreement is formed on a sequence of updates, hence a non-default decision is needed in order to make progress. To prevent updates from rogue parties, the model is extended with an External Validity predicate as follows: Definition 2 (External validity). If an honest party decides on a value v, then v is externally valid. <ref type="bibr" target="#b28">[29]</ref> a signature-free deterministic reduction from their binary agreement protocol <ref type="bibr" target="#b27">[28]</ref> that solves asynchronous Byzantine Agreement with Weak validity. It has optimal resilience and asymptotically optimal time and word communication. Unfortunately, BA with Weak validity only does not solve Atomic Broadcast or State Machine Replication (SMR).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mostéfaoui et al. presented in</head><p>Cachin et al. gave in <ref type="bibr" target="#b9">[10]</ref> a reduction from their binary agreement algorithm <ref type="bibr" target="#b10">[11]</ref> to VABA and also showed how to use it in order to implement an atomic broadcast. Their VABA protocol provides external validity, has optimal resilience, asymptotically optimal time, and expected message complexity O(n 3 ). That paper explicitly mentions the open problem of improving the expected word communication from O(n 3 ) to O(n 2 ).</p><p>Our Contribution. The main contribution of this paper is solving this open question. Just like <ref type="bibr" target="#b9">[10]</ref>, our protocol solves Asynchronous Byzantine agreement with external validity (VABA), has optimal resilience and asymptotically optimal time. Improving on <ref type="bibr" target="#b9">[10]</ref>, our expected word communication is also asymptotically optimal. In particular, honest parties send a total expected O(n 2 ) messages, which is optimal and each message is roughly the size of one or two threshold signatures.</p><p>Our protocol is secure against an adaptive adversary. This follows from using adaptively secure threshold signatures of Libert et al. <ref type="bibr" target="#b24">[25]</ref> and adaptively secure common coin protocol of Loss and Moran <ref type="bibr" target="#b25">[26]</ref>. Cachin et al. <ref type="bibr" target="#b9">[10]</ref> note that their binary protocol <ref type="bibr" target="#b10">[11]</ref> and their Validated protocol <ref type="bibr" target="#b9">[10]</ref> also immediately generalize to be secure against adaptive adversaries by using the primitives above.</p><p>Techniques and Challenges. At a high level, the main conceptual contribution of this paper is a new approach for solving Byzantine agreement in the asynchronous model by using view-change based techniques that were traditionally used only in the partially synchronous model <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b23">24]</ref>. Traditionally, all view-change based protocols depend on some timeout mechanism. To adopt viewchange based protocols to full asynchronous models and obtain optimal word communication against an adaptive adversary our work needs to overcome three core challenges (1) remove timeouts (2) provide safety and liveness against an an adaptive adversary and (3) reduce communication to a minimum.</p><p>Unlike previous constructions (e.g., <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b26">27]</ref>), our protocol does not go through a randomized binary agreement black-box. Instead, much like Katz and Koo's Synchronous Byzantine agreement protocol <ref type="bibr" target="#b21">[22]</ref>, in each view, we run n parallel leader-based threads and then use a random leader election primitive to decide which leader is elected in hindsight. To adopt this idea to the asynchronous model each leader-based thread is a separate instance of the leader-based paradigm of <ref type="bibr" target="#b13">[14]</ref> that uses view-change to replace leaders safely in asynchronous settings.</p><p>The idea of letting n parties concurrently broadcast their values and then using a leader election to determine which value should be further considered was first introduced in <ref type="bibr" target="#b7">[8]</ref>. However, while in <ref type="bibr" target="#b7">[8]</ref> they use this value as an input to a Byzantine agreement instance, we use a view-change mechanism to determine if this value can be safely decided or should it be adopted to the following views otherwise. By opening the black box agreement protocols used by both <ref type="bibr" target="#b9">[10]</ref> and <ref type="bibr" target="#b7">[8]</ref> we are able to reduce the communication complexity to a minimum. Just like <ref type="bibr" target="#b21">[22]</ref>, not all honest parties in our protocol reach agreement in the same view. To guarantee safety between different views we use a view-change protocol that guarantees that new leaders can propose only safe values. To guarantee liveness between different views, instead of using a timeout, the trigger is the knowledge that nf leader-based threads have made sufficient progress inside their protocol.</p><p>On the one hand, to obtain O(n 2 ) word communication per view, we need each of the n leader-based protocols to use just O(n) words and we need the global view change protocol to use just O(n 2 ) words. On the other hand, to guarantee progress we must guarantee that our view change protocol will allow progress even in Session 7 PODC '19, July 29-August 2, 2019, Toronto, ON, Canada asynchronous settings. To balance between frugal communication and liveness we adopt a four step leader-based protocol that is inspired by an approach taken in the partial synchronous model by Yin et al. <ref type="bibr" target="#b33">[34]</ref>.</p><p>To obtain the optimal O(1) expected time against an adaptive adversary, the next challenge is to guarantee that when the first honest party enters the leader election phase, there is a constant fraction of potential leaders such that if one of them is elected then all honest parties will decide in constant time. By electing the leader after many leaders have completed their work we limit the adaptive power of the adversary. Moreover, if the elected leader did not complete its broadcast, we need a mechanism to allow parties to abandon the elected leader's broadcast before running the global view-change protocol.</p><p>Cryptography vs Full information. In this paper we assume an environment with a trusted setup providing authenticated but asynchronous communication channels, and a computationally bounded adversary that cannot read the private state of non-faulty parties.</p><p>It is natural to ask if similar results can be obtained in the full information model where the adversary is computationally unbounded and can see the state of all parties. Recent years has seen major advances in this model. Kapron et al. <ref type="bibr" target="#b20">[21]</ref> solve ABA with just O(n 2 ) bits against a static full information adversary that controls less than n/6 parties. King and Saia <ref type="bibr" target="#b22">[23]</ref> solve ABA against a dynamic full information adversary that controls less than n/500. Bar Joseph and Ben Or <ref type="bibr" target="#b3">[4]</ref> show that there is a fundamental gap between the full information model and the cryptographic model. They prove that any randomized solution against an adaptive full information fail-stop adversary that controls a constant fraction of the parties must take at least Ω( n/log n) rounds in the synchronous model. By using cryptographic assumptions we overcome this lower bound and obtain the asymptotically optimal O(1) expected rounds and O(n 2 ) word communication in the asynchronous model. We are not aware of any lower bound for obtaining O(n 2 ) bits against a dynamic full information adversary with optimal resilience in the asynchronous model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MODEL</head><p>In order to reason about distributed algorithms in cryptographic settings we adopt the model defined in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. We consider an asynchronous message passing system consisting of a set Π of n parties, an adaptive adversary, and a trusted dealer. The adversary may control up to f &lt; n/3 parties during an execution. An adaptive adversary is not restricted to choose which parties to corrupt at the beginning of an execution, but is free to corrupt (up to f ) parties on the fly. Note that once a party is corrupted, it remains corrupted, and we call it faulty. A party that is never corrupted in an execution is called honest. To be able to use the threshold signature from <ref type="bibr" target="#b24">[25]</ref> and the coin tossing from <ref type="bibr" target="#b25">[26]</ref> we assume the cryptographic random oracle model. In addition, as in <ref type="bibr" target="#b5">[6]</ref>, we treat a hash function like a random oracle.</p><p>We assume an initial setup before every execution in which the trusted dealer generates the initial states of all parties, and we assume that the adversary cannot obtain the states of honest parties at any time during an execution.</p><p>Computation. Following <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, we use standard modern cryptographic assumptions and definitions. We model the computations made by all system components as probabilistic Turing machines, and bound the number of computational basic steps allowed by the adversary by a polynomial in a security parameter k. A function ϵ(k) is negligible in k if for all c &gt; 0 there exists a k 0 s.t. ϵ(k) &lt; 1/k c for all k &gt; k 0 . A computational problem is called infeasible if any polynomial time probabilistic algorithm solves it only with negligible probability. Note that by the definition of infeasible problems, the probability to solve at least one such problem out of a polynomial in k number of problems is negligible. Intuitively, this means that for any protocol P that uses a polynomial in k number of infeasible problems, if P is correct provided that the adversary does not solve one of its infeasible problems, then the protocol is correct except with negligible probability. We assume that the number of parties n is bounded by a polynomial in k.</p><p>Communication. We assume asynchronous links controlled by the adversary, that is, the adversary can see all messages and decide when and what messages to deliver. In order to fit the communication model with the computational assumptions, we restrict the adversary to perform no more than a polynomial in k number of computation steps between the time a message m from an honest party p i is sent to an honest party p j and the time m is delivered by p j<ref type="foot" target="#foot_3">3</ref> . In addition, for simplicity, we assume that messages are authenticated in a sense that if an honest party p i receives a message m indicating that m was sent by an honest party p j , then m was indeed generated by p j and sent to p i at some prior time. This assumption is reasonable since it can be easily implemented with standard symmetric-key cryptographic techniques <ref type="bibr" target="#b4">[5]</ref> in our model.</p><p>Termination. Note that the traditional definition of the liveness property in distributed system, which requires that all correct (honest) parties eventually terminate provided that all messages between correct (honest) parties eventually arrive, does not make sense in this model. This is because the traditional definition allows the following:</p><p>• Unbounded delivery time between honest parties, which potentially gives the adversary unbounded time to solve infeasible problems. • Unbounded runs that potentially may consist of an unbounded number of infeasible problems, and thus the probability that the adversary manages to solve one is not negligible. Following Cachin et al. <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, we address the first concern by restricting the number of computation steps the adversary makes during message transmission among honest parties. So as long as the total number of messages in the protocol is polynomial in k, the error probability remains negligible. To deal with the second concern, we do not use a standard liveness property in this paper, but instead we reason about the total number of messages required for all honest parties to terminate. We adopt the following definition from <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>: Definition 3 (Uniformly Bounded Statistic). Let X be a random variable. We say that X is probabilistically uniformly bounded if there exist a fixed polynomial T (k) and a fixed negligible functions δ (l) and ϵ(k) such that for all l, k ≥ 0,</p><formula xml:id="formula_0">Pr [X &gt; lT (k)] ≤ δ (l) + ϵ(k)</formula><p>With the above definition Cachin et al. <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> define a progress property that makes sense in the cryptographic settings:</p><p>• Efficiency: The number of messages generated by the honest parties is probabilistically uniformly bounded</p><p>The efficiency property implies that the probability of the adversary to solve an infeasible problem is negligible, which makes it possible to reason about the correctness of the primitives' properties. However, note that this property can be trivially satisfied by a protocol that never terminates but also never sends any messages. Therefore, in order for a primitive to be meaningful in this model, Cachin et al. <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> require another property:</p><p>• Termination<ref type="foot" target="#foot_4">4</ref> : If all messages sent by honest parties have been delivered, then all honest parties terminated. In this paper we consider both efficiency and termination properties as defined in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. However, note that when considering an adaptive adversary, it is also possible to define a slightly weaker termination property:</p><p>• Weak termination: If all messages sent by parties before they were corrupted have been delivered, then all honest parties terminated. Note that while any protocol that satisfies termination satisfies weak termination as well, a lower bound for termination does not apply for weak termination. Indeed our lower bound (see full paper <ref type="bibr" target="#b1">[2]</ref>) is for protocols that obtain the termination property. We leave the study of lower bounds for protocols with weak termination as an open question.</p><p>Complexity. We use the following standard complexity notions (see for example Cannetti and Rabin <ref type="bibr" target="#b12">[13]</ref>). We measure the expected word communication of our protocol as the maximum over all inputs and applicable adversaries of the expected total number of words sent by honest parties where expectation is taken over the random inputs of the players and of the adversary. We assume a finite domain V of valid values for the Byzantine agreement problem, and say that a word can contain a constant number of signatures (see Section and domain values 2.1). We measure the expected running time of our protocol as the maximum over all inputs and applicable adversaries of the expected duration where expectation is taken over the random inputs of the players and of the adversary. The duration of an execution is the total time until all honest players have terminated divided by the longest delay of a message in this execution. Essentially the duration of an execution is the number of steps taken if this execution is re-run in lock-step model where each message takes exactly one time step.</p><p>Following Cachin et al. <ref type="bibr" target="#b9">[10]</ref> (see Lemma 1 therein), in order to show that our view-based protocol runs in an expected constant running time and has expected O(n 2 ) word communication, it is enough to show that:</p><p>• every view consists of R(k) = O(n 2 ) messages that consist of one word, and</p><p>• the total number of messages is probabilistically uniformly bounded by R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Cryptographic abstractions</head><p>The main focus of this paper is on a novel distributed algorithm, which uses cryptographic tools as black-boxes. To this end, we present our protocol assuming the existence of two cryptographic abstractions:</p><p>• Threshold signatures scheme. We assume that each party p i has a private function share-sign i , and we assume 3 public functions: share-validate, threshold-sign, and thresholdvalidate. Informally, given n-f validated shares, the function threshold-sign returns a valid threshold signature. • Threshold coin-tossing. We assume that each party p i has a private function coin-share i , and we assume 2 public functions: coin-share-validate and coin-toss. Informally, given f + 1 validated coin shares, the function coin-toss returns a unique and pseudorandom number from the range [1, . . . , n].</p><p>The for formal definitions and implementation details can be found in the full paper <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Validated asynchronous byzantine agreement (VABA)</head><p>In this paper we follow Cachin et al. <ref type="bibr" target="#b9">[10]</ref> and define a (multi-valued) Byzantine agreement with an external validity function we call EX-VABA-VAL. The purpose of this function is to determine whether a value is externally valid for agreement, and the validity property of the VABA requires parties to decide only on externally valid values. To rule out trivial solutions in which parties always decide on some pre-defined externally valid value, we could try to add a requirement that only a value that was actually proposed by some party (honest or not) can be decided. However, since byzantine parties can propose one value and act as if they proposed a different value, this requirement seems to be impossible to achieve. Instead, we add another property to the VABA problem defined in <ref type="bibr" target="#b9">[10]</ref>, which we call quality. The quality property bounds the probability that the decision value was proposed by an honest party. Note that every probability that is grater than zero rules out trivial solutions, however, to capture the "fairness" of the decision value we require this probability to be 1/2 <ref type="foot" target="#foot_5">5</ref> . We conjecture that higher probability is impossible to achieve in our model. The formal definition of the VABA protocol is given below.</p><p>Definition 4 (Validated Byzantine Agreement). A protocol solves validated Byzantine agreement if it satisfies the following properties except with negligible probability:</p><p>• Validity: If an honest party decides an a value v, then EX-VABA-VAL(v) = true. • Quality: The probability of choosing a value that was proposed by an honest party is at least 1/2. • Agreement: All honest parties that terminate decide on the same value.</p><p>• Termination: If all honest parties start with externally valid values and all messages sent among honest parties have been delivered, then all honest parties decide. • Efficiency: The number of messages generated by the honest parties is probabilistically uniformly bounded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ASYMPTOTICALLY OPTIMAL VABA PROTOCOL</head><p>In this section we give a protocol for asynchronous byzantine agreement, secure against an adaptive adversary that controls up to f &lt; n/3 parties, with expected word communication O(n 2 ) and expected running time O(1). We present a modular implementation, which consists of three sub protocols: a simple two-round broadcast primitive we call Provable-Broadcast, a simple Leader-Election protocol, and another primitive, we call Proposal-Promotion, which is built on top of 4 sequential instances of Provable-Broadcast. In Section 3.1, we give an overview of the protocols, and in Section 3.2 we present detailed pseudocode and description.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Our VABA protocol overview</head><p>Provable-Broadcast. The Provable-Broadcast is a simple tworound broadcast that adds an external validity to the basic echo multicast protocol from <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b31">32]</ref>. In the first round, the sender sends a message, that contains a value and a proof for external validity, to all parties. In the second round, each party first validates, with an external validation function (which implements a logic of the protocol that is implemented on top of the broadcast), that the message is valid. Then, it (1) delivers the message (value and proof), (2) threshold-signs it, and (3) sends the signed share back to the sender. When the sender gets nf properly signed shares, it combines them into one threshold signature and returns it. An illustration of the Provable-Broadcast protocol appears in Figure <ref type="figure" target="#fig_1">1</ref>. Informally, the provability property of this simple broadcast satisfies the following: (1) An honest sender returns a threshold signature which he can later use to prove that at least f + 1 honest parties delivered the message; and (2) a faulty sender cannot produce two such proofs for two different messages. This proof is later used by the sender for external validity in other parts of the VABA protocol.</p><p>Proposal-Promotion. As we explain below, the VABA protocol works in a view-based manner, where in each view the parties participate in n concurrent Proposal-Promotion sub-protocols. Each party i is acting as the leader of the i t h Proposal-Promotion invocation and tries to promote its proposal by distributing them to all other parties. The distribution inside a Proposal-Promotion sub-protocol consists of 4 sequential steps, each of which invokes an instances of a Provable-Broadcast. An illustration of the sub-protocol appears in Figure <ref type="figure" target="#fig_2">2</ref>. All parties participating in an instance of a Proposal-Promotion maintain 3 local variables: key, lock, and commit. The key variable stores the message (value and proof) delivered in the second step (second instance of the Provable-Broadcast), the lock variable stores the message delivered in the third step, and the commit variable stores the message delivered in the fourth step. For clarity, we refer to these delivery events as key delivery, lock delivery, and commit delivery, respectively. A leader (the initiating party) of a Proposal-Promotion invocation that successfully completes gets a proof of its completeness, which is the threshold signature output of the last Provable-Broadcast instance therein. As for the external validity of the Provable-Broadcast steps inside a Proposal-Promotion, we distinguish between the first instance and the last 3. For the first instance (first step) the leader provides a proof key that the proposed value (the one to be promoted) is safe for the current view of the VABA protocol. (More details on this below). For each of the other 3 instances, the leader provides the threshold signature output of the preceding Provable-Broadcast instance, which is a proof of its successful completion. Informally, the provability property together with the external validity of Provable-Broadcast guarantee the following:</p><p>• All values delivered by honest parties in the key, lock, and commit deliveries are (1) equal and (2) satisfy the safety logic of the higher level VABA protocol for this view. • A valid completeness proof indicates that at least f + 1 honest parties delivered commit. In addition, if an honest party delivered commit, then at least f + 1 honest parties previously delivered lock, and if an honest party delivered lock, then at least f + 1 honest parties previously delivered key.</p><p>Leader-Election. The Leader-Election primitive is a simple oneround protocol that uses the cryptographic threshold coin-tossing abstraction to elect a unique leader <ref type="foot" target="#foot_6">6</ref> among the parties for each view. In every view R, each party p i uses coin-share i (R) to produce a share ρ i and sends it to all other parties. When a party gets f + 1 proper shares for view R it uses the function coin-toss to compute the leader of view R. Informally, the main properties are that (1) all honest parties agree on the leader, (2) the adversary cannot predict who is the leader unless one honest party participates, and (3) every party has an equal probability to became the leader of every view.  <ref type="formula">2</ref>). The LOCK variable stores a view number that corresponds to the highest view in which a view-change message with a valid lock (contains ⟨v, σ ⟩ s.t. σ is a proof for v's delivery in the third instance of the Provable-Broadcast in the Proposal-Promotion of view) was received. Informally, the external validity function in the first instance of the Provable-Broadcast of each Proposal-Promotion checks that the promoted value is attached to a valid key that was obtained in view that is at least large as the the view of the local variable LOCK. An high-level illustration appears in Figure <ref type="figure" target="#fig_3">3</ref>, and more details are given in the description below.</p><p>Our protocol guarantees that at least nf Proposal-Promotion instances complete in the broadcast phase before a leader is elected.</p><p>If the elected leader has completed its Proposal-Promotion (implying that at least f + 1 honest parties delivered a commit) then even an adaptive adversary cannot prevent progress. Otherwise, the view-change phase ensures that agreement is not violated even if a bad leader is elected. Since the probability to choose a leader that completed its Proposal-Promotion is constant, the number of views in the protocol is constant in expectation. More concretely, the probability to choose a completed broadcast is greater than 2/3, and thus the number of views in expectation is less than 3/2.</p><p>Communication complexity. Each of the key, lock, and commit variables stores one value and one threshold signature. Therefore, the total word complexity of the View-change phase is O(n 2 ). The word complexity of a single instance of Proposal-Promotion is O(n), which leads to total O(n 2 ) word complexity of the Leadernomination phase. Since the Leader-election phase has a single round all-to-all communication with messages of size 1 word, we get that all to all, our VABA protocol has an optimal O(n 2 ) word complexity in expectation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Detailed VABA protocol description</head><p>In this section we give a detailed description of our VABA protocol. A formal proof and a complexity analysis appear in the full paper <ref type="bibr" target="#b1">[2]</ref>. For better readability we use the top down approach. We first present the VABA protocol and then describe the subprotocols it uses. The formal definition of the properties as well as the pseudocode of the simple Leader-election primitive are deferred to Appendix B. As defined in the model, there is an external function, called EX-VABA-VAL(v), which checks if v is a valid value for the byzantine agreement. An instance of the high-level VABA protocol is identified with a parameter id. Every instance of every sub-protocol is identified with a parameter ID, which extends id. For example, the ID of p i 's Proposal-Promotion in view view is ⟨id, i, view⟩, and the ID of the second instance of the Provable-Broadcast therein is ⟨⟨id, i, view⟩, 2⟩.</p><p>Local variables. We start by presenting the local variables parties maintain (see Algorithm 1). All parties maintain two cross-view variables, LOCK and KEY :</p><p>• The LOCK variable stores the highest view number for which the party ever received a view-change message that includes a lock that was delivered in the Proposal-Promotion of the chosen leader of this view. • The KEY variable stores the 3-tuple: view, proof and value, derived from the maximum view for which the party ever received a view-change message that includes a key (composing of value and proof) that was delivered in the Proposal-Promotion of the chosen leader of this view. In addition, all parties maintain per-view variables: For a view view, each party stores the elected leader of this view in Leader [view], and few variables, PPdone[view], PPskip[view], skip <ref type="bibr">[view]</ref>, which are used to make sure that at least nf parties completed their Proposal-Promotion before some honest party moves to the leader election phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Local variables initialization for party p</head><formula xml:id="formula_1">i . LOCK ← 0 K EY ← ⟨0, v i , ⊥⟩ with selectors view, value, proof ▷ v i is p i 's input for every view ≥ 1, initialize: Leader [view ] ← ⊥ P Pdone[view ] ← 0 P P skip[view ] ← { } skip[view ] ← f alse</formula><p>The pseudocode of the top VABA protocol appears in algorithms 2 and 3. We next describe the phases in each view:</p><p>Leader nomination phase. Each party promotes, using a Proposal-Promotion sub-protocol, the value and key it has adopted from the previous views, as determined in the View-Change Phase (explained below); at view 1, a party promotes its input and an empty key. Parties participate in n concurrent Proposal-Promotions, and each party sends a done notification about the completion of its own Proposal-Promotion carrying its output for proof. When a party receives n-f such notifications, it sends a signature share on a skipshare message. For termination, each party waits to obtain (directly or indirectly) a combined threshold skip signature, forwards it to others, and moves to the Leader-election phase (even if its Proposal-Promotion has not completed due to abandon invocation of other parties).</p><p>Leader election phase. Once a party enters the Leader-election Phase, it abandons all the Proposal-Promotion instances (more details on abandon is given below). The parties elect a leader via the leader election primitive and continue to the next phase as if only the chosen leader's Proposal-Promotion ever occurred. From now on, we refer to the Proposal-Promotion of the leader of a view view view ← view + 1 as the Proposal-Promotion of view view, and refer to its delivery events as the deliveries of view view.</p><p>View-change phase. In the View-change Phase of every view, parties report their delivery events (value and proof) of this view (delivery in the chosen leader's Proposal-Promotion) to all other parties. Each party waits to collect n-f reports. Recall that Proposal-Promotion provides the following guarantees: If some honest party delivers a commit, then f + 1 honest parties deliver lock, hence all honest parties recieve this lock in the view-change exchange. Similarly, if some honest party delivers a lock, then f + 1 honest parties deliver a key, hence all honest parties receive this key.</p><p>Once a party has collected nf view-change messages, it processes them as follows. If it receives a commit with a value v, it decides v. Otherwise, if it receives a lock, it increases its LOCK variable to the current view. Last, if it receives a key, it updates its KEY variable to store the current view and the received key. If it if threshold-validate(⟨⟨⟨id, k, view ⟩, 4⟩, v ⟩, σ ) then if "skip-share" message was not sent yet in view view then ρ ← sigh-share(⟨id, skip, view ⟩)</p><formula xml:id="formula_2">7:</formula><p>send "id, skip-share, view, ρ" to all parties </p><formula xml:id="formula_3">K EY ← ⟨view, v 2 , σ 2 ⟩</formula><p>did not reach a decision, a party adopts the value v of its (up-todate) KEY variable and moves to the next view, where it promotes v together with KEY as proof for the external validation function (EX-PB-VAL) of the Provable-Broadcast.</p><p>As mentioned above, a party participates in a Proposal-Promotion only if the message m = ⟨v, ⟨R, σ key ⟩⟩ (note that ⟨R, v, σ key ⟩ = KEY) passes the external validation test. The external validation EX-PB-VAL includes a crucial key-locking mechanism (see Algorithm 5, lines 18 to 28). In particular, in view j &gt; 1, a party checks that the σ key is valid for v and R (meaning that σ key is a proof that key(⟨v, σ key ⟩) could have been deliverd by an honest party in the Proposal-Promotion of view R), and that the view R is at least as large as the LOCK variable. We prove in the full paper <ref type="bibr" target="#b1">[2]</ref> that the key-locking mechanism together with the fact that parties abandon all broadcasts before sending the view-change messages guarantee agreement and satisfy progress. Here we give some intuition for the proof:</p><p>• Lock Safety: If some party has a proof for commit delivery in view R, then at least f +1 honest parties previously delivered lock and thus locked (lock = R) in view R. S ← S ∪ {ρ k }</p><p>• Key Safety: If some party has a proof for commit delivery with a value v in view R, then it is not possible for a party to have a valid key that contains a value other than v in view higher than or equal to R. • Key Progress: If some party p i is locked in view R, then at least f +1 honest parties delivered a key in R before sending the view-change messages of view R, and thus all honest parties will have a KEY with view at least R. Meaning that all honest parties will have a key to "unlock" p i in the next view.</p><p>We now continue to the detailed description of the VABA subprotocols:</p><p>Provable-Broadcast. In addition to what is mention in the overview above, Provable-Broadcast also exposes a PB-abandon(ID) API, which parties invoke to explicitly stop their participation in the Provable-Broadcast protocol associated with identification ID -no message is delivered and no signed share is sent after PB-abandon(ID) is invoked. A Provable-Broadcast of a message m = ⟨v, σ ⟩ with identification ID is denoted PB(ID,m). The external validation function used by the Provable-Broadcast is denoted by EX-PB-VAL(I D, ⟨v, σ ⟩). This function has access to the local variables of the high-level VABA protocol. For better readability, the formal definition of the properties satisfied by Provable-Broadcast is deferred to Appendix A. The pseudocode of the sub-protocol and the EX-PB-VAL((ID, ⟨v, σ ⟩)) function appear in Algorithms 4 and 5. The EX-PB-VAL((ID, ⟨v, σ ⟩)) function implements an important logic of the VABA protocol. The proof σ consists of two proofs ⟨view, σ key ⟩ and σ in . If ID is an identification of a first Provable-Broadcast instance of some Proposal-Promotion sub-protocol, then ⟨view, σ key ⟩ is passed to function called check-key to check if v is a safe proposal for the current view by verifying that (1) σ key is a valid key from view view and (2) view is not smaller than LOCK. Otherwise, EX-PB-VAL checks that σ in is a valid output of the preceding instance of Provable-Broadcast by verifying that it is the correct threshold signature.</p><p>Proposal-Promotion. Besides the promote function mentioned in the overview, Proposal-Promotion also has an abandon function that invokes PB-abandon on all 4 instances of Provable-Broadcast therein. In addition, it also exposes getKey, getLock, and getCommit API for the VABA protocol to be able to get the delivered key, lock, and commit, respectively. For clarity and readability we do not if check-key(v,key) then parse key as ⟨view, ρ ⟩</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>22:</head><p>if view 1 then ▷ need to validate the key return false ▷ the key was obtained in a view that is smaller than the view on which LOCK is locked define formal properties for the Proposal-Promotion sub-protocol. Instead, we use it for exposition modularity and prove the VABA protocol by using the Provable-Broadcast properties directly. The pseudocode of Proposal-Promotion appears in Algorithms 7 and 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>Our protocol addresses an open problem introduced by Cachin et al. <ref type="bibr" target="#b9">[10]</ref> and reduces the expected word communication from O(n 3 ) to O(n 2 ) against an asynchronous adaptive adversary. We also show that in the standard definition of an asynchronous adaptive adversary this expected word communication is asymptotically optimal for any protocol that obtains the standard definition of termination (liveness) as defined <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. An interesting open question is related to protocols that obtain weak termination in the adaptive setting: is there a Ω(n 2 ) lower bound against an adaptive adversary that is required to deliver all messages sent by parties before they are  σ in ← PB(⟨ID, step⟩, ⟨v, ⟨key, σ in ⟩⟩)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>return σ in corrupted? or does there exist a protocol with near linear expected word communication under this weak termination property?</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Session 7 PODC ' 19 ,</head><label>719</label><figDesc>July 29-August 2, 2019, Toronto, ON, Canada</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Provable-Broadcast illustration. The message external validation by all parties is omitted. When a party receives a value v and a proof σ from the sender, it first uses σ to externally validate v, and only then deliver, sign, and send its share ν back to the sender.</figDesc><graphic coords="5,337.28,83.69,201.60,130.26" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Illustration of the 4 steps of a Proposal-Promotion sub protocol.</figDesc><graphic coords="6,90.00,83.69,432.01,92.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An illustration of a single view in the VABA protocol. Blue thin arrows represent messages and black thick arrows represent invocations and responds of sub-protocols.</figDesc><graphic coords="7,108.00,83.69,396.00,118.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm 2 6 : 7 : 9 : 12 :</head><label>267912</label><figDesc>Validated asynchronous byzantine agreement with identification id: protocol for party p i . 1: view ← 1 2: while true do 3: I D ← ⟨id, i, view ⟩ ▷ Leader nomination phase 4: key ← ⟨K EY .view, K EY .pr oof ⟩ 5: σ ← promote(I D,⟨K EY .value, key ⟩) wait for pr omot e to return or skip[view ] to become true if skip[view ] = false then 8: send "id, done, view, K EY .value, σ " to all parties wait until skip[view ] = t r ue ▷ Leader election phase 10: for all k=1,. . . ,n do 11: abandon( ⟨id, k, view ⟩) ▷ abandon Proposal-Promotion with I D = ⟨id, k, view ⟩ Leader [view ] ← el ect ( ⟨id, view ⟩) ▷ View-change phase 13: I D l e ad e r = ⟨id, Leader [view ], view ⟩ 14: send "id, View-change, view, дet K ey(I D l e ad e r ), дet Lock (I D l e ad e r ), дetCommit (I D l e ad e r )" to all parties 15:wait for View-change messages from nf different parties 16:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Session 7 PODC ' 19 ,</head><label>719</label><figDesc>July 29-August 2, 2019, Toronto, ON, Canada Algorithm 3 Validated asynchronous byzantine agreement with identification id: messages. 1: upon receiving "id, done, view, v, σ " from party p k for the first time do 2:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>3 :P</head><label>3</label><figDesc>Pdone[view ] ← P Pdone[view ] + 1 4:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>5 :</head><label>5</label><figDesc>if P Pdone[view ] = nf then 6:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Algorithm 4 3 : 4 : 5 : 6 :</head><label>43456</label><figDesc>Provable-Broadcast with identification I D: Protocol for the sender Local variables initialization: S = { } 1: upon PB(I D,⟨v, σ ⟩) invocation do 2: send "I D, send, ⟨v, σ ⟩" to all parties wait until |S | = nf return threshold-sign(S ) upon receiving "I D, ack, ρ k " form party p k for the first time do if share-validate( ⟨I D, v ⟩, k, ρ k ) = true then 7:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Algorithm 5 2 : 3 :stop ← t rue 4 : 5 : 8 :stop ← t rue 9 :</head><label>5234589</label><figDesc>Provable-Broadcast with identification I D: Protocol for a party p iLocal variables initialization:stop ← f alse 1: upon receiving "I D, send, ⟨v, σ ⟩" from the sender do ▷ parse I D as ⟨⟨id, k, j ⟩, l ⟩; P k is the senderif stop = f alse ∧ EX-PB-VAL(ID, ⟨v, σ ⟩) = true then ρ i ← share-sign i (⟨I D, v ⟩) deliver ⟨v, σ ⟩ 6:send "I D, ack, ρ i " to the sender 7: upon PB-abandon(I D) do procedure EX-PB-VAL(I D, ⟨v, σ ⟩) 10: parse I D as ⟨I D, st ep ⟩ ▷ I D is the identification of the higher level Proposal-Promotion; step is the Provable-Broadcast instance therein 11: parse σ as ⟨key, σ in ⟩ 12:if st ep = 1 then ▷ first instance of PB in a Proposal-Promotion 13:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>18 :</head><label>18</label><figDesc>if st ep &gt; 1 ∧ threshold-validate(⟨⟨I D, st ep -1⟩, v ⟩, σ in ) then procedure check-key(v, key) 19:if EX-VABA-VAL(v) = false then ▷ external VABA validity check 20:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>23 :</head><label>23</label><figDesc>if threshold-validate(⟨⟨⟨id, Leader[view ], view ⟩, 1⟩, v ⟩, ρ)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Algorithm 6 2 :step = 2 then 3 : 4 :step = 3 then 5 : 6 :step = 4 then 7 : 8 : 9 : 11 :</head><label>62345678911</label><figDesc>Proposal-Promotion with identification I D: Protocol for all parties.Local variables initialization: key = lock = commit = ⟨⊥, ⊥⟩ 1: upon delivery(⟨ID, step⟩, ⟨v, ⟨key, σ in ⟩⟩) do if key ← ⟨v, σ in ⟩ if lock ← ⟨v, σ in ⟩ if commit ← ⟨v, σ in ⟩ upon abandon(ID) do for step = 1, . . . , 4 do 10: PB-abandon(⟨ID, step⟩) Upon getKey(ID) return key 12: Upon getLock(ID) return lock 13: Upon getCommit(ID) return commit Algorithm 7 Proposal-Promotion with identification I D: Protocol for a sender.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>1 : 2 : σ in ← ⊥ 3 :</head><label>123</label><figDesc>upon promote(ID,⟨v, key⟩) invocation do for step = 1, .., 4 do 4:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>8: upon receiving "id, skip-share, view, ρ" from party p k for the first time in view view do upon receiving "id, View-change, view, ⟨v 2 , σ 2 ⟩, ⟨v 3 , σ 3 ⟩, ⟨v 4 , σ 4 ⟩" do</figDesc><table><row><cell>9:</cell><cell>if share-validate(⟨id, skip, view ⟩, k, ρ) then</cell></row><row><cell>10:</cell><cell>P P skip[view ] ← P P skip[view ] ∪ {ρ }</cell></row><row><cell>11:</cell><cell>if |P P skip[view ]| = n -f then</cell></row><row><cell>12:</cell><cell>σ ← threshold-sign(P P skip[view ])</cell></row><row><cell>13:</cell><cell>send "id, skip, view, σ " to all parties</cell></row><row><cell cols="2">14: upon receiving "id, skip, view, σ " do</cell></row><row><cell>15:</cell><cell>if threshold-validate(⟨id, skip, view ⟩, σ ) = true then</cell></row><row><cell>16:</cell><cell>skip[view ] ← t rue</cell></row><row><cell>17:</cell><cell>if "skip" message was not sent yet in view view then</cell></row><row><cell>18:</cell><cell>send "id, skip, view, σ " to all parties</cell></row><row><cell>19: 20:</cell><cell>leader ← Leader[view ]</cell></row><row><cell>21:</cell><cell>if v 4 ⊥ then</cell></row><row><cell>22:</cell><cell></cell></row><row><cell>23:</cell><cell>decide v 4</cell></row><row><cell>24:</cell><cell></cell></row><row><cell>26:</cell><cell>LOCK ← view</cell></row><row><cell>27:</cell><cell></cell></row></table><note><p><p>if threshold-validate(⟨⟨⟨id, leader, view ⟩, 3⟩, v 4 ⟩, σ 4 ) then if v 3 ⊥ ∧ view &gt; lock then 25: if threshold-validate(⟨⟨⟨id, leader, view ⟩, 2⟩, v 3 ⟩, σ 3 ) then if v 2 ⊥ ∧ view &gt; key .view then 28:</p>if threshold-validate(⟨⟨⟨id, leader, view ⟩, 1⟩, v 2 ⟩, σ 2 ) then 29:</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>while the construction of<ref type="bibr" target="#b27">[28]</ref> requires only O (n</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>) bits given a common coin, the word communication of the resulting binary Byzantine Agreement protocol is dominated by the common random coin protocol that requires threshold signatures and O (n 2 ) word communication.<ref type="bibr" target="#b1">2</ref> Note that this property is much weaker than the one required for strong consensus[20,   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p><ref type="bibr" target="#b29">30]</ref> since parties are allowed to return ⊥.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>Note that although this restriction gives some upper bound on the communication in terms of the adversary local speed, the model is still asynchronous since speeds of different parties are completely unrelated. Session 7 PODC '19, July 29-August 2, 2019, Toronto, ON, Canada</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Called liveness in<ref type="bibr" target="#b10">[11]</ref>, but we find this name confusing since it is not a liveness<ref type="bibr" target="#b2">[3]</ref> property.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>Note that although they do not explicitly define it, the protocol of Cachin et al.<ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> already obtains this Quality property. Session 7 PODC '19, July 29-August 2, 2019, Toronto, ON, Canada</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Note that every instance of a Proposal-Promotion has a unique leader, but here we choose among them one unique leader for each view.Session</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>PODC '19, July 29-August 2, 2019, Toronto, ON, Canada</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Christian Cachin and the anonymous reviewers for their high quality feedback.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A PROVABLE-BROADCAST PROPERTIES</head><p>Provable-Broadcast with identification ID satisfies the following properties except with negligible probability:</p><p>• PB-Integrity: An honest party delivers a message at most once. • PB-Validity: If an honest party p i delivers m, then EX-PB-VAL i (id, m) = true.</p><p>• PB-Abandon-ability: An honest party does not deliver any message after it invokes PB-abandon(ID). Note that an Provable-Broadcast does not guarantee any agreement property, however, when several instances are combined together (e.g., Proposal-Promotion) strong and useful properties can be guaranteed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B LEADER-ELECTION: PROPERTIES AND PSEUDOCODE</head><p>The Leader-Election primitive provides one operation to elect a unique party (called a leader) among the parties. An instance of a leader election primitive is identified via an identification ID, and exposes an operation elect(ID) to all parties, which returns a party p ∈ Π. Formal definitions are given below and the pseudocode appears in Algorithm 8.</p><p>A protocol for leader election associated with id id satisfies the following properties except with negligible probability.</p><p>• Termination: If f + 1 honest parties invoke elect(), and all messages among honest parties arrive, then all invocations by honest parties return. </p><p>send "share, ID, ρ i " to all parties 5:</p><p>return coin-toss(ID, Σ) 7: upon receiving "share, ID, ρ j " from p j for the first time do 8:</p><p>if coin-share-validate(id, j, ρ j ) = true then </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Synchronous byzantine agreement with expected O (1) rounds, expected O (n 2 ) communication, and optimal resilience</title>
		<author>
			<persName><forename type="first">Ittai</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kartik</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ling</forename><surname>Ren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Ittai</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dahlia</forename><surname>Malkhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Spiegelman</surname></persName>
		</author>
		<title level="m">Asymptotically optimal validated asynchronous byzantine agreement</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Defining liveness</title>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Alpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A tight lower bound for randomized synchronous consensus</title>
		<author>
			<persName><forename type="first">Ziv</forename><surname>Bar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ben-Or</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="193" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A modular approach to the design and analysis of authentication and key exchange protocols (extended abstract)</title>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computing, STOC &apos;98</title>
		<meeting>the Thirtieth Annual ACM Symposium on Theory of Computing, STOC &apos;98<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="419" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM conference on Computer and communications security</title>
		<meeting>the 1st ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Another advantage of free choice (extended abstract): Completely asynchronous agreement protocols</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ben-Or</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second Annual ACM Symposium on Principles of Distributed Computing, PODC &apos;83</title>
		<meeting>the Second Annual ACM Symposium on Principles of Distributed Computing, PODC &apos;83</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Resilient-optimal interactive consistency in constant time</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ben</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-Or</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ran</forename><surname>El-Yaniv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="249" to="262" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Asynchronous byzantine agreement protocols</title>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Bracha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Session 7 PODC &apos;19</title>
		<meeting><address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-11">November 1987. July 29-August 2, 2019</date>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="130" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Secure and efficient asynchronous protocols</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Petzold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Random oracles in constantinople: Practical asynchronous byzantine agreement using cryptography</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Blockchain consensus protocols in the wild (keynote talk)</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marko</forename><surname>Vukolic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st International Symposium on Distributed Computing, DISC 2017</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Andréa</surname></persName>
		</editor>
		<editor>
			<persName><surname>Richa</surname></persName>
		</editor>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">October 16-20, 2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast asynchronous byzantine agreement with optimal resilience</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-fifth Annual ACM Symposium on Theory of Computing, STOC &apos;93</title>
		<meeting>the Twenty-fifth Annual ACM Symposium on Theory of Computing, STOC &apos;93<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="42" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Practical byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">Miguel</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barbara</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="173" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Authenticated algorithms for byzantine agreement</title>
		<author>
			<persName><forename type="first">Danny</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Raymond</forename><surname>Strong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="656" to="666" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">BEAT: asynchronous BFT made practical</title>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Sisi Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haibin</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS 2018</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS 2018<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Consensus in the presence of partial synchrony</title>
		<author>
			<persName><forename type="first">Cynthia</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nancy</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="288" to="323" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Optimal algorithms for byzantine agreement</title>
		<author>
			<persName><forename type="first">Paul</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth Annual ACM Symposium on Theory of Computing, STOC &apos;88</title>
		<meeting>the Twentieth Annual ACM Symposium on Theory of Computing, STOC &apos;88<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="148" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Impossibility of distributed consensus with one faulty process</title>
		<author>
			<persName><forename type="first">J</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nancy</forename><forename type="middle">A</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">S</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="374" to="382" />
			<date type="published" when="1985-04">April 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient player-optimal protocols for strong and differential consensus</title>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Fitzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twenty-second annual symposium on Principles of distributed computing</title>
		<meeting>the twenty-second annual symposium on Principles of distributed computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="211" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fast asynchronous byzantine agreement and leader election with full information</title>
		<author>
			<persName><forename type="first">David</forename><surname>Bruce M Kapron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valerie</forename><surname>Kempe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jared</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vishal</forename><surname>Saia</surname></persName>
		</author>
		<author>
			<persName><surname>Sanwalani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Algorithms (TALG)</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">68</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On expected constant-round protocols for byzantine agreement</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chiu-Yuen</forename><surname>Koo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="91" to="112" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Byzantine agreement in polynomial expected time</title>
		<author>
			<persName><forename type="first">Valerie</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jared</forename><surname>Saia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the forty-fifth annual ACM symposium on Theory of computing</title>
		<meeting>the forty-fifth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="401" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The part-time parliament</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Born and raised distributively: Fully distributed non-interactive adaptively-secure threshold signatures with short shares</title>
		<author>
			<persName><forename type="first">Benoît</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moti</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">645</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Combining asynchronous and synchronous byzantine agreement: The best of both worlds</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Loss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Moran</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2018/235" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2018">2018/235. 2018</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The honey badger of BFT protocols</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyle</forename><surname>Croman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Signature-free asynchronous binary byzantine consensus with t &lt; n/3, O (n 2 ) messages, and o(1) expected time</title>
		<author>
			<persName><forename type="first">Achour</forename><surname>Mostéfaoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hamouma</forename><surname>Moumen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Raynal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">31</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Signature-free asynchronous byzantine systems: from multivalued to binary consensus with t &lt; n/3, O (n 2 ) messages, and constant time</title>
		<author>
			<persName><forename type="first">Achour</forename><surname>Mostéfaoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Raynal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Distributed consensus revisited</title>
		<author>
			<persName><forename type="first">Gil</forename><surname>Neiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information processing letters</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="195" to="201" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Reaching agreement in the presence of faults</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shostak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="228" to="234" />
			<date type="published" when="1980-04">April 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Secure agreement protocols: Reliable and atomic group multicast in rampart</title>
		<author>
			<persName><forename type="first">K</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ACM Conference on Computer and Communications Security</title>
		<meeting>the 2nd ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="68" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Practical threshold signatures</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Maofan</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dahlia</forename><surname>Malkhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><surname>Golan Gueta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ittai</forename><surname>Abraham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PODC</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note>HotStuff: BFT consensus in the lens of blockchain</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
