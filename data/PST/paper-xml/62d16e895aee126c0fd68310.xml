<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Domain Specific Run Time Optimization for Software Data Planes</title>
				<funder ref="#_NqMQfmF">
					<orgName type="full">Facebook</orgName>
				</funder>
				<funder ref="#_Mft6A2z">
					<orgName type="full">UK&apos;s EPSRC</orgName>
				</funder>
				<funder ref="#_7fDqKtr">
					<orgName type="full">NK-FIH/OTKA</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sebastiano</forename><surname>Miano</surname></persName>
							<email>s.miano@qmul.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">Queen Mary University</orgName>
								<address>
									<settlement>London London</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alireza</forename><surname>Sanaee</surname></persName>
							<email>a.sanaee@qmul.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="institution">Queen Mary University</orgName>
								<address>
									<settlement>London London</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fulvio</forename><surname>Risso</surname></persName>
							<email>fulvio.risso@polito.it</email>
							<affiliation key="aff2">
								<address>
									<settlement>Politecnico di Torino Turin</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">G?bor</forename><surname>R?tv?ri</surname></persName>
							<email>retvari@tmit.bme.hu</email>
							<affiliation key="aff3">
								<orgName type="department">Economics &amp; Ericsson Research</orgName>
								<orgName type="institution">Budapest University of Technology</orgName>
								<address>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gianni</forename><surname>Antichi</surname></persName>
							<email>g.antichi@qmul.ac.uk</email>
							<affiliation key="aff4">
								<orgName type="institution">Queen Mary University</orgName>
								<address>
									<settlement>London London</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Domain Specific Run Time Optimization for Software Data Planes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3503222.3507769</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:20+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Data Plane Compilation</term>
					<term>LLVM</term>
					<term>eBPF</term>
					<term>XDP</term>
					<term>DPDK</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>State-of-the-art approaches to design, develop and optimize software packet-processing programs are based on static compilation: the compiler's input is a description of the forwarding plane semantics and the output is a binary that can accommodate any control plane configuration or input traffic.</p><p>In this paper, we demonstrate that tracking control plane actions and packet-level traffic dynamics at run time opens up new opportunities for code specialization. We present Morpheus, a system working alongside static compilers that continuously optimizes the targeted networking code. We introduce a number of new techniques, from static code analysis to adaptive code instrumentation, and we implement a toolbox of domain specific optimizations that are not restricted to a specific data plane framework or programming language. We apply Morpheus to several eBPF and DPDK programs including Katran, Facebook's production-grade load balancer. We compare Morpheus against state-of-the-art optimization frameworks and show that it can bring up to 2x throughput improvement, while halving the 99th percentile latency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS CONCEPTS</head><p>? Networks ? Middle boxes / network appliances; Data center networks; End nodes; ? Software and its engineering ? Dynamic compilers; Just-in-time compilers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Software Data Planes, packet processing programs implemented on commodity servers, are widely adopted in real deployments <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b37">39,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b53">55,</ref><ref type="bibr" target="#b76">78,</ref><ref type="bibr" target="#b87">89,</ref><ref type="bibr" target="#b94">96,</ref><ref type="bibr" target="#b95">97]</ref>. Since data plane programs tend to be performance-critical, the code is usually transformed through a sequence of offline optimization steps (e.g., inlining, loop unrolling, branch elimination, or vectorization <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b59">61]</ref>) during the compilation process <ref type="bibr" target="#b39">[41,</ref><ref type="bibr" target="#b57">59]</ref>. These are mainly static transformations, independent of the actual input the code will process in operation, as this is unknown until then <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b28">30]</ref>. Thus, the resulting code is generic, as it contains logic for protocols and features that may never be triggered in a deployment, performs costly memory loads to access values that are only known at run time, and takes difficult-to-predict branches conditioned on variable data.</p><p>Dynamic compilation, in contrast, enables program optimization based on invariant data computed at run time and produces code that is specialized to the input the program is processing <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b28">30,</ref><ref type="bibr" target="#b38">40]</ref>. The idea is to continuously collect run time data about program execution and then re-compile it to improve performance. This is a wellknown practice adopted by generic programming languages (e.g., Java <ref type="bibr" target="#b28">[30]</ref>, JavaScript <ref type="bibr" target="#b38">[40]</ref>, and C/C++ <ref type="bibr" target="#b7">[8]</ref>) and often produces orders of magnitude more efficient code as shown for data-caching services <ref type="bibr" target="#b75">[77]</ref>, data mining <ref type="bibr" target="#b22">[23]</ref> and databases <ref type="bibr" target="#b55">[57,</ref><ref type="bibr" target="#b98">100]</ref>. Unfortunately, this is not the case for packet-processing programs <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b69">71]</ref>, since their performance critically depends on highly dynamic domainspecific knowledge, such as traffic patterns, match-action table content, and network configuration (?2). Obtaining and tracking this knowledge efficiently is extremely challenging: lightweight online tracing tools (e.g., Linux perf <ref type="bibr" target="#b26">[27]</ref>) are restricted to CPU performance counters, whereas capturing all domain-specific information requires tracking packet-level and instruction-level logs which is prohibitively costly. As an example, GCC FDO instrumentation, when applied in this context, may easily incur ~900% mean overhead <ref type="bibr" target="#b54">[56]</ref>. Therefore, existing solutions tailored for the networking domain (Table <ref type="table">2</ref>) resort to offline profiling, which requires operators to collect representative samples of data-plane configuration and match-action tables from production deployments and still completely miss out on dynamic traffic-level insights. The main challenge we tackle in this paper is unsupervised dynamic compilation for network code, which captures just enough domain-specific knowledge to enable efficient dynamic performance optimization, but inexpensive enough to be run online, inside the data plane pipeline. Offline profile-guided optimizer for generic software code. AutoFDO <ref type="bibr" target="#b22">[23]</ref> ? --? Offline profile-guided optimizer for generic software code. eSwitch <ref type="bibr" target="#b69">[71]</ref> ? ? ? ? Policy-driven optimizer for DPDK-based OpenFlow software switches. P5 <ref type="bibr" target="#b5">[6]</ref> ? ? ? ? Policy-driven optimizer for P4/RMT packet-processing pipelines. P2GO <ref type="bibr" target="#b92">[94]</ref> ? ? ? ? Offline profile-guided optimizer for P4/RMT packet-processing pipelines. PacketMill <ref type="bibr" target="#b34">[36]</ref> ? ? ? ? Packet metadata management optimizer for DPDK-based software data planes. NFReducer <ref type="bibr" target="#b29">[31]</ref> ? ? ? ? Policy-driven optimizer for network function virtualization. Morpheus ? ? ? ? Run time compiler and optimizer framework for arbitrary networking code.</p><p>We present Morpheus, a system to optimize network code at run time using domain-specific dynamic optimization techniques. Morpheus operates in unsupervised mode: it does not require any a priori knowledge about control plane configuration or data plane traffic patterns. We discuss its design challenges (?3), such as automatically tracking highly variable input (e.g., inbound traffic) that may change tens, or hundreds of millions times per second. We show that the required profiling and tracing facilities, if implemented carelessly, can easily nullify the performance benefit of code specialization. We introduce several novel techniques; we leverage static code analysis to build an understanding of the program offline and propose a low-overhead adaptive instrumentation mechanism to minimize the amount of data collected online. Then, we invoke several dynamic optimization passes (e.g., dead code elimination, data-structure specialization, just-in-time compilation, and branch injection) to specialize the code against control plane actions and data plane traffic patterns. Finally, we protect the consistency of the specialized code against changes to input that is considered invariant by injecting guards (?4).</p><p>Our implementation exploits the LLVM JIT compiler toolchain to apply the above ideas at the LLVM Intermediate Representation (IR) level in a generic fashion and separates data plane specific code to several backend plugins to minimize the effort in porting Morpheus to a new architecture (?5). The code currently contains an eBPF and a DPDK/C plugin. We apply Morpheus to a number of packet processing programs, including the production-grade L4 load balancer Katran from Facebook, using synthetic and real-world traffic traces (?6). Our results show that Morpheus can improve the performance of the unoptimized (statically compiled) eBPF application up to 94%, while reducing packet-processing latency by up to 123% at the 99th percentile. Applying Morpheus to a DPDK program, we increase performance by up to 469%. Finally, we measured Morpheus against state-of-the-art network code optimization frameworks such as ESwitch <ref type="bibr" target="#b69">[71]</ref> and PacketMill <ref type="bibr" target="#b34">[36]</ref>: we show that Morpheus boosts the throughput by up to 80% and 294%, respectively, compared to existing work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions. In this paper, we:</head><p>? demonstrate that tracking packet-level dynamics opens up new opportunities for network code specialization; ? design and implement Morpheus, a system working with standard compilers to optimize network code at run time;</p><p>? extensively evaluated Morpheus by applying it to two different I/O technologies (i.e., DPDK and eBPF), and a number of programs including production-grade software; ? share the code in open source to foster reproducibility <ref type="bibr" target="#b63">[65]</ref> <ref type="foot" target="#foot_0">1</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE CASE FOR DOMAIN-SPECIFIC OPTIMIZATIONS</head><p>State-of-the-art profile guided optimization tools (PGO), such as Google's AutoFDO <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b46">48]</ref> and Facebook's Bolt <ref type="bibr" target="#b75">[77]</ref>, can dynamically rewrite the targeted code using execution profiles recorded offline; e.g., by simplifying load instructions or reordering basic blocks to speed up the most frequently executed code paths. Fig. <ref type="figure" target="#fig_13">1a</ref> shows the single-core throughout obtained when applying AutoFDO and Bolt combined (PGO) to a sample DPDK firewall application <ref type="bibr" target="#b31">[33]</ref>, which performs basic L2/L3/L4 packet processing followed by a lookup into an access control list (ACL), over a stream of 64-byte packets at 40Gb line rate (see ?6 for the details of the configuration).</p><p>In line with the expectations <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b54">56,</ref><ref type="bibr" target="#b75">77]</ref>, we managed to improve the performance of the targeted code by a mere 4.2%. The behavior of packet-processing code can, however, be deeply influenced by specific metrics (e.g., match-action table access patterns, table sizes and content) that cannot be tracked with generic profiling mechanisms (i.e., Linux perf) used by standard PGO tools. Lacking such domain-specific insight, meaningful only in the packet processing context, generic purpose PGO tools cannot be fully exploited for dynamically optimizing network code <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b34">36,</ref><ref type="bibr" target="#b69">71,</ref><ref type="bibr" target="#b80">82]</ref>.</p><p>To understand the potential of domain-specific optimizations, we present a series of preliminary benchmarks using real network code. We consider two applications: the DPDK sample firewall discussed above and Katran <ref type="bibr" target="#b44">[46]</ref>, Facebook's open-source L4 eBPF/XDP load balancer.</p><p>The promise of policy-driven optimizations. Most data-plane programs are developed as a single monolithic block containing various features that might be activated depending on the specific network configuration in use at any instance of time. For example, many large-scale cloud deployments still run on pure IPv4 and so the hypervisor switches would never have to process IPv6 packets <ref type="bibr" target="#b48">[50]</ref> or adopt a single virtualization technology (VLAN/VxLAN/ GRE/Geneve/GTP) and so switches would never see other encapsulations in operation <ref type="bibr" target="#b53">[55,</ref><ref type="bibr" target="#b74">76]</ref>. This implies that, depending on dynamic input that is unknown at compile time, a huge body of unused code gets assembled into the program, boosting code size and causing excess branch prediction misses, negatively impacting the overall performance <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b60">62,</ref><ref type="bibr" target="#b67">69]</ref>.</p><p>Removing unused code based on run time configuration can have a profound effect on software performance. To show this, we configured our firewall as a TCP signature-based Intrusion Detection System (IDS), with only TCP wildcard rules generated with Class-Bench <ref type="bibr" target="#b91">[93]</ref>. This opens up an opportunity for optimization: all non-TCP packets can bypass the ACL table, avoiding a wasteful lookup. Fig. <ref type="figure" target="#fig_13">1b</ref> shows the run time benefit of this optimization (under the Run time configuration bar) for a synthetic input traffic trace where only about 10% of the packets are UDP. Although around 90% of the traffic still has to undergo an ACL lookup, just avoiding this costly operation for a small percentage of traffic increases performance with about 4.7%, without changing the semantic in any way. In many practical scenarios, like DDoS blocking, security groups <ref type="bibr" target="#b45">[47,</ref><ref type="bibr" target="#b72">74]</ref> or whitelist-based access control, most firewall rules are fully-specified; for instance, in the official Stanford ruleset <ref type="bibr" target="#b52">[54]</ref> on average ~45% of the rules are purely exact-matching. This opens up another dynamic optimization opportunity: add in front of the ACL an exact-matching lookup table to sidestep the costly wildcard lookup. The result in Fig. <ref type="figure" target="#fig_13">1b</ref> (under the Table specialization bar) shows a further ~8% performance improvement with this simple modification.</p><p>A similar effect is visible with the load-balancer (Fig. <ref type="figure" target="#fig_13">1c</ref>): configuring Katran as an HTTP load balancer <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b71">73]</ref> allows to dynamically remove all the branches and code unrelated to IPv4/TCP processing, which reduces the number of instructions by ~58% (as reported by the Linux perf tool), yielding ~17,1% decrease in the number of L1 instruction cache-load misses. Better cache locality then translates into ~12% performance improvement (from 4.09 Mpps to 4.69 Mpps). Takeaway #1: Specializing networking code for slowly changing input, like flow-rules, ACLs and control plane policies, substantially improves the performance of software data planes.</p><p>The need for tracking packet-level dynamics. The potential to optimize code for specific network configurations has been explored in prior work, for OpenFlow <ref type="bibr" target="#b69">[71]</ref>, P4 software <ref type="bibr" target="#b80">[82,</ref><ref type="bibr" target="#b92">94]</ref> and hardware targets <ref type="bibr" target="#b5">[6]</ref>, network functions <ref type="bibr" target="#b29">[31]</ref>, and programmable switches <ref type="bibr" target="#b34">[36]</ref> (see Table <ref type="table" target="#tab_0">1</ref>). In order to maximize performance, however, we need to go beyond specializing the code for relatively stable run time configuration and apply optimizations at the packet level.</p><p>Consider the DPDK firewall application. We installed 1000 wildcard rules and generated highly skewed traffic, so that from the thousand active unique 5-tuple flows only 5% accounts for 95% of the traffic. This opens up the opportunity to inline the match-action logic for the recurring rules. As the results show (Fig. <ref type="figure" target="#fig_13">1b</ref>, under the Fast Path bar), we obtain ~42% performance improvement with this simple traffic-dependent optimization. With the eBPF load balancer the effect is also visible: configuring 10 Virtual IPs (VIP) (both TCP and UDP), each with hundred different back-end servers, a similarly skewed input traffic trace presents the same opportunity to inline code, yielding ~24% performance edge (Fig. <ref type="figure" target="#fig_13">1c</ref>). Takeaway #2: For maximum performance, networking code must be specialized with respect to inbound traffic patterns, despite the potentially daunting packet-level dynamics. We were unable to run PGO on the latter, since existing tools do not support eBPF targets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CHALLENGES</head><p>Static compilation performs optimizations that depend only on compile-time constants: it does not optimize variables whose value is invariant during the execution of the program but remain unknown until then. Dynamic compilation, in contrast, enables specializing the code with respect to invariant run time data <ref type="bibr" target="#b7">[8]</ref>. This opens up a broad toolbox of optimization opportunities, to propagate, fold and inline constants, remove branches and eliminate code never triggered in operation, or even to completely sidestep costly match-action table processing. The unsupervised optimization of networking code, however, presents a number of unique challenges:</p><p>Challenge #1: Low-overhead run time instrumentation. Unsupervised dynamic optimization rests on the assumption that program variables remaining invariant for an extended period of time are promptly detected. This is the job of profiling tools. Although low-overhead solutions exist <ref type="bibr" target="#b26">[27,</ref><ref type="bibr">28,</ref><ref type="bibr" target="#b40">42,</ref><ref type="bibr" target="#b58">60]</ref>, they track high-level code behavior information such as cache events, branch misses or memory accesses which is not enough for packet-processing code (?2). Less lightweight and more accurate tools <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b27">29]</ref>, instead, are not practical to be used at data-plane time scales: recording at run time instruction-level logs for code that processes potentially tens of millions of packets per second can introduce an overhead that makes the subsequent optimization pointless. For example, GCC FDO instrumentation can easily incur ~900% mean overhead <ref type="bibr" target="#b54">[56]</ref>.</p><p>We tackle this challenge in Morpheus by using static code analysis to understand the structure of the program offline (?4.1) and leveraging an adaptive instrumentation mechanism to minimize the amount of data that is collected online (?4.2).</p><p>Challenge #2: Dynamic code generation. Once run time profiling information is available, the dynamic compiler applies domainspecific optimizations to specialize the code for that profile. Here, code generation must integrate seamlessly into the compiler toolchain, to avoid interference with the built-in optimizations. Furthermore, a toolbox of domain-specific optimization passes must be identified, which, when applied to networking code, promise significant speedup (?4.3).</p><p>Challenge #3: Consistency. The dynamically optimized data plane is contingent on the assumption that the data considered Original code invariant during the compilation indeed remains so: any update to such data would immediately invalidate the specialized code. Here, the challenge is to guarantee data plane consistency under any modification to the invariants on which the specialized code relies. We tackle this challenge by injecting guards at critical points in the code that allow the execution to fall back to the generic unoptimized path whenever an invariant changes. Since the performance burden on each packet, possibly taking several guards during its journey, can be taxing, we introduce a guard elision heuristic to sidestep useless guards (?4.3). To do so, our static code analysis tool must have enough understanding of the program to separate stateless from stateful code (?4.3). Finally, mechanisms are needed to atomically update the data plane once the code is re-optimized for the new invariants (?4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>New optimized code</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MORPHEUS COMPILATION PIPELINE</head><p>We designed Morpheus with an ambitious goal: to build a portable dynamic software data plane compilation and optimization toolbox. The system architecture is shown in Fig. <ref type="figure" target="#fig_1">2</ref>. Morpheus accepts the input code at the Intermediate Representation (IR) level. The pipeline is triggered periodically at given time slots to readjust the code for possibly changed traffic patterns and control plane updates. At each invocation, the compiler performs an extensive offline code analysis to understand the program control/data flow (see ?4.1) and then reads a comprehensive set of instrumentation tables to extract run time match-action table access patterns (see ?4.2). Finally, Morpheus invokes a set of dynamic compilation passes to specialize the code (see ?4.3) and then replaces the running data plane with the new, optimized code on the fly (see ?4.4). Below, we review the above steps in more detail. We use the simplified main loop of the Katran XDP/eBPF load balancer <ref type="bibr" target="#b44">[46]</ref> as a running example (see Listing 1). The main loop is invoked by the Linux XDP datapath for each packet. It starts by parsing the L3 (line 4) and the L4 (line 5) header fields, using a special case for QUIC traffic as this is not trivial to identify <ref type="bibr" target="#b56">[58]</ref>. In particular, QUIC flows are marked by a flag stored in the VIP record (line 12); if the flag is set, then a special function is called to deal with the QUIC protocol. Otherwise, a lookup in the connection table (line 17) is done: in case of a match, the ID of the backend assigned to the flow is returned; if no connection tracking information is found, a new backend is allocated and written back to the connection table (line 20). Finally, the IP address of the backend associated with the packet is read from the backend pool (line 24), the packet is encapsulated (line 25) and sent out (line 26).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Code Analysis</head><p>To be able to specialize code, we need to have a good understanding of the possible inputs it may receive during run time. Networking code tends to be fairly simplistic in this regard: commonly, the input consists of the context, which in eBPF/XDP corresponds to the raw packet buffers, and the content of match-action tables named maps in the eBPF world (Listing 1). Since input traffic may be highly variable and provides limited visibility into program operation, Morpheus does not monitor this input directly <ref type="bibr" target="#b6">[7]</ref>. Rather, it relies on tracking the map access patterns and uses this information to indirectly reconstruct aggregate traffic dynamics and identify invariants along frequently taken control flow branches.</p><p>In the first pass, Morpheus uses comprehensive statement-level static code analysis to identify all map access sites in the code, understand whether a particular access is a read or a write operation, and reason about the way the result is used later in the code. In particular, signature-based call site analysis is used to track map lookup and update calls, and then a combination of memory dependency analysis <ref type="bibr" target="#b3">[4]</ref> and alias analysis <ref type="bibr" target="#b2">[3]</ref> is performed to match map lookups to map updates. Maps that are never modified from within the data plane are marked as read-only (RO) and the rest as read-write (RW). Note that RO maps may still be modified from user space, but such control-plane actions tend to occur at a coarser timescale compared to RW maps, which may be updated with each packet. This observation will then allow to apply more aggressive optimizations to stateless code, which interacts only with relatively stable RO maps, and resort to conservative optimization strategies when specializing stateful code, which depend on potentially highly variable RW maps. Running example. Consider the Katran main loop (Listing 1). Morpheus leverages the domain-specific knowledge, provided by the eBPF data-plane plugin (?5.1), to identify map reads by the map.lookup eBPF helper signature and map writes either via map.update calls or a direct pointer dereference. Thus, map backend_pool is marked as RO and conn_table as RW. For vip_map, memory dependency analysis finds an access via a pointer (line 12), but since this conditional statement does not modify the entry and no other alias is found, vip_map is marked as RO as well.</p><p>Table <ref type="table">2</ref>: Dynamic optimizations in Morpheus. Applicability of each optimization depends on the map size, access profile (RO/RW), and availability of instrumentation information. Note that optimizations marked as "traffic-dependent" can also be applied, at least partially, without packet-level information (e.g., small RO maps can always just-in-time compiled). For full efficiency, these passes rely on timely instrumentation information (e.g., to JIT heavy hitters from a large map as a fast-path). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Instrumentation</head><p>In the second pass, Morpheus profiles the dynamics of the input traffic by generating heatmaps of the maps' access patterns, so that the collected statistics can then be used to drive the subsequent optimization passes. Specifically, Morpheus uses a sketch to keep track of map accesses, by storing instrumentation data in a LRU (least-recently-used) cache alongside each map and adapting the sampling rate along several dimensions to control the run time cost of profiling. The dimensions of adaptation are as follows.</p><p>(1) Size: small maps are unconditionally inlined into the code and hence instrumentation is disabled for these maps. ( <ref type="formula">2</ref>) Dynamics: Morpheus does not record each map access, but rather it samples just enough information to reliably detect heavy hitters <ref type="bibr" target="#b33">[35]</ref>. (3) Locality: instrumentation caches are per-CPU and hence track the local traffic conditions at each execution thread separately, i.e., specific to the RSS context. This improves per-core heavy hitter detection in presence of highly asymmetric traffic. (4) Scope: after identifying heavy hitters in the CPU context, local instrumentation caches are run together to identify global heavy hitters. ( <ref type="formula">5</ref>) Context: if a map is accessed from multiple call sites then each one is instrumented separately, so that profiling information is specific to the calling context. ( <ref type="formula">6</ref>) Application-specific insight: the operator can manually disable instrumentation for a map if it is clear from operational context that access patterns prohibit any traffic-dependent optimization (see Table <ref type="table">2</ref>). Traffic-independent optimizations are still applied by Morpheus in such cases.</p><p>Running example. Consider the vip_map in our sample program, identified as an RO map in the first pass. In addition, suppose that there are hundreds of VIPs associated with TCP services stored in the vip_map and only a single one is running QUIC, but the QUIC service receives the vast majority of run time hits. Then, instrumentation will identify the QUIC VIP as a heavy hitter and Morpheus will seize the opportunity to specialize the subsequent QUIC call-path explicitly. Note that this comes without direct traffic monitoring, only using indirect traffic-specific instrumentation information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Optimization Passes</head><p>The third step of the compilation pipeline is where all online code transformations are applied. Before deploying any code transformation, Morpheus has to protect the consistency of the new specialized code against changes to the invariants the optimizations depend on. To do this, Morpheus uses guards, a standard mechanism used by dynamic compilers to guarantee code consistency by injecting simple run time version checks at specific points in the code <ref type="bibr" target="#b43">[45]</ref>.</p><p>When the control flow reaches a guard, it atomically checks if the version of the guard is the same as the version of the optimized code; if yes, execution jumps to the optimized version, otherwise it falls back to the original code (?deoptimization?). Below, we describe all the various run time optimizations currently applied by Morpheus; see Table <ref type="table">2</ref> for a summary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Just-in-Time Compilation (JIT). Empirical evidence (see ?2)</head><p>suggests that table lookup is a particularly taxing operation for software data planes. This is because certain match-action table types (e.g., LPM or wildcard), that are relatively simple in hardware, are notoriously expensive to implement in software <ref type="bibr" target="#b35">[37]</ref>. Therefore, Morpheus specializes tables at run time with respect to their content and dynamic access patterns, as learned in the instrumentation pass. Specifically, empty maps are completely removed, small maps are unconditionally just-in-time (JIT) compiled into equivalent code, and larger maps are preceded by a similar JIT compiled fast-path cache, which is in charge of handling the heavy hitters. Note that the consistency of the the fast-path cache must be carefully protected against potential changes made to the specialized map entries; Morpheus places guards into the code to ensure this (see later). Running example. Consider again Listing 1 and suppose that there are only two VIPs configured in the vip_map. Being an exactmatching hash it is trivial to compile the vip_map into an ?if-thenelse? statement, representing each distinct map key as a separate branch. To do so, Morpheus uses the insights from the code analysis phase to discover that relevant fields in the lookup are the destination address (pkt.dstIP), port (pkt.dstPort) and the IP protocol (pkt.proto). Then, for each entry in the map, it builds a separate ?if? conditional to compare the entry's fields against the relevant packet header fields and chains these with ?else? blocks. Since the instrumentation and the just-in-time compiled map are specific to unique combinations of destination address/port and protocol, the lookup semantics is correctly preserved even for longest prefix matching (LPM) caches and wildcard lookup. makes it possible to propagate these constants to the surrounding code so to inline memory accesses. In Morpheus, constant propagation opportunistically extends to larger maps that cannot be wholly just-in-time compiled: if a certain table field is found to be constant across all entries, then it is also inlined into the surrounding code. This optimization is thereby two-faceted: it can be used to specialize the code with respect to the inbound traffic (traffic-dependent, former case) but can also be applied without packet-level information (traffic-independent, the latter case). Morpheus does not implement constant propagation itself; rather, it relies on the underlying compiler toolchain to perform this pass. Running example. Suppose there are only two backends in the backend_pool. Here, the map lookup (line 24) is rewritten into an ?if-then-else? statement, with two branches for each backend. Correspondingly, in each branch the value of the backend variable is constant, which allows to save the costly memory dereference backend-&gt;ip (line 25) by inlining the backend IP address right into the specialized code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Dead Code Elimination.</head><p>Depending on the specific configuration, a large portion of code may sit unused in memory at any point in time. Such ?dead code? can be found using a combination of static code analysis and the instrumentation information obtained from the previous pass. Upon detection, Morpheus removes all dead code on the optimized code path. As previously, this operation is outsourced to the compiler. Running example. Consider the vip_map lookup site (line 10) and suppose that there are no QUIC services configured. As a consequence, the vip_info-&gt;flags is identical across all the entries in the vip_map and the constant propagation pass inlines this constant into the subsequent conditional (line 10). Thus, the condition vip_info-&gt;flags &amp; F_QUIC_VIP always evaluates to false and the subsequent branch can be safely removed. Handling updates within the data plane. The optimized datapath must be protected from data-plane updates as well, which requires an explicit guard at all access sites for RW maps. If the guard tests valid then a query is made into the just-in-time compiled fast-path map cache and, on cache hit, the result is used in the subsequent code. Once a modification is made to the map from inside the data plane, the guard is invalidated and map lookup falls back to the original map.</p><p>Fig. <ref type="figure">3</ref> presents a breakdown of the strategies Morpheus uses to protect the consistency of optimized code. For RW maps (Fig. <ref type="figure">3a</ref>), first an instrumentation cache is inlined at the access sites, followed by a guard that protects the just-in-time compiled fast-path against data-plane updates. Note that the constant propagation and dead code elimination passes are suppressed, since these passes may modify the code after the map lookup and the guard does not protect these optimizations. In contrast, RO map lookups (Fig. <ref type="figure">3b</ref> and Fig. <ref type="figure">3c</ref>) elide the guard, because only control-plane updates could invalidate the optimizations in this case but these are covered by the program-level guard. RO maps are specialized more aggressively than RW maps, by enabling all optimization passes. Finally, additional overhead can be shaved off for small RO tables by removing the fall-back map all together (Fig. <ref type="figure" target="#fig_3">4c</ref>). Running example. Once static code analysis confirms that the vip_map and backend_pool maps are RO, Morpheus opportunistically eliminates the corresponding guards at the call site. This then implies that, as long as the VIPs and the backend pool are invariant, the optimized code elides the guard. Since the conn_table map is RW, it is protected with a specific guard at the call site (line 17). Thus, the specialized map is used only as long as the connection tracking module's state remains constant; once a new flow is introduced into conn_table (line 20) the specialized code is immediately invalidated by bumping the data-plane version. This does not invalidate all optimizations: as long as the rest of the (RO) maps are not updated by the control plane, the program-level guard remains valid and the corresponding RO map specializations still apply.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Update</head><p>Upon invocation, Morpheus executes the above passes to create the optimized datapath and uses the native compiler toolchain to transform the optimized code to target native code. Meanwhile, control plane updates are temporarily queued without being processed. This allows the ?old? code to process packets without any disruption while the optimization takes place. Once compilation is finished, the optimized code is injected into the data path, the program-level guard is updated <ref type="bibr" target="#b41">[43]</ref> and the outstanding table updates are executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION</head><p>Morpheus is implemented in about 6000 lines of C++ code and it is openly available at https://github.com/Morpheus-compiler/ Morpheus, with the artifacts archived on Zenodo <ref type="bibr" target="#b63">[65]</ref>. The code is separated into a data plane independent portable core, containing the compiler passes, and technology-specific plugins to interact with the underlying technology (i.e., eBPF, DPDK).</p><p>The Morpheus core extends the LLVM <ref type="bibr" target="#b57">[59]</ref> compiler toolchain (v10.0.1) for code manipulation and run time code generation. We opted to implement Morpheus at the intermediate representation (IR) level as it allows to reason about the running code using a relatively high-level language framework without compromising on code generation time. Moreover, this also makes the Morpheus core portable across different data plane frameworks and programming languages <ref type="bibr" target="#b86">[88]</ref>.</p><p>The data plane plugins are abstracted via a backend API. This API exports a set of functions for the core to identify match-action table access sites based on data-plane specific call signatures; compute cost functions for data structure specialization; rewrite data plane dependent code using templates; and provide an interface to inject guards. Additionally, the backend can channel instrumentation data from the data plane to the compiler core, implement the data plane dependent parts of the pipeline update mechanism, and provide a mechanism for the Morpheus core to intercept, inspect, and queue any update made by the control plane. The latter allows the compilation pipeline to be triggered when Morpheus intercepts a control plane event, e.g., an update to a table. Currently, only eBPF (fully) and DPDK (partially) are supported, but the architecture is generic enough to be extended to essentially any I/O framework, like netmap <ref type="bibr" target="#b82">[84]</ref> or AF_XDP <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The eBPF Plugin</head><p>Morpheus leverages the Polycube <ref type="bibr" target="#b66">[68]</ref> framework as an eBPF backend to manage chains of in-kernel packet processing programs. Polycube readily delivers almost all the needed components for an eBPF backend. We added a mechanism for updating the data plane program on-the-fly and defined templates to inject guards. We discuss these components next. Pipeline update. Once the optimized program is built, Morpheus calls the eBPF LLVM backend to generate the final eBPF native code, loads the new program into the kernel using the bpf() system call, and directs execution to the new code. In Polycube, a generic data plane program is usually realized as a chain of small eBPF programs connected via the eBPF tail-call mechanism, using a BPF_PROG_ARRAY map to get the address of the entry point of the next eBPF program to execute. Thus, injecting a new version of an eBPF program boils down to atomically update the BPF_PROG_-ARRAY map entry pointing to it with the address of the new code. Guards. Morpheus relies on guards to protect the specialized code against map updates. The program-level guard is implemented as a simple run time version check <ref type="bibr" target="#b41">[43]</ref>. For stateful processing, Morpheus installs a guard at each map lookup site and injects a guard update pre-handler at the instruction address corresponding to the map update eBPF function (map_update_elem). This handler will then safely invalidate the guard before executing the map update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The DPDK Plugin</head><p>Morpheus leverages FastClick <ref type="bibr" target="#b13">[14]</ref>, a framework to manage packetprocessing applications based on DPDK. FastClick makes implementing most components of the backend API trivial; below we report only on pipeline updates and guards. Pipeline update. A FastClick program is assembled from primitive network functions, called elements, connected into a dataflow graph. Every FastClick element holds a pointer to the next element along the processing chain. To switch between different element implementations at run time, Morpheus adds a level of indirection to the FastClick pipeline: every time an element would pass execution to the next one, the corresponding function call is conveyed through a trampoline, which stores the real address of the next element to be called. Then, atomic pipeline update simplifies into rewriting the corresponding trampoline to the address of the new code. In contrast to eBPF, which explicitly externalizes into separate maps all program data intended to survive a single packet's context, a FastClick element can hold non-trivial internal state, which would need to be tediously copied into the new element. As a workaround, our DPDK plugin disables dynamic optimizations for stateful FastClick elements. Guards. Since stateful FastClick elements are never optimized in Morpheus and RO elements always elide the guard, our DPDK plugin currently does not implement guards, except a programlevel version check at the entry point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATION</head><p>Our testbed includes two servers connected back-to-back with a dual-port Intel XL710 40Gbps NIC. The first, a 2x10-core Intel Xeon Silver 4210R CPU @2.40GHz with support for Intel's Data Direct I/O (DDIO) <ref type="bibr" target="#b0">[1]</ref> and 27.5 MB of L3 cache, runs the various applications under consideration. The second, a 2x10 Intel Xeon Silver 4114 CPU @2.20GHz with 13.75MB of L3 cache, is used as packet generator. Both servers are installed with Ubuntu 20.04.2, with the former running kernel 5.10.9 and the latter kernel 4.15.0-112. We also configured the NIC Receive-Side Scaling (RSS) to redirect all flows to a single receive queue, forcing the applications to be executed on a single CPU core, while Morpheus was pinned to another CPU core on the device-under-test (DUT).</p><p>In our tests, we used pktgen <ref type="bibr" target="#b30">[32]</ref> with DPDK v20.11.0 to generate traffic and report the throughput results, and the DPDK burst replay tool <ref type="bibr" target="#b81">[83]</ref> to replay the different packet traces. Unless otherwise stated, we report the average single-core throughput across five different runs of each benchmark, measured at the minimum packet size (64-bytes). For latency tests, we used Moongen <ref type="bibr" target="#b32">[34]</ref> to estimate the round-trip-time of a packet from the generator to the DUT and back. Finally, we used perf v5.10 to characterize the microarchitectural metrics of the DUT (e.g., cache misses, cycles, number of instructions).</p><p>In order to benchmark Morpheus on real applications, we chose four eBPF/XDP-based packet processing programs from the opensource eBPF/XDP reference network function virtualization framework Polycube <ref type="bibr" target="#b68">[70]</ref>, plus Facebook's Katran load-balancer used earlier as a running example <ref type="bibr" target="#b44">[46]</ref>.</p><p>The L2 switch, the Router and the NAT applications were taken from Polycube <ref type="bibr" target="#b68">[70]</ref>. The L2 switch use case is a functional Ethernet switch supporting 802.1Q VLAN and STP, with STP and flooding delegated to the control plane while learning and forwarding implemented entirely in eBPF, using an exact-matching MAC table supporting up to 4K entries. The Router use case implements a standard IP router, with RFC-1812 header checks, next-hop processing and checksum rewriting, configured with an LPM table taken from the Stanford routing tables <ref type="bibr" target="#b52">[54]</ref>. The NAT is an eBPF re-implementation of the corresponding Linux Netfilter application, configured with a single two-way SNAT/masquerading rule: the source IP of every packet is replaced with the IP of the outgoing NAT port and a separate L4 source port is allocated for each new flow. BPF-iptables is an eBPF/XDP clone <ref type="bibr" target="#b65">[67]</ref> of the well-known Linux iptables framework, configured with 5-tuple rules generated by Classbench <ref type="bibr" target="#b91">[93]</ref>. We used the Classbench trace generator <ref type="bibr" target="#b90">[92]</ref>   to generate packets matching the created rule set using a Pareto cumulative density function to control the locality of reference. We used the same default parameters suggested by the ClassBench paper <ref type="bibr" target="#b91">[93]</ref> to generate traces of varying locality, in particular the no-locality trace uses ? = 1, ? = 0 as Pareto parameters, the low locality uses ? = 1, ? = 0.0001, and the high locality uses ? = 1, ? = 1. Finally, Katran <ref type="bibr" target="#b44">[46]</ref> was configured as a web-frontend, with 10 TCP services/VIPs and 100 backend servers for each VIP.</p><p>For each benchmark, we generated 3 traffic traces with varying locality, to demonstrate the ability of Morpheus to track packetlevel dynamics and optimize the programs accordingly. In particular, we created a high-locality traffic trace, where few flows account for most of the traffic, a no-locality trace with flows generated at random by a uniform distribution and a low-locality trace that sits in the middle between the two previous cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Benefits of Optimizations</head><p>We first show the impact of Morpheus on the mentioned programs, when attached to the XDP hook of the ingress interface.</p><p>Morpheus improves packet-processing throughput. In Fig. <ref type="figure" target="#fig_3">4</ref>, we show the impact of Morpheus under different traffic conditions. Throughput is defined as the maximum packet-rate sustained by a program without experiencing packet loss. When a small subset of flows sends the majority of traffic (high-locality), Morpheus consistently provides more than 50% throughput improvement over the baseline, with a 2? speed-up for the Router. This is because it can track heavy flows and optimize the code accordingly. To confirm the benefit of packet-level optimizations in Morpheus, we compared it to a faithful eBPF/XDP re-implementation of ESwitch, a dynamic compiler that does not consider traffic dynamics <ref type="bibr" target="#b69">[71]</ref>. The results <ref type="bibr">(Fig 4)</ref> show that Morpheus delivers 5?10? the improvement compared to ESwitch for high-locality traces, while it falls back to ESwitch for uniform traffic.</p><p>Morpheus benefits at the micro-architectural scale. In Fig. <ref type="figure" target="#fig_4">5</ref>, we show that Morpheus reduces the last-level CPU cache misses by up to 96% and halves the instructions and branches executed per packet. At low or no traffic locality, the effects of packet-level optimizations diminish, but Morpheus can still bring considerable performance improvement: we see ? 30% margin for BPF-iptables even for the no-locality trace. This is because the optimization passes in Morpheus are carefully selected to be applicable independently from packet-level dynamics (see Table <ref type="table">2</ref>).</p><p>Morpheus reduces packet-processing latency. In Fig. <ref type="figure" target="#fig_5">6</ref>, we compared the 99th percentile baseline latency for each application against the one obtained with Morpheus, both in a best-case scenario when all packets travel through the optimized code path (e.g., the right branch in Fig. <ref type="figure">3a</ref>), and a worst-case scenario with all packets falling back to the default branch instead of taking the fast-patch cache for each map (the left branch in Fig. <ref type="figure">3a</ref>). The left panel in Fig. <ref type="figure" target="#fig_5">6</ref> shows the latency measured at low packet rate (10pps) so to avoid queuing effects <ref type="bibr" target="#b16">[17]</ref>, whereas the right panel shows latency under the maximum sustained load without packet drops <ref type="bibr" target="#b17">[18]</ref>. First, we observe that Morpheus never increases latency, despite the considerable additional logic it injects dynamically into the code (guards, instrumentation; see below); in fact, it generally reduces it even in the worst case scenario. Notably, it reduces Katran's packet-processing latency by about 123%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">What Is the Cost of Code Instrumentation?</head><p>Clearly, the price for performance improvements is the additional logic, most prominently, instrumentation, injected by Morpheus  into the fast packet-processing path. To understand this price, we compared our adaptive instrumentation scheme (?4.2) against a naive approach where all map lookups are explicitly recorded. Fig. <ref type="figure" target="#fig_6">7</ref> shows that instrumentation involves visible overhead: the instrumented code performs worse than the baseline. The naive approach imposes a hefty 14?23% overhead, but adaptive instrumentation reduces this to just 0.9%?9%. Most importantly, this reduction does not come at a prohibitive cost: adaptive instrumentation provides enough insight to Morpheus to make up for the performance penalty imposed by it and still attain a considerable throughput improvement on top (see the green stacked barplots).</p><p>In contrast, the performance tax of naive instrumentation may very well nullify optimization benefits, even despite full visibility into run time dynamics (e.g., for the L2 switch or Katran). We also studied the impact of packet sampling rate on instrumentation. Indeed, Morpheus collects information on packet-level dynamics only on a subset of input traffic in order to minimize the overhead. Fig. <ref type="figure" target="#fig_7">8</ref> highlights that Morpheus can strike a balance between overhead and efficiency by adapting the sampling rate. At a low sampling rate (e.g., recording every 100th packet) Morpheus does not have enough visibility into dynamics, which renders trafficdependent optimizations less effective (but the traffic-invariant optimizations still apply). Higher sampling rates provide better visibility but also impose higher overhead. At the extreme (BPF-iptables, 100% instrumentation rate), optimization is just enough to offset the price of instrumentation. In conclusion, we found that setting the sampling rate at 5%?25% represents the best compromise. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">How Fast Is the Compilation?</head><p>In Table <ref type="table" target="#tab_5">3</ref>, we indicate with t 1 the time to analyze, instrument and optimize the LLVM IR code, and with t 2 the time to generate the final eBPF code, starting from the LLVM IR. Note that t 1 is highly dependent on table size: the bigger the table, the more time needed to read and analyze it. We show the results for high-locality and nolocality traffic. The former is the best case since Morpheus needs to track fewer flows, thus requiring lighter instrumentation tables that are faster to analyze. The latter is the worst case. Generally, table read time (i.e., t 1 ) dominates over compilation time, consistently staying below 100ms and reaching only for Katran in the worst-case scenario almost 600ms. This is because Katran uses huge static maps with tens of thousands of entries to implement consistent hashing.</p><p>Recent advances in the Linux kernel allow to read maps in batches, which would cut down this time by as much as 80% <ref type="bibr" target="#b96">[98]</ref>, reducing recompilation time for Katran below 100ms. Furthermore, the time needed to inject the optimized datapath into the kernel depends on the complexity of the program, since all eBPF code must pass the in-kernel verifier for a safety check before being activated. This also ensures that a mistaken Morpheus optimization pass will never break the data plane. In our tests, injection time varies between 0.5 to 3.4ms in the best case and at most 6.1ms in the worst case.</p><p>Finally, in all the tests we run the Morpheus compilation pipeline on a separate core with respect to the data plane application, and we noticed that in most of the case it consumes, on average, ~5% of CPU, with a peak of 15% for applications that consist of a pipeline of multiple programs chained together (e.g., BPF-iptables) and with lot of table entries to be analyzed (e.g., Katran).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Morpheus in Action</head><p>To test the ability of Morpheus to track highly dynamic inputs, we fed the Router application with time-varying traffic and observed the throughput over the time (Fig. <ref type="figure" target="#fig_8">9a</ref>). Recompilation period was conservatively set to 1 second. In the first 5 seconds we generate uniform traffic; here, the traffic-independent optimizations applied by Morpheus yield roughly 15% performance improvement over the baseline. At the 5th second, the traffic changes to a high-locality profile: after a quick learning period Morpheus specializes the code, essentially the throughput. We see the same effect from the 10th second, when we switch to another high-locality trace with a new set of heavy-hitters: after a brief training period Morpheus   dynamically adapts the optimized datapath to the new profile and attains 60?100% performance improvement. We also repeated the same test using a real-world traffic trace (CAIDA 2019 dataset, equinix-nyc <ref type="bibr" target="#b21">[22]</ref>), counting 30M packets with an average size of 910B. The trace experiences also a low degree of traffic locality, with the most hit entry matched around 0.4% overall. In Figure <ref type="figure" target="#fig_8">9b</ref>, we show how Morpheus consistently improves the throughput of the router by factor of ~10%.</p><p>Finally, in Figure <ref type="figure" target="#fig_10">10</ref>, we report the multi-core scaling of Morpheus. Here, we still used the router when processing input traffic characterized by low-locality. The constant performance increase is enabled mainly by our adaptive instrumentation mechanism, which is able to track the flow states across the different cores, i.e., specific to the RSS context and, depending on their distribution optimize the code accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">What Can Go Wrong?</head><p>The flip side of dynamic optimization is the potential for a misguided run time code transformation to harm performance. With generic languages this can happen when the dynamic compiler steals CPU cycles from the running code <ref type="bibr" target="#b28">[30,</ref><ref type="bibr" target="#b88">90]</ref>; in such cases careful manual compiler parameter tuning and deep application-specific knowledge is needed to make up for the lost performance <ref type="bibr" target="#b73">[75]</ref>. Similar issues may arise with dynamically optimizing network code, as we show below on the NAT use case <ref type="bibr" target="#b68">[70]</ref>. The NAT is organized as a single large connection tracking table, updated from within the data plane on each new flow. This represents a worst-case scenario for Morpheus: fully stateful code, so that guards cannot be opportunistically elided, coupled with potentially high traffic dynamics. Yet, since traffic-independent optimizations can still be applied (Table <ref type="table">2</ref>) Morpheus can improve throughput by around 5% (from 4.36 to 4.58  Mpps) in the presence of high-locality traffic. However, for lowlocality traffic we see about 6% performance degradation compared to the baseline. Intuitively, Morpheus just keeps on recompiling the conntrack fast-path with another set of potential heavy hitters, just to immediately remove this optimization as a new flow arrives. Our tests mark micro-architectural reasons behind this: the number of branch misses and instruction cache loads increases by 90% and 75%, respectively, both clear symptoms of frequent code changes. The rest of the stateful applications (L2 switch and Katran) exhibit a similar pattern, but the speed-up enabled by dead code elimination, constant propagation and branch-injection can make up for this. As with Java, such cases require human intervention; manually disabling optimization for the connection tracking module's table safely eliminates the performance degradation on the NAT use case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Morpheus with DPDK Programs</head><p>We applied Morpheus to a DPDK program, the FastClick <ref type="bibr" target="#b13">[14]</ref> version of the eBPF Router application, the same one used in Pack-etMill's paper <ref type="bibr" target="#b34">[36]</ref>. We configured it with either 20 or 500 rules from the Stanford routing tables <ref type="bibr" target="#b52">[54]</ref> and generated traffic with different levels of locality. We compared the throughput and the latency of the baseline code, the Morpheus optimized and its version transformed with PacketMill, state-of-the-art DPDK packetprocessing optimizer. In our tests PacketMill uses the following optimizations: removing virtual function calls, inlining variables, and allocating/defining the elements' objects in the source code. Fig. <ref type="figure" target="#fig_13">11a</ref> reports the average throughput results. For only 20 prefix rules and with low locality traffic, PacketMill outperforms Morpheus by about 9%, whereas for high-locality traffic and larger forwarding tables Morpheus produces a whopping 469% improvement over PacketMill. The reason for the large performance drop from 20 rules to 500 rules is that LPM lookup is particularly expensive in FastClick (linear search), but Morpheus can largely avoid this costly lookup by inlining heavy hitters. The 99th percentile latency results (Fig. <ref type="figure" target="#fig_13">11b</ref>) confirm this finding, with Morpheus decreasing latency 5-fold compared to PacketMill with high-locality traffic.</p><p>On the other hand, the reason for the lower performance of Morpheus in the low/no locality case (20 rules) can be found in the main difference between the two systems. First, Morpheus requires instrumentation to track table access patters, which produces some run time overhead, while PacketMill does not apply online optimizations and so it does not need instrumentation at all. Second, PacketMill implements some optimizations that Morpheus does not (although nothing prevents us from implementing them), but in most cases the effect of these additional optimizations is masked by the speedup brought by the Morpheus traffic-level optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSIONS</head><p>Add other optimizations to Morpheus compilation pipeline. Morpheus is orthogonal to most optimizations proposed in recent literature and can be extended to support them. For example, Pack-etMill optimizations <ref type="bibr" target="#b34">[36]</ref>, such as the reordering of metadata fields, could be easily integrated into Morpheus with the added benefit that, having access to the number of accesses to a given variable thanks to Morpheus's instrumentation, we could obtain a more accurate reordering compared to PacketMill, which only estimates access patterns. Finally, traditional PGO optimizations can be used with Morpheus too, allowing the compiler to optimize the code on-the-fly, as opposed to traditional PGO approaches where the profile is collected offline. Extend Morpheus to other data plane technologies. Morpheus comprises a data plane-independent core implementing the bulk of the optimization passes, and separate data plane-specific plugins. This makes it relatively easy to port Morpheus to new dataplanes that use well defined APIs (e.g, for table lookups or packet reception). This is the case of eBPF/XDP and DPDK FastClick, but any data plane with a clear API can be potentially used with Morpheus. To do this, the developer would need to write a new data plane plugin, providing the function signatures for the relevant API calls as well as some simple operators for Morpheus to read match-action table content and manipulate the underlying code (e.g., inject a guard). The choice of working at the IR level. In Morpheus, all the optimizations are directly applied at the LLVM IR level. A major drawback of this approach is that by doing so we lose direct access to the low-level machine code, making certain optimizations impossible: peephole, vectorization/SIMD, or other micro-architectural optimizations <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr" target="#b89">91,</ref><ref type="bibr" target="#b97">99]</ref>. Nevertheless, this choice provides also a series of benefits: (i) IR code is in the Static Single Assignment (SSA) form and SSA simplifies the use of different compiler optimization algorithms; (ii) Morpheus optimization passes can exploit flow information performed in the compiler itself to gather information about the code under consideration: for instance, we use LLVM MemorySSA analysis to retrieve information about variable and load/store dependencies; (iii) working at the IR level allows Morpheus to re-use part of the other optimizations already available in the compiler suite; (iv) finally, it allows to keep the optimization passes as generic as possible with respect to the language in which the data plane is written. It is not all about table lookups. Morpheus heavily optimizes also the code surrounding the table lookups using the insights it obtains during code analysis. It separates table lookup code into a fast-path, with the lookup results specialized for the heavy hitters, and a generic slow-path. It uses the table lookup code to also gather information about the table's content, and how it is used in the rest of the code. This allows for optimizing the entire fast-path code after the table lookup without affecting the slow path in any way. For example, constants are folded from the JITted lookup code (effectively a set of nested if-then-else statements) into the surrounding code (i.e., each branch of the if-then-else is specific to a certain value of the conditional), unreachable code is removed or tables are specialized depending on their run time entries.</p><p>Because of this, caching/JITting table lookups is just one, albeit very important, optimization that Morpheus performs. As shown in Figure <ref type="figure" target="#fig_3">4</ref>, the results with the ?no locality? trace demonstrate the combined benefits of all the optimizations that are independent from the input traffic, such as dead code elimination, constant propagation and data structure specialization, while the rest of the cases (?low/high-locality?) show the additional effect of trafficdependent optimizations. Note that some optimizations cannot be directly measured since they are the results of a combination of other passes; e.g., the contribution of dead code elimination is dependent on constant propagation. Morpheus dependence on compilation periodicity. The performance of Morpheus depend on how fast Morpheus can recompile the targeted code (see Table <ref type="table" target="#tab_5">3</ref>). In the presence of traffic changes that are faster than that, then traffic-dependent optimizations become less effective. Nevertheless, Morpheus can still speedup the original function, since other traffic-independent optimizations are still valid (Figure <ref type="figure" target="#fig_3">4</ref>). Potentially, we could disable traffic-level optimizations when Morpheus discovers highly variable traffic that goes under the recompilation period (Section 6.5); this would reduce the impact of guards and instrumentation and increase the benefits of traffic-independent optimizations. Examining these techniques remains as future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RELATED WORK</head><p>Generic code optimization has a long-standing stream of research and prototypes <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr" target="#b70">72,</ref><ref type="bibr" target="#b75">77,</ref><ref type="bibr" target="#b78">80,</ref><ref type="bibr" target="#b83">85]</ref>. In the context of networking, domain-specific data-plane optimization has also gained substantial interest lately.</p><p>Static optimization of data-plane programs. Several packet I/O frameworks present specific APIs for developers to optimize network code <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b76">78]</ref>, or implement different paradigms to efficiently execute packet-processing programs sequentially or in parallel <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b50">52,</ref><ref type="bibr" target="#b60">62,</ref><ref type="bibr" target="#b62">64,</ref><ref type="bibr" target="#b84">86,</ref><ref type="bibr" target="#b89">91,</ref><ref type="bibr" target="#b97">99]</ref>. Other proposals aim to remove redundant logic or merge different elements together <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b51">53,</ref><ref type="bibr" target="#b85">87]</ref>. These works provide static optimizations; Morpheus, on top of these, also considers run time insight to specialize generic network code.</p><p>Dynamic optimization of packet-processing programs. ESwitch <ref type="bibr" target="#b69">[71,</ref><ref type="bibr" target="#b80">82]</ref> was the first functional framework for the unsupervised dynamic optimization of software data planes with respect to the packet-processing program, specified in OpenFlow, being executed. PacketMill <ref type="bibr" target="#b34">[36]</ref> and NFReducer <ref type="bibr" target="#b29">[31]</ref> leverage the LLVM toolchain <ref type="bibr" target="#b57">[59]</ref> instead of OpenFlow: PacketMill targets the FastClick datapath by exploiting the DPDK packet I/O framework and NFReducer aims to eliminate redundant logic from generic packet processing programs using symbolic execution. Morpheus is strictly complementary to these works: (1) it applies some of the same optimizations but it also introduces a toolbox of new ones (e.g., branch injection or constant propagation for stable table entries);</p><p>(2) Morpheus can detect packet-level dynamics and apply more aggressive optimizations depending on the specific traffic patterns; and (3) Morpheus is data-plane agnostic, in that it performs the optimizations at the IR-level using a portable compiler core and relies on the built-in compiler toolchain to generate machine code and a data-plane plugin to inject it into the datapath.</p><p>Profile-guided optimization for packet-processing hardware. P2GO <ref type="bibr" target="#b92">[94]</ref> and P5 <ref type="bibr" target="#b5">[6]</ref> apply several profile-driven optimizations to improve the resource utilization of programmable P4 hardware targets. Some of the ideas presented in this work can also be used with programmable P4 hardware, provided it is possible to re-synthesize the packet processing pipeline without traffic disruption, with a notable difference: P2GO and P5 require a priori knowledge (i.e., the profiles) while Morpheus aims at unsupervised dynamic optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSIONS &amp; FUTURE WORK</head><p>We presented Morpheus, a run time compiler and optimizer framework for arbitrary networking code. We demonstrated the importance of tracking packet-level dynamics and how they open up opportunities for a number of domain-specific optimizations. We proposed a solution, Morpheus, capable of applying them without any a priori information on the running program and implemented on top of the LLVM JIT compiler toolchain at the IR level. This allows decouple our system from the specific framework used by the underlying data plane as much as possible. Finally, we demonstrated the effectiveness of Morpheus on a number of programs written in eBPF and DPDK and released the code in open-source to foster reproducibility of our results.</p><p>We consider Morpheus only as a first step towards more intelligent systems that can adapt to network conditions. As future work, we intend to integrate a run time performance prediction model <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b61">63,</ref><ref type="bibr" target="#b77">79,</ref><ref type="bibr" target="#b79">81]</ref> into Morpheus, enabling the compiler to reason about the effect of each different dynamic optimization pass. This would allow for selecting the most efficient subset of optimizations and adapt the recompilation timescales to the current network conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A ARTIFACT APPENDIX A.1 Abstract</head><p>Morpheus is a system working alongside static compilers that continuously optimizes the targeted networking code. It introduces a number of new techniques to manipulate the code on-the-fly depending on runtime traffic patterns and control plane configurations. The Morpheus core exploits the LLVM compiler toolchain for code manipulation and run-time code generation. It works at the intermediate representation (IR) level as it allows to reason about the running code using a relatively high-level language framework without compromising on code generation time.</p><p>Our paper's artifact contains the source code, the experimental workflow, and additional information to (i) compile and build Morpheus, (ii) install the software dependencies and setup the testbed to run all the experiments, (iii) the scripts that can be used to perform some of the experiments presented in the paper, and (iv) the scripts to generate the plots based on the obtained results.</p><p>A.2 Artifact Check-list (Meta-information)  <ref type="bibr" target="#b64">[66]</ref> that optimizes the target program at runtime. This artifact produces also raw performance measurements and plots of the different NFs while receiving traffic. ? Experiments: (1) Baseline vs Morpheus throughput experiments (Figure <ref type="figure" target="#fig_3">4</ref>), (2) Effect of Morpheus optimizations on PMU counters (Figure <ref type="figure" target="#fig_4">5</ref>), (3) Baseline vs Morpheus latency experiments (Figure <ref type="figure" target="#fig_5">6</ref>), (4) Naive vs Adaptive instrumentation (Figure <ref type="figure" target="#fig_6">7</ref>), (5) Instrumentation overhead (Figure <ref type="figure" target="#fig_7">8</ref>), (6) Effect of Morpheus optimizations with dynamic changing traffic (Figure <ref type="figure" target="#fig_8">9a</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Description</head><p>A.3.1 How to Access. Our artifacts are archived under Zenodo <ref type="bibr" target="#b63">[65]</ref>. We also published the software and artifact, with the corresponding setup instructions at the following Github repository (https://github. com/Morpheus-compiler/Morpheus). Note: The GitHub repository is the preferred method to access our artifacts, since it provides the latest updates and fixes. The repository is linked with Zenodo so that every release is automatically archived.</p><p>A.3.2 Hardware Dependencies. In order to fully reproduce the results presented in the paper and run the majority of the experiments, this artifact requires two servers connected back-to-back with 2 different interfaces. The first server is used as packet generator, while the second is used as Device Under Test (DUT) running the data plane application together with the Morpheus compiler/optimizer. The driver used by the two interface in the DUT server should be compatible with XDP Native mode<ref type="foot" target="#foot_1">2</ref> ; we have tested our artifact only with Intel cards, in particular a dual-port Intel XL710 40Gbps NIC. In addition, the NIC should should have the possibility to set hardware rules to redirect packets to a single core (e.g., Intel Flow Director technology).</p><p>A.3.3 Software Dependencies. We provide here a tentative list of software dependency required to run our artifact, for both packet generator server (pktgen) and Device Under Test server (DUT). The setup script available in the repository will take care of installing all the libraries and software needed for the artifact, just make sure you meet the following requirements:</p><p>? Ubuntu 20.04 LTS (pktgen and DUT).</p><p>? DPDK v20.11.3 (pktgen).</p><p>? At least 10G of large hugepages (1G each) required to send large PCAPs (pktgen). ? Linux kernel v5.10+ (the paper's test have been performed on kernel v5.12) (DUT). ? The bpf_jit_enable flag enabled on the kernel<ref type="foot" target="#foot_2">3</ref> (DUT).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Installation</head><p>If you have a local testbed that meets the hardware (Section A.3.2) and software (Section A.3.3) requirements, you can directly follow the instructions in Section A.5. If you do not have a local testbed, we also prepared a Cloudlab <ref type="bibr" target="#b4">[5]</ref> profile to run the artifacts.</p><p>A.4.1 CloudLab Setup. To run our artifact on Cloudlab, you can follow these steps: You can now choose a hardware node type. We already provide a default type (i.e., c220g1) but you can use another (we only tested it on c220g1). Note: Althought c220g1 hardware nodes are similar to our paper's testbed, it is not the same; the absolute results may be different, but the Morpheus behavior should be evident.</p><p>A.7.3 Baseline vs Morpheus Latency Experiment. This experiment measures the effect of Morpheus optimizations on the latency for the different services. In particular, it calculates the latency in the best and worst case scenario depending on the Morpheus optimizations applied. The results should follow a similar trend as Figure <ref type="figure" target="#fig_5">6</ref>.</p><p>The experiment can be executed with the following command:</p><p>$ ./ run_all_latency_tests . sh -r 5 # 5 runs $ cd plot &amp;&amp; python3 parse_latency_results . py $ make latency # generate figure A.7.4 Naive vs Adaptive Instrumentation. This experiment measures the effect of Morpheus instrumentation mechanism. In particular, it measures the overhead that would be introduced by the naive instrumentation, compared to the overhead of the adaptive instrumentation, which is the one applied by Morpheus. The results should follow a similar trend as Figure <ref type="figure" target="#fig_6">7</ref>. The experiment can be executed with the following command: $ cd router $ ./ start_dynamic_traffic_test . sh $ cd plot &amp;&amp; make dynamic_traffic # generate figure</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (a) Impact of AutoFDO+Bolt (PGO) and performance breakdown when applying a set of domain specific optimizations to both (b) the DPDK firewall and (c) the Facebook's Katran eBPF load balancer. We were unable to run PGO on the latter, since existing tools do not support eBPF targets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The Morpheus compiler pipeline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Listing 1 : 4 p 7 v</head><label>147</label><figDesc>Simplified Katran main loop 1 i n t p r o c e s s _ p a c k e t ( p a c k e t p k t ) { 2 u32 b a c k e n d _ i d x ; 3 a r s e _ l 3 _ h e a d e r s ( p k t ) ; 5 p a r s e _ l 4 _ h e a d e r s ( p k t ) ; 6 i p . v i p = p k t . d s t I P ; 8 v i p . p o r t = p k t . d s t P o r t ; 9 v i p . p r o t o = p k t . p r o t o ; 10 v i p _ i n f o = vip_map . l o o k u p ( v i p ) ; 11 12 i f ( v i p _ i n f o -&gt; f l a g s &amp; F_QUIC_VIP ) { 13 b a c k e n d _ i d x = h a n d l e _ q u i c ( k e n d _ i d x = c o n n _ t a b l e . l o o k u p ( p k t ) ; 18 i f ( ! b a c k e n d _ i d x ) { 19 b a c k e n d _ i d x = a s s i g n _ t o _ b a c k e n d ( p k t ) 20 c o n n _ t a b l e . u p d a t e ( pkt , b a c k e n d _ i d x ) ; k e n d = b a c k e n d _ p o o l . l o o k u p ( b a c k e n d _ i d x ) ; 25 e n c a p s u l a t e _ p k t ( backend -&gt; i p ) ; 26 r e t u r n XDP_TX ; 27 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Single core throughput (64B packets) varying input traffic locality. The optimizations adopted by Morpheus are traffic-dependent, while the ones from ESwitch [71] are not. For this reason, the ESwitch throughput (shown in the right box) is the same across the different traffic localities.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Effect of Morpheus optimizations on PMU counters, obtained with perf at the default frequency (40KHz). The top panel shows the percentage of decrease, per packet, of different metrics for high locality traffic (best-case for Morpheus), and the bottom panel for no locality traffic (worst-case).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: 99th percentile (P 99 ) latency with Morpheus. The graph shows both the latency for the optimized and nonoptimized code paths, under small load (10pps) and heavy load (highest rate without packet drop).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure7: Naive vs adaptive instrumentation (low locality traffic). In the naive case all map lookups are recorded, while adaptive instrumentation adjusts data sampling selectively for the access patterns at each lookup call site.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Effectiveness of instrumentation at varying sampling rates (Router and BPF-iptables, low-locality traffic).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: (a) Single core throughput over time with Morpheus on the Router use case, with dynamically changing traffic patterns, and (b) with a CAIDA [22] trace.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Multicore application (router) with Morpheus.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Comparison between vanilla FastClick, PacketMill and Morpheus for the Router FastClick (DPDK) application with 20 and 500 rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>( 1 )</head><label>1</label><figDesc>Login to Cloudlab (https://cloudlab.us/) using your username and password. (2) Go to Experiments &gt; Start Experiment on the left tab. (3) Click on Change Profile button on the right side of the page, and select the Morpheus-ASPLOS profile; then click Next.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>$</head><label></label><figDesc>./ run_all_adaptive_naive_tests . sh -r 5 # 5 runs $ python3 parse_adaptive_naive_instr_results . py $ make adaptive_vs_naive # generate figure A.7.5 Instrumentation Overhead. This experiment measures the effect of Morpheus instrumentation rate on the optimizations applied. It measures the throughput of the Router and BPF-iptables service with varying instrumentation rate. The results should follow a similar trend as Figure 8. Note: To run this experiment, you first need to run the Experiment A.7.1, since to generate the final figure, we rely on the results of that test. The experiment can be executed with the following command: $ ./ run_all_instr_overhead_tests . sh -r 5 # 5 runs $ cd plot &amp;&amp; python3 parse_instr_overhead_results . py $ make instr_overhead # generate figure A.7.6 Effect of Morpheus Optimizations with Dynamic Changing Traffic. This experiment measures the effect of Morpheus optimizations when the input traffic suddenly changes locality distribution. It measures the throughput of the Router service. The results should follow a similar trend as Figure 9a. The experiment can be executed with the following command:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>A comparison of some popular dynamic optimization frameworks and Morpheus.</figDesc><table><row><cell></cell><cell></cell><cell>Unsupervised</cell><cell>Unsupervised</cell><cell></cell><cell></cell></row><row><cell>Name</cell><cell>Domain specific</cell><cell>adaptation to control plane</cell><cell>adaptation to data plane</cell><cell>Data plane agnostic</cell><cell>Description</cell></row><row><cell></cell><cell></cell><cell>actions</cell><cell>traffic</cell><cell></cell><cell></cell></row><row><cell>Bolt [77]</cell><cell>?</cell><cell>-</cell><cell>-</cell><cell>?</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>4.3.4 Data Structure Specialization. Morpheus adapts the layout, size and lookup algorithm of a table against its content at run time. For example, if all entries share the same prefix length in an LPM Handling control plane updates. Theoretically, each table should be protected by a guard when the contents are modified from the control plane. This would require packets to perform one costly guard check for each table. To reduce this overhead, Morpheus collapses all table-specific guards protecting against control plane updates into a single program-level guard, injected at the program entry point. Once an RO map gets updated by the control plane, the program-level guard directs all incoming packets to the original (unoptimized) datapath until the next compilation cycle kicks in to re-optimize the code with respect to the new table content.</figDesc><table /><note><p><p><p><p><p><p><p><p><p><p><p>map, then a much faster exact-matching cache</p><ref type="bibr" target="#b69">[71]</ref> </p>can be used. This is done by first associating a backend-specific cost function with each applicable representation (this can be automatically inferred using static analysis and symbolic execution</p><ref type="bibr" target="#b75">[77,</ref><ref type="bibr" target="#b77">79]</ref></p>), generate the expected cost of each candidate, and finally implement the table that minimizes the cost.</p>4.3.5 Branch</p>Injection. This pass applies to the cases when certain fields take only few possible values in a table, which makes it possible to eliminate subsequent code that handles the rest of the values. This optimization was used in ?2 to sidestep the ACL lookup for UDP packets in the firewall use case: if we observe that the ?IP protocol? field can have only a single value in the ACL (e.g., TCP), then we can inject a conditional statement before the ACL lookup to check if the IP protocol field in a packet is TCP, use symbolic execution to track the use of this value throughout the resultant branch, and invoke dead code elimination to remove the useless ACL lookup on the non-TCP ?else? branch.</p>4.3.6 Guard Elision.</p>As discussed before, Morpheus uses guards to protect the consistency of the optimized code. Since each packet may need to pass multiple checks while traversing the datapath, guards may introduce non trivial run time overhead</p><ref type="bibr" target="#b93">[95]</ref></p>. To mitigate this, Morpheus heuristically eliminates as many guards as possible; this is achieved by using different schemes depending if changes to the code are made from the control plane or from the data-plane itself, as in the case when a program implements a stateful network function.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Time (in ms) to execute the entire Morpheus compilation pipeline and install the optimized datapath. LOC is calculated using cloc (v1.82) excluding comments and blank lines while instruction count is measured with bpftool v5.9. Uses a chain of eBPF programs; since Morpheus optimizes every eBPF program separately, values shown refer to the most complex program in the chain. t 1 Time to analyze the program, instrument it and read the maps. t 2 Time to generate the final eBPF code.</figDesc><table><row><cell>Application</cell><cell>C LOC</cell><cell>BPF Insn</cell><cell>t 1</cell><cell cols="4">Compilation (ms) Best Worst t 2 t 1 t 2</cell><cell cols="2">Injection (ms) Best Worst</cell></row><row><cell>L2 Switch</cell><cell>243</cell><cell>464</cell><cell>81</cell><cell></cell><cell>62</cell><cell>140</cell><cell>78</cell><cell>0.5</cell><cell>0.9</cell></row><row><cell>Router</cell><cell>331</cell><cell>458</cell><cell>87</cell><cell></cell><cell>65</cell><cell>196</cell><cell>91</cell><cell>1.1</cell><cell>1.3</cell></row><row><cell>BPF-iptables*</cell><cell>220</cell><cell>358</cell><cell>95</cell><cell></cell><cell>62</cell><cell>105</cell><cell>87</cell><cell>0.6</cell><cell>0.5</cell></row><row><cell>Katran</cell><cell>494</cell><cell>905</cell><cell cols="2">287</cell><cell>115</cell><cell>569</cell><cell>151</cell><cell>3.4</cell><cell>6.1</cell></row><row><cell>*</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>?</head><label></label><figDesc>Program: Morpheus, Polycube (Morpheus branch), BCC (Morpheus branch), libbpf (21f90f6). ? Compilation: GCC v9.3.0 to compile Morpheus, LLVM Toolchain and Clang (v10.0.1) for run-time code generation. ? Data set: High/low/no locality traces generated with Classbench [93] trace generator with different Pareto parameters; CAIDA 2019 dataset, equinix-nyc [22] to test real-world scenarios. ? Hardware: Two servers connected back-to-back with a dual-port Intel XL710 40Gbps NIC and Intel Xeon processors. ? Execution: The artifacts can be executed in a local testbed, or on a Cloudlab [5] setup. ? Metrics: Throughput, Latency and Compilation Time. ? Output: A modified Polycube binary with Morpheus support</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>? How much disk space required (approximately)?: ~30GB. ? How much time is needed to prepare workflow (approximately)?: ~1.5 hour with a local testbed, ~30 mins with Cloudlab setup. ? How much time is needed to complete experiments (approximately)?: ~1 day. ? Publicly available?: Code, setup scripts, measured results, and experiments are publicly available. The CAIDA 2019 dataset, equinixnyc should be requested separately on the CAIDA website [21]. ? Code licenses (if publicly available)?: Morpheus, Polycube and BCC use the Apache License 2.0, libbpf uses the 2-Clause BSD License. ? Archived (provide DOI)?: https://doi.org/10.5281/zenodo.5830832.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>A working version with latest updates is also available here: https://github.com/ Morpheus-compiler/Morpheus</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>A list of drivers that support XDP Native is available here: https://github.com/xdpproject/xdp-project/blob/master/areas/drivers/README.org.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p><ref type="bibr" target="#b2">3</ref> This flag is enabled by default on kernel v4.18+.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We would like to thank our shepherd, <rs type="person">Edouard Bugnion</rs>, for his insightful suggestions; the anonymous ASPLOS reviewers for their enlightening comments, the artifact evaluation committee for their effort in reviewing our artifacts, and <rs type="person">Srinivas Narayana</rs> for his feedback on the first draft of the paper. This work is partially supported by the <rs type="funder">UK's EPSRC</rs> under the projects <rs type="institution">NEAT</rs> (<rs type="grantNumber">EP/T007206/1</rs>) and by <rs type="funder">Facebook</rs> as part of the <rs type="grantName">2020 Networking Systems request for proposals (RFP) award</rs>. <rs type="person">G?bor R?tv?ri</rs> was funded by the <rs type="funder">NK-FIH/OTKA</rs> Project #<rs type="grantNumber">135606</rs>, the <rs type="institution">MTA-BME Information Systems Research Group</rs> and the <rs type="institution">MTA-BME Network Softwarization Research Group</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_Mft6A2z">
					<idno type="grant-number">EP/T007206/1</idno>
				</org>
				<org type="funding" xml:id="_NqMQfmF">
					<orgName type="grant-name">2020 Networking Systems request for proposals (RFP) award</orgName>
				</org>
				<org type="funding" xml:id="_7fDqKtr">
					<idno type="grant-number">135606</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(4) After the experiment is instantiated, you just need to wait for the setup to complete; then you can click on the List View tab to read the ssh command to log into the servers. (5) Follow the instructions in Section A.5 to install Morpheus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.5 Morpheus Installation</head><p>We provide a set of script to automatically install all the software dependencies, compile the code and setup the testbed (e.g., setup the hugepages or bound the interfaces to DPDK on the pktgen server). Morpheus's README.md describes all the steps needed to prepare the testbed and install the software. Here we provide a summary of the steps:</p><p>(1) (Pktgen &amp; DUT) Clone or download Morpheus repository.</p><p>(2) (Pktgen) Install dependencies.</p><p>$ ./ setup_pktgen . sh</p><p>(3) (DUT) Install Morpheus and dependencies.</p><p>$ ./ setup_dut . sh (4) (DUT) Upgrade the kernel to v5.12 (if needed). We provide a upgrade-kernel.sh script to simplify the process. ( <ref type="formula">5</ref>) (Pktgen &amp; DUT) Fill the experiment/config.sh file with all the information specific to the testbed (e.g., IP, MAC, username). This file is used by all the experiments scripts to automatically configure the experiments to the testbed. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.6 Experiment Workflow</head><p>Every experiment in this artifact is meant to be executed on the pktgen server. Once executed, the script reads the configuration parameters set in the experiment/config.sh file, starts the polycubed daemon with Morpheus on the DUT, instantiates the NF under test and configures it. If those steps are executed successfully, it start the DPDK packet generator to replay the high/low/no locality trace and collects the results in the results folder of every single service. Once the experiments are completed, the user can parse the results with the appropriate script under the experiments/plot folder and generate the final figures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.7 Evaluation and Expected Results</head><p>In this Section we present the main experiments included in this artifact. For more information please refer to the experiments' README.md of the Morpheus repository.</p><p>A.7.1 Baseline vs Morpheus Throughput Experiment. This experiment measures the single core throughput (with 64B packets) with varying input traffic locality. This is the main experiment, which evaluates the performance improvements provided by Morpheus with 4 different applications (Router, Switch, BPF-iptables and Katran). The results should follow a similar trend as Figure <ref type="figure">4</ref>. The experiment can be executed with the following command:</p><p>$ ./ run_all_throughput_tests . sh -r 5 # 5 runs $ cd plot &amp;&amp; python3 parse_throughput_loc_results . py $ make throughput_loc # generate figure A.7.2 Effect of Morpheus Optimizations on PMU Counters. This experiment measures the effect of Morpheus optimizations on PMU counters, obtained with the Linux perf tool, for 4 different applications (Router, Switch, BPF-iptables and Katran). The results should follow a similar trend as Figure <ref type="figure">5</ref>. The experiment can be executed with the following command:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Intel Data Direct I/O Technology</title>
		<ptr target="https://www.intel.co.uk/content/www/uk/en/io/data-direct-i-o-technology.html" />
		<imprint>
			<date type="published" when="2021-08">2021. August-2021</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<ptr target="https://www.kernel.org/doc/html/latest/networking/af_xdp.html" />
	</analytic>
	<monogr>
		<title level="j">Linux AF_XDP</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<date type="published" when="2021-08">2021. August-2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="https://llvm.org/docs/AliasAnalysis.html" />
		<title level="m">LLVM Alias Analysis</title>
		<imprint>
			<date type="published" when="2021-08">2021. August-2021</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Llvm Memoryssa</surname></persName>
		</author>
		<ptr target="https://llvm.org/docs/MemorySSA.html" />
		<imprint>
			<date type="published" when="2021-08">2021. August-2021</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">CloudLab</title>
		<ptr target="https://cloudlab.us/" />
		<imprint>
			<date type="published" when="2022-01">2022. January-2022</date>
			<biblScope unit="volume">26</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Policy-Driven Optimization of P4 Pipeline</title>
		<author>
			<persName><forename type="first">Anubhavnidhi</forename><surname>Abhashkumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeongkeun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Tourrilhes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sujata</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joon-Myung</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Akella</surname></persName>
		</author>
		<idno type="DOI">10.1145/3050220.3050235</idno>
		<ptr target="https://doi.org/10.1145/3050220.3050235" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on SDN Research</title>
		<meeting>the Symposium on SDN Research<address><addrLine>Santa Clara, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="136" to="142" />
		</imprint>
	</monogr>
	<note>SOSR &apos;17)</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Decoupling Algorithms and Optimizations in Network Functions</title>
		<author>
			<persName><forename type="first">Omid</forename><surname>Alipourfard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minlan</forename><surname>Yu</surname></persName>
		</author>
		<idno type="DOI">10.1145/3286062.3286073</idno>
		<ptr target="https://doi.org/10.1145/3286062.3286073" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM Workshop on Hot Topics in Networks</title>
		<meeting>the 17th ACM Workshop on Hot Topics in Networks<address><addrLine>Redmond, WA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="71" to="77" />
		</imprint>
	</monogr>
	<note>HotNets &apos;18)</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast, Effective Dynamic Compilation</title>
		<author>
			<persName><forename type="first">Joel</forename><surname>Auslander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthai</forename><surname>Philipose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><forename type="middle">J</forename><surname>Eggers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<idno type="DOI">10.1145/231379.231409</idno>
		<ptr target="https://doi.org/10.1145/231379.231409" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation (PLDI &apos;96)</title>
		<meeting>the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation (PLDI &apos;96)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="149" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>Gcc Authors</surname></persName>
		</author>
		<ptr target="https://gcc.gnu.org/wiki/AutoFDO/Tutorial" />
		<imprint>
			<date type="published" when="2016-08">2016. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">Istio</forename><surname>Authors</surname></persName>
		</author>
		<ptr target="https://istio.io/" />
		<title level="m">Istio -Connect, secure, control, and observe services</title>
		<imprint>
			<date type="published" when="2020-08">2020. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dynamo: A Transparent Dynamic Optimization System</title>
		<author>
			<persName><forename type="first">Vasanth</forename><surname>Bala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evelyn</forename><surname>Duesterwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Banerjia</surname></persName>
		</author>
		<idno type="DOI">10.1145/349299.349303</idno>
		<ptr target="https://doi.org/10.1145/349299.349303" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIG-PLAN 2000 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIG-PLAN 2000 Conference on Programming Language Design and Implementation<address><addrLine>Vancouver, British Columbia, Canada; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
	<note>PLDI &apos;00)</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Enabling End-Host Network Functions</title>
		<author>
			<persName><forename type="first">Hitesh</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Gkantsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">P</forename><surname>Grosvenor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Karagiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lazaros</forename><surname>Koromilas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg O'</forename><surname>Shea</surname></persName>
		</author>
		<idno type="DOI">10.1145/2785956.2787493</idno>
		<ptr target="https://doi.org/10.1145/2785956.2787493" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM Conference on Special Interest Group on Data Communication</title>
		<meeting>the 2015 ACM Conference on Special Interest Group on Data Communication<address><addrLine>London, United Kingdom; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="493" to="507" />
		</imprint>
	</monogr>
	<note>SIGCOMM &apos;15)</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automatic Generation of Peephole Superoptimizers</title>
		<author>
			<persName><forename type="first">Sorav</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<idno type="DOI">10.1145/1168857.1168906</idno>
		<ptr target="https://doi.org/10.1145/1168857.1168906" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the 12th International Conference on Architectural Support for Programming Languages and Operating Systems<address><addrLine>San Jose, California, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="394" to="403" />
		</imprint>
	</monogr>
	<note>ASPLOS XII)</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast Userspace Packet Processing</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Barbette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cyril</forename><surname>Soldani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Mathy</surname></persName>
		</author>
		<idno type="DOI">10.1109/ANCS.2015.7110116</idno>
		<ptr target="https://doi.org/10.1109/ANCS.2015.7110116" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh ACM/IEEE Symposium on Architectures for Networking and Communications Systems</title>
		<meeting>the Eleventh ACM/IEEE Symposium on Architectures for Networking and Communications Systems<address><addrLine>Oakland, California, USA; USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="5" to="16" />
		</imprint>
	</monogr>
	<note>) (ANCS &apos;15)</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A High-Speed Load-Balancer Design with Guaranteed Per-Connection-Consistency</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Barbette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haoran</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dejan</forename><surname>Kosti?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><forename type="middle">Q</forename><surname>Maguire</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Panagiotis Papadimitratos</surname></persName>
		</author>
		<author>
			<persName><surname>Chiesa</surname></persName>
		</author>
		<idno type="DOI">10.5555/3388242.3388291</idno>
		<ptr target="https://doi.org/10.5555/3388242.3388291" />
	</analytic>
	<monogr>
		<title level="m">17th USENIX Symposium on Networked Systems Design and Implementation (NSDI 20). USENIX Association</title>
		<meeting><address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="667" to="683" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Preliminary Performance Model for Optimizing Software Packet Processing Pipelines</title>
		<author>
			<persName><forename type="first">Ankit</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atul</forename><surname>Shree</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Bhargav</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sorav</forename><surname>Bansal</surname></persName>
		</author>
		<idno type="DOI">10.1145/3124680.3124747</idno>
		<ptr target="https://doi.org/10.1145/3124680.3124747" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Asia-Pacific Workshop on Systems</title>
		<meeting>the 8th Asia-Pacific Workshop on Systems<address><addrLine>Mumbai, India; New York, NY, USA, Article</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">26</biblScope>
		</imprint>
	</monogr>
	<note>) (APSys &apos;17)</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">Scott</forename><surname>Bradner</surname></persName>
		</author>
		<ptr target="https://www.rfc-editor.org/rfc/rfc1242.txt" />
		<title level="m">Benchmarking Terminology for Network Interconnection Devices. RFC 1242. RFC Editor. 1?12 pages</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Benchmarking Methodology for Network Interconnect Devices. RFC 2544</title>
		<author>
			<persName><forename type="first">Scott</forename><surname>Bradner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Mcquaid</surname></persName>
		</author>
		<ptr target="http://www.rfc-editor.org/rfc/rfc2544.txthttp://www.rfc-editor.org/rfc/rfc2544.txt" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">OpenBox: A Software-Defined Framework for Developing, Deploying, and Managing Network Functions</title>
		<author>
			<persName><forename type="first">Anat</forename><surname>Bremler-Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yotam</forename><surname>Harchol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Hay</surname></persName>
		</author>
		<idno type="DOI">10.1145/2934872.2934875</idno>
		<ptr target="https://doi.org/10.1145/2934872.2934875" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGCOMM Conference</title>
		<meeting>the 2016 ACM SIGCOMM Conference<address><addrLine>Florianopolis, Brazil; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="511" to="524" />
		</imprint>
	</monogr>
	<note>SIGCOMM &apos;16)</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An Infrastructure for Adaptive Dynamic Optimization</title>
		<author>
			<persName><forename type="first">Derek</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Garnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
		<idno type="DOI">10.5555/776261.776290</idno>
		<ptr target="https://dl.acm.org/doi/10.5555/776261.776290" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization</title>
		<meeting>the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization<address><addrLine>San Francisco, California, USA; USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="265" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><surname>Caida</surname></persName>
		</author>
		<ptr target="https://www.caida.org/catalog/datasets/passive_dataset_download/" />
		<title level="m">The CAIDA Anonymized Internet Traces Data Access</title>
		<imprint>
			<date type="published" when="2019-01">2019. January-2022</date>
			<biblScope unit="volume">26</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><surname>Caida</surname></persName>
		</author>
		<ptr target="http://www.caida.org/data/passive/passive_dataset.xml" />
		<title level="m">The CAIDA UCSD Anonymized Internet Traces</title>
		<imprint>
			<date type="published" when="2019-08">2019. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">AutoFDO: Automatic Feedback-Directed Optimization for Warehouse-Scale Applications</title>
		<author>
			<persName><forename type="first">Dehao</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">Xinliang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tipp</forename><surname>Moseley</surname></persName>
		</author>
		<idno type="DOI">10.1145/2854038.2854044</idno>
		<ptr target="https://doi.org/10.1145/2854038.2854044" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Symposium on Code Generation and Optimization</title>
		<meeting>the 2016 International Symposium on Code Generation and Optimization<address><addrLine>Barcelona, Spain; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="12" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">VeGen: A Vectorizer Generator for SIMD and Beyond</title>
		<author>
			<persName><forename type="first">Yishen</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charith</forename><surname>Mendis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
		<idno type="DOI">10.1145/3445814.3446692</idno>
		<ptr target="https://doi.org/10.1145/3445814.3446692" />
	</analytic>
	<monogr>
		<title level="m">Association for Computing Machinery</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="902" to="914" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">PVPP: A Programmable Vector Packet Processor</title>
		<author>
			<persName><forename type="first">Sean</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiang</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Skip</forename><surname>Booth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Keep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Marshall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changhoon</forename><surname>Kim</surname></persName>
		</author>
		<idno type="DOI">10.1145/3050220.3060609</idno>
		<ptr target="https://doi.org/10.1145/3050220.3060609" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on SDN Research</title>
		<meeting>the Symposium on SDN Research<address><addrLine>Santa Clara, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017. 197?198</date>
		</imprint>
	</monogr>
	<note>SOSR &apos;17)</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The Case for a Flexible Low-Level Backend for Software Data Planes</title>
		<author>
			<persName><forename type="first">Sean</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiang</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Skip</forename><surname>Booth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Keep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Marshall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changhoon</forename><surname>Kim</surname></persName>
		</author>
		<idno type="DOI">10.1145/3106989.3107000</idno>
		<ptr target="https://doi.org/10.1145/3106989.3107000" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Asia-Pacific Workshop on Networking</title>
		<meeting>the First Asia-Pacific Workshop on Networking<address><addrLine>Hong Kong, China; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="71" to="77" />
		</imprint>
	</monogr>
	<note>APNet&apos;17</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<ptr target="https://en.wikipedia.org/wiki/Perf_(Linux)" />
		<title level="m">Perf (linux)</title>
		<imprint>
			<publisher>Wikipedia contributors</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>Online; accessed 07-August-2021</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<ptr target="https://software.intel.com/content/www/us/en/develop/articles/pin-a-dynamic-binary-instrumentation-tool.html" />
		<title level="m">Pin -A Dynamic Binary Instrumentation Tool</title>
		<imprint>
			<date type="published" when="2020-08">2020. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
		<respStmt>
			<orgName>Intel Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Compiling Java Just in Time</title>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Terrence</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Seberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Wolczko</surname></persName>
		</author>
		<idno type="DOI">10.1109/40.591653</idno>
		<ptr target="https://doi.org/10.1109/40.591653" />
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="36" to="43" />
			<date type="published" when="1997-05">1997. may 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Redundant Logic Elimination in Network Functions</title>
		<author>
			<persName><forename type="first">Bangwen</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linhai</forename><surname>Song</surname></persName>
		</author>
		<idno type="DOI">10.1145/3373360.3380832</idno>
		<ptr target="https://doi.org/10.1145/3373360.3380832" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on SDN Research</title>
		<meeting>the Symposium on SDN Research<address><addrLine>San Jose, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="34" to="40" />
		</imprint>
	</monogr>
	<note>SOSR &apos;20)</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Pktgen Traffic Generator Using DPDK</title>
		<author>
			<persName><surname>Dpdk</surname></persName>
		</author>
		<ptr target="http://dpdk.org/git/apps/pktgen-dpdk" />
		<imprint>
			<date type="published" when="2018-08">2018. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><surname>Dpdk</surname></persName>
		</author>
		<ptr target="https://doc.dpdk.org/guides/sample_app_ug/l3_forward_access_ctrl.html" />
		<title level="m">L3 Forwarding with Access Control Sample Application</title>
		<imprint>
			<date type="published" when="2021-08">2021. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">Paul</forename><surname>Emmerich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Gallenm?ller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Raumer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Wohlfart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Carle</surname></persName>
		</author>
		<idno type="DOI">10.1145/2815675.2815692</idno>
		<ptr target="https://doi.org/10.1145/2815675.2815692" />
		<title level="m">MoonGen: A Scriptable High-Speed Packet Generator (IMC &apos;15)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="275" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">New Directions in Traffic Measurement and Accounting</title>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Estan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Varghese</surname></persName>
		</author>
		<idno type="DOI">10.1145/633025.633056</idno>
		<ptr target="https://doi.org/10.1145/633025.633056" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 Conference on Applications, Technologies, Architectures, and Protocols for Computer Communications</title>
		<meeting>the 2002 Conference on Applications, Technologies, Architectures, and Protocols for Computer Communications<address><addrLine>Pittsburgh, Pennsylvania, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="323" to="336" />
		</imprint>
	</monogr>
	<note>SIGCOMM &apos;02)</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">PacketMill: Toward per-Core 100-Gbps Networking</title>
		<author>
			<persName><forename type="first">Alireza</forename><surname>Farshin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Barbette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Roozbeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><forename type="middle">Q</forename><surname>Maguire</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">Dejan</forename><surname>Kosti?</surname></persName>
		</author>
		<idno type="DOI">10.1145/3445814.3446724</idno>
		<idno>AS- PLOS 2021</idno>
		<ptr target="https://doi.org/10.1145/3445814.3446724" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems<address><addrLine>Virtual, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Tradeoffs for packet classification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<idno type="DOI">10.1109/INFCOM.2000.832493</idno>
		<ptr target="https://doi.org/10.1109/INFCOM.2000.832493" />
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE INFOCOM 2000. Conference on Computer Communications. Nineteenth Annual Joint Conference of the IEEE Computer and Communications Societies</title>
		<meeting>IEEE INFOCOM 2000. Conference on Computer Communications. Nineteenth Annual Joint Conference of the IEEE Computer and Communications Societies</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">1202</biblScope>
		</imprint>
	</monogr>
	<note>Cat. No.00CH37064</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<ptr target="https://wiki.fd.io/view/VPP" />
		<title level="m">Vector Packet Processing (VPP) platform</title>
		<imprint>
			<date type="published" when="2020-08">2020. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
	<note>Linux Foundation</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Open Information Security Foundation</title>
		<ptr target="https://suricata-ids.org" />
	</analytic>
	<monogr>
		<title level="m">Suricata -Intrusion Detection System</title>
		<imprint>
			<date type="published" when="2020-08">2020. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Trace-Based Just-in-Time Type Specialization for Dynamic Languages</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brendan</forename><surname>Eich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Shaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mandelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><forename type="middle">R</forename><surname>Haghighat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Blake</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Graydon</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Zbarsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Orendorff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesse</forename><surname>Ruderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edwin</forename><forename type="middle">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rick</forename><surname>Reitmaier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Bebenita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mason</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
		<idno type="DOI">10.1145/1542476.1542528</idno>
		<ptr target="https://doi.org/10.1145/1542476.1542528" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09</title>
		<meeting>the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="465" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<ptr target="https://gcc.gnu.org/" />
		<title level="m">GNU Compiler Collection</title>
		<imprint>
			<date type="published" when="2021-08">August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
		<respStmt>
			<orgName>GNU Project</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Gprof: A Call Graph Execution Profiler</title>
		<author>
			<persName><forename type="first">Susan</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">B</forename><surname>Kessler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marshall</forename><forename type="middle">K</forename><surname>Mckusick</surname></persName>
		</author>
		<idno type="DOI">10.1145/800230.806987</idno>
		<ptr target="https://doi.org/10.1145/800230.806987" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1982 SIGPLAN Symposium on Compiler Construction</title>
		<meeting>the 1982 SIGPLAN Symposium on Compiler Construction<address><addrLine>Boston, Massachusetts, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="120" to="126" />
		</imprint>
	</monogr>
	<note>) (SIGPLAN &apos;82)</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Blueswitch: enabling provably consistent configuration of network switches</title>
		<author>
			<persName><forename type="first">Prashanth</forename><surname>Jong Hun Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charalampos</forename><surname>Mundkur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gianni</forename><surname>Rotsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nirav</forename><surname>Antichi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">W</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">G</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><surname>Neumann</surname></persName>
		</author>
		<idno type="DOI">10.1109/ANCS.2015.7110117</idno>
		<ptr target="https://doi.org/10.1109/ANCS.2015.7110117" />
	</analytic>
	<monogr>
		<title level="m">2015 ACM/IEEE Symposium on Architectures for Networking and Communications Systems (ANCS)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="17" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">Sangjin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keon</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aurojit</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shoumik</forename><surname>Palkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongsu</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvia</forename><surname>Ratnasamy</surname></persName>
		</author>
		<title level="m">SoftNIC: A software NIC to augment hardware</title>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback</title>
		<author>
			<persName><forename type="first">Urs</forename><surname>H?lzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Ungar</surname></persName>
		</author>
		<idno type="DOI">10.1145/178243.178478</idno>
		<ptr target="https://doi.org/10.1145/178243.178478" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation<address><addrLine>Orlando, Florida, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="326" to="336" />
		</imprint>
	</monogr>
	<note>PLDI &apos;94)</note>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Katran: A high performance layer 4 load balancer</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Hopps</surname></persName>
		</author>
		<ptr target="https://github.com/facebookincubator/katran" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Kubernetes: Production-Grade Container Orchestration</title>
		<ptr target="https://kubernetes.io" />
		<imprint>
			<date type="published" when="2019-08">2019. August-2021</date>
			<publisher>Google Inc</publisher>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Propeller: Profile Guided Optimizing Large Scale LLVMbased Relinker</title>
		<ptr target="https://github.com/google/llvm-propeller" />
		<imprint>
			<date type="published" when="2019-08">2019. August-2021</date>
			<publisher>Google Inc</publisher>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Performance Contracts for Software Network Functions</title>
		<author>
			<persName><forename type="first">Rishabh</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Pedrosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arseniy</forename><surname>Zaostrovnykh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Solal</forename><surname>Pirelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katerina</forename><surname>Argyraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th {USENIX} Symposium on Networked Systems Design and Implementation ({NSDI} 19)</title>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="517" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Kubernetes Long Road to Dual IPv4/IPv6 Support</title>
		<author>
			<persName><forename type="first">Joab</forename><surname>Jackson</surname></persName>
		</author>
		<ptr target="https://thenewstack.io/it-takes-a-community-kubernetes-long-road-to-dual-ipv4-ipv6-support" />
		<imprint>
			<date type="published" when="2019-08">2019. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Denali: A Goal-Directed Superoptimizer</title>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Randall</surname></persName>
		</author>
		<idno type="DOI">10.1145/512529.512566</idno>
		<ptr target="https://doi.org/10.1145/512529.512566" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation<address><addrLine>Berlin, Germany; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="304" to="314" />
		</imprint>
	</monogr>
	<note>PLDI &apos;02)</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Metron: NFV Service Chains at the True Speed of the Underlying Hardware</title>
		<author>
			<persName><forename type="first">P</forename><surname>Georgios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Katsikas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dejan</forename><surname>Barbette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rebecca</forename><surname>Kosti?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><forename type="middle">Q</forename><surname>Steinert</surname></persName>
		</author>
		<author>
			<persName><surname>Maguire</surname><genName>Jr</genName></persName>
		</author>
		<idno type="DOI">10.5555/3307441.3307457</idno>
		<ptr target="https://dl.acm.org/doi/10.5555/3307441.3307457" />
	</analytic>
	<monogr>
		<title level="m">15th USENIX Symposium on Networked Systems Design and Implementation (NSDI 18). USENIX Association</title>
		<meeting><address><addrLine>Renton, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="171" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">SNF: synthesizing high performance NFV service chains</title>
		<author>
			<persName><forename type="first">P</forename><surname>Georgios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Katsikas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maciej</forename><surname>Enguehard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><forename type="middle">Q</forename><surname>Ku?niar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dejan</forename><surname>Maguire</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><surname>Kosti?</surname></persName>
		</author>
		<idno type="DOI">10.7717/peerj-cs.98</idno>
		<ptr target="https://doi.org/10.7717/peerj-cs.98" />
	</analytic>
	<monogr>
		<title level="j">PeerJ Computer Science</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">98</biblScope>
			<date type="published" when="2016-11">2016. Nov. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Header Space Analysis: Static Checking for Networks</title>
		<author>
			<persName><forename type="first">Peyman</forename><surname>Kazemian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Mckeown</surname></persName>
		</author>
		<idno type="DOI">10.5555/2228298.2228311</idno>
		<ptr target="https://dl.acm.org/doi/10.5555/2228298.2228311" />
	</analytic>
	<monogr>
		<title level="m">9th USENIX Symposium on Networked Systems Design and Implementation (NSDI 12). USENIX Association</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="113" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Moving the Mobile Evolved Packet Core to the Cloud</title>
		<author>
			<persName><forename type="first">James</forename><surname>Kempf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bengt</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sten</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harald</forename><surname>Luning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tord</forename></persName>
		</author>
		<idno type="DOI">10.1109/WiMOB.2012.6379165</idno>
		<ptr target="https://doi.org/10.1109/WiMOB.2012.6379165" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 IEEE 8th International Conference on Wireless and Mobile Computing</title>
		<meeting>the 2012 IEEE 8th International Conference on Wireless and Mobile Computing<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="784" to="791" />
		</imprint>
	</monogr>
	<note>Networking and Communications (WiMob) (WIMOB &apos;12)</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">DMon: Efficient Detection and Correction of Data Locality Problems Using Selective Profiling</title>
		<author>
			<persName><forename type="first">Tanvir</forename><surname>Ahmed Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Neal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barzan</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/osdi21/presentation/khan" />
	</analytic>
	<monogr>
		<title level="m">15th USENIX Symposium on Operating Systems Design and Implementation (OSDI 21). USENIX Association</title>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="163" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Adaptive Execution of Compiled Queries</title>
		<author>
			<persName><forename type="first">Andr?</forename><surname>Kohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Viktor</forename><surname>Leis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2018.00027</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2018.00027" />
	</analytic>
	<monogr>
		<title level="m">2018 IEEE 34th International Conference on Data Engineering (ICDE)</title>
		<imprint>
			<date type="published" when="2018">2018. 197?208</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Manageability of the QUIC Transport Protocol</title>
		<author>
			<persName><forename type="first">Mirja</forename><surname>Kuehlewind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Trammell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
	<note>Internet-Draft draft-ietf-quic-manageability-09</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">LLVM: A Compilation Framework for Lifelong Program Analysis and Transformation</title>
		<author>
			<persName><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vikram</forename><surname>Adve</surname></persName>
		</author>
		<idno type="DOI">10.1109/CGO.2004.1281665</idno>
		<ptr target="https://doi.org/10.1109/CGO.2004.1281665" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization</title>
		<meeting>the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization<address><addrLine>Palo Alto, California; USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page">75</biblScope>
		</imprint>
	</monogr>
	<note>) (CGO &apos;04)</note>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<persName><forename type="first">John</forename><surname>Levon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Elie</surname></persName>
		</author>
		<ptr target="https://oprofile.sourceforge.io/news/" />
		<title level="m">Oprofile: A system profiler for linux</title>
		<imprint>
			<date type="published" when="2004-08">2004. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Survey of Performance Acceleration Techniques for Network Function Virtualization</title>
		<author>
			<persName><forename type="first">Leonardo</forename><surname>Linguaglossa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanislav</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Salvatore</forename><surname>Pontarelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G?bor</forename><surname>R?tv?ri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dario</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Zinner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Bifulco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Jarschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Bianchi</surname></persName>
		</author>
		<idno type="DOI">10.1109/JPROC.2019.2896848</idno>
		<ptr target="https://doi.org/10.1109/JPROC.2019.2896848" />
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="page" from="746" to="764" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">Microboxes: High Performance NFV with Customizable, Asynchronous TCP Stacks and Dynamic Subscriptions (SIGCOMM &apos;18). Association for Computing Machinery</title>
		<author>
			<persName><forename type="first">Guyue</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuxin</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mykola</forename><surname>Yurchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1145/3230543.3230563</idno>
		<ptr target="https://doi.org/10.1145/3230543.3230563" />
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="504" to="517" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Contention-Aware Performance Prediction For Virtualized Network Functions</title>
		<author>
			<persName><forename type="first">Antonis</forename><surname>Manousis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vyas</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Justine</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><surname>Sherry</surname></persName>
		</author>
		<idno type="DOI">10.1145/3387514.3405868</idno>
		<ptr target="https://doi.org/10.1145/3387514.3405868" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Conference of the ACM Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for Computer Communication (Virtual Event, USA) (SIGCOMM &apos;20)</title>
		<meeting>the Annual Conference of the ACM Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for Computer Communication (Virtual Event, USA) (SIGCOMM &apos;20)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="270" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">ClickOS and the Art of Network Function Virtualization</title>
		<author>
			<persName><forename type="first">Joao</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohamed</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Costin</forename><surname>Raiciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michio</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Bifulco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felipe</forename><surname>Huici</surname></persName>
		</author>
		<idno type="DOI">10.5555/2616448.2616491</idno>
		<ptr target="https://dl.acm.org/doi/10.5555/2616448.2616491" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Conference on Networked Systems Design and Implementation</title>
		<meeting>the 11th USENIX Conference on Networked Systems Design and Implementation<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association, USA</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="459" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Miano</surname></persName>
		</author>
		<idno type="DOI">10.5281/zenodo.5830832</idno>
		<ptr target="https://doi.org/10.5281/zenodo.5830832" />
		<title level="m">Morpheus: Domain Specific Run Time Optimization for Software Data Planes -Artifact for ASPLOS&apos;22</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Miano</surname></persName>
		</author>
		<ptr target="https://github.com/Morpheus-compiler/polycube/tree/morpheus" />
		<title level="m">Polycube (Morpheus branch)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Miano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matteo</forename><surname>Bertrone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fulvio</forename><surname>Risso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauricio</forename><forename type="middle">V?squez</forename><surname>Bernal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunsong</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianwen</forename><surname>Pi</surname></persName>
		</author>
		<idno type="DOI">10.1145/3371927.3371929</idno>
		<ptr target="https://doi.org/10.1145/3371927.3371929" />
	</analytic>
	<monogr>
		<title level="j">Securing Linux with a Faster and Scalable Iptables. SIGCOMM Comput. Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="2" to="17" />
			<date type="published" when="2019-11">2019. Nov. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">A Service-Agnostic Software Framework for Fast and Efficient in-Kernel Network Services</title>
		<author>
			<persName><forename type="first">S</forename><surname>Miano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bertrone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Risso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Bernal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shaikh</surname></persName>
		</author>
		<idno type="DOI">10.1109/ANCS.2019.8901880</idno>
		<ptr target="https://doi.org/10.1109/ANCS.2019.8901880" />
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Symposium on Architectures for Networking and Communications Systems (ANCS). 1?9</title>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Creating Complex Network Services with eBPF: Experience and Lessons Learned</title>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Miano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matteo</forename><surname>Bertrone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fulvio</forename><surname>Risso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Tumolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauricio</forename><forename type="middle">V?squez</forename><surname>Bernal</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPSR.2018.8850758</idno>
		<ptr target="https://doi.org/10.1109/HPSR.2018.8850758" />
	</analytic>
	<monogr>
		<title level="m">IEEE 19th International Conference on High Performance Switching and Routing (HPSR). 1?8</title>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">A Framework for eBPF-based Network Functions in an Era of Microservices</title>
		<author>
			<persName><forename type="first">S</forename><surname>Miano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Risso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Bernal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bertrone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNSM.2021.3055676</idno>
		<ptr target="https://doi.org/10.1109/TNSM.2021.3055676" />
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Network and Service Management</title>
		<imprint>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Dataplane Specialization for High-Performance OpenFlow Software Switching</title>
		<author>
			<persName><forename type="first">L?szl?</forename><surname>Moln?r</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gergely</forename><surname>Pongr?cz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G?bor</forename><surname>Enyedi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lajos</forename><surname>Zolt?n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Levente</forename><surname>Kis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ferenc</forename><surname>Csikor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Attila</forename><surname>Juh?sz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G?bor</forename><surname>K?r?si</surname></persName>
		</author>
		<author>
			<persName><surname>R?tv?ri</surname></persName>
		</author>
		<idno type="DOI">10.1145/2934872.2934887</idno>
		<ptr target="https://doi.org/10.1145/2934872.2934887" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGCOMM Conference</title>
		<meeting>the 2016 ACM SIGCOMM Conference<address><addrLine>Florianopolis, Brazil; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="539" to="552" />
		</imprint>
	</monogr>
	<note>SIGCOMM &apos;16)</note>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Dataflow-Based Pruning for Speeding up Superoptimization</title>
		<author>
			<persName><forename type="first">Manasij</forename><surname>Mukherjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pranav</forename><surname>Kant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhengyang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Regehr</surname></persName>
		</author>
		<idno type="DOI">10.1145/3428245</idno>
		<ptr target="https://doi.org/10.1145/3428245" />
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Program. Lang. 4, OOPSLA, Article 177</title>
		<meeting>ACM Program. Lang. 4, OOPSLA, Article 177</meeting>
		<imprint>
			<date type="published" when="2020-11">2020. Nov. 2020</date>
			<biblScope unit="page">24</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Stateless Datacenter Load-balancing with Beamer</title>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandru</forename><surname>Agache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Voinescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Costin</forename><surname>Raiciu</surname></persName>
		</author>
		<idno type="DOI">10.5555/3307441.3307453</idno>
		<ptr target="https://dl.acm.org/doi/10.5555/3307441.3307453" />
	</analytic>
	<monogr>
		<title level="m">15th USENIX Symposium on Networked Systems Design and Implementation (NSDI 18). USENIX Association</title>
		<meeting><address><addrLine>Renton, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="125" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Openstack</forename><surname>Authors</surname></persName>
		</author>
		<ptr target="https://www.openstack.org/" />
		<imprint>
			<date type="published" when="2020-08">2020. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<monogr>
		<author>
			<persName><surname>Oracle</surname></persName>
		</author>
		<ptr target="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html" />
		<title level="m">Java HotSpot VM Options</title>
		<imprint>
			<date type="published" when="2021-08">2021. August-2021</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<ptr target="http://www.openvswitch.org/support/dist-docs/ovn-architecture.7.html" />
		<title level="m">The Open Virtual Network architecture: Tunnel Encapsulations</title>
		<imprint>
			<date type="published" when="2018-08">2018. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">BOLT: A Practical Binary Optimizer for Data Centers and Beyond</title>
		<author>
			<persName><forename type="first">Maksim</forename><surname>Panchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Auler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bill</forename><surname>Nell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guilherme</forename><surname>Ottoni</surname></persName>
		</author>
		<idno type="DOI">10.5555/3314872.3314876</idno>
		<ptr target="https://dl.acm.org/doi/10.5555/3314872.3314876" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 IEEE/ACM International Symposium on Code Generation and Optimization</title>
		<meeting>the 2019 IEEE/ACM International Symposium on Code Generation and Optimization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="page" from="2" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">NetBricks: Taking the V out of NFV</title>
		<author>
			<persName><forename type="first">Aurojit</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangjin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keon</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Melvin</forename><surname>Walls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvia</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/osdi16/technical-sessions/presentation/panda" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Conference on Operating Systems Design and Implementation</title>
		<meeting>the 12th USENIX Conference on Operating Systems Design and Implementation<address><addrLine>Savannah, GA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association, USA</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="203" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Automated Synthesis of Adversarial Workloads for Network Functions</title>
		<author>
			<persName><forename type="first">Luis</forename><surname>Pedrosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rishabh</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arseniy</forename><surname>Zaostrovnykh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonas</forename><surname>Fietz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katerina</forename><surname>Argyraki</surname></persName>
		</author>
		<idno type="DOI">10.1145/3230543.3230573</idno>
		<ptr target="https://doi.org/10.1145/3230543.3230573" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 Conference of the ACM Special Interest Group on Data Communication</title>
		<meeting>the 2018 Conference of the ACM Special Interest Group on Data Communication<address><addrLine>Budapest, Hungary; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="372" to="385" />
		</imprint>
	</monogr>
	<note>SIGCOMM &apos;18)</note>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Scaling up Superoptimization</title>
		<author>
			<persName><forename type="first">Phitchaya</forename><surname>Mangpo Phothilimthana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Thakur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rastislav</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dinakar</forename><surname>Dhurjati</surname></persName>
		</author>
		<idno type="DOI">10.1145/2872362.2872387</idno>
		<ptr target="https://doi.org/10.1145/2872362.2872387" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems<address><addrLine>Atlanta, Georgia, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="297" to="310" />
		</imprint>
	</monogr>
	<note>ASPLOS &apos;16)</note>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">SymPerf: Predicting Network Function Performance</title>
		<author>
			<persName><forename type="first">Felix</forename><surname>Rath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Krude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>R?th</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Schemmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oliver</forename><surname>Hohlfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J?</forename><forename type="middle">?</forename><surname>Bitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Wehrle</surname></persName>
		</author>
		<idno type="DOI">10.1145/3123878.3131977</idno>
		<ptr target="https://doi.org/10.1145/3123878.3131977" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCOMM Posters and Demos</title>
		<meeting>the SIGCOMM Posters and Demos<address><addrLine>Los Angeles, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="34" to="36" />
		</imprint>
	</monogr>
	<note>SIGCOMM Posters and Demos &apos;17)</note>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<title level="m" type="main">Dynamic Compilation and Optimization of Packet Processing Programs</title>
		<author>
			<persName><forename type="first">G?bor</forename><surname>R?tv?ri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L?szl?</forename><surname>Moln?r</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G?bor</forename><surname>Enyedi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gergely</forename><surname>Pongr?cz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
			<publisher>ACM SIGCOMM NetPL</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Ribas</surname></persName>
		</author>
		<ptr target="https://github.com/FraudBuster/dpdk-burst-replay" />
		<title level="m">DPDK burst replay tool</title>
		<imprint>
			<date type="published" when="2019-08">2019. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Netmap: A Novel Framework for Fast Packet I/O</title>
		<author>
			<persName><forename type="first">Luigi</forename><surname>Rizzo</surname></persName>
		</author>
		<idno type="DOI">10.5555/2342821.2342830</idno>
		<ptr target="https://dl.acm.org/doi/10.5555/2342821.2342830" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 USENIX Conference on Annual Technical Conference</title>
		<meeting>the 2012 USENIX Conference on Annual Technical Conference<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>USENIX ATC&apos;12). USENIX Association, USA, 9</note>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
		<author>
			<persName><forename type="first">Raimondas</forename><surname>Sasnauskas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Collingbourne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeroen</forename><surname>Ketema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jubi</forename><surname>Taneja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Regehr</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1711.04422" />
		<title level="m">Souper: A Synthesizing Superoptimizer</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Design and Implementation of a Consolidated Middlebox Architecture</title>
		<author>
			<persName><forename type="first">Norbert</forename><surname>Vyas Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvia</forename><surname>Egi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guangyu</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><surname>Shi</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/nsdi12/technical-sessions/presentation/sekar" />
	</analytic>
	<monogr>
		<title level="m">Presented as part of the 9th USENIX Symposium on Networked Systems Design and Implementation (NSDI 12)</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="323" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">The Case for an Intermediate Representation for Programmable Data Planes</title>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Feamster</surname></persName>
		</author>
		<idno type="DOI">10.1145/2774993.2775000</idno>
		<ptr target="https://doi.org/10.1145/2774993.2775000https://doi.org/10.1145/2774993.2775000" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM SIGCOMM Symposium on Software Defined Networking Research</title>
		<meeting>the 1st ACM SIGCOMM Symposium on Software Defined Networking Research<address><addrLine>Santa Clara, California; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>SOSR &apos;15). Article 3, 6 pages</note>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">The Case for an Intermediate Representation for Programmable Data Planes</title>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Feamster</surname></persName>
		</author>
		<idno type="DOI">10.1145/2774993.2775000</idno>
		<ptr target="https://doi.org/10.1145/2774993.2775000" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM SIGCOMM Symposium on Software Defined Networking Research</title>
		<meeting>the 1st ACM SIGCOMM Symposium on Software Defined Networking Research<address><addrLine>Santa Clara, California; New York, NY, USA, Article</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>SOSR &apos;15)</note>
</biblStruct>

<biblStruct xml:id="b87">
	<monogr>
		<author>
			<persName><surname>Sourcefire</surname></persName>
		</author>
		<ptr target="https://www.snort.org/" />
		<title level="m">Snort -Network Intrusion Detection &amp; Prevention System</title>
		<imprint>
			<date type="published" when="2020-08">2020. August-2021</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<monogr>
		<title level="m" type="main">What can cause my code to run slower when the server JIT is activated</title>
		<author>
			<persName><surname>Stackoverflow</surname></persName>
		</author>
		<ptr target="https://stackoverflow.com/questions/2923989/what-can-cause-my-code-to-run-slower-when-the-server-jit-is-activated" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">NFP: Enabling Network Function Parallelism in NFV</title>
		<author>
			<persName><forename type="first">Chen</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Bi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhilong</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heng</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongxin</forename><surname>Hu</surname></persName>
		</author>
		<idno type="DOI">10.1145/3098822.3098826</idno>
		<ptr target="https://doi.org/10.1145/3098822.3098826" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference of the ACM Special Interest Group on Data Communication</title>
		<meeting>the Conference of the ACM Special Interest Group on Data Communication<address><addrLine>Los Angeles, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="43" to="56" />
		</imprint>
	</monogr>
	<note>SIGCOMM &apos;17)</note>
</biblStruct>

<biblStruct xml:id="b90">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><forename type="middle">S</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><surname>Turner</surname></persName>
		</author>
		<ptr target="https://www.arl.wustl.edu/classbench/" />
		<title level="m">Classbench Filter Set &amp; Trace Generator</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Classbench: A packet classification benchmark</title>
		<author>
			<persName><forename type="first">E</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><forename type="middle">S</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><surname>Turner</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNET.2007.893156</idno>
		<ptr target="https://doi.org/10.1109/TNET.2007.893156" />
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM transactions on networking</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="499" to="511" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">P2GO: P4 Profile-Guided Optimizations</title>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Wintermeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maria</forename><surname>Apostolaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Dietm?ller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Vanbever</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hot Topics in Networks (HotNets)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<monogr>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Worthington</surname></persName>
		</author>
		<ptr target="https://6guts.wordpress.com/2018/09/29/eliminating-unrequired-guards/" />
		<title level="m">Eliminating unrequired guards</title>
		<imprint>
			<date type="published" when="2018-08">2018. August-2021</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<monogr>
		<title level="m" type="main">Unimog -Cloudflare&apos;s edge load balancer</title>
		<author>
			<persName><forename type="first">David</forename><surname>Wragg</surname></persName>
		</author>
		<ptr target="https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Leveraging EBPF for Programmable Network Functions with IPv6 Segment Routing</title>
		<author>
			<persName><forename type="first">Fabien</forename><surname>Mathieu Xhonneux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Duchene</surname></persName>
		</author>
		<author>
			<persName><surname>Bonaventure</surname></persName>
		</author>
		<idno type="DOI">10.1145/3281411.3281426</idno>
		<ptr target="https://doi.org/10.1145/3281411.3281426" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Emerging Networking EXperiments and Technologies</title>
		<meeting>the 14th International Conference on Emerging Networking EXperiments and Technologies<address><addrLine>Heraklion, Greece; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="67" to="72" />
		</imprint>
	</monogr>
	<note>CoNEXT &apos;18)</note>
</biblStruct>

<biblStruct xml:id="b96">
	<monogr>
		<author>
			<persName><forename type="first">Yonghong</forename><surname>Song</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/797808/" />
		<title level="m">bpf: adding map batch processing support</title>
		<imprint>
			<date type="published" when="2019-08">2019. August-2021</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Don&apos;t Forget the I/O When Allocating Your LLC</title>
		<author>
			<persName><forename type="first">Yifan</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Alian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yipeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ren</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilia</forename><surname>Kurakin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charlie</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nam</forename><forename type="middle">Sung</forename><surname>Kim</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISCA52012.2021.00018</idno>
		<ptr target="https://doi.org/10.1109/ISCA52012.2021.00018" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual International Symposium on Computer Architecture (Virtual Event, Spain) (ISCA &apos;21)</title>
		<meeting>the 48th Annual International Symposium on Computer Architecture (Virtual Event, Spain) (ISCA &apos;21)</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="112" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Micro-Specialization: Dynamic Code Specialization of Database Management Systems</title>
		<author>
			<persName><forename type="first">Rui</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saumya</forename><surname>Debray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</author>
		<idno type="DOI">10.1145/2259016.2259025</idno>
		<ptr target="https://doi.org/10.1145/2259016.2259025" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth International Symposium on Code Generation and Optimization</title>
		<meeting>the Tenth International Symposium on Code Generation and Optimization<address><addrLine>San Jose, California; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="63" to="73" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
