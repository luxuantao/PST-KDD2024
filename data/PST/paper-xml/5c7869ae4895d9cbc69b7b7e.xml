<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Toward a Common Component Architecture for High-Performance Scientific Computing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rob</forename><surname>Armstrong</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Dennis</forename><surname>Gannon</surname></persName>
							<email>gannon@cs.indiana.edu</email>
						</author>
						<author>
							<persName><forename type="first">Al</forename><surname>Geist</surname></persName>
							<email>geist@msr.epm.ornl.gov</email>
						</author>
						<author>
							<persName><forename type="first">Katarzyna</forename><surname>Keahey</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Scott</forename><surname>Kohn</surname></persName>
							<email>skohn@llnl.gov.</email>
						</author>
						<author>
							<persName><forename type="first">Lois</forename><surname>McinnesÂ¦</surname></persName>
							<email>mcinnes@mcs.anl.gov.</email>
						</author>
						<author>
							<persName><forename type="first">Steve</forename><surname>Parker</surname></persName>
							<email>sparker@taz.cs.utah.edu</email>
						</author>
						<author>
							<persName><forename type="first">Brent</forename><surname>Smolinski</surname></persName>
							<email>smolinski1@llnl.gov</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Indiana University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Advanced Computing Laboratory</orgName>
								<orgName type="institution">Los Alamos National Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Center for Applied Scientific Computing</orgName>
								<address>
									<settlement>Lawrence Livermore Na-tional Laboratory</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Center for Applied Scientific Computing</orgName>
								<address>
									<settlement>Lawrence Livermore Na-tional Laboratory</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Toward a Common Component Architecture for High-Performance Scientific Computing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">14A5C38476BC660D5D3B399DC95302D2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes work in progress to develop a standard for interoperability among high-performance scientific components. This research stems from growing recognition that the scientific community needs to better manage the complexity of multidisciplinary simulations and better address scalable performance issues on parallel and distributed architectures. Driving forces are the need for fast connections among components that perform numerically intensive work and for parallel collective interactions among components that use multiple processes or threads. This paper focuses on the areas we believe are most crucial in this context, namely, an interface definition language that supports scientific abstractions for specifying component interfaces and a ports connection model for specifying component interactions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The complexity and resource demands of present-day software systems create the need for more flexible solutions than those offered by conventional programming styles based on a succession of subroutine calls. One solution is component programming, based on encapsulating units of functionality and providing a meta-language specification of their interfaces. Component-based software development can be considered an evolutionary step beyond object-oriented design. Object-oriented techniques have been very successful in managing the complexity of modern software, but they have not resulted in significant amounts of cross-project code reuse. Sharing objectoriented code is difficult because of language incompatibilities, the lack of standardization for inter-object communication, and the need for compile-time coupling of interfaces. Component-based software development addresses issues of language independence-seamlessly combining components written in different programming languagesand component frameworks define standards for communication among components.</p><p>These advantages are especially appealing in highperformance scientific computing, where high-fidelity, multi-physics simulations are increasingly complex and often require the combined expertise of multidisciplinary research teams working in areas such as mathematical modeling, adaptive mesh manipulations, numerical linear and nonlinear algebra, optimization, load balancing, computational steering, parallel I/O, sensitivity analysis, visualization, and data analysis. Consequently, the interoperability and rapid application development afforded by component programming are of particular importance, as they help to support incremental shifts in parallel algorithms and programming paradigms that inevitably occur during the lifetimes of scientific application codes. In addition, since components can be configured to execute in remote locations, component programming can offer high-level abstractions that facilitate the use of distributed supercomputing resources, which have been shown to offer powerful potential <ref type="bibr" target="#b19">[21]</ref>.</p><p>Many differing opinions about component definitions exist within the software community <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b43">47]</ref>. We present some working definitions as preliminaries for further discussion.</p><p>A component is an independent unit of software deployment. It satisfies a set of behavior rules and implements standard component interfaces that allow it to be composed with other components. These behavior rules are often specified as design patterns that must be followed when writing the component.</p><p>A component integration framework is an implementation of a set of interfaces and rules of interaction that govern the communication among components.</p><p>A component architecture is a specification of a set of interfaces and rules of interaction that govern the communication among components and other necessary tools, such as repositories and composition tools.</p><p>We have recently established the Common Component Architecture (CCA) Forum [15], a group whose current membership is drawn from various Department of Energy national laboratories and collaborating academic institutions. The goal of the CCA Forum is to specify a component architecture for high-performance computing, where our target architectures include workstation networks, distributed-memory multiprocessors, clusters of symmetric multiprocessors, and remote resources. We hope that this work will lay a foundation for the definition of standardized sets of domain-specific component interfaces and for the interoperability among toolkits developed by different teams across different institutions. The purpose of this paper is to discuss the current CCA specification and to present progress of the group to date.</p><p>The software industry has defined component standards such as CORBA <ref type="bibr" target="#b37">[40]</ref>, COM <ref type="bibr" target="#b41">[45]</ref>, and JavaBeans <ref type="bibr" target="#b17">[19]</ref> to address similar complexities within their target applications (see Section 3 for a detailed discussion). Our approach leverages this work where appropriate, but addresses the distinctly different technical challenges of large-scale scientific simulations. Based on the lessons learned from research projects in high-performance component architectures by CCA participants (see, e.g., <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b40">44,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr">32,</ref><ref type="bibr" target="#b33">36,</ref><ref type="bibr" target="#b34">37]</ref>) and projects considering related design issues (see, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b21">23,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr" target="#b5">6]</ref>), we are developing a single component interface specification that will enable interactions among scientific components that follow this standard. Additional related work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b32">35]</ref> can be found elsewhere.</p><p>We recognize two levels of interoperability: componentlevel interoperability, for which all the vital functions of any one architecture are accessible to any compliant component through a standard interface (e.g., facilities available within a CORBA ORB), and framework-level interoperability, for which the frameworks themselves interoperate through a standardized interface (e.g., inter-ORB communication via CORBA IIOP). Providing component-level interoperability requires defining an interaction model common to all components and a small set of indispensable highlevel framework services. In addition to these requirements, framework-level interoperability necessitates the standardization of a number of low-level services. Since defining a standard for interoperability at the framework level requires a superset of features needed for the component level, our focus is on providing the latter now and extending it in the future to include framework-level interoperability features. The scope of this paper is limited to component-level interoperability.</p><p>The remainder of this paper motivates and explains our approach, beginning in Section 2 with a discussion of some of the challenges in large-scale scientific computing. Section 3 compares our strategy with related work in the software industry. Section 4 presents a high-level view of the CCA standard and provides a roadmap outlining the relationships among its constituents. Sections 5 and 6 describe in detail the parts of the CCA standard that are most crucial for defining component interactions in high-performance scientific software, namely, a scientific interface definition language and a "ports" component linking and composition model with direct-connect and collective capabilities. Finally, Section 7 outlines future directions of work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivating Examples</head><p>Our work is motivated by collaborations with various computational science research teams, who are investigating areas such as combustion <ref type="bibr" target="#b13">[14]</ref>, microtomography <ref type="bibr" target="#b44">[48]</ref>, particle beam dynamics <ref type="bibr" target="#b28">[30]</ref>, mold filling <ref type="bibr" target="#b29">[31]</ref>, and plasma simulation <ref type="bibr" target="#b39">[43]</ref>. In conjunction with theoretical and experimental research, these simulations are playing increasingly important roles in overall scientific advances, particularly in fields where experiments are prohibitively expensive, time consuming, or in some cases impossible. While each of these simulations requires different mathematical models, numerical methods, and data analysis techniques, they could all benefit from infrastructure that is more flexible and extensible and therefore better able to manage complexity and change.</p><p>To enable a more concrete discussion of the CCA approach, we briefly review some challenges arising in chemically reacting flow simulations, which have demanding requirements for high resolution and complex physical submodels for turbulence, chemistry, and multiphase flows. Section 2.1 presents current functionality of a particular application, while Section 2.2 describes potential enhancements that component-based technology could help to support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Computational Hydrodynamics Example</head><p>We consider the CHAD (Computational Hydrodynamics for Advanced Design) application <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b38">42]</ref> because it exhibits computational requirements common within many of high-performance scientific codes. CHAD has been developed for fluids simulations in the automotive industry under the Supercomputing Automotive Applications Partnership with the United States Council for Automotive Research and five Department of Energy national laboratories (Argonne, Lawrence Livermore, Los Alamos, Oak Ridge, and Sandia). CHAD is the successor of KIVA <ref type="bibr" target="#b1">[2]</ref>, which has become a standard tool for device-level modeling of internal combustion engines. CHAD is intended for automotive design applications such as combustion, interior airflow, under-hood cooling, and exterior flows. Currently, CHAD solves the single-phase, compressible Navier-Stokes equations using an arbitrary Lagrangian-Eulerian formulation with hybrid unstructured meshes and a finite volume discretization scheme. The application was designed from its inception as parallel code using Fortran 90 and encapsulation of nonlocal communication in gather/scatter routines using the Message Passing Interface (MPI) standard <ref type="bibr" target="#b36">[39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Component Challenges and Opportunities</head><p>CHAD researchers are experimenting with numerical strategies ranging from explicit through semi-implicit and even more fully implicit schemes using Newton-type methods. Using semi-implicit and implicit techniques helps to overcome stability and accuracy restrictions on computational timesteps, and thereby can often help to reduce overall time to solution.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> demonstrates some typical interactions among components for a semi-implicit solution procedure within a PDE-based simulation. While a single diagram cannot express the richness of interactions within CHAD, nor the range of functionality needed by our motivating applications, this picture does convey key themes that motivate the CCA approach. We focus on (1) fast interactions between components via a "ports" component linking and composition model that allows direct connections (see Section 6.2), and (2) collective interactions among components that use multiple processes or threads (see Section 6.3). Collective abstractions are important for communication between both tightly coupled and loosely coupled components. For example, Figure <ref type="figure" target="#fig_0">1</ref> demonstrates collective directly connected ports between parallel preconditioner and Krylov solver components. The diagram also shows collective distributed port communication between numerical components of a parallel application and remote visualization tools. The goals of the CCA Forum are to simplify the infusion of new techniques within the lifetimes of existing applications such as CHAD and to facilitate the construction of new models. Interactions among multiple tools that use currentgeneration infrastructure typically require labor-intensive translations between interfaces and data structures. We aim to simplify this process and also to enable dynamic interactions, since researchers may wish to introduce new components during the course of ongoing simulations. For example, a researcher may wish to visualize flow fields on a local workstation by dynamically attaching a visualization tool to an ongoing simulation that is running on a remote parallel machine. Upon observing that the flow fields are not converging as expected, the researcher may wish to introduce a new scheme for hierarchical mesh refinement.</p><p>One of the most computationally intensive phases within the semi-implicit and implicit strategies under consideration within CHAD is the solution of discretized linear systems of the form "! $# , which are very large and have sparse coefficient matrices . The Equation Solver Interface (ESI) Forum <ref type="bibr" target="#b18">[20]</ref> is defining collections of abstract interfaces for solving such systems, with a goal of enabling applications like CHAD to experiment more easily with multiple solution strategies and to upgrade as new algorithms with better latency tolerance or more efficient cache utilization are discovered and encapsulated within toolkits. This area is one of many (e.g., partitioning, mesh management, discretization, optimization, visualization) that could benefit from component-based infrastructure to facilitate experiments among different tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Relationship to Existing Standards</head><p>Component architecture standards such as CORBA <ref type="bibr" target="#b37">[40]</ref>, COM <ref type="bibr" target="#b41">[45]</ref>, and JavaBeans <ref type="bibr" target="#b17">[19]</ref> have been defined by industrial corporations and consortia and are employed by millions of users. Unfortunately, these standards do not address the needs of high-performance scientific computing, primarily because they do not support efficient parallel communication channels between components. Abstractions suitable for high-performance computing are needed. The existence of many successful high-performance languages and libraries-such as HPC++ <ref type="bibr" target="#b22">[24]</ref>, POOMA <ref type="bibr" target="#b3">[4]</ref>, ISIS++ <ref type="bibr" target="#b11">[12]</ref>, SAMRAI <ref type="bibr" target="#b27">[29]</ref>, and PETSc <ref type="bibr" target="#b4">[5]</ref>-testifies that such abstractions can enable the user to develop more efficient programs faster. Similarly, we need abstractions that capture high-performance concepts in component architectures. For example, PARDIS <ref type="bibr" target="#b34">[37]</ref> and PAWS <ref type="bibr" target="#b5">[6]</ref> successfully show that introducing abstractions for single program multiple data (SPMD) computation can enable more efficient interactions between SPMD programs. In this section, we briefly review these industry standards and explain their limitations for high-performance scientific computing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Microsoft COM and ActiveX</head><p>COM (Component Object Model) is Microsoft's component standard that forms the basis for interoperability among all Window-based applications. ActiveX <ref type="bibr" target="#b10">[11]</ref> defines standard COM interfaces for compound documents. Microsoft has developed a distributed version of COM, called DCOM, that targets networked Windows workstations.</p><p>COM targets business objects and does not include abstractions for parallel data layout or basic scientific computing data types, such as complex numbers and Fortranstyle dynamic multidimensional arrays. Also, COM does not easily support implementation inheritance and multiple inheritance (which can be implemented through aggregation or containment). Some scientific libraries (see, e.g., <ref type="bibr" target="#b18">[20]</ref>) require multiple inheritance and a simple model for polymorphism, which COM does not provide.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Sun JavaBeans and Enterprise JavaBeans</head><p>JavaBeans and Enterprise JavaBeans (EJB) are component architectures developed by Sun and its partners. They are based on Sun's Java programming language and are cross-platform competitors to Microsoft's COM.</p><p>Neither JavaBeans nor EJB directly addresses the issue of language interoperability, and therefore neither is appropriate for the scientific computing environment. Both JavaBeans and EJB assume that all components are written in the Java language. Although the Java Native Interface <ref type="bibr" target="#b31">[34]</ref> library supports interoperability with C and C++, using the Java virtual machine to mediate communication between components would incur an intolerable performance penalty on every intercomponent function call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">OMG CORBA</head><p>CORBA is a distributed object specification supported by the OMG (Object Management Group), a consortium of over eight hundred partners. CORBA supports the interaction of complex objects written in different languages distributed across a network of computers running different operating systems.</p><p>The current CORBA specification does not define a component model, although a CORBA 3.0 component specification [41] is currently under review by the OMG. Like COM, CORBA does not provide abstractions necessary for high-performance scientific computing, such as Fortranstyle dynamic multi-dimensional arrays and complex numbers. Although CORBA enables robust and efficient implementations for distributed applications, it is far too inefficient when a method call is made within the same address space. While a recently established high-performance CORBA working group <ref type="bibr" target="#b26">[28]</ref> may eventually address a subset of our performance concerns, their mandate does not address the range of parallel computing issues, as discussed in Section 2. CORBA also has a limited object model in that method overriding is not supported and the semantics of multiple implementation inheritance can lead to ambiguities.</p><p>While CORBA 2.0 does not provide for a component interaction mechanism, the CCA specification does. It should be observed that the CORBA object model is sufficiently powerful to suppport an implementation of the CCA. This is a good example of the intent of the CCA specification: a layer on top of an existing system that enables highperformance computing. Such a "CCA over CORBA" implementation, targeting distributed environments, is being planned by one of the participating forum members.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Overview of the CCA Standard</head><p>We define the Common Component Architecture as a set of specifications and their relationships as depicted in Figure <ref type="figure" target="#fig_1">2</ref>. The elements with gray background pertain to specific implementations of a component architecture, while the elements with white background depict parts of the CCA standards necessary for component-level interoperability.</p><p>As shown in the picture, components interact with each other and with a specific framework implementation through standard application programming interfaces (APIs). Each component can define its inputs and outputs by using a scientific interface definition language (SIDL); these definitions can be deposited in and retrieved from a repository by using a CCA Repository API. The repository API defines the functionality necessary to search a framework repository for components as well as to manipulate components within the repository. In addition, these component definitions can serve as input to a proxy generator that generates component stubs, which form the component-specific part of the CCA Ports. Components can use framework services directly through the CCA Services interface. The CCA Configuration API supports interaction between components and various builders for functions such as notifying components that they have been added to a scenario and deleted from it, redirecting interactions between components, or notifying a builder of a component failure.</p><p>A component framework is said to be CCA compliant if it conforms to these standards-that is, provides the required CCA services and implements the required CCA interfaces. Different components require different sets of services to interoperate. For example, some will require remote communication while others communicate only in the same address space. Therefore, the CCA standard will allow different flavors of compliance; each component will specify a minimum flavor of compliance required of a framework within which it can interact. We will now describe in some detail three elements of the CCA standard that we believe are most critical for highperformance scientific computing, namely, a scientific interface definition language, a ports model, and a minimal set of supporting services. Work on the other parts of the CCA standard is also in progress, but details are beyond the scope of this paper.</p><p>SIDL is a programming-language-neutral interface definition language used to describe component interfaces. The SIDL provides a method for describing component and framework interfaces that is independent of the underlying implementation programming languages. Component descriptions using SIDL can be used by repositories and by a proxy generator to provide the component stubs element of communication ports.</p><p>CCA Ports define the communication model for all component interactions. Each component defines one or more ports to describe the calling interface. Communication links between components are implemented by connecting compatible ports, where port compatibility is defined as object-oriented type compatibility of the port interfaces, as can be described in the SIDL. As shown in Figure <ref type="figure" target="#fig_1">2</ref>, each port has two parts. The first part is a set of framework-specific but component-independent functionality pertaining to component interaction (e.g., adding a listener to an object) and has the same API for every component. The second part implements component-specific but framework-independent functionality; this part can be generated automatically by a proxy generator based on the component definition expressed in SIDL, and is referred to as a component stub. For example, a component stub may contain marshaling functions in a distributed environment.</p><p>CCA Services present a framework abstraction that can be used in the component stub implementation as well as by the components themselves; this CCA element provides a clear definition of the minimal services a framework must implement in order to be CCA compliant. Two critical concerns guiding this design are that the services enable high-performance interactions and that the services are sufficiently compact and user friendly to enable a rapid learning process for component writers, many of whom will not be computer scientists. As such, we have identified that the key CCA services are creation of CCA Ports and access to CCA Ports, which in turn enable connections between components.</p><p>Additional common facilities to handle naming, relationship management, error handling, querying, and so forth are of course also important, because in practice many components would need and could share these facilities. However, because the particular needs of different components and frameworks vary considerably depending on usage environment, discussion of these issues is beyond the scope of this paper.</p><p>The following sections describe these features in more detail. A reference implementation is tracking the evolution of the Common Component Architecture. Likewise, several ongoing computational science projects are experimenting with the CCA to manage interoperability among components developed by different research groups; these experiences will motivate further extensions and refinements to design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">The Scientific IDL</head><p>The Scientific Interface Definition Language is a highlevel description language used to specify the calling interfaces of software components and framework APIs in the component architecture. SIDL provides language interoperability that hides language dependencies to simplify the interoperability of components written in different programming languages. With the proliferation of languages used for numerical simulation-such as C, C++ , Fortran 77, Fortran 90, Java, and Python-the lack of seamless language interoperability can be a significant barrier to developing reusable scientific components.</p><p>For the purposes of our high-performance scientific component architecture, SIDL must be sufficiently expressive to represent the abstractions and data types common in scientific computing, such as dynamically dimensioned multidimensional arrays and complex numbers. Unfortunately, no such IDL currently exists, since most IDLs have been designed for operating systems <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b16">18]</ref> or for distributed client-server computing in the business domain <ref type="bibr" target="#b30">[33,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b42">46]</ref>.</p><p>The basic design of our scientific IDL borrows many concepts from current standards, such as the CORBA IDL <ref type="bibr" target="#b37">[40]</ref> and the Java programming language <ref type="bibr" target="#b25">[27]</ref>. This approach allows us to leverage existing IDL technology and language mappings. For example, CORBA already defines language mappings to C, C++ , and Java, and ILU <ref type="bibr" target="#b30">[33]</ref> (which supports the CORBA IDL) defines language mappings to Python.</p><p>The scientific IDL provides additional capabilities necessary for scientific computing <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b35">38]</ref>. It supports objectoriented semantics with an inheritance model similar to that of Java with multiple interface inheritance and single implementation inheritance. IDL support for multiple inheritance with method overriding is essential for scientific libraries that exploit polymorphism through multiple inheritance, such as used in the Equation Solver Interface <ref type="bibr" target="#b18">[20]</ref> standard. The IDL and associated run-time system provide facilities for cross-language error reporting. We have also added IDL primitive data types for complex numbers and multidimensional arrays for expressibility and efficiency when mapping to implementation languages.</p><p>We are developing SIDL support for reflection and dynamic method invocation, which are important capabilities for a component architecture. Interface information for dynamically loaded components is often unavailable at compile time; thus, components and the associated composition tools and frameworks must discover, query, and execute methods at run time. The SIDL reflection and dynamic method invocation mechanisms are based on the design of the Java library classes in java.lang and java.lang.reflect. Reflection information for every interface and class will be generated automatically by the SIDL compiler based on IDL descriptions.</p><p>Our SIDL implementation currently supports language mappings for both C and Fortran 77, and support for C++ is under development. The Fortran 77 language mapping is similar to the C language mapping defined by CORBA except that SIDL interfaces and classes are mapped to Fortran integers instead of opaque data types. The SIDL run-time environment automatically manages the translation between the Fortran integer representation and the actual object reference. The Fortran 90 language mapping is still under development. Fortran 90 is a particular challenge for scientific language interoperability, because Fortran 90 calling conventions and array descriptors vary widely from compiler to compiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Component Interaction through Ports</head><p>Every component architecture is characterized by the way in which components are composed together into applications. As introduced in Section 4, CCA Ports are communication end points that define the connection model for component interactions. Within Figure <ref type="figure" target="#fig_0">1</ref>, ports define the interactions between relatively tightly coupled parallel numerical components, which typically require very fast communication for scalable performance; ports also define loosely coupled interactions with possibly remote components that monitor, analyze, and visualize data.</p><p>To address this range of requirements, we adopt a provides/uses interface exchange mechanism, similar to that within the CORBA 3.0 proposal <ref type="bibr">[41]</ref>. This approach enables connections that do not impede inter-component performance, yet allows a framework to create distributed connections when desired. In the ideal case, an attached component would react as quickly as an inline function call. We refer to this situation as direct connection, which is further discussed in Section 6.2. This type of connection makes the most sense when the component instances exist in the same address space. Loosely coupled distributed connections should be available through the very same interface as the tightly coupled direct connections, without the components being aware of the connection type. This need arises because high-performance components will often be parallel programs themselves. A parallel component may reside inside a single multiprocessor or it may be distributed across many different hosts. Existing component models have no concept of attaching two parallel components together, and existing research systems, such as CU-MULVS <ref type="bibr" target="#b24">[26]</ref>, PAWS <ref type="bibr" target="#b5">[6]</ref>, and PARDIS <ref type="bibr" target="#b34">[37]</ref>, approach this problem in different ways. We therefore introduce a collective port model to enable interoperability between parallel components, as discussed in Section 6.3.</p><p>In the JavaBeans model <ref type="bibr" target="#b17">[19]</ref>, components notify other listener components by generating events. Components that wish to be notified of events register themselves as listeners with the target components. Although there are some similarities to the CCA specification, JavaBeans does not allow a provides/uses design pattern as part of its standard. In the COM/DCOM model <ref type="bibr" target="#b41">[45]</ref>, one component calls the interface functions exported by another. The COM model is very similar in form to the CCA specification. Platform interoperability issues are, in the opinion of the CCA working group, important enough that COM has not been not adopted outright. In the proposed CORBA 3.0 component model <ref type="bibr">[41]</ref>, both events and a provides/uses interface model are used. The provides/uses pattern employed by the CCA is very close to this proposed approach, and any component that is CCA compliant will likely map easily to CORBA 3.0. However, at the time of this writing, CORBA 3.0 is a proposed standard that is still undergoing rapid change, and CORBA 3.0 may see no implementation for years. The CCA working group believes that a compatible standard for high-performance computing should appear much more quickly than the CORBA 3.0 time frame. For this reason we have chosen the provides/uses pattern for use as the CCA Ports architecture. It is expected (and hoped) that the CORBA 3.0 specification will not drift far from what is described here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The Basics of CCA Ports</head><p>The concept of CCA Ports arises from the data-flow world, where component interactions are limited to pipelining data from one component to the next. CCA Ports generalize this idea to admit method calls and return values along the pipeline, allowing for a richer variety of component interactions. Links between components are implemented by a provides/uses interface design pattern, which is flexible enough to allow direct component interface connections for high performance or connections through proxy intermediaries enabling distributed object interactions. Significantly, in the CCA model, port connection is the responsibility of the framework; therefore, a particular component may find itself connected in a variety of different ways depending on its environment and mode of use (see <ref type="bibr" target="#b8">[9]</ref> for details of the CCA ports specification and an applet demonstration).</p><p>In the CCA architecture, components are linked together by connecting a "port" interface from one component to a "port" interface on another. As demonstrated in Figure <ref type="figure">3</ref>, we employ two types of ports: Provides port. A Provides port is an interface that a component provides to others.</p><p>Uses port. A Uses port interface has methods that one component (the caller) wants to call on another component (the callee); the caller component retrieves the Uses interface from the CCA Services handle. Provides ports are generalized listeners in the sense that they listen to Uses interfaces (i.e., calls of their functions by another component). Each Uses port maintains a list of listeners. To connect one component to another, one adds a Provides (input) port of one component to another's Uses (output) port. This approach follows many features of the proposed CORBA 3.0 design. When a component calls a member function on one of its Uses ports, the same member function on each listening Provides port is called. Note that this means one call may correspond to zero or more invocations on provider components.</p><p>As introduced in Section 4, all interaction between the component and its containing framework will occur through the component's CCAServices object, which is set by the containing framework. The component creates and adds Provides ports to the CCAServices, and registers and retrieves Uses ports from the CCAServices. The CCAServices enables access to the list of Provides and Uses ports and to an individual port by its instance name. It also implements a method for obtaining the various ports and registering them with the framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Direct-Connect Ports</head><p>Much of the reason for adopting the provides/uses interface exchange mechanism for connecting CCA components is to enable high-performance computing. Except for the SIDL bindings to UsesPort and ProvidesPort interfaces, the overhead for the privilege of becoming a CCA component is nothing more than a direct function call to the connected object. That is, there is no penalty for using the provides/uses component connection mechanism proposed in the CCA specification. The cost of the intervening SIDL binding for language independence is estimated to be approximately 2-3 function calls per interface method call.</p><p>Components can be directly connected in a variety of ways; probably the simplest is to create an object that exports a DirectConnectPort interface subclassing both the UsesPort and ProvidesPort interfaces. This way the framework gets a Provides interface from one component and gives that same interface directly to a connecting component as a Uses interface. Note that with this approach the framework still retains full control over the connection between components. Optionally, the provided DirectConnectPort can be translated through a proxy by a separate UsesPort provided by the framework, without the components on either end of the connection needing to know.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Collective Ports</head><p>The concept of Collective Ports is a small but powerful extension of the basic CCA Ports model to handle interactions among parallel components and thereby to free programmers from focusing on the often intricate implementation-level details of parallel computations. The provides/uses port interfaces and other port information are accessible from every thread or process in a parallel component. The CCA standard does not place any restrictions on the means by which particular implementations address this. For example, in a distributed-memory model a copy of these classes could be maintained by every process participating in computation, whereas in shared memory a class could be represented just once. However, the CCA standard does require that as one of the CCA services the implementation maintain consistency among the classes.</p><p>The creation of a collective port requires that the programmer specify the mapping of data (or processes participating) in the operations on this port. In the most common case the mappings of the input and output ports match each other. For example, n processes or threads in one component are mapped to n processes or threads in the other, and in this case data would not need redistribution between the parallel components. In the second most common case, a serial component interacts with a parallel component. The semantics of this interaction are very similar to broadcast, gather, and scatter semantics used in collective communication. Collective ports are defined generally enough to allow data to be distributed arbitrarily in the connected components; as demonstrated in Figure <ref type="figure" target="#fig_0">1</ref>, this capability is useful in connecting a parallel numerical simulation with differently distributed visualization tools. We are investigating issues in the behavior of information flow between collective ports, especially in cases of mismatch in cardinality, time, and space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Future Directions</head><p>This discussion has introduced the foundation for research by the CCA forum in defining a common component architecture that supports the needs of the highperformance scientific computing community and leverages existing component standards, but will likely not be addressed by them. Key facets of this work are development of an IDL that supports scientific abstractions for component interface specification and definition of a ports connection model that supports collective interactions. This architecture enables connections that do not impede intercomponent performance, yet allows a framework to create distributed connections when desired. Currently, we are implementing various Ports subclasses that relate directly to high-performance computing. Among these are the collective ports discussed earlier, a component based on a numeric solvers standard <ref type="bibr" target="#b18">[20]</ref>, and a reference implementation of a CCA-compliant framework (see <ref type="bibr">[15]</ref> for further information). Other proposals for components and standard interfaces compliant with the current CCA Ports specification are openly solicited.</p><p>Future plans include incorporating support for different computational models (e.g., SPMD and threaded models) and extending the definition of CCA Ports to accommodate dynamic component hook-up and configuration. Some changes to the existing port specification are inevitable as we gain experience with actual high-performance components. Currently, the CCA specification makes no provision for framework services beyond Ports. At this moment a proposal is being crafted for gaining access through the existing CCA specification to services provided by existing frameworks, such as CORBA or Enterprise JavaBeans. It does not seem likely that the CCA working group will decide to require any of these services to be present. This is because high-performance environments are often exotic, and requiring services may limit some of the intended audience for this specification.</p><p>Beyond these modifications and clarifications to the existing standard, the CCA working group will function as a standards body, incorporating or rejecting proposed port and component additions to the essential core of the standard. This phase of our activity has just begun, but is vital to the success of our mission. Our goal is to incorporate enough standard interfaces and components to make plugand-play high-performance computing a reality. This is an impossibly tall order for the CCA members to accomplish by themselves. However, by incorporating components and interfaces from interested researchers and consortia, it is hoped that this vision can be realized.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Diagram of component interactions. Parallel numerical components that use distributed data structures and require interconnections with low latency and high bandwidth are represented in the upper portion of the figure. Components for visualization, which can often be more loosely coupled and differently distributed than the numerical components, are shown in the figure's lower portion. Communication within a parallel component is at the discretion of the component itself. For example, in this diagram component A (a mesh) uses MPI to communicate among the four processes over which it is distributed, while component E (a visualization tool) uses shared memory. Communication between components is handled by ports.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Relationships among CCAelements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>3 Figure 3 .</head><label>33</label><figDesc>Figure 3. Illustration of the connection mechanism. % '&amp; Â©( The provided interface (i.e., ProvidesPort)is made known to Component 1's containing framework by % 0) 1( passing it to the CCAServices handle via the addProvidesPort() method. % 02 1( At the framework's option, either the interface or a proxy for the interface can be given to Component 2 through its CCAServices handle. % 43 5( Component 2 retrieves the interface using the getPort() method.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The Common Component Architecture (CCA) Forum was initially inspired by the DOE2000 Initiative <ref type="bibr" target="#b14">[16]</ref> and is motivated by ongoing collaborations with various scientific research groups. We especially thank Tom Canfield for conveying some of the challenges in device-scale combustion modeling, as discussed in Section 2.</p><p>The CCA Forum comprises researchers from national laboratories within the Department of Energy and collaborating academic institutions; current participants are Argonne National Laboratory, Indiana University, Lawrence Berkeley National Laboratory, Lawrence Livermore National Laboratory, Los Alamos National Laboratory, Oak Ridge National Laboratory, Sandia National Laboratories, and the University of Utah. The ideas presented here were developed with the participation of various individuals at these institutions, including Ben Allan, Rob Armstrong, Pete Beckman, Randall Bramley, Robert Clay, Andrew Cleary, Dennis Gannon, Al Geist, Paul Hovland, Bill Humphrey, Kate Keahey, Jim Kohl, Scott Kohn, Lois McInnes, Bill Mason, Carl Melius, Brent Milne, NoÃ«l Nachtigal, Steve Parker, Mary Pietrowicz, Barry Smith, Steve Smith, Brent Smolinski, Brian Toonen, and John Wu. These ideas have been influenced by laboratory and university software development teams, some of whose members are represented above.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work has been partially supported by the MICS Division of the U.S. Department of Energy through the DOE2000 Initiative. For further information on the Common Component Architecture Forum, see http://www.acl.lanl.gov/cca-forum or write to</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">ALICE Web page</orgName>
		</author>
		<ptr target="http://www.mcs.anl.gov/-alice" />
		<imprint/>
		<respStmt>
			<orgName>Mathematics and Computer Science Division, Argonne National Laboratory</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">KIVA-II: A computer program for chemically reactive flows with sprays</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Amsden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>O'rourke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">D</forename><surname>Butler</surname></persName>
		</author>
		<idno>LA-11560-MS</idno>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
		</imprint>
		<respStmt>
			<orgName>Los Alamos National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">POET (parallel objectoriented environment and toolkit) and frameworks for scientific distributed computing</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hawaii International Conf. on System Sci</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">POOMA: A highperformance distributed simulation environment for scientific applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Atlas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cummings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Hinker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Srikant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V W</forename><surname>Reynders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tholburn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing &apos;95 Proceedings</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient management of parallelism in object oriented numerical software libraries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Balay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">D</forename><surname>Gropp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Mcinnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modern Software Tools in Scientific Computing</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Arge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Bruaset</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Langtangen</surname></persName>
		</editor>
		<imprint>
			<publisher>Birkhauser Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="163" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient Coupling of Parallel Applications Using PAWS</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Beckman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Fasel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">F</forename><surname>Humphrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Mniszewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th IEEE International Symposium on High Performance Distributed Computation</title>
		<meeting>the 7th IEEE International Symposium on High Performance Distributed Computation</meeting>
		<imprint>
			<date type="published" when="1998-07">July 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Deimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Henn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Koskimies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>PlÃ¡Å¡il</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pomberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pree</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Szyperski</surname></persName>
		</author>
		<title level="m">What characterizes a (software) component? Software -Concepts and Tools</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Application specific tools</title>
		<author>
			<persName><forename type="first">H</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dongarra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Grid: Blueprint for a Future Computing Infrastructure</title>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://z.ca.sandia.gov/-Ëcca-forum/port-spec" />
		<title level="m">CCA Ports Web page</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A world-wide distributed system using Java and the internet</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rifkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Sivilotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mandelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Weisman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing</title>
		<meeting>the Fifth IEEE International Symposium on High Performance Distributed Computing</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996-08">August 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Understanding ActiveX and OLE</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chappell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Microsoft Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Clay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Williams</surname></persName>
		</author>
		<ptr target="http://ca.sandia.gov/isis" />
		<title level="m">ISIS++ Web page</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Language interoperability mechanisms for high-performance scientific computing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cleary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Smolinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIAM Workshop on Object-Oriented Methods for Inter-Operable Scientific and Engineering Computing</title>
		<meeting>the SIAM Workshop on Object-Oriented Methods for Inter-Operable Scientific and Engineering Computing</meeting>
		<imprint>
			<date type="published" when="1998-10">October 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Implicit-explicit Eulerian Godunov scheme for compressible flows</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Colella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Glaz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comp. Phys</title>
		<imprint>
			<biblScope unit="volume">116</biblScope>
			<biblScope unit="page" from="195" to="211" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName><surname>Doe</surname></persName>
		</author>
		<ptr target="http://www.mcs.anl.gov/DOE2000" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Eddon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Eddon</surname></persName>
		</author>
		<title level="m">Inside Distributed COM</title>
		<meeting><address><addrLine>Redmond, WA</addrLine></address></meeting>
		<imprint>
			<publisher>Microsoft Press</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Flexible and optimized IDL compilation for distributed applications</title>
		<author>
			<persName><forename type="first">E</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lepreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Simister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth Workshop on Languages, Compilers, and Run-time Systems for Scalable Computers</title>
		<meeting>the Fourth Workshop on Languages, Compilers, and Run-time Systems for Scalable Computers</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Developing Java Beans</title>
		<author>
			<persName><forename type="first">R</forename><surname>Englander</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
			<pubPlace>O&apos;Reilly</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
		<ptr target="http://-z.ca.sandia.gov/esi/" />
	</analytic>
	<monogr>
		<title level="j">Equation Solver Interface Forum. See</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">I</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kesselman</surname></persName>
		</author>
		<title level="m">The Grid: Blueprint for a Future Computing Infrastructure</title>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Object-based approaches. chapter 10</title>
		<author>
			<persName><forename type="first">G</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Furmanski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Grid: Blueprint for a Future Computing Infrastructure</title>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Infrastructure and interfaces for large-scale numerical software</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Freitag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">D</forename><surname>Gropp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Hovland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Mcinnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 International Conference on Parallel and Distributed Processing Techniques and Applications</title>
		<meeting>the 1999 International Conference on Parallel and Distributed Processing Techniques and Applications</meeting>
		<imprint/>
	</monogr>
	<note>to appear (also available as Argonne preprint ANL/MCS-P751-0599</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Gannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Beckman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Levine</surname></persName>
		</author>
		<title level="m">HPC++ and the HPC++Lib Toolkit. Languages, Compilation Techniques and Run Time Systems (Recent Advances and Future Perspectives)</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Component architectures for distributed scientific problem solving</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bramley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Villacis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Balasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Akman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Breg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Diwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Govindaraju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computational Science and Engineering</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="50" to="63" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">CUMULVS: Providing Fault Tolerance, Visualization and Steering of Parallel Applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Geist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kohl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Papadopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The International Journal of Supercomputer Applications and High Performance Computing</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="224" to="235" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">The Java Language Specification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
		<ptr target="http://java.sun.com" />
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">-Performance Corba Working</forename><surname>High</surname></persName>
		</author>
		<author>
			<persName><surname>Group</surname></persName>
		</author>
		<ptr target="http://www.omg.org/homepages/realtime/workinggroups/highperformancecorba.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The use of objectoriented design patterns in the SAMRAI structured AMR framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hornung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kohn</surname></persName>
		</author>
		<ptr target="http://www.llnl.gov/CASC/SAMRAI" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIAM Workshop on Object-Oriented Methods for Inter-Operable Scientific and Engineering Computing</title>
		<meeting>the SIAM Workshop on Object-Oriented Methods for Inter-Operable Scientific and Engineering Computing</meeting>
		<imprint>
			<date type="published" when="1998-10">October 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Particle beam dynamics simulations using the POOMA framework</title>
		<author>
			<persName><forename type="first">W</forename><surname>Humphrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ryne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cummings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Cleland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Habib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Qiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IS-COPE &apos;98 Conference</title>
		<meeting>the IS-COPE &apos;98 Conference</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Simulation of 3-D mold-filling and solidification processes on distributed memory parallel architectures</title>
		<author>
			<persName><forename type="first">F</forename><surname>Illinca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Hetu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bramley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Mechanical Engineering Congress &amp; Exposition</title>
		<meeting>International Mechanical Engineering Congress &amp; Exposition</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">B</forename><surname>Janssen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Spreitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Larner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jacobi</surname></persName>
		</author>
		<ptr target="ftp://ftp.parc.xerox.com/pub/ilu/ilu.html" />
		<imprint>
			<date type="published" when="1997-11">Nov. 1997</date>
		</imprint>
		<respStmt>
			<orgName>ILU Reference Manual. Xerox Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Java Native Interface Specification</title>
		<author>
			<persName><surname>Javasoft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Multiagent simulation of complex heterogeneous models in scientific computing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Drashansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Rice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weerawarana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Houstis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput. Simul</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="43" to="59" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Ligature: Component architecture for high-performance applications. International Journal of High-Performance and Scientific Applications</title>
		<author>
			<persName><forename type="first">K</forename><surname>Keahey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Beckman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ahrens</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">PARDIS: A Parallel Approach to CORBA</title>
		<author>
			<persName><forename type="first">K</forename><surname>Keahey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th IEEE International Symposium on High Performance Distributed Computation</title>
		<meeting>the 6th IEEE International Symposium on High Performance Distributed Computation</meeting>
		<imprint>
			<date type="published" when="1997-08">August 1997</date>
			<biblScope unit="page" from="31" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Component interoperability architecture: A proposal to the common component architecture forum</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Smolinski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>In preparation</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A message-passing interface standard</title>
		<author>
			<persName><surname>Mpi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International J. Supercomputing Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3/4</biblScope>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">The Common Object Request Broker: Architecture and Specification. Revision 2.0. OMG Document</title>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A variable explicit/implicit numerical method for calculating advection on unstructured meshes</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>O'rourke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Sahota</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comp. Phys</title>
		<imprint>
			<biblScope unit="volume">143</biblScope>
			<biblScope unit="page" from="312" to="345" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Plasma simulation studies using multilevel physics models</title>
		<author>
			<persName><forename type="first">W</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Belova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">Y</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">Z</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Sugiyama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physics of Plasmas</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1796" to="1803" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The SCIRun computational steering software system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weinstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modern Software Tools in Scientific Computing</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Arge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Bruaset</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Langtangen</surname></persName>
		</editor>
		<imprint>
			<publisher>Birkhauser Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="1" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Sessions</surname></persName>
		</author>
		<title level="m">COM and DCOM: Microsoft&apos;s Vision for Distributed Objects</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Guide to Writing DCE Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Magid</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>O&apos;Reilly &amp; Associates, Inc</publisher>
			<pubPlace>Sebastopol, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Component Software: Beyond Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szyperski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>ACM Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Real-time analysis, visualization, and steering of microtomography experiments at photon sources</title>
		<author>
			<persName><forename type="first">G</forename><surname>Laszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Insley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bresnahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kesselman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thiebaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Tieman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mcnulty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth SIAM Conference on Parallel Processing for Scientific Computing</title>
		<meeting>the Ninth SIAM Conference on Parallel Processing for Scientific Computing</meeting>
		<imprint>
			<date type="published" when="1999-03">March 1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
