<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Some Alternative Formulations of the Event Calculus</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rob</forename><surname>Miller</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
								<address>
									<postCode>WC1E 6BT</postCode>
									<settlement>London</settlement>
									<country key="GB">U.K</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Murray</forename><surname>Shanahan</surname></persName>
							<email>m.shanahan@ic.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="department">Imperial College of Science, Technology and Medicine</orgName>
								<address>
									<postCode>SW7 2BT</postCode>
									<settlement>London</settlement>
									<country key="GB">U.K</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Some Alternative Formulations of the Event Calculus</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">566F2751C2F799327B276F0F0F0DB277</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The Event Calculus is a narrative based formalism for reasoning about actions and change originally proposed in logic programming form by Kowalski and Sergot. In this paper we summarise how variants of the Event Calculus may be expressed as classical logic axiomatisations, and how under certain circumstances these theories may be reformulated as "action description language" domain descriptions using the Language E. This enables the classical logic Event Calculus to inherit various provably correct automated reasoning procedures recently developed for E.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The "Event Calculus" was originally introduced by Bob Kowalski and Marek Sergot <ref type="bibr" target="#b32">[33]</ref> as a logic programming framework for representing and reasoning about actions (or events) and their effects, especially in database applications. Since then many alternative formulations, implementations and applications have been developed. The Event Calculus has been reformulated in various logic programming forms (e.g. <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b52">[53]</ref>, <ref type="bibr" target="#b57">[58]</ref>, <ref type="bibr" target="#b70">[71]</ref>, <ref type="bibr" target="#b71">[72]</ref>, <ref type="bibr" target="#b72">[73]</ref>, <ref type="bibr" target="#b73">[74]</ref>), in classical logic (e.g. <ref type="bibr" target="#b61">[62]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref>), in modal logic (e.g. <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>) and as an "action description language" ( <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>). In one form or another it has been extended and applied, for example, in the context of planning (e.g. <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b62">[63]</ref>, <ref type="bibr" target="#b64">[65]</ref>, <ref type="bibr" target="#b19">[20]</ref>), cognitive robotics (e.g. <ref type="bibr" target="#b59">[60]</ref>, <ref type="bibr" target="#b60">[61]</ref>, <ref type="bibr" target="#b64">[65]</ref>, <ref type="bibr" target="#b66">[67]</ref>), abductive reasoning (e.g. <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b70">[71]</ref> and <ref type="bibr" target="#b71">[72]</ref>), database updates (e.g. <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b71">[72]</ref>), accident report processing <ref type="bibr" target="#b34">[35]</ref>, legal reasoning <ref type="bibr" target="#b29">[30]</ref>, modelling continuous change and mathematical modelling (e.g. <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b57">[58]</ref>, <ref type="bibr" target="#b70">[71]</ref>), modelling and reasoning about agent beliefs <ref type="bibr" target="#b34">[35]</ref>, reasoning about programming constructs <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b67">68]</ref>, and software engineering <ref type="bibr" target="#b51">[52]</ref>.</p><p>In spite of this growing menagerie of Event Calculus formulations and applications, relatively little work has been done to show how the various versions correspond. (Indeed, much more work has been done on showing how the Event Calculus corresponds to the Situation Calculus, see e.g. <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b47">[48]</ref>, <ref type="bibr" target="#b48">[49]</ref>, <ref type="bibr" target="#b72">[73]</ref>, <ref type="bibr" target="#b73">[74]</ref>.) This article is an attempt to begin to address this issue. We first In: "Computational Logic: Logic Programming and Beyond -Essays in Honour of Robert A. Kowalski", Lecture Notes in Artificial Intelligence, Vol. 2408, pub. Springer Verlag, 2002, pages 452-490.</p><p>summarise recent work (e.g. <ref type="bibr" target="#b61">[62]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref>) on axiomatising the Event Calculus in classical logic, using circumscription as a method for default reasoning to solve the frame and related problems. We then describe how under certain circumstances such classical logic theories may be reformulated as "action description language" domain descriptions using the Language E <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>. This enables the classical logic Event Calculus to inherit various provably correct, logic programming and/or argumentation based automated reasoning procedures developed for E in <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b22">[23]</ref> and <ref type="bibr" target="#b23">[24]</ref>.</p><p>Even if attention is restricted to classical logic formulations of the Event Calculus, there are a number of different choices or variations for the core set of axioms. The various alternatives are each geared to classes of domains with particular restrictions or features; for example to describe systems most naturally viewed as deterministic, as involving both continuous and discrete change, or which require reasoning about the future but not the past. In view of this, we first present (in Section 2) one particular (basic) form of the Event Calculus with six domain independent axioms labeled (EC1) to (EC6), and then (Section 3) list and motivate some alternatives. When describing these, possible substitutes for (for example) axiom (EC1) are labeled (EC1a), (EC1b), etc.</p><p>A central feature of the Event Calculi presented here are that they are narrative-based, i.e. a time structure which is independent of any action occurrences is established or assumed, and then statements about when various actions occur within this structure are incorporated in the description of the domain under consideration. The time structure is usually assumed or stated to be linear -typically the real or integer number line -although the underlying ideas can equally be applied to other (possibly branching) temporal structures. For the purposes of simplicity, unless otherwise stated we will assume in this article that time is represented either by the real numbers, the integers, the non-negative reals or the non-negative integers, and that appropriate axioms are included in the theory which establish one of these time structures.</p><p>Sections 2 and 3 of this article are mostly taken from <ref type="bibr" target="#b42">[43]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A Classical Logic Event Calculus Axiomatisation</head><p>Informally, the basic idea of the Event Calculus is to state that fluents (timevarying properties of the world) are true at particular time-points if they have been initiated by an action occurrence at some earlier time-point, and not terminated by another action occurrence in the meantime. Similarly, a fluent is false at a particular time-point if it has been previously terminated and not initiated in the meantime. Domain dependent axioms are provided to describe which actions initiate and terminate which fluents under various circumstances, and to state which actions occur when. In the context of the Event Calculus, individual action occurrences are often referred to as "events", so that "actions" are "event types". The Event Calculus given here is written in a sorted predicate calculus with equality, with a sort A for actions (variables a, a 1 , a 2 , . . .), a sort F for flu-ents (variables f, f 1 , f 2 , . . .), a sort T for timepoints (here either real numbers or integers, variables t, t 1 , t 2 , . . .) and a sort X for domain objects (variables x, x 1 , x 2 , . . .). To describe a very basic calculus we need five predicates (other than equality); Happens ⊆ A × T , HoldsAt ⊆ F × T , Initiates ⊆ A × F × T , Terminates ⊆ A × F × T and &lt; ⊆ T × T . Happens(A, T ) indicates that action A occurs at time T , HoldsAt(F, T ) means that fluent F is true at time T , and Initiates(A, F, T ) (respectively Terminates(A, F, T )) expresses that if A occurs at T it will initiate (respectively terminate) the fluent F . "&lt;" is the standard order relation for time.</p><p>It is convenient to also define auxiliary predicates Clipped ⊆ T × F × T and Declipped ⊆ T × F × T in terms of Happens, Initiates, Terminates, and &lt;. Clipped (T 1 , F, T 2 ) (respectively Declipped (T 1 , F, T 2 )) means "the fluent F is terminated (respectively initiated) between times T 1 and T 2 ." The corresponding definitional axioms 1  We can now axiomatise the two principles stated in the introduction to this section. Fluents which have been initiated by an occurrence of an action continue to hold until an occurrence of an action which terminates them HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) (EC3) ∧ t 1 &lt; t 2 ∧ ¬Clipped (t 1 , f, t 2 )] and fluents which have been terminated by an occurrence of an action continue not to hold until an occurrence of an action which initiates them:</p><formula xml:id="formula_0">¬HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) (EC4) ∧ t 1 &lt; t 2 ∧ ¬Declipped (t 1 , f, t 2 )]</formula><p>The four axioms above capture the behaviour of fluents once initiated or terminated by an action. But we need also to describe fluents' behaviour before the occurrence of any actions which affect them. We therefore axiomatise a general principle of persistence for fluents; fluents change their truth values only via the occurrence of initiating and terminating actions:</p><formula xml:id="formula_1">HoldsAt(f, t 2 ) ← [HoldsAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC5) ∧ ¬Clipped (t 1 , f, t 2 )] 1 By E1 def ≡ E2 we mean that expression E1 is notational shorthand for expression E2. ¬HoldsAt(f, t 2 ) ← [¬HoldsAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC6) ∧ ¬Declipped (t 1 , f, t 2 )]</formula><p>Definitions of the predicates Happens, Initiates and Terminates are given in the domain-dependent part of the theory, as illustrated in the following example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">An Example Domain Dependent Axiomatisation</head><p>As an example domain dependent theory, we axiomatise a simple scenario of a robot going outside a room by moving through a door, which can be locked and unlocked using an electronic key. For this example we will assume a real number time-line. We will use three fluents, Inside (the robot is inside the room), HasKey (the robot is holding the electronic key), and Locked (the door is locked), and three actions, Insert (insert the key in the door), GoThrough (move through the door), and Pickup (pick up the key). We assume uniqueness-of-names axioms<ref type="foot" target="#foot_0">2</ref> which confirm that all of these constant symbols refer to distinct fluents or actions. Inserting the key alternately locks and unlocks the door. Picking up the key causes the robot to be holding the key, and, going through the unlocked door causes the robot to swap from being inside to outside or vice-versa. We use the predicates Initiates and Terminates to express these effects:</p><formula xml:id="formula_2">Initiates(a, f, t) ≡ [[a = Pickup ∧ f = HasKey] (R1) ∨ [a = Insert ∧ f = Locked ∧ ¬HoldsAt(Locked , t) ∧ HoldsAt(HasKey, t)] ∨ [a = GoThrough ∧ f = Inside ∧ ¬HoldsAt(Locked , t) ∧ ¬HoldsAt(Inside, t)]] Terminates(a, f, t) ≡ [[a = GoThrough ∧ f = Inside (R2) ∧ ¬HoldsAt(Locked , t) ∧ HoldsAt(Inside, t)] ∨ [a = Insert ∧ f = Locked ∧ HoldsAt(Locked , t) ∧ HoldsAt(HasKey, t)]]</formula><p>Let us suppose that the door is locked and the robot is inside at time 0, and that the robot picks up the key, unlocks the door and goes through the door at times 2, 4 and 6 respectively:</p><formula xml:id="formula_3">HoldsAt(Locked , 0) ∧ HoldsAt(Inside, 0) (R3) Happens(a, t) ≡ [[a = Pickup ∧ t = 2] ∨ (R4) [a = Insert ∧ t = 4] ∨ [a = GoThrough ∧ t = 6]]</formula><p>The reader is invited to check that from (EC1)-(EC6) and (R1)-(R4), together with uniqueness-of-names axioms for fluents and actions and an appropriate axiomatisation of the real numbers, it is for example possible to deduce that the robot is no longer inside the room at time 8, i.e. ¬HoldsAt(Inside, 8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Circumscription and the Frame Problem</head><p>In Event Calculus terms, the frame problem is the problem of expressing in a succinct and elaboration tolerant way that in most cases a given action will not initiate or terminate a given fluent. The description of which actions initiate and terminate which fluents via single biconditionals (as in axioms (R1) and (R2) above), although succinct, is rather unsatisfactory from the point of view of elaboration tolerance. For example, if new information about the initiating effects of a new action needs to be included in the robot domain (e.g. Initiates(PressDoorBell , RingingNoise, t)) this cannot be simply added to the theory, since it would be inconsistent with axiom (R1) (from which it is possible to infer ¬Initiates(PressDoorBell , RingingNoise, t)).</p><p>Hence most versions of the Event Calculus describe each fact or rule about initiation and termination in a separate axiom or clause, and provide an extra transformation or non-monotonic reasoning method to infer negative information about Initiates and Terminates from the collection of such rules. In the context of our classical logic Event Calculus and robot example, the individual rules would be Initiates(Pickup, HasKey, t) (R5)</p><formula xml:id="formula_4">Initiates(Insert, Locked , t) ← (R6) [¬HoldsAt(Locked , t) ∧ HoldsAt(HasKey, t)] Initiates(GoThrough, Inside, t) ← (R7) [¬HoldsAt(Locked , t) ∧ ¬HoldsAt(Inside, t)] Terminates(GoThrough, Inside, t) ← (R8) [¬HoldsAt(Locked , t) ∧ HoldsAt(Inside, t)] Terminates(Insert, Locked , t) ← (R9) [HoldsAt(Locked , t) ∧ HoldsAt(HasKey, t)]</formula><p>Predicate completion or circumscription <ref type="bibr" target="#b38">[39]</ref> can then be used to transform this collection of axioms into expressions such as (R1) and (R2). In this article we use the notation described in <ref type="bibr" target="#b36">[37]</ref> to indicate circumscriptions of particular conjunctions of sentences. In particular, the circumscription</p><formula xml:id="formula_5">CIRC [(R5) ∧ (R6) ∧ (R7) ∧ (R8) ∧ (R9) ; Initiates, Terminates]</formula><p>yields exactly (R1) and (R2). For simple domains such as the above, this type of transformation (whether described in terms of circumscription or predicate completion) is analogous to the solution to the frame problem developed by Reiter for the Situation Calculus <ref type="bibr" target="#b49">[50]</ref>.</p><p>To make useful deductions using axioms (EC1)-(EC6), it is also necessary to be able to infer both positive and negative information about Happens from the domain dependent part of the theory. Again the issue of elaboration tolerance arises, so that, as for Initiates and Terminates, most versions of the Event Calculus encapsulate each individual action occurrence in a separate Happens assertion (rather than using a biconditional such as (R4)), and then use some form of non-monotonic reasoning to infer negative information about this predicate. For example, in the case of our robot example the assertions would be</p><formula xml:id="formula_6">Happens(Pickup, 2) (R10)</formula><p>Happens(Insert, 4) (R11)</p><formula xml:id="formula_7">Happens(GoThrough, 6) (R12)</formula><p>The circumscription CIRC [(R10) ∧ (R11) ∧ (R12) ; Happens] then gives (R4).</p><p>If we now wish to add more information about Happens, we can do so without altering axioms (R10)-(R12) and then reapply the circumscription operator. This information need not just be in the form of ground literals -we may have less precise information about the order or timing of action occurrences. For example, we might know that the robot pressed the door bell either just before, just after or at the same time as inserting the key, in which case we could add</p><formula xml:id="formula_8">∃t 1 .[Happens(PressDoorBell , t 1 ) ∧ 2 &lt; t 1 &lt; 6] (R13) The circumscription CIRC [(R10) ∧ (R11) ∧ (R12) ∧ (R13) ; Happens] then gives ∃t 1 .[2 &lt; t 1 &lt; 6 ∧ [Happens(a, t) ≡ (R14) [[a = Pickup ∧ t = 2] ∨ [a = Insert ∧ t = 4] ∨ [a = GoThrough ∧ t = 6] ∨ [a = PressDoorBell ∧ t = t 1 ]]]]</formula><p>enabling us to deduce facts such as ¬HoldsAt(Inside, 8) as before.</p><p>More generally, complete Event Calculus domain descriptions of this basic type are of the form</p><formula xml:id="formula_9">CIRC [Σ ; Initiates, Terminates] ∧ CIRC [∆ ; Happens] ∧ Ω ∧ EC</formula><p>where Σ is a conjunction of Initiates and Terminates formulae, ∆ is a conjunction of Happens and temporal ordering formulae, Ω is a conjunction of fluentspecific HoldsAt formulae such as (R3) and time-independent formulae (such as uniqueness-of-names axioms for actions and fluents), and EC is the conjunction of axioms (EC1) to (EC6) together an appropriate axiomatisation of the sort T . The minimisation of Initiates and Terminates corresponds to the default assumption that actions have no unexpected effects, and the minimisation of Happens corresponds to the default assumption that there are no unexpected event occurrences. The key to this solution to the frame problem is thus the splitting of the theory into different parts, which are circumscribed separately. This technique, sometimes referred to as forced separation, is also employed in <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b13">[14]</ref> and <ref type="bibr" target="#b27">[28]</ref>, and is akin to what Sandewall calls filtering <ref type="bibr" target="#b55">[56]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Narrative Information and Planning</head><p>In some circumstances it is convenient to define Happens in terms of other predicates representing different categories of action occurrence. For example, in the context of planning we may wish to distinguish between actions that have (definitely) happened in the past and actions that the agent will (possibly) perform in the future <ref type="foot" target="#foot_1">3</ref> . In this case we may include a domain independent axiom such as</p><formula xml:id="formula_10">Happens(a, t) ≡ [Occurred (a, t) ∨ Perform(a, t)] (EC7)</formula><p>We can now maintain a complete definition for Occurred (in the same way that we previously had a complete definition for Happens) based on our knowledge of actions that have already taken place, whilst keeping Perform undefined within the theory. In this way we can formulate a deductive specification of the planning task in terms of Perform. For example, in the context of the robot example suppose that at time 3 we know that a Pickup action has already taken place (at time 2), and wish to plan for the goal ¬HoldsAt(Inside, 8). We would include the axiom</p><formula xml:id="formula_11">Occurred (a, t) ≡ [a = Pickup ∧ t = 2] (R15)</formula><p>(or the equivalent expression CIRC [Occurred (Pickup, 2) ; Occurred ]) in the domain description, and then show that the sentence</p><formula xml:id="formula_12">Perform(a, t) ≡ [[a = Insert ∧ t = 4] ∨ [a = GoThrough ∧ t = 6]] (P1)</formula><p>is a plan for ¬HoldsAt(Inside, 8) in the sense that</p><formula xml:id="formula_13">[(EC1) ∧ . . . ∧ (EC7) ∧ (R1) ∧ (R2) ∧ (R3) ∧ (R15)] |= [(P1) → ¬HoldsAt(Inside, 8)]</formula><p>More generally, planning can be viewed as the deduction<ref type="foot" target="#foot_2">4</ref> of sentences of the form [Plan → Goal ] from an Event Calculus domain description, where Plan is a sentence such as (P1) defining the predicate Perform, and Goal is a sentence containing just the predicates HoldsAt and &lt; (we need also to establish via general theorems or a specific check that Plan is consistent with the Event Calculus theory). By the Deduction Theorem (see e.g. <ref type="bibr" target="#b17">[18]</ref>) Theory |= [Plan → Goal ] is equivalent to [Theory ∧ Plan] |= Goal so that planning in the context of the Event Calculus can also be understood in terms of abduction (i.e. finding plans to add to the theory so that the goal is entailed). Indeed, it is this abductive view which is taken in the majority of work on Event Calculus planning, e.g. in <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b62">[63]</ref>, <ref type="bibr" target="#b64">[65]</ref> and <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Non-determinism</head><p>In contrast to many versions of the Event Calculus, the axiomatisation described in (EC1)-(EC6) is non-deterministic, in the sense that simultaneously initiating and terminating a fluent simply gives rise to two sets of models (one in which the fluent is true immediately afterwards and one in which it is false), rather than resulting in an inconsistent theory. This is because of the requirement in axioms (EC1) and (EC2) that t 1 ≤ t, rather than t 1 &lt; t. For example, let us suppose that the action of tossing a coin is represented as TossCoin, and that each occurrence of this action results in the fluent HeadsUp being either true or false. We can represent this with an Initiates and a Terminates literal:</p><formula xml:id="formula_14">Initiates(TossCoin, HeadsUp, t) (C1)</formula><p>Terminates(TossCoin, HeadsUp, t)</p><formula xml:id="formula_15">(C2)</formula><p>Suppose the time is represented as the reals, and that a single TossCoin action happens at time 2:</p><formula xml:id="formula_16">Happens(TossCoin, 2) (C3)</formula><p>The theory which consists of axioms We can then rewrite axioms (C1) and (C2) as</p><formula xml:id="formula_17">Initiates(TossHead , HeadsUp, t) (C1a)</formula><p>Terminates(TossTail , HeadsUp, t) (C2a)</p><p>The theory consisting of (EC1)-(EC6), (C5), CIRC [(C3) ∧ (C4) ; Happens] and CIRC [(C1a) ∧ (C2a) ; Initiates, Terminates] now also gives rise to the desired classes of models described above. (The circumscription of Happens eliminates models where both a TossHead and a TossTail action occur at time 2.) For tasks such as planning, it is straightforward to specify that the agent in question can attempt some actions (such as TossCoin) but not others (such as TossHead or TossTail ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Concurrent Actions</head><p>The syntax of the Event Calculus makes it straightforward to express that two or more actions have occurred or will occur simultaneously, since different Happens literals in the domain description may refer to the same timepoint. In some domains, concurrently performed actions may cancel each others' effects, and may combine to cause effects which none of the actions performed in isolation would achieve. A standard example is that if a bowl is filled with water, lifting just the left side of the bowl or just the right side will cause the water to spill. Lifting both sides simultaneously will not cause the water to spill but will cause the bowl to be raised.</p><p>In the Event Calculus, we can describe cancellations and combinations of effects with Happens preconditions in the domain dependent axioms defining Initiates and Terminates. For example:</p><formula xml:id="formula_18">Initiates(LiftLeft, Spilt, t) ← ¬Happens(LiftRight, t) (B1) Initiates(LiftRight, Spilt, t) ← ¬Happens(LiftLeft, t) (B2) Initiates(LiftRight, Raised , t) ← Happens(LiftLeft, t) (B3)</formula><p>To illustrate the effect of such statements, suppose that our domain description also includes the following narrative information:</p><formula xml:id="formula_19">¬HoldsAt(Spilt, 0) (B4)</formula><p>Happens(LiftLeft, 2) (B5)</p><formula xml:id="formula_20">Happens(LiftRight, 2) (B6)</formula><p>The theory consisting of (EC1)-(EC6), (B4), CIRC [(B1) ∧ (B2) ∧ (B3) ; Initiates, Terminates] and CIRC [(B5) ∧ (B6) ; Happens] entails, for example, both ¬HoldsAt(Spilt, 4) and HoldsAt(Raised , 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Alternative and Extended Classical Logic Event Calculus Axiomatisations</head><p>The version of the Event Calculus described in Section 2 has a number of characteristics; it is geared to time-lines extending infinitely backwards as well as forwards, it is "non-deterministic" (in the sense described in Section 2.4), it regards all actions as possible under all circumstances, it regards all fluents' truth values as persisting between all relevant action occurrences, and it regards all action occurrences as instantaneous. However, the choice of which of these characteristics to include in a given Event Calculus axiomatisation is to a large extent arbitrary, and in this section we describe alternative axiomatisations which each negate one or more of these properties. For ease of presentation, sub-sections 3.1 to 3.7 below each alter the axiomatisation (EC1)-(EC6) as little as possible to illustrate the particular point under discussion. But unless otherwise stated these alterations can be combined in a straightforward and obvious manner. For example we can combine the modifications described in sub-sections 3.2, 3.3 and 3.6 below to produce a "deterministic" Event Calculus with facilities to describe when it is impossible for particular actions to occur, and including actions of a non-zero duration.</p><p>Where in a particular sub-section no alternative to one of the axioms (EC1)-( <ref type="formula">EC6</ref>) is given, it should be assumed that the axiom in question remains unchanged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">An Alternative Axiomatisation for Non-Negative Time</head><p>Where time is modeled as the non-negative reals or integers, it is often convenient to introduce two new predicates <ref type="foot" target="#foot_3">5</ref> InitiallyP ⊆ F and InitiallyN ⊆ F ("P " for "positive" and "N " for "negative"), and to replace axioms (EC5) and (EC6) with the following three axioms:</p><formula xml:id="formula_21">HoldsAt(f, t) ← [InitiallyP (f ) ∧ ¬Clipped (0, f, t)] (EC5a) ¬HoldsAt(f, t) ← [InitiallyN (f ) ∧ ¬Declipped (0, f, t)] (EC6a) InitiallyP (f ) ∨ InitiallyN (f ) (EC8a)</formula><p>Indeed, for non-negative time (EC5a), ( <ref type="formula">EC6a</ref>) and (EC8a) may be deduced from (EC5) and (EC6) together with the assertion</p><formula xml:id="formula_22">[HoldsAt(f, 0) ≡ InitiallyP (f )] ∧ [¬HoldsAt(f, 0) ≡ InitiallyN (f )]</formula><p>Axioms (EC5a) and (EC6a) have an advantage over (EC5) and (EC6) in that they can readily be converted to logic program clauses without causing obvious looping problems. However, this alternative axiomatisation is slightly weaker. For example, in the non-deterministic domain described in Sub-section 2.4 by axioms (C1), (C2) and (C3), axioms (EC5a), (EC6a) and (EC8a) would license models where HeadsUp fluctuated arbitrarily between true and false at times after 2. Although this characteristic is problematic for this particular example, it can be an advantage for representing other types of domain where it is convenient to "dynamically manage the frame", i.e. to regard some fluents as having an inherent persistence during some intervals of time but not during others. Indeed, for such domains axiom (EC8a) may not be appropriate. These issues are discussed in more detail in Section 3.7.</p><p>Since this particular axiomatisation does not include the general principle of persistence encapsulated in (EC5) and (EC6) (which describes how fluents persist independently of initiating and terminating action occurrences), adding individual HoldsAt literals to a given domain description (see for example axiom (R3) in Section 2.1) no longer necessarily has the same effect, particularly in axiomatisations where (EC8a) is omitted. Instead, individual observations of the form HoldsAt(F, T ) and ¬HoldsAt(F, T ) can be assimilated indirectly into the theory (perhaps automatically by a process of abduction) by appropriate addition of Happens, InitiallyP and InitiallyN literals. Axiom (R3), for example, can be replaced by</p><formula xml:id="formula_23">InitiallyP (Locked ) ∧ InitiallyP (Inside) (R3a)</formula><p>so that (R3) is now entailed by the theory consisting of (R3a), (R1), (R2), (R4), (EC1)-(EC4), (EC5a) and (EC6a).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Deterministic Event Calculus</head><p>A strictly deterministic Event Calculus (in the sense that simultaneously initiating and terminating a fluent results in inconsistency) may be formulated by replacing (EC3) and (EC4) by the following two axioms:</p><formula xml:id="formula_24">HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) (EC3b) ∧ t 1 &lt; t 2 ∧ ¬StoppedIn(t 1 , f, t 2 )] ¬HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) (EC4b) ∧ t 1 &lt; t 2 ∧ ¬StartedIn(t 1 , f, t 2 )]</formula><p>where the predicates StoppedIn and StartedIn are defined as follows:</p><formula xml:id="formula_25">StoppedIn(t 1 , f, t 2 ) def ≡ ∃a, t[Happens(a, t) ∧ t 1 &lt; t &lt; t 2 (EC9b) ∧ Terminates(a, f, t)] StartedIn(t 1 , f, t 2 ) def ≡ ∃a, t[Happens(a, t) ∧ t 1 &lt; t &lt; t 2 (EC10b) ∧ Initiates(a, f, t)]</formula><p>Note that StoppedIn and StartedIn are identical to Clipped and Declipped except for the inequality relations between the time-point variables. Strictly speaking (EC1) and (EC2) defining Clipped and Declipped are still required since these predicates are used in (EC5) and (EC6), or in their substitutes (EC5a) and (EC6a). But for domains using non-negative time and axioms (EC5a) and (EC6a), the definitions of Clipped and Declipped may be straightforwardly replaced by those for StoppedIn and StartedIn, provided no actions occur at time 0 which either terminate initially-positive fluents or initiate initially-negative fluents.</p><p>The effective meanings of Initiates and Terminates are slightly different in the deterministic Event Calculus (i.e. in axiomatisations including (EC3b) and (EC4b)) from their meanings in non-deterministic Event Calculus. (EC3b) and (EC4b) ensure that Initiates(A, F, T ) can be read as "F holds immediately after an occurrence of A at time T ", whereas with axioms (EC3) and (EC4) Initiates(A, F, T ) corresponds to the slightly weaker assertion that "an occurrence of A at time T has an initiating influence on F " (which may or may not be overridden by a simultaneously occurring terminating influence).</p><p>There are several ways in which non-determinism may be reintroduced into what we have described here as deterministic Event Calculus. For example, the technique exemplified in axioms (C1a), (C2a) and (C4) (see Section 2.4) is still applicable. Other methods include the use of determining fluents or a Releases predicate (see <ref type="bibr" target="#b61">[62]</ref> and Section 3.7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Action Preconditions and the Qualification Problem in the Event Calculus</head><p>We have already illustrated with axioms such as (R6)-(R9) (See Section 2.2) how preconditions for particular effects of actions may be expressed within the Event Calculus. These types of precondition are often referred to as fluent preconditions. There are also various ways in which action preconditions (i.e. conditions necessary for actions to be possible at all) can be expressed. One method is to introduce a new predicate Impossible ⊆ A × T and write an appropriate definition for Impossible with respect to each action in the domain in question. For instance, in our example domain we may wish to express that it is impossible for the robot to pickup the key if it is not fitted with a grabber, and it is impossible for the robot to go through a locked door:</p><formula xml:id="formula_26">Impossible(Pickup, t) ← ¬HoldsAt(HasGrabber , t) (R16) Impossible(GoThrough, t) ← HoldsAt(Locked , t) (R17)</formula><p>We can regard the qualification problem (at least in part) as the problem of expressing, in a succinct and elaboration tolerant way, that under most circumstances most actions are possible. To achieve this in the Event Calculus, we can minimise the predicate Impossible. CIRC [(R16) ∧ (R17) ; Impossible] gives</p><formula xml:id="formula_27">Impossible(a, t) ≡ [[a = Pickup ∧ ¬HoldsAt(HasGrabber , t)] (R18) ∨ [a = GoThrough ∧ HoldsAt(Locked , t)]]</formula><p>For narrative formalisms such as the Event Calculus, the way in which this type of knowledge is to be interpreted, and thus the way in which the domain independent axioms need to be adapted, depends to some extent on the individual domain and mode of reasoning under consideration. For tasks such as planning, which involves (hypothetical) reasoning about future events, it makes sense to regard the assertion Impossible(A, T ) as stating "it is impossible to predict the effects of attempting to perform action A at time T " (so that ¬Impossible(A, T ) can be regarded as analogous to Poss(A, S) in Reiter's Situation Calculus <ref type="bibr" target="#b49">[50]</ref>). In this case it is necessary only to block any inferences about what holds or does not hold at any time after an (attempt at an) 'impossible' action occurrence. This can be done by appropriately modifying the definitions of Clipped and Declipped :</p><formula xml:id="formula_28">Clipped (t 1 , f, t 2 ) def ≡ (EC1c) [∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 ∧ Terminates(a, f, t)] ∨ ∃a, t[Happens(a, t) ∧ t &lt; t 2 ∧ Impossible(a, t)]] Declipped (t 1 , f, t 2 ) def ≡ (EC2c) [∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 ∧ Initiates(a, f, t)] ∨ ∃a, t[Happens(a, t) ∧ t &lt; t 2 ∧ Impossible(a, t)]]</formula><p>On the other hand, if for example the domain includes certain knowledge about actions or events that have actually occurred in the past, it makes sense to regard the assertion Impossible(A, T ) as stating "action A could not have occurred at time T ". Hence where the definition of Happens is split as in axiom (EC7) (see Section 2.3), we can include additional constraints such as</p><formula xml:id="formula_29">¬Occurred (a, t) ← Impossible(a, t) (EC11c)</formula><p>Notice for example that from (R15), (R16) and (EC11c) we can infer the action precondition HoldsAt(HasGrabber , 2) for the known occurrence of Pickup at time 2. This illustrates why we would not want to include constraints analogous to (EC11c) for hypothetical future performances of actions -at time 0 we would not for example want Perform(Pickup, 1) to constitute a plan for the goal HoldsAt(HasGrabber , 1). We could however safely state that nothing happens when an agent attempts to perform an impossible action, by replacing (EC7) with</p><formula xml:id="formula_30">Happens(a, t) ≡ [[Perform(a, t) ∧ ¬Impossible(a, t)] (EC7c) ∨ Occurred (a, t)]</formula><p>Finally, note that rules such as (R16) and (R17) partially defining Impossible can have Happens (and Perform and Occurred ) preconditions as well as HoldsAt preconditions. This can be useful, for example, for expressing that it is impossible to perform certain combinations of actions simultaneously. For instance, the sentence</p><formula xml:id="formula_31">Impossible(a 1 , t) ← [Perform(a 2 , t) ∧ a 1 = a 2 ]</formula><p>states that it is in general impossible to perform more than one action at a time. Like (R16) and (R17), such sentences must be placed within the scope of the circumscription of Impossible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Categorisation of Fluents in the Event Calculus</head><p>For some domains, it is appropriate to categorise fluents into frame fluents and non-frame fluents (or primitive and derived fluents), and then to restrict the application of the principles of persistence encapsulated in axioms (EC3)-(EC6) to frame fluents only. To do this it is necessary to introduce a new predicate Frame ⊆ F, and alter (EC3)-(EC6) as follows:</p><formula xml:id="formula_32">HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) (EC3d) ∧ Frame(f ) ∧ t 1 &lt; t 2 ∧ ¬Clipped (t 1 , f, t 2 )] ¬HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) (EC4d) ∧ Frame(f ) ∧ t 1 &lt; t 2 ∧ ¬Declipped (t 1 , f, t 2 )] HoldsAt(f, t 2 ) ← [HoldsAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC5d) ∧ Frame(f ) ∧ ¬Clipped (t 1 , f, t 2 )] ¬HoldsAt(f, t 2 ) ← [¬HoldsAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC6d) ∧ Frame(f ) ∧ ¬Declipped (t 1 , f, t 2 )]</formula><p>This axiom set can be useful when we want to include simple types of indirect effects in domain descriptions, since we are now free to write definitions or partial definitions of non-frame fluents (i.e. state constraints) in terms of HoldsAt and frame fluents. For example, as regards the robot we may wish to introduce a non-frame fluent Happy and state that, although the robot is not happy at time 0, it is in general happy if it is holding the key:</p><formula xml:id="formula_33">Frame(f ) ≡ [f = Inside ∨ f = HasKey ∨ f = Locked ] (R19) ¬HoldsAt(Happy, 0) (R20)</formula><p>HoldsAt(Happy, t) ← HoldsAt(HasKey, t) (R21)</p><p>Using (EC1), (EC2), (EC3d)-(EC6d), (R1)-(R4) and (R19)-(R21) we can now, for example, infer HoldsAt(Happy, 5). Indeed, we can also infer ¬HoldsAt(HasKey, 0) and therefore ¬HoldsAt(HasKey, 1). But we can neither infer HoldsAt(Happy, 1) nor ¬HoldsAt(Happy, 1), since the non-frame fluent Happy has no intrinsic persistence of its own.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Trajectories, Delayed Actions and Gradual Change</head><p>Several techniques are available within the context of the Event Calculus for describing delayed effects. The simplest approach is to write rules in terms of Happens. For example, if setting an alarm clock causes it to ring 8 hours later, we can write</p><formula xml:id="formula_34">Happens(StartRing, t+8) ← Happens(Set, t) (A1)</formula><p>Initiates(StartRing, Ringing, t) (A2)</p><p>A disadvantage of rules such as (A1) is that it is difficult to express that the occurrence of the later action might be prevented by some intervening action (e.g. somebody might switch off the alarm during the night).</p><p>A more flexible approach involves the use of trajectories <ref type="bibr" target="#b57">[58]</ref>. It is convenient to illustrate this technique here by introducing a new sort P of parameters into the language. Like fluents, parameters are time-varying properties, but unlike (frame) fluents they have no associated default persistence. More precisely, parameters are names for arbitrarily-valued functions of time, and accordingly we introduce a new function ValueAt : P × T → X . For example, we might write ValueAt(Countdown, 5) = 2 to indicate that at time 5 the parameter Countdown, representing the time remaining before the alarm clock rings, has a value of 2. To represent delayed and triggered effects, as well as simple forms of gradual or continuous change, specific parameters are associated with specific fluents via the predicate Trajectory ⊆ F × T × P × T × X . The intended meaning of Trajectory(F, T 1 , P, T 2 , X) is that if fluent F is initiated at time T 1 and continues to hold until time T 1 +T 2 , this results in parameter P having a value of X at time T 1 +T 2 . For example, in the case of the alarm clock we might write</p><formula xml:id="formula_35">Trajectory(SwitchedOn, t 1 , Countdown, t 2 , 8-t 2 ) (A3)</formula><p>We can translate this intended meaning into Event Calculus terms with the addition of a single extra domain independent axiom</p><formula xml:id="formula_36">ValueAt(p, t 1 +t 2 ) = x ← (EC11) [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) ∧ 0 &lt; t 2 ∧ Trajectory(f, t 1 , p, t 2 , x) ∧ ¬Clipped (t 1 , f, t 1 +t 2 )]</formula><p>Continuing with our example, it is straightforward to express that when Countdown reaches 0 the alarm goes off:</p><formula xml:id="formula_37">Happens(StartRing, t) ← ValueAt(Countdown, t) = 0 (A4)</formula><p>We can complete our description of the domain by stating that switching on the alarm activates the timing mechanism (provided it is not already activated), that the ringing event switches off the timing mechanism, that when the timing mechanism is switched off the countdown is permanently fixed at 8, that the alarm is initially not switched on and that someone switches it on at time 2:</p><formula xml:id="formula_38">Initiates(Set, SwitchedOn, t) ← ¬HoldsAt(SwitchedOn, t) (A5) Terminates(StartRing, SwitchedOn, t) (A6) ValueAt(Countdown, t) = 8 ← ¬HoldsAt(SwitchedOn, t) (A7) ¬HoldsAt(SwitchedOn, 0) (A8)</formula><formula xml:id="formula_39">Happens(Set, 2) (A9)</formula><p>The theory consisting of (EC1)-(EC6), (EC11), (A3), (A7), (A8), CIRC [(A4) ∧ (A9) ; Happens] and CIRC [(A2) ∧ (A5) ∧ (A6) ; Initiates, Terminates] entails, for example, Happens(StartRing, 10) and HoldsAt(Ringing, 11). The Event Calculus is symmetric as regards positive and negative HoldsAt literals and as regards Initiates and Terminates. Hence (EC11) has its counterpart in terms of Terminates:</p><formula xml:id="formula_40">ValueAt(p, t 1 +t 2 ) = x ← (EC12) [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) ∧ 0 &lt; t 2 ∧ AntiTrajectory(f, t 1 , p, t 2 , x) ∧ ¬Declipped (t 1 , f, t 1 +t 2 )]</formula><p>This axiom uses the predicate AntiTrajectory ⊆ F × T × P × T × X . The intended meaning of AntiTrajectory(F, T 1 , P, T 2 , X) is that if fluent F is terminated at time T 1 and continues not to hold until time T 1 +T 2 , this results in parameter P having a value of X at time T 1 +T 2 . We can illustrate the use of anti-trajectories by representing the fact that a hot-air balloon rises when the air-heater is on, but falls when it is not:</p><formula xml:id="formula_41">Trajectory(HeaterOn, t 1 , Height, t 2 , x 1 +t 2 ) (H1) ← ValueAt(Height, t 1 ) = x 1 AntiTrajectory(HeaterOn, t 1 , Height, t 2 , x 1 -t 2 ) (H2) ← ValueAt(Height, t 1 ) = x 1</formula><p>(Note that in the alarm clock example (A7) can also be expressed as AntiTrajectory(SwitchedOn, t 1 , Countdown, t 2 , 8).)</p><p>Note that the functions captured in individual trajectories need not be continuous or even numerically valued. For example, we can use a trajectory to model the fact that the left indicator light of a car flashes once per second while the indicator switch is depressed:</p><formula xml:id="formula_42">Trajectory(IndicatorDepressed , t 1 , Light, t 2 , BlinkFunction(t 2 )) (L1) AntiTrajectory(IndicatorDepressed , t 1 , Light, t 2 , Off ) (L2)</formula><formula xml:id="formula_43">BlinkFunction(t) = On ← [t mod 2 &lt; 1] (L3)</formula><formula xml:id="formula_44">BlinkFunction(t) = Off ← [t mod 2 ≥ 1] (L4)</formula><p>In domains which include non-deterministic actions (in the sense that actions or combinations of actions can simultaneously initiate and terminate fluents) axioms (EC11) and (EC12) are too weak. For example, if the switching on mechanism is faulty in our alarm clock example, so that we have both (A5) and </p><formula xml:id="formula_45">ValueAt(p, t 1 +t 2 ) = x ← (EC11e) [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) ∧ 0 &lt; t 2 ∧ Trajectory(f, t 1 , p, t 2 , x) ∧ HoldsAt(f, t 1 +t 2 ) ∧ ¬StoppedIn(t 1 , f, t 1 +t 2 )] ValueAt(p, t 1 +t 2 ) = x ← (EC12e) [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) ∧ 0 &lt; t 2 ∧ AntiTrajectory(f, t 1 , p, t 2 , x) ∧ ¬HoldsAt(f, t 1 +t 2 ) ∧ ¬StartedIn(t 1 , f, t 1 +t 2 )]</formula><p>In Event Calculus axiomatisations where a distinction is made between fluents which are (temporarily or permanently) inside or outside the frame (such as in Section 3.4), we may dispense with the extra sort P in favour of non-frame fluents, and replace (EC11) and (EC12) with axioms such as</p><formula xml:id="formula_46">HoldsAt(f 2 , t 1 +t 2 ) ← [¬Frame(f 2 ) ∧ Happens(a, t 1 ) (EC11f) ∧ Initiates(a, f 1 , t 1 ) ∧ 0 &lt; t 2 ∧ Trajectory(f 1 , t 1 , f 2 , t 2 ) ∧ ¬Clipped (t 1 , f 1 , t 1 +t 2 )] HoldsAt(f 2 , t 1 +t 2 ) ← [¬Frame(f 2 ) ∧ Happens(a, t 1 ) (EC12f) ∧ Terminates(a, f 1 , t 1 ) ∧ 0 &lt; t 2 ∧ AntiTrajectory(f 1 , t 1 , f 2 , t 2 ) ∧ ¬Declipped (t 1 , f 1 , t 1 +t 2 )]</formula><p>Here Trajectory ⊆ F × T × F × T , and the intended meaning of </p><formula xml:id="formula_47">Trajectory(F 1 , T 1 , F 2 , T 2 ) is that if fluent F 1 is initiated at</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">The Event Calculus and Actions with Duration</head><p>The Event Calculus can be modified in various ways so that actions can be represented as occurring over intervals of time. To illustrate, we present here a simple modification in which actions are assigned a numerical duration using the function Dur : A → T . This avoids the need to introduce extra arguments of sort T in the predicates Happens, Initiates and Terminates. For example, we will interpret the assertion Happens(A, T ) to mean "the action A starts to occur at T " (so that it finishes at T +Dur (A)).</p><p>We will be cautious in the assumptions we make about the effects of actions. We will assume that actions may affect relevant fluents from the moment they start, but the effects only become certain after the actions have finished. Hence the values of affected fluents should be undetermined by the axiomatisation during action occurrences. To incorporate these assumptions in the domain independent axioms (EC1)-(EC6) it is necessary only to modify the various inequality relations between the timepoint variables in (EC1)-(EC4):</p><formula xml:id="formula_48">Clipped (t 1 , f, t 2 ) def ≡ ∃a, t[Happens(a, t) ∧ t 1 ≤ (t+Dur (a)) (EC1g) ∧ t &lt; t 2 ∧ Terminates(a, f, t)] Declipped (t 1 , f, t 2 ) def ≡ ∃a, t[Happens(a, t) ∧ t 1 ≤ (t+Dur (a)) (EC2g) ∧ t &lt; t 2 ∧ Initiates(a, f, t)] HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) (EC3g) ∧ (t 1 +Dur (a)) &lt; t 2 ∧ ¬Clipped (t 1 , f, t 2 )] ¬HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) (EC4g) ∧ (t 1 +Dur (a)) &lt; t 2 ∧ ¬Declipped (t 1 , f, t 2 )]</formula><p>The issue of preconditions becomes more complex when actions have duration. We may for example wish to make a distinction between preconditions which must hold at the start of the action and those which must hold throughout the action. It is therefore often convenient to define auxiliary predicates such as HoldsIn ⊆ F × T × T :</p><formula xml:id="formula_49">HoldsIn(f, t 1 , t 3 ) def ≡ ∀t 2 [t 1 ≤ t 2 ≤ t 3 → HoldsAt(f, t 2 )] (EC13)</formula><p>To illustrate the use of HoldsIn, consider a simple description of an automated train which can move at a fixed speed S along a track running from West to East, provided its motor is engaged. Using the action term MoveEast(T ) to represent the action of moving east for T time units, we can for example write axioms such as</p><formula xml:id="formula_50">Dur (MoveEast(t)) = t (T1) Initiates(MoveEast(t), Location(x 2 ), t 1 ) ← (T2) [HoldsAt(Location(x 1 ), t 1 ) ∧ x 2 = (x 1 +S ×Dur (MoveEast(t))) ∧ HoldsIn(MotorEngaged , t 1 , (t 1 +Dur (MoveEast(t))))]</formula><p>An alternative way of dealing with actions with duration is to split them into an (instantaneous) "start of action" (e.g. StartMoveEast), an "end of action" (e.g. StopMoveEast) and introduce an extra fluent representing the fact that the action is taking place (e.g. MovingEast). This approach is more easily integrated with the mechanisms described in Section 3.5 for dealing with gradual change, and allows straightforward description of interruptions of partly executed actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Dynamic Management of the Frame</head><p>We have already seen in Sections 3.4 and 3.5 how it can sometimes be advantageous to regard some fluents ("frame" fluents) as having an intrinsic (default) persistence, but regard other fluents as liable to change truth values between action occurrences. It can also be useful to be able to express that particular fluents have a default persistence during some intervals of time but not during others. This can, for example, help succinctly describe domains involving non-determinism, continuous change and indirect effects of actions (see <ref type="bibr" target="#b61">[62]</ref> for details). In this section we illustrate how this facility for "dynamic management of the frame" can be incorporated into the Event Calculus by use of a new predicate Releases ⊆ A × F × T . A form of this predicate was first introduced in <ref type="bibr" target="#b27">[28]</ref> and it is related to Sandewall's idea of occlusion <ref type="bibr" target="#b55">[56]</ref>.</p><p>Releases(A, F, T ) expresses that if A occurs at T it will disable the fluent F 's innate persistence. The truth value of F will then be free to fluctuate until the next action occurrence which initiates or terminates it. Releases is defined in the domain-dependent part of the theory and circumscribed in parallel with Initiates and Terminates. For example, in the alarm clock example of Section 3.5, we may write</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Releases(Set, Countdown, t)</head><p>and if this is the only such statement in our theory, the circumscription will then give</p><formula xml:id="formula_51">Releases(a, f, t) ≡ [a = Set ∧ f = Countdown]</formula><p>Initiates(A, F, T ) (respectively Terminates(A, F, T )) now expresses that if A occurs at T it will both initiate (respectively terminate) the fluent F and enable F 's innate persistence. At any given time-point, therefore, a fluent can be in one of four states -true and persisting, false and persisting, true and released or false and released. To describe these states explicitly, we introduce a predicate ReleasedAt ⊆ F × T analogous to HoldsAt. Finally we need two new auxiliary predicates ReleasedBetween ⊆ T × F × T and PersistsBetween ⊆ T × F × T . ReleasedBetween(T 1 , F, T 2 ) means "an action releases the fluent F between times T 1 and T 2 " and PersistsBetween(T 1 , F, T 2 ) means "the fluent is not in a state of release at any time between T 1 and T 2 ."</p><p>The Event Calculus described in (EC1)-(EC6) needs fairly radical modifications to incorporate these extra concepts and predicates. The modified axiomatisation is as follows (for ease of reading (EC1) and (EC2) are listed again, although they are unmodified). The first three axioms are all similar and give definitions for Clipped , Declipped and ReleasedBetween:</p><formula xml:id="formula_52">Clipped (t 1 , f, t 2 ) def ≡ ∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 (EC1) ∧ Terminates(a, f, t)] Declipped (t 1 , f, t 2 ) def ≡ ∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 (EC2) ∧ Initiates(a, f, t)] ReleasedBetween(t 1 , f, t 2 ) def ≡ (EC14h) ∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 ∧ Releases(a, f, t)]</formula><p>The next four axioms indicate how particular actions can put a fluent in one of the four states described above:</p><formula xml:id="formula_53">HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) (EC3h) ∧ t 1 &lt; t 2 ∧ ¬Clipped (t 1 , f, t 2 ) ∧ ¬ReleasedBetween(t 1 , f, t 2 )] ¬HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) (EC4h) ∧ t 1 &lt; t 2 ∧ ¬Declipped (t 1 , f, t 2 ) ∧ ¬ReleasedBetween(t 1 , f, t 2 )] ReleasedAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Releases(a, f, t 1 ) (EC15h) ∧ t 1 &lt; t 2 ∧ ¬Clipped (t 1 , f, t 2 ) ∧ ¬Declipped (t 1 , f, t 2 )] ¬ReleasedAt(f, t 2 ) ← (EC16h) [Happens(a, t 1 ) ∧ t 1 &lt; t 2 ∧ [Initiates(a, f, t 1 ) ∨ Terminates(a, f, t 1 )] ∧ ¬ReleasedBetween(t 1 , f, t 2 )]</formula><p>A weakened version of the "commonsense law of inertia" is captured in the following three axioms:</p><formula xml:id="formula_54">PersistsBetween(t 1 , f, t 2 ) def ≡ (EC17h) ¬∃t[ReleasedAt(f, t) ∧ t 1 ≤ t ≤ t 2 ] HoldsAt(f, t 2 ) ← [HoldsAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC5h) ∧ PersistsBetween(t 1 , f, t 2 ) ∧ ¬Clipped (t 1 , f, t 2 )] ¬HoldsAt(f, t 2 ) ← [¬HoldsAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC6h) ∧ PersistsBetween(t 1 , f, t 2 ) ∧ ¬Declipped (t 1 , f, t 2 )]</formula><p>Finally, we need to state that the meta-property of being "released" is itself subject to a form of meta-persistence between action occurrences:</p><formula xml:id="formula_55">ReleasedAt(f, t 2 ) ← [ReleasedAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC18h) ∧ ¬Clipped (t 1 , f, t 2 ) ∧ ¬Declipped (t 1 , f, t 2 )] ¬ReleasedAt(f, t 2 ) ← [¬ReleasedAt(f, t 1 ) ∧ t 1 &lt; t 2 (EC19h) ∧ ¬ReleasedBetween(t 1 , f, t 2 )]</formula><p>Individual ReleasedAt literals can be included in the domain dependent part of the theory in the same way as HoldsAt literals (see for example axiom (R3) in Section 2.1).</p><p>The above axiomatisation is fairly complex -it replaces our original six axioms with twelve (longer) ones and introduces four new predicates. However, for practical and computational purposes (e.g. ease of translation into logic programs) and where we are using non-negative time, we can dispense with the predicates ReleasedAt, ReleasedBetween and PersistsBetween and simply incorporate Releases in the definitions of Clipped and Declipped . This gives rise to the following alternative (and complete) set of domain independent axioms:</p><formula xml:id="formula_56">Clipped (t 1 , f, t 2 ) def ≡ (EC1i) ∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 ∧ [Terminates(a, f, t) ∨ Releases(a, f, t)]] Declipped (t 1 , f, t 2 ) def ≡ (EC2i) ∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 ∧ [Initiates(a, f, t) ∨ Releases(a, f, t)]] HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Initiates(a, f, t 1 ) (EC3) ∧ t 1 &lt; t 2 ∧ ¬Clipped (t 1 , f, t 2 )] ¬HoldsAt(f, t 2 ) ← [Happens(a, t 1 ) ∧ Terminates(a, f, t 1 ) (EC4) ∧ t 1 &lt; t 2 ∧ ¬Declipped (t 1 , f, t 2 )] HoldsAt(f, t) ← [InitiallyP (f ) ∧ ¬Clipped (0, f, t)] (EC5a) ¬HoldsAt(f, t) ← [InitiallyN (f ) ∧ ¬Declipped (0, f, t)] (EC6a)</formula><p>Note that fluents which are InitiallyP or InitiallyN are initially in the frame, whereas those which are neither InitiallyP nor InitiallyN are effectively initially "released". Hence axiom (EC8a) (see Section 3.1) implies that all fluents are initially in the frame, and may or may not be appropriate for a given domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">The Event Calculus, Continuous Change and Mathematical Modelling</head><p>The techniques using the Trajectory and AntiTrajectory predicates discussed in Section 3.5 are sufficient for modelling domains with very simple forms of continuous change, in particular where an explicit function of time is known for a particular parameter after a particular fluent has been initiated or terminated. However, this method is in general insufficient for integrating standard mathematical modelling techniques with the Event Calculus, for several reasons. First, the majority of mathematical models are expressed as sets of differential equations, and these cannot in general be solved so as to produce explicit functions of time for each parameter involved. Second, there might only be incomplete knowledge, expressed perhaps using inequalities, about the mathematical relationship between various parameters and/or their derivatives. Third, the circumstances under which various mathematical relationships hold between parameters might not be (easily) expressible in terms of a single fluent. Fourth, trajectories and antitrajectories do not provide mechanisms for describing continuous change in time intervals before any relevant initiating and/or terminating actions have occurred.</p><p>A more general approach is to include domain independent axioms which explicitly utilise the mathematical definitions of continuity and differentiability of real-valued functions of time. Under this approach, which is partly inspired by Sandewall's work <ref type="bibr" target="#b53">[54,</ref><ref type="bibr" target="#b54">55]</ref> and described in more detail in <ref type="bibr" target="#b41">[42]</ref>, continuity of realvalued parameters is regarded as a default analogous to default persistence of fluents, so that discontinuities arise only in particular parameters when specific actions occur. For this section, we will assume that time is represented either as the real numbers or as the non-negative real numbers. We will assume that some or all terms of sort P (introduced in Section 3.5) represent real-valued functions of time, and accordingly introduce two new function symbols V alue : P ×T → R and δ : P → P. The term Value(P, T ) represents the numerical value of parameter P at time T , and the axiomatisation below ensures that the term Value(δ(P ), T ) represents the numerical value at time T of its first derivative (at all time-points where this exists).</p><p>To integrate the standard mathematical concepts of continuity and differentiability into the Event Calculus, we need to express them in terms of Value and δ. It is also convenient to introduce the predicates LeftContinuous ⊆ P × T and RightLimit ⊆ P × T to capture the corresponding (standard) mathematical concepts <ref type="foot" target="#foot_4">6</ref> :</p><formula xml:id="formula_57">Continuous(p, t) ≡ ∀r∃t 1 ∀t 2 [[|t -t 2 | &lt; t 1 ∧ 0 &lt; r] (EC20j) → |Value(p, t) -Value(p, t 2 )| &lt; r] Differentiable(p, t) ≡ (EC21j) ∀r∃t 1 ∀t 2 [[0 &lt; |t -t 2 | &lt; t 1 ∧ 0 &lt; r] → |( Value(p,t)-Value(p,t2) t-t2 ) -Value(δ(p), t)| &lt; r] LeftContinuous(p, t) ≡ (EC22j) ∀r∃t 1 ∀t 2 [[t 2 &lt; t ∧ (t -t 2 ) &lt; t 1 ∧ 0 &lt; r] → |Value(p, t) -Value(p, t 2 )| &lt; r] RightLimit(p, t, r) ≡ (EC23j) ∀r 1 ∃t 1 ∀t 2 [[t &lt; t 2 ∧ (t 2 -t) &lt; t 1 ∧ 0 &lt; r 1 ] → |Value(p, t 2 ) -r| &lt; r 1 ]</formula><p>To respect the convention that actions take effect immediately after they occur, it is necessary to axiomatise the mathematical constraint that, at every time-point (including those at which actions occur), the function associated with each parameter is left-hand continuous:</p><formula xml:id="formula_58">LeftContinuous(p, t) (EC24j)</formula><p>To describe instantaneous changes in the values of parameters at times when actions occur, and discontinuities in their corresponding functions of time, the predicates BreaksTo ⊆ A × P × T × R and Breaks ⊆ A × P × T are introduced.</p><p>Both are minimised (by circumscribing them in parallel). BreaksTo(A, P, T, R) should be read as 'at time T , an occurrence of action A will cause parameter P to instantaneously take on value R'. More precisely, Axiom (EC27j) below states that if A does indeed occur at time T , then R is the value of the right-hand limit of P at T . Breaks(A, P, T ) can be read as 'at time T , action A potentially causes a discontinuity in parameter P '. The following domain-independent axioms make direct use of BreaksTo and Breaks. Axioms (EC25j) and (EC26j) can be likened to 'frame axioms' for parameters. Axiom (EC28j) states the relationship between BreaksTo and Breaks, and Axiom (EC29j) states that if an action potentially causes a discontinuity in a given parameter, it also potentially causes discontinuities in its higher derivatives.</p><formula xml:id="formula_59">¬[Happens(a, t) ∧ Breaks(a, p, t)] → Continuous(p, t) (EC25j) ¬[Happens(a, t) ∧ Breaks(a, δ(p), t)] → Differentiable(p, t) (EC26j) [BreaksTo(a, p, t, r) ∧ Happens(a, t)] → RightLimit(p, t, r) (EC27j) BreaksTo(a, p, t, r) → Breaks(a, p, t) (EC28j) Breaks(a, p, t) → Breaks(a, δ(p), t)<label>(EC29j)</label></formula><p>To make useful derivations using this axiomatisation, for any given time point T it is useful to be able to refer to the next point after T at which an action occurs, if there is such a point. Axioms (EC30j), (EC31j) and (EC32j) state that if any action occurs at any time point after T , then the term Next(T ) refers to the least such time point. (Such points are somewhat analogous to the "least natural time points" discussed in <ref type="bibr" target="#b50">[51]</ref>.)</p><formula xml:id="formula_60">t &lt; Next(t) (EC30j) [t &lt; t 1 ∧ t 1 &lt; Next(t)] → ¬Happens(a, t 1 ) (EC31j) [Happens(a 1 , t 1 ) ∧ t &lt; t 1 ] → ∃a.Happens(a, Next(t)) (EC32j)</formula><p>The above axiomatisation leaves us free to include (unsolved) sets of simultaneous differential equations in domain descriptions. As a simple illustration, suppose we wish to represent that the rate of change of the level of liquid in a tank is negatively proportional to the flow through a valve in its bottom, and that when the valve is open the flow is in turn proportional to the level (i.e. pressure). We need a single fluent ValveOpen, two parameters Level and Flow , and actions OpenValve and CloseValve. As well as Happens, Initiates and Terminates facts such as</p><formula xml:id="formula_61">Initiates(OpenValve, ValveOpen, t) (V1)</formula><p>Terminates(CloseValve, ValveOpen, t)</p><formula xml:id="formula_62">(V2)</formula><p>we can represent information about the instantaneous effects of actions on parameters using Breaks, Breaks(OpenValve, Flow , t) (V3)</p><formula xml:id="formula_63">Breaks(OpenValve, δ(Level ), t) (V4)</formula><p>and include mathematical constraints (differential equations) which hold in different circumstances, e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Value(δ(Level</head><formula xml:id="formula_64">), t) = -Value(Flow , t) (V5) HoldsAt(ValveOpen, t) → ∃r[Value(Flow , t) = r.Value(Level , t)] (V6)</formula><p>In this case the full theory will include the circumscription CIRC [(EC28j) ∧ (EC29j) ∧ (V3) ∧ (V4) ; Breaks, BreaksTo]. The Event Calculus now allows us to infer new boundary conditions for sets of differential equations which become applicable when actions such as OpenValve and CloseValve occur. A variation of this example is discussed in more detail in <ref type="bibr" target="#b41">[42]</ref>.</p><p>The above axiomatisation lays a foundation for integrating the Event Calculus with representational and computational techniques from the field of Qualitative Reasoning <ref type="bibr" target="#b8">[9]</ref>  <ref type="bibr" target="#b33">[34]</ref>. An Event Calculus based axiomatisation of some of the basic concepts in <ref type="bibr" target="#b33">[34]</ref> is given in <ref type="bibr" target="#b41">[42]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9">Other Issues and Extensions</head><p>Space limitations forbid a detailed summary of all work done on extending the classical logic Event Calculus in this article. In particular, three important topics we have not covered are hierarchical actions, ramifications, and knowledge producing actions.</p><p>Hierarchical or compound actions are non-instantaneous actions whose occurrence consists of the occurrence of a set of shorter actions. (For example, the "go to work" action might comprise a "walk to the station" action, a "get the train" action and a "walk to the office" action.) These can be formalised in the Event Calculus using "happens if happens" formulae. For more details, see <ref type="bibr" target="#b62">[63]</ref> or <ref type="bibr" target="#b67">[68]</ref>. Davila <ref type="bibr" target="#b9">[10]</ref> has done related work on formulating programming constructs within an Event Calculus framework.</p><p>The ramification problem is the problem of representing permanent constraints between collections of fluents, and indirect effects of actions propagated via such constraints, whilst preserving a succinct and elaboration tolerant solution to the frame problem. Shanahan <ref type="bibr" target="#b65">[66]</ref> has shown that a straightforward extension of the Event Calculus can handle many canonical examples of the ramification problem, including those in which concurrent events simultaneously affect the same fluent. In Section 4 we show an equivalence between the Event Calculus and the Language E <ref type="bibr" target="#b20">[21]</ref>, and E has been extended to deal with ramifications in <ref type="bibr" target="#b21">[22]</ref> by using fixed point definitions to express how actions indirectly initiate and terminate fluents. It seems likely that this same technique can be described in the classical Event Calculus using inductive definitions similar to those in <ref type="bibr" target="#b68">[69]</ref> and <ref type="bibr" target="#b69">[70]</ref>.</p><p>To our knowledge, little work has been done in the Event Calculus on representing the effects of knowledge producing actions. These are important, for example, in the context of planning. To catch a flight, an agent may plan to go to the airport and then look at the departures board to find out which gate the flight is boarding from. The action of looking at the board doesn't change the state of the external world but rather the agent's knowledge of it. To reason about such actions, the agent has to have a model about its own future knowledge state and how this will relate to the external world. Work on addressing these issues in the context of other action formalisms can be found for example in <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b45">[46]</ref>, <ref type="bibr" target="#b46">[47]</ref> and <ref type="bibr" target="#b56">[57]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Correspondence Result</head><p>The focus of the previous sections has been on the development of Event Calculus axiomatisations written in standard predicate calculus to represent knowledge about the effects of actions. In this sense it follows the tradition established by McCarthy and others in developing the Situation Calculus <ref type="bibr" target="#b39">[40]</ref>. Implicit in such work is the idea that such classical logic theories can act as specifications for computer programs that simulate various forms of reasoning about the domains represented. However, more recently there has been a trend towards the use of more specialised logics for representing and reasoning about the effects of actions, and in particular a growing body of work on the development and implementation of "action description languages" <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>. It is not our intention here to argue the merits and demerits of specialised as opposed to general purpose logics. (We do not for example subscribe to the view that formulations in classical or other general purpose logics require formulations in specialised logics to act as their "specification" or "semantics", or that specialised logics are at a "higher level" because they lack a proof theory.) However, it is clearly advantageous to explore correspondences between various types of representation, so that results and implementations for one approach can be more readily adapted to others.</p><p>While the majority of action description languages bear a resemblance to the Situation Calculus, the Language E <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref> is inspired by, and inherits its ontology from, the Event Calculus. In this section we describe the circumstances under which Event Calculus theories correspond to Language E domain descriptions and may thus take advantage of the provably correct automated proof procedures that have been developed for E (see e.g. <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b25">[26]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Language E</head><p>The definition of the Language E given here corresponds to that in <ref type="bibr" target="#b20">[21]</ref>. (This definition has subsequently been extended in various ways, in particular to deal with ramifications and the ramification problem <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref>.)</p><p>The Language E is really a collection of languages. The particular vocabulary of each language depends on the domain being represented, but always includes a set of fluent constants, a set of action constants, and a partially ordered set of time-points. A fluent literal may either be a fluent constant or its negation, as shown in the following definitions.</p><p>Definition 1 (Domain Language). A domain language is a tuple Π, , ∆, Φ , where is a partial (possibly total) ordering defined over the non-empty set Π of time points, ∆ is a non-empty set of action constants, and Φ is a non-empty set of fluent constants.</p><p>Definition 2 (Fluent literal). A fluent literal of E is an expression either of the form F or of the form ¬F , where F ∈ Φ.</p><p>Three types of statements are used to describe domains; h-propositions ("h" for "happens"), t-propositions ("t" for "time point") and c-propositions ("c" for "causes"). Their intended meanings are clear from their definitions:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (h-proposition). An h-proposition in E is an expression of the form</head><p>A happens-at T where A ∈ ∆ and T ∈ Π.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (t-proposition). A t-proposition in E is an expression of the form</head><p>L holds-at T where L is a fluent literal of E and T ∈ Π. C-propositions of the form "A initiates F when ∅" and "A terminates F when ∅" can be written more simply as "A initiates F " and "A terminates F " respectively. A domain description in E is a triple γ, η, τ , where γ is a set of c-propositions, η is a set of h-propositions and τ is a set of t-propositions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (c-proposition). A c-proposition in E is an expression either of the form</head><p>The Event Calculus domain described in Section 2.1 might be described as an E domain description D R as follows. The definition of a model in E is parametric on the definitions of an initiation point and a termination point. Initiation and termination points are simply timepoints where a c-proposition and an h-proposition combine to describe a direct effect on a particular fluent: Definition 8 (Initiation/termination point). Let H be an interpretation of E, let D = γ, η, τ be a domain description, let F ∈ Φ and let T ∈ Π. T is an initiation-point (respectively termination-point) for F in H relative to D iff there is an A ∈ ∆ such that (i) there is both an h-proposition in η of the form "A happens-at T " and a c-proposition in γ of the form "A initiates F when C" (respectively "A terminates F when C") and (ii) H satisfies C at T .</p><p>For an interpretation to qualify as a model, three basic properties need to be satisfied; (1) fluents change their truth values only via occurrences of initiating or terminating actions, (2) initiating a fluent establishes its truth value as true, and (3) terminating a fluent establishes its truth value as false. In addition, (4) every model must match with each of the t-propositions in the domain description: Definition 9 (Model). Given a domain description D = γ, η, τ in E, an interpretation H of E is a model of D iff, for every F ∈ Φ and T, T , T 1 , T 3 ∈ Π such that T 1 ≺ T 3 , the following properties hold: As regards the robot example, using the above definitions it is easy to see that D R |= E ¬Inside holds-at 8 More generally, if time is taken as the integers or reals, Definitions 8 and 9 indicate that the Language E corresponds to the "deterministic" Event Calculus described in Section 3.2, i.e. with domain independent axioms (EC1), (EC2), (EC3b), (EC4b), (EC5), (EC6), (EC9b) and (EC10b). Specifically condition 1 of Definition 9 mirrors axioms (EC1), (EC2), (EC5) and (EC6), condition 2 mirrors (EC3b) and (EC9b), and condition 3 mirrors (EC4b) and (EC10b). This correspondence is established more formally in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Translating Between the Event Calculus and E</head><p>Clearly, for some domains (such as the robot example) translation from the Event Calculus to E (and vice versa) is straightforward. Equally clearly, for some other Event Calculus theories, perhaps with disjunctive or existentially quantified sentences partially defining Initiates, Terminates, Happens or HoldsAt (e.g. the robot example extended with (R13)), a translation into the restricted syntax of E is not possible. But it is difficult and cumbersome in general to describe necessary and sufficient syntactic conditions whereby an Event Calculus theory can be translated into an equivalent Language E domain description.</p><p>To illustrate, consider the following Event Calculus description of a "millennium counter" -a display of the minutes passed since 12 midnight on 31 December 2000. Time is taken as the integers, where each integer represents one second and 0 represents 12 midnight, 31 December 2000. An action Tick happens once every 60 seconds and increments the display by 1:</p><formula xml:id="formula_65">Initiates(a, f, t) ≡ [a = Tick ∧ ∃n.[f = Display(n) ∧ HoldsAt(Display(n -1), t)]] Terminates(a, f, t) ≡ [a = Tick ∧ ∃n.[f = Display(n) ∧ HoldsAt(Display(n), t)]] Happens(a, t) ≡ [a = Tick ∧ ∃t .[t = (t * 60)]] HoldsAt(Display(0), 0) ∧ ∀n.[n = 0 → ¬HoldsAt(Display(n), 0)]</formula><p>This axiomatisation might at first seem problematic as regards translation into E; it entails an infinite number of positive ground Initiates, Terminates and Happens literals and (even without augmentation with domain independent Event Calculus axioms) an infinite number of negative ground HoldsAt literals (at t = 0). All of these need explicit representation in E. But the following (infinite) Language E domain description γ, η, τ is well defined and clearly entails the same collection of "holds at" facts along the time line:</p><formula xml:id="formula_66">γ = {Tick terminates Display(n) when {Display(n)} | n ∈ Z} ∪ {Tick initiates Display(n) when {Display(m)} | n, m ∈ Z and n = m+1} η = {Tick happens-at (t * 60) | t ∈ Π} τ = {Display(0) holds-at 0} ∪ {¬Display(n) holds-at 0 | n ∈ Z and n = 0}</formula><p>This example illustrates that any general syntactic constraints that we place on Event Calculus theories in order to ensure that they are translatable into E are likely to be over-restrictive. In what follows, we therefore instead concentrate on establishing a collection of sufficient (and intuitive) "semantic" constraints for a correct translation to be possible. Each of these will in most cases be straightforward to check from the form of the axiomatisation in question. Precisely what we mean by a "correct translation" is established in Proposition 1.</p><p>In Definitions 12 to 20 and Proposition 1 that follow, we will assume that D = γ, η, τ is a Language E domain description written in the language Π, ≤ , ∆, Φ (where Π is either Z or R). We will also assume that T EC is a collection of (domain dependent) axioms written in a sorted predicate calculus language of the type described in Section 2 that constrains the interpretation of the sort T to be Π, and that T EC does not mention the predicates Clipped , Declipped , StoppedIn and StartedIn. Furthermore we will assume that the language of T EC includes all symbols in ∆ as ground terms of sort A and all symbols in Φ as ground terms of sort F. Notation: We will denote as Φ ± the set of all (positive and negative) fluent literals that can be formed from the fluent constants in Φ. Given a model M of T EC , G M will denote the interpretation (i.e. the denotation) of the ground term or symbol G in M . We will refer to the set of domain independent Event Calculus axioms {(EC1), (EC2), (EC3b), (EC4b), (EC5), (EC6), (EC9b), (EC10b)} (see Sections 2 and 3.2) as Det EC .</p><p>The first condition to express is that (in all its models) T EC establishes uniqueness of names for the fluents and actions referred to in D: The next condition to establish (Definitions 13 to 16 below) is that all interpretations of Initiates, Terminates and Happens licensed by T EC are isomorphic to the unique interpretation (relative to the interpretation of HoldsAt) explicitly indicated by the c-and h-propositions in D: Finally, it is necessary to establish that (without the domain independent Event Calculus axioms in Det EC ), T EC imposes exactly the same collection of pointwise constraints on the interpretation of HoldsAt that are indicated by the t-propositions in D. To do this it is necessary to impose a domain closure property on fluent names (the first condition in <ref type="bibr">Definition 19)</ref>. It is also necessary to ensure that T EC does not entail any extra "global dependencies" not captured by the t-propositions of D, either between two or more fluents (e.g. ∀t.[HoldsAt(HasKey, t) → HoldsAt(Inside, t)]), or between fluents and other facts represented in T EC (e.g. ∀t.[HoldsAt(HasKey, t) → SmallEnoughToHold (Key)]). This is guaranteed by the third condition in Definition 19.</p><formula xml:id="formula_67">Definition 13 (h-satisfies). Given a model M of T EC , a time-point T ∈ Π and a set C ⊆ Φ ± of Language E fluent literals, M h-satisfies C at T iff for all F ∈ Φ, if F ∈ C then F M , T ∈ HoldsAt M ,</formula><p>Definition 17 (t-model). An interpretation H of E is a t-model of D iff, for every F ∈ Φ and T, T ∈ Π, for all t-propositions in τ of the form "F holds-at T ", H(F, T ) = true, and for all t-propositions of the form "¬F holds-at T ", H(F, T ) = false. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of (3):</head><p>This is identical to the proof of (1), but substituting "H(F, T ) = false" for "H(F, T ) = true" and substituting "M H -¬HoldsAt(F, T )" for "M H -HoldsAt(F, T )".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of (4):</head><p>This is identical to the proof of ( <ref type="formula">2</ref>), but substituting "M -¬HoldsAt(F, T )" for "M -HoldsAt(F, T )" and substituting "H M (F, T ) = false" for "H M (F, T ) = true".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(end of proof of Proposition 1)</head><p>Proposition 1 is analogous in some respects to the results in <ref type="bibr" target="#b26">[27]</ref>, which show the equivalence of various classical logic formulations of the Situation Calculus to the Language A. But whereas the conditions for the results in <ref type="bibr" target="#b26">[27]</ref> are syntactic, those for Proposition 1 are semantic and so less restrictive. Although checking through all the conditions for Proposition 1 to hold might at first sight seem tedious, in many cases the fact that a collection of domain dependent axioms "matches" a Language E domain description will be obvious. In particular, it is clear that any Language E domain description written using only a finite number of action and fluent constants can be straightforwardly translated into an Event Calculus axiomatisation by formulating sentences analogous to (R1) -(R4) (see Section 2.1).</p><p>As stated earlier, Proposition 1 is useful because it allows the (deterministic) classical logic Event Calculus to take advantage of the provably correct automated reasoning procedures developed for E (see <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>). Of these implementations, the most flexible is that described in <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref>, which is based on a sound and complete translation of E into an argumentation framework. The resulting implementation E-RES <ref type="bibr" target="#b23">[24]</ref> [26] allows reasoning backwards and forwards along the time line even in cases where information about what holds in the "initial state" (i.e. before any action occurrences) is incomplete. E-RES has been further extended into an abductive planning system <ref type="bibr" target="#b24">[25]</ref> able to produce plans and conditional plans even with incomplete information about the status of fluents along the time line.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Summary</head><p>In this article, we have described a basic, classical logic variation of the Event Calculus, and then summarised previous work on how this axiomatisation may be adapted and/or extended in various ways to represent various features of particular domains. In particular, we have described versions of the Event Calculus able to incorporate non-deterministic actions, concurrent actions, action preconditions and qualifications, delayed actions and effects, actions with duration, gradual and continuous change, and mathematical models using sets of simultaneous differential equations. We have also shown how one particular version of the basic Event Calculus may be given a sound and complete translation into the Language E and thus inherit E's provably correct automated reasoning procedures.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Terminates(Set, SwitchedOn, t) (A10e) axiom (EC11) will not inform us that the countdown is activated even in the circumstance where fluent SwitchedOn holds immediately after time 2. One solution is to replace (EC11) and (EC12) with equivalent axioms which have an extra HoldsAt condition in their right-hand sides, but use StoppedIn and StartedIn (see axioms (EC9b) and (EC10b)) instead of Clipped and Declipped :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>A</head><label></label><figDesc>initiates F when C or of the form A terminates F when C where F ∈ Φ, A ∈ ∆, and C is a set of fluent literals of E.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>6 (</head><label>6</label><figDesc>For action and fluent constants we would have ∆ = {Insert, GoThrough, Pickup} and Φ = {Inside, HasKey, Locked } respectively. For Π and we would use the real numbers with the usual ordering relation. Axioms (R1)-(R4) would be expressed in D R as: Pickup initiates HasKey Insert initiates Locked when {¬Locked , HasKey} GoThrough initiates Inside when {¬Locked , ¬Inside} GoThrough terminates Inside when {¬Locked , Inside} Insert terminates Locked when {Locked , HasKey} Locked holds-at 0 Inside holds-at 0 Pickup happens-at 2 Insert happens-at 4 GoThrough happens-at The reader may also find it useful to compare this collection of propositions with axioms (R5)-(R12) in Section 2.2.) The semantics of E is based on simple definitions of interpretations and models. Since the primary interest is in inferences about what holds at particular time-points in Π, it is sufficient to define an interpretation as a mapping of fluent/time-point pairs to true or false (i.e. a "holds" relation). An interpretation satisfies a fluent literal or set of fluent literals at a particular time-point if it assigns the relevant truth values to each of the corresponding fluent constants: Definition 6 (Interpretation). An interpretation of E is a mapping H : Φ × Π → {true, false} Definition 7 (Point satisfaction). Given a set of fluent literals C of E and a time point T ∈ Π, an interpretation H satisfies C at T iff for each fluent constant F ∈ C, H(F, T ) = true, and for each fluent constant F such that ¬F ∈ C, H(F , T ) = false.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 12 (</head><label>12</label><figDesc>Name-matches). D name-matches T EC iff for every model M of T EC , for every F, F ∈ Φ and for everyA, A ∈ ∆, -if F = F then F M = F M , and if A = A then A M = A M .Typically this name-matches property might be established by a collection of inequality statements in T EC between ground fluent and action literals (e.g. Inside = HasKey, etc. in the Robot example) or by universally quantified implications such as ∀m, n.[Display(m) = Display(n) → m = n].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 18 (Proposition 1 .</head><label>181</label><figDesc>E-projection). The E-projection of a model M of T EC is defined as the following (Language E) interpretation H M :H M (F, T ) = true if F M , T ∈ HoldsAt M false otherwiseDefinition 19 (Holds-matches). D holds-matches T EC iff for every model M of T EC the following conditions are satisfied:for every fluent φ in the domain of discourse of M there existsF ∈ Φ such that φ = F M , -the E-projection of M is a t-model of D, -For every t-model H t of D there is a model M H t ofT EC which differs from M only in the interpretation of HoldsAt and is such that H t is the E-projection of M H t . Definition 20 (matches). D matches T EC iff D name-matches, initiatesmatches, terminates-matches, happens-matches and holds-matches T EC . Let F ∈ Φ and let T ∈ Π. If T EC is consistent and D matches T EC then:-D |= E F holds-at T iff T EC ∪ Det EC |= HoldsAt(F, T ) -D |= E ¬F holds-at T iff T EC ∪ Det EC |= ¬HoldsAt(F, T )Proof. It is sufficient to prove the following: 1. If there exists a model H of D such that H(F, T ) = true then there exists a model M H of T EC ∪ Det EC such that M H -HoldsAt(F, T ). 2. If there exists a model M of T EC ∪Det EC such that M -HoldsAt(F, T ) then there exists a model H M of D such that H M (F, T ) = true. 3. If there exists a model H of D such that H(F, T ) = false then there exists a model M H of T EC ∪ Det EC such that M H -¬HoldsAt(F, T ). 4. If there exists a model M of T EC ∪ Det EC such that M -¬HoldsAt(F, T ) then there exists a model H M of D such that H M (F, T ) = false. Proof of (1): If there exists a model H of D such that H(F, T ) = true then by Definitions 9 and 17 H is a t-model of D. Hence, since T EC is consistent, by Definition 19 there exists a model M H of T EC such that H is the E-projection of M H . Therefore M H -HoldsAt(F, T). Since T EC does not mention the predicates Clipped , Declipped , StoppedIn and StartedIn then clearly we can assume that M H is such that it satisfies (EC1), (EC2), (EC9b) and (EC10b). Since D name-matches, initiates-matches, terminates-matches and happensmatches T EC then by condition 1 of Definition 9 M H satisfies (EC5) and (EC6), by condition 2 of Definition 9 M H satisfies (EC3b), and by condition 3 of Definition 9 M H satisfies (EC4b). Therefore M H is a model of T EC ∪Det EC .Proof of (2):If there exists a model M of T EC ∪ Det EC such that M -HoldsAt(F, T ), then by Definition 19 the E-projection H M of M is a t-model of D and H M (F, T ) = true. It remains to show that H M satisfies conditions 1, 2 and 3 of Definition 9. Since D name-matches, initiates-matches, terminates-matches and happens-matches T EC , it follows directly from the fact that M -[(EC5)∧(EC6)] that H M satisfies condition 1 of Definition 9, it follows directly from the fact that M -(EC3b) that H M satisfies condition 2 of Definition 9, and it follows directly from the fact that M -(EC4b) that H M satisfies condition 1 of Definition 9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>are</head><label></label><figDesc>Clipped (t 1 , f, t 2 )</figDesc><table><row><cell>def ≡ ∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 ∧ Terminates(a, f, t)]</cell><cell>(EC1)</cell></row><row><cell>Declipped (t 1 , f, t 2 )</cell><cell></cell></row></table><note><p>def ≡ ∃a, t[Happens(a, t) ∧ t 1 ≤ t &lt; t 2 (EC2) ∧ Initiates(a, f, t)]</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>time T 1 and continues to hold until time T 1 +T 2 , this results in F 2 holding at time T 1 +T 2 (similarly for AntiTrajectory). In the alarm clock example Countdown would then be parameterised, (A3), (A4) and (A6) would be written</figDesc><table><row><cell>Happens(StartRing, t) ← HoldsAt(Countdown(0), t)</cell><cell>(A4f)</cell></row><row><cell>HoldsAt(Countdown(8), t) ← ¬HoldsAt(SwitchedOn, t)</cell><cell>(A7f)</cell></row><row><cell>and the domain description would include the additional constraint</cell><cell></cell></row><row><cell>[HoldsAt(Countdown(x 1 ), t) ∧ HoldsAt(Countdown(x 2 ), t)] → x 1 = x 2</cell><cell>(A10f)</cell></row><row><cell>Trajectory(SwitchedOn, t 1 , Countdown(8-t 2 ), t 2 )</cell><cell>(A3f)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1. If there is no initiation-point or termination-pointT 2 for F in H relative to D such that T 1 T 2 ≺ T 3 , then H(F, T 1 ) = H(F, T 3 ). 2. If T 1 is an initiation-point for F in H relative to D, and there is no termination-point T 2 for F in H relative to D such that T 1 ≺ T 2 ≺ T 3 , then H(F, T 3 ) = true. 3. If T 1 is a termination-point for F in H relative to D, and there is no initiation-point T 2 for F in H relative to D such that T 1 ≺ T 2 ≺ T 3 , then H(F, T 3 ) = false.<ref type="bibr" target="#b3">4</ref>. For all t-propositions in τ of the form "F holds-at T ", H(F, T ) = true, and for all t-propositions of the form "¬F holds-at T ", H(F, T ) = false.</figDesc><table><row><cell>Definition 10 (Consistency). A domain description is consistent iff it has a</cell></row><row><cell>model.</cell></row><row><cell>Definition 11 (Entailment). A domain description D entails the t-</cell></row><row><cell>proposition "F holds-at T ", written 7 "D |= E F holds-at T ", iff for every model H of D, H(F, T ) = true. D entails the t-proposition "¬F holds-at T "</cell></row><row><cell>iff for every model H of D, H(F, T ) = false.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>and if ¬F ∈ C then F Definition 15 (Terminates-matches). D terminates-matches T EC iff for every model M of T EC , every time-point T and every action α and fluent φ in the domain of discourse of M the following holds. α, φ, T ∈ Terminates M if and only if there exist F ∈ Φ, A ∈ ∆ and C ⊆ Φ ± such that α = A M , φ = F M , M h-satisfies C at T , and "A terminates F when C" ∈ γ. Definition 16 (Happens-matches). D happens-matches T EC iff for every model M of T EC , every time-point T and every action α in the domain of discourse of M the following holds. α, T ∈ Happens M if and only if there exists A ∈ ∆ such that α = A M and "A happens-at T " ∈ η.</figDesc><table /><note><p>M , T ∈ HoldsAt M . Definition 14 (Initiates-matches). D initiates-matches T EC iff for every model M of T EC , every time-point T and every action α and fluent φ in the domain of discourse of M the following holds. α, φ, T ∈ Initiates M if and only if there exist F ∈ Φ, A ∈ ∆ and C ⊆ Φ ± such that α = A M , φ = F M , M h-satisfies C at T , and "A initiates F when C" ∈ γ.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>In this case the collection of uniqueness-of-names axioms will consist of a sentence such as Inside = HasKey for each pair of fluent names and action names. In domains where parameterised fluents or actions are used, e.g. a Lower (x) action to represent the act of lowering an object x meters, it might also typically include sentences such as Lower (x1) = Lower (x2) → x1 = x2. The inclusion of such uniqueness-of-names axioms is not obligatory (we might for example wish to deliberately use two names to refer to the same action), but their omission will generally lead to unexpected results.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Or we may wish to distinguish between actions performed by the agent and events occurring in the environment and outside the agent's control.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>That is to say, planning can be specified as a deductive task. We do not wish to claim that general purpose classical theorem provers are practical as planning systems.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>These predicates are referred to as InitiallyTrue and InitiallyFalse in<ref type="bibr" target="#b41">[42]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>A function is left-continuous if discontinuities occur only between successive intervals where the first is closed on the right and the second is open on the left. For example the function f (t) = 0 for all t ≤ 1, f (t) = 2 otherwise, is left-continuous at all time-points, whereas the function f (t) = 0 for all t &lt; 1, f (t) = 2 otherwise, is not. The right-limit of a function at a particular point is the limit value as the point is approached from the right. So, for example, the right-limit of both f and f at 1 is 2.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>The symbol |=E is used here to distinguish Language E entailment from entailment in classical logic. It is identical in meaning to the symbol |= used in other publications concerning the Language E.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Nonmonotonic Reasoning in the Framework of the Situation Calculus</title>
		<author>
			<persName><forename type="first">A</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="5" to="23" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Modal Calculus of Partially Ordered Events in a Logic Programming Framework</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chittaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ICLP&apos;95</title>
		<meeting>ICLP&apos;95</meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="299" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A General Modal Framework for the Event Calculus and its Skeptical and Credulous Variants</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chittaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth European Conference on Artificial Intelligence (ECAI&apos;96)</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Wahlster</surname></persName>
		</editor>
		<meeting>the Twelfth European Conference on Artificial Intelligence (ECAI&apos;96)</meeting>
		<imprint>
			<publisher>John Wiley and Sons</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="33" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Hierarchy of Modal Event Calculi: Expressiveness and Complexity</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franceschet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Temporal Logic (ICTL&apos;97</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</editor>
		<meeting>the 2nd International Conference on Temporal Logic (ICTL&apos;97</meeting>
		<imprint>
			<publisher>Kluwer Applied Logic Series</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Modal Event Calculi with Preconditions</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franceschet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Workshop on Temporal Reasoning (TIME&apos;97)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Khatib</surname></persName>
		</editor>
		<meeting>the Fourth International Workshop on Temporal Reasoning (TIME&apos;97)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="38" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Complexity of Model Checking in Modal Event Calculi with Quantifiers</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franceschet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Montanari</surname></persName>
		</author>
		<ptr target="http://www.ida.liu.se/ext/etai/" />
	</analytic>
	<monogr>
		<title level="j">Journal of Electronic Transactions on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Linköping University Electronic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Skeptical and Credulous Event Calculi for Supporting Modal Queries</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chittaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Montanari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Provetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh European Conference on Artificial Intelligence (ECAI&apos;94)</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Cohn</surname></persName>
		</editor>
		<meeting>the Eleventh European Conference on Artificial Intelligence (ECAI&apos;94)</meeting>
		<imprint>
			<publisher>John Wiley and Sons</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="361" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Chleq</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constrained Resolution and Abductive Temporal Reasoning</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">383406</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Formalizing Reasoning about Change: A Qualitative Reasoning Approach</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Etherington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings AAAI&apos;92</title>
		<meeting>AAAI&apos;92</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="577" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reactive Pascal and the Event Calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Davila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings FAPR&apos;96 Workshop on Reasoning about Actions and Planning in Complex Environments</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Siegmund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Thielscher</surname></persName>
		</editor>
		<meeting>FAPR&apos;96 Workshop on Reasoning about Actions and Planning in Complex Environments</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Temporal Reasoning with Abductive Event Calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Missiaen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ECAI 92</title>
		<meeting>ECAI 92<address><addrLine>Vienna</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Schreye A Realistic Experiment in Knowledge Representation in Open Event Calculus : Protocol Specification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Van Belleghem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Duchatelet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>De</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint International Conference and Symposium on Logic Programming</title>
		<meeting>the Joint International Conference and Symposium on Logic Programming</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An Inductive Definition Approach to Ramifications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Theseider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Dupré</surname></persName>
		</author>
		<author>
			<persName><surname>Van Belleghem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Transactions on Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Reasoning about Action and Change Using Occlusion</title>
		<author>
			<persName><forename type="first">P</forename><surname>Doherty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ECAI&apos;94</title>
		<meeting>ECAI&apos;94</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="401" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Abductive Planning with Event Calculus</title>
		<author>
			<persName><forename type="first">K</forename><surname>Eshghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference and Symposium on Logic Programming</title>
		<editor>
			<persName><forename type="first">Robert</forename><surname>Kowalski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kenneth</forename><surname>Bowen</surname></persName>
		</editor>
		<meeting>the 5th International Conference and Symposium on Logic Programming</meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="562" to="579" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Representing Actions in Extended Logic Programming, JICSLP&apos;92</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">560</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Representing Action and Change by Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JLP</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="301" to="322" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Jeffrey</surname></persName>
		</author>
		<title level="m">Formal Logic: Its Scope and Limits</title>
		<imprint>
			<publisher>McGraw-Hill</publisher>
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multi-Agent Planning Using an Abductive Event Calculus</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Burt</surname></persName>
		</author>
		<idno>RR-96-04</idno>
	</analytic>
	<monogr>
		<title level="j">DFKI</title>
		<imprint>
			<date type="published" when="1996">1996. 1996</date>
			<pubPlace>Germany</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">DFKI Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Jung</surname></persName>
		</author>
		<title level="m">Situated Abstraction Planning by Abductive Temporal Reasoning, Proceedings ECAI&apos;98</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page">383387</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Simple Declarative Language for Describing Narratives with Actions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kakas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special Issue on Reasoning about Action and Change</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="157" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Reasoning about Actions, Narratives and Ramifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kakas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<ptr target="http://www.ida.liu.se/ext/etai/" />
	</analytic>
	<monogr>
		<title level="j">Journal of Electronic Transactions on Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1998">1998</date>
			<publisher>Linköping University Electronic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An Argumentation Framework for Reasoning about Actions and Change</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kakas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Toni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LPNMR&apos;99</title>
		<meeting>LPNMR&apos;99</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">E-RES -A System for Reasoning about Actions, Events and Observations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kakas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Toni</surname></persName>
		</author>
		<ptr target="http://xxx.lanl.gov/abs/cs.AI/0003034" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of NMR 2000, Special Session on System Demonstrations and Descriptions</title>
		<meeting>NMR 2000, Special Session on System Demonstrations and Descriptions</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Planning with Incomplete Information, Proceedings of NMR 2000</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kakas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Toni</surname></persName>
		</author>
		<ptr target="http://xxx.lanl.gov/abs/cs.AI/0003049" />
	</analytic>
	<monogr>
		<title level="m">Special Session on Representing Actions and Planning</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">E-RES -Reasoning about Actions, Events and Observations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kakas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Toni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR&apos;2001)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Truszczynski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Faber</surname></persName>
		</editor>
		<meeting>the 6th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR&apos;2001)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>LNCS/LNAI series</publisher>
			<date type="published" when="2001">September 17-19, 2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Soundness and Completeness Theorems for Three Formalizations of Action</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Kartha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IJCAI&apos;93</title>
		<meeting>IJCAI&apos;93</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page">724</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A Simple Formalization of Actions Using Circumscription</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Kartha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IJCAI&apos;95</title>
		<meeting>IJCAI&apos;95</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="1970" to="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Database Updates in the Event Calculus</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="121" to="146" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</author>
		<title level="m">Legislation as Logic Programs, Informatics and the Foundations of Legal Reasoning</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Bankowski</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="325" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The Situation Calculus and Event Calculus Compared</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sadri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Logic Programming Symposium (ILPS&apos;94)</title>
		<meeting>the International Logic Programming Symposium (ILPS&apos;94)</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Reconciling the Event Calculus with the Situation Calculus</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sadri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming, Special Issue on Reasoning about Action and Change</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="39" to="58" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A Logic-Based Calculus of Events</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Sergot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="67" to="95" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Qualitative Reasoning: Modeling and Simulation with Incomplete Knowledge</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kuipers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Representing Beliefs in a Situated Event Calculus</title>
		<author>
			<persName><forename type="first">F</forename><surname>Lévy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Quantz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ECAI&apos;98</title>
		<meeting>ECAI&apos;98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page">547551</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">What is Planning in the Presence of Sensing?</title>
		<author>
			<persName><forename type="first">H</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI&apos;96</title>
		<meeting>AAAI&apos;96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Nonmonotonic Reasoning and Uncertain Reasoning</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Circumscription</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Handbook of Logic in Artificial Intelligence and Logic Programming</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Hogger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="297" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Adding Knowledge to the Action Description Language A</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lobo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mendez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI&apos;97</title>
		<meeting>AAAI&apos;97</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Circumscription A Form of Non-Monotonic Reasoning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="27" to="39" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Some Philosophical Problems from the Standpoint of Artificial Intelligence</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence 4</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Meltzer</surname></persName>
		</editor>
		<imprint>
			<publisher>Edinburgh University Press</publisher>
			<date type="published" when="1969">1969</date>
			<biblScope unit="page" from="463" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Situation Calculus Specifications for Event Calculus Logic Programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Conference on Logic Programming and Non-monotonic Reasoning</title>
		<meeting>the Third International Conference on Logic Programming and Non-monotonic Reasoning<address><addrLine>Lexington, KY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Reasoning about Discontinuities in the Event Calculus</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1996 Knowledge Representation Conference (KR&apos;96)</title>
		<meeting>1996 Knowledge Representation Conference (KR&apos;96)</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page">6374</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">The Event Calculus in Classical Logic -Alternative Axiomatisations</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
		<ptr target="http://www.ep.liu.se/ej/etai/1999/016/" />
	</analytic>
	<monogr>
		<title level="m">Section A</title>
		<imprint>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="77" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Localized Abductive Planning for Robot Assembly</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Missiaen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1991 IEEE Conference on Robotics and Automation, pub. IEEE Robotics and Automation Society</title>
		<meeting>1991 IEEE Conference on Robotics and Automation, pub. IEEE Robotics and Automation Society</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="605" to="610" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">An Abductive Planning System Based on Event Calculus</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Missiaen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="579" to="602" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A Formal Theory of Knowledge and Action</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Theories of the Commonsense World</title>
		<editor>
			<persName><forename type="first">Moore</forename><surname>Hobbs</surname></persName>
		</editor>
		<meeting><address><addrLine>Ablex, Norwood, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Knowledge Preconditions for Actions and Plans</title>
		<author>
			<persName><forename type="first">L</forename><surname>Morgenstern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference in Artificial Intelligence 1987 (IJCAI&apos;97)</title>
		<meeting>the International Joint Conference in Artificial Intelligence 1987 (IJCAI&apos;97)</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Temporal Reasoning in Logic Programming: A Case for the Situation Calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings ICLP</title>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page">203</biblScope>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Hypothetical Reasoning about Actions: From Situation Calculus to Event Calculus</title>
		<author>
			<persName><forename type="first">A</forename><surname>Provetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Intelligence</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">The Frame Problem in the Situation Calculus: A Simple Solution (Sometimes) and a Completeness Result for Goal Regression</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</editor>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="359" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Natural actions, concurrency and continuous time in the situation calculus</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Knowledge Representation and Reasoning: Proceedings of the Fifth International Conference (KR&apos;96)</title>
		<meeting><address><addrLine>Cambridge, Massachusetts, U.S.A</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">November 5-8, 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">An Abductive Approach for Handling Inconsistencies in SCR Specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nuseibeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proceedings of the 3rd International Workshop on Intelligent Software Engineering (WISE3)</title>
		<meeting>the 3rd International Workshop on Intelligent Software Engineering (WISE3)<address><addrLine>Limerick, Ireland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-06">June, 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Variants of the Event Calculus</title>
		<author>
			<persName><forename type="first">F</forename><surname>Sadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Logic Programming</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Stirling</surname></persName>
		</editor>
		<meeting>the International Conference on Logic Programming<address><addrLine>Kanagawa, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="67" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Combining Logic and Differential Equations for Describing Real World Systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sandewall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings KR&apos;89</title>
		<meeting>KR&apos;89</meeting>
		<imprint>
			<publisher>Morgan Kaufman</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Sandewall</surname></persName>
		</author>
		<title level="m">Filter Preferential Entailment for the Logic of Action in Almost Continuous Worlds, Proceedings IJCAI&apos;89</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="894" to="899" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">The Representation of Knowledge about Dynamical Systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sandewall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Oxford University Press</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">The Frame Problem and Knowledge-Producing Actions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Scherl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI&apos;93</title>
		<meeting>AAAI&apos;93</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Representing Continuous Change in the Event Calculus</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ECAI&apos;90</title>
		<meeting>ECAI&apos;90</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="598" to="603" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">A Circumscriptive Calculus of Events</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="249" to="284" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
		<title level="m">Robotics and the Common Sense Informatic Situation, Proceedings ECAI&apos;96</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="684" to="688" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Noise and the Common Sense Informatic Situation for a Mobile Robot</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings AAAI&apos;96</title>
		<meeting>AAAI&apos;96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="1098" to="1103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Event Calculus Planning Revisited</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 4th European Conference on Planning (ECP&apos;97)</title>
		<title level="s">Springer Lecture Notes in Artificial Intelligence</title>
		<meeting>4th European Conference on Planning (ECP&apos;97)</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="390" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
		<title level="m">Noise, Non-Determinism and Spatial Uncertainty, Proceedings AAAI&apos;97</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="153" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
		<title level="m">Reinventing Shakey, Working Notes of the 1998 AAAI Fall Symposium on Cognitive Robotics</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="125" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">The Ramification Problem in the Event Calculus</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IJCAI&apos;99</title>
		<meeting>IJCAI&apos;99</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">A Logical Account of the Common Sense Informatic Situation for a Mobile Robot</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Transactions on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">The Event Calculus Explained, in Artificial Intelligence Today</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Springer-Verlag Lecture Notes in Artificial Intelligence no. 1600</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Wooldridge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Veloso</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="409" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Transactions and Change in Logic Databases</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ternovskaia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Inductive Definability and the Situation Calculus</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Freitag</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Decker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1472</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Causality via Inductive Definitions, in Working Notes of</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ternovskaia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">AAAI Spring Symposium Series</title>
		<imprint>
			<biblScope unit="page" from="94" to="100" />
			<date type="published" when="1998">March 23-28, 1998</date>
		</imprint>
	</monogr>
	<note>Prospects for a Commonsense Theory of Causation</note>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Representing Continuous Change in the Abductive Event Calculus</title>
		<author>
			<persName><forename type="first">K</forename><surname>Van Belleghem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">De</forename><surname>Schreye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1994 International Conference on Logic Programming</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Van Hentenrijck</surname></persName>
		</editor>
		<meeting>1994 International Conference on Logic Programming</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="225" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">The Abductive Event Calculus as a General Framework for Temporal Databases</title>
		<author>
			<persName><forename type="first">K</forename><surname>Van Belleghem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">De</forename><surname>Schreye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Temporal Logic</title>
		<meeting>the International Conference on Temporal Logic</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Combining Situation Calculus and Event Calculus</title>
		<author>
			<persName><forename type="first">K</forename><surname>Van Belleghem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">De</forename><surname>Schreye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Logic Programming</title>
		<meeting>the International Conference on Logic Programming</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">On the Relation Between Situation Calculus and Event Calculus</title>
		<author>
			<persName><forename type="first">K</forename><surname>Van Belleghem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">De</forename><surname>Schreye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Special Issue on Reasoning about Action and Change)</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>Journal of Logic Programming</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
