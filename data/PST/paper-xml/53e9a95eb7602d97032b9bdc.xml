<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Improving Xen Security through Disaggregation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge Computer Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Grzegorz</forename><surname>Milos</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge Computer Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Steven</forename><surname>Hand</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge Computer Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Improving Xen Security through Disaggregation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A7F20B8E645AEDD467389A8EB3B92699</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.6 [Operating Systems]: Security and Protection-Information flow controls General Terms Design</term>
					<term>Security Disaggregation</term>
					<term>trusted computing base</term>
					<term>virtual machines</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Virtual machine monitors (VMMs) have been hailed as the basis for an increasing number of reliable or trusted computing systems. The Xen VMM is a relatively small piece of software -a hypervisor -that runs at a lower level than a conventional operating system in order to provide isolation between virtual machines: its size is offered as an argument for its trustworthiness. However, the management of a Xen-based system requires a privileged, fullblown operating system to be included in the trusted computing base (TCB).</p><p>In this paper, we introduce our work to disaggregate the management virtual machine in a Xen-based system. We begin by analysing the Xen architecture and explaining why the status quo results in a large TCB. We then describe our implementation, which moves the domain builder, the most important privileged component, into a minimal trusted compartment. We illustrate how this approach may be used to implement "trusted virtualisation" and improve the security of virtual TPM implementations. Finally, we evaluate our approach in terms of the reduction in TCB size, and by performing a security analysis of the disaggregated system.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Many researchers have proposed using virtual machine monitors (VMMs) to improve the reliability, security or assurance of computing systems <ref type="bibr" target="#b9">[10]</ref>. They argue that the small code-base of a VMM can be used as justification for trusting its correct operation; this same argument has been applied to microkernels <ref type="bibr" target="#b30">[31]</ref>. The assumption is made that the integrity of the lower layers (including the VMM) is axiomatic, therefore it is possible to infer the integrity of components (individual virtual machines) running above <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>. We aim to use the Xen hypervisor <ref type="bibr" target="#b3">[4]</ref> as the basis of an "open trusted computing" system <ref type="bibr" target="#b19">[20]</ref>. Such an approach extends the purview of trusted computing hardware into virtual machines (VMs); it also allows the user discretion over when to use this hardware, and enables the use of trusted and untrusted software side-by-side.</p><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. VEE'08, <ref type="bibr">March 5-7, 2008</ref>, Seattle, Washington, USA Copyright c 2008 ACM 978-1-59593-796-4/08/03. . . <ref type="bibr">$5.00</ref> In order to evaluate the trustworthiness of a software system, it is necessary to identify its trusted computing base (TCB). The integrity of the TCB may then be measured, and this unforgeable measurement can be used to generate a key that may be used for attestation, encryption and decryption operations <ref type="bibr" target="#b32">[33]</ref>. However, the TCB of a current Xen-based system comprises, in addition to the VMM, a fully-fledged operating system (known as Dom0) and a set of user-space tools. These tools are used to perform several tasks that require elevated privileges, including the creation of new VMs. Due to the inclusion of user-space software in the TCB, the size of the TCB is practically unbounded, as it can include any software that may be run by the administrator of the physical platform. Furthermore, any measurement of the TCB cannot be used to guarantee the integrity of a virtual machine, because the system administrator may run arbitrary privileged code at any time. In effect, this implies that the system administrator must be trusted, which impairs the usefulness of Xen in utility computing scenarios <ref type="bibr" target="#b25">[26]</ref>.</p><p>In this paper, we demonstrate the use of disaggregation to shrink the TCB of a virtual machine in a Xen-based system. We have transferred the VM-building functionality into a small, trusted VM that runs alongside Dom0. We had two main goals in this work. The primary goal was to reduce and bound the TCB of a Xen-based system, in order to improve its security. In particular, by removing Dom0 user-space from the TCB, we would remove the requirement that the administrator of the physical platform be trusted. We anticipate that this will be relevant for the users of virtualisation in utility computing. A closely-related goal was to demonstrate that a VM running on a disaggregated system maintains the same confidentiality and integrity properties as a physical machine, assuming the inviolability of the TCB. This should allay many concerns over switching to a virtualised approach.</p><p>We begin by introducing the Xen architecture, the domain building process, and how these relate to the TCB of a Xen-based system (Section 2). We then describe our framework for selecting a TCB for the disaggregated solution, and introduce new criteria for evaluating a TCB that should be considered in addition to the raw number of lines of code (Section 3). We discuss the implementation of our disaggregated domain builder design, which has also necessitated the development of a lightweight inter-VM communication mechanism (Section 4). We evaluate our disaggregated approach against our primary goals by enumerating the contents of the TCB and performing a security analysis (Section 6). Finally, we consider related work (Section 7) and draw conclusions (Section 8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>The existing Xen VMM architecture and privilege model have implications for security, and enable an administrator to take full control of all virtual machines running on the same host. It is therefore impossible for the users of a virtual machine to trust in the confidentiality and integrity of that virtual machine. This may inhibit the uptake of virtualisation, especially in the class of applications where confidentiality is required by law.</p><p>In this section, we provide a brief overview of the Xen architecture (Subsection 2.1), describe the domain building process (Subsection 2.2), and discuss the design of Xen with respect to its trusted computing base (Subsection 2.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Xen architecture</head><p>The traditional representation of a Xen-based system shows several virtual machines, drawn separately and side-by-side on top of the Xen VMM (hypervisor), which itself is positioned above the platform hardware <ref type="bibr" target="#b3">[4]</ref>. A single VM, Dom0, is distinguished as a management or control VM, which is always booted by the hypervisor, and contains the control plane software. However, this picture ignores the trust relationships between Dom0 and the remaining VMs. In our work we aim to reduce and bound these trust relationships, so that Dom0 can accurately be positioned side-by-side with other VMs.</p><p>Xen makes extensive use of paravirtualisation in order to achieve good performance. This process entails porting VM kernels to run on a new machine architecture that corresponds to the support provided by the VMM. On the x86 architecture, four processor rings are used to define privilege levels. In most common operating systems, the kernel runs in ring 0 (the highest privilege level), and user processes run in ring 3 (the lowest privilege level). Xen must have full control over and protection from the VMs that it hosts, so it runs in ring 0. VM kernels are paravirtualised in order to run in ring 1. User processes continue to run in ring 3.</p><p>Xen provides many mechanisms for communication. The most primitive is the hypercall, which is an invocation of the hypervisor by a guest VM. A hypercall is analogous to a system call in conventional operating systems, and is also implemented using a software trap to transfer control to the hypervisor. Hypercalls are leveraged to build higher level communication primitives. In particular, in order to facilitate inter-VM communication, Xen provides event channels and a mechanism to establish shared memory regions <ref type="bibr" target="#b3">[4]</ref>. Shared memory can be established via the grant table interface or using direct foreign mappings <ref type="bibr" target="#b13">[14]</ref>.</p><p>Event channels are a lightweight event delivery mechanism that may be used both to virtualise interrupts and enable communication between VMs. They may be used to send only a single bit of information, and are typically employed to synchronise producers and consumers in virtual device drivers.</p><p>A grant reference is the index of an entry in a VM-owned grant table. Each entry contains the physical address of the page to be granted, the ID of the VM to which access is granted, and access control flags. When the grantee wants to map a granted page, it makes a hypercall, specifying the grant reference, granting VM ID, and instructions for where to map the granted page.</p><p>Direct foreign mappings are only possible in a privileged VM, typically only Dom0, and are used for platform management. A privileged VM can request that the hypervisor maps a specific physical frame of memory from a specific VM into one of its page tables. It is possible to make direct foreign mappings into both the kernel and user-space. User-space mappings are made by a privileged command driver (privcmd), the use of which is typically restricted to the administrator using file permissions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Building a new VM</head><p>In the Xen architecture, the creation of new VMs (known as domain building) is carried out by management software in Dom0, which uses its special privileges in order to access the address space and processor state of the new VM. The original design decision was that the domain building code is relatively complicated and should be omitted from the hypervisor for reasons of compactness and robustness <ref type="bibr" target="#b3">[4]</ref>. However, the delegation of this task to user-space processes exposes the special privileges to all user-space processes in Dom0, which has implications for the trusted computing base (see §2.3). In this subsection, we describe the process of building a paravirtualised VM. Thanks to paravirtualisation, many of the lowlevel steps involved in a conventional x86 OS boot process (such as interactions with the BIOS, and the use of 16-bit real mode) can be elided.</p><p>The main steps in the domain building process are shown in Figure <ref type="figure" target="#fig_0">1</ref>, with privileged operations (as defined later in §3.1) shown as bold arrows. Firstly, the kernel image (and, optionally, an initial ramdisk) are loaded from disk into the domain builder's memory. The image is parsed in order to extract the executable code region, and obtain any parameter values. Following this, the builder requests that the hypervisor allocates physical memory for the new VM. This is not depicted as a privileged operation, because it does not affect the confidentiality or integrity of any VM, but it can lead to denial of service, so its use should be restricted. The kernel image is then loaded into the new VM, using a direct foreign mapping. Following this, the initial page tables for the new VM are calculated and written into the new VM, using multiple direct foreign mappings. Finally, the new VM is launched, by setting the virtual CPU registers to a start-of-day configuration, and unpausing the VM.</p><p>The domain builder is implemented by the xc linux build function and its callees in libxc, a C library that provides low-level control over VMs. It is implemented in an object-oriented fashion, passing a struct xc dom image object between steps to communicate intermediate results. Direct foreign mappings are implemented by the xc map foreign range function, and setting the virtual CPU registers is performed by the xc set vcpucontext function. The libxc library is linked into the xend management daemon, which is implemented in Python. xend implements the Xen API, which is an XML-RPC-based API that several tools use to manage a Xen-based system <ref type="bibr" target="#b34">[35]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The TCB of a guest VM</head><p>We analyse the trusted computing base (TCB) of Xen for two reasons. Firstly, it is received wisdom that a smaller TCB corresponds to more trustworthy code <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b29">30]</ref>; therefore demonstrating the large size of the TCB gives motivation to our work. Secondly, it is necessary to enumerate and measure the TCB in order to build trusted virtualisation systems, which we discuss in Section 5.</p><p>The term "Trusted Computing Base" is defined variously in the literature, so it is useful to agree on a definition at the outset of this discussion. Hohmuth et al refer to "the set of components on which a subsystem S depends as the TCB of S." <ref type="bibr" target="#b16">[17]</ref>. We refine this and define the TCB as "the set of components which a subsystem S trusts not to violate the security of S". We draw this distinction because, although S may depend on the piece of code which, for example, loads it from disk into memory, that piece of code may be unable to violate the confidentiality or integrity of S, and therefore should not be considered part of the TCB.</p><p>We now turn to analysing the TCB of a guest virtual machine. The TCB must include Xen itself, because the hypervisor runs in a more privileged processor ring than the guest, and so it may access all memory and processor state. The Dom0 kernel is included in the TCB, because Dom0 is privileged, and the kernel can make privileged hypercalls. The domain builder process must also be included in the TCB, because it writes to the address space of the guest VM and configures its processor state: if it should malfunction, the security of S could be compromised. The domain builder code is dynamically linked into the Python interpreter that runs xend, so xend and the interpreter must be included in the TCB. However, the domain builder accesses the guest address space using the privileged command driver, which is exposed to all processes that run with administrator privileges in Dom0. Therefore, all such processes must be included within the TCB.</p><p>This poses a challenge when building trusted virtualisation systems. A trusted computing system relies on a chain of integrity measurements that inductively guarantees system integrity <ref type="bibr" target="#b2">[3]</ref>. Therefore, it is necessary to communicate the integrity of the physical platform to each VM. However, if arbitrary software can be run in Dom0 at the discretion of the platform administrator, the integrity chain may be undermined at any point while a VM is running. For example, the integrity of the virtual platform may be used to decrypt a secret, after which the TCB may be altered by running some malicious software in Dom0. The secret now exists as plaintext in the memory of the guest virtual machine, and the malicious software may read it by performing a direct foreign mapping of the relevant page frames. We discuss this example in more detail in Subsection 5.1.</p><p>Therefore, we have shown that the TCB of a guest virtual machine running on Xen is both indefinitely large and dynamic. This raises questions about the robustness of such a system, and further precludes the use of Xen for trusted virtualisation, where the system administrator is not trusted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Selecting the TCB</head><p>The goal of our disaggregation is to reduce the TCB of a Xen-based system. Therefore, in order to make an appropriate partition of the code base, it is necessary to determine which sections of code must be trusted, and which may be untrusted. In this section, we provide definitions that motivate our discussion of the TCB of a system (Subsection 3.1). We then argue that the "lines of code" metric for determining trustworthiness is insufficient, and introduce two new criteria (Subsection 3.2). Finally, we illustrate the use of these definitions for our disaggregation of the domain builder in a Xenbased system (Subsection 3.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definitions</head><p>We want to be able to identify trusted and untrusted code. Therefore, we make the following definitions:</p><p>Privileged Operation An operation that can be used to subvert the confidentiality or integrity of a system or subsystem. (This differs from the definition of a privileged operation in Xen, which is broader, and includes all management tasks, such as creating and destroying VMs.)</p><p>Sanitising Operation An operation that checks that all potentiallyuntrusted inputs it receives are valid.</p><p>Invokable Operation An operation that may be invoked (from a particular position in the code base) without indirection via a sanitising operation. An operation is invokable from point p if it is implemented in the same address space as p and in the same or a less-privileged protection ring. An operation is also invokable from point p if there is a call path to that operation that does not include a sanitising operation.</p><p>Using these the definitions, it is clear that privileged operations must be implemented in a separate address space and/or protection ring from untrusted code. The TCB may alternatively be defined as the set of code positions for which any privileged operation is an invokable operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Criteria</head><p>It is commonly held that the trustworthiness of a TCB is a function of the number of lines of code that it comprises <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref>. This assumption is typically based on studies that relate software size to the number of bugs <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">24]</ref>. Furthermore, it is attractive because it yields a metric that can be used to compare solutions. Whilst we accept that a smaller code base can be easier to comprehend, we believe there are scenarios in which adding code can improve trustworthiness. Therefore, in this section, we introduce two new criteria for evaluating the trustworthiness of a TCB: the size of the interface and the size of the TCB state space.</p><p>As we have stated in the previous subsection, it is necessary to sanitise the untrusted inputs to trusted, privileged code. As the number of interface functions in the TCB increases, so does the amount of sanitising code. Similarly, a less constrained type (e.g. a pointer to a region of memory that is used as an input) may require more complicated sanitisation than a more constrained type (e.g. an integer ID value).</p><p>An error in the sanitising code is likely to allow a maliciouslyconstructed input to compromise the TCB. For example, Shankar et al observe a large number of security vulnerabilities that result from using an unsanitised string as the first argument to printf <ref type="bibr" target="#b28">[29]</ref>. Therefore, minimising the complexity of the sanitising code is more important than doing the same for other trusted code. Basili and Perricone revealed the unexpected result that, as the size of a module increases, its error rate decreases <ref type="bibr" target="#b4">[5]</ref>. They posit that this may be due to a uniform distribution of "interface errors" across all modules. This agrees with our intuition that the interface should be minimised, as interfacing code is the main source of critical errors. Furthermore, an increase in the size of the TCB should be tolerated, if it reduces the size or complexity of the interface.</p><p>Our second criterion is the size of the state space. We suggest that, where possible, TCB interface functions should be atomic operations, and, if they modify global state, this should not have an effect on the behaviour of subsequent invocations. In particular, we discourage a TCB design whereby it is necessary to pair operations together (such as lock and unlock operations), or where there is an assumed ordering to the operations. As such operations proliferate, the number of possible test cases increases factorially, and the likelihood of making an obscure error also increases. Therefore, if it is possible to create an atomic operation by including some previously-untrusted code in the TCB, we would prefer this to a smaller TCB.</p><p>We can illustrate our two criteria using the following simple example:</p><p>1. Invoke privileged operation P1 2. Perform untrusted calculation, U , based on the result of P1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Invoke privileged operation P2, based on the results of P1 and</head><p>U .</p><p>Should U be implemented inside or outside the TCB? Its size (number of lines of code) and ability to run arbitrary instructions should first be considered. Figure <ref type="figure" target="#fig_1">2</ref> illustrates the data paths between the three operations, and the location of sanitising code for each case. When U is outside the TCB (Figure <ref type="figure" target="#fig_1">2(a)</ref>), it is necessary to sanitise the input to P1, the external input to P2 and the output of P1 and U . The output of P1 is generated by the TCB, and so we know that it is valid; however, it has left the TCB and must be sanitised, because the untrusted code could have modified it. If U is moved inside the TCB (Figure <ref type="figure" target="#fig_1">2(b)</ref>), it is only necessary to sanitise the external inputs to P1, U and P2. The outputs of P1 and U need no longer be sanitised, because they never leave the TCB.</p><p>In terms of the state space, our decision depends on whether P1 and P2 have an effect on the state of the system. For example, are all calls to P1 and P2 paired? What happens if P2 is invoked before P1, or if P1 is invoked without invoking P2? What happens if another operation is invoked between the invocations of P1 and P2? An incorrect implementation of mutual exclusion in this context could lead to liability inversion or deadlock. If the P1; U ; P2 sequence were implemented as an atomic operation within the TCB, these problems would not arise.</p><p>Obvious tensions exist between the criteria that we have described here. For example, as one incorporates all possible atomic sequences of privileged operations into the TCB, the size of the TCB interface grows, and the number of lines of code in the TCB also grows. As the size of the TCB interface is reduced, the number of lines of code in the TCB may grow. Neither of our suggested criteria are intended as a panacea for choosing an appropriate TCB, but we believe that they should be considered as part of the whole picture when designing a secure system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Redrawing the TCB of a guest VM</head><p>In this subsection, we present our redrawn TCB for a disaggregated Xen-based system. We concentrate on the domain builder, as it is the fundamental operation that has led to a large TCB for Xenbased systems. In order to reduce the size of the TCB, it is necessary to ensure that privileged operations are not invokable from untrusted code. In a VMM-based system, this is possible by moving the privileged operations to another VM, and interposing a sanitising operation on all call paths between untrusted and trusted code. In this subsection, we concentrate on the functionality that is disaggregated; Section 4 concentrates on the practical implementation of disaggregation.</p><p>By placing a sanitising operation (see §3.1) between Dom0 user-space and the privileged operations in the domain builder, it is possible to remove Dom0 user-space from the TCB. Therefore, since only the hypervisor, Dom0 kernel and part of the domain builder remain in the TCB, it is possible to measure the TCB at boot and be confident that it will not change. This is crucial for trusted virtualisation, which we discuss further in Section 5. The remaining question is where to place the sanitising code.</p><p>Figure <ref type="figure" target="#fig_2">3</ref> shows the domain builder process, annotated with three possible TCB demarcations. We determined that TCB (a), which places the entire domain building process (as described in Subsection 2.2) inside the TCB, was the best solution. The interface between trusted and untrusted code is the xc linux build function, which is called by the Python-based tool stack to perform the lowlevel build process (as opposed to the high-level configuration of virtual devices, which remains in Dom0).</p><p>This approach has two main advantages. First, the size of the interface is reduced to a single function, which has no arguments that are used as arguments to privileged operations (excluding the VM ID, which is straightforwardly validated). Therefore, the necessary amount and complexity of sanitising code is minimised, and, since errors here are critical, this improves our confidence in the security of the partitioning. Furthermore, the interface to the TCB exports a single, atomic function, which encapsulates all of its state either on its stack, or on the heap in regions referenced only by stack pointers. Therefore the TCB is effectively stateless, and it is not possible to use the interface to manipulate the TCB into an unexpected state.</p><p>Note that we include the "Load kernel image from disk" step inside the TCB. At first, it appear that we must trust the system call, file system and block device code that fulfil such a request. However, it is possible to include this step inside the TCB by using a trusted wrapper, as described by Singaravelu et al <ref type="bibr" target="#b29">[30]</ref>, around the file-handling code. We use an approach called "I/O forwarding", which is described in Subsection 4.1.</p><p>We now consider the alternative approaches depicted in Figure <ref type="figure" target="#fig_2">3</ref>. The domain builder process incorporates five main steps, of which three use privileged operations. TCB (b) places only these three steps inside the TCB, which is therefore smaller (in lines of code) than TCB (a). The TCB is then responsible for copying the kernel image into the new VM, building the initial page tables, and launching the VM. However, the second step in the build process ("Allocate physical memory map") generates a potentially-large amount of data that must be validated before it is used inside the TCB. These data originate in the (trusted) hypervisor, and ideally would not require validation. The process of validation would be so similar to the original process of retrieval, that it is redundant to perform this step outside the TCB.</p><p>Minimising the number of lines of code yields TCB (c) in Figure <ref type="figure" target="#fig_2">3</ref>. Here, the TCB includes only the implementation of "map foreign pages" and "set virtual CPU registers", and the necessary sanitising code that is required to ensure that these functions are not abused. However, because of the flexibility of these functions, the sanitising code would have to be almost as complex as the untrusted code from which it has been partitioned 1 . As we have stated, the amount and complexity of sanitising code should be minimised, as any error here could result in a security vulnerability.</p><p>In conclusion, choosing our disaggregation gives a useful example of the criteria for a trustworthy TCB that we presented in the previous subsection. We chose the largest of the three TCBs because this minimises the size of the interface (and hence the amount of sanitising logic), and introduces only a single, atomic operation to the TCB interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implementation</head><p>In this section, we describe the implementation of the reduced TCB that we chose in the previous section. The principal component is the domain builder service (Subsection 4.1). In order to support the domain builder, we also implemented a lightweight remote procedure call mechanism (Subsection 4.2) and a user-space driver for accessing granted memory (Subsection 4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The domain builder</head><p>We ported the domain builder to a minimal paravirtualised operating system, called MiniOS. MiniOS was developed as an example of how to implement the various features of paravirtualisation in Xen, such as event channels, granted pages and hypercalls. It includes no physical device drivers or file systems. A rudimentary virtual network driver is included, but there is no TCP/IP stack in the standard version. The small code base and the absence of many common exploit vectors make MiniOS a suitable basis for building a trusted service on Xen. However, the lack of functionality poses some problems, which we will address in this section.</p><p>The main challenge when implementing the disaggregated domain builder was that the existing code relies on file system access, in order to load kernel images and, optionally, initial ramdisks for a new guest. However, it is difficult to load a file into our domain builder, because, as we have already remarked, MiniOS includes no physical device drivers, file systems or networking stack. We have rejected adding any of these to MiniOS, because they are non-essential, complex pieces of code, which constitute an unnecessary burden on the TCB. Instead, we forward the file system calls, such as fopen and fread, to Dom0. Dom0 runs an I/O forwarding service, called vfsback, which receives the requests and executes them locally, returning the results to the domain builder.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> illustrates how the various processes communicate in the disaggregated domain building process. To begin the process, xend, through the linked libxc, makes an IVMC request (described in §4.2) to the domain builder (known as DomB), specifying the filenames of the kernel and initial ramdisk, the domain ID and the amount of memory to be allocated. The domain builder loads the kernel and initial ramdisk by forwarding I/O calls to the vfsback daemon in Dom0. The domain builder allocates a physical memory map as before, then installs the kernel image, initial ramdisk and initial page tables in the new VM. Finally, the domain builder launches the new VM, and returns control to xend in Dom0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Inter-VM Communication</head><p>In order for the management software to control the domain builder, it is necessary for Dom0 and DomB to communicate. However, as we do not want to introduce a TCP/IP stack into MiniOS, it is not possible to use existing network-based mechanisms to perform this communication. Instead, we have borrowed the concept of interprocess communication (IPC) from the microkernel community, 1 It must effectively ensure that the sequence of invocations and parameters correspond to the correct domain-building procedure. and implemented synchronous procedure call semantics using only the facilities present in a VMM-based system. IPC is often highlighted as a method of communication between trusted and untrusted components in a microkernel-based system <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b29">30]</ref>. The use of a VMM as the basis of a secure system is frequently criticised, because VMMs lack, as a primitive, any notion of inter-process communication. Indeed, it is suggested <ref type="bibr" target="#b16">[17]</ref> that the only way to emulate IPC is using a remote procedure call (RPC) protocol <ref type="bibr" target="#b7">[8]</ref> over a virtual network. Whilst this approach is feasible between full operating systems, it is not suitable for small-TCB applications that might lack a networking stack. This gives rise to our inter-VM communication (IVMC) implementation.</p><p>What do we mean by inter-VM communication? Clearly, a combination of the mechanisms in Subsection 2.1 can be used by two VMs in order to communicate: in fact, this is how the virtual devices in Xen are implemented <ref type="bibr" target="#b13">[14]</ref>. We assume that the IPC advocated by Hohmuth et al is "message transfer between threads" <ref type="bibr" target="#b20">[21]</ref>, using which synchronous procedure calls can be developed.</p><p>We were inspired by the use of an Interface Definition Language (IDL) in the applications built on the L4/Fiasco microkernel <ref type="bibr" target="#b26">[27]</ref>. The Dresden IDL Compiler (DICE) obviates the need to write lowlevel communication code, and presents a C or C++ procedural interface for IPC <ref type="bibr" target="#b0">[1]</ref>. It contains front-ends for parsing DCE and CORBA IDL, and back-ends that generate code for the L4/Fiasco API and Linux Sockets. Although the interface to the domain builder is relatively small and simple, an IDL compiler enables rapid experimentation with different interfaces, and can be used in the disaggregation of other functionality. Furthermore, it raises the possibility of portable applications running on both Xen/MiniOS and L4/Fiasco.</p><p>We developed a new back-end for DICE that can be used on a Xen system. The generated code uses a generic communication object that encapsulates a shared buffer and user-provided notification function. The shared buffer is created by the client allocating a page and using its grant table to grant access to the server; the notification is handled using an inter-VM event channel.</p><p>An IVMC end-point is identified by the ID of the server VM, a grant reference for the shared buffer, and the ID of the inter-VM event channel. These numbers may potentially change between boots of the physical platform, and so some mechanism is required to bind the name "DomB" to the correct endpoint. In the simplest case, the identity of the DomB virtual machine is known to the VMM at boot. DomB can then make a hypercall to set the grant reference and event channel ID after it has booted. Dom0, seeking the endpoint details, can then make a hypercall to discover these details. Since the VMM is part of the TCB, the correctness of the details can be trusted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The user-space grant table device</head><p>In order to complete our disaggregation, and disable the privileged operations in Dom0, it is necessary to remove all uses of the direct foreign mapping operation from Dom0 user-space. The grant table concept (see §2.1) provides a mechanism for controlled sharingakin to capabilities -but this has hitherto only been available in the kernel. Therefore, we implemented a user-space grant table device (gntdev), which provides a means of mapping one or more granted pages directly into the user-space of a virtual machine.</p><p>We implemented gntdev as a Linux kernel driver, which is manipulated using the same mmap and ioctl system calls that are used with the privcmd driver. In addition, we provide library functions in libxc for performing common operations, such as mapping a single grant reference from another VM. These library functions are used to replace instances of the direct foreign mapping operation, and to map the shared buffer used for IVMC.</p><p>The principal challenge in developing gntdev was the transience of user processes, when compared with virtual machines. It was necessary to make a slight modification to the Linux virtual memory subsystem, adding a hook that is called when a page table is cleared, in order to unmap grant references correctly when a process crashes. Furthermore, it was necessary to address the case where pages are granted by a user-space process, mapped by another VM, and not unmapped before the process dies. In this case, we ensure that the granter operating system does not reuse such pages until they are unmapped, in order that no information about other processes is leaked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Trusted virtualisation</head><p>Our work in this paper lays a foundation for trusted virtualisation. By bounding the TCB of a Xen-based system, we have made it possible for the hypervisor and Dom0 to take their place in a chain of trust that extends from the hardware Trusted Platform Module (TPM) into each VM. In this section, we address the problems with the status quo in trusted virtualisation (Subsection 5.1) and present our design for a trusted VMM using disaggregation (Subsection 5.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Problems with the status quo</head><p>Xen already incorporates virtual TPM (VTPM) software that may be used for trusted virtualisation. It was developed with the stated requirement of a "Strong association of the Virtual TPM with the Underlying TCB" <ref type="bibr" target="#b6">[7]</ref>. The VTPM is implemented as a virtual driver, with a front end that matches the interface of a physical TPM, and a back end in Dom0 that performs TPM emulation and multiplexing of requests to the real physical TPM. For additional security, the authors show that the back end can be implemented on a secure coprocessor.</p><p>Two issues with the implementation of the virtual TPM undermine its effectiveness, however. The first is that there is no communication between the libxc domain builder and the VTPM software. Therefore, any attempt to measure the kernel and initial ramdisk, then store it in the VTPM, is vulnerable to a timeof-check-to-time-of-use (TOCTOU) attack <ref type="bibr" target="#b8">[9]</ref>.</p><p>The second issue is that the TCB may change at any time, due to the administrator running a new executable in Dom0. The issue is not mitigated by using a Dom0 operating system that is modified to measure all of its executables as they are run, such as that suggested by Sailer et al <ref type="bibr" target="#b27">[28]</ref>. Consider the following series of events: 1. The hypervisor and Dom0 are measured on boot, and the platform is brought into a trustworthy state. A new VM, DomU, is created.</p><p>2. DomU decrypts some data, based on the virtual platform configuration. The data now exists as plaintext in DomU's memory.</p><p>3. A new executable, memorysniffer, is run in Dom0, which modifies the physical platform configuration (and, hence, the virtual platform configuration of DomU) to a no-longer-trustworthy state.</p><p>4. memorysniffer maps each page of DomU's physical memory until it finds the unencrypted secret.</p><p>At no point in the above steps does any component malfunction, yet it is possible for Dom0 to compromise the confidentiality of DomU. A similar argument can be made for integrity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Trusted VMM using disaggregation</head><p>In this subsection, we present an improved design for virtualising the TPM, using the disaggregated domain builder.</p><p>Figure <ref type="figure" target="#fig_4">5</ref> illustrates our design for the trusted virtualisation system. DomB is expanded to include a VTPM Manager, a hardware TPM driver and virtual platform configuration storage. Anderson et al previously ported the VTPM Manager to MiniOS <ref type="bibr" target="#b1">[2]</ref>. The VTPM front end (/dev/tpm) is unchanged, but now connects to the VTPM Manager in DomB.</p><p>The build process is modified so that an integrity measurement of the kernel, initial ramdisk and any configuration options is taken after the relevant files have been loaded into DomB's memory. At this point, a new VTPM instance is created for the domain, and the measurements are stored in one or more virtual PCRs. By performing the measurement here, the VTPM is not vulnerable to a TOCTOU attack, as the kernel that is measured is guaranteed to be the same as the one that is loaded. As in the existing VTPM implementation, the first nine physical PCRs are mapped into all virtual TPMs. In order to associate the virtual platform with the physical platform, a driver for the hardware TPM is included in DomB, and Xen gives DomB exclusive control over the device.</p><p>The physical platform configuration is measured by a trusted bootloader, such as the OSLO bootloader developed by Bernhard Kauer <ref type="bibr" target="#b17">[18]</ref>. This loads and measures the hypervisor, Dom0 kernel and domain builder, and stores the measurements in the hardware TPM.</p><p>It is possible to refine this model in order to allow dynamic kernel module loading in Dom0. The Dom0 kernel must be modified to make an IVMC call to DomB before a new module is loaded. The IVMC call would contain a measurement of the loaded module, and DomB would update the physical platform configuration on Dom0's behalf. DomB would only perform the extension, and return a successful response, if no guest VMs were currently running on the physical machine. Otherwise, loading the module could potentially compromise the running VMs, so the extension would not be performed, and Dom0 would be instructed not to load the module. As the Dom0 kernel is part of the TCB, it could be trusted to respect the decision of DomB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluation</head><p>In this work, we aimed to improve the trustworthiness of a Xenbased system. In this section, we evaluate our solution both quantitatively and qualitatively, by enumerating the contents of the TCB before and after disaggregation (Subsection 6.1), performing a security analysis of a disaggregated system (Subsection 6.2), and discussing the limitations of our approach (Subsection 6.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Reducing the TCB</head><p>Figure <ref type="figure" target="#fig_5">6</ref> shows three illustrations of the TCB in a Xen-based system, representing the existing, disaggregated and ideal cases.</p><p>The existing case (Figure <ref type="figure" target="#fig_5">6</ref>(a)) shows the TCB of a system running the current version of Xen (version 3.1). The TCB of every guest VM includes the hypervisor, the Dom0 kernel, and all userspace code that the administrator runs in Dom0. This includes a Python interpreter that runs the xend control daemon, the libxc low-level control library, and a C library (libc).</p><p>The disaggregated case (Figure <ref type="figure" target="#fig_5">6</ref>(b)) shows the current state of our work. The TCB of every guest VM includes the hypervisor, the Dom0 kernel, and a MiniOS-based version of the libxc low-level control library. The Dom0 kernel is included in the TCB because it is responsible for interaction with physical input/output devices; however, it no longer exports privileged operations to user-space. The xend control daemon and the Python interpreter are no longer part of the TCB, because they cannot be used to undermine the confidentiality of a VM, and any attempt to undermine integrity would be detected (see §6.2 for details).</p><p>Table <ref type="table" target="#tab_0">1</ref> compares the TCB contents for the existing and disaggregated cases. The following software was analysed: Xen version 3.1 (for the hypervisor, Dom0 kernel (version 2.6.18-xen), Dom0 kernel drivers, libxc and xend), Python version 2.4.4 and glibc version 2.6. We used version 2.26 of the SLOCCount tool <ref type="bibr" target="#b33">[34]</ref> to perform the analysis. We analysed only platform-independent code and platform-specific code for the x86 32 architecture. We did not analyse testing code. The table does not include other user-space code in Dom0 that would be counted as part of the TCB in the existing version, but instead concentrates on a minimal Dom0 configuration.</p><p>In addition to the amount of code in the TCB, the size of the interface must be considered. the privcmd driver, which enables user-space processes run by the administrator to make privileged hypercalls. By removing this feature from the driver, it is no longer possible for user-space processes to perform a direct foreign mapping, or alter the virtual CPU state. This step removes Dom0 user-space from the TCB. Figure <ref type="figure" target="#fig_5">6</ref>(c) illustrates the ideal TCB. At present, this is not feasible. Several authors have commented that a malconfigured device that can perform Direct Memory Access (DMA) can access any part of physical memory <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b16">17]</ref>, and its driver must therefore be included in the TCB. The introduction of Input/Output Memory Management Units (IOMMUs), which in effect create virtual address spaces for DMA, should help to mitigate this problem <ref type="bibr" target="#b5">[6]</ref>. It will be necessary to add code that controls the IOMMU, either to the hypervisor, or in a small, trusted VM that runs beside DomB. Without an IOMMU, we must trust the physical device drivers, and since these run within a Linux kernel, we must trust the kernel itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Security analysis</head><p>In this subsection, we evaluate a disaggregated Xen-based system in terms of two security properties: confidentiality and integrity. We consider two unauthorised sources of attacks: the administrator of the physical platform (hereafter abbreviated to Dom0-admin), and other unprivileged VMs on the same physical host.</p><p>We take the definitions of confidentiality and (data) integrity from the NIST Handbook on Computer Security <ref type="bibr" target="#b22">[23]</ref>:</p><p>Confidentiality "A requirement that private or confidential information not be disclosed to unauthorized individuals."</p><p>Integrity "[A] requirement that information and programs are changed only in a specified and authorized manner."</p><p>In our analysis, we use a physical host as the benchmark for our security properties. We do not consider the availability of a VM, because, if it were a physical machine in a managed data center, the machine could be powered down arbitrarily, and it is not possible for software to prevent this. Therefore, the xend operations of creating and destroying VMs are not considered privileged operations. Similarly, we assume that all input/output channels and secondary storage are insecure, because on a physical machine these could be intercepted by, for example, wiretapping a physical cable or transplanting a hard drive into another machine. Finally, we assume that encryption is unbreakable and we do not consider timing attacks in this analysis.</p><p>We describe the results of our analysis for the virtual CPU (6.2.1), physical RAM (6.2.2), secondary storage (6.2.3), network (6.2.4) and kernel image (6.2.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Virtual CPU</head><p>Each VM has one or more virtual CPUs (VCPUs), which are stored in a hypervisor data structure when not in use by the physical CPU. The confidentiality of a VCPU may be attacked by a hypercall that gets the contents of that VCPU. The integrity of a VCPU may be attacked by a hypercall that sets the contents of that VCPU.</p><p>Neither Dom0-admin, nor an unprivileged VM has access to either hypercall, and so neither can undermine the confidentiality or integrity of a VCPU. Only DomB can use the "set" hypercall, as part of the build process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Physical RAM</head><p>In order to map a page of RAM from another VM, it is necessary to create a mapping to that page in the attacking VM's page table. However, all active page tables are protected by Xen, and any update that refers to a page that belongs to another VM must be made using a hypercall. The confidentiality of physical RAM may be attacked by mapping a page for read access. The integrity of physical RAM may be attacked by mapping a page for write access.</p><p>An unprivileged VM may only update its page table to include pages that it owns, or to which it has been granted explicit access. Therefore, it cannot undermine the confidentiality or integrity of physical RAM.</p><p>The Dom0 kernel may, in effect, access any page of physical memory, because it controls devices that may perform DMA from any address. However, the Dom0 kernel does not propagate this control to user-space; therefore Dom0-admin cannot use user-space software in Dom0 to undermine the confidentiality or integrity of physical RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3">Secondary storage</head><p>The contents of secondary storage may be held directly on a physical backing store, or in a file in Dom0. Because the virtual block device back-end is typically implemented there, Dom0 requires readand write-access to the secondary storage. The confidentiality of secondary storage may be attacked by inspecting the content of the physical backing store or file. The integrity of secondary storage may be attacked by overwriting the content of the physical backing store or file.</p><p>An unprivileged VM has no direct access to hardware, and cannot directly access a file in Dom0 that contains another VM's secondary storage. Therefore, it cannot undermine the confidentiality or integrity of secondary storage, unless aided by Dom0.</p><p>Clearly, Dom0-admin can read any unencrypted contents of secondary storage, and can make arbitrary changes. In order to protect confidentiality, it is necessary for the guest to encrypt its data using, for example, the dm-crypt API in Linux <ref type="bibr" target="#b31">[32]</ref> or the BitLocker feature in Microsoft Windows Vista <ref type="bibr" target="#b21">[22]</ref>. Keys can be protected using the sealing functionality of the virtual TPM. Encryption can also be used to preserve integrity, though this does not rule out a destructive attack on the data in secondary storage.</p><p>We note that the protection given to secondary storage is equivalent to that provided by a physical host, as a physical hard drive can be transplanted into an untrusted computer, in order to circumvent access control.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.4">Network</head><p>The virtual network driver is implemented as a virtual split device that has a front end in the guest VM and a back end in Dom0. In the most common Xen network topology, the back ends are connected to a software bridge, which is then connected to the physical network interface. The confidentiality of network traffic may be attacked by attaching a packet sniffer to the virtual network. The integrity of network traffic may be attacked by modifying the bridge software to change the contents of packets as they are forwarded, or injecting false packets into the network.</p><p>An unprivileged VM will only see packets that are addressed to it, and it cannot send packets with false headers that appear to be from another VM, because Dom0 will reject them. Therefore, an unprivileged VM cannot undermine the confidentiality or integrity of the network.</p><p>As is the case for secondary storage, all network traffic passes through Dom0. A packet sniffer, run in Dom0, could therefore be used to undermine the confidentiality of the network. An encryption scheme, such as TLS <ref type="bibr" target="#b10">[11]</ref> or IPSec <ref type="bibr" target="#b18">[19]</ref> may be used to protect confidentiality. In order to modify packet data, it would be necessary to modify the Dom0 kernel code that controls the software bridge: since this is part of the TCB, it would be reflected in integrity measurements. However, encryption provides an additional defence against attacks on the integrity of the network. The use of Virtual Private Networking <ref type="bibr" target="#b15">[16]</ref> software in the guest VM would be sufficient to protect the confidentiality and integrity of the network from Dom0-admin.</p><p>We note that the protection given to network connections is equivalent to that provided by a physical host, when it is connected to an untrusted network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.5">Kernel image</head><p>The kernel image (and optionally, the initial ramdisk) exist as unencrypted files in the Dom0 file system, which are transferred to the domain builder when a VM is created. We do not consider the confidentiality of a kernel image, because this is incompatible with an "open trusted computing" approach: it should be possible to inspect the contents of the kernel and be confident that it is not carrying out any malicious activities <ref type="bibr" target="#b19">[20]</ref>. The integrity of a kernel image may be attacked by modifying the relevant file or files.</p><p>An unprivileged VM cannot access the file containing the kernel image unless it is granted access by Dom0, and it cannot intercept the IVMC channel used to transfer the file to DomB, because this channel uses explicit granted access from DomB to Dom0. Dom0-admin may modify the contents of the kernel image. However, the trusted VMM architecture (see §5.2) stipulates that the integrity of the kernel image is measured before boot, and this measurement is stored in the virtual TPM. If Dom0-admin compromises the integrity of the kernel image, the guest will be able to detect this by performing attestation, or trying to decrypt a secret that has been sealed to the platform configuration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Limitations</head><p>As discussed in Subsection 6.1, one major limitation of our approach is that the Dom0 kernel must be included in the TCB, and it is by far the largest TCB component. It is included in the TCB because it controls physical hardware that may perform DMA, and, without an IOMMU, may therefore read or write to any location in physical memory. Why, in that case, did we not include the domain builder code in the Dom0 kernel, and retain the aggregation of privileges for Dom0? We chose disaggregation because, when IOM-MUs are commonly available, the disaggregated approach will facilitate a switch to the "ideal" TCB depicted in Figure <ref type="figure" target="#fig_5">6</ref>(c), whereas there would be no advantage if the domain builder were integrated in the Dom0 kernel.</p><p>Duflot et al demonstrated that it is possible to use the System Management Mode on x86 computers to undermine security policies <ref type="bibr" target="#b11">[12]</ref>. The exploit is possible from user-space, when running as the administrator, even when using a "secure" OS, such as OpenBSD. In order to mitigate the attack, user-space access to video RAM must be disabled. In this case, it is not possible to use an X Server, which relies on this access. This is not a concern in data centre use cases, but it has severe implications for desktop virtualisation. We are currently investigating the use of a lightweight GUI, such as Nitpicker, which is sufficiently small to be included in the TCB <ref type="bibr" target="#b12">[13]</ref>.</p><p>We have analysed the Xen tool stack and found several tools that make use of the xc map foreign range function from libxc. Most of these map single frames for communication with guest VMs: we have introduced "third-party grants" that enable the domain builder to insert entries in a new VM's grant table in order to share these pages. The user-space grant table device (see §4.3) may be used to perform the mappings. The save and restore functions use direct foreign mappings in order to copy the contents of a VM's memory to and from disk, respectively. These may be implemented in a disaggregated fashion, using the same basis as the domain builder. A final category of mappings are those used for debugging: we do not attempt to enable these, because they would undermine the confidentiality and integrity guarantees that our approach makes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>Disaggregation is similar to the work carried out by Singaravelu et al on the Nizza architecture <ref type="bibr" target="#b29">[30]</ref>. This work involved extracting the security-critical components ("AppCores") of several legacy applications, and running these within a kernelised TCB, which runs on top of the L4 microkernel. Communication between the trusted and untrusted components was implemented using L4 interprocess communication (IPC). However, the intention of this work was to protect the security sensitive parts of an application from the much larger, untrusted segment. The authors did not attempt to protect applications from a malicious administrator. Disaggregation is also an example of privilege separation, described by Provos et al <ref type="bibr" target="#b24">[25]</ref>. They describe an approach whereby an application containing privileged and unprivileged components is divided so that each part runs with the least necessary privilege, and analyse their approach on OpenSSH. In their security analysis, they concentrate on minimising the number of lines of code in the privileged components. By contrast, we introduce additional criteria for qualitatively evaluating the TCB in Subsection 3.2, and base our separation upon these, in addition to the number of lines of code.</p><p>Hohmuth et al criticise the security claims made of virtual machine monitors and suggest using a small kernel, inter-process communication and wrappers around untrusted code, in order to reduce TCB size <ref type="bibr" target="#b16">[17]</ref>. To this end, they demonstrate the ability to run legacy applications on an L 4 Linux server, which runs on top of the L4 microkernel. They propose a new point on the VMM-microkernel continuum, namely "VM-enabled microkernels", which they conflate with "VMMs with microkernel-like features". We believe that the two are actually different, and, in this paper, we present an example of the latter. In particular, Hohmuth et al hold that, in a paravirtualisation-based VMM, such as Xen, "IPC needs device emulation", which thereby hinders the adoption of a disaggregated approach. In Subsection 4.2, we demonstrate that this is not the case.</p><p>The Terra architecture for Trusted Computing presents the concept of "closed box" virtual machines that cannot be inspected or altered by another virtual machine running on the same platform <ref type="bibr" target="#b14">[15]</ref>. Such closed boxes could be provided by, for example, a online game manufacturer, who wants to ensure that players are unable to cheat whilst playing the game. Although the authors present an architecture that could enable closed box operation, they do not provide details for how these may be isolated from the host operating system (analogous to Dom0 on a Xen platform). Indeed, they acknowledge that their implementation, using VMWare GSX Server and a Debian Linux host OS, is not "suitably high assurance for a real TVMM [Trusted VMM]". We develop their work further by suggesting the mechanisms that can be used to develop a trustworthy VMM.</p><p>Fraser et al demonstrated the use of virtual machine isolation for providing safe and reliable access to hardware devices <ref type="bibr" target="#b13">[14]</ref>. In their system, each hardware device and the least I/O privileges required to access it are assigned to an individual Xen VM. Therefore, the robustness of the system is improved when faced with a misbehaving driver. "I/O Spaces" are used to disaggregate the I/O port and memory privileges that were previously assigned to a monolithic Dom0. However, this work differs from ours in that it concentrates on driver isolation, and does not attempt to shield guests against a malicious administrator.</p><p>Two separate projects have implemented socket-like communications between virtual machines in a Xen-based system. Zhang et al created "XenSocket", which provides a "high-throughput interdomain transport" between Linux-based VMs <ref type="bibr" target="#b35">[36]</ref>. Anderson et al have developed an inter-domain communication (IDC) library, which may be used to communicate between Linux-and MiniOSbased VMs. In addition, they have ported a minimal C library and development toolchain to MiniOS, which enables trusted applications to be built straightforwardly <ref type="bibr" target="#b1">[2]</ref>. These approaches differ from ours, because they implement communication in the Linux kernel, whereas we use the user-space grant table device to implement communication in user-space. Furthermore, both approaches assume a trusted Dom0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions</head><p>In conclusion, we have demonstrated that it is possible to improve the security of a virtual machine running on the Xen virtual machine monitor, using a process of disaggregation. Our approach yields a measurable TCB that can be used with established trusted computing techniques. In redrawing the TCB, we have asserted that the number of lines of code is not the sole determinant of trustworthiness in a TCB, and introduced two new criteria -interface size and state space size -for judging trustworthiness. We applied these criteria to the selection of a TCB for disaggregation.</p><p>In order to implement our solution, we have made three main contributions. The principal contribution is the disaggregated domain builder service, based on our TCB design. This domain builder is a small, trusted service, which is given the necessary privileges in order to build new virtual machines. It therefore obviates the need for a monolithic management domain (Dom0) to have full privileges. Our other contributions supported the development of the domain builder, but can also be used for other purposes. We developed an inter-VM communication mechanism and associated IDL compiler. This enables developers to create lightweight code that communicates between Xen guest VMs without using a networking stack, which is particularly useful when developing trusted services that run on a minimal operating system (such as MiniOS). The IDL dialect is compatible with that used for L4/Fiasco, and we hope that this will lead to an exchange of solutions between the VMM and microkernel development communities. Finally, we developed a user-space grant table driver, which replaces the use of direct foreign mappings in Dom0. The grant table permits controlled sharing, and the new driver may be used in future to develop secure user-space management software for Xen guest VMs.</p><p>Our design has been informed greatly by developments in microkernels, especially the privilege separation work that has been carried out using the L4 microkernel <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b29">30]</ref>. We borrow the concept of IPC between protection domains, and, indeed, we make use of the same IDL compiler front-end that is used to integrate applications on L4 <ref type="bibr" target="#b26">[27]</ref>. We believe that our approach, "VMMs with microkernel-like features", leads to a satisfactory combination of security and functionality.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>DomUFigure 1 .</head><label>1</label><figDesc>Figure 1. Outline of the steps involved in building a new VM (DomU). Privileged operations are shown as bold arrows; direct foreign mappings are shown as dotted lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Location of data paths (black arrows) and sanitising code (bold lines) depending on the position of U relative to the TCB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Three possible TCBs for the domain builder. N.B. This diagram only shows which parts of the domain builder (from libxc) are part of the TCB, and omits lower-level code for clarity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Communication relationship between the control software in Dom0 and the disaggregated domain builder (DomB). The IVMC mechanism is described in §4.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Design of a trusted virtualisation system, using the disaggregated domain builder (DomB).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Illustration of the TCB contents for the existing, disaggregated and ideal Xen-based systems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>The existing version includes Changes to the TCB between the existing and disaggregated approaches. Rows beginning with + indicate where code was added to the TCB; rows beginning withindicate where it has been removed.</figDesc><table><row><cell></cell><cell>Component</cell><cell cols="3">1000s of lines of code C ASM Python</cell></row><row><cell></cell><cell>Hypervisor</cell><cell>98</cell><cell>3</cell><cell>-</cell></row><row><cell></cell><cell>Dom0 kernel</cell><cell>1500</cell><cell>9.6</cell><cell>-</cell></row><row><cell></cell><cell cols="3">Dom0 drivers ≤ 2400 ≤ 2.6</cell><cell>-</cell></row><row><cell>+</cell><cell>DomB</cell><cell>9.2</cell><cell>0.5</cell><cell>-</cell></row><row><cell>-</cell><cell>libc</cell><cell>690</cell><cell>15</cell><cell>-</cell></row><row><cell>-</cell><cell>Python</cell><cell>220</cell><cell>-</cell><cell>140</cell></row><row><cell>-</cell><cell>libxc</cell><cell>9.9</cell><cell>-</cell><cell>-</cell></row><row><cell>-</cell><cell>xend</cell><cell>2.4</cell><cell>-</cell><cell>17</cell></row><row><cell>+</cell><cell>Added</cell><cell>9.2</cell><cell>0.5</cell><cell>-</cell></row><row><cell>-</cell><cell>Removed</cell><cell>920</cell><cell>15</cell><cell>160</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank our colleagues for their comments and suggestions. This work was partially supported by EPSRC Grant reference EP/D020158/1 (XenSE), and the Open Trusted Computing project of the European Commission Sixth Framework Programme.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">DICE User&apos;s Manual</title>
		<author>
			<persName><forename type="first">R</forename><surname>Aigner</surname></persName>
		</author>
		<ptr target="http://os.inf.tu-dresden.de/dice/manual.pdf" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Dresden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Towards Trustworthy Virtualisation Environments: Xen Library OS Security Service Infrastructure</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">I</forename><surname>Dalton</surname></persName>
		</author>
		<idno>HPL-2007-69</idno>
		<imprint>
			<date type="published" when="2007-04">April 2007</date>
			<publisher>Hewlett-Packard Development Company, L.P</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A secure and reliable bootstrap architecture</title>
		<author>
			<persName><forename type="first">W</forename><surname>Arbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Farber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1997 IEEE Symposium on Security and Privacy</title>
		<meeting>the 1997 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Xen and the art of virtualization</title>
		<author>
			<persName><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Dragovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Neugebauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth ACM symposium on operating systems principles</title>
		<meeting>the nineteenth ACM symposium on operating systems principles<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="164" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Software errors and complexity: an empirical investigation</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Perricone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="42" to="52" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Utilizing IOMMUs for Virtualization in Linux and Xen</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Krieger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xenidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V</forename><surname>Doorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mallick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nakajima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Wahlig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 Ottawa Linux Symposium</title>
		<meeting>the 2006 Ottawa Linux Symposium</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">vTPM: virtualizing the trusted platform module</title>
		<author>
			<persName><forename type="first">S</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cáceres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sailer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Doorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th USENIX Security Symposium</title>
		<meeting>the 15th USENIX Security Symposium<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="21" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Implementing remote procedure calls</title>
		<author>
			<persName><forename type="first">A</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="59" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Checking for race conditions in file accesses</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bishop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dilger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="131" to="152" />
			<date type="published" when="1996">Spring 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">When virtual is better than real</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Noble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Workshop on Hot Topics in Operating Systems</title>
		<meeting>the 8th Workshop on Hot Topics in Operating Systems<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">133</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The TLS Protocol Version 1.0. RFC 2246, IETF</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dierks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Allen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-01">Jan. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Using CPU System Management Mode to Circumvent Operating System Security Functions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Duflot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Etiemble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumelard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th CanSecWest conference</title>
		<meeting>the 7th CanSecWest conference</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A nitpicker&apos;s guide to a minimalcomplexity secure GUI</title>
		<author>
			<persName><forename type="first">N</forename><surname>Feske</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Helmuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC &apos;05: Proceedings of the 21st Annual Computer Security Applications Conference</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="85" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Safe hardware access with the Xen virtual machine monitor</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Neugebauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Williamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st Workshop on Operating System and Architectural Support for the on demand IT InfraStructure</title>
		<meeting>the 1st Workshop on Operating System and Architectural Support for the on demand IT InfraStructure</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Terra: a virtual machine-based platform for trusted computing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM Symposium on Operating Systems Principles</title>
		<meeting>the 19th ACM Symposium on Operating Systems Principles<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="193" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Framework for IP Based Virtual Private Networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gleeson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heinanen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Armitage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Malis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IETF</title>
		<imprint>
			<biblScope unit="volume">2764</biblScope>
			<date type="published" when="2000-02">Feb. 2000</date>
		</imprint>
	</monogr>
	<note>RFC</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Reducing TCB size by using untrusted components: small kernels versus virtual-machine monitors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hohmuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Härtig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM SIGOPS European workshop: beyond the PC</title>
		<meeting>the 11th ACM SIGOPS European workshop: beyond the PC<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">OSLO: Improving the Security of Trusted Computing</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th USENIX Security Symposium. USENIX Association</title>
		<meeting>the 16th USENIX Security Symposium. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Security Architecture for the Internet Protocol</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Seo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IETF</title>
		<imprint>
			<biblScope unit="volume">4301</biblScope>
			<date type="published" when="2005-12">Dec. 2005</date>
		</imprint>
	</monogr>
	<note>RFC</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An Open Trusted Computing Architecture: Secure virtual machines enabling user-defined policy enforcement</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kuhlmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Landfermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ramasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ramunno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vernizzi</surname></persName>
		</author>
		<ptr target="https://secure.opentc.net/otcHighLevelOverview/OTCArchitectureHighleveloverview.pdf" />
	</analytic>
	<monogr>
		<title level="m">OpenTC consortium</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On micro-kernel construction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liedtke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="237" to="250" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">BitLocker Drive Encryption</title>
		<ptr target="http://technet.microsoft.com/en-us/windowsvista/aa905065.aspx" />
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Microsoft Corporation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">An Introduction to Computer Security: the NIST Handbook</title>
		<idno>800-12</idno>
		<imprint>
			<date type="published" when="1995-10">October 1995</date>
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology ; National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The distribution of faults in a large industrial software system</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ostrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Weyuker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGSOFT Softw. Eng. Notes</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="55" to="64" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Preventing privilege escalation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Provos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Friedl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Honeyman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Security Symposium</title>
		<meeting>the 12th USENIX Security Symposium<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="16" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Xenoservers: Accountable execution of untrusted programs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Menage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Early</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Stratford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Workshop on Hot Topics in Operating Systems</title>
		<meeting>the 7th Workshop on Hot Topics in Operating Systems<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">136</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Component Interfaces in a Microkernel-based System</title>
		<author>
			<persName><forename type="first">L</forename><surname>Reuther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Uhlig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Aigner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Workshop on System Design Automation (SDA)</title>
		<meeting>the 3rd Workshop on System Design Automation (SDA)</meeting>
		<imprint>
			<date type="published" when="2000-03">March 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Design and Implementation of a TCG-based Integrity Measurement Architecture</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sailer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Doorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th USENIX Security Symposium</title>
		<meeting>the 13th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Detecting format string vulnerabilities with type qualifiers</title>
		<author>
			<persName><forename type="first">U</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Talwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Security Symposium</title>
		<meeting>the 10th USENIX Security Symposium<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Reducing TCB complexity for security-sensitive applications: Three case studies</title>
		<author>
			<persName><forename type="first">L</forename><surname>Singaravelu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Helmuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroSys</title>
		<meeting>EuroSys</meeting>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Can we make operating systems reliable and secure?</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tanenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="44" to="51" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">dm-crypt -a device-mapper crypto target</title>
		<author>
			<persName><forename type="first">)</forename><surname>Unattributed</surname></persName>
		</author>
		<ptr target="http://www.saout.de/misc/dm-crypt/" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><surname>Unattributed</surname></persName>
		</author>
		<ptr target="https://www.trustedcomputinggroup.org/specs/TPM/mainP1DPrev103.zip" />
		<title level="m">TPM Main Part 1 Design Principles</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Trusted Computing Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wheeler</surname></persName>
		</author>
		<author>
			<persName><surname>Sloccount</surname></persName>
		</author>
		<ptr target="http://www.dwheeler.com/sloccount/" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">XenApi -Xen Wiki</title>
		<author>
			<persName><surname>Xensource</surname></persName>
		</author>
		<ptr target="http://wiki.xensource.com/xenwiki/XenApi" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">XenSocket: A high-throughput interdomain transport for VMs</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcintosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rohatgi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Griffin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Middleware 2007</title>
		<meeting>Middleware 2007<address><addrLine>Secaucus, NJ, USA; New York, Inc</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
