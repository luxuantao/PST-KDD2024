<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PEMU: A PIN Highly Compatible Out-of-VM Dynamic Binary Instrumentation Framework</title>
				<funder ref="#_dWUzpp2">
					<orgName type="full">AFOSR</orgName>
				</funder>
				<funder ref="#_bWCUYtd">
					<orgName type="full">DARPA</orgName>
				</funder>
				<funder>
					<orgName type="full">DARPA. Finally</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Junyuan</forename><surname>Zeng</surname></persName>
							<email>jzeng@utdallas.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Texas at Dallas</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yangchun</forename><surname>Fu</surname></persName>
							<email>yangchun.fu@utdallas.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Texas at Dallas</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zhiqiang</forename><surname>Lin</surname></persName>
							<email>zhiqiang.lin@utdallas.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Texas at Dallas</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">PEMU: A PIN Highly Compatible Out-of-VM Dynamic Binary Instrumentation Framework</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/2731186.2731201</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.4 [Software]: Processors-Code generation</term>
					<term>Translator writing systems and compiler generators</term>
					<term>D.4.6 [Operating Systems]: Security and Protection General Terms Design, Security Dynamic binary instrumentation</term>
					<term>Introspection</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Over the past 20 years, we have witnessed a widespread adoption of dynamic binary instrumentation (DBI) for numerous program analyses and security applications including program debugging, profiling, reverse engineering, and malware analysis. To date, there are many DBI platforms, and the most popular one is PIN, which provides various instrumentation APIs for process instrumentation. However, PIN does not support the instrumentation of OS kernels. In addition, the execution of the instrumentation and analysis routine is always inside the virtual machine (VM). Consequently, it cannot support any out-of-VM introspection that requires strong isolation. Therefore, this paper presents PEMU, a new open source DBI framework that is compatible with PIN-APIs, but supports out-of-VM introspection for both user level processes and OS kernels. Unlike in-VM instrumentation in which there is no semantic gap, for out-of-VM introspection we have to bridge the semantic gap and provide abstractions (i.e., APIs) for programmers. One important feature of PEMU is its API compatibility with PIN. As such, many PIN plugins are able to execute atop PEMU without any source code modification. We have implemented PEMU, and our experimental results with the SPEC 2006 benchmarks show that PEMU introduces reasonable overhead.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Dynamic binary instrumentation (DBI) is an extremely powerful technique for program analysis. At a high level, it dynamically inserts extra analysis code into the running binary program to observe how it behaves. It works similarly to a debugger but the analysis routine is programmed. Therefore, it can be used to automatically inspect the program state at instruction level and build many program analyses, such as performance profiling (e.g., <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b45">46]</ref>), architecture simulation (e.g., <ref type="bibr" target="#b28">[29]</ref>), program debugging (e.g., <ref type="bibr" target="#b24">[25]</ref>), program shepherding (e.g., <ref type="bibr" target="#b22">[23]</ref>), program optimization (e.g., <ref type="bibr" target="#b1">[2]</ref>), dynamic data flow analysis (e.g., taint analysis <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b35">36]</ref>), reverse engineering (e.g., <ref type="bibr" target="#b23">[24]</ref>), and malware analysis (e.g., <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b48">49]</ref>).</p><p>Today, there are many DBI platforms such as PIN <ref type="bibr" target="#b25">[26]</ref>, VALGRIND <ref type="bibr" target="#b30">[31]</ref>, DYNAMORIO <ref type="bibr" target="#b1">[2]</ref>, QEMU <ref type="bibr" target="#b3">[4]</ref>, and BOCHS <ref type="bibr" target="#b0">[1]</ref>. Each platform is built atop its own virtual machine (VM), and has its own pros and cons. For example, process-level DBI such as PIN and VALGRIND provides rich APIs to analyze user level binary code execution, but the analysis code is executed inside the VM (i.e., in-VM) with the same privilege as the instrumented process. Moreover, it does not support any kernel-level code instrumentation. Some platforms only support a limited type of operating system (OS), e.g., VALGRIND only supports Linux binaries but provides no support for Microsoft Windows binaries. Some platforms are designed as a full system emulator (e.g., QEMU), but do not provide any general DBI APIs. As such, can we build a cross-OS, APIrich, out-of-VM dynamic binary instrumentation framework that supports both user level and kernel level code?</p><p>While there have been attempts to address this problem, they only partially achieved these goals. Specifically, PINOS <ref type="bibr" target="#b7">[8]</ref> attempted to create a kernel instrumentation tool atop the XEN <ref type="bibr" target="#b2">[3]</ref> hypervisor. However, it only supports inspecting the very low level instruction semantics (such as the executing instruction address), and does not support any high level instrumentation and introspection (e.g., get the running process ID inside the VM). Meanwhile, because of its implementation of stealing memory from the guest OS, it does not offer strong isolation and the analysis routine can be accessed by the instrumented process or kernel. Another attempt is TEMU <ref type="bibr" target="#b47">[48]</ref>, which extends QEMU with its own APIs to allow end-users to develop TEMU-plugins for whole system instrumentation. Though it has greatly reduced developers' efforts in understanding the internals of QEMU in order to develop any useful plugins, it has only limited APIs compared to those provided by PIN. A recent effort, DRK <ref type="bibr" target="#b33">[34]</ref>, is able to perform kernel instrumentation. However, it is still an in-VM solution and does not isolate the analysis code (the analysis routine is executed as Linux Kernel modules), resulting in security issues when the kernel has malware.</p><p>To address these weaknesses, this paper presents PEMU (inherited from both PIN and QEMU), a new PIN-API compatible DBI framework that provides a whole system instrumentation but from out-of-VM introspection perspective. There are a number of goals PEMU aims to achieve. Specifically, it aims for PIN API-compatibility because of the large amount of users and rich-APIs PIN has. For instance, it has over 450 comprehensive, well-documented, easy to use instrumentation APIs. With the PIN compatible APIs, PIN plugins can be easily ported to PEMU with no or minimal modifications. Meanwhile, it aims for out-of-VM instrumentation because of the isolation requirement from security applications such as introspection. In addition, it aims for supporting a large number of different guest OSes without modification, considering that there are so many OSes with many different versions today.</p><p>The key idea to realize PEMU is to add an additional software layer atop an existing VM, and make our APIs selfcontained. Such a design makes our system easily portable if the underlying VM has been upgraded. In addition to the engineering challenges (in support of the large number of PIN APIs), we also face a number of research challenges. One is how to bridge the semantic gap <ref type="bibr" target="#b8">[9]</ref> while providing the out-of-VM instrumentation abstractions (e.g., APIs) for both process and kernel introspection, and also what those abstractions should be. The second is how to design our instrumentation engine such that it works seamlessly with the translation engine provided by the underlying VM but does not introduce large overhead. The third one is how to support the existing PIN APIs by using our framework.</p><p>We have addressed these challenges and implemented PEMU atop QEMU, and our experimental results with SPEC 2006 benchmarks show that PEMU has reasonable performance overhead compared to original QEMU and it will be useful for quickly developing PIN-style plugins atop PEMU or directly recompiling the existing PIN-plugins, for both instruction inspection and higher level semantic introspection.</p><p>Contributions. In summary, this paper makes the following contributions. We devise an additional software layer atop an existing binary code translation based VM with a set of standard APIs for both user level and kernel level DBI. This additional layer hides the low level VM details and contains a number of instrumentation related abstractions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background and Overview</head><p>In this section, we first discuss the background related to our system in ?2.1, and then motivate our research in ?2.2. Next, we discuss how to develop a plugin using PEMU in ?2.3, and finally we give an overview of PEMU in ?2.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">In-VM vs. Out-of-VM Instrumentation</head><p>The key technique behind any DBI is the just-in-time compilation (JIT) <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b36">37]</ref>. Basically, all the executing instructions are translated by a JIT compiler, which provides an opportunity to interpose and instrument the binary code for analysis purposes. The entire DBI infrastructure can be considered as a VM, which could be a process level VM (e.g., PIN, VAL-GRIND), or a system level VM (e.g., QEMU). At a high level, a VM mediates program execution by dynamically translating blocks of native code and executing them from a code cache. Given an analysis routine (e.g., printing the executed instruction addresses), there are two different ways of instrumenting the analysis routine with the original program code, as illustrated in Fig. <ref type="figure">1</ref>.</p><p>? In-VM instrumentation. This is the easiest way. The analysis routine is directly translated together with the original code into the same code cache. The analysis routine and the original program code share the same address space, and they are executed inside the VM either at guest "ring 3" (application layer) or "ring 0" (OS kernel layer). Therefore, the analysis routine can feel free to call any guest OS abstractions, and access any code or data of the instrumented process or kernel. Most DBI systems (e.g., PIN and VALGRIND) are designed in this way.  ? Out-of-VM instrumentation. Unlike in-VM instrumentation, the analysis routine is executed outside of the original program code (mostly at the virtual machine monitor layer, e.g., at "ring 3" of a host OS), though the original code and the analysis routine can be translated into the same cache. Therefore, the analysis routine and the original code does not share the same address space any more. There is a world switch for analysis routine from host "ring 3" to access the state of the monitored process or kernel at "ring 3" or "ring 0" of guest OS. Only a handful of systems (e.g., PINOS and TEMU) support out-of-VM instrumentation. However, their introspection supports are guest OS specific. Also, the isolation provided by PINOS is not as strong as TEMU. More specifically, while the instrumented code and instrumentation engine do not share any code in PINOS, the analysis routine and the original program code actually share the same address apace, because the analysis routine steals <ref type="bibr" target="#b7">[8]</ref> the address space from the guest OS, which makes it possible to tamper with the analysis routine when used to analyze malware.</p><p>We can notice that in-VM instrumentation and out-of-VM instrumentation share the opposite pros and cons. In-VM instrumentation occurs inside the VM, and has rich abstractions. But it executes at the same privilege level as the monitored process. Out-of-VM instrumentation occurs outside of the VM, and has less abstractions. But the analysis routine is isolated with the original program code. To develop the analysis routine, we can still use host OS abstractions, but to inspect any guest OS state, there is a need for techniques to bridge the semantic gap.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Objectives</head><p>While there have been significant efforts in the past 20 years to build various DBI platforms, few works focus on out-of-VM instrumentation where the analysis routine and original program code are strongly isolated. In this paper, we would like to develop a new out-of-VM DBI with an emphasis on supporting security applications that satisfy the following constraints:</p><p>(1) Rich APIs. Similar to PIN tool, we would like to offer rich and well-defined APIs. Since PIN is one of the most popular DBI tools, we would like to make our API compatible with PIN. This will make an open source alternative to PIN, which will be useful when there is a need to customize the PIN engine.</p><p>(2) Cross-OS. Unlike VALGRIND, which only analyzes Linux binaries, we would also like to offer support to instrument both Windows and Linux binaries using the same platform. More importantly, since there are a large number of different OSes, we would like to make our system OS agnostic for the introspection.</p><p>(3) Strong Isolation. Unlike existing in-VM approaches, we would like to make our analysis code execute at the hypervisor layer (can be considered "ring -1") instead of at the guest OS "ring 3" for process introspection or "ring 0" for kernel introspection.</p><p>(4) VM Introspection. Unlike PINOS, which does not support higher level guest object introspection <ref type="bibr" target="#b15">[16]</ref>, we would like to provide APIs to retrieve the high level semantic state from the guest OS for the monitored process or guest kernel. Considering that there are too many guest OSes, we would like to design a general way to query the guest OS state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">An Example</head><p>Before describing the details of how we achieve these goals, we would like to first illustrate how to develop a PEMU plugin by using the provided APIs. As presented in Fig. <ref type="figure" target="#fig_0">2</ref>, this is a very simple plugin with the functionality of counting the number of executed instructions. Similar to many other DBIs, to develop a PEMU plugin, users need to provide two sets of procedures: Instrumentation Routine, which specifies where the instrumentation should occur; and Analysis Routine, which defines analysis activities.</p><p>One important feature of PEMU is the API compatibility with the PIN tool. As illustrated in this example, the API we used is exactly identical to those used by a PIN tool. Therefore, many legacy PIN plugins can be recompiled and executed inside PEMU, but the distinctive feature is that both the analysis routine and instrumentation routine will be executed in the host OS, instead of inside the guest OS as would be done using PIN. For instance, the fprintf (line 13) and fopen (line 21) statements will be executed at the VMM layer and call host OS fprintf and fopen, but when we use PIN they will be executed inside the guest OS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Architecture Overview</head><p>An overview of PEMU is presented in Fig. <ref type="figure" target="#fig_1">3</ref>. There are two key components inside PEMU: instrumentation engine ( ?3) and introspection engine ( ?4). They both are located inside a virtual machine monitor.</p><p>To use PEMU, end users use the PIN compatible APIs provided by our instrumentation engine to develop the plugins, which will be compiled and linked at the VMM layer (namely, the host OS layer). If the analysis routine requires retrieving the state of the guest OS (e.g., pid of the instrumented process), it uses APIs provided by our introspection engine. In the following two sections, we describe how we design these two engines in greater detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Instrumentation Engine</head><p>Since PEMU aims for API compatibility with PIN, we have to first examine what those PIN APIs are. We take a recently released version of PIN (version 2.13), and we find there are in total 477 APIs. The distribution of these APIs are presented in Fig. <ref type="figure">4</ref>.</p><p>PIN defines two sets of instrumentation: (1) trace instrumentation that occurs immediately before a code sequence is executed, and (2) ahead-of-time instrumentation that caches the instrumentation before the execution. There are three different types of trace instrumentation depending on the granularity: INS_IsBranch, etc.). In total there are 142 INS related APIs.</p><p>? Basic Block Level (BBL). A basic block (BB) is a single entrance, single exit sequence of instructions. Instead of one analysis call for every instruction, it is often more efficient to insert a single analysis call for a BB, thereby reducing the number of analysis calls. PIN does not offer a BBL_AddInstrumentationFunction, and instead developers have to instrument the TRACES (described next) and iterate through them to get the BB. There are in total 14 APIs related to BBL.</p><p>? Trace Level. A TRACE in PIN is defined as a sequence of instructions that begin at the target of a taken branch and end with an unconditional branch (i.e., jmp/call/ret). This is the set of instructions that are disassembled by a linear sweep algorithm, when giving a starting address. Therefore, a TRACE usually consists of a number of BBs. PIN provides TRACE_AddInstrumentFunction call back to instrument a TRACE. There are in total also 14 APIs related to TRACE. Note that PIN introduced the concept of TRACE for a trace-linking optimization <ref type="bibr" target="#b25">[26]</ref>, which attempts to branch directly from a trace exit to the target trace without trapping to the VM. TRACE is at a higher granularity than BB and INS, and sometimes instrumenting analysis routine at TRACE granularity can improve performance. For instance, TRACE-based BBL instruction counting (as shown in Fig. <ref type="figure" target="#fig_0">2</ref>) is much faster than that of an INS based one.</p><p>tion, and the INS of a routine. Image instrumentation relies on symbol information to determine an RTN boundary. An analysis routine can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. IMG instrumentation utilizes the IMG_AddInstrumentFunction API. In total, there are 27 APIs related to IMG, and 16 APIs related to SEC.</p><p>? RTN instrumentation allows a PIN-tool to inspect and instrument an entire routine when the image, it is contained in, is first loaded. A PIN-tool can walk the instructions of an RTN. An analysis routine can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. RTN instrumentation utilizes the RTN_AddInstrumentFunction API. In total, there are 39 APIs related to RTN.</p><p>Next, we discuss how to design PEMU in support of these APIs. As we base PEMU atop QEMU, we have to examine the difference between QEMU and PIN. In fact, there are substantial differences, leading to a number of new challenges while designing PEMU. First, QEMU does not introduce any abstractions for TRACE, SEC, RTN, and IMG, and it only allows instrumentation at the INS or BB level. Therefore, we have to rebuild these missing abstractions. Second, QEMU's disassembling is based on BB, and the size of a BB has a limited value. For example, we notice that in QEMU-1.53 a BB needs to be split if the number of generated intermediate instructions is greater than 640. But there is no such constraint in PIN.</p><p>To address these challenges, we add our own disassembler rather than using the one in QEMU. Our own disassembler aims to reconstruct the abstractions for TRACE and we thus call this component TRACE Constructor ( ?3.1). To insert the analysis routine into the original program code, we leverage QEMU's dynamic binary translation (DBT) engine, on top of which to design our Code Injector ( ?3.2). In the rest of this section, we present the detailed design of these two components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">TRACE Constructor</head><p>The fundamental reason to introduce our own disassembler is to build the TRACE abstraction for PIN-APIs, from which to further build many other APIs such as those related to RTN, BB, and INS. Meanwhile, to uniformly support both trace and ahead of time instrumentation, we use a cache (we call hooking point hash table) to store all the call-back points where an analysis routine is instrumented. Then whenever these instruction points are executed, they will automatically invoke the analysis routine defined by users.</p><p>Since we aim to build TRACE abstractions, which contain BB and INS, we have to disassemble per TRACE. However, QEMU disassembles an instruction at a time (per BB). Therefore, when a starting address of a TRACE is to be disassembled by QEMU, we will disassemble all of the following TRACE_Instrument(T RACE, HP HT ); 25: } 26: } Algorithm 1: TRACE Construction instructions until we encounter an unconditional branch (e.g., jmp, ret, call), which is the end of a TRACE. As such, we will hold an entire TRACE before QEMU disassembles each instruction inside it.</p><p>However, there are also some practical challenges. One is that the instructions that belong to a TRACE may not exist in the guest OS memory (swapped or not loaded yet). The other is the instructions being disassembled are not currently being translated by QEMU-DBT, which is the underlying component for our Code Injector. Consequently, we cannot insert our analysis routines into the guest code while perform our disassembling.</p><p>To solve the first challenge, we use a proactive page fault injection approach that is triggered from the hypervisor layer and let the guest OS map the missing pages. For the second challenge, we use a global hooking point hash-table (HPHT) to cache the instruction point that will have analysis routine inserted. Later, when QEMU generates the translated code, our Code Injector will query this hash table to insert the analysis routine if there is any.</p><p>The Algorithm. To precisely describe how we build the TRACE abstraction and facilitate the instrumentation process, we use Algorithm 1 to show its details. For each P C that is a trace starting address, we will start disassembling the whole TRACE (line . This is the only point to invoke our own disassembler. To decide whether a given PC is a trace starting address, we query the TPC set that stores all the starting addresses of the TRACES. Note that some of the starting To disassemble a TRACE, we first create a TRACE (line 5) and a BB instance (line 6), respectively. Then we disassemble and iterate each instruction inside the basic block, and add them into the corresponding BB (line 8-9). If there is any instruction level instrumentation (e.g., when INS_InsertCall is called in the PEMU plugin), we add the hooking point of the disassembling instruction into the HPHT (line 10-12). Next, if there is a control flow transfer instruction (line 13-20), then the current BB ends and we insert it into the current TRACE (line 14). Also, we insert a BB hooking point if there is any (line <ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref>. Meanwhile, we allocate a new BB (line 18). To get a new TRACE starting address, we invoke a helper function, GetTargetPC (line <ref type="bibr" target="#b18">19</ref>), and we store the new starting address in our TPC. Next, we continue to get the next instruction (line 21), which can be the next instruction inside a BB or a starting address of a new BB. Until we encounter an unconditional control flow transfer instruction, we finish disassembling the current TRACE. If there is any TRACE instrumentation, we add the TRACE hooking points into HPHT (line <ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref>.</p><p>Regarding the connection between TRACE, BB, and INS, we illustrate their data structures in the right hand side of Fig. <ref type="figure">5</ref>. Each instance of these data structures is semantically compatible with the corresponding PIN counter-part. With these data structures, PIN's instrumentation and inspection APIs can be easily implemented. For example, when BBL_Next is called in a plugin, we will correspondingly traverse the BB instance list to return the next BB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Code Injector</head><p>To inject the analysis routine that is specified in our HPHT, we leverage the QEMU's DBT for this goal. In particular, to translate the guest binary code into host code, QEMU uses a tiny code generator (TCG), which provides APIs to insert additional code. Having collected which instruction needs the instrumentation, our Code Injector will directly use the TCG API (e.g., tcg_gen_helper) to insert the analysis routine.</p><p>We can also notice that reconstructing TRACE abstractions as well as using the HPHT significantly alleviates the complexity of the instrumentation. With these data structures, we can uniformly achieve code injection anywhere regardless of the granularity. For instance, we can inject an analysis routine at an entry address of a BB, starting address of a TRACE, entry or exit address of an RTN, or just a particular instruction address. That is why we do not attempt to construct abstractions for RTN, SEC, and IMG. For them, we just perform ahead-of-time disassembling and extract the instruction address of interest. For instance, to hook the malloc routine, we just need to know the entry address of this function (which can be acquired by signature scanning in the guest memory), and then at runtime, we inject the analysis routine if there is a need for the function argument interpretation of malloc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Putting it all together</head><p>To put it all together, we illustrate the overall execution steps of our instrumentation engine in Fig. <ref type="figure">5</ref>. For each guest instruction, our TRACE Constructor will take control (Step ). It first checks whether the current instruction is a starting address of a TRACE by querying the metadata (Step ) that stores all the observed tracing starting addresses. Note that to disassemble a new TRACE, its starting address must have been observed by QEMU, and therefore it has already been included in our TPC set (we use a red-black tree to store this set). If this is not a trace starting address, then we directly continue the execution of Code Injector (Step ) to generate the final host code (Step ). During the code generation, our Injector may query the metadata, especially the HPHT data structure, to decide whether the current instruction needs an instrumentation (Step ).</p><p>If the instruction is a TRACE starting address, then our disassembler will be invoked to disassemble the entire TRACE. During the disassembling, it will insert the corresponding instrumentation routine into the entry of the HPHT (Step ), if such a routine is specified by instrumentation API in the user defined plugins (Step ). When the disassembling finishes, the execution continues to Code Injector (Step ) to generate the final host code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Introspection Engine</head><p>Since the plugin of PEMU is executed below the guest OS, we have to design an introspection engine that supports the identification of the monitoring process/threads, as well as bridges the semantic gap when the plugins need to inspect the state of the monitored process or OS kernels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Identification of Monitored Process/Threads</head><p>The instrumentation APIs and the execution of the analysis routine need to be executed when the monitored process is executing. In PIN, all of them are executed in the same address space as the monitored process. However, in PEMU, all of them are executed below the guest OS. Therefore, we have to precisely identify the target process or threads.</p><p>Given a running OS, there are a number of ways to differentiate and retrieve the process or thread execution context from a hypervisor layer. One intuitive approach is to traverse kernel data structure to locate the process name, but such an approach is OS-gnostic. Other approaches include using the value of page global directory (PGD) to differentiate each process (as shown in <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>), or using PGD and the masked value of the kernel stack pointer (as shown in <ref type="bibr" target="#b14">[15]</ref>).</p><p>In PEMU, we adopted the PGD and kernel stack pointer approach. However, we still need to extend it to capture the beginning of the process/thread execution because our instrumentation happens right before process execution. To this end, we propose to capture the data life time of PGD to identify the new process. This is based on the observation that the guest OS must allocate a new (unused) PGD when creating a new process. In x86, PGD is stored in control register CR3. Therefore, if we keep tracking the use of CR3, we can detect a new process.</p><p>More specifically, starting from the execution of the guest OS, we maintain a list of the used CR3 values. When a new value is used to update the CR3 (by monitoring mov instructions with the destination register cr3), we detect that a new process is created. However, we also need to capture when the process exits, because a dead process's CR3 value can be reused for new process. Therefore, we also monitor the execution of exit syscall, and the CR3 value used in this syscall will be removed from the CR3 list such that we can detect a new process when this value is used again.</p><p>Note that all threads share the same address space. Therefore they will have the same CR3. To differentiate threads, we use the masked value of kernel stack pointer, because each thread will have a corresponding kernel stack that keeps the return addresses and local variables of the functions executed in a syscall trapped from the thread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Addressing the Semantic Gap Challenge</head><p>Once we have detected the newly created process/thread, our instrumentation will be performed on the monitored process/thread if the instrumentation is for it. Nearly all of our instrumentation APIs are self-contained, and many of them use the abstractions provided by the host OS. Therefore, for most of the instrumentation and analysis routines, there is no semantic gap. For instance, the analysis routine can call fprintf in the host OS to print the analysis result.</p><p>Unfortunately, for analysis routines that inspect the running process or kernel states, we have to reconstruct their abstractions (namely bridging the semantic gap). For instance, we cannot call the getpid syscall at the VMM layer, because the return value of this syscall will be the pid of the VMM. Instead, we need to retrieve the pid of the monitored process executed inside the VMM.</p><p>In the past decade, many approaches have been proposed to address the semantic gap challenge. These approaches include leveraging the kernel debugging information, as shown in the pioneer work Livewire <ref type="bibr" target="#b15">[16]</ref>; analyzing and customizing kernel source code (e.g., <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b34">35]</ref>); manually creating the routines to traverse kernel objects based on kernel data structure knowledge (e.g., <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">33]</ref>); or using a dual-VM based binary code reuse approaches <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b46">47]</ref>. Some of these approaches (e.g., <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20]</ref>) have a strong semantic gap <ref type="bibr" target="#b18">[19]</ref>, which does not trust any guest OS code; Some of them (e.g., <ref type="bibr" target="#b46">[47]</ref>) have a weak semantic gap, which trusts guest kernel code, but not application code.</p><p>To make PEMU more practical, we adopt the approach proposed in HyperShell <ref type="bibr" target="#b46">[47]</ref>. Though it is a weak semantic gap approach, it is guest OS agnostic. More specifically, by taking this approach, we will forward the syscall execution into the guest OS if the syscall needs to inspect or retrieve the guest OS state. Regarding which syscall needs such forwarding, we let the PEMU plugin developers decide but we provide the corresponding APIs for them. For instance, if a plugin needs to retrieve the instrumented process ID, the plugin developers will invoke PEMU_getpid. If a plugin needs to open a file in the guest OS, it will use PEMU_open, and this file will be closed by PEMU_close. In other words, we provide a set of wrapper functions with PEMU prefix for state inspection and file system related glibc-APIs. These APIs work as usual except that we have to detour the control flow of the entry point and exit point of these syscalls, such that the corresponding syscall execution can be forwarded to the guest OS. In total, there are 28 state inspection syscalls (including getpid,gettimeofday etc.), and 15 file system related syscalls (including open,fstat,lseek,etc.), which are forwarded to the guest OS if the plugin uses the PEMU prefix syscalls.</p><p>Though PEMU offers a weak semantic gap, we would like to note that for all other syscalls involved in the analysis routine, we offer a strong semantic gap. This is because we will not execute any guest code, will not traverse any guest kernel data structures, and the execution of the syscall will be directly executed on the host OS. If there is a strong security need, only the results for syscalls prefixed with PEMU cannot be trusted. In other words, a plugin developer is aware of this and can hence quantify the trustworthiness of her analysis routine.</p><p>Execution of a Forwarded Guest Syscall. To illustrate how a forwarded syscall really works, we present its detailed execution steps in Fig. <ref type="figure" target="#fig_2">6</ref>. In general, there are three parts of code involved in an introspection process: (1) original program code, (2) the analysis routine, and (3) the modified PEMU_glibc.</p><p>Suppose the control flow is transferred to an analysis routine (Step ), which needs to open a file inside the guest VMby calling PEMU_open. Then, PEMU_open goes to the real open in PEMU_glibc (Step ). Next, it invokes the syscall function (Step ) where real sys_open is triggered. PEMU intercepts syscall so that it will not trap to host OS kernel. To forward the syscall execution to guest OS, it first needs to save the register context and set up the arguments (Step ). If the argument is a pointer, we cannot directly pass that pointer to the guest VM because the guest OS can only access memory in its address space. To allow legal memory access inside the guest OS, we inject a sys_mmap to allocate a piece of memory and copy the argument content to the allocated memory (here it is the file name in this case). Next, it waits until the instrumented process executes in user space, and then it forces the execution of the syscall entry (Step ). The control flow goes back to the original program and a forwarded syscall gets executed. Finally, right after the execution of the syscall exit, PEMU copies the result and restores the register context (Step ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Evaluation</head><p>We have implemented a proof-of-concept prototype of PEMU atop qemu-1.5.3. We use XED library to build our own disassembler. Meanwhile, we have implemented over one hundred PIN compatible instrumentation APIs for INS, RTN, BB, and TRACE, as well as 43 guest OS state inspection and file system related APIs. To implement the rest of the APIs is an engineering challenge, and we leave it for future work.</p><p>In this section, we present our evaluation result. We first test the compatibility of PEMU with PIN in ?5.1. Then in ?5.2 we evaluate the performance of PEMU using an instruction count plugin (shown in Fig. <ref type="figure" target="#fig_0">2</ref>) with the SPEC CPU2006 benchmark. Next, we evaluate the memory cost of PEMU in ?5.3. Finally, we perform case studies to demonstrate the unique benefits of PEMU in ?5.4. Our host environment runs Ubuntu 12.04 with 32-bit Linux kernel 3.0.0-31-generic-pae, on Intel Core i7 CPU with 8G memory. Our guest OS is a 32-bit Ubuntu 11.04 (Linux kernel 2.6.38-8-generic) with 512M memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Compatibility Testing With PIN Plugins</head><p>To test how compatible PEMU is with PIN, we download the most recent released PIN tool, and use the plugins in SimpleExamples directory for this test. In total, there are 23 plugins. We recompile these plugins with PEMU's header files and library files. As shown in Table <ref type="table" target="#tab_3">1</ref>, a pleasant surprise is that 21 of them can be executed without any problem, considering that so far we only implemented over one hundred PIN APIs. More specifically, we notice that most of these test plugins are mainly used to test the tracing of instructions (including opcode and operand), control flow transfers (branching, call, ret, etc.), memory access, and library calls. Since these are the basic functionalities for a DBI tool, the current implementation of PEMU fortunately supports all of them.</p><p>As shown in Table <ref type="table" target="#tab_3">1</ref>, we have two failures dcache.so and opcodemix.so. The main reason is that our current implementation does not support APIs for CODECACHE and CONTROLLER. Note that CODECACHE allows developers to inspect the PIN code cache and/or alter the code cache replacement policy, and CONTROLLER is used to detect the beginning or end of an interval of the execution of a program. We leave the support of these APIs for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance Evaluation</head><p>Next, we test the performance of PEMU. We perform two sets of experiments: one is to measure how slow PEMU is when compared to a vanilla-QEMU, and the other is how slow when compared to PIN. We directly use the instruction counting plugin described in Fig 2 . This plugin increases the number of instructions in a BB for an accumulated counter before the execution of each BB. We test this plugin with the SPEC 2006 benchmark programs. Each of the benchmark programs is executed 100 times, and we use the corresponding average number in our report.</p><p>Performance Comparison with vanilla-QEMU. In this experiment, we measure the overhead introduced by PEMU instrumentation. We compare the execution when running the benchmarks with PEMU, directly with QEMU without any instrumentation.</p><p>We report the detailed experimental result in Table <ref type="table" target="#tab_6">2</ref>. Specifically, we show the total number of instructions executed in the 2 nd column and also the execution time of QEMU and PEMU is reported in the 3 rd and 4 th column (namely, T Qemu and T _P emu). We notice that on average there are 17649.1 million instructions traced for these benchmarks, and the average slowdown over QEMU is about 4.33X, which we believe it is reasonable for practical use. This overhead includes our TRACE Constructor, Code Injector, as well as runtime overhead of the analysis routine.</p><p>Performance Comparison with PIN. In the second experiment, we compare PEMU against PIN using the same plugin with the same benchmark. The execution time of running in PIN is presented in the 6 th column, and the comparison between PEMU and PIN is presented in the last column.</p><p>We notice that the average slowdown between PEMU and PIN is over 83.61X. The main reason is that PIN is running natively while PEMU (based on QEMU) needs extra translation. The largest slowdown comes from 444.namd which is above 310X. However, we note that when running this program in vanilla-QEMU, it will have close to 100X slowdown. We carefully examine the reason and find the root cause due to the use of large amount of floating point instructions which needs time-consuming emulation inside QEMU.</p><p>It is also interesting to note that for 450.soplex, running in QEMU is faster than that of PIN. The main reason is this program contains more control flow instructions that will go to the middle of a TRACE, thereby breaking the TRACE. In this case, QEMU (based on BBL disassembling) will just redisassemble the basic block that has not been disassembled, but PIN (based on TRACE disassembling) will redisassemble the whole trace after a new trace is found. Meanwhile, the running time of this program is relatively short. Thus, the time is dominated by the disassembling time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Memory Cost Evaluation</head><p>Since PEMU uses an ahead-of-time instrumentation that will store the hooking point to facilitate the instrumentation, we would like to measure how much memory space this hooking point table consumes. Again, we evaluate this memory cost with our instruction counting plugin against the SPEC2006 benchmark. The result is presented in Fig. <ref type="figure" target="#fig_3">7</ref>. We notice that the average memory cost is about 9M.</p><p>More specifically, as shown in Fig. <ref type="figure" target="#fig_3">7</ref>, the maximum memory cost comes from 465.tonto (about 22M) because this program contains the largest number of BB, resulting in the largest hash table to store the hooking points. More interestingly, 464.h264ref is one of the most time consuming programs but requires a relative small size of hash table. The reason is that this program contains lots of loops and thus certain instructions get executed repeatedly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Case Studies</head><p>We have demonstrated using PEMU to analyze Linux binaries. In fact, our system is cross-OS, which is one of our design goals. To test this, we apply PEMU to analyze Windows binaries as we have evaluated with Linux binaries. In particular, we use a number of anti-PIN binaries during this test.</p><p>First, we test how PEMU would analyze the software protected by tElock and safengine shielden, which are two widely used tools to build anti-analysis software. We apply these protectors to the hostname binaries in a Win-XP SP3 machine, with anti-debugging and antiinstrumentation enabled, and produce two anti-analysis  More specifically, we developed a simple strace (as shown in Fig. <ref type="figure" target="#fig_4">8</ref>) plugin to trace the syscall executed by the hostname binary. This plugin will print the syscall number at syscall entry point, and the return value at syscall exit point. We compiled it into a PIN plugin and PEMU plugin with the same source code. PIN failed on these two tests. Both packed programs detected the presence of PIN and exited at early stages. In contrast, hostname ran successfully on PEMU and displayed the host name.</p><p>In our other case study, we used eXait <ref type="bibr" target="#b12">[13]</ref>, a benchmarklike tool to test anti-instrumentation techniques. eXait has a plugin architecture, and each technique is implemented  as a separated DLL. There are 21 plugins in total. Again we run PIN with strace plugin to instrument eXait and the loaded DLLs. We found that 17 anti-instrumentation techniques detect the presence of PIN. But none of them detect the presence of PEMU.</p><p>Through these case studies, we show there is a need for outof-VM PIN alternatives. Also, even though future malware will be able to detect the presence of PEMU, we should be able to add countermeasures against them, given that the source code of PEMU is open.</p><p>In addition, PEMU can be used to build many out-of-VM introspection tools. In the past several years, we have been using its base internally to build introspection tools such as VMST <ref type="bibr" target="#b13">[14]</ref>, and EXTERIOR <ref type="bibr" target="#b14">[15]</ref>. We believe there will be more use cases of PEMU in this regard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Limitations and Future Work</head><p>The current design and implementation of PEMU has a number of limitations. The first one is the incomplete support of the PIN-APIs. Due to the grand engineering challenge, currently we are not able to support all of the PIN-APIs. Besides continuing to finish those unsupported APIs, we would also like to leverage the power from the open source community and make PEMU open source. Being an open source PIN alternative, we believe that there will be more users of PEMU, especially when there is a need to modify the instrumentation engine.</p><p>The second limitation is that we used a weak semantic gap <ref type="bibr" target="#b18">[19]</ref> when designing the introspection API. That is, while we did not trust any instrumented application code, we did trust the guest OS kernel because we will forward the execution of state inspection related syscalls (e.g., PEMU_getpid) to the guest OS. A stronger semantic gap <ref type="bibr" target="#b18">[19]</ref> will not trust the guest OS kernel at all. How to retrieve meaningful and trustworthy information from the hypervisor layer when guest OS is untrusted is still an open challenge. One of our future works will investigate how to address this problem.</p><p>The third limitation is that we have not attempted to optimize the generated instrumentation and analysis routine yet, though we have designed a number of optimized data structures (e.g., hooking point hash table) to speed up the instrumentation process. Currently, we directly leveraged the optimization from the tiny code generator (TCG) to optimize our instrumentation and analysis routine. We leave the investigation of other optimization techniques such as leveraging parallelism (e.g., <ref type="bibr" target="#b42">[43]</ref>) for us to pursue in another future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>Over the past 20 years, many dynamic binary instrumentation (DBI) platforms have been developed. In this section, we compare PEMU with these platforms. Note that static binary code instrumentation or rewriting systems, including the first influential link-time instrumentation system ATOM <ref type="bibr" target="#b39">[40]</ref>, are not within our scope.</p><p>At a high level, these dynamic binary instrumentation platforms can be classified into (1) machine simulator, emulator, and virtualizer, (2) process level instrumentation framework, and (3) system wide instrumentation framework. In the following, we discuss these related works and compare PEMU with each of them. A summary of the comparison is presented in Table <ref type="table">3</ref>. EMBRA <ref type="bibr" target="#b44">[45]</ref> 1996 VMWARE <ref type="bibr" target="#b9">[10]</ref> 1998 KERNINST <ref type="bibr" target="#b40">[41]</ref> 1999 DYNINSTAPI <ref type="bibr" target="#b6">[7]</ref> 2000 DYNAMO <ref type="bibr" target="#b1">[2]</ref> 2000 BOCHS <ref type="bibr" target="#b0">[1]</ref> 2001 SIMICS <ref type="bibr" target="#b26">[27]</ref> 2002 VALGRIND <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref> 2003 STRATA <ref type="bibr" target="#b36">[37]</ref> 2003 DYNAMORIO <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6]</ref> 2004 QEMU <ref type="bibr" target="#b3">[4]</ref> 2005 PIN <ref type="bibr" target="#b25">[26]</ref> 2005 NIRVANA <ref type="bibr" target="#b4">[5]</ref> 2006 HDTRANS <ref type="bibr" target="#b38">[39]</ref> 2006 VIRTUALBOX <ref type="bibr" target="#b43">[44]</ref> 2007 PINOS <ref type="bibr" target="#b7">[8]</ref> 2007 TEMU <ref type="bibr" target="#b47">[48]</ref> 2010 DYNINST <ref type="bibr" target="#b27">[28]</ref> 2010 DRK <ref type="bibr" target="#b33">[34]</ref> 2013 DECAF <ref type="bibr" target="#b16">[17]</ref> 2014 PEMU 2015</p><p>Table <ref type="table">3</ref>. Comparison with other dynamic binary instrumentation platforms.</p><p>Machine Simulator, Emulator, and Virtualizer. The very early development of dynamic binary code instrumentation originated from machine simulation or emulation. EM-BRA <ref type="bibr" target="#b44">[45]</ref> is such a simulation system. It performs whole system dynamic translation for MIPS architectures. BOCHS <ref type="bibr" target="#b0">[1]</ref> and SIMICS <ref type="bibr" target="#b26">[27]</ref> are also simulators that allow the instrumentation and inspection of all the executed x86 instructions. Targeting x86 architecture, the very early versions of VMWARE <ref type="bibr" target="#b9">[10]</ref> also use dynamic binary translation to build virtual machine monitors (VMM). Another widely used VMM or emulator is QEMU <ref type="bibr" target="#b3">[4]</ref>, which supports a large number of architectures. When used as an emulator, QEMU uses a tiny code generator to emulate a CPU through a binary translation. QEMU can also be used as a virtualizer recently, and it can cooperate with the Xen hypervisor or KVM kernel module to achieve a near native performance through running the guest code directly on host CPU. VIRTUALBOX <ref type="bibr" target="#b43">[44]</ref> is a faster VMM compared to QEMU, and it employs an in-situ patching to achieve better performance. For all these out-of-VM works, they certainly can instrument both user level and kernel level code, but they do not offer any APIs for users to build dynamic binary instrumentation applications. Also, when used to analyze guest kernels, they all tend to be kernel specific.</p><p>Process Level Instrumentation Framework. Recognizing the importance and wide applications of DBI, many process level instrumentation frameworks (e.g., DYNINSTAPI <ref type="bibr" target="#b6">[7]</ref>, STRATA <ref type="bibr" target="#b36">[37]</ref>, DYNAMORIO <ref type="bibr" target="#b1">[2]</ref>, VALGRIND <ref type="bibr" target="#b29">[30]</ref>, PIN <ref type="bibr" target="#b25">[26]</ref>, NIRVANA <ref type="bibr" target="#b4">[5]</ref>, HDTRANS <ref type="bibr" target="#b38">[39]</ref>, DYNINST <ref type="bibr" target="#b27">[28]</ref>) have been proposed. These frameworks offer APIs for developers to build plugins for various applications such as high performance simulation <ref type="bibr" target="#b36">[37]</ref>, program shepherding <ref type="bibr" target="#b22">[23]</ref>, and memory error detection <ref type="bibr" target="#b37">[38]</ref>.</p><p>Among them, VALGRIND <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref> is a comprehensive DBI framework that offers rich APIs for dynamic binary instrumentation. It supports various architectures (e.g., x86, ARM, MIPS) due to the use of an intermediate representation (IR) that is processor-neutral and SSA-based. Similar to VALGRIND, PIN <ref type="bibr" target="#b25">[26]</ref> also works at user space, but it only supports IA-32 and x86-64 architectures. Developers can create PIN-tools using the APIs provided by PIN, and execute them atop either Windows or Linux. It is featured with 'ease of use' with rich APIs to abstract away the underlying instruction-set idiosyncrasies. Making PIN-API compatible is one of our design goals such that PIN users can easily switch to our platform, especially when there is a need to customize the underlying DBI engine. Unlike other DBI platforms, DYNINST <ref type="bibr" target="#b27">[28]</ref> can instrument at any time in the execution of a program, from static instrumentation (i.e., binary rewriting) to dynamic instrumentation (i.e., instrumenting actively while executing the code). Also, it allows users to modify or remove instrumentation at any time, with such modifications taking immediate effect.</p><p>For process level instrumentation, they are efficient. They are built atop OS, and thus are OS-agnostic. It is also easier to develop the plugins. However, the analysis routine and the original program code share the same address space. Therefore, they are all in-VM approaches, and users have to be cautious when applying them for security sensitive applications.</p><p>System Wide Instrumentation Framework. In addition to process level instrumentation, there is also a need for OS kernel instrumentation. KERNINST <ref type="bibr" target="#b40">[41]</ref>, PINOS <ref type="bibr" target="#b7">[8]</ref>, TEMU <ref type="bibr" target="#b47">[48]</ref>, DRK <ref type="bibr" target="#b33">[34]</ref>, and DECAF <ref type="bibr" target="#b16">[17]</ref> are such systems.</p><p>Among them, KERNINST and DRK are built atop in kernel dynamic binary code translation. They basically control all kernel instruction execution, and enable comprehensive instrumentation of the OS kernel code. PINOS <ref type="bibr" target="#b7">[8]</ref> is a wholesystem instrumentation extension of PIN. It takes advantage of Intel VT Technology to interpose between the subject system and hardware. PINOS has been implemented based on the Xen virtual machine monitor. Compared to PEMU, the instrumentation and analysis code of KERNINST, PINOS and DRK actually share the same address space. Even though PINOS steals the memory from the guest OS, the monitored process is still able to guess and access the memory used by analysis routines. Therefore, they do not offer strong out-of-VM isolation.</p><p>TEMU <ref type="bibr" target="#b47">[48]</ref> is a whole-system instrumentation tool built atop QEMU. A unique feature in TEMU is that it offers APIs for dynamic taint analysis and in-depth program behavioral analysis. It is an out-of-VM based instrumentation, but it installed a helper kernel module inside the guest OS to report the states to the outside analysis routine. The most recent effort, DECAF, extends TEMU. It does not use any in-VM kernel module anymore, but the way to bridge the semantic gap still requires the knowledge of kernel data structures. Therefore, DECAF is a more OS-specific solution. For TEMU, it is less since it is an in-VM based approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>We have presented the design, implementation, and evaluation of PEMU, a new dynamic binary code instrumentation framework that allows end-users to develop out-of-VM plugins for various program analyses. One distinctive feature of PEMU is its PIN-API compatibility. Therefore, many of the PIN-tools can be recompiled and executed within our framework. Unlike other similar systems, it is guest-OS agnostic, and can execute many different guest OSes with different versions. Our experimental results with SPEC 2006 benchmarks show that PEMU introduces reasonable overhead.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. A PEMU plugin to count the number of executed instructions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Architecture Overview of PEMU.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Detailed Steps For An Execution Forwarded Guest Syscall.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Memory Cost Comparison with SPEC2006 Benchmarks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. A cross-OS PEMU plugin to trace the syscall.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>t o r , S i m u l a t o r , V i r t u a l i z e r K e r n e l L e v e l I n s t r u m e n t a t i o n U s e r L e v e l I n s t r u m e n t a t i o n w / A P I f o r i n s t r</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>1 :</head><label>1</label><figDesc>Global: T P C: a set storing the starting address of a T RACE; HP HT : the global hooking point hash table indexed by P C and storing function pointers of the user defined analysis routine. 2: Input: P C, the current trace starting instruction address; 3: Output: a T RACE, and updated T P C and HP HT .</figDesc><table><row><cell cols="2">4: Disassemble (P C) {</cell></row><row><cell>5:</cell><cell>T RACE ? GetTRACE();</cell></row><row><cell>6:</cell><cell>BB ? GetBB();</cell></row><row><cell>7:</cell><cell>do {</cell></row><row><cell>8:</cell><cell>IN ST ? DisasINST(P C);</cell></row><row><cell>9:</cell><cell>InsertINST(BB, IN ST );</cell></row><row><cell>10:</cell><cell>if (INST_Instrument = NULL) {</cell></row><row><cell>11:</cell><cell>INST_Instrument(IN ST , HP HT );</cell></row><row><cell>12:</cell><cell>}</cell></row><row><cell>13:</cell><cell>if (IN ST .type ? {jcc,jmp,call,ret}) {</cell></row><row><cell>14:</cell><cell>InsertBB(T RACE, BB);</cell></row><row><cell>15:</cell><cell>if (BB_Instrument = NULL) {</cell></row><row><cell>16:</cell><cell>BB_Instrument(BB, HP HT );</cell></row><row><cell>17:</cell><cell>}</cell></row><row><cell>18:</cell><cell>BB ? GetBB();</cell></row><row><cell>19:</cell><cell>T P C ? T P C? GetTargetPC(INST) ;</cell></row><row><cell>20:</cell><cell>}</cell></row><row><cell>21:</cell><cell>P C ? P C + IN ST .InstLen();</cell></row><row><cell>22:</cell><cell>} while(IN ST .type / ? {jmp, call, ret});</cell></row><row><cell>23:</cell><cell>if (TRACE_Instrument = NULL) {</cell></row><row><cell>24:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1 .</head><label>1</label><figDesc>Compatibility Testing with Existing PIN Plugins.</figDesc><table><row><cell>Plugin</cell><cell>Description</cell><cell>Supported</cell></row><row><cell>calltrace.so</cell><cell>Call trace tracing</cell><cell></cell></row><row><cell>extmix.so</cell><cell>Instruction extension mix profile</cell><cell></cell></row><row><cell>inscount2_vregs.so</cell><cell>Counting executing instructions</cell><cell></cell></row><row><cell>pinatrace.so</cell><cell>Memory address tracing</cell><cell></cell></row><row><cell>xed-cache.so</cell><cell>Decode cache profile</cell><cell></cell></row><row><cell>catmix.so</cell><cell>Instruction category mix profile</cell><cell></cell></row><row><cell>fence.so</cell><cell>Runtime text modification guard</cell><cell></cell></row><row><cell>jumpmix.so</cell><cell>Jmp/branch/call profiling</cell><cell></cell></row><row><cell>regmix.so</cell><cell>Register usage mix profile</cell><cell></cell></row><row><cell>xed-print.so</cell><cell>XED usage testing</cell><cell></cell></row><row><cell>coco.so</cell><cell>Code coverage analyzer</cell><cell></cell></row><row><cell>icount.so</cell><cell>Counting executing instructions</cell><cell></cell></row><row><cell>ldstmix.so</cell><cell>Register/memory operand profiler</cell><cell></cell></row><row><cell>topopcode.so</cell><cell>Opcode mix profiler</cell><cell></cell></row><row><cell>xed-use.so</cell><cell>XED interface usage testing</cell><cell></cell></row><row><cell>dcache.so</cell><cell>Data cache simulation</cell><cell></cell></row><row><cell>ilenmix.so</cell><cell>Instruction length mix profiler</cell><cell></cell></row><row><cell>malloctrace.so</cell><cell>Tracing calls to malloc</cell><cell></cell></row><row><cell>toprtn.so</cell><cell>Hostest routines profiling</cell><cell></cell></row><row><cell>edgcnt.so</cell><cell>Control flow edge profiler</cell><cell></cell></row><row><cell>inscount2_mt.so</cell><cell>Counting executing instructions</cell><cell></cell></row><row><cell>opcodemix.so</cell><cell>Opcode mix profiler</cell><cell></cell></row><row><cell>trace.so</cell><cell>Compressed instruction tracer</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 .</head><label>2</label><figDesc>Performance compared with vanilla-QEMU and PIN.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="3">Program</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">#Inst (M)</cell><cell></cell><cell cols="4">T Qemu (s)</cell><cell></cell><cell cols="4">T P emu (s)</cell><cell>T P emu / T Qemu</cell><cell>T P in (s) T Qemu / T P in</cell><cell>T P emu / T P in</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">401.bzip2</cell><cell></cell><cell></cell><cell></cell><cell cols="4">11500.27</cell><cell></cell><cell></cell><cell cols="3">24.55</cell><cell></cell><cell></cell><cell></cell><cell cols="2">81.15</cell><cell>3.31</cell><cell>11.17</cell><cell>2.20</cell><cell>7.26</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">403.gcc</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">4940.36</cell><cell></cell><cell></cell><cell cols="3">18.35</cell><cell></cell><cell></cell><cell cols="3">169.21</cell><cell>9.22</cell><cell>13.56</cell><cell>1.35</cell><cell>12.48</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">410.bwaves</cell><cell></cell><cell></cell><cell></cell><cell cols="4">29360.09</cell><cell></cell><cell></cell><cell cols="3">419.99</cell><cell></cell><cell></cell><cell cols="3">1336.57</cell><cell>3.18</cell><cell>7.44</cell><cell>56.45</cell><cell>179.65</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">416.gamess</cell><cell></cell><cell></cell><cell></cell><cell cols="4">2121.15</cell><cell></cell><cell></cell><cell cols="3">23.19</cell><cell></cell><cell></cell><cell></cell><cell cols="2">84.99</cell><cell>3.66</cell><cell>3.35</cell><cell>6.92</cell><cell>25.37</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">429.mcf</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">3562.67</cell><cell></cell><cell></cell><cell cols="3">23.91</cell><cell></cell><cell></cell><cell></cell><cell cols="2">70.58</cell><cell>2.95</cell><cell>3.55</cell><cell>6.74</cell><cell>19.88</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">433.milc</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">39509.49</cell><cell></cell><cell></cell><cell cols="3">779.07</cell><cell></cell><cell></cell><cell cols="3">2570.44</cell><cell>3.30</cell><cell>9.28</cell><cell>83.95</cell><cell>276.99</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="5">435.gromacs</cell><cell></cell><cell></cell><cell cols="4">4907.53</cell><cell></cell><cell></cell><cell cols="3">106.28</cell><cell></cell><cell></cell><cell cols="3">334.74</cell><cell>3.15</cell><cell>3.43</cell><cell>30.99</cell><cell>97.59</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="6">436.cactusADM</cell><cell></cell><cell cols="4">9730.11</cell><cell></cell><cell></cell><cell cols="3">304.89</cell><cell></cell><cell></cell><cell cols="3">1019.89</cell><cell>3.35</cell><cell>4.42</cell><cell>68.98</cell><cell>230.74</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">437.leslie3d</cell><cell></cell><cell></cell><cell></cell><cell cols="4">55857.54</cell><cell></cell><cell></cell><cell cols="3">900.01</cell><cell></cell><cell></cell><cell cols="3">3009.06</cell><cell>3.34</cell><cell>15.38</cell><cell>58.52</cell><cell>195.65</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">444.namd</cell><cell></cell><cell></cell><cell></cell><cell cols="4">74037.63</cell><cell></cell><cell></cell><cell cols="3">1523.78</cell><cell></cell><cell></cell><cell cols="3">5037.00</cell><cell>3.31</cell><cell>16.22</cell><cell>93.94</cell><cell>310.54</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">445.gobmk</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">314.88</cell><cell></cell><cell></cell><cell></cell><cell cols="2">2.43</cell><cell></cell><cell></cell><cell></cell><cell cols="2">4.17</cell><cell>1.72</cell><cell>1.71</cell><cell>1.42</cell><cell>2.44</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">450.soplex</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">63.67</cell><cell></cell><cell></cell><cell></cell><cell cols="2">1.49</cell><cell></cell><cell></cell><cell></cell><cell cols="2">2.22</cell><cell>1.49</cell><cell>1.80</cell><cell>0.83</cell><cell>1.23</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">453.povray</cell><cell></cell><cell></cell><cell></cell><cell cols="4">2987.41</cell><cell></cell><cell></cell><cell cols="3">36.16</cell><cell></cell><cell></cell><cell cols="3">193.17</cell><cell>5.34</cell><cell>3.52</cell><cell>10.27</cell><cell>54.88</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">454.calculix</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">187.33</cell><cell></cell><cell></cell><cell></cell><cell cols="2">2.53</cell><cell></cell><cell></cell><cell></cell><cell cols="2">6.61</cell><cell>2.61</cell><cell>2.46</cell><cell>1.03</cell><cell>2.69</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">456.hmmer</cell><cell></cell><cell></cell><cell></cell><cell cols="4">17862.2</cell><cell></cell><cell></cell><cell cols="3">46.43</cell><cell></cell><cell></cell><cell cols="3">260.56</cell><cell>5.61</cell><cell>6.95</cell><cell>6.68</cell><cell>37.49</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">458.sjeng</cell><cell></cell><cell></cell><cell></cell><cell cols="4">15514.49</cell><cell></cell><cell></cell><cell cols="3">48.40</cell><cell></cell><cell></cell><cell cols="3">432.79</cell><cell>8.94</cell><cell>14.38</cell><cell>3.37</cell><cell>30.10</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="6">462.libquantum</cell><cell></cell><cell></cell><cell cols="3">408.63</cell><cell></cell><cell></cell><cell></cell><cell cols="2">0.77</cell><cell></cell><cell></cell><cell></cell><cell cols="2">2.01</cell><cell>2.61</cell><cell>0.62</cell><cell>1.24</cell><cell>3.24</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">464.h264ref</cell><cell></cell><cell></cell><cell></cell><cell cols="4">98144.32</cell><cell></cell><cell></cell><cell cols="3">392.21</cell><cell></cell><cell></cell><cell cols="3">2751.31</cell><cell>7.01</cell><cell>34.01</cell><cell>11.53</cell><cell>80.90</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">465.tonto</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">3571.85</cell><cell></cell><cell></cell><cell cols="3">48.23</cell><cell></cell><cell></cell><cell cols="3">195.16</cell><cell>4.05</cell><cell>5.44</cell><cell>8.87</cell><cell>35.88</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">470.lbm</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">7744.81</cell><cell></cell><cell></cell><cell cols="3">161.22</cell><cell></cell><cell></cell><cell cols="3">692.51</cell><cell>4.30</cell><cell>2.92</cell><cell>55.21</cell><cell>237.16</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="5">471.omnetpp</cell><cell></cell><cell></cell><cell cols="4">2209.23</cell><cell></cell><cell></cell><cell cols="3">16.24</cell><cell></cell><cell></cell><cell cols="3">136.63</cell><cell>8.41</cell><cell>3.19</cell><cell>5.09</cell><cell>42.83</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">473.astar</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">26645.10</cell><cell></cell><cell></cell><cell cols="3">102.95</cell><cell></cell><cell></cell><cell cols="3">734.52</cell><cell>7.13</cell><cell>13.67</cell><cell>7.53</cell><cell>53.73</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">482.sphinx3</cell><cell></cell><cell></cell><cell></cell><cell cols="4">6198.21</cell><cell></cell><cell></cell><cell cols="3">77.95</cell><cell></cell><cell></cell><cell cols="3">322.26</cell><cell>4.13</cell><cell>4.94</cell><cell>15.78</cell><cell>65.23</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="5">999.specrand</cell><cell></cell><cell></cell><cell cols="4">6198.21</cell><cell></cell><cell></cell><cell></cell><cell cols="2">1.42</cell><cell></cell><cell></cell><cell></cell><cell cols="2">2.46</cell><cell>1.73</cell><cell>0.92</cell><cell>1.54</cell><cell>2.67</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Avg.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">17649.05</cell><cell></cell><cell></cell><cell cols="3">210.94</cell><cell></cell><cell></cell><cell cols="3">810.42</cell><cell>4.33</cell><cell>7.68</cell><cell>22.52</cell><cell>83.61</cell></row><row><cell>25</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>10 15 20 Size of HashTable (M)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0</cell><cell>401.bzip2</cell><cell>403.gcc</cell><cell>410.bwaves</cell><cell>416.gamess</cell><cell>429.mcf</cell><cell>433.milc</cell><cell>435.gromacs</cell><cell>436.cactusADM</cell><cell>437.leslie3d</cell><cell>444.namd</cell><cell>445.gobmk</cell><cell>450.soplex</cell><cell>453.povray</cell><cell>454.calculix</cell><cell>456hmmer</cell><cell>458.sjeng</cell><cell>462.libquantum</cell><cell>464.h264ref</cell><cell>465.tonto</cell><cell>470.lbm</cell><cell>471.omnetpp</cell><cell>473.astar</cell><cell>482.sphinx3</cell><cell>999.specrand</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Regarding the ahead-of-time instrumentation, PIN provides an image (IMG) instrumentation and routine (RTN) instrumentation. More specifically:? IMG instrumentation allows a PIN-tool to inspect and instrument an entire image when it is loaded. A PIN-tool can walk the sections (SEC) of an image, the RTN of a sec-</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgement and Availability</head><p>We thank the anonymous reviewers for their insightful comments. We are also grateful to <rs type="person">Erick Bauman</rs> for his invaluable feedback on an early draft of this paper. This research was supported in part by a <rs type="funder">AFOSR</rs> grant <rs type="grantNumber">FA9550-14-1-0119</rs> and a <rs type="funder">DARPA</rs> grant <rs type="grantNumber">12011593</rs>. Any opinions, findings, conclusions, or recommendations expressed are those of the authors and not necessarily of the AFOSR and <rs type="funder">DARPA. Finally</rs>, the source code of PEMU is available at https://github.com/utds3lab/pemu.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_dWUzpp2">
					<idno type="grant-number">FA9550-14-1-0119</idno>
				</org>
				<org type="funding" xml:id="_bWCUYtd">
					<idno type="grant-number">12011593</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The open source ia-32 emulation project</title>
		<ptr target="http://bochs.sourceforge.net/" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dynamo: A transparent dynamic optimization system</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Duesterwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjia</surname></persName>
		</author>
		<idno>PLDI &apos;00</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Xen and the art of virtualization</title>
		<author>
			<persName><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Dragovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Neugebauery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth ACM symposium on Operating systems principles</title>
		<meeting>the nineteenth ACM symposium on Operating systems principles</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Qemu, a fast and portable dynamic translator</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bellard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the annual conference on USENIX Annual Technical Conference</title>
		<meeting>the annual conference on USENIX Annual Technical Conference<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>ATEC &apos;05</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Framework for instruction-level tracing and analysis of program executions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bhansali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jong</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Drini ?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Miho ?ka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<idno>VEE &apos;06</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2Nd International Conference on Virtual Execution Environments</title>
		<meeting>the 2Nd International Conference on Virtual Execution Environments<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="154" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Transparent dynamic instrumentation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM SIGPLAN/SIGOPS Conference on Virtual Execution Environments</title>
		<meeting>the 8th ACM SIGPLAN/SIGOPS Conference on Virtual Execution Environments<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="133" to="144" />
		</imprint>
	</monogr>
	<note>VEE &apos;12, ACM</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An api for runtime code patching</title>
		<author>
			<persName><forename type="first">B</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Hollingsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. High Perform. Comput. Appl</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="317" to="329" />
			<date type="published" when="2000-11">Nov. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Pinos: A programmable framework for whole-system dynamic instrumentation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Bungale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd international conference on Virtual execution environments</title>
		<meeting>the 3rd international conference on Virtual execution environments</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="137" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">When virtual is better than real</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Noble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Workshop on Hot Topics in Operating Systems</title>
		<meeting>the Eighth Workshop on Hot Topics in Operating Systems</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="133" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Virtualization System Including a Virtual Machine Monitor for a Computer with a Segmented Architecture</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Devine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bugnion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">United States Patent</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">242</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Virtuoso: Narrowing the semantic gap in virtual machine introspection</title>
		<author>
			<persName><forename type="first">B</forename><surname>Dolan-Gavitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhivich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32 nd IEEE Symposium on Security and Privacy</title>
		<meeting>the 32 nd IEEE Symposium on Security and Privacy<address><addrLine>Oakland, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="297" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Dynamic spyware analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2007 USENIX Annual Technical Conference on Proceedings of the USENIX Annual Technical Conference</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
	<note>ATC&apos;07</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic binary instrumentation frameworks: I know you&apos;re there spying on me</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Francisco Falc? ?n</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">recon</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Space traveling across vm: Automatically bridging the semantic-gap in virtual machine introspection via online kernel data redirection</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2012 IEEE Symposium on Security and Privacy<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-05">May 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Exterior: Using a dual-vm based external shell for guest-os introspection, configuration, and recovery</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth Annual International Conference on Virtual Execution Environments</title>
		<meeting>the Ninth Annual International Conference on Virtual Execution Environments<address><addrLine>Houston, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-03">March 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A virtual machine introspection based architecture for intrusion detection</title>
		<author>
			<persName><forename type="first">T</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Network and Distributed Systems Security Sym. (NDSS&apos;03)</title>
		<meeting>Network and Distributed Systems Security Sym. (NDSS&apos;03)</meeting>
		<imprint>
			<date type="published" when="2003-02">February 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Make it work, make it right, make it fast: Building a platform-neutral whole-system dynamic binary analysis platform</title>
		<author>
			<persName><forename type="first">A</forename><surname>Henderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<idno>ISSTA 2014</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Interna-tional Symposium on Software Testing and Analysis</title>
		<meeting>the 2014 Interna-tional Symposium on Software Testing and Analysis<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="248" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Ensuring operating system kernel integrity with osck</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">S</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Dunn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems</title>
		<meeting>the sixteenth international conference on Architectural support for programming languages and operating systems<address><addrLine>Newport Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="279" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sok: Introspections on trust and the semantic gap</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Baig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
		<idno>SP &apos;14</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2014 IEEE Symposium on Security and Privacy<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="605" to="620" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Stealthy malware detection through vmm-based out-of-the-box semantic view reconstruction</title>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Conference on Computer and Communications Security (CCS&apos;07)</title>
		<meeting>the 14th ACM Conference on Computer and Communications Security (CCS&apos;07)<address><addrLine>Virginia, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="128" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Antfarm: tracking processes in a virtual machine environment</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. annual Conf. USENIX &apos;06 Annual Technical Conf</title>
		<title level="s">USENIX Association</title>
		<meeting>annual Conf. USENIX &apos;06 Annual Technical Conf<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Vmm-based hidden process detection and identification using lycosid</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<idno>VEE &apos;08</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. fourth ACM SIG-PLAN/SIGOPS international Conf. Virtual execution environments</title>
		<meeting>fourth ACM SIG-PLAN/SIGOPS international Conf. Virtual execution environments<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="91" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Secure execution via program shepherding</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kiriansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Security Symposium</title>
		<meeting>the 11th USENIX Security Symposium<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="191" to="206" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Automatic reverse engineering of data structures from binary execution</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Annual Network and Distributed System Security Symposium (NDSS&apos;10)</title>
		<meeting>the 17th Annual Network and Distributed System Security Symposium (NDSS&apos;10)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-02">February 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Avio: detecting atomicity violations via access interleaving invariants</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on Architectural support for programming languages and operating systems</title>
		<meeting>the 12th international conference on Architectural support for programming languages and operating systems<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ASPLOS XII, ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hazel-Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation</title>
		<meeting>the 2005 ACM SIGPLAN conference on Programming language design and implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
	<note>PLDI &apos;05, ACM</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Simics: A full system simulation platform</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Magnusson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Christensson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Eskilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forsgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>H?llberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>H?gberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Larsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moestedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="50" to="58" />
			<date type="published" when="2002-02">Feb. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Bernat</surname></persName>
		</author>
		<author>
			<persName><surname>Anywhere</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>any time binary instrumentation</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatic logging of operating system effects to guide application-level architecture simulation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<idno>SIGMETRICS &apos;06/Performance &apos;06</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the joint international conference on Measurement and modeling of computer systems</title>
		<meeting>the joint international conference on Measurement and modeling of computer systems<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="216" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A program supervision framework</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
		<author>
			<persName><surname>Valgrind</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third Workshop on Runtime Verification (RV&apos;03</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A framework for heavyweight dynamic binary instrumentation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
		<author>
			<persName><surname>Valgrind</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="89" to="100" />
		</imprint>
	</monogr>
	<note>PLDI &apos;07, ACM</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Dynamic taint analysis for automatic detection, analysis, and signature generation of exploits on commodity software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Network and Distributed Systems Security Symposium</title>
		<meeting>Network and Distributed Systems Security Symposium</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Secure and flexible monitoring of virtual machines</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Payne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carbone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Annual Computer Security Applications Conference</title>
		<meeting>the 23rd Annual Computer Security Applications Conference</meeting>
		<imprint>
			<publisher>ACSAC</publisher>
			<date type="published" when="2007-12">2007. December 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Comprehensive kernel instrumentation via dynamic binary translation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D B</forename><surname>Peter Feiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the seventeenth international conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the seventeenth international conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Automated detection of persistent kernel control-flow attacks</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Petroni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">L</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM conference on Computer and communications security</title>
		<meeting>the 14th ACM conference on Computer and communications security</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="103" to="115" />
		</imprint>
	</monogr>
	<note>CCS &apos;07</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask)</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<idno>SP &apos;10</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2010 IEEE Symposium on Security and Privacy<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="317" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Retargetable and reconfigurable software dynamic translation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Velusamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Childers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Soffa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization</title>
		<meeting>the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="36" to="47" />
		</imprint>
	</monogr>
	<note>CGO &apos;03</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Using valgrind to detect undefined value errors with bit-precision</title>
		<author>
			<persName><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<idno>ATEC &apos;05</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Conference on USENIX Annual Technical Conference</title>
		<meeting>the Annual Conference on USENIX Annual Technical Conference<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An open source, low-level dynamic instrumentation system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sridhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Northup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Bungale</surname></persName>
		</author>
		<author>
			<persName><surname>Hdtrans</surname></persName>
		</author>
		<idno>VEE &apos;06</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2Nd International Confer-ence on Virtual Execution Environments</title>
		<meeting>the 2Nd International Confer-ence on Virtual Execution Environments<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="175" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Atom: A system for building customized program analysis tools</title>
		<author>
			<persName><forename type="first">A</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Eustace</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="196" to="205" />
		</imprint>
	</monogr>
	<note>PLDI &apos;94, ACM</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Fine-grained dynamic instrumentation of commodity operating system kernels</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tamches</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Symposium on Operating Systems Design and Implementation</title>
		<meeting>the Third Symposium on Operating Systems Design and Implementation<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="117" to="130" />
		</imprint>
	</monogr>
	<note>OSDI &apos;99</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Superpin: Parallelizing dynamic instrumentation for real-time performance</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th Annual International Symposium on Code Generation and Optimization</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-03">March 2007</date>
			<biblScope unit="page" from="209" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Coremu: A scalable and portable parallel full-system emulator</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>the 16th ACM Symposium on Principles and Practice of Parallel Programming<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="213" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Virtualbox: Bits and bytes masquerading as machines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Watson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Linux J</title>
		<imprint>
			<biblScope unit="volume">166</biblScope>
			<date type="published" when="2008-02">2008. Feb. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Embra: Fast and flexible machine simulation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems</title>
		<meeting>the 1996 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="68" to="79" />
		</imprint>
	</monogr>
	<note>SIGMETRICS &apos;96, ACM</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A dynamic compilation framework for controlling microprocessor energy and performance</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Connors</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Microarchitecture, 2005. MICRO-38. Proceedings. 38th Annual IEEE/ACM International Symposium on</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Hypershell: A practical hypervisor layer guest os shell for automated in-vm management</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Z</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC&apos;14 Proceedings of the 2014 USENIX conference on USENIX Annual Technical Conference (USENIX Association</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="85" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Temu: Binary code analysis via whole-system layered annotative execution</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<idno>UCB/EECS-2010-3</idno>
		<imprint>
			<date type="published" when="2010-01">Jan 2010</date>
			<pubPlace>Berkeley</pubPlace>
		</imprint>
		<respStmt>
			<orgName>EECS Department, University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Panorama: capturing system-wide information flow for malware detection and analysis</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM conference on Computer and communications security</title>
		<meeting>the 14th ACM conference on Computer and communications security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="116" to="127" />
		</imprint>
	</monogr>
	<note>CCS &apos;07, ACM</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
