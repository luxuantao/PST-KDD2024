<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The LLUNATIC Data-Cleaning Framework</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Antwerp -Antwerp</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Giansalvatore</forename><surname>Mecca</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Università della Basilicata -Potenza</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Papotti</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Qatar Computing Research Institute (QCRI) -Doha</orgName>
								<address>
									<country key="QA">Qatar</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Donatello</forename><surname>Santoro</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Università della Basilicata -Potenza</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Università Roma Tre -Roma</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">The 39th International Conference on Very Large Data Bases</orgName>
								<address>
									<addrLine>Riva del Garda</addrLine>
									<postCode>26th -30th 2013</postCode>
									<settlement>August, Trento</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The LLUNATIC Data-Cleaning Framework</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6F8E2FD6480B95A3C04947A82F02D469</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Data-cleaning (or data-repairing) is considered a crucial problem in many database-related tasks. It consists in making a database consistent with respect to a set of given constraints. In recent years, repairing methods have been proposed for several classes of constraints. However, these methods rely on ad hoc decisions and tend to hard-code the strategy to repair conflicting values. As a consequence, there is currently no general algorithm to solve database repairing problems that involve different kinds of constraints and different strategies to select preferred values. In this paper we develop a uniform framework to solve this problem. We propose a new semantics for repairs, and a chase-based algorithm to compute minimal solutions. We implemented the framework in a DBMSbased prototype, and we report experimental results that confirm its good scalability and superior quality in computing repairs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>In the constraint-based approach to data quality, a database is said to be dirty if it contains inconsistencies with respect to some set of constraints. The data-cleaning (or data-repairing) process consists in removing these inconsistencies in order to clean the database. It represents a crucial activity in many real-life information systems as unclean data often incurs economic loss and erroneous decisions <ref type="bibr" target="#b14">[15]</ref>.</p><p>Data cleaning is a long-standing research issue in the database community. Focusing on recent years, many interesting proposals have been put forward, all with the goal of handling the many facets of the data-cleaning process.</p><p>-A plenitude of constraint languages has been devised to capture various aspects of dirty data as inconsistencies of constraints. These constraint languages range from standard database dependency languages such as functional dependencies and inclusion dependencies <ref type="bibr" target="#b0">[1]</ref>, to conditional functional dependencies <ref type="bibr" target="#b15">[16]</ref> and conditional inclusion dependencies <ref type="bibr" target="#b14">[15]</ref>, to matching dependencies <ref type="bibr" target="#b13">[14]</ref> and editing-rules <ref type="bibr" target="#b17">[18]</ref>, among others. Each of these languages allows to capture different forms of dirtiness in data.</p><p>-Various repairing strategies have been proposed for these constraint languages. One of the distinguishing features of these strate-gies is how they use the constraints to modify the dirty data by changing values into "preferred " values. Preferred values can be found from, e.g., master data <ref type="bibr" target="#b23">[24]</ref>, tuple-certainty and value-accuracy <ref type="bibr" target="#b18">[19]</ref>, freshness and currency <ref type="bibr" target="#b16">[17]</ref>, just to name a few.</p><p>-Repairing strategies also differ in the kind of repairs that they compute. Since the computation of all possible repairs is infeasible in practice, conditions are imposed on the computed repairs to restrict the search space. These conditions include, e.g., various notions of (cost-based) minimality <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b9">10]</ref> and certain fixes <ref type="bibr" target="#b17">[18]</ref>. Alternatively, sampling techniques are put in place to randomly select repairs <ref type="bibr" target="#b6">[7]</ref>.</p><p>It is thus safe to say that there is already a good arsenal of approaches and techniques for data cleaning at our disposal. In this paper, we want to capitalize on this wealth of knowledge about the subject, and investigate the following foundational problem: what happens to the data administrator facing a complex data-cleaning problem that requires to bring together several of the techniques discussed above? This problem is illustrated in the following example.</p><p>Example 1: Consider the database shown in Fig. <ref type="figure" target="#fig_0">1</ref> consisting of customer data (CUSTOMERS), with their addresses and credit-card numbers, and medical treatments paid by insurance plans (TREAT-MENTS). We refer to these two tables as the target database to be cleaned. As is common in corporate information systems <ref type="bibr" target="#b23">[24]</ref>, an additional master-data table is available; this table contains highlycurated records whose values have high accuracy and are assumed to be clean. In our approach, master data is referred to as the source database, since it is a source of reliable clean data.  We first illustrate the problem of specifying a set of constraints under which the target database is regarded to be clean, as follows: (a1) Standard functional dependencies (FD): d1 = (SSN, NAME → PHONE) and d2 = (SSN, NAME → CC#) on table CUS-TOMERS. The pair of tuples {t2, t3} in the target database violates both d1 and d2; the database is thus dirty.</p><p>(a2) A conditional FD (CFD): d3 = (INSUR[Abx] → TREAT [Dental]) on table TREATMENTS, expressing that insurance company 'Abx' only offers dental treatments ('Dental'). Tuple t5 violates d3, adding more dirtiness to the target database.</p><p>(a3) A master-data based editing rule (eR), d4, stating that whenever a tuple t in CUSTOMERS agrees on the SSN and PHONE attributes with some master-data tuple tm, then the tuple t must take its NAME, STR, CITY attribute values from tm. Tuple t2 does not adhere to this rule.</p><p>(a4) An inter-table CFD d5 between TREATMENTS and CUSTOME-RS, stating that the insurance company 'Abx' only accepts customers who reside in San Francisco (SF). Tuple pairs {t1, t4} and tuples {t1, t5} violate this constraint.</p><p>With the dirty target database at hand, we are faced with the problem of repairing it. The main problem is to identify and select "preferred values" as modifications to repair the data.</p><p>(b1) Consider FD d1. To repair the target database one may want to equate t2[PHONE] and t3 <ref type="bibr">[PHONE]</ref>. The FD does not tell, however, to which phone number these attribute values should be repaired: '122-1876' or '000-0000', or even a completely different value. As it happens in this kind of problems, we assume that the PHONE attribute values in the CUSTOMERS table come with a confidence (Conf.) value. If we assume that one prefers values with higher confidence, we can repair t3[PHONE] by changing it to '122-1876'.</p><p>(b2) Similarly, when working with the TREATMENTS table, we may use dates of treatments to infer the currency of other attributes. If the target database is required to store the most recent value for the salary by FD d6 = (SSN → SALARY), this may lead us to repair the obsolete salary value '10K' in t4 with the more recent (and preferred) value '25K' in t5.</p><p>(b3) Notice that we don't always have a clear policy to choose preferred values. For example, when repairing t2[CC#] and t3[CC#] for FD d2, there is no information available to resolve the conflict. This means that the best we can do is to "mark" the conflict, and then, perhaps, ask for user-interaction in order to solve it.</p><p>Another crucial aspect that complicates matters is the interaction between dependencies: repairing them in different orders may generate different repairs.</p><p>(c1) Consider dependencies d1 and d4. As discussed above, we can use d1 to repair tuples t2, t3 such that both have phone-number '122-1876'; then, since t2 and t3 agree with the master-data tuple tm, we can use d4 to fix names, streets and cities, to obtain: (222, F. Lennon, 122-1876, Sky Dr., SF, 781658), for t2, and (222, F. Lennon, 122-1876, Sky Dr., SF, 784659), for t3. However, if, on the contrary, we apply d4 first, only t2 can be repaired as before; then, since t2 and t3 do not share the same name anymore, d1 has no violations. We thus get a different result, of inferior quality.</p><p>A first, striking observation about our example is that, despite many studies on the subject, there is currently no way to handle this kind of scenarios. This is due to several strong limitations of the known techniques.</p><p>Problem 1: Missing Semantics First, although repairing strategies exist for each of the individual classes of constraints discussed at items (a1), (a2) and (a3), there is currently no formal semantics for their combination. In fact, the interactions shown in (c1) require a uniform treatment of the repairing process and a clear definition of what is a repair. Aside from the generic notion of a repair as an updated database that satisfies the constraints, it is not possible to say what represents a "good" repair in this case. Problem 2: Missing Repair Algorithms Since there is no semantics, we have no algorithms at our disposal to compute repairs. Notice that combining the repairing algorithms available for each of the constraints in isolation does not really help, since repairing a constraint of one type may break one of a different type. Also, current algorithms tend to hard-code the way in which preferred values are used for the purpose of repairing the database. As a consequence, there is no way to incorporate the different strategies illustrated in (b1) and (b2) into existing repairing algorithms in a principled way.</p><p>Problem 3: Main-Memory Implementations and Scalability Third, even if we were able to devise a reasonable semantics for this kind of scenarios, we would still face a paramount problem, i.e., computing solutions in a scalable way despite the high complexity of the problem. Computing repairs requires to explore a space of solutions of exponential size wrt the size of the database. In fact, previous proposals have mainly adopted main-memory implementations to speed-up the computation, with a rather limited scalability (in the order of the tens of thousands of tuples). Contributions The main contribution of this paper consists in developing a uniform framework for data-cleaning problems that solves the issues discussed above. More specifically:</p><p>(i) We introduce a language to specify constraints based on equality generating dependencies (egds) <ref type="bibr" target="#b3">[4]</ref> that generalizes many of the constraints used in the literature. This standardizes the way to express dependencies, and extends them to express inter-table constraints, with several benefits in terms of scalability, as discussed in our experiments.</p><p>(ii) The core contribution of the paper consists in the definition of a novel semantics for the data-cleaning problem. The definition of such a semantics is far from trivial, since our goal is to formalize the process of cleaning an instance as the process of upgrading its quality, regardless of the specific notions of value preference adopted in a given scenario. Our semantics builds on two main concepts. First, we show that seeing repairs simply as cell updates is not sufficient. On the contrary, we introduce the new notion of a cell group, that is essentially a "partial repair with lineage"; then, we formalize the notion of an upgrade by introducing a very general notion of a partial order over cell groups; the partial order nicely abstracts all of the most typical strategies to decide when a value should be preferred to another, including master data, certainty, accuracy, freshness and currency. In the paper, we show how users can easily plug-in their preference strategies for a given scenario into the semantics. Finally, by introducing a new category of values, called lluns, we are able to complete the lattice of instances induced by the partial order, and to provide a natural hook for incorporating user feedbacks into the process.</p><p>(iii) We introduce the notion of a minimal solution and develop algorithms to compute minimal solutions, based on a parallel-chase procedure. The definition of the chase is far from trivial, since our goal is to guarantee both generality and proper scalability. To start, we chase violations not at tuple level, but at equivalenceclass level <ref type="bibr" target="#b7">[8]</ref>. This allows us to introduce a notion of a cost manager as a plug-in for the chase algorithm that selects which repairs should be kept and which ones should be discarded. The cost manager abstracts and generalizes all of the popular solutionselection strategies, including similarity-based cost, set-minimality, set-cardinality minimality, certain regions, sampling, among others. In Example (iv) We develop an implementation of the chase engine, called LLUNATIC. To the best of our knowledge, LLUNATIC is the first system that runs over the DBMS to compute repairs. We devote special care in implementing our parallel chase -which may generate large trees of repairs -in a scalable way. A key ingredient of our solution is the development of an ad-hoc representation systems for solutions, called delta relations. In our experiments, we show that the chase engine scales to databases with millions of tuples, a considerable advancement in scalability wrt previous mainmemory implementations.</p><p>We believe that these contributions make a significant advancement with respect to the state-of-the-art. To start, our proposal generalizes many previous approaches. Table <ref type="table" target="#tab_1">1</ref> summarizes the features of LLUNATIC with respect to some of these approaches. LLUNATIC is the first proposal to achieve such a level of generality. Even more important, this work sheds some light on the crucial aspect of data-cleaning problems, namely the trade-offs between the quality of solutions and the complexity of repairing algorithms. This allows us to select data-repairing algorithms with good scalability and superior quality with respect to previous proposals, as our experiments show. Organization of the Paper The preliminaries are in Section 2. In Sections 3, 4, and 5 we introduce the key components of the semantics of a cleaning scenario, which is defined in Section 6. The chase algorithm is described in Sections 7 and 8. Our experiments are reported in Section 9. Related work is described in Section 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>We start by presenting some background notions and introducing the constraint language used in the paper.</p><p>A schema S is a finite set {R1, . . . , R k } of relation symbols, with each Ri having a fixed arity ni ≥ 0. Let CONSTS be a countably infinite domain of constant values, typically denoted by lowercase letters a, b, c, . . . . Let NULLS be a countably infinite set of labeled nulls, distinct from CONSTS. An instance I = (I1, . . . , I k ) of S consists of finite relations Ii ⊂ (CONSTS ∪ NULLS) n i , for i ∈ <ref type="bibr">[1, k]</ref>. Let R be a relation symbol in S with attributes A1, . . . , An and I an instance of R. A tuple is an element of I and we denote by t.Ai the value of tuple t in attribute Ai. Furthermore, we always assume the presence of unique tuple identifiers for tuples in an instance. That is, ttid denotes the tuple with id "tid " in I. Given two disjoint schemas, S and T , if I is an instance of S and J is an instance of T , then the pair I , J is an instance of S, T .</p><p>A relational atom over T is a formula of the form R(x) with R ∈ T and x is a tuple of (not necessarily distinct) variables. Traditionally, an equality generating dependency (egd) over T is a formula of the form ∀ x(φ(x) → xi = xj) where φ(x) is a conjunction of relational atoms over T and xi and xj occur in x.</p><p>To express data-cleaning contraints, we rely on a specific form of egd. More specifically, besides relation atoms, we also consider equation atoms of the form t1 = t2, where t1, t2 are either constants in CONSTS or variables, and allow for both source and target atoms in the premise. In our approach, a cleaning egd is then a formula of the form ∀ x(φ(x) → t1 = t2) where φ(x) is a conjunction of relational and equation atoms over S, T , and t1 = t2 is of the form xi = c or xi = xj, for some variables xi, xj in x and constant c ∈ CONSTS. Furthermore, at most one variable in the conclusion of an egd can appear in the premise as part of a relation atom over S. The latter condition is to ensure that the egd specifies a constraint on the target database rather than on the fixed source database. With an abuse of notation, in the following we shall often refer to these cleaning egds simply as egds. Egds for our running example are expressed as follows: e1. Cust(ssn, n, p, s, c, cc), Cust(ssn, n, p , s , c , cc ) → p = p e2. Cust(ssn, n, p, s, c, cc), Cust(ssn, n, p , s , c , cc ) → cc = cc e3. Treat(ssn, s, ins, tr, d), ins = 'Abx' → tr = 'Dental' e4. Cust(ssn, n, p, s, c, cc), MD(ssn, n , p, s , c ) → n = n e5. Cust(ssn, n, p, s, c, cc), MD(ssn, n , p, s , c ) → s = s e6. Cust(ssn, n, p, s, c, cc), MD(ssn, n , p, s , c ) → c = c e7. Cust(ssn, n, p, str , c, cc), Treat(ssn, sal , ins, tr, d), ins = 'Abx' → c = 'SF' e8. Treat(ssn, s, ins, tr, d), Treat(ssn, s , ins , tr , d ) → s = s An immediate observation is that constants in egds can be avoided altogether, by encoding them in additional tables in the source database. Consider dependency e3 in our example in which two constants appear: 'Abx' in attribute INSUR and 'Dental' in attribute TREAT. We extend S with an additional binary source table, denoted by CSTe3 with attributes INSUR and TREAT, corresponding to the "constant" attributes in e3. Furthermore, we instantiate CSTe3 with the single tuple te 3 : (Abx, Dental). Given this, e3 can be expressed as an egd without constants, as follows: e 3 . Treat(ssn, s, ins, tr, d), Cste 3 (ins, tr ) → tr = tr In general, S can be extended with such constants tables, one for each CFD, and their source tables contain tuples for the constants used to define the CFD. In other words, these tables coincide with the pattern tableaux associated with the CFDs <ref type="bibr" target="#b15">[16]</ref>. Of course, one needs to provide a proper semantics of egds such that whenever such constant tables are present, egds have the same semantics as CFDs. We give such semantics later in the paper.</p><p>Further extensions of egds with, e.g., built-in predicates, matching functions and negated atoms, are needed to encode matching dependencies and constraints for numerical attributes <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b8">9]</ref>. We do not consider them in this paper for simplicity of exposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CLEANING SCENARIOS AND LLUNS</head><p>Our uniform framework for data repairing is centered around the concept of a cleaning scenario. A cleaning scenario consists essentially of a source schema S, a target schema T , and a set of constraints Σ. Here, S and T represent the two databases involved in the repairing process (see Example 1): (i) S, the source database, provides clean and reliable information as input for the repairing process (like, for example, master data). We assume that source databases cannot be changed and consist of constants from CONSTS only; (ii) T , the target database, corresponds to the database that is dirty relative to Σ, and that needs to be repaired. The target database may contain constants from CONSTS and null values from NULLS. Such null values indicate missing or unknown values. However, we also allow the target database to contain a third class of values, called lluns (pronounced "loons"), which we introduce next.</p><p>Recall from Example 1 that t2 and t3 form a violation for the dependency e2 (stating that customers with equal ssns and names should have equal credit-card numbers), and that the target database could be repaired by equating t2.CC# = t3.CC#. However, as discussed before, no information is available as to which value should be taken in the repair. In such case, we repair the target database (for e2) by changing t2.CC# and t3.CC# into the llun L0, that is to indicate that we need to introduce a new value for the credit-card number that may be either 781658 or 784659, or some other preferred value. In this case, such value is currently unknown and we mark it so that it might be resolved later on into a constant, e.g., by asking for user input.</p><p>We denote by LLUNS = {L1, L2, . . .} an infinite set of symbols, called lluns, distinct from CONSTS and NULLS. Lluns can be regarded as the opposite of nulls since lluns carry "more information" than constants. In our approach, they play two important roles: (i) they allow us to complete the lattice induced by our partial orders, as it will be discussed in the next section; (ii) they provide a clean way to record inconsistencies in the data that require the intervention of users to be resolved.</p><p>With this in mind, given an instance J of T , along with an instance I of S, the goal is to compute a repair of J, i.e., a set of updates to J such that the resulting instance satisfies the constraints in Σ.</p><p>Early works about database repairing <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b20">21]</ref> followed an approach that relied on tuple-insertions and tuple-deletions. Since tuple-deletions may bring to unnecessary loss of information, the recent literature has concentrated on tuple updates, instead. Roughly speaking, we may say that the semantics adopted in these works are centered around three main ideas. First, a repair is seen as a set of changes to the cells of the database (each cell being an attribute of a tuple). Second, the logic to repair conflicting values is hardcoded into the semantics. Third, cost functions are used to (heuristically) compare different repairs and choose the "good" ones.</p><p>In the following sections, we develop a new semantics for cleaning scenarios that departs from this standard in three significant ways. Our first intuition is that, in order to generalize the semantics to larger classes of constraints and different ways to pick-up preferred values, it is not sufficient to reason about single-cell updates. On the contrary, we need to introduce a notion of "repairs with a lineage", called cell groups, in the sense that: (a) we keep track of cells that need to be repaired together; (b) we keep track of the provenance of their values, especially if they come from the source database.</p><p>A second, key idea, is that the strategy to select preferred values and repair conflicts should be factored-out of the actual repairing algorithm. Our solution to do that is to introduce a notion of a partial order over cell groups. The partial order plays a central role in our semantics, since it allows us to identify when a repair is an actual "upgrade" of the original database.</p><p>Finally, we introduce a principled way to check when a repaired instance satisfies the constraints, and to compare repairs with one another. This is based on an extension to data cleaning of the notion of instance homomorphism <ref type="bibr" target="#b11">[12]</ref> that is typically used to compare the relative information content of database instances.</p><p>The next sections are devoted to these notions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CELL GROUPS AND REPAIRS</head><p>Given instance I , J of S, T , we represent the set of changes made to repair the target database J in terms of cell groups. As the name suggests, cell groups are groups of cells, i.e., locations in a database specified by tuple/attribute pairs ttid.Ai. For example, t2.CC# and t3.CC# are two cells in the CUSTOMERS table. Observe the following:</p><p>(a) As our example shows, to repair inconsistencies, different cells are often changed together, i.e., they are either changed all at the same time or not changed at all. For example, t2.CC# and t3.CC# are both modified to the same llun value in Figure <ref type="figure">2</ref>. Cell groups thus need to specify a set of target cells, called occurrences of the group, and a value to update them.</p><p>(b) In addition, in some cases the target cells to repair receive their value from the source database; consider Example 1 and dependency e5. When repairing t2, cell t2.STREET gets the value 'Sky Dr.' from cell tm.STREET. Since source cells contain highly reliable information, it is important to keep track of the relationships among changes to target cells and values in the source. To do this, a cell group c has a set of associated source cells carrying provenance information about the repair in terms of cells of the source database. We call these source cells the justifications for c, since they provide lineage information for the change we make to the target cells in c, i.e., to its occurrences. Occurrences and justifications need to be kept separate since we can only update target cells, while source cells are immutable.</p><p>(c) Cell groups provide an elegant way of describing repairs. Indeed, in order to specify a repair it suffices to provide the original target database together with the set of cell groups to modify. In other words, cell groups can be seen as partial repairs with lineage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>These observations are captured by the following definitions:</head><p>Definition 1 [CELL GROUP] A cell group g over an instance I , J of S, T is a triple v → C, by Cs where: (i) v is a value in CONSTS ∪ NULLS ∪ LLUNS; (ii) C is a finite set of cells of the target instance, J, called the occurrences of g, denoted by occ(g);</p><p>(iii) Cs is a finite set of cells of the source instance, I, called the justifications of g, denoted by just(g).</p><p>A cell group g = v → C, by Cs can be read as "change the target cells in C to value v, justified by the source cells in Cs". We define a repair to an instance I , J as a set of cell groups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 [REPAIR]</head><p>A repair Rep = {g0, . . . , g k } for instances I , J is a (possibly empty) finite set of cell groups over I , J , such that each cell of J occurs in at most one cell group gi.</p><p>That is, each cell in J is either unchanged in a repair or it is modified in a unique way as described by the cell group to which it belongs. We denote by g Rep (c) the cell-group of cell c according to Rep.</p><p>Example 2: In our example, consider the repair Rep 1 , consisting of the following cell groups referred to as g1, . . . , g7: Cell group g1 fixes credit-card numbers for dependency e2; it has empty justifications because no source relation is involved in e2. On the contrary, cell groups g2 and g4 repair tuples t2, t3 for dependencies e4, e5; justifications for these groups contain the respective cells in the master-data tuple tm. Similarly, for cell groups g5, g6; here tc 3 , tc 7 are the tuples in the CSTe 3 , CSTe 7 tables, encoding the constants in the original CFDs.</p><formula xml:id="formula_0">Rep 1 = { g1 : L0(781658, 784659) → {t2.CC#, t3.CC#},</formula><p>When applied to the original database in Figure <ref type="figure" target="#fig_0">1</ref>, repair Rep 1 yields the repaired instance shown in Figure <ref type="figure">2</ref>. Clearly, other repairs are possible. For example, to resolve e3 one may consider changing the value of the cell t5.INSURANCE into a new llun value L1, i.e., an unknown value that improves 'Abx'. The following repair, Rep 2 , follows the same approach to satisfy all dependencies, and yields the repaired instance shown in Figure <ref type="figure">3</ref>:</p><formula xml:id="formula_1">Rep 2 = {g7, L1 → {t1.SSN}, by ∅ , L2 → {t2.SSN}, by ∅ L3 → {t5</formula><p>.INSURANCE}, by ∅ } Note that J itself can be seen as the empty repair, Rep ∅ .</p><p>Given I, J , we say that a repair is complete if each cell of J occurs in a cell group in Rep, i.e., all cells in J are covered by the repair. We may assume, without loss of generality, that a repair is always complete. Indeed, a repair Rep can be easily completed into a complete repair Rep , as follows: (i) initially, we let Rep = Rep; (ii) for each cell c of J that is not changed by Rep, if val(c) ∈ CONSTS, then we add to Rep the cell group val(c) → {c}, by ∅ ; (iii) for each cell c of J that is not changed by Rep, if val(c) ∈ NULLS, then we add to Rep the cell group of c with value val(c), occurrences consisting of all cells of J in which val(c) occurs and empty justifications.</p><p>From now on, we always assume a repair to be complete, and we blur the distinction between a repair Rep and the instance Rep(J ) obtained by applying Rep to J .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THE PARTIAL ORDER</head><p>We are now ready to introduce another crucial ingredient of our framework: the partial order. The partial order is the core element of the semantics of our repairs and, as already mentioned, is used to indicate preferred upgrades to the target database. We want users to be able to specify different partial orders for different repairing problems in a simple manner. To do this, the user only has to specify for each attribute in the target schema when two values are preferred over each other. This is done by specifying an assignment Π of so-called ordering attributes to T . As we will see shortly, such an assignment automatically induces a partial order on cell groups.</p><p>A Hierarchy of Information Content. In order to define our partial order, let us first introduce a simple hierarchy between the three kinds of values that appear in a database, namely nulls, constants, and lluns. More specifically, given two values v1, v2 ∈ NULLS ∪ CONSTS ∪ LLUNS, we say that v2 is more informative than v1, in symbols v1 ¡ v2 if v1 and v2 are of different types, and one of the following holds: (i) v1 ∈ NULLS, i.e., the first value is a null value; or (ii) v2 ∈ LLUN, i.e., the second value is a llun.</p><p>User-Specified preferred values. We say that an attribute A of T has ordered values if its domain DA is a partially ordered set. To specify which values should be preferred during the repair, users may associate with each attribute Ai of T a partially ordered set PA i = D, ≤ . The poset PA i associated with attribute Ai may be the empty poset, or its domain DA i if Ai has ordered values, or the domain of a different attribute DA j that has ordered values. In the latter case, we call Aj the ordering attribute for Ai. Intuitively, PA i specifies the order of preference for values in the cells of Ai. An assignment of ordering attributes to attributes in T is denoted by Π. For reasons that become clear shortly, Π is referred to as the partial order specification.</p><p>In our example, the DATE attribute in the TREATMENTS table, and the confidence column, CONF, in the CUSTOMERS table have ordered values (to simplify the treatment, we consider CONF as an attribute of the table). For these attributes, we choose the corresponding domain as the associated poset (i.e., we opt to prefer more recent dates and higher confidences). Other attributes, like the PHONE attribute in the CUSTOMERS table, have unordered values; we choose CONF as the ordering attribute for PHONE (a phone number will be preferred if its corresponding confidence value is higher). Notice that there may be attributes, like SALARY in TREATMENTS, that have ordered values; however, the natural ordering of values does not reflect our notion of a preferred value. To model the correct notion of preference, we use DATE as the ordering attribute for SALARY (we prefer most recent salaries). Finally, attributes like SSN will have an empty associated poset, i.e., all constant values are equally preferred. Below is a summary of the assignment Π of ordering attributes in our example (attributes not listed have an empty poset):</p><formula xml:id="formula_2">Π =          PCUSTOMERS.CONF = DCUSTOMERS.CONF PTREATMENTS.DATE = DTREATMENTS.DATE PCUSTOMERS.PHONE = DCUSTOMERS.CONF PTREATMENTS.SALARY = DTREATMENTS.DATE PCUSTOMERS.SSN = ∅         </formula><p>Partial order on cell values. Given an assignment Π, we can define a corresponding partial order Π J for the values of cells of the target instance J as follows. For any pair of values v1, v2 we say that v1 Π J v2 iff one of the following holds: (i) either v1 = v2 or v1 ¡v2, i.e., the values are equal or the second one is more informative than the first;</p><p>(ii) v1 appears in cell t1.A1, v2 in cell t2.A2 in J , and both are constants in CONSTS; then, assume the ordering attributes for A1 and A2, called A 1 , A 2 have the same poset, i.e.,</p><formula xml:id="formula_3">P A 1 = P A 2 ; call v 1 , v 2 the values of cells t1.A 1 , t2.A 2 . Then, v1 Π J v2 iff v1 = v2 or v 1 &lt; v 2 according to P A 1 = P A 2 .</formula><p>We also consider values of the source instance I . In our approach, source values are immutable, and all equally preferable. So, we assume that the partial order I over values in I is based on rule (i) only. We call Π I ,J the partial order over values of cells in I , J obtained by the union of Π J and I , with the additional rule that values of source cells are always preferable to values of target cells, i.e., for each target cell t.At and source cell t .As, it is always the case that val(t.At) Π I ,J val(t .As). In fact, we always give preference to values from the source, like master-data or constant values in dependencies.</p><p>Given the partial order Π I ,J , in the following we want to be able to compute upper bounds for cell values. To do this, we use lluns. Indeed, for any set C of cells we denote by lub Π I ,J Partial order on cells groups. The partial order Π I ,J over cell values induces a partial order on the cell groups of I , J . Before we turn to the definition, we want to exclude from the comparison cell groups that correspond to unjustified ways of changing the target. In order to do this, we say that a cell group g has a valid value if one of the following conditions holds. Consider the value val lub that is the least upper bound of values in occ(g) ∪ just(g) according to Π I ,J , i.e., val lub = lub Π I ,J</p><p>(just(g) ∪ occ(g)). Then, either val(g) = val lub , i.e., the cell group takes the value of the least upper bound, or val lub ¡val(g), i.e., the cell group takes an even more informative value. Given cell groups g and g with valid values, we say that g Π g iff (i) occ(g) ⊆ occ(g ) and just(g) ⊆ just(g ), and (ii) either val(g) and val(g ) are values of the same type (null, constant, or llun), or val(g) ¡ val(g ). In essence, we say that a cell group g can only be preferred over a cell group g according to the partial order, if a containment property is satisfied, and the value of g is at least as informative as the value of g. If the containment property is not satisfied for g and g then these cell groups are incomparable relative to the partial order. Indeed, cell groups that change unrelated groups of cells represent incomparable ways to modify a target instance.</p><p>Example 3: Consider a simple relation R(A, B), with three dependencies: (i) an FD A → B, and two CFDs:</p><formula xml:id="formula_4">(ii) A[a] → B[x], A[a] → B[y].</formula><p>Notice that the two CFDs clearly contradict each other. Assume R contains two tuples: t1 : R(a, 1), t2 : R(a, 2), and that PA is A itself. Following is a set of ordered cell groups: . This is where the real strength of the partial order lies: it provides a uniform way of incorporating information on preferred repairs.</p><formula xml:id="formula_5">1 → {t1.B}, by ∅ Π 2 → {t1.B, t2.B}, by ∅ Π x → {t1.B,</formula><p>Proposition 1: Given an assignment Π of ordering attributes to attributes in T , the corresponding partial order Π I ,J over values of cells in I , J induces a partial order Π over the cell groups and repairs of I , J . In fact, Π is semi-join lattice.</p><p>Notice that, besides the standard rules above, users may specify additional custom rules to plug-in other value-selection strategies and refine the lattice of cell groups. As an example, a frequency rule may state that the lub of cell groups g and g with constant values c1 and c2 and empty justifications should take as value c1 (c2, resp.) if |occ(g1)| &gt; |occ(g2)| (|occ(g2)| &gt; |occ(g1)|, resp.).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SEMANTICS</head><p>With the partial order specification Π in place, we now define a cleaning scenario as a quadruple CS = { S, T , Σ, Π}. Given a cleaning scenario and an instance I , J , we address the problem of defining a solution for CS over I , J . Intuitively, a solution is a repair for I , J that satisfies the set Σ of egds and is an upgrade of the original target instance J relative to Π . We next formalize these notions.</p><p>Consider an instance I, Rep(J) and a set Σ of constraints. Usually, Rep(J) is called a solution if I, Rep(J) satisfies Σ using the standard semantics of first-order logic. Since we want to -rather ambitiously-ensure that there is always a solution we need to revise this semantics. In contrast, previous proposals often fail to return a repair or are stuck in an endless loop during repairing, as is illustrated next.</p><p>Consider dependency e3 from Example 1. Suppose that a contradictory dependency e 3 .Treat(ssn, s, ins, tr, d), ins = 'Abx → tr = 'Cholest. is specified. In addition, assume that only modifications to the TREAT attribute-values are allowed. Clearly, there is no repair made of constants that can satisfy both dependencies <ref type="bibr" target="#b15">[16]</ref>. However, one may consider of changing 'Dental' and 'Cholest.' to a llun L that improves both original values. In essence, the llun has the role of indicating to the user that the constraints are contradictory. In our setting, we want to regard this repair as a solution of a conflicting cleaning scenario.</p><p>Consider an egd e : ∀x φ(x) → x = x . First, recall that, in the standard semantics, I, Rep(J) satisfies e if for any homomorphism h that maps the variables x into values of I, Rep(J) such that φ(h(x)) is true, then also h(x) = h(x ) must be true. We want this to hold in our semantics as well. However, we want more. That is, we allow h(x) = h(x ) as long as the cell group corresponding to h(x) is an upgrade to the cell groups corresponding to h(x ), or vice versa.</p><p>To make this precise, we need to extend h to a mapping from variables to cell groups. Since h associates values to variables, it also associates with each variable xi ∈ x a set of cells from I, Rep(J) , called cells h (xi), one for each occurrence of xi and all with the same value, h(xi). We use these to define the cell group of xi according to h, as follows.</p><p>Given a formula φ(x), a repair Rep, an homomorphism h of φ(x) into I, Rep(J) , and a variable xi ∈ x, the cell group of xi according to h is defined as g h (xi) = h(xi) → C, by Cs where C (resp. Cs) is the union of all occurrences (resp. justifications) of cell groups g Rep (ci) in Rep, for each cell ci ∈ cells h (xi). In addition, Cs contains all cells in cells h (xi) that belong to the source I.</p><p>We are now ready to introduce our extended notion of satisfaction, namely satisfaction after repairs: Definition 3 [SATISFACTION AFTER REPAIRS] Given an egd e : ∀x φ(x) → x = x , an instance I, J , and a repair Rep, we say that I, Rep(J) satisfies after repairs e wrt the partial order Π if, whenever there is an homomorphism h of φ(x) into I, Rep(J) , then (i) either the value of h(x) and h(x ) are equal, or (ii) it is the case that g h (x) Π g h (x ) or g h (x ) Π g h (x).</p><p>We can now find a repair that satisfies the conflicting egds e3 and e 3 above. Given a tuple t in the target, consider Rep that repairs t.TREAT with L, and justifies the change with both cells in the source corresponding to constants 'Dental' and 'Cholest.'. Now, despite the fact that L is not equal to any of the constants in the dependencies, both dependencies are satisfied after repairs by Rep(J).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 [SOLUTION]</head><p>Given a cleaning scenario CS = { S, T , Σ, Π} and instance I , J a solution for CS over I , J is a repair Rep such that: (i) J Π Rep, i.e., Rep upgrades J; and (ii) I, Rep(J) satisfies after repairs Σ wrt Π . An important property of cleaning scenarios is that every input instance has a solution, albeit a solution that is not necessarily minimal and is rather uninformative.</p><p>Theorem 2: Given a scenario CS = { S, T , Σ, Π} and an input instance I , J , there always exists a solution for CS and I , J . Proof: Indeed, there is always a solution corresponding to the repair that changes all cells of J to a single llun L, and justifies it by all cells in I, i.e., Rep trivial = L → cells(J), by cells(I) . P Among all possible repairs, we are interested in those that minimally upgrade the dirty instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 [MINIMAL SOLUTION]</head><p>A minimal solution for a cleaning scenario is any solution Rep that is minimal wrt ≺ Π , i.e., such that there exists no other solution Rep such that Rep ≺ Π Rep.</p><p>The repair Rep 1 in Example 2 is a minimal solution for the scenario in Example 1: it is an upgrade of J , it satisfies the dependencies, and by undoing any of its changes violations arise. Minimal solutions are not unique. Indeed, also repair Rep 2 in Example 2 is a minimal solution. As an example of a non-minimal solution, one can add to Rep 2 the cell group L4 → {t2.NAME}, by ∅ . The resulting repair Rep 3 is still a solution but not a minimal one (Rep 2 ≺ Π Rep 3 ). Consider now repair Rep 4 , obtained by adding a cell group 111111 → {t2. CC#}, by ∅ to Rep 2 . In this case, Rep 4 is not a solution because the last cell group is totally unjustified wrt the partial order, and therefore it is not true that Rep 4 (J) is an upgrade of the original target instance.</p><p>An important property is that two repairs can be efficiently compared wrt to the partial order. We assume here that the partial order of two values v Π I ,J v can be checked in constant time. Theorem 3: Given two solutions Rep, Rep for a scenario CS over instance I , J , one can check Rep Π Rep in O(n+kmlog(m)) time, where n is the number of cells in J, k is the maximum number of cell groups in Rep, Rep , and m is the maximum size of a cell group in Rep, Rep .</p><p>Given a cleaning scenario CS and an instance I , J , the data repairing problem consists of computing all minimal solutions for CS over I , J . We provide a chase-based algorithm for the data repairing problem in the next section.</p><p>What are Lluns, in the End? The role and the importance of lluns should now be apparent. While lluns are nothing more than symbols from a distinguished set, like constants and nulls, their use in conjunction with cell groups makes them a powerful addition to the semantics. Not only they allow us to complete the lattice of cellgroups and repairs, but, when appearing inside cell-groups, they also provide important lineage information to support users in the delicate task of resolving conflicts. Consider again Example 3 in Section 5. The cell group L → {t1.B, t2.B}, by {tc1.x, tc2.y} is a clear indication that it was not possible to fully resolve the conflicts, and therefore user interventions are needed to complete the repair. In addition, the cell-group provides complete information about the conflict, both in terms of which target cells -and therefore which original values -where involved, and also in terms of source values that justify the change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">COMPUTING SOLUTIONS</head><p>In order to generate solutions for cleaning scenarios, we resort to a variant of the traditional chase procedure for egds <ref type="bibr" target="#b11">[12]</ref>. However, our chase is a significant departure from the standard one, for several reasons: (i) during the chase, we shall make extensive use of the partial order, Π ; (ii) to generate all possible solutions, a dependency may be chased both forward, to satisfy its conclusion, or backward, to falsify its premise; this, in turn, means that the we need to consider a disjunctive chase, which generates a tree of alternative repairs; (iii) finally, and most important, we shall not consider violations at the tuple level, as it is common <ref type="bibr" target="#b11">[12]</ref>, but at the higher level of equivalence classes.</p><p>To explain this latter difference, consider a simple functional dependency</p><formula xml:id="formula_6">A → B over relation R(A, B, C), with tuples t1 = R(1, 2, x), t2 = R(1, 2, y), t3 = R(1, 4, z), t4 = R(2, 5, w), t5 = R(2, 5, v).</formula><p>It is highly inefficient to analyze the violations of this FD at the tuple level; in fact, eventually, the B value of t1, t2, t3 will all become equal, and therefore one may prefer grouping and fixing them together. In the literature <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b14">15]</ref> this has been formalized by means of equivalence classes. We want to introduce a similar concept into our chase algorithm. Given the higher generality of our dependency language, we need a number of preliminary definitions.</p><p>Preliminary Notions Recall that, given an homomorphism h of a formula φ(x) into I, Rep(J) , we denote by g h (x) the cell group associated by h with variable x. We first introduce the notions of witness and witness variable for a dependency e. Intuitively, the witness variables are those variables upon which the satisfiability of the dependency premise depends; these are all variables that have more than one occurrence in the premise, i.e., they are involved in a join or in a selection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 [WITNESS]</head><p>Let e : ∀x (φ(x) → x = x ) be an egd. A witness variable for e is a variable x ∈ x that has multiple occurrences in φ(x). For an homomorphism h of φ(x) into I, Rep(J) , we call a witness, w h for e and h, the vector of values h(xw) for the witness variables xw of e.</p><p>Consider, for example, dependency e8 in Example 1 (we omit some of the variables for the sake of conciseness): e8. Treat(ssn, s, . . .), Treat(ssn, s , . . .) → s = s . Assume that the target instance TREATMENTS contains tuples t4 = (ssn : 222, salary : 10K, . . .), t5 = (ssn : 222, salary : 25K, . . .). We have an homomorphism h that maps the first atom of e8 into t4, and the second one into t5. In this case, the witness variable, i.e., the variable that imposes the constraint that the two tuples have the same SSN, is ssn, and its value is 222. Notice that equivalence classes induce classes of tuples in a natural way. In our example above, the tuples are partitioned into two equivalence classes, as follows: ec1 = {t1, t2, t3} (with witness 1) and ec2 = {t4, t5} (with witness 2).</p><p>To identify a violation, we look for different values in the conclusion of e. To see an example, consider the equivalence class ec1 (witness 1), composed of the three tuples {t1, t2, t3}: to identify the violation, we notice that they have two different values for the B attribute, 2 and 4, respectively. To formalize this, we introduce the set of witness groups, w-groups H , and conclusion groups, c-groups H , for H and e, as the set of cell groups associated by any homomorphism h ∈ H with the witness variables, xw, and the conclusion variables, x, x , respectively:</p><formula xml:id="formula_7">w-groups H = h∈H,xw ∈xw g h (xw) c-groups H = h∈H g h (x) ∪ h∈H g h (x )</formula><p>We say that an equivalence class for Rep and e generates a violation if it has at least two conclusion groups with different values and such that there is no ordering among them, i.e, there exist g1, g2 ∈ c-groups H such that val(g1) = val(g2) and neither g1 Π g2 nor g2 Π g1. In this case, we say that e is applicable to I, Rep(J) with H.</p><p>The Chase We are now ready to define the notion of a chase step. Our goal is to define the chase in such a way that it is as general as possible, but at the same time it allows to plug-in optimizations to tame the exponential complexity. In order to do this, we introduce the crucial notion of a repair strategy for an equivalence class, which provides the hook to introduce the notion of a cost manager in the next section.</p><p>A repair strategy rsH for H is a mapping from the set of conclusion cell-groups, c-groups H of Rep and H, into the set {f , b} (where f stands for "forward", and b for "backward"). We call the forward groups, forw-g rs H , of rsH the set of groups gi such that rsH(gi) = f , and the backward groups, back-g rs H , those such that rsH(gi) = b.</p><p>For each backward group g ∈ back-g rs H and for each target cell ci ∈ g, we assume that the repair strategy rsH also identifies (whenever this exists) one of the witness cells in w-groups H to be backward-repaired. This cell, denoted by w-cellrs H (ci), must be such that:</p><p>(i) it belongs to the same tuple as ci;</p><p>(ii) the corresponding cell group gi according to Rep has a constant value, i.e., val(gi) ∈ CONSTS;</p><p>(iii) the corresponding cell group gi has empty justifications, i.e., just(gi) = ∅.</p><p>Observe that we do not chase backward in two cases: first, when cells contain nulls or lluns; in fact, nulls and lluns are essentially placeholders, and there is no need to replace a placeholder by another one, since this is does not represent an upgrade of the repair; second, when cell values have a justification from the source; since we use the source to model high-reliability data, we consider it unacceptable to disrupt a value coming from the source in favor of a llun.</p><p>Each chase step is defined based on a specific repair strategy.  The leaves are repairs Rep such that there is no dependency applicable to I, Rep (J) with some equivalence class H. Any leaf in the chase tree is called a result of the chase of I , J with Σ.</p><p>Note that, as usual, the chase procedure is sensitive to the order of application of the dependencies. Different orders of application of the dependencies may lead to different chase sequences and therefore to different results.</p><p>We next show that the chase procedure always generates solutions, i.e., it is sound, and it terminates after a finite number of steps. Furthermore, all minimal solutions can be obtained in this way, i.e., the chase is complete for minimal solutions.</p><p>Theorem 4: Given a cleaning scenario CS = {S, T , Σ, Π} and an instance I , J , the chase of I , J with Σ (i) terminates; (ii) it generates a finite set of results, each of which is a solution for CS over I , J ; and (iii) it generates all minimal solutions.</p><p>Complexity It is well-known <ref type="bibr" target="#b4">[5]</ref> that a database can have an exponential number of solutions, even for a cleaning scenario with a single FD and when no backward chase steps are allowed. In general, it is readily verified that a cleaning scenario can have at most an exponential number of solutions. When considering the disjunctive chase procedure, as outlined above, one can verify that each solution is computed in a number of steps that is polynomial in the size of the data. For this, it suffices to observe that one can associate an integer-valued function f on repairs such that f (Rep) &lt; f (Rep ) whenever Rep →e,H Rep during the chase. Intuitively, f depends on the number of llun values and sizes of cell groups in the repairs. Since both the number of lluns and size of cell groups is bounded by the input instance, we may infer that f cannot be increased further after polynomially many steps, i.e., when a solution is obtained.</p><p>In contrast, computing all solutions by means of the chase takes exponential time in the size of instance. Indeed, given the polynomial size of each branch in the chase tree, as argued above, and the fact that the branching factor is polynomially bounded by the input, the overall chase tree is exponential in size. We discuss techniques to handle this high complexity in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">A SCALABLE CHASE</head><p>The chase procedure defined in the previous section provides an elegant operational semantics for cleaning scenarios. However, as argued above, computing all solutions has very high complexity, which makes the chase often impractical. In this section, we introduce a number of techniques that improve the scalability of the chase, namely: a central component of our framework, the cost manager, and a representation systems for chase trees, called delta databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Introducing the Cost Manager</head><p>Chasing at the equivalence-class level is more efficient than chasing at the tuple level, but by itself it does not reduce the total number of solutions, and ultimately the complexity of the whole chase process. In fact, previous proposals have chosen many different and often ad-hoc ways to reduce the complexity by discarding some of the solutions in favor of others. Among these we mention various notions of minimality of the repairs <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b6">7]</ref>, certain regions <ref type="bibr" target="#b17">[18]</ref>, and sampling <ref type="bibr" target="#b6">[7]</ref>. We propose to incorporate these pruning methods into the chase process in a more principled and user-customizable way by introducing a component, called the cost manager.</p><p>Definition 10 [COST MANAGER] Given a cleaning scenario, CS and instance I , J , a cost manager for CS and I , J is a predicate CM over repair strategies to be used during the chase. For each repair strategy rsH for equivalence class H, it may either accept it (CM(rsH) = true), or refuse it (CM(rsH) = false).</p><p>During the chase, we shall systematically make use of the cost manager. Whenever we need to chase an equivalence class, we only generate repairs corresponding to repair strategies accepted by the cost manager. The standard cost manager is the one that accepts all repair strategies, and may be used for very small scenarios. As an alternative, our implementation offers a rich library of cost managers. Among these, we mention the following, that have been used in experiments: -a maximum size cost manager (SN): it accepts repair strategies as long as the number of leaves in the chase tree (i.e., the repairs produced so far) are less than N ; as soon as the size of the chase tree exceeds N , it accepts only the first one of them, and rejects the rest; as a specific case, the S1 cost manager only considers one order of application of the dependencies, and ignores other permutations; -a frequency cost manager (FR): in order to repair equivalence class H for dependency e, FR adopts the following rules; it relies on the frequency of values appearing in conclusion cells, and on a similarity measure for values (based on the Levenshtein distance for strings); then: (i) it rejects repair strategies that backward-chase cells with the most frequent conclusion value; (ii) for every other conclusion cell, if its value is similar (distance below a fixed threshold) to the most frequent one, the cell is forward-chased; otherwise, it is backward chased; this is typically used with a frequency rule in the partial order of cell-groups; -a forward-only cost manager (FO): it accepts forward-only repair strategies, and rejects those that perform backward repairs.</p><p>Notice that combinations of these strategies are possible, to obtain, e.g., a FR-S5 or a FR-S1-FO cost manager. The FR-S5 relies on value frequencies and, in addition, it considers five different permutations of the dependencies, and for each of them will compute one repair. Alternative cost managers may implement different pruning strategies, to incorporate the notion of a certain region, and refute all steps in which changes are made to attributes of the target that are considered to be "fixed", i.e., reliable, or perform different forms of sampling. In the following, we shall always assume that a cost manager has been selected in order to perform the chase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Delta Databases</head><p>Even with cost managers in place, the parallel nature of our chase algorithm imposes to store a possibly large tree of repairs. A naive approach in which new copies of the whole database are created whenever we need to generate a new node in the tree, is clearly inefficient. To solve this problem, we introduce an ad-hoc representation system for nodes in our chase trees, called delta databases. Delta databases are a formalism to store a finite set of worlds into a single relational database. Intuitively, they allow to store "deltas", i.e., modifications to the original database, rather than entire instances as is done in the naive approach.</p><p>Delta relations rely on an attribute-level storage system, inspired by U-relations <ref type="bibr" target="#b1">[2]</ref>, modified to efficiently store cell groups and chase sequences. More specifically, (i) each column in the original database is stored in a separate delta relation, to be able to record cell-level changes; (ii) chase steps are identified by a function with a prefix property, such that the id of the father of n is a prefix of the encoding of n; this allows to quickly reconstruct the state of the database at any given step, using fast SQL queries; (iii) additional tables are used to store cell groups, i.e., occurrences and justifications.</p><p>More formally, we introduce a function stepId() that associates a string id with each chase step, i.e., with each node in the chase tree, and has the prefix property such that, stepId(father (n)) is a prefix of stepId(n), for each n. For this, we use the function that assigns the id r to the root, r.0, r.1, . . ., r.n to its children, and so on. During the chase, we store the whole chase tree into the delta database. We do not perform updates, which are slow, but execute inserts instead. Whenever, at step s, a cell t id .A in table R is changed to value v, we store a new tuple in the delta table R A with value (t id , stepId, v). Using this representation, it is possible to store trees of hundreds of nodes quite efficiently. In addition, it is relatively easy to find violations using SQL (the actual queries are omitted for space reasons).</p><p>In the next section we show how the combination of our advanced chase procedure and its implementation under the form of delta databases scale to large repairing problems with millions of tuples and large chase trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">EXPERIMENTS</head><p>The proposed algorithms have been implemented in a working prototype of the LLUNATIC system, written in Java. In this section, we consider several cleaning scenarios, of different nature and sizes, and study both the quality of the repairs computed by our system, and the scalability of the chase algorithm. We show that our algorithm produce repairs of better quality with respect to other systems in the literature, and at the same time scales to large databases. All experiments have been executed on a Intel i7 machine with 2.6Ghz processor and 8GB of RAM under Linux. The DBMS was PostgreSQL 9.2.  The second one, CUSTOMERS, corresponds to our running example in Figure <ref type="figure" target="#fig_0">1</ref>. The database schema contains 3 tables with 16 attributes, plus 2 additional tables encoding constants in CFDs. Dependencies are the ones in Section 1. We synthetically generated up to 1M tuples for the 2 target relations, with a proportion of 40% in the CUSTOMERS table, and 60% in TREATMENTS; the master-data table contains 20% of the tuples present in CUSTOMERS. We consider master-data tuples outside the total, as they cannot be modified. For this scenario, we defined the partial order as discussed in Section 5.</p><p>It is worth noting that these scenarios somehow represent opposite extremes of the spectrum of data-repairing problems. In fact, the HOSPITAL scenario contains functional dependencies only, and therefore is quite standard in terms of constraints; however, it can be considered a worst-case in terms of scalability, since all data are stored as a single, non-normalized table, with many attributes and lots of redundancy; over this single table, the 9 dependencies interact in various ways, and there is no partial-order information that can be used to ameliorate the cleaning process.</p><p>On the contrary, the CUSTOMERS scenario contains a complex mix of dependencies; this increased complexity of the constraints is compensated by the fact that data is stored as two normalized tables, with no redundancy, and clear preference strategies are given for some of the attributes.</p><p>Errors. In order to test our algorithms with different levels of noise, we introduced errors in the two datasets. Part of these errors were generated by a random-noise generator. However, in order to be as close as possible to real scenarios, in the HOSPITAL dataset we also used a different source of noise. We asked workers from Mechanical Turk (MT) (https://www.mturk.com/mturk/) to perform data entry for a random sample of tuples from the original database. Workers were shown the original tuple under the form of a jpeg image, and needed to manually copy values into a form. We used different groups of workers with different approval rates; approval rates measure the quality of a worker in terms of the percentage of previous jobs positively evaluated within MT. Approval rates varied between 50% and 99%; for these, we observed a percentage of wrong values between 5% and 1%. These errors were then complemented with those generated by the random noise generator.</p><p>For both datasets, we generated dirty copies with a number of noisy cells ranging from 1% to 5% of the total. Changes to the original values were done only for attributes involved in dependencies, in order to maximize the probability of generating detectable violations.</p><p>Algorithms. We tested LLUNATIC with several cost managers chosen among those presented in Section 8. We chose variants of the LLUNATIC-FR-SN cost manager -the frequency cost-manager that generates up to N solutions -with N = 1, 10, 50, and the LLUNATIC-FR-S1-FO, the forward-only variant of LLUNATIC-FR-S1. We do not report results obtained by the standard cost manager, as it only can be used with small instances due to its high computing times.</p><p>In order to compare our system to previous approaches, we tested also the following FD repair algorithms from the literature, implemented as separate systems: (a) Mimimum Cost <ref type="bibr" target="#b7">[8]</ref> (MIN. COST); (b) Vertex Cover <ref type="bibr" target="#b22">[23]</ref> (VERTEX COVER); (c) Repair Sampling <ref type="bibr" target="#b6">[7]</ref> (SAMPLING), for which, for each experiment, we took 500 samples, as done in the original paper.</p><p>Notice that these systems support a smaller class of constraints wrt to the ones expressible with cleaning egds (essentially FDs and, in some cases, CFDs). Several of the constraints in the CUS-TOMERS scenario are outside of this class, and therefore cannot handled by these algorithms. We therefore performed the comparison on the HOSPITAL scenario only.</p><p>Quality Metrics. We used precision-recall metrics. More specifically, for each clean database, we generated the set Cp of perturbated cells. Then, we run each algorithm to generate a set of repaired cells, Cr, and computed precision (P ), recall (R), and Fmeasure (F = 2 × (P × R)/(P + R)) of Cr wrt Cp. Since several of the algorithms may introduce variables as repairs -like our lluns -we calculated two different metrics.</p><p>The first one is the one adopted in <ref type="bibr" target="#b6">[7]</ref>, which we call Metric 0.5: (i) for each cell c ∈ Cr repaired to the original value in Cp, the score was 1; (ii) for each cell c ∈ Cr changed into a value different from the one in Cp, the score was 0; (iii) for each cell c ∈ Cr repaired to a variable value, if the cell was also in Cp, the score was 0.5. In essence, a llun or a variable is counted as a partially correct change. This gives an estimate of precision and recall when variables are considered as a partial match.</p><p>Since our scenarios may require a consistent number of variables, due to the need for backward repairs, and this metric disfavors variables, we also adopt a different metric, which counts all correctly identified cells. In this metric, called Metric 1.0, item (iii) above becomes: for each cell c ∈ Cr repaired to a variable value, if the cell was also in Cp, the score was 1.</p><p>Whenever an algorithm returned more than one repair for a database, we calculated P, R, and F for each repair; in the graphs, we report the maximum, minimum, and average values.</p><p>Quality Figure <ref type="figure">4</ref> shows quality and scalability results. We start by showing that LLUNATIC produces repairs of significantly higher quality with respect to those produced by previous algorithms. We ran LLUNATIC with the cost managers listed above, and the three competing algorithms on samples of the HOSPITAL dataset with increasing size (5k to 25k tuples) and increasing percentage of errors (1% to 5%). We do not report values for the LLUNATIC-FR-S50 cost manager, since they differ for less than one percentage point from those of LLUNATIC-FR-S10.</p><p>The maximum F-measure for Metric 1 is in Figure <ref type="figure">4</ref>.(a); for the two algorithms that return more than one solution, the minimum and average F-measures are reported in Figure <ref type="figure">4</ref>.(b). The maximum F-measure for Metric 0.5 is in Figure <ref type="figure">4</ref>.(c). Quality results for algorithms MIN. COST, VERTEX COVER, and REP. SAMPLING are consistent with those reported in <ref type="bibr" target="#b6">[7]</ref>, which also conducted a comparison of these three algorithms on scenarios in which left and right-hand-side repairs were necessary.</p><p>It is not surprising that the F-measure in these cases is quite low. Consider, in fact, a relation R(A, B) with FD A → B and a tuple R(a, 1); suppose the first cell is changed to introduce an error, so that the tuple becomes R(x, 1). There are many cases in which this error is not fixed by repairing algorithms. This happens, in fact, whenever the new tuple, R(x, 1), does not get involved in any conflict, and therefore the error goes undetected. In addition, even if a violation is raised, an algorithm may choose to repair the right-hand side of the dependency, thus missing the correct repair. Finally, even when a left-hand-side repair is correctly identified, algorithms have no clue about the right value for the A attribute, and may do little more than introducing a variable -a llun in our case -to fix the violation. All of these cases contribute to lower precision and recall.</p><p>The superior quality achieved by LLUNATIC variants can be explained by first noticing that algorithms capable of repairing both right and left-hand sides of dependencies obtained better results than those that only perform forward repairs. Besides LLUNATIC, the only other algorithm capable of backward repairs is SAMPLING.</p><p>However, this algorithm picks up repairs in a random way. On the contrary, LLUNATIC's chase algorithm explores the space of solutions is a more systematic way, and this explains its improvements in quality. <ref type="bibr">Figures 4.(d)</ref> reports results for the CUSTOMERS scenario. Recall that LLUNATIC is the first system that is able to handle such kind of scenarios with complex constraints. We notice that quality results are better than those on HOSPITAL; this is a consequence of the clear user-specified preference rules.</p><p>Scalability The trade-offs between quality and scalability are shown in Figures 4.(e) and 4.(f). Figure <ref type="figure">4</ref>.(e) compares execution times for the various algorithms on the HOSPITAL scenario up to 100K tuples, with 1% perturbation. Recall that LLUNATIC is the first DBMS-based implementation of a data repairing algorithm. Therefore, our implementation is somehow disfavored in this comparison. To see this, consider that, when producing repairs, mainmemory algorithms may aggressively use hash-based data structures to speed-up the computation of repairs, at the cost of using more memory. Using the DBMS, our algorithm is constrained to use SQL for accessing and repairing data; to see how this changes the cost of a repair, consider that even updating a single cell (a very quick operation when performed in main memory) when using the DBMS requires to perform an UPDATE, and therefore a SELECT to locate the right tuple.</p><p>Nevertheless, the LLUNATIC-FR-S1 cost manager scales nicely and had better performances than some of the main memory implementations. We may therefore say that graphs (c) and (e) in Figure <ref type="figure">4</ref> give us a concrete perception of the trade-offs between complexity and accuracy, and allow us to say that the LLUNATIC-FR-S1 is the best compromise for the HOSPITAL scenario. Other algorithms do not allow to fine tune this trade-off. To see an example, consider the REP. SAMPLING algorithm: we noticed that taking 1000 samples instead of 500 doubles execution times, but it does not produce significant improvements in quality.</p><p>Figure <ref type="figure">4</ref>.(f) clearly shows the benefits that come with a DBMS implementation wrt main-memory ones, namely the possibility of scaling up to very large databases. While previous works <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref> have reported results up to a few thousand tuples, we were able to investigate the performance of the system on databases of millions of tuples. The figure shows that LLUNATIC scales in both scenarios to large databases. For the HOSPITAL scenario we replicated the original dataset ten times with 1% errors. In these cases, execution times in the order of the hours for millions of tuples can be considered as a remarkable result, since no system had been able to achieve them before on problems of such exponential complexity. It is interesting to note that performances were significantly better on the CUSTOMERS scenario. This is not surprising: as we discussed above, the CUSTOMERS database contains non redundant, normalize tables. In fact, this clearly shows the benefit of a constraint language that allows to express inter-table cleaning constraints.</p><p>It is also worth noting that storing chase trees as delta databases is crucial in order to achieve such a level of scalability. Without such a representation system times would be orders of magnitude higher.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">RELATED WORK</head><p>Several classes of constraints have been proposed to characterize and improve the quality of data (see <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15]</ref> for surveys). Most relevant to this paper are the (semi-)automated repairing algorithms for these constraints <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b22">23]</ref>. These methods differ in the constraints that they admit, e.g., FDs <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>, CFDs <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b22">23]</ref>, in-clusion dependencies <ref type="bibr" target="#b7">[8]</ref>, and editing rules <ref type="bibr" target="#b17">[18]</ref>, and the underlying techniques used to improve their effectiveness and efficiency, e.g., statistical inference <ref type="bibr" target="#b9">[10]</ref>, measures of the reliability of the data <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b17">18]</ref>, and user interaction <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b24">25]</ref>.</p><p>All of these methods work for a specific class of constraints only, with the exception of <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b8">9]</ref>. These works explore the interaction among different kinds of dependencies, but they do not have a unified formal semantics with a definition of solution, neither the generality of our partial order to model preferences.</p><p>In industrial settings, most data quality related tasks are executed with ETL tools (e.g, Talend, and Informatica PowerCenter). These systems are employed for data transformations and have low-level modules for specific data quality tasks, such as verification of addresses and phone numbers. More complex operations are also partially available, but lack the support for constraints.</p><p>We do allow for forward and backward chasing. Similarly, <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b6">7]</ref> resolve violations by changing values for attributes in both the premise and conclusion of constraints. They do, however, only support a limited class of constraints. Previous works <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b6">7]</ref> have used variables in order to repair the left-hand side of dependencies. With respect to variables, our lluns are a more sophisticated tool. In our approach, the full power of lluns is achieved in conjunction with cell-groups: for each llun, the corresponding cell group provides complete provenance data for the llun, both in terms of target and source cells. Therefore, it represents an ideal support for user intervention, when the value of the llun must be resolved to some constant. In fact, lluns and cell-groups can be seen as a novel representation system <ref type="bibr" target="#b21">[22]</ref> for solutions, that stands in between of the naive tables of data exchange, and of the more expressive c-tables, trying to strike a balance between complexity and expressibility.</p><p>An approach similar to ours has been proposed in <ref type="bibr" target="#b5">[6]</ref>, with respect to a different cleaning problem. The authors concentrate on scenarios with matching dependencies and matching functions, where the main goal is to merge together values based on attribute similarities, and develop a chase-based algorithm. They show that, under proper assumptions, matching functions provide a partial order over database values, and that the partial order can be lifted to database instances and repairs. A key component of their approach is the availability of matching functions that are essentially total, i.e., they are able to merge any two comparable values. In fact, the problem they deal with can be seen as an instance of the entity-resolution problem. In this paper, we deal with the different problem of data-repairing under a large class of data-cleaning constraints, and have a more ambitious goal, i.e., to embed different forms of value preference into a general semantics for the cleaning process. Our main intuition is that the notion of a partial order is an effective way to let users specify value preferences, and to incorporate them into the semantics in a principled way. In order to do this, we have shown that reasoning on the ordering of values -as in <ref type="bibr" target="#b5">[6]</ref> -or on the ordering of single cells is not enough. On the contrary, it is necessary to devise a more sophisticated notion of a partial order for cell-groups, i.e., groups of cells that need to be repaired together and for which lineage information is maintained. Also, we do not make strong assumptions about the possibility of resolving all conflicts among values in the database, and therefore introduce lluns as a third category of values besides nulls and constants.</p><p>A comparison of the features supported by existing methods and our repairing method is given in Table <ref type="table" target="#tab_1">1</ref>. We believe that this work makes a concrete step forward towards the goal of developing a uniform formalism for data cleaning, and may stimulate further research on this subject. With a similar spirit, <ref type="bibr" target="#b10">[11]</ref> has developed a unifying view of previous approaches by abstracting different classes of constraints with respect to a different problem, that of query answering over inconsistent data.</p><p>Our framework can be seen as an extension of the data exchange setting <ref type="bibr" target="#b11">[12]</ref>. With respect to the standard chase algorithms for egds, our chase always terminates and never fails, by leveraging the partial order. We are not aware of any extension of the data exchange setting that allows the introduction of special values (like lluns) to avoid failing chase computations. In fact, we are currently extending our formalism to accommodate for mapping and cleaning scenarios, in such a way to maintain the results from the data exchange literature and enlarge them to data repairing.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Customers, Treatments and Master Data.We first illustrate the problem of specifying a set of constraints under which the target database is regarded to be clean, as follows: (a1) Standard functional dependencies (FD): d1 = (SSN, NAME → PHONE) and d2 = (SSN, NAME → CC#) on table CUS-TOMERS. The pair of tuples {t2, t3} in the target database violates both d1 and d2; the database is thus dirty.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>C) the value that is (i) either the least upper bound for values of all cells in C according to Π I ,J , if it exists; (ii) a new value Ni not in J, if all cells in C have null values; (iii) a new llun value Lj otherwise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 7 [</head><label>7</label><figDesc>EQUIVALENCE CLASS] Given a repair Rep, and an egd e : ∀x (φ(x) → x = x ), let xw ⊆ x be the witness variables of e. An equivalence class for Rep and e, H, is a set of homomorphisms of φ(x) into I, Rep(J) such that all hi ∈ H have equal witness values hi(xw).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>e8 in Example 1, and the equivalence class associated with witness ssn = 222. The cell groups for the conclusion cells are: g = 10K → {t4.SALARY}, by ∅ and g = 25K → {t5.SALARY}, by ∅ . Notice that the two cell groups are incomparable, and therefore we have a violation. The chase procedure generates three different repairs for the violation: (a) the forward repair is: Rep f,f = 25K → {t4.SALARY, t5.SALARY}, by ∅ (25K is more recent than 10K as a salary, and therefore it is preferred); as you can see, the least upper bound is constructed in such a way that it contains the union of occurrences and the union of justifications of the two conflicting groups; (b) the first backward repair, which changes the first occurrence of the witness variable ssn to a llun L1: Rep b,f = L1 → {t4.SSN}, by ∅ ; (c) the second backward repair, changing the second occurrence of ssn to L2: Rep f,b = L2 → {t5.SSN}, by ∅ . Definition 9 [CHASE TREE] Given a cleaning scenario CS = {S, T , Σ, Π}, a chase of I , J with Σ is a tree whose root is I , J , i.e., the empty repair, and for each node Rep, the children of Rep are the repairs Rep 0 , Rep 1 , . . . , Rep n such that, for some e ∈ Σ and some H, it is the case that Rep →e,H Rep 0 , Rep 1 , . . . , Rep n .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Max F-Measure for the CUSTOMERS Scenario (e) HOSPITAL Execution Times (sec) (f) Large Datasets Execution Times (sec)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Feature Comparison. the ones in Figures2 and 3, where Li values represent lluns (confidence values have been omitted); notice that other minimal solutions exist for this example. Cost managers allow users to differentiate between these two solutions, which have completely different costs in terms of chase computation, and ultimately to fine-tune the tradeoff between quality and scalability of the repair process.</figDesc><table><row><cell>1, our semantics generates minimal solutions as</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>by ∅ g2 : F.Lennon → {t2.NAME, t3.NAME}, by {tm.NAME} g3 : 122-1876 → {t2.PHN, t3.PHN}, by ∅ g4 : Sky Dr. → {t2.STR, t3.STR}, by {tm.STR}</figDesc><table /><note><p>g5 : Dental → {t5.TREAT}, by {tc 3 .TREAT} g6 : SF → {t1.CITY}, by {tc 7 .CITY} } g7 : 25K → {t4.SALARY, t5.SALARY}, by ∅ }</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>t2.B}, by {tc1.x} → {t1.B, t2.B}, by {tc1.x, tc2.y} Partial order on repairs. Given an instance I , J , a partial order Π over cell groups in I , J , and two complete repairs, Rep, Rep , we say that Rep upgrades Rep, denoted by Rep Π Rep , if for each group g ∈ Rep there exists a group g ∈ Rep such that g Π g . If Rep Π Rep and the converse does not hold, then we write Rep ≺ Π Rep . A repair Rep is thus preferable to Rep whenever Rep Π Rep</figDesc><table /><note><p><p>Π</p>L</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Definition 8 [CHASE STEP] Given a cleaning scenario CS = {S, T , Σ, Π}, and a complete repair Rep of J, let e : ∀x (φ(x) → x = x ) be an egd in Σ, applicable to I, Rep(J) with H. For each repair strategy rsH, a chase step generates a new repair Rep rs H defined as follows: (i) to start, we initialize Rep rs Rep ( w-cellrs H (ci)) by the cell group g i that is an immediate successor of gi according to Π as follows: Rep rs H = Rep rs H -{gi} ∪ {g i } Note that such a successor always exists. Indeed, g i = Li → occ(gi), by ∅ , where Li is a new LLUN value, is a successor of gi. Given Rep, each repair strategy rs i H for H generates a different step, Rep rs i H . We simultaneously consider all these chase steps, in parallel, and write Rep →e,H Rep rs 0</figDesc><table><row><cell>H</cell><cell>, Rep rs 1 H</cell><cell>. . . , Rep rs n</cell></row></table><note><p><p><p>H = Rep (ii) then, we replace all forward groups by their least upper bound:</p>Rep rs H = Rep rs H -forw-g rs H ∪ lub Π (forw-g rs H )</p>(iii) finally, we add the backward repairs, i.e, for each backward group g ∈ back-g rs H , and cell ci ∈ occ(g), we replace gi = g</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Definition 11 [DELTA DATABASE] Given a target database schema R = {R1, . . . , R k }, a delta database for R contains the following tables: (i) a delta table Ri Aj with attributes (t id , stepId, value), for each Ri and each attribute Aj of Ri; (ii) a table occurrences, with schema (stepId, value, t id , table, attr); (iii) a table justifications, with schema (stepId, value, t id , table, attr).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Datasets and Scenarios. We selected two scenarios. (i) The first one, HOSPITAL, is based on a dataset from US Department of Health &amp; Human Services (http://www.medicare.gov/hospitalcompare/). The database contains a single table with 100K tuples and 19 attributes, over which we specified 9 functional dependencies. (ii)</figDesc><table><row><cell></cell><cell>LLUNATIC-FR-S1</cell><cell>LLUNATIC-FR-S10</cell><cell cols="3">LLUNATIC-FR-S50</cell><cell cols="3">LLUNATIC-FR-S1-FO</cell><cell></cell><cell cols="2">SAMPLING-500</cell><cell>VERTEX COVER</cell><cell>MIN. COST</cell></row><row><cell>0.8</cell><cell></cell><cell>0.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.6</cell></row><row><cell>0.6 0.7</cell><cell></cell><cell>0.7 0.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>AVG MIN</cell><cell>0.5</cell></row><row><cell>0.5</cell><cell></cell><cell>0.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.4</cell></row><row><cell>0.3 0.4</cell><cell></cell><cell>0.3 0.4</cell><cell></cell><cell>AVG</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.3</cell></row><row><cell>0.2</cell><cell></cell><cell>0.2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.2</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>MIN</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0.1</cell><cell></cell><cell>0.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.1</cell></row><row><cell></cell><cell cols="2">1% 2% 3% 4% 5% 1% 2% 3% 4% 5% 1% 2% 3% 4% 5%</cell><cell></cell><cell cols="6">1% 2% 3% 4% 5% 1% 2% 3% 4% 5% 1% 2% 3% 4% 5%</cell><cell></cell><cell>1% 2% 3% 4% 5% 1% 2% 3% 4% 5% 1% 2% 3% 4% 5%</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>5k</cell><cell></cell><cell>10k</cell><cell></cell><cell>25k</cell><cell></cell><cell></cell><cell>5k</cell><cell>10k</cell><cell>25k</cell></row><row><cell>0.8</cell><cell></cell><cell cols="2">2000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>CUSTOMERS</cell><cell>HOSPITAL</cell></row><row><cell></cell><cell>METRIC 1</cell><cell>METRIC 1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>HOSPITAL</cell></row><row><cell>0.7</cell><cell></cell><cell cols="2">1500</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0.6</cell><cell></cell><cell cols="2">1000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>METRIC 0.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>METRIC 0.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0.5</cell><cell></cell><cell cols="2">500</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>CUSTOMERS</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>CUSTOMERS</cell></row><row><cell>0.4</cell><cell cols="2">5k 1% 2% 3% 4% 5% 1% 2% 3% 4% 5% 1% 2% 3% 4% 5% 10k 25k</cell><cell>0</cell><cell>0 0</cell><cell>20 20K</cell><cell>40 40K</cell><cell>60 60K</cell><cell>80 80K</cell><cell cols="2">100 100K</cell><cell>100K 250K 400K 550K 700K</cell><cell>850K 1M</cell></row><row><cell></cell><cell></cell><cell cols="10">Figure 4: Experimental results for HOSPITAL and CUSTOMERS.</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast and Simple Relational Processing of Uncertain Data</title>
		<author>
			<persName><forename type="first">L</forename><surname>Antova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Olteanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="983" to="992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Consistent Query Answers in Inconsistent Databases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chomicki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="68" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Proof Procedure for Data Dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="718" to="741" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Database Repairing and Consistent Query Answering</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bertossi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Morgan &amp; Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Data Cleaning and Query Answering with Matching Dependencies and Matching Functions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kolahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lakshmanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="268" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Sampling the repairs of functional dependency violations under hard constraints</title>
		<author>
			<persName><forename type="first">G</forename><surname>Beskales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Golab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="197" to="207" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A cost-based model and effective heuristic for repairing constraints by value modification</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Flaster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rastogi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="143" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Holistic Data Cleaning: Putting Violations into Context</title>
		<author>
			<persName><forename type="first">X</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Papotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Improving data quality: Consistency and accuracy</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="315" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Repair Localization for Query Answering from Inconsistent Databases</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Greco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="51" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Data Exchange: Semantics and Query Answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dependencies Revisited for Improving Data Quality</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="159" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Dynamic constraints for record matching</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="495" to="520" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Foundations of Data Quality Management</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Geerts</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Morgan &amp; Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Conditional Functional Dependencies for Capturing Data Inconsistencies</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>ACM TODS</publisher>
			<biblScope unit="volume">33</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Determining the Currency of Data</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wijsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="71" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Towards certain fixes with editing rules and master data</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="173" to="184" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Interaction Between Record Matching and Data Repairing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="469" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Querying and Repairing Inconsistent Numerical Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Flesca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Furfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Parisi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="page" from="1" to="77" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Logical Framework for Querying and Repairing Inconsistent Databases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Greco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Greco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Zumpano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDE</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1389" to="1408" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Incomplete Information in Relational Databases</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imieliński</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On Approximating Optimum Repairs for Functional Dependency Violations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kolahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Master Data Management</title>
		<author>
			<persName><forename type="first">D</forename><surname>Loshin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Knowl. Integrity, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><surname>Yakout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Neville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ouzzani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Guided data repair</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="279" to="289" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
