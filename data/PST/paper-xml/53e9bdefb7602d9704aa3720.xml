<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Processing of XML Twig Patterns with Parent Child Edges: A Look-ahead Approach</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jiaheng</forename><surname>Lu</surname></persName>
							<email>lujiahen@comp.nus.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<addrLine>3 Science Drive 2</addrLine>
									<postCode>117543</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ting</forename><surname>Chen</surname></persName>
							<email>chent@comp.nus.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<addrLine>3 Science Drive 2</addrLine>
									<postCode>117543</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tok</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<addrLine>3 Science Drive 2</addrLine>
									<postCode>117543</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Processing of XML Twig Patterns with Parent Child Edges: A Look-ahead Approach</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">16E2E4F29D99C3DB2FD32E5C9E63E337</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.4 [Database Management]: [Systems-query processing] Algorithm</term>
					<term>Performance XML</term>
					<term>Holistic twig pattern matching</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>With the growing importance of semi-structure data in information exchange, much research has been done to provide an effective mechanism to match a twig query in an XML database. A number of algorithms have been proposed recently to process a twig query holistically. Those algorithms are quite efficient for quires with only ancestor-descendant edges. But for queries with mixed ancestor-descendant and parent-child edges, the previous approaches still may produce large intermediate results, even when the input and output size are more manageable. To overcome this limitation, in this paper, we propose a novel holistic twig join algorithm, namely T wigStackList. Our main technique is to look-ahead read some elements in input data steams and cache limited number of them to lists in the main memory. The number of elements in any list is bounded by the length of the longest path in the XML document. We show that TwigStackList is I/O optimal for queries with only ancestor-descendant relationships below branching nodes. Further, even when queries contain parent-child relationship below branching nodes, the set of intermediate results in T wigStackList is guaranteed to be a subset of that in previous algorithms. We complement our experimental results on a range of real and synthetic data to show the significant superiority of T wigStackList over previous algorithms for queries with parent-child relationships.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>XML is emerging as a de f acto standard for information exchange over the Internet. Although XML documents could have rather complex internal structures, they can generally be modelled as ordered trees. In most XML query languages (see, e.g. <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b3">3]</ref>), the structures of XML documents are expressed by twig (i.e. a small tree) patterns, while the values of XML elements are used as part of selection predicates. Finding all occurrences of a twig pattern in an XML database is a core operation in XML query processing, both in relational implementations of XML databases and in native XML databases <ref type="bibr" target="#b5">[5]</ref>. In the past few years, many algorithms <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">17]</ref> proposed in the literature are based on a form of labeling scheme that encodes each element in an XML database by its positional information.</p><p>In order to answer a query twig pattern, these algorithms access the labels alone without traversing the original XML documents</p><p>In particular, Al-Khalifa et al. <ref type="bibr" target="#b1">[1]</ref> propose to decompose the twig pattern into many binary relationships, and then use T ree-merge or Stack-tree algorithms to match the binary relationships, and finally stitch together basic matches to get the final results. The main disadvantage of such a decomposition based approach is that intermediate result sizes can get very large, even when the input and the final result sizes are much more manageable. To address the problem, Bruno et al. <ref type="bibr" target="#b5">[5]</ref> propose a holistic twig join algorithm, namely T wigStack. With a chain of linked stacks to compactly represent partial results of individual query root-to-leaf paths, their approach is I/O and CPU optimal among all sequential algorithms that read the entire input for twigs with only ancestor-descendant edges.</p><p>The work reported in this paper is motivated by the following observation: although T wigStack has been proved to be I/O optimal in terms of input and output sizes for queries with only ancestor-descendant edges, their algorithms still cannot control the size of intermediate results for queries with parent-child edges. To get the better understanding of this limitation, we experimented with TreeBank dataset which was downloaded from University of Washington XML repository <ref type="bibr">[16]</ref>. We use three twig queries patterns(as shown in Table <ref type="table" target="#tab_0">1</ref>), each of which contains at least one parent-child edge. T wigStack operates two steps:(i) a list of intermediate path solutions is output as intermediate results;(ii) the intermediate path solutions in the first step are merge-joined to produce the final solutions. Table <ref type="table" target="#tab_0">1</ref> shows the numbers of intermediate path solutions output in the first step and the merge-joinable paths among them in the second step. An immediate observation from the table is that T wigStack output too many partial paths that are not merge-joinable. For all three queries, more than 95% partial paths produced by T wigStack in the first step are "useless" to final answers. Thus, our experiment shows that it is a big challenge to improve the previous algorithms to answer queries with parent-child edges. In this paper, we propose a new holistic twig join algorithm, which has the same performance as T wigStack for query patterns with only ancestor-descendant edges, but it is significantly more efficient than T wigStack for queries with the presence of parent-child edges. In particular, we propose Algorithm T wigStackList to match query twig patterns. The main technique of T wigStackList is to make use of two data structures: stack and list for each node in query twigs. A chain of linked stacks is used to compactly represent partial results of individual query root-leaf paths. We look-ahead read some elements in input data streams and cache limited number of them in the list. The number of elements in any list is bounded by the length of the longest path in the XML document. The elements in lists help us to determine whether an element possibly contributes to final answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Query</head><p>Our contribution can be summarized as follows:</p><p>• We propose a novel holistic twig join algorithm, namely T wigStackList. When all edges below branching nodes in the query pattern are ancestor-descendant relationships, the I/O cost of our algorithm is only proportional to the sum of sizes of the input and the final output. In other words, unlike previous algorithms, our algorithm can guarantee the I/O optimality even for queries with parent-child relationships below nonbranching nodes. This improved result mainly owe to the look-ahead technique of our algorithm.</p><p>• Furthermore, even when there exist parent-child relationships below branching nodes, we show that the intermediate solutions output by T wigStackList are guaranteed to be a subset of that by the previous algorithms.</p><p>• We present experimental results on a range of real and synthetic data, and query twig patterns. Our experiments validate our analysis results and show the superiority of T wigStackList over previous algorithms.</p><p>The rest of the paper proceeds as follows. We first discuss the previous algorithm and show our intuitive observation in Section 2. The novel algorithm T wigStackList is presented in Section 3. We report the experimental results in Section 4. Section 5 is dedicated to the related work and Section 6 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Data model and twig pattern query</head><p>XML data is commonly modelled by a tree structure, where nodes represent elements, attributes and texts, and parent-child edges represent element-subelement, elementattribute and element-text pairs. Most existing XML query processing algorithms <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b14">14]</ref> use a region code (start, end, level ) to present the position of a tree node in the data tree. The region encodings support efficient evaluation of structural relationships. Formally, element u is an ancestor of element v if and only if u.start &lt;v.start &lt;u.end. For parent-child relationship, we also check whether u.level =v.level -1.</p><p>Queries in XML query languages make use of twig patterns to match relevant portions of data in an XML database. Twig pattern nodes may be elements, attributes and texts. Twig pattern edges are either parent-child relationships (denoted by "/") or ancestor-descendant relationships (denoted by "//"). If the number of children of a node is greater than one, then we call this node a branching node. Otherwise, when the node has only one child, it is a non-branching node.</p><p>Given a twig pattern T and an XML database D, a match of T in D is identified by a mapping from nodes in T to elements in D, such that: (i) query node predicates are satisfied by the corresponding database elements; and (ii) the parentchild and ancestor-descendant relationships between query nodes are satisfied by the corresponding database elements. The answer to query T with m nodes can be represented as a list of m-ary tuples, where each tuple (t1,...,tm) consists of the database elements that identify a distinct match of T in D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">TwigStack and our observation</head><p>Bruno et al. <ref type="bibr" target="#b5">[5]</ref> propose a novel holistic twig join algorithm called T wigStack to match XML twig patterns. They use a chain of linked stacks to compactly represent partial results of individual query root-to-leaf paths. In particular, T wigStack operates two phases as follows.</p><p>1. Output path solutions A list of root-leaf path solutions is output as intermediate path solutions. Each root-leaf solution matches the corresponding path pattern in the query pattern.</p><p>2. Merge All lists of path solutions in the first phase are merged to produce the final answer to the whole query twig pattern When all edges in query patterns are ancestor-descendant (A-D) relationships, T wigStack ensures that each root-leaf solution in the first phase is merge-joinable with at least one solution to each of the other root-leaf query paths. Thus, none of those path solutions is redundant. However, this property does not hold if there is a parent-child (P-C) edge in the query pattern.</p><p>To see an example, if we evaluate the twig pattern in Figure <ref type="figure" target="#fig_1">1</ref>(a) on the XML document in Figure <ref type="figure" target="#fig_1">1</ref>(b), T wigStack will push a1 into the stack and output all root-leaf path solutions: (a1,b1,c1), (a1,b1,c2),...,(a1,bn-1,cn), (a1,bn,cn), because they match path a//b//c. Notice that in this example, there is no match at all! But T wigStack output 4n "useless" intermediate path solutions. Since the size of intermediate path solutions has a great impact on the performance  The main problem of T wigStack is that it only considers ancestor-descendant property between nodes in the first phase. The level information of nodes, on the other hand, is not sufficiently exploited. As an illustration, see the query and data in Figure <ref type="figure" target="#fig_1">1</ref>(a) and (b) again. Since &lt; a, d &gt; edge in the twig pattern is the parent-child relationship, node a1 in the document contributes to the final answer only if a1 has a child with name d. But T wigStack pushes a1 into the stack only because a1 has a descendant (not a child ) with tag d. Thus, this algorithm outputs a large size of intermediate paths. However, our method pushes a1 into the stack only if a1 or its descendant(with tag a) has a child with name d. In the document of <ref type="bibr">Fig 1 (b)</ref>, although a1 has many descendants with tag d, none of them has a child with tag d. Thus, our method does not push a1 into the stack and thereby avoid outputting the "useless" intermediate path solutions.</p><p>In the following, we extend the intuition in the above example and propose a new holistic twig matching algorithm, which is able to produce much less intermediate path solutions than T wigStack for queries with parent-child relationships.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">TWIG JOIN ALGORITHM</head><p>In this section, we present T wigStackList, a new efficient algorithm for finding all matches of a query twig pattern against an XML document. We start this section with introducing some notations and data structures which will be used by T wigStackList.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Notation and data structures</head><p>A query twig pattern can be represented with a tree. The self-explaining function isRoot(n) and isLeaf (n) examine whether a query node n is a root or a leaf node. The function children(n) gets all child nodes of n, and P CRchildren(n), ADRchildren(n) returns child nodes which has the parentchild or ancestor-descendant relationship with n in the query twig pattern, respectively. That is, P CRchildren(n) ADRchildren(n) = children(n). In the rest of the paper, "node" refers to a tree node in the twig pattern (e.g. node n), while "element" refers to an element in the data set involved in a twig join (e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>element e).</head><p>There is a data stream Tn associated with each node n in the query twig. We use Cn to point to the current element in Tn. Function end(Cn) tests whether Cn is at the end of Our join algorithm will make use of two types of data structure: list and stack. Given a query twig, we associate a list Ln and a stack Sn for each node n in the twig, as shown in Figure <ref type="figure" target="#fig_2">2</ref>.</p><p>The use of stack in our algorithm is similar to that in T wigStack. That is, each data node in the stack consists of a pair: (positional representation of an element from Tn , pointer to an element in S parent(n) ). The operations over stack are: empty, pop, push, topStart, topEnd. The last two operations return the start and end attributes of the top element in the stack, respectively. At every point during computation: (i) the node in stack Sn (from bottom to top) are guaranteed to lie on a root-leaf path in the XML database (ii) the set of stacks contain a compact encoding of partial and total answers to the query twig pattern.</p><p>For each list Ln, we declare an integer variable say pn, as a cursor to point to an element in the list Ln. We use Ln.elementAt(pn) to denote the element pointed by pn. We can access the attribute values of Ln.elementAt(pn) by Ln.elementAt(pn).start, Ln.elementAt(pn).end and Ln.elementAt(pn).level. At every point during computation: elements in each list Ln are strictly nested from the first to the end, i.e. each element is an ancestor of the element following it. The operations over list Ln are delete(pn) and append(e). The first operation delete Ln.elementAt(pn) in list Ln and the last operation appends element e at the end of Ln .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">TwigStackList</head><p>Algorithm T wigStackList, which computes answers to a query twig pattern, is presented in Algorithm 2. This algorithm operates in two phases. In the first phase (line 1-11), it repeatedly calls the getNext algorithm with the query root as the parameter to get the next node for processing. We output solutions to individual query root-to-leaf paths in this phase. In the second phase (line 12), these solutions are merge-joined to compute the answer to the whole query twig pattern.</p><p>In Section 3.2.1, we explain the getNext algorithm and Section 3.2.2 presents the main algorithm in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">getNext algorithm</head><p>getNext(n) is a procedure called in the main algorithm of T wigStackList. It returns a node n (possibly n = n) with three properties : assume that element e n =getElement(n ),  <ref type="figure" target="#fig_3">4</ref>). Otherwise, we will try to locate a child of n which satisfies the above three properties. Line 6 and 7 get the max and min elements for the current head elements in lists or streams, respectively. Line 8 skips elements that do not contribute to results. If no common ancestor for all Cn i is found, line 9 returns the child node with the smallest start value, i.e. gmin .</p><formula xml:id="formula_0">Algorithm 1 getNext(n) 1: if isLeaf (n) return n 2: for all node ni in children(n) do 3: gi = getNext(ni) 4: if (gi = ni) return gi 5: end for 6: nmax = maxarg n i ∈children(n) getStart(ni) 7: nmin = minarg n i ∈children(n) getStart(ni) 8: while ( getEnd(n) &lt; getStart(nmax)) proceed(n) 9: if ( getStart(n) &gt; getStart(nmin))</formula><p>Line 10 is an important step. Here we look-ahead read some elements in the stream Tn and cache elements that are ancestors of Cn max into the list Ln. Whenever any element ni cannot find its parent in list Ln for ni ∈ children(n), algorithm getNext returns node ni (in line 17). Note that this step manifests the key difference between T wigStackList and the previous algorithms (i.e. T wigStack ) . In this scenario, the previous ones return n instead of ni , which may results in many "useless" intermediate paths. But our algorithm adopt a clever strategy: return ni that has no parent in list Ln, since we make sure that ni does not contribute to final results involved with the elements in the remaining parts of streams. Finally, if n is not a branching node, in line 14, we need to move the cursor in the list Ln to point to the parent of getElement(ni).</p><p>The main difference between two getNext algorithms in T wigStack and T wigStackList can be summarized as follows. In T wigStack, getNext(n) return n if the head element e n in stream T n has a descendant en i in each stream Tn i , for ni ∈ children(n ) (which is the same as the first property as mentioned above), but T wigStackList needs n to satisfy three properties, as illustrated as follows.</p><p>Example 1. Consider a query twig pattern a[/b]/c on a data set visualized in Figure <ref type="figure">3</ref>. A subscript is added to each element in the order of their start values for easy reference. Initially, the three elements are (a1,b1,c1). The first call of getNext(root) returns node c, because element c1 cannot find parent with tag a in the path from a1 to it. But in this scenario, the first call of getNext(root) of T wigStack would return a1, since a1 has two descendants b1 and c1 in stream b and c respectively. Because T wigStack return a1 instead of c1, in the main algorithm, T wigStack will output the useless path solution &lt; a1, b1 &gt;. Further, the second call of getNext(root) in T wigStackList returns b1. In addition, the cursor of node a is forwarded to a2. Right before the third call, T wigStackList reach a cursor setup (a2, b2, c2), which is actually the match of the query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Main Algorithm</head><p>Algorithm 2 shows the main algorithm of T wigStackList. It repeatedly calls getNext(root) to get the next node n to process, as described next.</p><p>First of all, line 2 calls getNext algorithm to identify the 1: while (¬empty(Sn) (topEnd(Sn) &lt; actEnd)) do 2: pop(Sn) 3: end while node nact to be processed. Line 4 and 7 remove partial answers from the stacks of parent(nact) and nact that cannot be extended to total answer. If n is not a leaf node, we push element getElement(nact) into Sn act (line 8); otherwise (line 10), all path solution involving getElement(nact) can be output. Note that path solutions should be output in root-leaf order so that they can be easily merged together to form final twig matches (line 17). As a result, we may need to block some path solutions during output. Interested readers may refer to T wigStack <ref type="bibr" target="#b4">[4]</ref> to know more details about blocking technique.</p><p>It is not correct to merge cleanParentStack and cleanSelf-Stack into one procedure cleanStack as Figure <ref type="figure" target="#fig_3">4</ref>. Consider a twig query a[//b//c]/d and a document in Figure <ref type="figure">5</ref>. Suppose the four elements are initially at (a1,b1,c1,d1). At the first call of getNext, node a is returned. At this point, note that the current element pointed by cursor p b in list L b is b2, instead of b1 (recall, line 14 in Algorithm 1). Then the next two calls of getNext return b,c once to consume b1 and c1. After that, the current elements are (b1,c2,d1) (stream a has finished). The next call of getNext will return node b again. Here, if we used the algorithm shown in Figure <ref type="figure" target="#fig_3">4</ref>, then b2 would not be popped from stack. Then, the property of stack (i.e. the upper element should be the descendant of the lower one) would not be hold.   Initially, the first call of getNext in T wigStack and T wigStackList return node a. After the second call of getNext, (a1,b1) is output as intermediate results in both T wigStack and T wigStackList. Subsequently, the third call of getNext in T wigStack returns node a again. But the third call of getNext in T wigStackList returns node b, since b2 has not the parent in the stream Ta . Thus, unlike T wigStack, T wigStackList does not output the intermediate result (a2,d1) and (a2,d2), which do not contribute to any final answers. ✷ Example 2 illustrates the fact that, in T wigStackList, when twig patterns contain only ancestor-descendant relationships below branching nodes, each solution to individual query root-leaf path is guaranteed to be merge-joinable with at least one solution to each of the other root-leaf paths. On the other hand, Example 3 illustrates another fact that even if there exist parent-child relationships below branching nodes, T wigStackList is still superior to T wigStack in that it output less useless intermediate solutions.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Analysis of TwigStackList</head><p>In this section, we discuss the correctness of Algorithm T wigStackList, and then we analyze its complexity. Finally, we compare T wigStackList with T wigStack in terms of the size of intermediate results.</p><p>Definition 1. (head element en ) In T wigStackList, for each node n in the query twig pattern, if the list Ln is not empty, then we say that the element indicated by the cursor pn of Ln is the head element of n, denoted by en. Otherwise, we say that element Cn in the stream Tn is the head element of n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. (child and descendant Extension)</head><p>We say that a node n has the child and descendant extension if the following three properties hold:</p><p>1. for each ni ∈ ADRchildren(n), there is an element en i (with tag ni ) which is a descendant of en, and;</p><p>2. for each ni ∈ P CRchildren(n), there is an element ei ( with tag n) in the path from en to en max such that ei is the parent of en i , where en max has the maximal start attribute value for all head elements of child nodes of n; and 3. each of children of n has the child and descendant extension.</p><p>The above two definitions are important to establish the correctness of the following lemma.</p><p>Lemma 1 Suppose that for an arbitrary node n in the twig query we have getNext(n) = n . Then the following properties hold:</p><p>• n has the child and descendant extension.</p><p>• Either (a) n = n or (b) parent(n) does not have the child and descendant extension because of n (and possibly a descendant of n ).</p><p>Using Lemma 1, we can prove the following lemma.</p><p>Lemma 2. Suppose getNext(n) = n returns a query node n (n = n) in the line 17 of Algorithm getNext. If the stack is empty, then the head element does not contribute to any final solutions.</p><p>Proof(Sketch): Suppose that on the contrary, there is a solution using the head element. In line 10 of algorithm getNext, we insert all elements with the name parent(n ) which are in the path from e parent(n ) to en max into the list L parent(n ) . According to line 12, if the parent of e n is not in L parent(n ) , then using our hypothesis, we know that parent(e n ) also participate in the final solution. But using Lemma 1, we see that this is a contradiction, since the start attribute of parent(e n ) is less than that of e parent(n ) and the stack S parent(n ) is empty. ✷ Lemma 3. At every point during computation of Algorithm T wigStackList: elements in each stack Sn are strictly nested, i.e. each element is a descendant of the element below it.</p><p>Proof: This lemma is obvious in the previous T wigStack. But since algorithm T wigStackList may change the cursor of the list, this lemma is nontrivial. In T wigStackList, we can insert elements into the stack only in Procedure moveT oStack. There are four cases for relationship between the new element enew to be pushed into stack and the existing top element etop in stack(see Figure <ref type="figure" target="#fig_7">7</ref>). Case(i): Since etop.end &lt; enew.end, the element etop will be popped in Procedure cleanSelf Stack . So this case is impossible. Case(ii): In this case, enew will be added into the stack safely. Case(iii): Similar to case (i), since etop.end &lt; enew.end, the element etop will be popped. We also ensure that etop cannot participate in final answers any longer. Case(iv): This case is impossible. Because, in algorithm T wigStackList , we can change the cursor of a list only in line 14 of getNext. The new element indicated by the cursor is guaranteed to be a descendant of the previous one. Therefore, this lemma holds in all cases. ✷ Lemma 4. In T wigStackList, any element that is popped from the stack Sn does not participate in any new solution any more.</p><p>Proof: Any element is popped from stack Sn in either Procedure cleanP arentStack or cleanSelf Stack. In the following, we prove the correctness of the lemma in these two cases respectively.</p><p>• In cleanP arentStack, suppose on the contrary, there is a new solution involving the popped element epop.</p><p>According to line 1 of cleanP arentStack, epop.end &lt; actStart, where actStart is the start attribute of the head element of parent(n) (i.e. e parent(n) ). Using the containment property, epop cannot be contained by any element in the path from the root to e parent(n) and after e parent(n) , which is a contradiction.</p><p>• In cleanSelf Stack, using the containment property, we see that cleanSelf Stack pops elements that are descendants of en , where en is the head element of node n. The popped element does not participate in new answers any more. This is because, at this point, n has only one child with parent-child relationship. Thus, the start value of any child of epop is less than that of the head element of node children(n). Thus, there is no element that is a child of epop in the remaining portion of the stream T child(n) . Therefore, epop does not participate in any new solutions. ✷ Theorem 1. Given a query twig pattern q and an XML database D, Algorithm T wigStackList correctly returns all answers for q on D.  Proof(Sketch): We prove Theorem 1. Using Lemma 2, we know that when getNext returns a query node n in the line 17 of getNext, if the stack S parent(n) is empty, then the head element en does not contribute to any final solutions. Thus, any element in the ancestors of n that use en in the descendant and child extension is returned by getNext before en . By using Lemma 3 and Lemma 4, we can maintain, for each node n in the query, the elements that involve in the root-leaf path solution in the stack Sn. Finally, each time that n = getNext(root) is a leaf node, we output all solutions that use en. ✷ While correctness holds for query twig patterns with both ancestor-descendant and parent-child relationships in any edges, we can prove optimality only for the case where parentchild relationships appear only in edges below non-branching nodes. The intuition is that we push into stacks only elements that have the child and descendant extension. If there is a parent-child relationship below the non-branching node, according to Lemma 1, we are guaranteed that en is pushed into stack only if en has a child element in the stream T child(n) . Therefore, we have the following result.</p><p>Theorem 2. Consider a query twig pattern with m nodes, and there are only ancestor-descendant relationships below branching nodes (in other words, this pattern may have parent-child relationships below non-branching nodes), and an XML database D. Algorithm T wigStackList has the worst-case I/O complexities linear in the sum of sizes of the m input lists and the output list. ✷ Since the worst-case size of any stack and list in TwigStack-List is proportional to the maximal length of a root-leaf path in the XML database, we have the following results about the space complexity of T wigStackList. Theorem 3. Consider a query twig pattern with m nodes and an XML database D. The worst-case space complexity of algorithm T wigStackList is proportional to m times the maximal length of a root-leaf path in D.</p><p>It is particularly important to note that, even for the case where query patterns contain parent-child relationships below branching nodes, as shown in our experimental results in Section 4, algorithm T wigStackList usually output much less intermediate path solutions than T wigStack. The reason is simple. T wigStackList pushes any element into stack that has both descendant and child extension, but T wigStack pushes any element that has only the descendant extension into the stack. Therefore, T wigStackList pushes fewer elements that do not contribute to final answers to the stack and thereby output less intermediate results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXPERIMENTAL EVALUATION</head><p>In this section we present experimental results on the performance of the twig pattern matching algorithms, namely T wigStackList and T wigStack, with both real and synthetic data. We evaluated the performance of these algorithms using the following metrics:</p><p>1. Number of partial solutions. This metric measures the total number of partial path solutions, which reflects the ability of the algorithms T wigStackList and T wigStack to control the size of intermediate results for different kinds of query twig patterns.</p><p>2. Running time. The running time of an algorithm is obtained by averaging the running times of several consecutive runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experimental Setting</head><p>We implemented all algorithms in JDK 1.4. All our experiments were performed on 1.7GHz Pentium 4 processor with 768MB RAM running on windows XP system. We used the following three real-world and synthetic data sets for our experiments:</p><formula xml:id="formula_1">• TreeBank.</formula><p>We obtained the TreeBank data set from the University of Washington XML repository <ref type="bibr">[16]</ref>. The document in the TreeBank is deep and has many recursions of element names. The data set has the maximal depth 36 and more than 2.4 million nodes.</p><p>• DTD data set. We used the following simple DTD to create highly and less nested data trees: a → bc|cb|d; c → a; where a and c are non-terminals and b and d are terminals. We generated about 114M bytes raw XML data according to this DTD. The maximal depth of each data tree varied from 3-30.</p><p>• Random. We generated random data trees using two parameters: fan-out, depth. The fan-out of nodes in data trees varied in the range of 2-100. The depths of data trees varied from 10-100. We use seven different labels, namely: a,b,c,d,e,f ,g, to generate the data sets. The node labels in the trees were uniformly distributed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">TwigStackList Vs TwigStack</head><p>We compare algorithm T wigStackList against T wigStack with different twig pattern queries over above three data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">TreeBank</head><p>We first used the queries shown in Table <ref type="table" target="#tab_5">2</ref> over the realworld Treebank data. These queries have different twig structures and different distribution of ancestor-descendant (A-D) and parent-child (P-C) edges. In particular, all edges in Q1 are A-D relationships, while all edges in Q2,Q6 are P-C relationships. In Q3,Q5, all edges below branching nodes are A-D relationships, but in Q4, edges below branching nodes contain both A-D and P-C relationships. We choose these different queries so that we can give a comprehensive comparison between Algorithm T wigStackList and T wigStack.   <ref type="table" target="#tab_6">3</ref> shows the number of partial solutions, where the fourth column is the number of merge-joinable path that can contribute to at least one final answer. From the table and figure, we have several observations and conclusions:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Query</head><p>• When the query twig pattern contains only ancestordescendent edges, both T wigStackList and T wigStack are I/O optimal in that each of path solutions can contribute to final answers(see Q1 in Table <ref type="table" target="#tab_6">3</ref>). Thus, in this case, both algorithms have very similar performance( see Q1 in • When all edges below branching nodes contain only ancestor-descendant relationships, T wigStackList is still I/O optimal, but T wigStack has not the nice property. For example, see Q3 in Table <ref type="table" target="#tab_6">3</ref>. The numbers of intermediate path solution in T wigStack is 25892, while T wigStackList produces only 4612 solutions. Considering the number of merge-joinable path is also 4612, each of path solutions in T wigStackList contributes to final answers.</p><p>• When edges below branching nodes contain any parentchild relationship, both algorithms T wigStackList and T wigStack are suboptimal (see Q2,Q4,Q6 in Table <ref type="table" target="#tab_6">3</ref>). But in this case, we observed that the number of intermediate paths produced by T wigStackList is significantly less than that by T wigStack. For example, in queries Q4 and Q6, T wigStack produced 10663 and 70988 intermediate paths, while T wigStackList only produce 11 and 30 solutions. About 99% partial solutions of T wigStack are pruned by T wigStackList. Therefore, the execution time of T wigStack is considerably slower than that of T wigStackList for these queries.</p><p>In summary, Algorithm T wigStackList performs better than T wigStack for query twig patterns with parent-child edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">DTD data set</head><p>We then used the query a[//c]//b/d over different synthetically generated data sets. Note that in this query, all edges below the branching node are ancestor-descendant relationships. According to the DTD rules a → bc|cb|d and c → a, since b is a terminal and has not any child nodes, clearly, there is no answer for this query in the data set. So any path solution does not contribute to final answers. We varied the size of tag d relative to the size of tag b and c as the child of tag a from 10% to 90% . We generated nine data sets and each of them has about 1 million nodes. Figure <ref type="figure" target="#fig_8">8 (b-c</ref>) show the execution time of T wigStack and T wigStackList and the number of partial path solutions each algorithm produces. The consistent gap between T wigStack and T wigStackList results from the fact that the latter is I/O optimal for this query, but the former is not. As seen in Figure <ref type="figure" target="#fig_8">8</ref>(c), the number of solutions produced by T wigStack is very large, but T wigStackList does not produce any partial solutions at all! We issued the second Xpath query a[/c][/d]/b over the previous nine data sets. As before, there is no match for the query in data sets. But the main different with the previous experiment is that T wigStackList is also not optimal in the second case (since there are parent-child relationships below the branching node a). Therefore, both T wigStack and T wigStackList output some intermediate path solutions that do not contribute to the final answers. Figure <ref type="figure" target="#fig_8">8</ref> (d) shows the execution time for two algorithms and Figure <ref type="figure" target="#fig_8">8</ref> (e) shows the number of partial solutions. We can see that even in the presence of parent-child relationship below the branch node , T wigStackList is again more efficient than T wigStack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Random data set</head><p>Finally we used random data set to compare T wigStack and T wigStackList. In particular, we generate random XML documents consisting of seven different labels, namely: a,b,c,d,e,f ,g. The random data set has about 1 million nodes. We issued five twig queries shown in Figure <ref type="figure" target="#fig_12">9</ref>     <ref type="table" target="#tab_6">3</ref> and<ref type="table" target="#tab_8">4</ref>, we find that most of the reduction percentage in Table <ref type="table" target="#tab_8">4</ref> is smaller than that in Table <ref type="table" target="#tab_6">3</ref>. This fact is due to the difference between TreeBank and random data. There are more than 50 tags in the real-world TreeBank data, but there are only 7 tags in random data. Further, random data (average depth 50) is deeper than TreeBank (average depth 8). Therefore, for random data, in the line 12 of getNext algorithm, the IF condition usually returns true. But for TreeBank, the condition of line 12 usually returns false. Thus, more intermediate paths are pruned by T wigStackList in TreeBank than that in random data. From this fact, we conclude that (i) compared to T wigStack, T wigStackList can reduce partial path solutions for the queries that have parent-child relationship, and (ii) the reduction percentage is relative to the tag distribution in the data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>Join processing is central to query evaluation. In the context of semi-structured and XML databases, structural join is essential to XML query processing because XML queries usually impose certain structural relationships (e.g. parent-child or ancestor-descendant relationships). For binary structural join, Zhang et al <ref type="bibr" target="#b15">[17]</ref>. proposed a multipredicate merge join (MPMGJN) algorithm based on (Start, End, Level) labelling of XML elements. The later work by Al-Khalifa et al <ref type="bibr" target="#b1">[1]</ref> gives a stack-based binary structural join algorithm. Then Wu et al <ref type="bibr" target="#b14">[14]</ref> studied the problem of binary join order selection for complex queries on a cost model which takes into consideration factors such as selectivity and intermediate results size.</p><p>More recently, Bruno et al <ref type="bibr" target="#b5">[5]</ref> propose a holistic twig join algorithm, namely T wigStack, to avoid producing a large intermediate result. T wigStack is I/O optimal for queries with only ancestor-descendant relationships. Jiang et al <ref type="bibr" target="#b9">[9]</ref> studied the problem of holistic twig joins on all/partly indexed XML documents. Their proposed algorithms use indexes to efficiently skip the elements that do not contribute to final answers, but their method cannot reduce the size of intermediate results. Choi. et al <ref type="bibr">[7]</ref> proves that optimality evaluation of twig patterns with arbitrarily mixed ancestordescendant and parent-child edges is not feasible. In this paper, we proposed the algorithm T wigStackList, which is better than any of previous work in term of the size of intermediate results for matching XML twig pattern with both parent-child and ancestor-descendant edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION AND FUTURE WORK</head><p>In this paper, we propose an enhanced holistic twig pattern matching algorithm T wigStackList. Unlike the previous Algorithm T wigStack, our approach takes into account the level information of elements and consequently results in much smaller intermediate path solutions for query twig patterns with both ancestor-descendant and parent-child edges. Experimental results showed that our method is much more efficient than T wigStack for queries with parent-child edges.</p><p>Since Choi et al. <ref type="bibr">[7]</ref> have proven that there is no algorithm which is I/O and CPU optimal for all query patterns, one issue to improve our algorithm is to modify the coding method of the intermediate path solutions so that its size is guaranteed to be no more than the size of input data for all queries. Another possible issue involves designing a new powerful numbering scheme, which needs to change the format of input data.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Illustration to the sub-optimality of T wigStack</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Stacks Sn and lists Ln used in our algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The incorrect merge of two procedures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 : 4</head><label>54</label><figDesc>Figure 5: An example to show the incorrectness of codes in Fig. 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Two examples to illustrate the benefits of Algorithm T wigStackList</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Illustration to the proof of Lemma 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 (</head><label>8</label><figDesc>Figure 8(a)  shows the execution time of queries for two algorithms and Table3shows the number of partial solutions, where the fourth column is the number of merge-joinable path that can contribute to at least one final answer. From the table and figure, we have several observations and conclusions:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Fig 8(a)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>, which have more complex twig structures than that of the queries in the previous experiments. The experimental results, including the execution time and the number of partial solutions are shown in Fig 8(f) and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Queries against random data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Number of partial path solutions produced by T wigStack against TreeBank data</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell>Partial</cell><cell>Merge-</cell><cell>Percentage</cell></row><row><cell></cell><cell>paths</cell><cell>joinable</cell><cell>of useless</cell></row><row><cell></cell><cell></cell><cell>paths</cell><cell>paths</cell></row><row><cell>VP[/DT]//PRP DOLLAR</cell><cell cols="2">10663 5</cell><cell>99.9%</cell></row><row><cell>S[/JJ]/NP</cell><cell cols="2">70988 10</cell><cell>99.9%</cell></row><row><cell>S[//VP/IN]//NP</cell><cell cols="2">702391 22565</cell><cell>96.8%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>return nmin 10: MoveStreamToList(n, nmax) 11: for all node ni in children(n) do 12: if (there is an element ei in list Ln such that ei is the parent of getElement(ni) ) then n has a descendant en i in each of stream Tn i for ni ∈ children(n ); and (ii) if n is not a branching node in the query, element e n has a child en i in Tn i , where ni ∈ P CRchildren(n ) (if any); and (iii) if n is a branching node, there is an element en i in each Tn i such that there exists an element ei(with tag n) in the path from e n to en max that is the parent of en i , where ni ∈ P CRchildren(n ) (if any ) and en max has the maximal start attribute for all children(n ). At line 2-5, in Algorithm getNext, we recursively invoke getNext for each ni ∈ children(n). If any returned node gi is not equal to ni , we immediately return gi (line</figDesc><table><row><cell>13:</cell><cell cols="5">if (ni is the only child of n) then</cell></row><row><cell>14:</cell><cell cols="6">move the cursor pn of list Ln to point to ei</cell></row><row><cell>15:</cell><cell>end if</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>16:</cell><cell>else</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>17:</cell><cell>return ni</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>18:</cell><cell>end if</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">19: end for</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">20: return n</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Procedure getElement(n)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>2:</cell><cell cols="4">if Cn.end &gt; getEnd(g) then</cell><cell></cell></row><row><cell>3:</cell><cell cols="2">Ln.append(Cn)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>4:</cell><cell>end if</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>5:</cell><cell>advance(Tn)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">6: end while</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Procedure proceed(n)</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">1: if empty(Ln) then</cell><cell></cell><cell></cell><cell></cell></row><row><cell>2:</cell><cell>advance(Tn)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">3: else</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>4:</cell><cell>Ln.delete(pn)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>5:</cell><cell cols="6">pn = 0 {Move pn to point to the beginning of Ln}</cell></row><row><cell cols="2">6: end if</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>root</cell><cell></cell></row><row><cell></cell><cell>a</cell><cell></cell><cell>a 1</cell><cell></cell><cell>a 2</cell></row><row><cell></cell><cell>b</cell><cell>c</cell><cell>b 1</cell><cell>d 1</cell><cell>b 2</cell><cell>c 2</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>c 1</cell><cell></cell></row><row><cell></cell><cell cols="2">(a) Query</cell><cell cols="3">(b) Document</cell></row></table><note><p>1: if ¬empty(Ln) then 2: return Ln.elementAt(pn) 3: else return Cn Procedure getStart(n) 1: return the start attribute of getElement(n) Procedure getEnd(n) 1: return the end attribute of getElement(n) Procedure MoveStreamT oList(n, g) 1: while Cn.start &lt; getStart(g) do Figure 3: An example to illustrate getNext algorithm then (i) e</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>start &lt; e new .start e top .end&gt;e new .end e top .start &gt; e new .start e top .end &lt; e new .end e new .end &lt; e top .start</head><label></label><figDesc></figDesc><table><row><cell></cell><cell>Case(i)</cell><cell>Case(ii)</cell><cell>Case(iii)</cell><cell></cell><cell cols="2">Case(iv)</cell></row><row><cell>Property</cell><cell>e top .end &lt; e new .start</cell><cell>e top .</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>e top</cell><cell>e top</cell><cell>e new</cell><cell></cell><cell>e</cell><cell>top</cell></row><row><cell>Segment</cell><cell>e new</cell><cell>e new</cell><cell>e top</cell><cell>e</cell><cell>new</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 : Queries over TreeBank data</head><label>2</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="2">XPath expression</cell><cell></cell></row><row><cell></cell><cell>Q1</cell><cell cols="2">S[//MD]//ADJ</cell><cell></cell></row><row><cell></cell><cell>Q2</cell><cell cols="3">S/VP/PP[/NP/VBN]/IN</cell></row><row><cell></cell><cell>Q3</cell><cell cols="3">S/VP//PP[//NP/VBN]//IN</cell></row><row><cell></cell><cell>Q4</cell><cell cols="3">VP[/DT]//PRP DOLLAR</cell></row><row><cell></cell><cell>Q5</cell><cell cols="2">S[//VP/IN]//NP</cell><cell></cell></row><row><cell></cell><cell>Q6</cell><cell cols="2">S[/JJ]/NP</cell><cell></cell></row><row><cell cols="3">Queries T wigStack</cell><cell>T wigStackList</cell><cell>Reduction</cell><cell>Useful</cell></row><row><cell></cell><cell>Path</cell><cell></cell><cell>Path</cell><cell>percent-</cell><cell>Path</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>age</cell></row><row><cell>Q1</cell><cell>35</cell><cell></cell><cell>35</cell><cell>0%</cell><cell>35</cell></row><row><cell>Q2</cell><cell>2957</cell><cell></cell><cell>143</cell><cell>95%</cell><cell>92</cell></row><row><cell>Q3</cell><cell>25892</cell><cell></cell><cell>4612</cell><cell>82%</cell><cell>4612</cell></row><row><cell>Q4</cell><cell>10663</cell><cell></cell><cell>11</cell><cell>99.9%</cell><cell>5</cell></row><row><cell>Q5</cell><cell>702391</cell><cell></cell><cell>22565</cell><cell>96.8%</cell><cell>22565</cell></row><row><cell>Q6</cell><cell>70988</cell><cell></cell><cell>30</cell><cell>99.9%</cell><cell>10</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3 : Number of intermediate path soltuions pro- duced by T wigStack and T wigStackList for TreeBank data</head><label>3</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Execution time against TreeBank data (b)-(e) Performance comparison of two algorithms using generated DTD data (f ) Execution time against random data</head><label></label><figDesc>Table 4 respectively. From the figure and table, we see that for all queries, T wigStackList is again more efficient than T wigStack.</figDesc><table><row><cell>Execution time(second)</cell><cell>0 2 4 6 8 10 12 14</cell><cell></cell><cell cols="4">TwigStack TwigStackList</cell><cell></cell><cell>29s</cell><cell></cell><cell></cell><cell>Execution time (second)</cell><cell>0 5 10 15 20 25 30</cell><cell>10%</cell><cell>20%</cell><cell>30%</cell><cell>40% TwigStack TwigStackList 50% 60% 70%</cell><cell>80%</cell><cell>90%</cell><cell cols="2">Number of intermediate solutions</cell><cell>0 200000 400000 600000 800000 1000000 1200000 1400000 1600000 1800000</cell><cell>10%</cell><cell>20%</cell><cell>30% TwigStack 40%</cell><cell>50%</cell><cell>60%</cell><cell>70% TwigStackList 80%</cell><cell>90%</cell></row><row><cell></cell><cell></cell><cell>Q1</cell><cell></cell><cell>Q2</cell><cell>Q3</cell><cell>Query</cell><cell>Q4</cell><cell>Q5</cell><cell></cell><cell>Q6</cell><cell></cell><cell></cell><cell cols="5">Fraction of the number of elements with tag d relative to the number of elements with tag b and c</cell><cell></cell><cell></cell><cell></cell><cell>Fraction of the number of elements with tag d relative to the number of elements with tag b and c</cell></row><row><cell></cell><cell></cell><cell cols="9">(a)Execution time on TreeBank</cell><cell></cell><cell cols="7">(b) Execution time for a[//c]//b/d</cell><cell cols="3">(c)Intermediate solutions for a[//c]//b/d</cell></row><row><cell>Execution time (second)</cell><cell>0 5 10 15 20 25 30</cell><cell>10%</cell><cell>20%</cell><cell>30%</cell><cell cols="4">40% TwigStack TwigStackList 50% 60% 70%</cell><cell>80%</cell><cell>90%</cell><cell>Number of intermediate solutions</cell><cell cols="2">0 100000 200000 300000 400000 500000 600000 700000 800000</cell><cell cols="5">10% 20% 30% 40% 50% 60% 70% 80% 90% TwigStack TwigStackList</cell><cell>Execution time(second)</cell><cell>0 2 4 6 8 10 12</cell><cell>Q1</cell><cell>Q2</cell><cell>Q3 TwigStack TwigStackList Q4</cell><cell>Q5</cell></row><row><cell></cell><cell cols="9">Fraction of the number of elements with tag d relative to the</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">Fraction of the number of elements with tag d relative to the</cell><cell></cell><cell></cell><cell>Query</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="5">number of elements with tag b and c</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">number of elements with tag b and c</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="10">(d) Execution time for a[/c][/d]/b</cell><cell cols="8">(e) Intermediate solutions for a[/c][/d]/b</cell><cell cols="3">(f) Execution time on random data</cell></row><row><cell cols="6">Figure 8: (a) Queries T wigStack</cell><cell cols="5">T wigStackList</cell><cell cols="3">Reduction</cell><cell cols="2">Useful</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Path</cell><cell></cell><cell cols="2">Path</cell><cell></cell><cell></cell><cell></cell><cell cols="3">percentage</cell><cell cols="2">Path</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Q1</cell><cell></cell><cell cols="2">9048</cell><cell></cell><cell cols="2">4354</cell><cell></cell><cell></cell><cell></cell><cell>52%</cell><cell></cell><cell></cell><cell cols="2">2077</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Q2</cell><cell></cell><cell cols="2">1098</cell><cell></cell><cell cols="2">467</cell><cell></cell><cell></cell><cell></cell><cell>57%</cell><cell></cell><cell></cell><cell>100</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Q3</cell><cell></cell><cell cols="2">25901</cell><cell></cell><cell cols="2">14476</cell><cell></cell><cell></cell><cell></cell><cell>44%</cell><cell></cell><cell></cell><cell cols="2">14476</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Q4</cell><cell></cell><cell cols="2">32875</cell><cell></cell><cell cols="2">16775</cell><cell></cell><cell></cell><cell></cell><cell>49%</cell><cell></cell><cell></cell><cell cols="2">16775</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Q5</cell><cell></cell><cell cols="2">3896</cell><cell></cell><cell cols="2">1320</cell><cell></cell><cell></cell><cell></cell><cell>66%</cell><cell></cell><cell></cell><cell>566</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 : Number of intermediate path soltuions pro- duced by T wigStack and T wigStackList for random data</head><label>4</label><figDesc></figDesc><table /></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Structural Joins: A primitive for efficient XML query pattern matching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Al-Khalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M Y</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="141" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Berglund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Boag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Robie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simeon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">XML Path Language</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>XPath) 2.0&quot; W3C Working Draft 22 August</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Xquery 1.0: An XML QueryW3C</title>
		<author>
			<persName><forename type="first">S</forename><surname>Boag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Robie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simeon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Working Draft 22 August</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Holistic twig joins: Optimal XML pattern matching</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-03">March 2002</date>
		</imprint>
		<respStmt>
			<orgName>Columbia University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Holistic twig joins: Optimal XML pattern matching</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="310" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">BLAS: An Efficient XPath Processing System</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD 2004</title>
		<meeting>SIGMOD 2004</meeting>
		<imprint>
			<biblScope unit="page" from="47" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the Optimality of Holistic Algorithms for Twig Queries</title>
		<author>
			<persName><forename type="first">B</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mahoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DEXA</title>
		<imprint>
			<biblScope unit="page" from="28" to="37" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Generalized search trees for database systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pfeifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="562" to="573" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Holistic twig joins on indexed XML documents</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB 2003</title>
		<meeting>VLDB 2003</meeting>
		<imprint>
			<biblScope unit="page" from="273" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">XR-Tree: Indexing XML Data for Efficient Structural Joins</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE 2003</title>
		<meeting>ICDE 2003</meeting>
		<imprint>
			<biblScope unit="page" from="253" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient Processing of Twig Queries with OR-Predicates</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD 2004</title>
		<meeting>SIGMOD 2004</meeting>
		<imprint>
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Indexing and querying XML data for regular path expressions</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="361" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Storing and Querying Ordered XML Using a Relational Database System</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tatarinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Viglas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shekita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="204" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Structural Join Order Selection for XML Query Optimization</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDE</title>
		<imprint>
			<biblScope unit="page" from="443" to="454" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On Supporting containment Queries in Relational Database Management Systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Lohman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="425" to="436" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
