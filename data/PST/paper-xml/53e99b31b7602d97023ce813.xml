<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Predicting Vulnerable Software Components</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stephan</forename><surname>Neuhaus</surname></persName>
							<email>neuhaus@st.cs.uni-sb.de</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Zimmermann</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Calgary</orgName>
								<address>
									<settlement>Calgary</settlement>
									<region>Alberta</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><surname>Holler</surname></persName>
							<email>holler@st.cs.uni-sb.de</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
							<email>zeller@st.cs.uni-sb.de</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>Alexandria</settlement>
									<region>Virginia</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Predicting Vulnerable Software Components</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">414B504456286A8481F942281D39C2FB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software Engineering]: Software/Program Verification-Statistical methods</term>
					<term>D.2.5 [Software Engineering]: Testing and Debugging-Testing tools</term>
					<term>D.4.6 [Operating Systems]: Security and Protection-Invasive software Security, Experimentation, Measurement Software Security, Prediction</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Where do most vulnerabilities occur in software? Our Vulture tool automatically mines existing vulnerability databases and version archives to map past vulnerabilities to components. The resulting ranking of the most vulnerable components is a perfect base for further investigations on what makes components vulnerable.</p><p>In an investigation of the Mozilla vulnerability history, we surprisingly found that components that had a single vulnerability in the past were generally not likely to have further vulnerabilities. However, components that had similar imports or function calls were likely to be vulnerable.</p><p>Based on this observation, we were able to extend Vulture by a simple predictor that correctly predicts about half of all vulnerable components, and about two thirds of all predictions are correct. This allows developers and project managers to focus their their efforts where it is needed most: "We should look at nsXPInstallManager because it is likely to contain yet unknown vulnerabilities.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Many software security problems are instances of general patterns, such as buffer overflow or format string vulnerabilities. Some problems, though, are specific to a single project or problem domain: JavaScript programs escaping their jails are a problem only in web browsers. To improve the security of software, we must therefore not only look for general problem patterns, but also learn specific patterns that apply only to the software at hand.</p><p>Modern software development usually does a good job in tracking past vulnerabilities. The Mozilla project, for instance, maintains a vulnerability database which records all incidents. However, these databases do not tell how these vulnerabilities are distributed across the Mozilla codebase. Our Vulture tool automatically mines a vulnerability database and associates the reports with the change history to map vulnerabilities to individual components (Figure <ref type="figure" target="#fig_0">1</ref>). Vulture's result is a distribution of vulnerabilities across the entire codebase. Figure <ref type="figure" target="#fig_1">2</ref> shows this distribution for Mozilla: the darker a component, the more vulnerabilities were fixed in the past.The distribution is very uneven: Only 4% of the 10,452 components were involved in security fixes. This raises the question: Are there specific code patterns that occur only in vulnerable components?</p><p>In our investigation, we were not able to determine code features such as, code complexity or buffer usage that would correlate with the number of vulnerabilities. What we found, though, was that vulnerable components shared similar sets of imports and function calls. In the case of Mozilla, for instance, we found that of the 14 components importing nsNodeUtils.h, 13 components (93%) had to be patched because of security leaks. The situation is even worse for those 15 components that import nsIContent.h, nsIInterface-RequestorUtils.h and nsContentUtils.h together-they all had vulnerabilities. This observation can be used for automatically predicting whether a new component will be  After discussing the scope of this work (Section 2), the remainder of this paper details our original contributions, which can be summarized as follows.</p><p>• We present a fully automatic way of mapping vulnerabilities to components (Section 3).</p><p>• We provide empirical evidence that vulnerabilities correlate with component imports (Section 4).</p><p>• We show how to build fully automatic predictors that predict vulnerabilities of new components based on their imports and function calls (Section 5).</p><p>• Our evaluation on the Mozilla project shows that these predictors are accurate (Section 6).</p><p>After discussing related work (Section 7), we close with conclusions and future work (Section 8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SCOPE OF THIS WORK</head><p>Our work is empirical and statistical: we look at correlations between two phenomena-vulnerabilities on one hand and imports or function calls on the other-, but we do not claim that these are cause-effect relationships. It is clearly not the case that importing some import or calling some function causes a vulnerability. Programmers writing that import statement or function call generally have no choice in the matter: they need the service provided by some import or function and therefore have to import or call it, whether they want to or not.</p><p>Our hypothesis is that the cause of the vulnerability is the import's or function's domain, that is, the range of services that it uses or implements. It appears that some domains are more risky than others, and being associated with a particular domain increases the risk of having a vulnerability. Different projects might have different risky domains, which would lead Vulture to mine project-specific vulnerability patterns.</p><p>We have also identified the following circumstances that could affect the validity of our study:</p><p>Study size. The correlations we are seeing with Mozilla could be artifacts that are specific to Mozilla. They might not be as strong in other projects, or the correlations might disappear altogether. From our own work analyzing Java projects, we think this is highly unlikely <ref type="bibr" target="#b30">[29]</ref>; see also Section 7 on related work.</p><p>Bugs in the database or the code. The code to analyze the CVS or import the Security Advisories into the database could be buggy; the inputs to the machinelearning methods or the code that assesses the effectiveness of these methods could be wrong. All these risks were mitigated either by sampling small subsets and checking them manually for correctness, or by implementing the functionality a second time starting from scratch and comparing the results. For example, some machine-learning inputs were manually checked, and the assessment code was rewritten from scratch.</p><p>Bugs in the R library. We rely on a third-party R library for the actual computation of the SVM and the predictions <ref type="bibr">[9]</ref>, but this library was written by experts in the field and has undergone cross-validation, also in work done in our group <ref type="bibr" target="#b30">[29]</ref>.</p><p>Wrong or noisy input data. It is possible that the Mozilla source files contain many "noisy" import relations in the sense that some files are imported but actually never used; or the Security Advisories that we use to map vulnerabilities to components could accidentally or deliberately contain wrong information. Our models do not incorporate noise. From manually checking some of the data, we believe the influence of noise to be negligible, especially since results recur with great consistency, but it remains a (remote) possibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Yet unknown vulnerabilities.</head><p>Right now, our predictions are evaluated against known vulnerabilities in the past. Finding future vulnerabilities in flagged components would improve precision and recall; finding them in unflagged components would decrease recall.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">COMPONENTS AND VULNERABILITIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Components</head><p>For our purposes, a component is an entity in a software project that can have vulnerabilities. For Java, components would be .java files because they contain both the definition and the implementation of classes. In C++, and to a lesser extent in C, however, the implementation of a component is usually separated from its interface: a class is declared in a header file, and its implementation is contained in a source file. A vulnerability that is reported only for one file of a two-file component is nevertheless a vulnerability of the entire component. For this reason, we will combine equallynamed pairs of header and source files into one component.</p><p>In C, it is often the case that libraries are built around abstractions that are different from classes. The usual case is that there is one header file that declares a number of structures and functions that operate on them, and several files that contain those functions' implementations. Without a working build environment, it is impossible to tell which source files implement the concepts of which header file. Since we want to apply Vulture to projects where we do not have a working build environment-for example because we want to analyze old versions that we cannot build anymore due to missing third-party software-, we simply treat files which have no equally-named counterpart as components containing just that file. We will subsequently refer to components without any filename extensions.</p><p>Of course, some components may naturally be self-contained. For example, a component may consist only of a header file that includes all the necessary implementation as inline functions there. Templates must be defined in header files. A component may also not have a header file. For example, the file containing a program's main function will usually not have an associated header file. These components then consist of only one file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Mapping Vulnerabilities to Components</head><p>A vulnerability is a defect in one or more components that manifests itself as some violation of a security policy. Vulnerabilities are announced in security advisories that provide users workarounds or pointers to fixed versions and help them avoid security problems. In the case of Mozilla, advisories also refer to a bug report in the Bugzilla database. We use this information, to map vulnerabilities to components through the fixes that remove the defect.</p><p>First we retrieve all advisories from the Web to collect the defects, in case of Mozilla from the "Known Vulnerabilities in Mozilla Products" page. <ref type="foot" target="#foot_0">1</ref> We then search for references to the Bugzilla database that typically take the form of links to its web interface: https://bugzilla.mozilla.org/show_bug.cgi?id=362213</p><p>The number at the end of this URL is the bug identifier of the defect that caused the vulnerability. We collect all bug identifiers and use them to identify the corresponding fixes in the version archive. In version archives every change is annotated with a message that describes the reason for that change. In order to identify the fixes for a particular defect, say 362213, we search these messages for bug identifiers such as "362213", "Bug #362213", and "fix 362213" (see also Figure <ref type="figure" target="#fig_7">3</ref>). This approach is described in detail by Śliwerski et al. <ref type="bibr" target="#b31">[30]</ref> and extends the approaches introduced by Fischer et al. <ref type="bibr" target="#b11">[10]</ref> and by Čubranić et al. <ref type="bibr" target="#b8">[7]</ref>.</p><p>Once we have identified the fixes of vulnerabilities, we can easily map the names of the corrected files to components. Note that a security advisory can contain several references to defects, and a defect can be fixed in several files.</p><p>It is important to note that we do not analyze binary patches to programs, but source code repository commits. Binary patches usually address a number of bugs at once, which are not necessarily vulnerabilities, or contain functionality enhancements. In contrast, commits are very specific, fixing only one vulnerability at a time. This is why we can determine the affected components with confidence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Vulnerable Components in Mozilla</head><p>Mozilla as of 4 January 2007 contains 1,799 directories and 13,111 C/C++ files which are combined into 10,452 components. There were 134 vulnerability advisories, pointing to 302 bug reports. Of all 10,452 components, only 424 or 4.05% were vulnerable.</p><p>Security vulnerabilities in Mozilla are announced through Mozilla Foundation Security Advisories (MFSAs) since January 2005 and are available through the Mozilla Foundation's web site <ref type="bibr" target="#b34">[33]</ref>. These advisories describe the vulnerability and give assorted information, such as Bugzilla bug identification numbers. Of all 302 vulnerability-related bug reports, 280 or 92.7% could be assigned to components using the techniques described above.  If a component has a vulnerability-related bug report associated with it, we call it vulnerable. In contrast to a vulnerable component, a neutral component has had no vulnerabilityrelated bug reports associated with it so far.</p><p>The distribution of the number of MFSAs can be seen in Figure <ref type="figure">4</ref>. The most important result from this histogram is that it directly contradicts an item of security folklore that says that components that had vulnerabilities in the past will likely have vulnerabilities in the future. If that were truly the case, the histogram should show ascending numbers of components with ascending numbers of reports. In fact, however, the opposite is true: there were twice as many components with one MFSA (292) than all components with two or more MFSAs combined (132).</p><p>One consequence of this empirical observation is that the number of past vulnerability reports is not a good predictor for future reports, because it would miss all the coman authenticated account. We suppose that these reports concern vulnerabilities that have high impact but that are not yet fixed, either in Mozilla itself or in other software that uses the Mozilla codebase. In many cases, we were still able to assign bug reports to files automatically because the CVS log message contained the bug report number. By looking at the diffs, it would therefore have been possible to derive what the vulnerability was. Denying access to these bug reports is thus largely ineffectual and might even serve to alert blackhats to potential high-value targets. ponents that have only one report. Indeed, when we take the CVS from July 24, 2007-encompassing changes due to MFSAs 2007-01 through 2007-25-we find that 149 components were changed in response to MFSAs. Of these newly fixed components, 81 were repeat offenders, having at least one vulnerability-related fix before January 4. The remaining 68 components had never had a security-related fix.</p><p>As for using other metrics such as lines of code and so on to predict vulnerabilities, studies by Nagappan et al. have shown that there is no single metric that correlates with failures across all considered projects <ref type="bibr" target="#b22">[21]</ref>.</p><p>The top ten most vulnerable components in Mozilla are listed in Table <ref type="table" target="#tab_1">1</ref>. The four most vulnerable components all deal with scripting in its various forms:</p><p>1. nsGlobalWindow, with fixes for 14 MFSAs and 14 bug reports, has, among others, a method to set the status bar, which can be called from JavaScript and which will forward the call to the browser chrome.</p><p>2. jsobj (13 MFSAs; 24 bug reports) contains support for JavaScript objects.</p><p>3. jsfun (11 MFSAs; 15 bug reports) implements support for JavaScript functions.</p><p>4. nsScriptSecurityManager (11 MFSAs; 15 bug reports) implements access controls for JavaScript programs.</p><p>In the past, JavaScript programs have shown an uncanny ability to break out of their jails, which manifests as a high number of security-related changes to these components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPORTS AND FUNCTIONS MATTER</head><p>As discussed in Section 3.3, we found that several components related to scripting rank among the most vulnerable components. How does a concept like scripting manifest itself in the components' code?</p><p>Our central assumption in this work is that what a component does is characterized by its imports and function calls. A class that implements some form of content-anything that can be in a document's content model-will use functions declared in nsIContent.h and will therefore need to import it; a class that implements some part of the Document Object Model (DOM) will likely use functions fromand hence import-nsDOMError.h. And components associated with scripting are characterized by the functions from and the import of nsIScriptGlobalObject.h.</p><p>In a strictly layered software system, a component that is located at layer k would import only from components at layer k +1; its imports would pinpoint the layer at which the component resides. In more typical object-oriented systems, components will not be organized in layers; still, its imports will include those components whose services it uses and those interfaces that it implements.</p><p>If an interface or component is specified in an insecure way, or specified in a manner that is difficult to use securely, then we would expect many components that use or implement that interface or component to be vulnerable. In other words, we assume that it is a component's domain, as given by the services it uses and implements, that determine whether a component is likely to be vulnerable or not.</p><p>How do imports and function calls correlate with vulnerabilities? For this, we first need a clear understanding of what constitutes an import or a function call and what it means for a set of imports or function calls to be correlated with vulnerability.</p><p>In the following discussion, we use the term "feature" to refer to both imports and function calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Imports</head><p>In C and C++, a component's imports are those files that it references through #include preprocessor directives. These directives are handled by the preprocessor and come in three flavors:</p><p>#include &lt;name&gt; This variant is used to import standard system headers.</p><p>#include "name" This variant is used to import header files within the current project.</p><p>#include NAME In this variant, NAME is treated as a preprocessor symbol. When it is finally expanded, it must resolve to one of the two forms mentioned above.</p><p>The exact computation of imports for C and C++ is difficult because the semantics of the first two variants are implementation-dependent, usually influenced by compiletime switches and macro values. That means that it is not possible to determine exactly what is imported without a working build environment. We therefore adopted the following heuristics:</p><p>• We treat every occurrence of #include as an import, even though it may not be encountered in specific compile-time configurations-for example because of conditional compilation. The reason is that we want to obtain all possible import relations, not just the ones that are specific to a particular platform.</p><p>• We assume that identically-named includes refer to the same file, even though preprocessor directives may cause them to refer to different files. It turns out that this does not happen in Mozilla.</p><p>• Implementing the computed include would require a full preprocessor pass over the source file. This in turn would require us to have a fully compilable (or at least preprocessable) version of the project. Fortunately, this use of the include directive is very rare (Mozilla does not use it even once), so we chose to ignore it.</p><formula xml:id="formula_0">#ifdef XP_OS2 if (DosCreatePipe(&amp;pipefd[0], &amp;pipefd[1], 4096) != 0) { #else if (pipe(pipefd) == -1) { #endif</formula><p>fprintf(stderr, "cannot create pipe: %d\n", errno); exit(1); } </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Function Calls</head><p>In C and C++, a function call is an expression that could cause the control flow to be transferred to a function when it is executed. <ref type="foot" target="#foot_2">3</ref> A function call is characterized by the name of the function and a parenthesized list of arguments.</p><p>Statically extracting function calls from unpreprocessed C or C++ source code is difficult. Dynamic parsing with type information would require compilable source code and even a full static parsing is blighted by syntax errors caused by some preprocessor statements; see Figure <ref type="figure" target="#fig_3">5</ref>. As a consequence, we simply treat all occurrences of identifier (. . . ) and identifier &lt;. . . &gt;(. . . ) as function calls.</p><p>Keywords are excluded so that if or while statements are not erroneously classified as function calls. Also, to match only function calls and not function definitions, these patterns must not be followed by an opening curly bracket. But even with these restrictions, there are many other constructs which match these patterns, such as constructors, macros, forward declarations, member function declarations, initialization lists, and C++ functional-style type casts. Some of these, like constructors and macros, are very similar to function calls and hence are actually desired. The false classifications of forward declarations, member function declarations, initialization lists, and type casts do not seem to affect our results.</p><p>In contrast to these undesirable positive classifications, there are also function calls that are not caught by our heuristic, such as function calls using function pointers or overloaded operators. A simple parser without preprocessing will generally not be able to do type checking, and will therefore not be able to correctly classify such calls. However, we believe that this is a rather uncommon practice in C++, especially in bigger projects such as Mozilla because such dynamic calls are more effectively employed through virtual functions. Hence, we ignore this category of call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Mapping Vulnerabilities to Features</head><p>In order to find out which feature combinations are most correlated with vulnerabilities, we use frequent pattern mining <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b19">18]</ref>. The result of frequent pattern mining is a list of feature sequences that frequently occur in vulnerable components. To judge whether these features are significant, we apply the following criteria: Minimum Support. For imports, the pattern must appear in at least 3% of all vulnerable components. (In other words, it needs a minimum support count of 3% Significance. We only want to include patterns that are more meaningful than their sub-patterns. For this, we test whether the entire pattern is more specific for vulnerabilities than its sub-patterns. Let I be a set of features that has passed the minimum-support test.</p><formula xml:id="formula_1">P (V |I) V ∧ I !V ∧ I</formula><p>Then for each proper subset J ⊂ I, we look at all files that feature I and at all files that feature I -J.</p><p>We then classify those files into vulnerable and neutral files and then use the resulting contingency table to compute whether additionally featuring J significantly increases the chance of vulnerability. We reject all patterns where we cannot reject the corresponding hypothesis at the 1% level. (In other words, it must be highly unlikely that featuring J in addition to I -J is independent from vulnerability.) <ref type="foot" target="#foot_3">4</ref>For patterns that survive these tests, the probability of it occurring in a vulnerable component is much higher than for its subsets. This is the case even though the conditional probability of having a vulnerability when including these particular includes may be small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Features in Mozilla</head><p>Again, we applied the above techniques to the Mozilla base. In Mozilla, Vulture found 79,494 import relations of the form "component x imports import y", and 9,481 distinct imports. Finding imports is very fast: a simple Perl script goes through the 13,111 C/C++ files in about thirty seconds. We also found 324,822 function call relations of the form "component x calls function y", and 93,265 distinct function names. Finding function calls is not as fast as finding imports: the script needs about 8 minutes to go through the entire Mozilla codebase.</p><p>Frequent pattern mining, followed by weeding out insignificant patterns yields 576 include patterns and 2,470 function call patterns. The top ten include patterns are shown in Table 2. Going through all 576 include patterns additionally reveals that some includes occur often in patterns, but not alone. For example, nsIDocument.h appears in 45 patterns, but never appears alone. Components that often appear together with nsIDocument.h come from directories layout/base or content/base/public, just like nsIDocument itself. Similar observations hold for function call patterns.</p><p>Table <ref type="table" target="#tab_2">2</ref> reveals that implementing or using nsIContent.h together with nsIInterfaceRequestorUtils and nsContent-Utils.h correlated with vulnerability in the past. Typical components that imports these are nsJSEnvironment or nsHTMLContentSink. The first is again concerned with JavaScript, which we already know to be risky. The second has had a problems with a crash involving DHTML that apparently caused memory corruption that could have led to arbitrary code execution <ref type="bibr">(MFSA 2006-64</ref>).</p><p>Looking at Table <ref type="table" target="#tab_2">2</ref>, we see that of the 35 components importing nsIScriptSecurityManager.h, nsIContent.h, and nsContentUtils.h, 34 are vulnerable, while only one is not. This may mean one of two things: either the component is invulnerable or the vulnerability just has not been found yet. At the present time, we are unable to tell which is true. However, the component in question is nsObjectLoading-Content. It is a base class that implements a content loading interface and that can be used by content nodes that provide functionality for loading content such as images or applets. It certainly cannot be ruled out that the component has an unknown vulnerability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PREDICTING VULNERABILITIES FROM FEATURES</head><p>In order to predict vulnerabilities from features, we need a data structure that captures all of the important information about components and features (such as which component has which features) and vulnerabilities (such as which component has how many vulnerabilities), but abstracts away information that we consider unimportant (such as the component's name). In Figure <ref type="figure">6</ref>, we describe our choice: if there are m components and n features, we write each component as a n-vector of features: x k = (x k1 , . . . , x kn ), where for 1 ≤ k ≤ m and 1 ≤ j ≤ n,</p><formula xml:id="formula_2">x kj = ( 1 if component i features feature j, 0 otherwise.</formula><p>We combine all components into X = (x1, . . . , xm) t , the project's feature matrix. Entities that cannot contain includes or function calls, such as makefiles, are ignored.</p><p>In addition to the feature matrix, we also have the vulnerability vector v = (v1, . . . , vm), where vj is the number of vulnerability reports associated with component j. Now assume that we get a new component, xm+1. Our question, "How vulnerable is component m + 1?" is now equivalent to asking for the rank of vm+1 among the values of v, given xm+1; and "Is component m + 1 vulnerable?" is now equivalent to asking whether vm+1 &gt; 0.</p><p>As we have seen in the preceding sections, features are correlated with vulnerabilities. How can we use this information to answer the above questions? Both questions can 10 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 &lt;stdio.h&gt; "util.h" "nsIJavaDOM.h" &lt;sys/file.h&gt; "nsStackFrame.h" "jvmp.h" "btree.h" "orkinEnv.h" "nsIXPConnect.h" "sslimpl.h" nsIDocument.h be posed as machine-learning problems. In machine learning, a parameterized function f , called a model, is trained using training data X and y, so that we predict ŷ = f (X).</p><p>The parameters of f are usually chosen such that some measure of difference between y and ŷ is minimized. The question, "Is this component vulnerable?" is called classification, and "Is this component more or less vulnerable than another component?" can be answered with regression: by predicting the number of vulnerabilities and then ranking the components accordingly.</p><p>In our case, X would be the project's feature matrix, and y would be the vulnerability vector v. We now train a model and use it to predict for a new component x . If it classifies x as vulnerable, this means that x has features that were associated with vulnerabilities in other components.</p><p>For our model f , we chose support vector machines <ref type="bibr" target="#b37">[36]</ref> (SVMs) over other models such as k-nearest-neighbors [13, Chapter 13] because they have a number of advantages. For example, when used for classification, SVMs cope well with data that is not linearly separable. They are also much less prone to overfitting than other machine-learning methods.<ref type="foot" target="#foot_5">5</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Validation Setup</head><p>To test how good our particular set of features work as predictors for vulnerabilities, we simply split our feature matrix to train and to assess the model. For this purpose, we randomly select a number of rows from X and the corresponding elements from v-collectively called the training set-and use this data to train f . Then we use the left-over rows from X and elements from y-the validation set-to predict whether the corresponding components are vulnerable and to compare the computed prediction with what we already know from the bug database. It is usually recommended that the training set be twice as large as the validation set, and we are following that recommendation. We are not using a dedicated test set because we will not  be selecting a single model, but will instead be looking at the statistical properties of many models and will thus not tend to underestimate the test error of any single model <ref type="bibr" target="#b14">[13,</ref><ref type="bibr">Chapter 7]</ref>.</p><p>One caveat is that the training and validation sets might not contain vulnerable and neutral components in the right proportions. This can happen when there are so few vulnerable components that pure random splitting would produce a great variance in the number of vulnerable components in different splits. We solved this problem by stratified sampling, which samples vulnerable and neutral components separately to ensure the proper proportions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Evaluating Classification</head><p>For classification, we can now compare the predicted values v with the actual values v and count how many times our prediction was correct. This gives rise to the measures of precision and recall, as shown in Figure <ref type="figure" target="#fig_6">7</ref>:</p><p>• The precision measures how many of the components predicted as vulnerable actually have shown to be vulnerable. A high precision means a low number of false positives; for our purposes, the predictor is efficient.</p><p>• The recall measures how many of the vulnerable components are actually predicted as such. A high recall means a low number of false negatives; for our purposes, the predictor is effective.</p><p>In order to assess the quality of our predictions, consider a simple cost model. <ref type="foot" target="#foot_6">6</ref> Assume that we have a "testing budget" of T units. Each component out of m total components is either vulnerable or not vulnerable, but up front we do not know which is which. Let us say there are V vulnerabilities distributed arbitrarily among the m components and that if we spend 1 unit on a component, we determine for sure whether the component is vulnerable or not. In a typical software project, both V and T would be much less than m.</p><p>If we fix T , m, and V , and if we have no other information about the components, the optimal strategy for assigning units to components is simply to choose components at random. In this case, the expected return on investment would be T V /m: we test T components at random, and the fraction of vulnerable components is V /m. Now assume that we have a predictive method with precision p and that we spend our T units only on components that have been flagged as vulnerable by the method. In this case, the expected return on investment is T p because the fraction of vulnerable components among the flagged components is p. If p &gt; V/m, the predictive method does better than random assignment. In practice, we estimate V by the number of components already known to have vulnerabilities, V , so we will want p to be much larger then V /m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Evaluating Ranking</head><p>When we use a regression model, we predict the number of vulnerabilities in a component. One standard action based on this prediction would be allocating quality assurance efforts: As a manager, we would spend most resources (such as testing, reviewing, etc.) on those components which are the most likely to be vulnerable. With a prediction method that estimates the number of vulnerabilities in a component, we would examine components of v in decreasing order of predicted vulnerabilities.</p><p>Usually, the quality of such rankings is evaluated using Spearman's rank correlation coefficient. This is a number between -1 and 1 which says how well the orderings in two vectors agree. Values near 1 mean high correlation (if the values in one vector go up, then so do the values in the other vector), values near 0 mean no correlation, and values near -1 mean negative correlation (if the values in one vector go up, the values in the other vector go down).</p><p>However, this measure is inappropriate within the simple cost model from above. Suppose that we can spend T units on testing. In the best possible case, our ranking predicts the actual top T most vulnerable components in the top T slots. The relative order of these components doesn't matter because we will eventually fix all top T components: while high correlation coefficients mean good rankings, and while bad rankings will produce correlation coefficients near 0, the converse is not true.</p><p>Instead, we extend our simple cost model as follows. Let p = (p1, . . . , pm) be a permutation of 1, . . . , m such that vp = (vp 1 , . . . , vpm ) is sorted in descending order (that is, vp j ≥ vp k for 1 ≤ j &lt; k ≤ m), and let q and vq be defined accordingly. When we fix component pj, we fix vp j vulnerabilities. Therefore, when we fix the top T predicted components, we fix F = P 1≤j≤T vp j vulnerabilities, but with optimal ordering, we could have fixed Fopt = P 1≤j≤T vq j vulnerabilities instead. Therefore, we will take the quotient Q = F/Fopt as a quality measure for our ranking. This is the fraction of vulnerabilities that we have caught when we used p instead of the optimal ordering q. It will always be between 0 and 1, and higher values are better.</p><p>In a typical situation, where we have V m and T small, a random ranking will almost always have Q = 0, so our method will be better than a random strategy if Q is always greater than zero. In order to be useful in practice, we will want Q to be significantly greater than zero, say, greater than 1/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CASE STUDY: MOZILLA</head><p>To evaluate Vulture's predictive power, we applied it to the code base of Mozilla <ref type="bibr" target="#b35">[34]</ref>. Mozilla is a large open-source project that has existed since 1998. It is easily the second most commonly used Internet suite (web browser, email reader, and so on) after Internet Explorer and Outlook.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Data Collection</head><p>We examined Mozilla as of January 4, 2007. Vulture mapped vulnerabilities to components, and then created the feature matrices and the vulnerability vector as described in Sections 3.3 and 4.4.</p><p>Table <ref type="table">3</ref> reports approximate running times for Vulture's different phases when applied to Mozilla with imports as the features under consideration. Vulture is so fast that we could envision it as part of an IDE giving feedback in real time (see Figure <ref type="figure" target="#fig_10">10</ref> at the end of the paper).</p><p>The 10,452 × 9,481 import matrix would take up some 280 MB of disk space if it were written out in full. The sparse representation that we used <ref type="bibr" target="#b16">[15]</ref> required only 230 KB of disk space, however. The 10,452 × 93,265 function call matrix took up 2.6 MB of disk space.</p><p>For each feature matrix and the vulnerability vectors, we created 40 random splits using stratified sampling. This ensures that vulnerable and neutral components are present in the training and validation sets in the same proportions. The training set had 6,968 entries and was twice as large as the validation set with 3,484 entries; this is the standard proportion for empirical evaluations of this kind. Finally, we assessed these SVMs with the 40 validation sets.</p><p>For the statistical calculations, we used the R system <ref type="bibr" target="#b25">[24]</ref> and the SVM implementation available for it <ref type="bibr">[9]</ref>. It is very easy to make such calculations with R; the size of all R scripts used in Vulture is just about 200 lines. The calculations were done on standard hardware without special memory sizes or processing powers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Classification</head><p>The SVM used the linear kernel with standard parameters. Figure <ref type="figure" target="#fig_8">8</ref> reports the precision and recall values for the 40 random splits, both for imports and for function calls. For imports, the recall has an average of 0.45 and standard deviation of 0.04, which means that about half of all vulnerable components are correctly classified: Of all vulnerable components, Vulture flags 45% as vulnerable.</p><p>For function calls, the precision has a mean of 0.70 and a standard deviation of 0.05.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Of all components flagged as vulnerable,</head><p>70% actually are vulnerable. Vulture is much better than random selection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Ranking</head><p>The SVM used the linear kernel with standard parameters. The coefficient Q that was introduced in Section 5.3 was computed for imports and function calls, for T = 30. It is shown in Figure <ref type="figure" target="#fig_9">9</ref>, plotted against Fopt. For imports, its mean is 0.78 (standard deviation is 0.04), for function calls, it is 0.82 (standard deviation 0.08).  Let us illustrate the quality of the ranking by an actual example where T = 10. Table <ref type="table" target="#tab_6">4</ref> shows such a prediction as produced in one of the random splits. Within the validation set, these would be the components to spend extra effort on. Your effort would be well spent, because all of the top ten components actually turn out to be vulnerable. (SgridRowLayout and NsHttpTransaction are outliers, but still vulnerable.) Furthermore, in your choice of ten, you would recall the top four most vulnerable components, two more would still be in the top ten (at predicted ranks 3 and 6), and two more would be in the top twenty (at predicted ranks 7 and 9).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Discussion</head><p>In the simple cost model introduced in Section 5.2, we have m = 10, 452 and V = 424, giving V /m = 0.04. With p = 0.65, we see that Vulture does more than fifteen times better than random assignment.</p><p>For ranking, all Q values are higher than 0.6; the average values are way above that. This more than satisfies our criterion from Section 5.3.</p><p>Therefore, our case study shows three things. First of all, allocating quality assurance efforts based on a Vulture prediction achieves a reasonable balance between effective-  ness and efficiency. Second, it is effective because half of all vulnerable components are actually flagged. And third, Vulture is efficient because directing quality assurance efforts on flagged components yields a return of 70%-more than two out of three components are hits. Focusing on the top ranked components will give even better results. Furthermore, these numbers show that there is empirically an undeniable correlation between imports and function calls on one hand, and vulnerabilities on the other. This correlation can be profitably exploited by tools like Vulture to make predictions that are correct often enough so as to make a difference when allocating testing effort. Vulture has also identified features that very often lead to vulnerabilities when used together and can so point out areas that should perhaps be redesigned in a more secure way.</p><p>Best of all, Vulture has done all this automatically, quickly, and without the need to resort to intuition or human expertise. This gives programmers and managers much-needed objective data when it comes to identify (a) where past vulnerabilities were located, (b) other components that are likely to be vulnerable, and (c) effectively allocating quality assurance effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>Previous work in this area reduced the number of vulnerabilities or their impact by one of the following methods:</p><p>Looking at components' histories. The Vulture tool was inspired by the pilot study by Schröter et al. <ref type="bibr" target="#b30">[29]</ref>, who first observed that imports correlate with failures. While Schröter et al. examined general defects, the present work focuses specifically on vulnerabilities. To our knowledge, this is the first work that specifically mines and leverages vulnerability databases to make predictions. Also, our correlation, precision and recall values are higher than theirs, which is why we believe that focusing on vulnerabilities instead of on bugs in general is worthwhile.</p><p>Evolution of defect numbers. Both Ozment et al. <ref type="bibr" target="#b24">[23]</ref> as well as Li et al. <ref type="bibr" target="#b18">[17]</ref> have studied how the numbers of defects and security issues evolve over time. <ref type="bibr">Ozment et</ref>  Estimating the number of vulnerabilities. <ref type="bibr">Alhazmi et al.</ref> use the rate at which vulnerabilities are discovered to build models to predict the number of as yet undiscovered vulnerabilities <ref type="bibr" target="#b3">[2]</ref>. They use their approach on entire systems, however, and not on source files. Also, in contrast to Vulture, their predictions depend on a model of how vulnerabilities are discovered.</p><p>Miller et al. build formulas that estimate the number of defects in software, even when testing reveals no flaws <ref type="bibr" target="#b21">[20]</ref>. Their formulas incorporate random testing results, information about the input distribution, and prior assumptions about the probability of failure of the software. However, they do not take into account the software's history-their estimates do not change, no matter how large the history is.</p><p>Tofts et al. build simple dynamic models of security flaws by regarding security as a stochastic process <ref type="bibr" target="#b36">[35]</ref>, but they do not make specific predictions about vulnerable software components. Yin et al. <ref type="bibr" target="#b40">[39]</ref> highlight the need for a framework for estimating the security risks in large software systems, but give neither an implementation nor an evaluation.</p><p>Testing the binary. By this we mean subjecting the binary executable-not the source code-of the program in question to various forms of testing and analysis (and then reporting any security leaks to the vendor). This is often done with techniques like fuzz testing <ref type="bibr" target="#b20">[19]</ref> and fault injection; see the book by Voas and McGraw <ref type="bibr" target="#b39">[38]</ref>.</p><p>Eric Rescorla argues that finding and patching security holes does not lead to an improvement in software quality <ref type="bibr" target="#b26">[25]</ref>. But he is talking about finding security holes by third-party outsiders in the finished product and not about finding them by in-house personnel during the development cycle. Therefore, his conclusions do not contradict our belief that Vulture is a useful tool.</p><p>(Statically) examining the source. This is usually done with an eye towards specific vulnerabilities, such as buffer overflows. Approaches include linear programming <ref type="bibr" target="#b13">[12]</ref>, dataflow analysis <ref type="bibr" target="#b15">[14]</ref>, locating functions near a program's input <ref type="bibr" target="#b9">[8]</ref> 7 , axiomatizing correct pointer usage and then checking against that axiomatization <ref type="bibr" target="#b12">[11]</ref>, exploiting semantic comments <ref type="bibr" target="#b17">[16]</ref>, checking path conditions <ref type="bibr" target="#b32">[31]</ref>, symbolic pointer checking <ref type="bibr" target="#b29">[28]</ref>, or symbolic bounds checking <ref type="bibr" target="#b27">[26]</ref>.</p><p>Rather than describing the differences between these tools and ours in every case, we we briefly discuss ITS4, developed by Viega et al. <ref type="bibr" target="#b38">[37]</ref>, and representative of the many other static code scanners. Viega et al.'s requirement was to have a tool that is fast enough to be used as real-time feedback during the development process, and precise enough so that programmers would not ignore it. Since their approach is essentially pattern-based, it will have to be manually extended as new patterns emerge. The person extending it will have to have a concept of the vulnerability before it can be condensed into a pattern. Vulture will probably not flag components that contain vulnerabilities that were unknown at training time, but it will flag components that 7 The hypothesis of DeCast et al. that vulnerabilities occur more in functions that are close to a program's input is not supported by the present study. Many of Mozilla's vulnerable components, such as nsGlobalWindow, lie in the heart of the application. contain vulnerabilities that have been fixed before but have no name.</p><p>Also, since ITS4 checks local properties, it will be very difficult for it to find security-related defects that arise from the interaction between far-away components, that is, components that are connected through long chains of def-use relations. Additionally, ITS4, as it exists now, will be unable to adapt to programs that for some reason contain a number of pattern-violating but safe practices, because it completely ignores a component's history.</p><p>Another approach is to use model checking <ref type="bibr" target="#b4">[3,</ref><ref type="bibr" target="#b5">4]</ref>. In this approach, specific classes of vulnerabilities are formalized and the program model-checked for violations of these formalized properties. The advantage over other formal methods is that if a failure is detected, the model checker comes up with a concrete counter-example that can be used as a regression test case. This too is a useful tool, but like ITS4, it will have to be extended as new formalizations emerge. Some vulnerability types might not even be formalizable.</p><p>Vulture also contains static scanners-it detects features by parsing the source code in a very simple manner. However, Vulture's aim is not to declare that certain lines in a program might contain a buffer overflow, but rather to direct testing effort where it is most needed by giving a probabilistic assessment of the code's vulnerability.</p><p>Hardening the source or runtime environment. This encompasses all measures that are taken to mitigate a program's ability to do damage Hardening a program or the runtime environment is useful when software is already deployed. StackGuard is a method that is representative of the many tools that exist to lower a vulnerability's impact <ref type="bibr" target="#b7">[6]</ref>. Others include mandatory access controls as found in App-Armor <ref type="bibr" target="#b6">[5]</ref> or SELinux <ref type="bibr" target="#b23">[22]</ref>. However, Vulture works on the other side of the deployment divide and tries to direct programmers and managers to pieces of code requiring their attention, in the hope that StackGuard and similar systems will not be needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS AND FUTURE WORK</head><p>We have presented empirical evidence that features correlate with vulnerabilities. Based on this empirical evidence, we have introduced Vulture, a new tool that predicts vulnerable components by looking at their features. It is fast and reasonably accurate: it analyzes a project as complex as Mozilla in about half an hour, and correctly identifies half of the vulnerable components. Two thirds of its predictions are correct.</p><p>The contributions of the present paper are as follows:</p><p>1. A technique for mapping past vulnerabilities by mining and combining vulnerability databases with version archives.</p><p>2. Empirical evidence that contradicts popular wisdom saying that vulnerable components will generally have more vulnerabilities in the future.</p><p>3. Evidence that features correlate with vulnerabilities.</p><p>4. A tool that learns from the locations of past vulnerabilities to predict future ones with reasonable accuracy.</p><p>5. An approach for identifying vulnerabilities that automatically adapts to specific projects and products. Characterizing domains. We have seen that empirically, features are good predictors for vulnerabilities. We believe that this is so because features characterize a component's domain, that is, the type of service that it uses or implements, and it is really the domain that determines a component's vulnerability. We plan to test this hypothesis by studies across multiple systems in similar domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Methods predicted as vulnerable are marked</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Methods predicted as most vulnerable</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>List of dangerous import combinations</head><p>Fine-grained approaches. Rather than just examining features at the component level, one may go for more finegrained approaches, such as caller-callee relationships. Such fine-grained relationships may also allow vulnerability predictions for classes or even methods or functions.</p><p>Evolved components. This work primarily applies to predicting vulnerabilities of new components. However, components that already are used in production code come with their own vulnerability history. We expect this history to rank among the best predictors for future vulnerabilities.</p><p>Usability. Right now, Vulture is essentially a batch program producing a textual output that can be processed by spreadsheet programs or statistical packages. We plan to integrate Vulture into current development environments, allowing programmers to query for vulnerable components.</p><p>Such environments could also visualize vulnerabilities by placing indicators next to the entities (Figure <ref type="figure" target="#fig_10">10</ref>).</p><p>In a recent blog, Bruce Schneier wrote, "If the IT products we purchased were secure out of the box, we wouldn't have to spend billions every year making them secure." <ref type="bibr" target="#b28">[27]</ref> One first step to improve security is to learn where and why current software had flaws in the past. Our approach provides essential ground data for this purpose, and allows for effective predictions where software should be secured in the future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: How Vulture works. Vulture mines a vulnerability database (e.g. a Bugzilla subset), a version archive (e.g. CVS), and a code base, and maps past vulnerabilities to components. The resulting predictor predicts the future vulnerabilities of new components, based on their imports or function calls.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Distribution of vulnerabilities within Mozilla's codebase. A component's area is proportional to its size; its shade of gray is proportional to its number of vulnerabilities. A white box means no vulnerabilities, as is the case for 96% of the components.</figDesc><graphic coords="2,53.76,53.82,502.14,335.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: Mapping Mozilla vulnerabilities to changes. We extract bug identifiers from security advisories, search for the fix in the version archive, and from the corrected files, we infer the component(s) affected by the vulnerability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Extract from nsprpub/pr/tests/sigpipe.c, lines 85ff. Parsing C and C++ is generally only possible after preprocessing: attempting to parse these lines without preprocessing results in a syntax error.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Row vector x 3 Figure 6 :</head><label>36</label><figDesc>Figure 6: The feature matrix X and the vulnerability vector v for imports. The rows of X contain the imports of a certain component as a binary vector: x ik is 1 if component i imports import k. The vulnerability vector contains the number of vulnerabilityrelated bug reports for that component.</figDesc><graphic coords="7,126.12,108.65,120.45,64.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Precision and recall explained. Precision is TP/(TP + FP ); recall is TP/(TP + FN ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Table 3 :</head><label>3</label><figDesc>Creation of SVM, w/classification and regression 0.5 m Approximate running times for Vulture's different phases.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Scatterplot of precision/recall values for the 40 experiments. Figure (a) shows the results for imports, figure (b) shows the results for function calls. The apparent lack of data points is due to overplotting of close-by precision/recall pairs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Scatterplot of Q versus Fopt for the 40 experiments where T = 30. Figure (a) shows the results for imports, figure (b) shows the results for function calls. Higher values are better.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Sketch of a Vulture integration into Eclipse. Vulture annotates methods predicted as vulnerable with red bars. The view "Predictions" lists the methods predicted as most vulnerable. With the view "Dangerous Imports", a developer can explore import combinations that lead to past vulnerabilities.</figDesc><graphic coords="11,117.38,54.83,374.78,280.01" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : The top ten most vulnerable components in Mozilla, sorted by associated Mozilla Foundation Security Advisories (SAs) and bug reports (BRs). Components with equal numbers of SAs get an av- eraged rank.</head><label>1</label><figDesc></figDesc><table><row><cell>Rank</cell><cell>Component</cell><cell cols="2">SAs BRs</cell></row><row><cell># 1</cell><cell>dom/src/base/nsGlobalWindow</cell><cell>14</cell><cell>14</cell></row><row><cell># 2</cell><cell>js/src/jsobj</cell><cell>13</cell><cell>24</cell></row><row><cell cols="2"># 3.5 js/src/jsfun</cell><cell>11</cell><cell>15</cell></row><row><cell cols="2"># 3.5 caps/src/nsScriptSecurityManager</cell><cell>11</cell><cell>15</cell></row><row><cell># 5</cell><cell>js/src/jsscript</cell><cell>10</cell><cell>14</cell></row><row><cell># 6</cell><cell>dom/src/base/nsDOMClassInfo</cell><cell>9</cell><cell>10</cell></row><row><cell># 7</cell><cell>docshell/base/nsDocShell</cell><cell>9</cell><cell>9</cell></row><row><cell># 8</cell><cell>js/src/jsinterp</cell><cell>8</cell><cell>14</cell></row><row><cell># 9</cell><cell>content/base/src/nsGenericElement</cell><cell>7</cell><cell>10</cell></row><row><cell># 10</cell><cell>layout/base/nsCSSFrameConstructor</cell><cell>6</cell><cell>17</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 : Include patterns most associated with vul- nerability. The column labeled "Includes" contains the include pattern; the column labeled</head><label>2</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>Includes</cell></row><row><cell>1.00</cell><cell>13</cell><cell>0</cell><cell>nsIContent.h • nsIInterfaceRequestorUtils</cell></row><row><cell></cell><cell></cell><cell></cell><cell>• nsContentUtils.h</cell></row><row><cell>1.00</cell><cell>14</cell><cell>0</cell><cell>nsIScriptGlobalObject.h • nsDOMCID.h</cell></row><row><cell>1.00</cell><cell>19</cell><cell>0</cell><cell>nsIEventListenerManager.h • nsIPresShell.h</cell></row><row><cell>1.00</cell><cell>13</cell><cell>0</cell><cell>nsISupportsPrimitives.h • nsContentUtils.h</cell></row><row><cell>1.00</cell><cell>19</cell><cell>0</cell><cell>nsReadableUtils.h • nsIPrivateDOMEvent.h</cell></row><row><cell>1.00</cell><cell>15</cell><cell>0</cell><cell>nsIScriptGlobalObject.h • nsDOMError.h</cell></row><row><cell>0.97</cell><cell>34</cell><cell>1</cell><cell>nsCOMPtr • nsEventDispatcher.h</cell></row><row><cell>0.97</cell><cell>29</cell><cell>1</cell><cell>nsReadableUtils.h • nsGUIEvent.h</cell></row><row><cell>0.96</cell><cell>22</cell><cell>1</cell><cell>nsIScriptSecurityManager.h • nsIContent.h</cell></row><row><cell></cell><cell></cell><cell></cell><cell>• nsContentUtils.h</cell></row><row><cell>0.95</cell><cell>18</cell><cell>1</cell><cell>nsWidgetsCID.h • nsContentUtils.h</cell></row></table><note><p>P (V |I) con-</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>tains the conditional probability that a component is vulnerable (V ) if it includes the pattern (I). The columns labeled</head><label></label><figDesc></figDesc><table /><note><p>V ∧ I and !V ∧ I give</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>the absolute numbers of components that are vulnerable and in- clude the set, and of components that are not vul- nerable, but still include the set.</head><label></label><figDesc></figDesc><table /><note><p>of 424, or 13). For function calls, this threshold is raised to 10%, or 42.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 : The top ten most vulnerable compo- nents from a validation set, as predicted by Vul- ture. The column labeled "BRs" shows the number of vulnerability-related bug reports for that compo- nent. Eight of the predicted top ten are actually very vulnerable.</head><label>4</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>al. report a decrease in the rate at which new vulnerabilities are reported, while Li et al. report an increase. Neither of the two approaches allow mapping of vulnerabilities to components or prediction.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.mozilla.org/projects/security/knownvulnerabilities.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>2 Some bug reports in Bugzilla<ref type="bibr" target="#b33">[32]</ref> are not accessible without</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This cautious phrasing is necessary because of the possibility of inlining.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>For this, we use χ 2 tests if the entries in the corresponding contingency table are all at least</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>5, and Fischer exact tests if at least one entry is 4 or less.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>Two sets of n-dimensional points are said to be linearly separable if there exists an n -1-dimensional hyperplane that separates the two sets. Overfitting occurs when the estimation error in the training data goes down, but the estimation error in the validation data goes up.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>This was suggested to us by the anonymous reviewers.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers for their helpful comments. We also thank the Mozilla team for making their databases available. David Schuler and Andrzej Wasylkowski provided valuable feedback on earlier revisions of this paper. Thomas Zimmermann is funded by a stipend from the DFG-Graduiertenkolleg "Leistungsgarantien für Rechnersysteme".</p><p>Vulture is part of the "Mining software archives" project at Saarland University. For more information, see http://www.st.cs.uni-sb.de/softevo/</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast algorithms for mining association rules</title>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramakrishnan</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Int&apos;l Conf. on Very Large Data Bases, VLDB</title>
		<editor>
			<persName><forename type="first">Jorge</forename><forename type="middle">B</forename><surname>Bocca</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Matthias</forename><surname>Jarke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</editor>
		<meeting>20th Int&apos;l Conf. on Very Large Data Bases, VLDB</meeting>
		<imprint>
			<biblScope unit="page" from="487" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Morgan</forename><surname>Kaufmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994-09">September 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Security Vulnerabilities in Software Systems: A Quantitative Perspective</title>
		<author>
			<persName><forename type="first">Omar</forename><surname>Alhazmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yashwant</forename><surname>Malaiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Indrajit</forename><surname>Ray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">3645</biblScope>
			<biblScope unit="page" from="281" to="294" />
			<date type="published" when="2005-08">2005. August 2005</date>
			<publisher>Springer Verlag</publisher>
			<pubPlace>Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Model checking one million lines of C code</title>
		<author>
			<persName><forename type="first">Drew</forename><surname>Hao Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>11th Annual Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2004-02">February 2004</date>
			<biblScope unit="page" from="171" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">MOPS: An infrastructure for examining security properties of software</title>
		<author>
			<persName><forename type="first">Hao</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th ACM Conf. on Computer and Communications Security (CCS)</title>
		<meeting>9th ACM Conf. on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2002-11">November 2002</date>
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Apparmor linux application security</title>
		<author>
			<persName><forename type="first">Crispin</forename><surname>Cowan</surname></persName>
		</author>
		<ptr target="http://www.novell.com/linux/security/apparmor/" />
		<imprint>
			<date type="published" when="2007-01">January 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">StackGuard: Automatic adaptive detection and prevention of buffer-overflow attacks</title>
		<author>
			<persName><forename type="first">Crispin</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Calton</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Walpole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peat</forename><surname>Bakke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Grier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Perry</forename><surname>Wagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heather</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th USENIX Security Conf</title>
		<meeting>7th USENIX Security Conf<address><addrLine>San Antonio, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-01">January 1998</date>
			<biblScope unit="page" from="63" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Hipikat: A project memory for software development</title>
		<author>
			<persName><forename type="first">Davor</forename><surname>Cubranic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gail</forename><forename type="middle">C</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janice</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kellogg</forename><forename type="middle">S</forename><surname>Booth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="446" to="465" />
			<date type="published" when="2005-06">June 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Characterizing the security vulnerability likelihood of software functions</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Dacosta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Dahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Spiros</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vassilis</forename><surname>Prevelakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Proc. 2003 Int&apos;l Conf. on Software Maintenance (ICSM&apos;03)</title>
		<imprint>
			<date type="published" when="2003-09">September 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">Evgenia</forename><surname>Dimitriadou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Hornik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Friedrich</forename><surname>Leisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Weingessel</surname></persName>
		</author>
		<title level="m">Misc Functions Department of Statistics</title>
		<imprint>
			<date type="published" when="1071">e1071. 2006</date>
			<biblScope unit="volume">1071</biblScope>
			<biblScope unit="page" from="5" to="13" />
		</imprint>
		<respStmt>
			<orgName>TU Wien</orgName>
		</respStmt>
	</monogr>
	<note>R package version</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Populating a release history database from version control and bug tracking systems</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Pinzger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harald</forename><surname>Gall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Software Maint e nance (ICSM&apos;03)</title>
		<meeting>Int&apos;l Conf. on Software Maint e nance (ICSM&apos;03)<address><addrLine>Amsterdam, Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003-09">September 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Static detection of pointer errors: An axiomatisation and a checking algorithm</title>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronan</forename><surname>Caugne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">Le</forename><surname>Métayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Programming</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="125" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Buffer overrun detection using linear programming and static analysis</title>
		<author>
			<persName><forename type="first">Vinod</forename><surname>Ganapathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Somesh</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Chandler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Melski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Vitek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th ACM Conf. on Computer and Communications Security (CCS)</title>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The Elements of Statistical Learning: Data Mining, Inference, and Prediction</title>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Hastie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Tibshirani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerome</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Springer Series in Statistics</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pixy: A static analysis tool for detecting web application vulnerabilities (short paper)</title>
		<author>
			<persName><forename type="first">Nenad</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Engin</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2006-05">May 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">SparseM: Sparse Linear Algebra</title>
		<author>
			<persName><forename type="first">Roger</forename><surname>Koenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pin</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">R package version 0</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Statically detecting likely buffer overflow vulnerabilities</title>
		<author>
			<persName><forename type="first">David</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2001-08">August 2001</date>
			<biblScope unit="page" from="177" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Have things changed now? An empirical study of bug characteristics in modern open source software</title>
		<author>
			<persName><forename type="first">Zhenmin</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuanhui</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengxiang</forename><surname>Zhai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Architectural and System Support for Improving Software Dependability</title>
		<meeting>Workshop on Architectural and System Support for Improving Software Dependability</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006-10">2006. October 2006</date>
			<biblScope unit="page" from="25" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient algorithms for discovering association rules</title>
		<author>
			<persName><forename type="first">Heikki</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannu</forename><surname>Toivonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Inkeri</forename><surname>Verkamo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Knowledge Discovery in Databases: Papers from the 1994 AAAI Workshop</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An empirical study reliability of UNIX utilities</title>
		<author>
			<persName><forename type="first">Barton</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lars</forename><surname>Fredriksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bryan</forename><surname>So</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="32" to="44" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Estimating the probability of failure when testing reveals no failures</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Morell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Noonan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Nicol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Murrill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Voas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="33" to="43" />
			<date type="published" when="1992-01">January 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Mining metrics to predict component failures</title>
		<author>
			<persName><forename type="first">Nachiappan</forename><surname>Nagappan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th Int&apos;l Conf. on Software Engineering</title>
		<meeting>29th Int&apos;l Conf. on Software Engineering</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005-11">November 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title/>
		<ptr target="http://www.nsa.gov/selinux/" />
	</analytic>
	<monogr>
		<title level="j">National Security Agency. Security-enhanced linux</title>
		<imprint>
			<date type="published" when="2007-01">January 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Milk or wine: Does software security improve with age?</title>
		<author>
			<persName><forename type="first">Andy</forename><surname>Ozment</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><forename type="middle">E</forename><surname>Schechter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Usenix Security Symposium</title>
		<meeting>15th Usenix Security Symposium</meeting>
		<imprint>
			<date type="published" when="2006-08">August 2006</date>
			<biblScope unit="page" from="93" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">R: A Language and Environment for Statistical Computing</title>
		<author>
			<orgName type="collaboration">R Development Core Team</orgName>
		</author>
	</analytic>
	<monogr>
		<title level="m">R Foundation for Statistical Computing</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Is finding security holes a good idea?</title>
		<author>
			<persName><forename type="first">Eric</forename><surname>Rescorla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security and Privacy</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="14" to="19" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Symbolic bounds analysis of pointers, array indices, and accessed memory regions</title>
		<author>
			<persName><forename type="first">Radu</forename><surname>Rugina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN &apos;00 conference on Programming language design and implementation</title>
		<meeting>ACM SIGPLAN &apos;00 conference on Programming language design and implementation</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="182" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Do we really need a security industry? Wired</title>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Schneier</surname></persName>
		</author>
		<ptr target="http://www.wired.com/politics/security/commentary/securitymatters/2007/%05/securitymatters_0503" />
		<imprint>
			<date type="published" when="2007-05">May 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Symbolic pointer analysis for detecting memory leaks</title>
		<author>
			<persName><forename type="first">Berhard</forename><surname>Scholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johann</forename><surname>Blieberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Fahringer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2000 ACM SIGPLAN workshop on Partial evaluation and semantics-based program manipulation</title>
		<meeting>2000 ACM SIGPLAN workshop on Partial evaluation and semantics-based program manipulation</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="104" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Predicting component failures at design time</title>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Schröter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Int&apos;l Symposium on Empirical Software Engineering</title>
		<meeting>5th Int&apos;l Symposium on Empirical Software Engineering<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-09">September 2006</date>
			<biblScope unit="page" from="18" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">When do changes induce fixes?</title>
		<author>
			<persName><forename type="first">Jacek</forename><surname>Śliwerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int&apos;l Workshop on Mining Software Repositories</title>
		<meeting>Second Int&apos;l Workshop on Mining Software Repositories</meeting>
		<imprint>
			<date type="published" when="2005-05">May 2005</date>
			<biblScope unit="page" from="24" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient path conditions in dependence graphs for software safety analysis</title>
		<author>
			<persName><forename type="first">Gregor</forename><surname>Snelting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Torsten</forename><surname>Robschink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Krinke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Int&apos;l Conf. on Software Engineering</title>
		<meeting>24th Int&apos;l Conf. on Software Engineering<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<ptr target="http://www.bugzilla.org" />
		<title level="m">The Mozilla Foundation. Bugzilla</title>
		<imprint>
			<date type="published" when="2007-01">January 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<ptr target="http://www.mozilla.org/projects/security/known-vulnerabilities.html" />
		<title level="m">The Mozilla Foundation. Mozilla foundation security advisories</title>
		<imprint>
			<date type="published" when="2007-01">January 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<ptr target="http://www.mozilla.org/" />
		<title level="m">The Mozilla Foundation. Mozilla project website</title>
		<imprint>
			<date type="published" when="2007-01">January 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Towards an analytic model of security flaws</title>
		<author>
			<persName><forename type="first">Chris</forename><surname>Tofts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Monahan</surname></persName>
		</author>
		<idno>2004-224</idno>
		<imprint>
			<date type="published" when="2004-12">December 2004</date>
			<pubPlace>Bristol, UK</pubPlace>
		</imprint>
		<respStmt>
			<orgName>HP Trusted Systems Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Naumovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vapnik</forename></persName>
		</author>
		<title level="m">The Nature of Statistical Learning Theory</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Token-based scanning of source code for security problems</title>
		<author>
			<persName><forename type="first">John</forename><surname>Viega</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Bloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tadayoshi</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><surname>Mcgraw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transaction on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="238" to="261" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Software Fault Injection: Innoculating Programs Against Errors</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Voas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><surname>Mcgraw</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">On estimating the security risks of composite software services</title>
		<author>
			<persName><forename type="first">Jian</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chunqiang</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaolan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Mcintosh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PASSWORD Workshop</title>
		<meeting>PASSWORD Workshop</meeting>
		<imprint>
			<date type="published" when="2006-06">June 2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
