<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Read-Only Transactions in a Distributed Database</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hector</forename><surname>Garcia-Molina</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University</orgName>
								<address>
									<country>GIO</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">WIEDERHOLD Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Read-Only Transactions in a Distributed Database</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">325F8A707CF5BDD8B9DDEC128CA7A7C5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Computer-Communication Networks]: Distributed Systems--distributed databases</term>
					<term>H.2.4 [Database Management]: Systems--distributed systems</term>
					<term>query processing concurrency control, consistency, currency, query, R insularity, read-only transaction, schedule, serializability, transaction, transaction processing algorithm 2. BASIC CONCEPTS</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A read-only transaction or query is a transaction which does not modify any data. Read-only transactions could be processed with general transaction processing algorithms, but in many cases it is more efficient to process read-only transactions with special algorithms which take advantage of the knowledge that the transaction only reads. This paper defines the various consistency and currency requirements that read-only transactions may have. The processing of the different classes of read-only transactions in a distributed database is discussed. The concept of R insularity is introduced to characterize both the read-only and update algorithms. Several simple update and readonly transaction processing algorithms are presented to illustrate how the query requirements and the update algorithms affect the read-only transaction processing algorithms.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Distributed</head><p>databases have become a very active research area. Within this research area, the transaction processing problem has been getting considerable attention. A transaction is (informally) a user application request or program that has been submitted to the distributed database. The distributed database system must efficiently process these transactions in a way that does not violate the data integrity or consistency constraints <ref type="bibr" target="#b3">[4]</ref>.</p><p>For example, suppose that data on a person's salary are duplicated at two nodes (sites) in the system. Since the two data items represent the same person's salary, the two items should have the same value. However, if two transactions attempt to modify the salary concurrently, it is possible for the two data items to Authors' addresses: H. Garcia-Molina, Department of Electrical Engineering and Computer Science, School of Engineering/Applied Science, Engineering Quadrangle, Princeton University, Princeton, NJ, 08540; G. Wiederhold, Department of Computer Science, Stanford University, Stanford, CA, 94305. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. 0 1982 ACM 0362-5915/82/0600-0209 $00.75 end up with different values. A transaction processing algorithm, or concurrency control mechanisms, is needed to prevent these types of problems. A large number of such algorithms for distributed databases have been proposed [l, <ref type="bibr">3, 7, 10, etc.]</ref>.</p><p>A read-only transaction or query is a transaction that does not modify the distributed database. For example, a transaction to check the balance of a given checking account in a bank is a query. Since queries are still transactions, they can be processed using the algorithms for arbitrary transactions. However, it is also possible to use special processing algorithms for queries in order to improve efficiency. With this approach, the specialized algorithm can take advantage of the knowledge that no data will be modified by the transaction. In this paper, we explore these ideas on queries, study the requirements for these special transactions, and analyze the types of algorithms needed for processing them. The emphasis of this paper is on discussing the issues and available design choices instead of on the presentation of a particular approach.</p><p>The idea of using the "type" of a transaction in order to improve efficiency is not new <ref type="bibr" target="#b1">[2]</ref>. However, this has been a somewhat controversial idea because it is not clear if it is possible to know beforehand all of the transaction types that will run on a distributed database system. Nevertheless, we believe that the transaction type idea does have great potential in the special case where there are only two types: read-only transactions and update (i.e., not read-only) transactions. The reasons for this are that (1) we believe that there will be a high percentage of read-only transactions in most systems, and (2) we believe that it wilI be fairly easy to distinguish a read-only transaction from an update transaction.</p><p>In this paper we avoid two important issues of transaction processing: directory management and transaction optimization. That is, we do not consider how a transaction locates the data it needs, nor do we consider how a transaction decides where and in what order to read the data it needs. We assume that by the time a user transaction is given to the transaction processing algorithm it has been translated into a series of actions that reference particular data values located at particular nodes.</p><p>In order to simplify the presentation, we make another important assumption about the distributed database system. We assume that no failures occur in the system. This is a reasonable assumption because crash recovery for queries is straightforward.</p><p>Since a query does not modify the data, there is no recovery problem with an unfinished read-only transaction.</p><p>In Section 2 we present the basic concepts that are needed for this paper. Then in Section 3, we study read-only transactions and the various user requirements that they may have. In Section 4 we discuss how the different classes of queries can be processed efficiently. Finally, some conclusions from this study are presented in Section 5. mechanisms for maintaining consistency in a distributed database differ significantly from those in a centralized database.)</p><p>A distributed database is a collection of named items. Each item has a name and between 1 and n values associated with it, where n is the number of nodes in the system. Each value for a given item is stored at a different node of the system. In addition, each item i has associated with it a set S(i). Set S(i) is the set of the nodes which have a value for item i stored in them. We assume that all sets S(i) are not empty and, at most, have all n nodes in them. We use the notation d <ref type="bibr">[i, x]</ref> to represent the value of the item named i at node LX. For nodes y not in S(i), d[i, y] is undefined. The values for a given item i at different nodes should be the same (i.e., d[i, X] should equal d[i, z] for all nodes X, z in S(i)). However, owing to the updating activity, the values may be temporarily different.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows a sample distributed-database.</p><p>There are four items in this distributed database: item "deposits" represents the total deposits made to a certain bank account, item "withdrawals" represents the total withdrawals from the same account, item "balance" represents the balance of the account, while item "name" represents the name of the person who owns the account. As can be seen in Figure <ref type="figure" target="#fig_0">1</ref>, the balance of the account is reported to be 60 dollars at nodes 1 and 2. That is, d[balance, l] = d[balance, 2]= 60. Since node 3 does not have a value for item "balance," d [balance, 31 is undefined.</p><p>In addition to items and values, a distributed database has a collection of consistency constraints. A consistency constraint is a predicate defined on the database which describes the relationships that must hold among the items and their values. For example, the distributed database of Figure <ref type="figure" target="#fig_0">1</ref> may have the consistency constraint "deposits -withdrawals = balance." In addition to this type of constraint, distributed databases always have the constraint that the values of an item should be equal. We call this constraint the implicit constraint simply to differentiate it from the other user-dependent constraints. We say that a distributed database is consistent (or is in a consistent state) if all the consistency constraints are satisfied by the data values.</p><p>We can use the d[i, X] notation to express the consistency constraints. For example, the constraint "deposits -withdrawals = balance" becomes "d  Operations on the data are grouped into transactions. Each transaction T is a sequence of actions which preserve consistency. One way of representing an action is by a triplet (Z', a, d[i, x]) where T is the name of the transaction which performs the action, a is the action type (e.g., read, write), and d[i, X] is the data value which is referenced by the action (d[i, x] must be defined). Notice the difference between T, the name of the transaction, and T, the transaction itself. All transactions must preserve consistency. That is, if a transaction is run on a consistent distributed database and without interference from other transactions, then the transaction should leave the distributed database in a consistent state.</p><p>Figure <ref type="figure" target="#fig_2">2</ref> shows a transaction T, that registers a 5-dollar deposit into the account of Figure <ref type="figure" target="#fig_0">1</ref>. The transaction is presented in an informal notation which describes the actual operations performed. The formal notation for TI as a sequence of actions is also shown in Figure <ref type="figure" target="#fig_2">2</ref>. Notice that the formal representation of Tl does not specify that the value that is written into d[balance, l] is 5 dollars more than its old value, nor that the values written into d[balance, l] and d[balance, 21 are the same. However, as long as we know that Tl preserves consistency, the information given in Figure <ref type="figure" target="#fig_2">2</ref> is sufficient to study the potential conflicts of Tl with other transactions.</p><p>A schedule S of a set of transactions T,, Tz, . . . , T,,, represents a particular order in which the actions of the transactions were performed in the system. A schedule is also a sequence of actions. The actions of schedule S are simply the actions of the transactions Tl, Tz, . . . , T,,, interleaved in a way which preserves the relative order of the original actions. That is, if (Ti, al, d[i~, XI]) preceded (T;, ~2, d[iz, XZ]) in Tj (for 1 sj 5 m), then (Tj, ~1, d[il, xl]) must precede (Tj, ~2, cE[k, XZ]) in S. Figure <ref type="figure" target="#fig_4">3</ref> shows a schedule for transactions Tl and Tz, where transaction Tl is given in Figure <ref type="figure" target="#fig_2">2</ref>, and transaction TZ is a similar transaction which withdraws 10 dollars from the same account. The informal notation for S is also given. Some schedules have undesirable effects. For example, if the schedule named S in Figure <ref type="figure" target="#fig_4">3</ref> is run on a consistent distributed database, then the distributed database will be left in an inconsistent state. (Try it.) Hence, it is important to discover which schedules are "good" and which have undesirable effects. One set   of "good" schedules are those schedules which are serial or which are equivalent to serial. Serial schedules are one&amp; where transactions are performed one at a time, and are clearly "good." A schedule which is equivalent to a serial schedule is one which has the same effect on the data as some serial schedule. We call this set of ccgood" schedules consistent schedules. The following definitions and theorem [from 41 state these concepts more precisely. As we will see later on in this paper, there are some schedules that some users might consider "good" which are not "consistent" by the given definitions. However, all consistent schedules are "good" in the sense that they do not cause any undesirable effects or violate the distributed database consistency. Furthermore, it is relatively easy (with the theorem) to check whether a schedule is consistent, so most researchers have chosen consistent schedules as their definition of "good" schedules. In this paper we also use this definition.</p><p>A transaction processing algorithm should process transactions in such a way that the resulting schedule is consistent. A few of these algorithms are described in Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">READ-ONLY TRANSACTIONS</head><p>A read-only transaction or query is a transaction without any write actions. Such a transaction simply reads data from the distributed database and presents the values obtained to a user of the system. The user cannot then make an update to the distributed database based on the data obtained from the query. If the user wishes to submit such an update, the update transaction must first read the data again to check whether the data have changed.</p><p>We believe that in many distributed database applications, queries represent a very significant proportion of the total transactions submitted. Hence it is important to understand what classes of queries exist, as well as how they can be processed efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Requirements for Queries</head><p>Users who issue queries may have varying requirements for the transactions. These user requirements can be divided into two independent classes: the consistency and the currency requirements. The consistency requirements specify the "degree" of consistency needed by the read-only transaction. (Gray <ref type="bibr" target="#b5">[6]</ref> discusses degrees of consistency for arbitrary transactions; here we define different but related degrees for queries.) A query may have strong, weak, or no consistency requirements.</p><p>(1) No consistency requirement. If a query Q has no consistency requirement, then &amp;I may read data which are inconsistent.</p><p>(2) Weak consistency. If a query Qz requires weak consistency, then Qz must obtain a consistent view of the data. This means that all the consistency constraints that can be fully evaluated with the data read by Qz must be true.</p><p>(3) Strong consistency. If a query Q3 requires strong consistency, then the schedule of all the update transactions (i.e., not read-only) together with all other strong consistency queries must be consistent. Notice that Q3 also obtains a consistent view of the data. (Since a consistent schedule is equivalent to some serial schedule, all transactions in the schedule read consistent data.) Thus all Read-Only Transactions in a Distributed Database l 215 queries with the strong consistency requirement also satisfy the weak consistency requirement.</p><p>In Section 4.1.2 we see that queries with the weak requirement do not necessarily satisfy the strong requirement. The example in that section also clarifies the difference between the weak and strong requirements.</p><p>The currency requirement of a query specifies what update transactions should be reflected by the data read. There are several ways in which the currency requirement can be stated; here we discussthree common ways.</p><p>(1) t-vintage requirement. A query Q4 can require data as they existed at a given (previous) time t. This means that the data read by Q4 must reflect the modifications of all update transactions "committed" in the distributed system before time t, and must not reflect modification due to any update transactions "committed" after time t. Intuitively, the commit time of an update transaction T is the time when any data modification produced by T first becomes available anywhere in the system. In many cases, the time of the first write action of T at any node would be the commit time of T. However, if the data written by T are protected by locks or any such mechanism that makes the new values written inaccessible, then the commit point is not reached until the new values actually become accessible to other transactions. (Here, as in the rest of the paper, we use the concept of time in an intuitive fashion. These ideas could be formalized using the concepts in [S].) We call transactions like Q4 t-vintage queries.</p><p>(2) t-bound requirement. A query Q5 can request that the data it reads at least reflect all update transactions committed before time t. The data may or may not reflect any transactions committed after time t. We call transactions like QE, tbound queries. A special case occurs when t is the current time (i.e., the time when Qs is submitted). In this case, QE, requires the latest or most up-to-date data available. Such transactions are called latest-bound queries.</p><p>(3) No currency requirement. A query Q6 can have no currency requirements. This means that the data read by Q6 can reflect any set of update transactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">An Example</head><p>Let us illustrate the consistency and currency requirements with a simple example. Consider once again the distributed database of Figure <ref type="figure" target="#fig_0">1</ref>, but for simplicity, let us assume that node 3 does not exist. Suppose that there are three update transactions T,, Tz, and Ts. Transaction TI (shown in Figure <ref type="figure" target="#fig_2">2</ref>) is submitted at time tl and records  If Q is a strong consistency query, then it can only read those same consistent values. However, if Q has no consistency requirement, it can read anything: do, Ml(do), Ml(Mz(do)), iS(Ml(&amp;)), and so on.</p><p>If query Q is t-vintage where tz c t &lt; t3, then it should read data that reflect only those transactions submitted before time t, that is Tl and Tz. Hence, in this case, Q can read Mz(M~(do)) or Ml(Mz(do)) only. If in addition to being t-vintage, Q is a weak consistency (or strong consistency) query, then only the values M2(Ml(do) would be acceptable. If Q is a t-bound query with t2 &lt; t &lt; t3, then Q</p><formula xml:id="formula_0">can read MAMl(do)), Ml(M&amp;&amp;)), ~3(~2(~1(&amp;))),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M~(&amp;(Mddo))), and my other</head><p>data which reflect Ml, Mz, M3 in any order. However, neither Ma(Mz(do)) nor M1(M3(do)) would be acceptable to thii t-bound query. If in addition to being tbound, Q is a weak consistency (or strong consistency) query, then only the values M~(Ml(do)) or M3(M2(Ml(do)))</p><p>would be acceptable to Q. If Q is a latest bound (i.e., k-bound) query, then any data which reflect Ml, it&amp;, MS in any order are acceptable, but if Q is also weak (or strong) consistent, then only M,(M,(M,(do))) is acceptable. Finally, if Q has no currency requirement, then it can read anything: do, Mu, Mz(do), Mz(Ml(do)), M~(Mz(do)), etc.</p><p>In this example we have not described how the query Q could go about reading the data it needs. (We did not even consider reading data at node 1.) The example simply discussed what data would be acceptable to Q depending on its user-Read-Only Transactions in a Distributed Database * 217 defined consistency and currency requirements. The algorithms for processing the different types of queries are discussed in Section 4. This example does not illustrate the difference between weak consistency and strong consistency queries. An example which illustrates this difference is given in Section 4.1.2. In this section we discuss why the different query classes are needed. For instance, it might seem that a query with no currency or consistency requirements is not very useful because, as the previous example illustrated, it may produce data which "does not make much sense." On the other hand, queries with no requirements, which we will call free queries, are extremely simple and efficient to process. All that has to be done to process free queries is to find the nearest copy of the requested data and read it, without worrying about the consistency of the data or how old the data are. So, in many applications, users may be willing to sacrifice consistency and currency for efficiency. Furthermore, in a well-designed distributed database system, free queries should produce results that are not too old. For example, a warehouse manager might want a rough idea of where the inventory stands. The manager does not really care if the data are obtained 15 or 30 minutes old. The manager might not mind that the total number of parts reported does not exactly match the sum of the itemized entries in the report obtained (which may be a consistency violation). As another example, consider a free query which computes an average salary for a large set of employees. The result might not be accurate if some of the salaries are being updated during the long period that the averaging query is running. But the user might decide that such occasional conflicts will not alter the average significantly. Furthermore, not running the averaging query as a free query will produce long delays in other transactions that access the salary data.</p><p>Another case in which free queries are valuable is that of one-item queries. A query that only reads one item value will always give a consistent view of the data. (The last update transaction that wrote a value into the item must have made sure that the written value satisfied any consistency constraints dealing exclusively with the item. This assumes that update transactions do not write intermediate values out to the database.) Therefore, the simple algorithm for processing free queries can be used for one-item queries, and the result will always be consistent. In many systems one-item queries are common, and considerable effort can be saved if we use an efficient method like the free query mechanism for performing these queries.</p><p>Clearly, not all queries in a system can be free. In some queries, a consistent view of the data is required. For instance, the checking account monthly statement that is sent to a bank customer must be consistent (e.g., the sum of the cashed checks should equal the total debits entry). Usually, the query to print the monthly statement does not have any currency requirements because any checks missed one month will simply be reported the next. (If the checking account yields an interest, then there may be some currency requirements.)</p><p>For an example of a t-vintage query, consider the case of a tax auditor examining the computerized records of a company. The auditor may be interested in looking at the database as it existed December 31, 1960, at 12 : 00 midnight. Queries of December 31, 1960, 12 : 00 midnight-vintage will provide the auditor with the desired results. Such queries would probably be weak (or strong) consistent too. But in some cases, like that of a one-item transaction, no consistency requirement may be necessary.</p><p>In some situations it may be necessary to obtain the latest information that is available in the system. For example, a general who has to decide whether or not to fire a missile at an incoming airplane will use a latest-bound query to obtain the latest information on the airplane's position and speed.</p><p>To see when a t-bound query with t different from the current time could be used, consider the case of a distributed database node which becomes isolated from the rest of the system at time tl because of a communications failure. (True, we have assumed that no failures occur, but let us make this small exception.) In this case, any latest-bound queries submitted after time tl at the isolated node will be delayed until the failure is repaired. (While the node is isolated, it cannot tell whether other update transactions are being processed by the rest of the system.) Instead of waiting, users may prefer to submit tl-bound queries to obtain at least the latest data available before the crash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PROCESSING QUERIES</head><p>It is now time to discuss how queries can be processed. The approach we take in this paper is that queries are processed with a special algorithm that is different from the update transaction processing algorithm. This way, queries can be processed more efficiently because the algorithm for processing them can take advantage of the fact that no data will be modified by these transactions.</p><p>In order to use a special query algorithm, we must assume that it is possible a priori to distinguish queries from the other transactions. This is a reasonable assumption because the transaction programmer can usually tell if the transaction has no intention of updating the database. Hence, transactions can be marked as read-only from their inception. We also assume that the consistency and currency requirements for each query are given when the query is initiated. If the requirements are unknown, then some standard default requirements could be made.</p><p>Although it is difficult to evaluate the efficiency of query processing algorithms, it is possible to define one evaluation criterion which is very useful. Definition 4. Suppose that a query Q is submitted at a certain node x (by a user located at node x). We say that query Q is insular if all the items referenced by Q have values at the node where Q was submitted.</p><p>Depending on the consistency and currency requirements-of insular query Q, the query processing algorithm may or may not be able to process Q locally at node x, without the need to communicate or synchronize with other nodes. Therefore, we introduce the following definition. Definition 5. If a query algorithm can process an insular query Q with requirement R at the node where Q was submitted, we say that this is an R insular algorithm.</p><p>For example, an algorithm which can process weak consistency insular queries at the submission node of the query is a weak consistency insular algorithm. We expect an R insular algorithm to be considerably superior to one which is not R insular, at least as far as R queries are concerned. Thus R insularity is an important characteristic of an algorithm, which can be used for comparing and evaluating query processing algorithms. At this point it would be nice if we could simply present one query algorithm that is R insular for all possible requirements R. Unfortunately, this is not possible because the query algorithm is closely related to the algorithm used for processing update transactions. Thus, for each possible update algorithm, we have to design a different query algorithm. Furthermore, with some update algorithms it is not possible to have query algorithms with all the desirable properties. For example, with certain update algorithms it is impossible to process weak or strong consistency insular queries at their originating node. That is, for those update algorithms there are no weak or strong consistency insular algorithms. This means that we can also use the R insular property to characterize update algorithms. Definition 6. We say that an update transaction processing algorithm is R insular if there exists an R insular query algorithm that can be used with that update algorithm.</p><p>We consider R insularity an important feature of update algorithms because efficient query processing hinges on this feature. In the following section we present several examples to illustrate some of the concepts we have defined so far. Then in Section 4.2, we consider the issues involved in processing nonsingular queries. Queries with t-vintage and t-bound requirements are not covered until Section 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Examples of R Insular Update Algorithms</head><p>In this section we present four update algorithms with various interesting R insularity properties. Recall that an update algorithm R insular if there exists a query algorithm capable of locally processing insular queries with requirement R.</p><p>Since we are interested in insular queries, let us assume in this section that the data are completely replicated at all nodes of the system. That is, assume that all items i have a value d[i, X] at a node x of the system. This will make all queries insular and will simplify our examples. After the examples, we return to the general case in order to discuss noninsular queries.</p><p>Before starting with the examples, let us point out that the update algorithms we present are extremely simple and possibly not very efficient. The purpose of the examples is to illustrate how queries can be processed and not how to design efficient update algorithms. But let us also point out that the algorithms we show are just simplified versions of some popular (and more efficient) update algorithms, where both the simple and the original algorithms have the same features with respect to queries. In the CCA, a node of the distributed database is selected as the "central" site. This central node processes all update transactions one at a time, and sends messages to all other nodes giving them new values. We now give a brief description of the CCA. Figure <ref type="figure" target="#fig_12">5</ref> depicts the steps of the CCA in a 4-node system.</p><p>(1) Update transaction T arrives at node x from a user. (Recall that we assume that all data are replicated at every node in the system.) (2) Node x forwards transaction T to the central node. The CCA processes update transactions one at a time, without interleaving with other update transactions. Therefore, any schedule of update transactions produced by the CCA is serial and hence consistent.</p><p>Now suppose that a query Q, which desires a consistent view of the database, arrives at a node x. Since all items have local values, query Q is insular. Notice that between update transactions, the distributed database is consistent. Hence, if Q reads its data at node x "between" update transactions, it will get a consistent view. In other words, node x can process Q by waiting until the current update transaction (if any) completes at node x and then by delaying any actions of the following update transaction until Q completes. (The following transaction can be delayed by delaying the acknowledgment for the previous one.) What we have just described is a local processing algorithm for queries. Let us call this algorithm the atomic algorithm (AA) because queries are performed as if they were atomic operations.</p><p>The AA gives a consistent view of the data and is therefore a weak consistency insular query algorithm. As a matter of fact, the AA is also a strong consistency insular algorithm. To show this, we must show that any schedule produced by the CCA and the AA is consistent (although this may be obvious to some readers).</p><p>Instead of immediately showing that the AA is strong consistency insular, let us briefly describe another significantly more efficient query processing algorithm which can also be used for processing strong (and weak) consistency insular queries. After presenting the second algorithm, we show that both algorithms have the strong consistency insular characteristic.</p><p>The local locking algorithm (LLA) uses local locks to guarantee that the local queries do not conflict with the update transactions. A local lock is assigned to every value d[i, X] at node x (for all nodes x). Before any transaction (query or update) can reference (i.e., read or write) an item value, it must request the lock for that value. Once obtained, the lock gives that transaction exclusive access to the value. When the transaction completes at node x (but possibly not at other nodes), all local locks held by the transaction are released. Other waiting transactions may then be given the newly released locks. Notice that the local lock manager (which is just the LLA) does not need to communicate with other nodes in order to decide whether to grant or release a lock. (In the CCA, a node can easily tell which is the last action of an update transaction at a node. It is the last write of the "perform update" message. In other update algorithms, it is also possible to identify the last action of a transaction at a node.)</p><p>The LLA gives queries a consistent view of the data because whenever a query Q sees the effects of an update transaction T1, then Q sees the complete effects of TI and, also, Q sees the complete effects of any update transaction Tz that preceded Tl. In other words, the LLA guarantees that in any schedule S, the following conditions hold:  We can now show that the schedules produced by the CCA and LLA are consistent and thus that strong consistency queries can be processed locally. As a matter of fact, any query algorithm that satisfies Conditions 1 and 2 has this property. For example, the AA which processes queries as if they were atomic operations also satisfies these conditions and is hence also strong consistency insular.</p><p>Before presenting the following theorem, let us define a binary relation which will be useful in the theorem's proof. Let binary relation "GE" be defined on the set of query and update transactions of a schedule S as follows: T1 &lt; TZ iff all actions of Tl precede all actions of T2 in S. Notice that "&lt;&lt;" is a transitive and ii-reflexive relation. That is, Tl -=K Tz and Tz &lt;&lt; T3 implies Tl -=K T3, and Tl&lt;&lt; Tl is false, for all transactions Tl, T2, and Ts. THEOREM 2. All schedules produced by the CCA and an insular query processing algorithm which satisfies Conditions 1 and 2 are consistent. PROOF. Suppose that there is a cycle in the "&lt;" relation for S. This cycle can have update transactions or queries. Choose any update transaction (there must be one) and call it Tl. Call the other update transactions along the cycle Tz, Ts, TG..., T,,,. If a given update transaction appears more than once, it simply gets two names. In particular, Tl = T,. Now take any pair of update transactions Ti, Ti+l. There are two cases: (1) Ti &lt; Ti+l. This implies that Ti &lt;&lt; Ti+l because the CCA is serial. (2) Ti &lt; Q &lt; Ti+l for some query Q. (There can only be one query between Ti and Ti+l because queries cannot have dependencies.) Here, Ti # Ti+l because of Condition 1 of the query algorithm. By Condition 2, there is an action of Ti which precedes Ti+l , SO Ti &lt;&lt; Ti+l because the CCA is serial. Since for every pair Ti, Ti+l we have Ti &lt;&lt; Ti+l, then we must have Tl &lt;&lt; T2 &lt;&lt; ---&lt;&lt; T,. This, in turn, implies that Tl &lt;&lt; T,, (since "&lt;&lt;" is transitive), which is impossible because Tl = T,. Therefore, all schedules must be consistent. Cl</p><p>The LLA is an efficient algorithm for processing strong (and weak) consistency queries. In this section we have illustrated how it could be used in conjunction with the CCA. However, the LLA is not limited to the CCA; the LLA can be used with a large variety of update algorithms. For example, in Section 4.1.2 we see how the LLA can be used with one more update algorithm.</p><p>Before ending this section, let us point out that deadlocks can occur with the LLA. In any sistuation where processes (i.e., transactions) compete for a finite set of resources (i.e., local locks), deadlocks may arise. Fortunately, all possible deadlocks are local ones and can be easily detected by special processes running at each node. (A deadlock is local when all the resources involved in a cycle of waiting processes are resources located at a single node.) Here we assume that such deadlock detection processes do exist, and that they can successfully break deadlocks. Furthermore, we assume that the local lock manager at each node is fair and does not allow a transaction to wait indefinitely for a lock.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">An Example:</head><p>The Wait-for List Centralized Algorithm ( WLCA). In this section we will present an update algorithm which allows local queries to obtain a consistent view of the data, but where the schedule of all transactions may be inconsistent. The algorithm is the Wait-for List Centralized Algorithm (WLCA) (inspired by the centralized locking algorithm with wait-for lists of <ref type="bibr" target="#b4">[5]</ref>).</p><p>The WLCA is similar to the CCA in that a central node executes all update transactions. However, the central node does not wait for acknowledgments for the perform update messages before starting the next transaction. In order to prevent perform update messages from being executed out of order, a "wait-for" list is appended to each message.</p><p>The central node computes a wait-for list, WFL(T), for each transaction T it processes. List WFL(T) contains the names of all transactions whose perform update messages must be processed before the message of T in order to avoid conflicts. (The outline of the WLCA which follows shows how the central node can compute these lists.) A copy of wait-for list WFL(T) is appended to each perform update message of T, and nodes will only process these messages if they have processed all transactions in WFL(T) first.</p><p>We now give an outline of the WLCA (Figure <ref type="figure" target="#fig_16">6</ref> illustrates the steps of this algorithm). Array LAST is stored at the central node, and LAST(i) is the name of the last transaction which referenced (read or write) item i. A list, DONE(x), Notice that these two transactions do not conflict because they reference different items. Thus the name Tp will not be in WFL(T,) and the name Tp will not be in WFL(T,). This means that the actions of Tp and Tq may occur in any order at node y.</p><p>Next, consider two queries which read items 1 and 2. One query, Qr is performed locally at node X, while query Qz is executed at node y. We can represent Qi and Since the actions of Tp and Tq may occur in any order at node y, schedule S is a legal schedule as far as the WLCA is concerned. But notice that Tp c QI &lt; Tp &lt; Q2 &lt; Tp (see Definitions 1 and 3), so this schedule is not consistent (see Theorem 1).</p><p>The fact that S is not consistent can be interpreted as follows: In S, &amp;I sees the effects of T,, but does not see the effects of T,, while Qz sees the effects of Tp but not Tp. There is no way that these four transactions can be executed one at a time (i.e., serially) and produce this same effect. In any serial schedule, if Q1 sees Tp and Q2 follows Q1 in the schedule, then Q2 must also see Tp. This is not the case in S.</p><p>The example shows that the WLCA is not strong consistency insular. In other words, there is no query algorithm which can process Q1 and QZ locally, without outside information, and avoid inconsistent schedules. Notice that when Q1 is processed at node x, Tp has completed there, and there is no way of knowing that Tq will come later. Hence, any query algorithm should allow Q, to be processed there. A similar statement can be made about Q2. Of course, nonlocal query algorithms can avoid the problems. For example, if all queries are executed at the central node (just like update transactions), then all schedules will be consistent. (Such a query algorithm is not strong consistency insular because queries are not processed at their originating node, even though the items requested have values there.)</p><p>Fortunately, the fact that our sample schedule S is not consistent does not mean that Q1 and Qz do not see a consistent view of the data. If we elimnate QZ from S, we observe that the resulting schedule is consistent and equivalent to the serial schedule T,,, &amp;I, T, (i.e., Tp executed first, then &amp;I, then T,). Thus, Q1 sees a consistent database at node x. Similarly, if we delete &amp;I actions from S, we find that QZ sees the consistent data at node y produced by serial schedule Tp, Qz, Tp.</p><p>In other words, both queries see a database produced by some serial execution of * H. Garcia-Molina and G. Wiederhold the update transactions, but these serial executions may be different for each query.</p><p>How critical is it that Q1 and QZ do not see "compatible" consistent views? If the users who submitted Q1 and QZ communicate directly and compare their query results, then they may be confused. But on the other hand, many users may be content with getting a consistent view, especially if their weak consistency query can be processed faster than a strong consistency query. Thus, schedule 5' may be considered a "good" schedule in some cases, even though it is not consistent (see Section 2).</p><p>The following theorem confirms the fact that weak consistency queries can indeed be processed locally in conjunction with the WLCA. The query algorithm for weak consistency queries can be the local locking algorithm, LLA (or any such algorithm which satisfies conditions 1 and 2 of Section 4.1.1). THEOREM 3. In all schedules produced by the WLCA and LLA, queries get a consistent view of the data. PROOF. Consider any such schedule S and any query Q in that schedule. Construct schedule S' by eliminating from S all actions of queries other than Q. Since the eliminated queries had no effect on the values read by Q, query Q reads the same values in both S and S'. We show that these values are consistent by showing that schedule S' is ccinsisteht.</p><p>Let x be the node where Q was executed, and assume that there is a cycle in the "&lt;" relation for S'. Assume that Q is in the cycle, and say the cycle is Q &lt; Tl &lt;Tz&lt; . . . &lt; T,, &lt; Q. Since T, &lt; Q &lt; Tl, we know by Conditions 1 and 2 that Tl # T, and an action of T,, precedes an action of T1 at node x. For each pair in the cycle Ti &lt; Ti+l, we know that Ti +&amp; Ti+l (property of WCLA), SO Tl G&amp; Tz &lt;&lt;r . . . ex T,. (Recall that Ti ax Ti+l means that all actions of Ti precede all actions of Ti+l at node x.) This in turn means that Tl eX T,, (relation is transitive), which contradicts the fact that an action of T, precedes an action of Tl at n. If Q is not in the cycle, then Tl &lt; Tz &lt; ----z T,, &lt; Tl becomes T, c&amp; Tz -G ---CG Tl, a contradiction too. Hence, S' is consistent, and all queries read consistent data. Cl 4.1.3 An Example: The Timestamp Centralized Algorithm (TCA). There are some update algorithms where strong or weak consistency insular queries cannot be processed locally. The Timestamp Centralized Algorithm (TCA), which we now describe, is one of these. (This algorithm was inspired by a Majority Consensus Algorithm of <ref type="bibr">[lo]</ref>.)</p><p>The TCA is similar to the WLCA, except that a different mechanism from wait-for lists is used to execute the perform update messages. Let us assume that the central node has a real time clock (which is never set back). In addition to this, each item value in the system has a timestamp associated with it. The timestamp of value d[i, x], ts(d[i, x]), represents the last time when item i was modified at the central site, as far as node x can tell.</p><p>When a transaction T is executed at the central node, it is assigned a timestamp, ts(T), equal to the current time. All perform update messages for T carry a copy of ts(T). This timestamp is used to detect whether the execution of the perform update T message will overwrite values that are more current than those produced  An interesting property of any schedule produced by the TCA is that Ti &lt; Tj implies ts(Ti) is less than ts(Tj) for all update transactions Ti, Tj. (If both of the Ti, q actions that cause the dependency are writes, then step 7 of the TCA guarantees that ts(T;) is less than ts(Tj). Otherwise, the actions must occur at the central site because alI update transaction reads occur there, and ts(Ti) should also be less than ts (Tj) .) This property can be used to show that all TCA schedules for update transactions are consistent.</p><p>Even though the TCA schedules are consistent, the database at a node can be left inconsistent "between" update transactions. To see how this could happen, consider once more the distributed database of Figure <ref type="figure" target="#fig_0">1</ref> and transactions Tl and TZ of Section 3.2 (Tl : "deposit 5 dollars", TZ : "withdraw 10 dollars"). Let us assume that node 1 is the central node. Then the events described in Section 3.2 could occur under control of the TCA. That is, transaction Tl could be executed at time tl at node 1 and message M1 (now with timestainp tl) could be sent to node 2 (see Figure <ref type="figure" target="#fig_6">4</ref>). Similarly, message Mz, with timestamp tz, could also be sent to node 2.</p><p>Suppose that MZ arrives at node 2 before Ml. The new values for the items indicated in MZ would be stored (with timestamp tz), leaving the database at node (Recall that the consistency constraint is deposits -withdrawals = balance.) Any local query performed at node 2 after M2 has been performed and before Ml has arrived will read inconsistent data. No local query processing algorithm can avoid this because at node 2 there is no way to know whether there is or there is not a missing perform update message.</p><p>Of course, when message Ml (with timestamp tl) finally arrives at node 2, the local database will return to a consistent state. Notice that the "d[balance, 21 c 65" part of Ml (see Figure <ref type="figure" target="#fig_6">4</ref>) will not be performed because the timestamp of Ml is less than the timestamp of value d[balance, 23.</p><p>Thus, the TCA is neither strong nor weak consistency insular. Since the schedules of update transactions produced by the TCA are consistent, then strong and weak consistency queries could be processed as if they were update transactions. Of course, such an algorithm for queries would be nonlocal because queries would have to be forwarded to the central node. In the DLA, an update transaction must complete all of its actions at every node before the next transaction can be started. This means that transactions are executed serially, and hence, the DLA produces consistent schedules for update transactions. This also means that a query which is executed locally at node x will see the effects of all previous transactions, except possibly the one that is currently being executed. However, by examining the local update lock at node x, it is possible to tell if indeed the query may miss the effects of the currently executing update transaction. The reason for this is that no update transaction can reach its commit point unless a.ll update locks are held by it. (For the DLA, the commit point of an update transaction is the time of its first write when the new values first become available to queries.) Thus if the local update lock at node x is free, no update ilansactions are currently being executed and any local query at node x will see the effects of all previously committed update transactions.</p><p>This discussion has given us an algorithm for processing latest-bound queries locally at a node x. Say a latest-bound query Q arrives at node x at time t. Node x waits until its local update lock becomes free and at that time starts processing Q. (The local update lock does not have to be held during the processing of Q.) This guarantees that Q will see the effects of all update transactions which committed before time t.</p><p>The reason why the DLA permits local latest-bound query processing is that all nodes participate in the "decision" to perform an update transaction. That is, all nodes must grant an update lock to an update transaction before it can go ahead and commit. This implies that every node must be aware of the fact that there is an update transaction in progress.</p><p>On the other hand, in many algorithms the decision to perform an update transaction is taken by a single node or by a subset of nodes. In these cases, nodes which do not participate in the decision will be unable to process latestbound queries locally because these nodes will not know whether an update transaction is in progress. This is the case with the CCA, WLCA, and TCA algorithms. In all these algorithms, the central node decides what update transactions to process. Thus all nodes (except the central one) must process latestbound queries by either reading the data at the central site or by requesting a wait-for list or timestamps from the central node. (In the second case, a wait-for list for the referenced items or the current central node timestamps for the required items can be used to make sure that all necessary updates are seen by the query.  In the previous sections we presented several types of R insular update algorithms. In those sections we assumed that all data were completely replicated, so that all .</p><p>H. Garcia-Molina and G. Wiederhold queries became insular queries. We now go back to the general case so we may discuss noninsular queries.</p><p>We have proposed a criterion for evaluating query algorithms according to the way in which they process insular queries. We would also like to have a similar criterion for evaluating query algorithms by the way they process noninsular queries. Unfortunately, in the noninsular case it is not as easy to decide what constitutes a good algorithm. That is, one noninsular algorithm may seem the best under certain circumstances, but another algorithm may be superior under different circumstances. We illustrate this with some examples. The update algorithms we select for these examples are modified versions of the CCA, WLCA, TCA, and DLA.</p><p>The CCA, WLCA, TCA, and DLA as stated in the previous sections, cannot be used in a case where some nodes may not have values for all items. However, they can easily be modified to handle the more general case. The resulting algorithms may not be very practical, but they will help us to illustrate some ideas. In all algorithms, nodes should simply ignore any parts of the perform update messages that do not apply. For example, if a node z receives a perform update message indicating that the value of item i is now 10, and node x does not have a value for item i, then x should ignore that part of the message. The only other necessary modification to the algorithms is in reading data for transactions.</p><p>In the CCA, when the central node decides to execute a transaction T, the values needed by T may not be available locally. Hence, the central node must send messages to the other nodes requesting the values. Since the central node executes transactions serially, thii modification does not change the properties of the CCA. A similar modification can be used for the other algorithms. However, care must be taken to preserve the basic properties of the algorithms. For example, in the WLCA, when the central node reads a value for item i at node z, it must ensure that node x has performed the modifications for transaction LAST(i). Otherwise, Ti &lt; Tj would not imply that Ti &lt;&lt;I Tie Since the modifications to the update algorithms have not altered the basic properties of the algorithms, the modiied algorithms still have the same properties with respect to insular queries. We now look at noninsular query processing with these modified algorithms. We use the same names for the modified update algorithms as for the original algorithms, since it should be clear that we refer to the modified algorithms when discussing noninsular queries.</p><p>Consider a noninsular query Q in a system that uses an update algorithm like the TCA, which is not weak consistency insular. Suppose that Q requires values located at nodes x1, x2, . . . , x,. If Q reads the values at those nodes, the values obtained at each node may be inconsistent, and, as a consequence, the collection of values read at nodes x1, . . . , X~ may also be inconsistent. Thus, with the TCA, noninsular weak (or strong) consistency queries cannot be processed by simply going to the nodes that have the required data. As in the case of insular queries, one solution is to process weak consistency queries as if they were update transactions. For the TCA, this involves processing queries at the central node. Depending on how heavily loaded the central node is, the query algorithm may or may not be efficient.</p><p>Next, consider an update algorithm that is weak consistency insular like the WLCA. Again, suppose that query Q requires values from nodes xl, . . . , xm. In l H. Garcia-Molina and G. Wiederhold has the disadvantage that the central node can become a bottleneck. On the other hand, the SLLA avoids this problem, but at the cost of synchronizing different consistent views. This overhead involves revisiting nodes after reading data and delays for missing perform update messages (which are also possible with the other algorithm). If the central node is not heavily loaded, probably the central node algorithm would be a better choice, while the SLLA would be superior in the high-load case. Also notice that the SLLA cannot process strong consistency queries, but the central node algorithm can.</p><p>To end our discussion of weak and strong consistency noninsular queries, let us briefly look at the CCA. Even though thii is a strong consistency insular algorithm, noninsular queries cannot simply read the required values without any internode synchronization. As with the WLCA, there are several alternatives for processing noninsular queries with the CCA. One alternative is to process the queries at the central node. Another is to read several consistent views and to combine them into a single consistent view, like in the SLLA. A third is to delay update processing so that a query may observe the same consistent state at several nodes. Recall that update transaction processing can be halted in the CCA by not acknowledging a perform update message.</p><p>Still another alternative is to use the local locking algorithm (LLA) at each node, but only releasing the locks until all values at all nodes have been read by the query. Such an algorithm guarantees that whenever a query Q sees the effects of an update transaction T1, then (1) 2'1 sees the complete effects of TI at any node, and (2) Q also sees the complete effects of any update transaction Tz that preceded Tl anywhere in the system. (These conditions are similar to those of Section 4.1.1.) Hence this algorithm, like the other three we discussed for the CCA, guarantees that all schedules of queries and update transactions are consistent. Unfortunately, this last query algorithm is prone to global deadlocks as queries and update transactions compete for the local locks. (In the LLA for insular queries, only local deadlocks could occur.)</p><p>Thus the choice of a good query algorithm for noninsular queries in the CCA is just as hard as with the WLCA. Which CCA query algorithm performs better will depend on factors such as the load at the central node, the cost of detecting and correcting and global deadlocks, and the cost of delaying update transactions.</p><p>Processing latest-bound noninsular queries is considerably simpler than processing weak or strong consistency noninsular queries. The reason for this is that a latest-bound query Q which spans data at nodes xl, x2, . . . , x,, can be decomposed into a set of n independent insular queries at nodes XI, x2, . . . , x,.</p><p>That is, as long as each of the subqueries observes all update transactions that were committed before Q's submission time, then the combined data produced by the subqueries will reflect alI update transactions that were committed before Q's submission time. This means that the algorithm for processing noninsular latest-bound queries can simply be a collection of calls to the latest-bound insular algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Processing f-Vintage and t-Bound Queries</head><p>In this section we discuss the processing of t-vintage and t-bound queries. We start by pointing out that if any type of t-vintage or t-bound queries are to be processed, then a history of the distributed database must somehow be kept by the system. This history must record the various states the distributed database went through to arrive at the current state.</p><p>In the algorithms we have presented so far, the "old" values of an item were never saved before replacing them with new values. Thus it is impossible to find out what the distributed database looked like at a given time or at what times the previous update transactions committed. No t-bound or t-vintage queries can be performed with these algorithms as stated.</p><p>In the update algorithms that do keep a history, there are several alternatives for doing so. Probably the simplest and most efficient alternative would be to keep a log of all the update transactions. A transaction log is a record all the transactions and the modifications they performed. Typical entries for update transaction Tin the log would be T's commit time, T's name, the new item values produced by T, and the old values they replaced. A t-vintage or t-bound query can be processed by examining the log in reverse chronological order until the desired data are reconstructed. Since these queries must examine the log, tvintage and t-bound queries can only be executed at nodes which have a copy of the log. One important advantage of the transaction log mechanism is that in many systems the log is required anyway for crash recovery and update transaction undoing <ref type="bibr" target="#b6">[7]</ref>. Thus, in these systems, keeping the log for t-vintage and tbound queries represents no real overhead.</p><p>A second alternative for keeping a history of the distributed database is to keep a log for each item value in the system. Each of these logs records the previous values of an item at a node and the times when the values changed <ref type="bibr" target="#b8">[9]</ref>. A tvintage of t-bound query can be processed by examining the logs for all the items referenced by the query. This can be done at a single node as long as all the required logs are found there.</p><p>Owing to space limitations, we do not discuss here how either type of log can be maintained and how the t-vintage and t-bound queries can be processed using the logs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSIONS</head><p>In this paper we studied the various requirements that read-only transactions or queries can make. The requirements can be strong consistency, weak consistency, t-vintage, t-bound, or latest-bound. We also discussed how queries can be processed efficiently in a distributed database. The criterion of R insularity, that is, whether a query with a requirement R can be processed locally, was used to characterize both query and update transaction algorithms.</p><p>Several update and query algorithms were presented as examples. These examples were intended to illustrate the issues involved in query processing, and care must be taken not to overgeneralize. For example, one cannot say that only update algorithms which produce serial schedules (like the CCA) can be strong consistency insular. Similarly, we cannot conclude that any update algorithm which uses timestamps will not be weak consistency insular. The R insularity property is a property of the update and query algorithms, and not of a particular approach.</p><p>In any distributed database where queries are expected to be a significant fraction of the total transactions, the expected requirements of the queries should be studied and considered in the design of the update and query algorithms. The * H. Garcia-Molina and G. Wiederhold R insularity properties of the proposed algorithms should be analyzed to see if the algorithms are appropriate. For most applications, it is not a good idea to design the most efficient or most elegant update algorithm without keeping in mind queries and their requirements.</p><p>It is also important to notice that in some cases a minor change of the update algorithm can drastically change its R insularity properties. For example, in both the TCA and the WLCA algorithms, the central node can add a sequence number to all update transactions processed. The sequence numbers can then be appended to the perform update messages, and the query algorithms can use this extra information to process weak consistency and even strong consistency queries. Thus the modified TCA and WLCA become strong consistency insular algorithms. But, of course, in algorithms where there is no central node to assign sequence numbers, it may not be as easy to obtain the necessary information to change the R insularity properties.</p><p>In closing, let us point out that the ideas presented in this paper could also be applied to centralized databases. In a centralized database, queries can have the same requirements that we have discussed here. However, in a centralized database system (when all queries are insular) it is fairly easy to design R insular query algorithms for any requirement R because all necessary information is located in the one node.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Sample distributed database.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>[deposits, l] -d[withdrawals, l] = d[balance, 11," and "d[deposits, 21 -d[withdrawals, 21 = d[balance, 21." Notice that there is no constraint at node 3 because two of the ACM Transactions on Database Systems, Vol. 7, No. 2, June 1982. ,lh-y+5 (7',, w. d[balance,l]), 5 d [balance,Zh-y+S (7,, w. d[balance,21), 6 d [deposi&amp;,21-x+5 CT,, w, dIdeposits.21)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. TI: "Deposit 5 dollars."</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Read</head><label></label><figDesc>x-d [deposits, 1 I S -((T,,r.d[deposi~s.l~). T, : y-d [balance. 11 (T,,r,dIbalance,l~), 7,: d[deposits,ll-x+5 (T,,H',dldeposits.ll), T,: d[balance.ll--4.+5 (T,,~.dlbalance.ll). T,: .--d[withdrawals,ll (T,,r,dIwithdrawals.ll). T,: H.-d[balance,ll (T,,r,d[balance.ll), 7,: d[withdrawals,ll-z+lO (T2.~,dlwi~hdrawals,ll).7,: d[balance,ll-w-10 (TI,H.,dibalance,ll), T,: d[withdrawals,ZkztlO (T2.~,d[wilhdrawals,21), T2: d [balance,21-n?-10 (T2.~,dlbalance.21). T,: dIbalance.21-y-l-5 (T,.~,d~balance,Zll. 7,: d[deposils.21-x+5 (T,,H..dldeposits,Zl), 7,: d[withdrawals,31-z+lO (TI.~,dlwithdrawals,31)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. 2'~: "Deposit 5 dollars." T2: "Withdrawal 10 dollars."</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Definition 1 .</head><label>1</label><figDesc>Let T be the set of all transaction names in a schedule named S, and let V be the set of all defined item values d[i, x] in the distributed database. The dependency relation induced by schedule S, dep(S), is a ternary relation on T X V X T defined by (Tl, u, Tz) E dep(S) if and only if, for some i &lt; j, S=(..., (TIP ai, u), . . . , (T2, aj, u), . . .), and ai or aj is a write type action, and there is no Fz such that i&lt;k&lt;j and vk = v and ak = write. The last part of the definition specifies that there should be no write action on item value u between the (Tl, ai, u) action and the (Tz, aj, u) action. (Notice that item values d[i, x] play the role of the entities of [4].) Definition 2. Let S1 and S2 be two schedules for transactions Tl, T2, . . . , T,,,. S1 is equivalent to SZ iff dep(&amp;) = dep(S2). Definition 3. The binary relation "&lt;" on the set of transactions of a schedule S is defined by Tl &lt; T2 iff (Tl , u, T2) E dep (S) for some item value u. THEOREM 1. A schedule S is consistent (i.e., equivalent to a serial schedule) iff the binary relation &lt; for S is an acyclic relation. ACM Transactions on Database Systems, Vol. 7, No. 2, June 1982. . H. Garcia-Molina and G. Wiederhold To illustrate the definition of consistent schedule, consider once more the schedule S of Figure 3. Here, (2'1, d[balance, 11, 2'~) E dep (S) because of the actions in lines 4 and 6. Similarly, ( Tz, d[balance, 21, 2'1) E dep (S) because of the actions in lines 10 and 11. Therefore T, &lt; TZ and TZ &lt; Tl, and the &lt; relation is not acyclic. So S is inconsistent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Example for Section 3.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4</head><label>4</label><figDesc>Figure 4 shows the situation at this point. Let us assume that messages A&amp;, Mz, and A&amp; can arrive in any order at node 2. Let us define &amp;C(d) to be the resulting item values at node 2 after message Mi is processed there, given that d are the previous item values. For example, if do are the initial values at node 2 (see Figure l), then Ml(&amp;) are the values d[deposits, 2]= 105, drwithdrawals, 21 = 40 and d[balance, 21 = 65. Notice that if the messages are processed out of order at node-2, then consistency is violated. For example, M~(i%(&amp;)) is inconsistent because the resulting deposits minus the resulting withdrawals is not equal to the resulting balance. Next, a query Q arrives at node 2 at time t4 (t4 &gt; t3 &gt; t2 &gt; h). Query Q requests the values of all three items at node 2. If Q is a weak consistency query (i.e., a query with a weak consistency requirement), then Q can only be allowed to read do (the initial values), Ml(do), &amp;(M~(&amp;)), or M3(Mz(Ml(do))).If Q is a strong consistency query, then it can only read those same consistent values. However, if Q has no consistency requirement, it can read anything: do, Ml(do), Ml(Mz(do)), iS(Ml(&amp;)), and so on.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>3. 3</head><label>3</label><figDesc>Why Different Read-Only Transaction Types are Needed</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>-H. Garcia-Molina and G. Wiederhold</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Read-Only Transactions in a Distributed Database * 219</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>4. 1 . 1 .</head><label>11</label><figDesc>An Example: The Complete Centralization Algorithm (CCA). The first sample update processing algorithm is a strong consistency insular one. The name of the algorithm is the Complete Centralization Algorithm (CCA) (inspired by the primary site algorithm of [l]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Complete centralization algorithm (numbers correspond to algorithm steps in text).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>( 3 )</head><label>3</label><figDesc>When the central node receives T, it places it in a queue. Update transaction T waits in the queue until its turn to be executed comes up. (4) When T's turn comes, it is executed at the central node. (At this time, all previous transactions have completed at all nodes.) The item values requested by T are read from the database at the central node, any necessary computations are carried out, and the new values are stored in the local database. (5) "Perform update T" messages are sent out by the central node to ah other nodes giving them the new values that must be stored at each site. (6) Each node that receives a "perform update T" message stores the new values produced by T into the database. Then an acknowledgment message is sent back to the central node. (7) When the central node receives acknowledgments for the "perform update 7"' messages from all the nodes in the system, then it knows that T has completed everywhere. Thus the central node gets the next update transaction that is waiting in its queue and processes it. (See step 4.) (End of CCA.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Condition 1 .</head><label>1</label><figDesc>(Tl, d[a, x], Q) E dep(S) implies that (Q, d[b, LX], Tl) tf dep(S), for any update transaction TI, query Q, items a, b, node x. Condition 2. (TI, d[a, x], Q) E dep(S) and action (Tz, w, d[b, x]) precedes action (Tl, w, d[a, x]) at node x implies that (Q, d[b, x], Tz) +Z dep(S), for all update transactions TI , Tz, query Q, items a, b, node x. It is simple to check that the LLA does indeed force all schedules to satisfy these conditions. For Condition 1, (Tl, d[a, x], Q) E dep (S) means that S must ACM Tmmactions on Database Systems, Vol. 7, No. 2, June 1982.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>-Molina and G. Wiederhold be of the form ( . . . , VI, w, d[a, xl,, . . . , (Q, r, d[a, xl), . . J. This implies that 2'1 must complete at x before Q does (or else Q would not get the d[a, X] lock). If (Q, d[b, n], T1) E dep(S), then we get the contradiction that Q completes at node x before T1 does. Therefore, (Q, d[b, x], TI) must not be in dep (S). The check for Condition 2 is similar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Wait-for list centralized and timestamp centralized algorithms (numbers correspond to algorithm steps in text).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>Read-Only Transactions in a Distributed Database * 225</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>QZ as Ql = ((&amp;I, r, 41, xl,, (81, r, 42, xl)), Qz = (t&amp;z, r, W, YI), (81, r, d[2, ~1)). Now consider the following schedule of these four transactions: S = (Pm w, 41,4) (QI, r, d[l, ~3, (&amp;I, r, 42, xl), U',, w, dP, xl,, U',, w, d[2, ~1)s (Q2, r, d[l, YI), (Q2, r, 0, ~3, U'm w, 41, ~1)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>Read-Only Transactions in a Distributed Database l 227 by T. The details are given in the following outline of the TCA. (These steps are depicted in Figure 6.) (l)-(4) Same steps as the WLCA.(5)Transaction T is assigned a timestamp ts(T) equal to the current time at the central node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>update T" messages, which include a copy of ts(T), are sent out by the central node to all other nodes, giving them the new values that must be stored at each site. The central node is done with T, and goes on to process the next update transaction that is waiting in its queue. (See step 4.)<ref type="bibr" target="#b6">(7)</ref> When a node x receives a "perform update T" message, it performs the following for each "d[i, x]+ value" in the message: If ts(d[i, x]) is less than ts( T) then replace the value d[i, x] by the value given in the message; otherwise do nothing to d[i, x]. No acknowledgment is sent to the central node. (End of TCA).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>2 inconsistent: d[deposits, 21 = 100, drwithdrawals, 23 = 50, d[balance, 21 = 55.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>4. 1 . 4 229 ( 5 )</head><label>142295</label><figDesc>An Example: The Distributed Locking Algorithm (DLA). In this section we present a latest-bound insular update algorithm. Recall that a latest-bound Read-Only Transactions in a Distributed Database * Perform update T messages are sent by node x to all other nodes giving them the new values that must be stored at each site. (6) Each node y that receives a perform update T message stores the new values into the local database. Theupdate lock at node y is released and any waiting lock request is granted (see step 3). (End of DLA).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>4. 2</head><label>2</label><figDesc>Processing Noninsular Queries</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Database Systems, Vol. 7, No. 2, June 1982, Pages 209-234.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>ACM Transactions on Database Systems, Vol. 7, No. 2, June 1982.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>ACM Tnmsactions on Database Systems, Vol. 7, No. 2, June 1982.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>ACM Tmnsactions on Database Systems, Vol. 7, No. 2, June 1982.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>ACM Transactions on Database Systems, Vol. 7, No. 2, June 1982</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>ACM Tmmwtionaon Database System, Vol. 7, NO. 2, June 1982.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors wish to thank Susan Davidson, Clarence Ellis, Susan Owicki, and the referees for their useful comments and suggestions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>l H. Garcia-Molina and G. Wiederhold is kept at each node X. This list contains the names of transactions whose perform update messages have been processed at node x.</p><p>(1) An update transaction arrives at node x from a user. Node x assigns a name T to the transaction. (The name could be, for example, a node identification number followed by the user name and a sequence number.) Recall that we are assuming that all data are replicated at all nodes in the system.</p><p>(2) Node x forwards transaction T to the central node.</p><p>(3) When the central node receives T, it places it in a queue. Update transaction T waits in the queue until its turn to be executed comes up. In order to describe an important property of the WLCA, let us define a binary relation "c~" on the set of all transactions of a schedule S, as follows: Ti &lt;&lt;r Tj, if and only if all actions of transaction Ti precede all actions of transaction Tj at node y in schedule S. Notice that "cY," like "cc," is transitive and h-reflexive.</p><p>The important property of the WLCA is that if update transactions TI and TZ reference a common item i, then either Tl CC,. TZ at all nodes y, or TZ &lt;&lt;r TI at all nodes y. To see why this is true, suppose that Tl is processed first at the central node, and say that transactions RI, RB, . . . , R, also reference item i and are processed after Tl but before Tz. Then Tl will be in WFL(Rl), RI will be in WFL(Rz), . . . , and R, will be in WFL(T2). As we can see in step 7 of WLCA, if Tl is in WFL(RI), then Tl &lt;&lt;u RI at all nodes y. Similarly, RI &lt;&lt;u RZ . -. R, &lt;&lt;r TZ at all nodes y, so Tl &lt;&lt;r T2 at all nodes y by the transitive property of the relation.</p><p>If TZ is processed first at the central node, then TZ &lt;&lt;r Tl at all nodes y. As an immediate consequence, if Tl &lt; TZ in any WLCA schedule, then TI &lt;&lt;u TZ at all nodes y. In turn, this property can be used to immediately show that all WLCA schedules are consistent. (By the way, notice that saying that Tl &lt;&lt;r TZ at all nodes y is not the same as saying that all actions of Tl precede all actions of TZ everywhere, or Tl -=K Tz.)</p><p>Even though the WLCA has these properties, it turns out that not all schedules of update transactions and queries performed locally are consistent. The following example illustrates this. Consider two update transactions Tp and Tq in a system with two nodes x and y, and say that x is the central node. Transaction Tp simply updates item 1 without reading any data, while Tq similarly updates item 2. Thus   query Q submitted at time t must see the effects of all update transactions that have committed before time t. (This algorithm was inspired by Ellis' ring algorithm <ref type="bibr" target="#b2">[3]</ref>.)</p><p>In the Distributed Locking algorithm (DLA), each node in the system has a single update lock. Before an update transaction T can be performed, it must request and obtain this update lock from every single node in the system. Once transaction T has all locks, it knows that no other transaction is updating, so T can be performed, releasing all locks upon its completion. Of course, global deadlocks may occur when two transactions attempt to obtain the update locks, but we will avoid this problem by assuming that there is a special program in the distributed database which detects global deadlocks and orders update transactions to release their locks.</p><p>The following is a brief description of the DLA, while Figure <ref type="figure">7</ref> illustrates these steps.</p><p>(1) Update transaction T arrives node x from a user.</p><p>(2) Node x, on behalf of T, sends "request update lock" messages to all nodes in the system (including one to itself).</p><p>(3) When a node y receives a "request update lock" message from node x, it checks its lock. If the lock is available, then a "lock granted" message is sent to x and the lock is marked as given. If the lock has been given to some other transaction the lock request is placed on a queue to wait for the release of the lock. this case it would be possible to get a consistent view at each of the m nodes, but the combination of these m consistent views may be inconsistent. Thus even though the WLCA is weak consistency insular, noninsular weak consistency queries have the same problem as they had in the TCA. However, in the case of the WLCA, there are two (or more) possible weak consistency algorithms. The first solution is, as for the TCA, to process noninsular queries at the central node. This algorithm could be used for weak as well as strong consistency queries. The second solution is to read a set of consistent views at the required nodes and then to make these views consistent among themselves. As we shall see, thii algorithm avoids communication with the central node (unless data must be read there).</p><p>We now give a brief outline of this query algorithm which does not communicate with the central node. Let us call this algorithm the Synchronized Local Locking Algorithm (&amp;LA).</p><p>The algorithm is presented for the case of a query which spans two nodes only. The extension for general noninsular queries should be straightforward.</p><p>(1) Query Q needs to read item values at nodes x and y.</p><p>"2) Query Q uses the LLA to obtain a consistent view of the data at node x. These values are saved in DATA(x). Before releasing the local locks, Q copies the list of performed update transactions, DONE(x), into VIEW(x). A special procedure to collect all perform update messages that are performed at node x in the future is started. (The reason for thii will become apparent later.) Then the local locks at x are released. (3) Query Q waits at node y until all perform update messages for transactions in VIEW(x)</p><p>have been performed at node y. (That is, until VIEW(x) is a subset of DONE(y).) Then Q uses the LLA to obtain a consistent view of the data at node y. These values are saved in DATA(y). The list DONE(y) and the local locks are released. (4) Back at node x, query Q compares the transactions seen at node y, VIEW(y), with the transactions seen at node x, VIEW(x). Query Q waits until the perform update messages for all transactions in VIEW(y), but not in VIEW(n), have been performed at node x. At this point, the perform update messages for transactions missed by Q at node x, that is VIEW(y) -VIEW(x), have been saved at node x. Hence, Q can simply perform the missing messages on the data read originally, DATA(x). Of course, no message for transactions not in VIEW(y) should be performed. The messages that are performed on DATA(x) are performed in the same order as at node x.</p><p>We do not formally prove that the SLLA gives noninsular queries a consistent view, but we present an intuitive argument. At node y, query Q is performed with the LLA and gets a consistent view of the data. That is, Q observes the database as if the transactions in VIEW(y) had been performed serially. If we let 5"1, Tz, . . . ) T, be the names of the update transaction in VIEW(y), then the effect on Q at node y is as if the serial schedule ( TI Tz, . . . , t,Q) had been performed (i.e., TI performed completely, then Tz, and so on). At node X, Q also sees the effect of TI, Tz, . . . . T,, but possibly in a different order. However, transactions Ti and Tj can only be observed in a different order at nodes x and y if they have no items in common. Therefore, in the schedule observed at node x, we may switch any pair of transactions whose order does not coincide with the order in (TI, . . . , TnQ). So Q observes the same consistent state at both nodes x and y, and the combined values read at nodes x and y must be consistent.</p><p>We now have the problem of deciding whether the SLLA or the central node algorithm is superior for weak consistency queries in the WLCA environment. The central node algorithm (where queries are processed like update transactions)</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A principle for resilient sharing of distributed resources</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Alsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Day</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Int. Conf. Sofiware Engineering</title>
		<meeting>2nd Int. Conf. Sofiware Engineering<address><addrLine>San Francisco, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="562" to="570" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The concurrency control mechanism of SDD-1: A system for distributed databases (the fully redundant case)</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rothnie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="154" to="168" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Consistency and correctness of duplicate database systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Symp. Operating System Principles</title>
		<meeting>6th Symp. Operating System Principles<address><addrLine>West Lafayette, Ind</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="67" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The notions of consistency and predicate locks in a database system</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Eswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Traiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="624" to="633" />
			<date type="published" when="1976-11">Nov. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Performance of update algorithms for replicated data in a distributed database</title>
		<author>
			<persName><forename type="first">Garcia-M•</forename><surname>Lina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
		<idno>Rep. STAN-(X-79-744</idno>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>Stanford, Calif</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dep. Computer Science, Stanford Univ.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Granularity of locks and degrees of consistency in a shared database</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Pijtzolu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Traiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Database Management Systems</title>
		<meeting><address><addrLine>North-Holland, New York</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="365" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Notes on database operating systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advanced Course on Operating Systems, Technical Univ</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<pubPlace>Munich</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Naming and synchronization in a decentralized computer system</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Reed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
		<respStmt>
			<orgName>Dep. Electrical Engineering and Computer Science, Massachusetts Institute of Technology, Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A majority consensus approach to concurrency control for multiple copy databases</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="180" to="209" />
			<date type="published" when="1979-06">June 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1980-04">April 1980. 1980. 1981. June 1982</date>
		</imprint>
	</monogr>
	<note>revised July. accepted April</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
