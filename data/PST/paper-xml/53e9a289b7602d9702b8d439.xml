<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EnTracked: Energy-Efficient Robust Position Tracking for Mobile Devices</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Mikkel</forename><forename type="middle">Baun</forename><surname>Kjaergaard</surname></persName>
							<email>mikkelbk@cs.au.dk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jakob</forename><surname>Langdal</surname></persName>
							<email>jakobl@cs.au.dk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Torben</forename><surname>Godsk</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Toftkjaer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">EnTracked: Energy-Efficient Robust Position Tracking for Mobile Devices</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">32B049B0E137467D10EDC20DB4AC4732</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C</term>
					<term>2</term>
					<term>4 [Computer-Communication Networks]: Distributed Systems Experimentation, Measurement</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An important feature of a modern mobile device is that it can position itself. Not only for use on the device but also for remote applications that require tracking of the device. To be useful, such position tracking has to be energy-efficient to avoid having a major impact on the battery life of the mobile device. Furthermore, tracking has to robustly deliver position updates when faced with changing conditions such as delays due to positioning and communication, and changing positioning accuracy.</p><p>This work proposes EnTracked -a system that, based on the estimation and prediction of system conditions and mobility, schedules position updates to both minimize energy consumption and optimize robustness. The realized system tracks pedestrian targets equipped with GPS-enabled devices. The system is configurable to realize different tradeoffs between energy consumption and robustness.</p><p>We provide extensive experimental results by profiling how devices consume power, by emulation on collected data and by validation in several real-world deployments. Results from this profiling show how a device consumes power while tracking its position. Results from the emulation indicate that the system can estimate and predict system conditions and mobility. Furthermore they provide evidence for that the system can lower the energy consumption considerably and remain robust when faced with changing system conditions. By validation in several real-world deployments we provide evidence that the real system works as predicted by the emulation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>An important feature of a modern mobile device is that it can position itself. Not only for use locally on the device but also for remote applications that require tracking of the device. Examples of such applications are geo-based information applications <ref type="bibr" target="#b6">[6]</ref> or proximity and separation detection for social networking applications <ref type="bibr" target="#b12">[12]</ref> just to mention a few. To be useful, such position tracking has to be energy-efficient to avoid having a major impact on the power consumption of the mobile device. Optimizing the operation of mobile devices for energy efficiency is an important issue and research is trying to address it from many angles, for instance, by trying to lower the impact of network protocols on power consumption <ref type="bibr" target="#b15">[15]</ref> or by optimizing the execution at the operating system level <ref type="bibr" target="#b4">[4]</ref>. Furthermore, tracking has to be robust in order to deliver position updates within limits when faced with changing conditions such as delays due to positioning and communication, and changing positioning accuracy.</p><p>To quantify the impact of position tracking on power consumption, we measured the power consumption of a Nokia N95 phone for 30 minutes, while the phone periodically positioned itself using the built-in GPS receiver and then send the position data using UMTS to a remote service hosted on an internet-connected server. The measurements were repeated with different time intervals between the periodic position updates. The average power consumption measured is plotted in Figure <ref type="figure" target="#fig_0">1</ref>. The results highlight that even for moderate time intervals between position updates such as sixty seconds the power consumption is as high as 0.6 watt, which is twelve times more consumed power than when the phone is idle and the double amount of power compared to when the phone is used with the screen turned on.</p><p>From Figure <ref type="figure" target="#fig_0">1</ref> one might propose to minimize the power consumption by using large intervals between position updates, but then maintaining position accuracy becomes a problem, as a pedestrian target can walk or run quite far during two to five minutes. To address this problem previous research such as <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b19">19]</ref> has proposed dynamic tracking to try to minimize the frequency of needed position updates by only requiring updates after the target has moved more than a specified distance or has moved out of a specified area.</p><p>The systems proposed in previous research for such dynamic tracking have several drawbacks. First, the research assumes that power consumption for positioning and sending is instantaneous meaning that the power consumption per position sensing and sending is a constant and that you can calculate the total power consumption by just multiplying this constant with the number of position updates. For instance, for the Nokia N95 this constant could be set to 1.523 joules <ref type="foot" target="#foot_0">1</ref> . Using this model to calculate the power consumption with different periodic intervals gives the results in Figure <ref type="figure" target="#fig_0">1</ref>, which we denote by 'instantaneous model'. From the results we can see, that this model is not at all able to account for the real power consumption of a device. The reason is that this model does not take into account the delays involved when either the GPS or the GSM transceiver is initializing, nor the delays of it powering off. Second, previous research assumes that positioning takes constant time. This is not true, for instance, for sensing position with a GPS module the positioning time depends on how well the GPS module knows the frequencies of visible satellites, the current satellite constellation and several other parameters. Third, they considered the accuracy of positioning to be constant. This is also incorrect: the accuracy of GPS positioning depends on the number of visible satellites, signalblocking structures near the receiver and several other factors. Fourth, they did not deploy the systems on actual hardware. Systems were evaluated either by simulation or emulation. This paper proposes EnTracked -a system that, based on the estimation and prediction of system conditions and mobility, schedules position-updates to both minimize energy consumption and optimize robustness. The realized system tracks pedestrian targets equipped with GPS-enabled devices. The system is configurable to realize different tradeoffs between energy consumption and robustness.</p><p>We make the following contributions in this work: First of all, we present a system that uses the estimation and prediction of system conditions and mobility to build a robust energy-efficient tracking system. Secondly, we profile how devices consume power for tracking and propose a device model that can account for the real power consumption of a device. Thirdly, we propose methods for position tracking that take the changing system conditions into account, e.g., positioning delays and position accuracy. Fourthly, we propose a method (implemented by dynamic programming) that can minimize power consumption and satisfy robustness by calculating the optimal plan for when to power on and off features of the mobile devices such as the GPS module or the UMTS radio. Fifthly, we provide a deep investigation by means of emulation to show that the system can: estimate and predict system conditions and mobility; lower the energy consumption considerably; and remain robust when faced with changing system conditions. Finally, we implement EnTracked and use this prototype in a real deployment to gather results showing that the real system works as predicted by the emulation.</p><p>The remainder of this paper is structured as follows: In Section 2, we present the relevant related work. Subsequently, we present our profiling results and propose a device model that can account for the real power consumption of a device. Then we introduce the EnTracked System in Section 4. The results from evaluating our system by means of emulation are presented in Section 5. In Section 6 we discuss our implementation and the results of our real-world deployment. Finally, in Section 7 we provide a summarizing discussion and Section 8 concludes the paper and provides directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>As mentioned earlier, existing research have proposed dynamic tracking for updating position information about a target. Previous works such as <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14]</ref> study dynamic tracking to minimize communication and to minimize the load on server nodes by lowering the number of position updates. Leonhardi et al. <ref type="bibr" target="#b14">[14]</ref> study time-based and distancebased tracking that takes a constant positioning accuracy and target speed into account. They study by simulation the number of updates each tracking technique produces and the average and maximum uncertainty of the server-known position. They have later extended this work for tracking based on dead-reckoning <ref type="bibr" target="#b13">[13]</ref>. Systems that tries to minimize the number of position updates for a specific application such as GeoPages have also been proposed <ref type="bibr" target="#b6">[6]</ref>.</p><p>A later work focusing on both energy efficiency and GPS positioning is Farrell et al. <ref type="bibr" target="#b8">[8]</ref>. They propose methods that take into account a constant positioning delay, target speed, and stress the importance of the fact, that it is not energyfree to use the GPS constantly as assumed by earlier work. The methods have been evaluated by simulation, where they can save around 50% energy in the evaluated scenarios assuming an instantaneous power model. They have later extended this work for area-based tracking where they also take constant position accuracy and communication delays into account.</p><p>For sensor networks, Tilak et al. <ref type="bibr" target="#b19">[19]</ref> propose dynamic tracking techniques that take into account target speed and heading. They assume that the positioning uncertainty is negligible. They evaluate the methods by simulation for proximity-based sensor network positioning. For an indoor sensor network setting, You et al. <ref type="bibr" target="#b20">[20]</ref> propose dynamic tracking techniques that take into account a constant positioning accuracy and delay, target speed and acceleration to detect if the target is moving or not. They evaluate the techniques by emulation for IEEE 802.15.4 signal-strengthbased indoor positioning and one of their results is that considerable energy savings can be gained from the use of an accelerometer to detect if the target is stationary or not.</p><p>In comparison, our work proposes techniques that take into account dynamically estimated position accuracy and delays, communication delays, power constraints, target speed and acceleration (to detect if the target is moving or not). Furthermore we evaluate our techniques both by emulation and in real-world deployments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DEVICE MODEL</head><p>To be able to dynamically track a mobile device robustly and energy-efficiently we require a device model that can account for the delays and power consumption of the device. If we do not have such a model we cannot make decisions that will minimize the power consumption and make position updates within required limits. As motivated in the introduction previous research have assumed a simple, instantaneous power model. When using a more detailed model, one drawback is that it depends on more device dependent parameters, therefore we discuss how such parameters automatically can be estimated and the generality of the model in Section 7.</p><p>The proposed model is based on profiling the delays and power consumption of a Nokia N95 8GB 2 mobile phone. The N95 is a 3G phone with an internal GPS module and a triaxial accelerometer, both of unspecified brand, and a 1200 mAh battery. The main contributors to the delays and power consumption of the phone are the individual components used in the N95 and as such we hypothesize that the proposed model is generalizable to a wider range of phones than just the N95. The phone runs the Symbian 60 operating system version F1. We measured the power consumption of the phone by using the Nokia-developed tool Nokia Energy Profiler <ref type="bibr" target="#b2">[2]</ref> version 1.1. The Nokia Energy Profiler tool has been built by Nokia to enable developers to analyze the power consumption of mobile applications and it supports a power-sampling rate of 4Hz. To measure the delays and power consumption of different features, several Python scripts have been developed that enable and disable features and measure various delays. The Python scripts run on the N95 with the aid of the Python Interpreter for S60, version 1.4.4 <ref type="bibr" target="#b3">[3]</ref> and the included library that provides access to phone features such as the internal GPS and the triaxial accelerometer. The internal GPS supports a sampling rate of 1Hz and the triaxial accelerometer a sampling rate of 30Hz. For the measurements involving sending data using the phone's UMTS radio, a TCP/IP server was implemented in Java and deployed on a server connected to the internet and with a public IP address that the phone was able to connect to over UMTS.</p><p>The proposed device model consists of two parts: a power model that describes the power usage of the phone; and a delay model that, for instance, describes the delays when requesting a phone feature, e.g., the time it takes for the GPS to return a position. In both models we consider the following phone features:</p><p>• accelerometer (a)</p><p>• GPS (g)</p><p>• radio idle (r)</p><p>• radio active (s)</p><p>• idle (include Python and Nokia Energy Profiler) (i) 2 For the remainder of this paper the Nokia N95 8GB phone is abbreviated as the N95 phone or simply N95</p><p>These are the features that we find relevant for phone tracking, 'idle' is not strictly a feature, but is included in the power model for completeness. For interactive user applications on the device, one would also need to take into account the power usage of features such as the computations of the application logic, the key strokes, camera use, and screen use.</p><p>The power model consists of two functions defined in Equation 1: the power function power and the consumption function c d,p where d is a feature's power-off delay and p it's power consumption.</p><formula xml:id="formula_0">power(T ) = P T t=1 ip + ca d ,ap (at) + cg d ,gp (gt) + cr d ,rp (rt) + cs d ,sp (st) c d,p (x) = ( p if x &lt;= d 0 if x &gt; d (1)</formula><p>The equation uses the variables at, gt, rt, st for the different features listed in the feature list above. Each variable denotes, at time step t, the number of seconds since the feature was last powered off (a variable is zero if the feature is in use in the current time step t). Since the idle power consumption is constant no variable it is introduced. Furthermore the parameters ip, ap, gp, rp, sp denote the power consumption of a feature, e.g., 0.324 watt for the N95 internal GPS. The parameters a d , g d , s d , r d denote the number of seconds a feature takes to power off after last use, e.g., 30 seconds for the N95 internal GPS. The values of the parameters will be determined in Section 3.1 and Section 3.2 from traces collected from a N95 phone.</p><p>The delay model is given as two functions reqg, reqs that describe the request delays for the GPS and for activating the radio for sending. For the other features the request delays are negligible in our case, because they are below 100 milliseconds. The functions are defined and their values determined in Section 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Power Consumption</head><p>To determine the power parameters ip, ap, gp, rp, sp we have collected a number of power consumption traces with a N95 phone with different features enabled and disabled. Before each trace collection and before all other of our experiments, the phone was fully charged to counter the influence of the non-linear voltage decrease of batteries <ref type="bibr" target="#b5">[5]</ref>. First, the Nokia Energy Profiler application was started. Then the python interpreter was started with a Python script that enabled or disabled certain features for a specific amount of time. The total script running time was five minutes for these measurements. Then the Python interpreter was closed and the Nokia energy profiler was stopped. The power consumption trace collected with the Nokia energy profiler was exported to a file. These traces were trimmed to remove the consumption logged while the Python script was not running and when the screen was powered on. The average feature consumptions were calculated from the trimmed traces and is listed in Table <ref type="table" target="#tab_0">1</ref>. In the model we use the average values for the parameters. Table 1 also lists the standard deviations. As these values are rather small, using the average value in our model is a reasonable choice. Just for reference, we also measured the power consumption of the screen, which is around 0.2 watt. However, as discussed earlier we do not use this value in our device model. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Delays</head><p>The delay model includes two types of delays as introduced earlier. The first is request delays, which is the time a feature uses to get operational. The second type is delays when powering off, which is the time a feature takes to power off after the last usage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Request Delays</head><p>The request delays have been measured using the same experimental setup as described in Section 3.1, but with two changes. First, for GPS request delays the Python scripts logged the time difference in the internal clock between requesting a GPS measurement and the moment when a position was returned. Second, for the radio request delays the Python script logged the timestamp provided by the GPS for each position. This timestamp is taken at nearly the same time as when the Python script starts to request a TCP/IP connection to the server and on the server the Java application logged the time of data reception. The server was configured to synchronize its time using the Network Time Protocol <ref type="bibr" target="#b16">[16]</ref> which can synchronize the clock to a precision of tens of milliseconds over the internet. The radio request delay was then measured as the difference between the GPS timestamp and the reception timestamp on the server. This difference includes both the time to activate the UMTS radio and the transmission time of the packet data.</p><p>A trace lasting fourteen hours was collected in order to measure the GPS request delays for varying periodic intervals between requests. For periodic intervals shorter than 85 seconds, the interval was increased one second for every five repetitions, while for periods equal to or longer than 85 seconds the increase step was five seconds. The collected trace is plotted in Figure <ref type="figure" target="#fig_1">2</ref>(a) and shows that the request delays depend on the periodic interval between requests.</p><p>When a GPS device starts up it has to acquire the carrier frequencies on which the satellites send their signals and get data about the satellites' orbits, also known as ephemeris data <ref type="bibr" target="#b10">[10]</ref>. The used N95 had Assisted GPS enabled, which means that the GPS receives the approximate signal frequencies, the ephemeris data, and other relevant data through the cell network, which speeds up the acquisition process. The GPS still has to tune to and synchronize with the actual signals. This process can take several seconds depending on the GPS device in use. The reason why the GPS has to tune into the actual carrier frequencies is that, due to effects such as the Doppler effect, the signal frequencies are shifted on their way from the satellites. From Figure <ref type="figure" target="#fig_1">2</ref>(a) one can note that with periods above 30 seconds the GPS has to use at least five seconds to lock-on to the signals and estimate it's position. With periods below 30 seconds it only takes around one second. The reason for this is that the 30 seconds period matches the power-off delay for the GPS module (this value is determined later in this Section). So for 30 seconds after the last GPS request the GPS power is kept on and the GPS is locked on to the signals and therefore it does not have to re-acquire the signals. When the GPS powers off, it looses the signal locks and has to start over again. From the results we notice that with higher periods a longer acquisition time is needed to reacquire a signal lock. Based on these results we have chosen to model the GPS request delays as the function req g given in Equation 2 which depends on whether the periods being below or above the 30 second limit. As can be noticed from Figure <ref type="figure" target="#fig_1">2</ref>(a), sometimes it takes even longer than 6 seconds, so to favour robustness over energy-efficiency, one could set this value higher. In comparison, previous work <ref type="bibr">[9]</ref> uses a constant value of 0.5 seconds for the GPS request delay.</p><formula xml:id="formula_1">reqg(x) = ( 1 if x &lt;= 30 6 if x &gt; 30 reqr(x) = ( 0.3 if x &lt;= 6 1.1 if x &gt; 6<label>(2)</label></formula><p>To determine the UMTS radio request delay a trace lasting 30 minutes was collected. During this trace data was sent from a N95 phone to a server over UMTS with different periods. The collected data cover periods from one second to fifteen seconds and is shown in Figure <ref type="figure" target="#fig_1">2</ref></p><formula xml:id="formula_2">(b). From Fig- ure 2(b)</formula><p>we can observe that with a period of less than 6 seconds, the radio request delay is very short, around 300 milliseconds. Above 6 seconds it is around 1100 milliseconds with some fluctuations. The limit of 6 seconds matches the power-off delay for the radio from active to idle, determined later in this section. The reason is that when the radio powers off it can take the radio up to several seconds to be activated again as stated in the technical report published by Nokia <ref type="bibr" target="#b17">[17]</ref>. The fluctuations can be explained by variations in the communication path from the phone to the server over both the cellular network and the Internet, e.g., lost packets and delays. Based on these results we have chosen to model the radio request delay as the function req r given in Equation <ref type="formula" target="#formula_1">2</ref>. For both the function reqg and reqr we have focused on the average case which (because of the existence of higher delays) trades energy-efficiency over robustness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Power-Off Delays</head><p>The power-off delay which is the time a feature takes to power off after the last usage has also been measured using the same experimental setup as described in Section 3.1. To determine the power-off delays, thirty minutes of data was collected where each minute, a GPS position was requested, then when a position was returned the position data was sent to a server and when the data was sent, the connection was closed. To determine the power-off delays, the power consumption traces were manually inspected and timestamps for the enabling and disabling of different features were entered into a trace file. The enabling and disabling of a feature could be determined from knowledge about the collection procedure and from knowledge about the power consumption of each feature, as determined by the experiments presented in Section 3.1. From the entries in the trace file   <ref type="table" target="#tab_1">2</ref> were calculated. The results indicate that the power-off delay for the GPS and for radio idle is around thirty seconds and a little below six seconds for radio active. The power-off delay for radio idle is relative to when radio active has powered off to idle mode. The reason no power-off delay is listed for the accelerometer is that the accelerometer did not power off when requested to by our Python code. Only when the interpreter was stopped the power consumption dropped for the accelerometer. Furthermore the accelerometer uses an order of magnitude less power than the radio and the GPS. Therefore the accelerometer is treated in the same manner as the idle consumption, i.e., as a constant power usage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Device Model Validation</head><p>To validate the proposed device model, we now compare the average power consumption for the periodic sampling calculated with this new model to the power consumption traces collected on a N95 phone. These traces were mentioned earlier in Section 1 and have not been used in the above sections to derive the model. Therefore they can be used to validate that the model can explain the power consumption of a real phone with high precision. Figure <ref type="figure" target="#fig_3">3(a)</ref> plots data from the collected trace for 60 seconds periodic tracking, overlaid with the predicted power consumption of the two other models. We can see how the proposed model closely matches the real power consumption, whereas the instantaneous model does not. Average values have also been calculated for a 30-minute scenario, which match the length of the traces collected on the N95 phone. The results of the collected traces and the two models have been plotted in Figure <ref type="figure" target="#fig_3">3(b)</ref>. The results show that the new model can describe the power consumption of a real phone with a much higher precision. Therefore this model can be used to inform the design of our tracking techniques towards minimizing the power consumption, whereas the instantaneous model has misinformed earlier research.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ENTRACKED</head><p>The goal of EnTracked is to dynamically track mobile devices in both an energy-efficient and robust manner. Thus, robust, position updates have to be delivered to applications within application-specified error limits, where error refers to the distance between the application-known position and the real position of the device. Given that in this paper we focus on pedestrian targets we can assume that there is an upper threshold on target speed vmax which we assume to be 10m/s. Furthermore, the focus on pedestrian targets guides us how to detect whether the target is moving or not by using an accelerometer.</p><p>To use EnTracked, position-based applications have to provide error limits that they want targets tracked with. But one might ask if it is the case that position-based applications always want the highest possible accuracy. In practice application providers will be motivated to minimize their applications' power consumption by providing limits because users will stop using their applications if they experience that they quickly drain their device's battery. Privacy restrictions might also provide error limits if users specify lower limits for the granularity of which an application is allowed to track them with. Another option is that users themselves can decide how they want to trade application experience with energy efficiency by setting the limits themselves.</p><p>For a lot of applications it is also possible to calculate relevant error limits. A map application, that shows the positions of a number of mobile devices, can use the zoom level to determine relevant error limits (such as 25 meters for street-level view, 100 meter for a suburb, and 200 meter for a city-wide view). Another example is the many types of social networking applications that focus on relationships between the positions of devices, for instance, to detect when people come into proximity or when they separate. Methods have been proposed to efficiently track devices to reveal relationships, such as the ones proposed by Küpper et al. <ref type="bibr" target="#b12">[12]</ref>. The methods work by dynamically assigning tracking jobs with changing error limits that they calculate based on the distance between the targets. Such methods produce tracking error limits ranging from 10 meters to several kilometres, depending on the distance between the devices.</p><p>When a position-based application requests to use En-Tracked the steps illustrated in Figure <ref type="figure">4</ref> are carried out. Firstly, an application issues a request for the tracking of a device with an error limit <ref type="bibr" target="#b1">(1)</ref>. Secondly, the server propagates the request to the client-side part of EnTracked <ref type="bibr" target="#b2">(2)</ref>. Thirdly, the client finds a start position and returns it through the server to the application (3)+(4). Fourthly, the En-Tracked client logic schedules features to deliver the next position within the error limit <ref type="bibr" target="#b5">(5)</ref>. Fifthly, at some point later EnTracked determines that a new position has to be delivered to the client through the server (6)+ <ref type="bibr" target="#b7">(7)</ref>. If several applications requests tracking for the same device, En-Tracked configures the device for tracking with the smallest requested error limit to fulfil both of the applications' limits. (2). Then, using the accelerometer-based method presented in Section 4.1, it is determined if the device is moving or not (3). If not, the logic waits for movement. When moved, the speed of the device is determined using GPS measurements as described in Section 4.2 (4). Then, using the error model presented in Section 4.3, a time for the next GPS position reading is calculated (5). This time limit is then given to a dynamic programming algorithm proposed in Section 4.4, that -based on the current power state of device features -finds the optimal strategy for minimizing the power consumption for this time limit and how to schedule features to satisfy the limit considering both possible GPS and radio delays <ref type="bibr" target="#b6">(6)</ref>. Then, the logic follows the scheduling plan calculated by the dynamic algorithm <ref type="bibr" target="#b7">(7)</ref>, restarts the process when appropriate <ref type="bibr" target="#b8">(8)</ref>, and returns the next GPS position to the server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Detecting Movement</head><p>Movement can be detected by using accelerometers and has been proposed previously for indoor dynamic tracking by You et al. <ref type="bibr" target="#b20">[20]</ref>. The Nokia N95 -as many other mobile devices -has a triaxial accelerometer which is used by EnTracked for movement detection. EnTracked only detects two states of movement, i.e. standing still and moving. As we have a robustness requirement stating that we have to position within a certain limit, we are interested in a detection scheme that has a low tolerance for movement, which will ensure that we detect movement very well. We have used the following scheme for movement detection: first, an accelerometer measurement is collected for each of the three axes; next, for each axis the variance of the last 30 measurements is calculated and the three variance values are summed. In Figure <ref type="figure">6</ref> we have plotted such summed variance values for a trace of accelerometer readings collected for a person that, at first is standing still, then starts walking and then stops again. Figure <ref type="figure">6</ref> also plots a manually collected ground truth for when the person was moving. From Figure <ref type="figure">6</ref> we can see that there is a noticeable difference in variance between standing still and moving. To detect movement, we use a threshold which was selected to be 1000 based on the receiver-operating-characteristic curve plotted in Figure <ref type="figure">7</ref> to have an equal tradeoff between detecting still (true positive rate) and not detecting movement (false positive rate).</p><p>As the device running EnTracked could be carried and  handled in many different ways, this might cause false detections. If a person is stationary, but gesturing with the device in hand the accelerometer will detect this movement, which will increase power consumption. If a person is walking with the device in hand, and keeping the device steady, there might not be enough acceleration in any direction for the variance to reach the threshold for movement detection. This poses a problem and can only be solved by using a more clever movement detection scheme such as the ones proposed by Reddy et al. <ref type="bibr" target="#b18">[18]</ref>. However, for EnTracked only one sudden move with the device will make the state change and then speed estimation based on GPS measurements will kick in.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Estimating Speed</head><p>The movement speed of a mobile device vest can be estimated from GPS measurements vgps, however, we need to analyse whether or not it is reliable. GPS modules normally implement a Kalman filter to estimate the speed of the GPS <ref type="bibr" target="#b10">[10]</ref> from GPS positions and measured Doppler shifts of the satellite signals. Therefore we choose to use the GPS module estimated speed because it gives more accurate speed estimates compared to the method used by earlier work such as <ref type="bibr" target="#b8">[8]</ref>, that only takes into consideration the time difference and distance between the two last GPS positions received from the GPS. In order to evaluate the accuracy of the GPS-estimated speed vgps, we compare it with the ground truth speed v groundtruth . The ground truth speed is calculated by interpolating between manually collected timestamps for the visiting of well-known reference spots while collecting GPS measurements. Using a subset of our trace data collected for emulation, we have plotted vest compared to v groundtruth in Figure <ref type="figure">8</ref>. From the figure we see that vgps tends to correlate with v groundtruth . As vgps in many situations is underestimated, we have plotted vgps + vaccuracy in Figure <ref type="figure">8</ref>. vaccuracy is the estimated accuracy of the estimated GPS speed vgps provided by the GPS module. vgps + vaccuracy is generally overestimated, which improves the robustness of the system. However, at very low speeds the GPS speed is largely overestimated because the value of the estimated accuracy is high. Therefore, for detecting stationary situations we rely on movement detection with an accelerometer as presented in Section 4.1.</p><p>In order to save power, we are interested in turning off the GPS, so that it doesn't consume unnecessary power. When the GPS has been put to sleep for some time, we need to know at what point we are able to trust the speed measurements provided by the GPS. Though we want to know the speed as quickly as possible, we don't want to use the speed measurements until they give us the required accuracy, which may vary depending on how long the GPS has been sleeping and the number of measurements vgps is based upon. We have investigated the number of necessary GPS measurements needed in order to get a vgps with sufficient accuracy. Figure <ref type="figure">9</ref> plots measurements where the GPS is put to sleep for a varying period of time and restarted. After restart, vgps based on one through four measurements have been collected, and the difference between vgps and v groundtruth is calculated. During this test v groundtruth is equal to zero meters per second. For reasons that we will not investigate as a part of this work, there are some speed measurements that the used Python library returns as "not a number". In order for such cases not to be neglected, they are placed at the top of the graph (from 7.6 m/s for 4 measurements and up to 7.9 m/s for 1 measurement), but must not be considered valid, inaccurate measurements.</p><p>According to Figure <ref type="figure">9</ref>, it seems that one GPS measurement is sufficient as long as the GPS doesn't sleep more than 30 seconds between measurements. However, as the sleeping period rises to 30 seconds or more, one, two and three measurements become insufficient. From 30 seconds onwards, it seems that four measurements provide the best speed measurements with some inaccuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Error Model</head><p>For calculating the time limit for when to deliver the next GPS measurement to an application, we use the following error model inspired by the error model proposed by Ferrell et al. <ref type="bibr">[9]</ref>. This error model takes into account the estimated uncertainty of the last GPS position delivered to the application ugps, the time since the last GPS position tgps, and the estimated speed vest (as described in Section 4.2). The error model then calculates the current error e model with respect to the last delivered GPS position as defined in Equation <ref type="formula">3</ref>.</p><formula xml:id="formula_3">e model = ugps + (t -tgps) * vest</formula><p>(3) As an estimate for the uncertainty of a GPS position, we use the horizontal accuracy outputted by the GPS in the N95 phone. Most GPS modules are able to output such information calculated based on the quality of the satellite signals and the quality of the signal processing. The horizontal accuracy outputted in Symbian OS is specified to be the 68% error quartile <ref type="bibr" target="#b1">[1]</ref>, which means that in 68% of the time the error should be less than this value. For one of the traces collected for our emulation, we have plotted the real error of a GPS position versus the horizontal accuracy for the GPS position in Figure <ref type="figure" target="#fig_0">10</ref>. The real error was calculated with respect to a manually entered ground truth. From the plot, we can see that the real error is largely overestimated, and to get an on-average more precise estimate, we choose to  use a linear model g(x) = a * x to map the horizontal accuracy outputted by the GPS. The parameter a was found by using linear regression on the trace entries for the following equation g(x) = a * x -2; the -2 was added to (on-average) optimize the error to be overestimated with 2 meters. This value can be changed to trade power efficiency (with smallest possible uncertainty values) and robustness (with largely overestimating uncertainty values). Figure <ref type="figure" target="#fig_0">10</ref> also plots the values that have been mapped by the linear model. Even tough the values are mapped, most still overestimate the error to keep favouring robustness.</p><p>The calculation of the time limit for the next GPS position t limit is based on the application-defined error limit d limit , the current error e model (using Equation <ref type="formula">3</ref>) and the estimated speed vest. The limit is found, using Equation <ref type="formula">4</ref>, as the time it will take the device to move beyond the application limit considering the current error with respect to the last delivered GPS position.</p><formula xml:id="formula_4">t limit = d limit -e model vest (4)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Minimize Consumption</head><p>To minimize the power consumption and to be robust based on the time limit, we need to calculate when to power features on and off. This calculation has to take into account the delays for powering off features and the request delays when powering features on again. To calculate when to power features on and off, we have formalized the problem as a minimization problem for a set of recursive functions as defined in Equation <ref type="formula">5</ref>. The problem is defined for the variables g, r, s that denote the number of seconds since the GPS, radio idle, and radio active, respectively was requested to start powering off. The problem is to find g , r , s (that denote the variable states when the features should be powered on again) in comparison to g0, r0, s0 (the feature states when calculating a solution to the minimization problem). The problem also takes into account the upper time limit t limit as defined in Equation <ref type="formula">4</ref>.</p><formula xml:id="formula_5">reqg(x) = ( 1 if x &lt;= 30 6 if x &gt; 30 reqs(x) = 1 Cu,p(t, x, x0) = 8 &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; : 0 i f t = 0, x = x0 p + Cu,p(t -1, x) i ft &gt; 0, x = 0 Cu,p(t -1, x -1) if t &gt; 0, x &gt; u p + Cu,p(t -1, x -1) if t &gt; 0, 0 &lt; x &lt;= u Undefined else (g , r , s ) = arg min g,r,s {C30,0.324(t -reqg(g), g, g0)</formula><p>+C31,0.466(t, r, r0) + C6,0.645(t, s, s0)|t = t limitreqs(s)} (5) The solution is found by finding the variable values that minimize the sum of the three instances of the power consumption function Cu,p(t, x, x0), where u is the power-off delay, p the power consumption of the feature, and t the time step. To simplify the power consumption function, it is assumed that a solution to the minimization problem will either choose to keep features powered on or to power them off, then later power them on again. Therefore, the function does not model the possibility to turn a feature on again, except as a solution to the problem. The solution for the minimization problem is calculated by an algorithm based on dynamic programming which means that the running time of the algorithm is O(t 2 limit ). Therefore, the running time depends on the representation of t limit , and -to keep the needed number of computations as low as possible -the functions and values in Equation <ref type="formula">5</ref>are restricted to represent time in seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EMULATION</head><p>In this section we present the results of our emulation to study if EnTracked can lower the energy consumption and remain robust when faced with changing system conditions.</p><p>We have implemented the EnTracked system based on a layered architecture as depicted in Figure <ref type="figure" target="#fig_9">11</ref>. From a high-level view there are two layers: a platform layer and a client logic layer. The platform layer represents a device that is capable of providing GPS positions and acceleration measurements. The client logic is implemented such that it can run on top of any platform that can provide it with position and acceleration data.</p><p>For the emulation we exploit this layered design, in that The emulation engine reads data files of the same format as the ones used for the analysis of the phone characteristics. The output of running the EnTracked client on top of the emulation engine contains the same information as running it on the actual N95 phone. Furthermore the emulation engine outputs information on the state of the phone at all emulation time steps. This state information is used in combination with the normal output to calculate power consumption and robustness for various runs of the EnTracked client.</p><p>To evaluate the power consumption of EnTracked, we selected a number of parameter variations to emulate. The data used for emulation was collected using a N95 phone that continuously sampled the GPS position and the accelerometers while walking a predetermined route. During this data collection, the actual position was recorded manually on a small laptop. Based on the collected data we correlated the phone's actual positions with the positions reported by the GPS. We made three data collection runs on the route shown in Figure <ref type="figure" target="#fig_10">12</ref>, each lasting approximately 35 minutes and the percentage of stationary time is 67.1%. The route runs through a parking lot and has a length of 700 meters. We kept the phone stationary for several minutes at three locations, marked in the figure . During the run we made sure only to walk in straight lines and we registered the actual position every time the direction was changed. Furthermore we made sure to maintain a steady pace between these points, which allows us to calculate a reasonable estimate of the ground truth speed.</p><p>We evaluated EnTracked as described in Section 4 and a periodic sampling algorithm in the emulation system. Here we present three emulations: one for which the goal for the positioning precision was defined to be 25 meter, i.e., the system should never report a position that is more than 25 meter from the actual position of the phone; one for which the goal was 100 meter; and one for which the goal was 200 meter. These limits corresponds to the value d limit in Section 4.3.</p><p>A naive approach to obtain the required precision, while still conserving some power compared to continuous sampling, is to sample the position at an interval small enough that it would be impossible to move outside the area bounded by the requested precision between GPS fixes. Assuming that the GPS device is carried by a pedestrian these intervals is every 2.5th second, every 10th second and every 20th second for 25 meter, 100 meter and 200 meter respectively 3 . 3 The interval is based on the assumption that it is very We denote this sampling strategy by the name the periodic strategy. For the emulation, the EnTracked algorithm was limited to the desired precision and in the case that the GPS estimated speed was returned as "not a number" we set the speed to the maximum possible speed of 10 m/s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Robustness</head><p>Our robustness goal is that the real error must remain below a given application limit. We have analyzed the robustness in our emulations for the different strategies by comparing the last GPS position sent to the server with the ground truth known position. The real error is calculated as the difference between these two positions. In Figure <ref type="figure" target="#fig_11">13</ref> and Figure <ref type="figure" target="#fig_12">14</ref> we compare the real error for 10 and a 20 seconds periodic strategies with EnTracked configured with a limit of 100 meters and 200 meters, respectively. From the figures we see that when EnTracked detects the device is stationary, it does not update the position and when it detects that the device is moving, it schedules sleeps depending on the movement speed. During the sleep periods the error increases until the sleep ends and a new GPS position is provided. The longer sleeps for EnTracked with a 200 meter limit can also be seen. unlikely that a pedestrian moves faster than the world record for 100 meter dash  The robustness results for both the periodic strategies and EnTracked and EnTracked(β) with the limits 25 meter, 100 meter and 200 meter are summarized in Table <ref type="table" target="#tab_4">5</ref> as the average real error and the percentage of time the real error went above the threshold limit. EnTracked(β) is our system but without movement detection. The average error is greater for EnTracked(β) because it only schedules sleeps. The reason why the average error is greater for EnTracked with a 200 meter limit than for 25 and 100 meter is that with a limit of 200 meter, longer sleeping periods are scheduled compared to the 25 and 100 meter limits. This also enables EnTracked with the 200 meter limit to provide better energy saving. The reason that the limit is crossed when configured to 25 meter is that a single bad GPS measurement can have an error above the limit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Energy Efficiency</head><p>Based on the emulations we have calculated the power consumption of different periodic strategies and EnTracked using the device model described in Section 3. In Figure <ref type="figure" target="#fig_0">15</ref> and Figure <ref type="figure" target="#fig_0">16</ref> we compare the power consumption for: a 10 and a 20 seconds periodic strategy; EnTracked configured with limits of 100 meters and 200 meters. From the figures we see that when EnTracked detects the device to be still, no position updates are produced, thus the power consumption drops significantly because the GPS and the radio can be switched off. During movement, sleeps are scheduled and depending on their length, the power usage drops significantly. The periodic strategy on the other hand has a repeating static power consumption pattern and never drops significantly because the GPS and radio can never be switched off.</p><p>Table <ref type="table" target="#tab_3">4</ref> summarize the power usage of the periodic strategies and EnTracked and EnTracked(β) for limits of 25m, 100m and 200m. Furthermore the power savings as the percent savings in comparison to the power use of continuous sampling which in our case is similar to a one second periodic strategy. From the table we can see that EnTracked saves considerably more power than the periodic strategy.</p><p>The fact that the EnTracked strategy uses motion detection allows it to save power proportional to the time the device is stationary. Even without using the motion detection we can see that the EnTracked client should be able to conserve a fair amount of power, compared to the periodic strategy. With a limit of 200 meter EnTracked(β) nearly saves as much power as EnTracked because it is able to schedule long sleeps on low estimated speeds. However, if the device is suddenly moved the EnTracked(β) might sleep while the error limit is crossed, because a long sleep has been scheduled. This makes EnTracked preferable over EnTracked(β). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">REAL-WORLD VALIDATION</head><p>In this section, we present our results obtained from prototype deployment during a period of more than one week. The system was deployed for tracking of pedestrian targets in both a residential neighborhood, as shown in Figure <ref type="figure" target="#fig_14">17</ref> and a larger part of the city of Aarhus in Denmark. In the residential-neighborhood deployment, the system was evaluated for energy-efficiency and robustness. For the city deployment the system was evaluated for tracking everyday movements of an office worker focusing on energy-efficiency.</p><p>We deployed EnTracked in three different versions to evaluate some of our design choices in the deployment. First, EnTracked with all functionality. Second, EnTracked(β), without movement detection as described in Section 5, Third, EnTracked(α) both without movement detection and only using a single GPS measurement when estimating speed instead of the selected four. For the deployment we used several N95 phones installed with our EnTracked client, Python for S60 and the Nokia Energy Profiler. For the deployments we used the same implementation of our client as used for emulation only this time connected to the real GPS, accelerometer and UMTS radio on the N95 phones as illustrated in Figure <ref type="figure" target="#fig_9">11</ref>. The deployed clients were configured with a special phone ID for each phone to enable the server to identify the different clients and different application limits that we wanted to test. All other client settings were kept as described in the previous sections of this paper. The clients also logged the state they were in. The server setup used for power profiling, as described in Section 3, was reused for the deployments. In the residential neighborhood deployment, a person walked along a pre-configured route while carrying several phones attached to a small laptop. The route is shown in Figure <ref type="figure" target="#fig_14">17</ref>, it has a length of 1.7 kilometres and contains three stop points highlighted by markers (one of them used twice). At the stop points the person would rest for around five minutes before continuing. The purpose of the route is to mimicking a person walking around in a neighborhood, stopping at certain points to chat with neighbors. The person walking the route was instructed to change walking speed from slow walk around 1 m/s, over moderate speed, around 2 m/s to fast run/jog, around 3 m/s making the system deal with different speeds. Including stopping time, it took around 35 minutes to walk the route. The route was repeated three times. In the first run, the phones was kept still 51.0% of the time, in the second 51.8% of the time and in the third 54.3% of the time. A manually entered ground truth was collected on the laptop using the same method as described in Section 5. Before the person started each repetition the Nokia Energy Profiler was started on all phones and followed by the EnTracked client. When finishing with the route the Nokia Energy Profiler was stopped and trace files exported.</p><p>The route was repeated three times with three, three, and four phones respectively. In the first, second and third run, two phones ran EnTracked(α), EnTracked(β), and En-Tracked, respectively. One phone was configured with a limit of 100 meter and the other with a limit of 200 meter. The reason we left out the 25 m limit is that with a 25 meter limit during walking as shown in Section 5 our strategies will only set the phone to sleep a few seconds at most. Therefore this limit is a less interesting scenario than the higher limits that generate higher sleeping times and therefore are more challenging for our system. The third phone in each of the repetitions had a one second periodic strategy installed to gather reference data for calculating the average GPS accuracy in the area. We have calculated this average value from the gathered data to be 9.04 meters. The fourth phone in the third repetition ran EnTracked with a 100 meter limit but without the uncertainty mapping described in Section 4.3 to favour robustness over energy-efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Robustness</head><p>Our robustness goal is that the real error must remain below a given application limit. We have analyzed the robustness in our deployments by comparing the GPS position known at the server to the ground truth known position. Figure <ref type="figure" target="#fig_0">18</ref> and Figure <ref type="figure" target="#fig_0">19</ref> plots the errors of the server known positions with EnTracked for the limits of 100 meter and 200 meter, respectively. The plots also show the limit and the state of the client: detected to be stationary from accelerometer (A), sleeping until next scheduled GPS measurement (S) and getting GPS position and sending new position to server (G/R).</p><p>From Figure <ref type="figure" target="#fig_0">18</ref> we can observe that the position known at the server is less than the 100 meter limit, except in one situation. Furthermore we see that the accelerometer quite accurately detects the four resting periods and that upon movement, GPS measurements are read and the client is requested to sleep until the next scheduled GPS measurement. The scheduled sleeping periods are on average around 30 seconds with short periods down to 6 seconds and a few long ones up to 102 seconds. It was the sleeping period of 102 seconds that created the situation where the algorithm went above the limit. In this situation the speed was estimated to 0.839 m/s and the error of the current position estimate to 5.82 meters. From these numbers the system calculated a sleeping period of 102 seconds. From the figure we can see that the current error was actually lower, around 1 meter, but what happened is that the person actually speeded up to a speed of 1.59 m/s instead, thus letting the error cross the limit.</p><p>The EnTracked client uses the parameters selected in Section 4. These parameters are selected to prioritize robustness and energy-efficiency equally. However, our system can be configured to have different prioritizations, which can help avoid situations, where the error can cross the limit. As stated earlier a version of EnTracked without the uncertainty mapping proposed in Section 4.3 was also deployed and the result is shown in Figure <ref type="figure" target="#fig_15">20</ref> overlaid on the error graph for the normal EnTracked version with a limit of 100 meter. From the figure we can see that for EnTracked with- out the uncertainty mapping, the calculated sleep periods become shorter so more GPS measurements are taken and therefore the error spikes become smaller. But more GPS measurements of course increases the power consumption as will be discussed in Section 6.2.</p><p>From Figure <ref type="figure" target="#fig_0">19</ref> we can see, that with a 200 meter limit the sleep periods are longer, on average 90 seconds. In all situations the error remains under the limit. We can also observe that because the sleeping intervals are larger, the client takes longer time to realize that the device has stopped moving, e.g., for the sleeping period between 544 and 602 seconds and between 1324 and 1468 seconds. This means that it takes longer time before we can switch to the accelerometer for observing when the device starts moving again. To enable the system to react faster to movement, an improvement to our system would be to consider cancelling sleeping periods if the client is detected to be stationary for a period of time.</p><p>The robustness results for all three versions are summarized in Table <ref type="table" target="#tab_4">5</ref> as the average error and the percentage of time the error went above the limit. From these numbers we see that the average error is higher for the 200 meter limit than for the 100 meter limit, as we would expect. That there is a trend, is especially clear for the 200 meter strategy, which has a declining average error for EnTracked compared to the two other versions. Furthermore we can see that errors above the limit happened less frequently for the 200 meter limit. For the 100 meter limit the unlisted version with no uncertainty mapping had an average error around 24.4 meter, nearly the same as with the mapping. However, no errors above the limit were produced by the client.</p><p>Compared to the emulation results there were more situations were the error went above the limit. One reason for this difference is that during emulation EnTracked received better speed estimates than during deployment. The reason is that the emulation data was collected continuously with one GPS measurements per second and as discussed in Section 4.2 this gives much more precise measurements than when the GPS is turned off between measurements. However, the deployment area was also larger and the target did at no point walk back following the same line which also contributes to larger errors. Among the different EnTracked versions in both the emulations and the deployment En-Tracked gave the best results in terms of both average error and limit crossing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Energy Efficiency</head><p>In the deployments the Nokia Energy Profiler was used to collect power consumption traces on the phones. The power consumption is plotted in Figure <ref type="figure" target="#fig_1">21</ref> and 22 for EnTracked with the limits 100 meter and 200 meter, respectively. The figure also plots the current client state in the same manner as in the previous section. We can see from the figures how the GPS and radio requests increases the power consumption with a factor of twenty compared to the consumption when only the accelerometer is in use. The higher number of GPS and radio requests for the 100 meter limit plot also creates more spikes in the power consumption. We can also notice the time it takes the different features to power off.</p><p>To summarize the results for the different versions Table <ref type="table" target="#tab_5">6</ref> lists the average power consumption and the power savings as the percentage power saved compared to the power usage of continuous sampling, which in our case is similar to a one second periodic strategy. For the 100 meter limit, EnTracked has the lowest average consumption because it effectively power off features when stationary. The EnTracked version without uncertainty mapping mentioned in the previous section consumed a bit more power, 0.864 watt compared to 0.574 watt, so the better robustness causes an increase in power consumption.</p><p>For a limit of 200 meters, EnTracked(β) provides the lowest average consumption because of its ability to schedule long delays. EnTracked on the other hand uses more power for the 200 meter. Maybe because of the extra power consumption for the accelerometer can not be out weighted by the savings it provides. However, the results for EnTracked(β) and EnTracked are not from the same data collection run, thus differences in stopping periods and walking speed can to some degree explain the differences. However, when compared to the periodic strategy all three versions provide large savings.</p><p>The major part of the savings that EnTracked provides is when the device is kept still because the system can enter the lowest power state during such periods. In the collected scenarios the percentages are just above 50%, which is quite low when compared to usual use cases for pedestrian tracking (above 90%<ref type="foot" target="#foot_1">4</ref> ). The reason we collected data with such low a percentage is that it is reasonably argued, that power can be saved easily by using an accelerometer when the device is stationary. We wanted data that focused more on robustness and saving power when moving. To show that for a more normal use case the system can save a lot more power we collected data for a four hour deployment where an office worker carries the phone with EnTracked configured to a 100 meter limit in his jacket pocket. During the deployment the worker walks home from work which is a 1.45 km trip and then hangs the jacket with the phone in the front hall which has windows so GPS reception is still possible. The jacket then hangs there for some hours until the worker later takes a short walk in the neighborhood around 650 meter and then hangs the jacket back again. This scenario also tests the system when placed in a jacket pocket and when  used with free movement. The collected power trace is plotted in Figure <ref type="figure" target="#fig_3">23</ref> and the average power consumption during this trace is 0.173 W which is a 85.7% saving compared to a ten second periodic strategy.</p><p>Compared to the emulation results the deployment power savings were around ten percent points higher. The four hour deployment highlighted that even larger savings can be achieved in more realistic use cases with a higher percentage of still time. For both the emulated and deployed percentage of still time EnTracked had problems outperforming EnTracked(β), however, we speculate that for scenarios with even higher still time such as the four hour deployment this would be the case. However, there is a tradeoff point were the limit is so high that the power used by the accelerometer is higher than what is needed to occasionally wake up to do a position update and calculate a new sleeping period. However, such long sleeps would make the system very slow to react to movement which might result in repeated limit crossings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">DISCUSSION</head><p>The presented work have been based on a single device, i.e., the Nokia N95 8GB phone. Furthermore, we implemented our system using Python. To explore if our system can be generalized to other devices we measured the parameters for the device model on another Symbian S60 phone, i.e., the newer Nokia N96 phone. We found that the N96 phone's delays and power consumption are comparable to the N95. Our system can thus assumably be generalized to other devices running Symbian S60 and Python. Further work is needed to evaluate if our model generalizes to other programming environment, e.g., Symbian C++ or J2ME, other operating systems like Microsoft Windows Mobile and other brands of phones.</p><p>One method to address that device models might have to be parameterized for different brands of phones is auto calibration. Some operating systems provide an API for collecting power measurements. Given such an API it would be possible to write an application that could automatically profile a new device for power consumption and delays by starting and stopping features and measuring the consumed power when they power off. The needed parameters for the device model could then be calculated from the collected profiling data.</p><p>In our emulations and deployments we only experienced very bad GPS accuracy above 200 meter a few times. One of the methods EnTracked use to fight such situations is to use the GPS-estimated uncertainty to quickly schedule a new measurement if a potential bad measurement is received. For the cell network we generally experienced good communication throughput. However, in our logs we see that some resending of packets have taken place, and thereby increasing the delay for delivering position updates to the server.</p><p>In this work we evaluated tradeoffs between robustness and energy efficiency. In the case where we traded energy efficiency for robustness the power consumption was increased from 0.574 watt to 0.864 watt, which is a substantial increase. However, for this case we only changed one out of several possible adjustments points in our system. For instance, when we selected the delays in the device model we selected the average values instead of selecting more conservative values such as the average and two times the standard deviation. Therefore it would be relevant to study the different adjustment points in more detail, in order to understand which ones are the best to use for tuning the system towards either robustness or energy efficiency.</p><p>A simple threshold-based algorithm for movement detection was applied but more advanced algorithms do exists. Advanced algorithms could determine the mode of transportation such as those proposed by Reddy et al. <ref type="bibr" target="#b18">[18]</ref>. It would be relevant to extend the systems with such algorithms to allow the tracking to scale to biking and car driving as well. Furthermore such algorithms are also better at handling the many different ways that a person can carry a phone; and ignore movements that are not part of an actual movement, e.g., gestures.</p><p>An optimization for the system would be to skip sending position updates to the server if the newly measured position is close to the one that the server already know. Also it could increase power savings for EnTracked if the accelerometer could be powered off when not needed, however, due to the Python library used, this is not possible in the current version. Also more power could be saved if the Python library allowed control of or simply was able to minimize the power-off delays. In this paper we focused on position-based applications that run on a server or a different device than the tracked device. However, for applications running locally on the device the proposed system could be used for optimizing the use of the GPS only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>The primary contribution of this paper is the novel En-Tracked system that can track mobile devices robustly and energy-efficiently. We profiled how devices consume power for tracking and proposed a device model that can account for the real power consumption of a concrete device family. Furthermore, we propose methods for position tracking that take the changing system conditions into account, specifically radio delays, positioning delays and position accuracy. We also proposed a method that can minimize power consumption and satisfy robustness by calculating the optimal plan for when to power on and off features of the mobile devices such as the GPS module.</p><p>The results of our emulation was that the proposed methods can lower the energy consumption considerably and remain robust when faced with changing system conditions. These emulation results was validated by our real-world deployment where a mobile device was successfully energyefficiently tracked in an urban environment. The results also provide insights into the limitations of our system and led to discussions on how to address these, e.g., by changing the trade-off between robustness and energy efficiency.</p><p>In our ongoing work we are trying to address several issues. These are: First, a further exploration of how to tune parameters of our system to realize the best trade-offs between robustness and energy efficiency. Second, propose methods for automatically determine the parameters of our device model for new devices. Third, apply the proposed methods and findings to other positioning technologies such as location fingerprinting <ref type="bibr" target="#b11">[11]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Average power consumption for periodic position updating measured on a N95.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Request delays for GPS and the radio for different periods between requests on a N95.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Over time for 60 seconds periodic tracking</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Power consumption on a Nokia N95, with the instantaneous model and the proposed model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: The steps of EnTracked when used by a position-based application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Figure 6: Summed variance for each of the axes over accelerometer data for 30 measurements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 Figure 10 :</head><label>810</label><figDesc>Figure 8: GPS speed versus ground truth speed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: System architecture for emulation and deployment</figDesc><graphic coords="9,361.08,53.95,150.60,184.31" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Route used for collection of emulation data. (0.7km)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Real error in emulation with a limit of 100 meter and a periodic strategy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Real error in emulation with a limit of 200 meter and a periodic strategy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 15 :Figure 16 :</head><label>1516</label><figDesc>Figure 15: Emulated power consumption with a limit of 100 meter and a periodic strategy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 17 :</head><label>17</label><figDesc>Figure 17: Residential neighborhood overlaid with walking route and stop points.</figDesc><graphic coords="11,60.36,328.50,225.90,157.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 20 :</head><label>20</label><figDesc>Figure 20: Real error for 100 meter limit with no uncertainty mapping</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>Figure 23: Power consumption over four hours</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : N95 features' power consumption.</head><label>1</label><figDesc></figDesc><table><row><cell>Feature</cell><cell cols="2">Avg. Power [watt] Std. Dev. [watt]</cell></row><row><cell>Idle (ip)</cell><cell>0.0621</cell><cell>0.0173</cell></row><row><cell>Idle (ip) + Logging</cell><cell>0.0647</cell><cell>0.0197</cell></row><row><cell>Accelerometer (ap)</cell><cell>0.0503</cell><cell>0.035</cell></row><row><cell>GPS (gp)</cell><cell>0.324</cell><cell>0.0435</cell></row><row><cell>Radio idle (rp)</cell><cell>0.466</cell><cell>0.0324</cell></row><row><cell>Radio active (sp)</cell><cell>0.645</cell><cell>0.0470</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 : N95 power-off delays for features.</head><label>2</label><figDesc></figDesc><table><row><cell>Feature</cell><cell cols="2">Avg. [second] Std. Dev [second]</cell></row><row><cell>GPS</cell><cell>30.0</cell><cell>0.735</cell></row><row><cell>Radio idle</cell><cell>31.3</cell><cell>0.337</cell></row><row><cell>Radio active</cell><cell>5.45</cell><cell>0.774</cell></row><row><cell cols="2">the values listed in Table</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 : Robustness results as average error and percentage of time above the error limit.</head><label>3</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="3">Periodic EnTracked(β) EnTracked</cell></row><row><cell></cell><cell>25m</cell><cell>8.2</cell><cell>8.4</cell><cell>7.8</cell></row><row><cell>Avg.[m]</cell><cell>100m</cell><cell>8.6</cell><cell>16.4</cell><cell>10.6</cell></row><row><cell></cell><cell>200m</cell><cell>9.6</cell><cell>24.4</cell><cell>14.3</cell></row><row><cell></cell><cell>25m</cell><cell>2.0%</cell><cell>3.2%</cell><cell>2.2%</cell></row><row><cell>Limit</cell><cell>100m</cell><cell>0.0%</cell><cell>0.0%</cell><cell>0.0%</cell></row><row><cell></cell><cell>200m</cell><cell>0.0%</cell><cell>0.0%</cell><cell>0.0%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 : Power consumption</head><label>4</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="3">Periodic EnTracked(β) EnTracked</cell></row><row><cell></cell><cell>25m</cell><cell>1.468</cell><cell>1.351</cell><cell>0.781</cell></row><row><cell>Avg.[W]</cell><cell>100m</cell><cell>1.331</cell><cell>0.851</cell><cell>0.710</cell></row><row><cell></cell><cell>200m</cell><cell>1.264</cell><cell>0.608</cell><cell>0.600</cell></row><row><cell></cell><cell>25m</cell><cell>0.0%</cell><cell>6.89%</cell><cell>43.36%</cell></row><row><cell>Savings</cell><cell>100m</cell><cell>9.19%</cell><cell>40.55%</cell><cell>48.73%</cell></row><row><cell></cell><cell cols="2">200m 13.58%</cell><cell>56.05%</cell><cell>56.20%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 : Robustness results for different versions and limits.</head><label>5</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="3">EnTracked(α) EnTracked(β) EnTracked</cell></row><row><cell></cell><cell>100m</cell><cell>25.9</cell><cell>30.2</cell><cell>24.8</cell></row><row><cell>Avg.[m]</cell><cell>200m</cell><cell>47.7</cell><cell>44.9</cell><cell>34.8</cell></row><row><cell></cell><cell>100m</cell><cell>2.5%</cell><cell>5.7%</cell><cell>2.6%</cell></row><row><cell>Limit</cell><cell>200m</cell><cell>5.1%</cell><cell>0.0%</cell><cell>0.0%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 : Power consumption for different version and limits.</head><label>6</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="3">EnTracked(α) EnTracked(β) EnTracked</cell></row><row><cell></cell><cell>100m</cell><cell>0.630</cell><cell>0.600</cell><cell>0.574</cell></row><row><cell>Avg.[W]</cell><cell>200m</cell><cell>0.451</cell><cell>0.379</cell><cell>0.462</cell></row><row><cell></cell><cell>100m</cell><cell>58.6%</cell><cell>60.6%</cell><cell>62.3%</cell></row><row><cell>Savings</cell><cell>200m</cell><cell>70.4%</cell><cell>75.1%</cell><cell>69.7%</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We have based this value on the average energy consumption for updating position every second, assuming that one update takes one second.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>corresponds to less than two and a half hours of movement per day.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Anders Kabell Kristensen for helping collecting measurements. The authors acknowledge the financial support granted by the Danish National Advanced Technology Foundation under J.nr. 009-2007-2.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Associated with the Alexandra Institute A/S, Denmark † Associated with the Danish Agricultural Advisory Service, National Centre, Denmark ‡ Associated with Systematic A/S, Denmark</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.forum.nokia.com" />
		<title level="m">Location Acquisition API: Using Location Acquisition API</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Nokia -Energy</forename><surname>Profiler</surname></persName>
		</author>
		<ptr target="http://www.nokia.com" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://sourceforge.net/projects/pys60" />
		<title level="m">Python for S60</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Ghosts in the machine: Interfaces for better power management</title>
		<author>
			<persName><forename type="first">M</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference on Mobile Systems, Applications, and Services</title>
		<meeting>the Second International Conference on Mobile Systems, Applications, and Services</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Linux Laptop Battery Life</title>
		<author>
			<persName><forename type="first">L</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Karasyov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Levedev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Starikovskiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Stanley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Linux Symposium</title>
		<meeting>of the Linux Symposium</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Design, analysis, and implementation of a large-scale real-time location-based information sharing system</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Mobile Systems, Applications, and Services</title>
		<meeting>the 6th International Conference on Mobile Systems, Applications, and Services</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Techniques for efficient road-network-based tracking of moving objects</title>
		<author>
			<persName><forename type="first">A</forename><surname>Civilis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pakalnis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="698" to="712" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Energy-efficient monitoring of mobile objects with uncertainty-aware tolerances</title>
		<author>
			<persName><forename type="first">T</forename><surname>Farrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Database Engineering and Applications Symposium</title>
		<meeting>the Eleventh International Database Engineering and Applications Symposium</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Energy-efficient tracking of mobile objects with early distance-based reporting</title>
		<author>
			<persName><forename type="first">T</forename><surname>Farrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th Int. Conference on Mobile and Ubiquitous Systems</title>
		<meeting>4th Int. Conference on Mobile and Ubiquitous Systems</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Understanding GPS: Principles and Applications</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hegarty</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Artech House Incorporated</publisher>
		</imprint>
	</monogr>
	<note>second edition edition</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Taxonomy for Radio Location Fingerprinting</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Kjaergaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Symposium on Location and Context Awareness</title>
		<meeting>the Third International Symposium on Location and Context Awareness</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient proximity and separation detection among mobile targets for supporting location-based community services</title>
		<author>
			<persName><forename type="first">A</forename><surname>Küpper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Treu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mobile Computing and Communications Review</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A map-based dead-reckoning protocol for updating location information</title>
		<author>
			<persName><forename type="first">A</forename><surname>Leonhardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nicu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 16th Int. Parallel and Distributed Processing Symposium</title>
		<meeting>16th Int. Parallel and Distributed Processing Symposium</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A comparison of protocols for updating location information</title>
		<author>
			<persName><forename type="first">A</forename><surname>Leonhardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cluster Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="355" to="367" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Micro power management of active 802.11 interfaces</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Mobile Systems, Applications, and Services</title>
		<meeting>the 6th International Conference on Mobile Systems, Applications, and Services</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Computer Network Time Synchronizationthe Network Time Protocol</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mills</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>CRC Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">S60 Platform: Effective Power and Resource Management, Version 3.1. Nokia</title>
		<author>
			<persName><surname>Nokia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Determining transportation mode on mobile phones</title>
		<author>
			<persName><forename type="first">S</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Burke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The 12th IEEE Int. Symposium on Wearable Computers</title>
		<meeting>The 12th IEEE Int. Symposium on Wearable Computers</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dynamic localization protocols for mobile sensor networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tilak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kolar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">B</forename><surname>Abu-Ghazaleh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IWSEEASN</title>
		<meeting>IWSEEASN</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Impact of sensor-enhanced mobility prediction on the design of energy-efficient localization</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wen You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-H</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-R</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-Y</forename><surname>Lau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ad Hoc Networks</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1221" to="1237" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
