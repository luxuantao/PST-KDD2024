<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Implementing Declarative Overlays</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thau</forename><surname>Loo</surname></persName>
							<affiliation key="aff5">
								<orgName type="department">Boon Thau Loo and Tyson</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Petros</forename><surname>Maniatis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Tyson</forename><surname>Condie</surname></persName>
							<affiliation key="aff5">
								<orgName type="department">Boon Thau Loo and Tyson</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Timothy</forename><surname>Roscoe</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
						</author>
						<author>
							<persName><forename type="first">U</forename><forename type="middle">C</forename><surname>Berkeley</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">UC Berkeley</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Intel Research Berkeley</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">UC Berkeley</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Intel Research Berkeley</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Intel Research Berkeley UC Berkeley Ion Stoica</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Implementing Declarative Overlays</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B42E17910020E8B1DC210F21291EAA98</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Computer Communication Networks]: Distributed Systems-distributed applications</term>
					<term>D.4.7 [Operating Systems]: Organization and Design-Distributed systems</term>
					<term>C.2.2 [Computer Communication Networks]: Network Protocols-protocol architecture, routing protocols Design, Experimentation, Languages Declarative overlays, dataflow engines, executable pseudocode</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Overlay networks are used today in a variety of distributed systems ranging from file-sharing and storage systems to communication infrastructures. However, designing, building and adapting these overlays to the intended application and the target environment is a difficult and time consuming process.</p><p>To ease the development and the deployment of such overlay networks we have implemented P2, a system that uses a declarative logic language to express overlay networks in a highly compact and reusable form. P2 can express a Naradastyle mesh network in 16 rules, and the Chord structured overlay in only 47 rules. P2 directly parses and executes such specifications using a dataflow architecture to construct and maintain overlay networks. We describe the P2 approach, how our implementation works, and show by experiment its promising trade-off point between specification complexity and performance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Large-scale distributed systems inherently use one or more application-level overlay networks as part of their operation. In some cases, the overlay is prominent: for example, filesharing networks maintain neighbor tables to route queries. In other systems the overlay or overlays may not be as explicit: for example, Microsoft Exchange email servers within an enterprise maintain an overlay network among themselves using a link-state algorithm over TCP for routing mail and status messages.</p><p>This paper describes P2, a facility (deployable as a service or library) for the declarative construction, maintenance, and sharing of overlay networks. Applications submit to P2 a concise logical description of an overlay network, and P2 executes this to maintain routing data structures, perform resource discovery, and optionally provide forwarding for the overlay.</p><p>P2 is intended to greatly simplify the process of selecting, implementing, deploying and evolving an overlay network design. It is novel in (a) using a declarative logic language for specifying overlays, and (b) employing a dataflow framework at runtime for maintaining overlays instead of the more conventional finite state machine approach. P2 automatically compiles the declarative specification of the overlay into a dataflow program, and can compile multiple overlay specifications into a single dataflow.</p><p>We believe that these innovations together promise two advantages: ease of specification, and sharing/reuse of code. P2 overlay descriptions can be extremely concise. For example, Chord <ref type="bibr" target="#b34">[34]</ref> can be specified in 47 simple logic rules, versus thousands of lines of code for the MIT Chord reference implementation and more than 320 statements in MACE-DON <ref type="bibr" target="#b30">[30]</ref>, which is a much less complete implementation than ours. Also, the high-level, declarative nature of P2 specifications means that they decompose cleanly into logically reusable units: for example, a Symphony DHT <ref type="bibr" target="#b23">[23]</ref> might share many of the definitions in the Chord specification.</p><p>This facilitates not only code reuse among systems, but also the comparison, extension, and hybridization of overlay designs within a single system. Moreover, describing overlays declaratively (effectively as queries) enables the natural integration of distributed information-gathering tasks like resource discovery and network status monitoring.</p><p>Unlike some other proposals for overlay toolkits, P2 does not aim for performance results as good as optimized C, C++, or Java implementations. Instead, our first aim is to demonstrate that declarative overlay descriptions can be implemented by P2 with acceptable performance, and that there are benefits to the declarative specification that go beyond the raw performance of a single overlay design. We believe that this is useful for rapidly prototyping new ideas, and eventually for deploying production systems as well. This is not to say that P2 code is slow. P2's memory footprint running a full Chord implementation is relatively small (about 800 kB of working set) and its CPU usage is comparable to C++ implementations. However, the P2 specifications we discuss in this paper support a new design point on the trade-off between a high degree of specification compactness and the fine-grained timer tuning and adaptivity optimizations that pepper the code of mature, efficient but painstaking overlay implementations.</p><p>Ultimately, our argument for P2 is similar to the argument for SQL and relational database management systems some 35 years ago. The initial goals of our implementation are also akin to those of the early relational database systems: to explore the feasibility of the declarative approach in practice at a coarse grain, without trying to capture all possible optimizations in the first generation of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Contributions and Overview</head><p>This paper makes the following contributions. First, we show how a diverse set of overlays can be expressed concisely in a declarative specification language. Second, we show how such specifications can usefully be executed as overlay maintenance protocols -sharing communication, state, and computation -by our implementation, the P2 distributed dataflow engine. Finally, we demonstrate experimentally that such overlays have acceptable performance compared to hand-coded implementations.</p><p>The rest of this paper is structured as follows. In Section 2 we outline the main features of our approach: using a declarative logic language to specify an overlay, and compiling it to an executable graph of dataflow elements. We contrast this approach to the typical techniques from the literature. In Section 3 we discuss our implementation of P2 and the specific challenges we encountered, and then in Section 4 we examine in detail a relatively complex overlay (Chord <ref type="bibr" target="#b34">[34]</ref>) as implemented over P2. Section 5 evaluates the performance of this network, and shows it to be acceptable despite the simplicity of the specification. Section 6 situates our work in the context of other language-based approaches and related research in data processing systems. We conclude in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">APPROACH</head><p>In this section we provide a broad overview of the P2 approach to overlay specification and runtime execution. In the past, overlay networks have typically been characterized in one of two ways. The protocol-centric approach favored by MACEDON <ref type="bibr" target="#b30">[30]</ref> traces its roots to event languages <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b35">35]</ref> that specify overlay execution via automata for event and message handling. This style emphasizes the dynamics of the overlay and its maintenance, but makes it difficult to determine the overlay's coarse structure and invariant properties. The alternative is a structure-centric approach, whose roots can be traced to the specification of parallel interconnection networks <ref type="bibr" target="#b19">[19]</ref>. This style, which has influenced the literature on distributed hash tables (DHTs), specifies overlays by focusing on a network graph structure (hypercube, torus, de Bruijn graph, small-world graph, etc.), whose invariant properties must be maintained via asynchronous messaging. Unfortunately, graph-theoretic descriptions tend to be expressed at a high level in natural language, and often gloss over details of the actual runtime messaging. As a result, implementing structure-centric overlays often requires a fair bit of engineering <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b29">29]</ref>, and different implementations of the same overlay can vary significantly in their actual execution.</p><p>P2 spans the two approaches above, and expands upon them in a way that we believe is particularly attractive for overlay specification and runtime. The interface of P2 is closer in spirit to the structure-centric approach, in that it encourages the specification of overlays as logical structures with invariants. However, it also automatically compiles this specification to a dataflow program for managing asynchronous messages, which looks closer to the protocolcentric approach. We believe P2 improves upon previous overlay specification work in either camp, by providing a machine-interpretable description language based on relations among node states in the network, and by using a dataflow runtime model instead of automaton-based protocols.</p><p>Here, we provide a high-level view of the three components of our approach: the use of relational tables to represent overlay state, our high-level declarative language to specify the overlay's logical properties and behavior, and graphs of dataflow elements to represent runtime information processing. The specific implementation details of these components are deferred until Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Tables and Streams</head><p>We model an overlay as a distributed data structure, represented via a set of structured relations (sets of tuples) as in a relational database. P2 employs two types of relations: soft-state tables, and streams of transient tuples, as in stream query engines <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b26">26]</ref>.</p><p>There are many ways to represent network graphs, but the relational approach seems attractive for a variety of reasons. First, structured tables are a simple and natural representation for network state; for example, neighbor tables are widely used in networks. Second, and more importantly for our purposes, tables and relationships between them are easy to represent concisely in a declarative language, as the success of SQL has shown. Third, the distributed database abstraction provides a consistently-named view of all the local tables and messages at different nodes: queries and rules can specify distributed state in a high-level, concise way.</p><p>Finally, the relational abstraction is a natural way to reuse functionality and share routing state among different overlays. Tables with multiple indices can store tuples relevant to several overlays or parts of overlays, which can select elements from each table with their own criteria. For instance, a table holding network links along with their measured capacity and latency can be shared between a latencyconscious overlay as well as a capacity-conscious overlay. Table names (with appropriate namespace scoping) provide a natural way to share definitions between multiple overlay specifications.</p><p>Our experience with overlay implementations has shown that relations, together with some suitable mechanisms for selecting tuples from each table, can fairly naturally represent the persistent routing state of the overlays we considered. We give examples later in support of this claim.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The OverLog language</head><p>Having established our data model, we turn our attention to the P2 specification language for overlays. As noted above, we choose to specify overlays declaratively via a logic language. Our language, which we term OverLog, is based on the widely-used Datalog <ref type="bibr" target="#b2">[2]</ref> query language.</p><p>A few preliminary remarks are in order to frame the discussion that follows. Datalog itself is a general declarative query language -a subset of Prolog free from operational (imperative) constructs. OverLog is not a pure logic language like Datalog; we add constructs to specify physical distribution properties (in particular, where tuples are physically generated, stored, or sent), continuous queries over streams as well as tables, and deletion of tuples from tables.</p><p>Note that OverLog is not designed as a Domain-Specific Language for overlay specification; it is simply an adaptation of a powerful query language to a distributed context of data and messages. Our motivation for the design of OverLog was to investigate which language features are of particular value for specifying the properties of overlay networks, and so lay the groundwork for a future, dedicated overlay description language. We reflect on the suitability of OverLog for overlay specification in Section 4.1.</p><p>Despite these caveats, overlay descriptions in OverLog are remarkably concise, especially considering that they can be directly translated by P2 into dataflow graphs that maintain overlay networks. In the rest of this section, we introduce OverLog progressively by example, giving a specification of a mesh overlay like that used by Narada <ref type="bibr" target="#b8">[8]</ref> in <ref type="bibr" target="#b16">16</ref> Over-Log rules. Later in the paper we compare the performance of our full Chord implementation, specified in 47 rules, to published results from a handcoded implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">OverLog by Example: A Narada Mesh</head><p>Narada is a popular overlay multicast system, which implements the multicast functionality using two layers: the first layer constructs and maintains a mesh connecting all members in the group, while the second layer constructs delivery trees on top of the mesh using a DVMRP-like multicast algorithm <ref type="bibr" target="#b11">[11]</ref>. We focus on constructing a Narada-like mesh here as an example of the use of OverLog.</p><p>Briefly, the mesh maintenance algorithm works as follows. Each node maintains a set of neighbors, and the set of all members in the group. Every member epidemically propagates keep-alives for itself, associated with a monotonically increasing sequence number. At the same time, neighbors exchange information about membership liveness and sequence numbers, ensuring that every member will eventually learn of all the other group members' liveness. If a member fails to hear from a direct neighbor for a period, it declares its neighbor dead, updating its own membership state and propagating this information to the rest of the population.</p><p>In addition, each node A periodically probes a random group member B measuring their round-trip latency. If the probed node (B) improves the routing utility of node A by a certain threshold, node A adds node B to its neighbor set. Similarly, if node A concludes that the cost of a link to neighbor B exceeds some predefined threshold, it removes B from its neighbor set.</p><p>In the rest of this section, we show how the mesh maintenance portion of Narada can be expressed in OverLog. In the interest of brevity, we omit node removal and recovery from network partitions.</p><p>An OverLog program is largely composed of table declaration statements and rules; we consider each in turn. As in Datalog, the number and types of fields in relations are inferred from their (consistent) use in the program's rules. However, unlike Datalog, tables must be defined explicitly in OverLog via "materialization" statements, which specify constraints on the size and soft-state lifetime of tuple storage -any relations not declared as tables are treated as named streams of tuples. For example, the declarations: materialize(neighbor, 120, infinity, keys(2)). materialize(member, 120, infinity, keys(2)). materialize(sequence, infinity, 1, keys(2)).</p><p>specify that neighbor and member are tables whose tuples are retained for 120 seconds and have unbounded size, while sequence allows a single entry that does not expire. The keys(...) construct specifies the position of the tuple field or fields making up the primary key of each table. Each tuple within a table has unique primary-key fields.</p><p>Much like Datalog and Prolog, OverLog rules have the form [&lt;ruleID&gt; &lt;head &gt; :-&lt;body&gt;.] where the &lt;body&gt; is a list of relations ("predicates") over constants and variables, and the &lt;head &gt; defines a set of tuples derived by variable assignments satisfying the body's predicates. The order in which the rules are presented is immaterial. The commas separating the predicates in a &lt;body&gt; are interpreted as logical conjuncts (AND), and the order in which predicates appear in a &lt;body&gt; has no semantic significance. Following Prolog and Datalog, names for tuples, predicates, function symbols, and constants in OverLog begin with a lower-case letter, while variable names begin with an uppercase letter.</p><p>Narada periodically gossips with neighbors to refresh membership information. We start with a rule that causes a node to initiate a refresh: R1 refreshEvent(X) :-periodic(X, E, 3).</p><p>In Datalog, this rule with identifier R1 would be read as "table refreshEvent has a row with value (X), for any X, if table periodic has a row with value (X, E, 3), for some E." Because of the use of streams and continuous queries in P2, the OverLog interpretation is slightly different.</p><p>First, periodic is a built-in term; it is not a stored table but a stream that periodically produces a tuple with a unique identifier E at node X -in this example the period is 3 seconds. Since refreshEvent and periodic are data streams rather than stored tables, it is more appropriate to read this rule as "generate a refreshEvent tuple with a value (X) whenever you see a periodic tuple of value (X, E, 3)."</p><p>Before a Narada node can refresh its neighbors, it must update its own sequence number, stored in the singleton table sequence.</p><p>R2 refreshSeq(X, NewSeq) :-refreshEvent(X), sequence(X, Seq), NewSeq := Seq + 1. R3 sequence(X, NewS) :-refreshSeq(X, NewS). MemberLive is a boolean indicating whether the local node believes a member is live or has failed. We now introduce location specifiers, which annotate the components of a rule to specify the node at which the tuples in question should exist. Consider the following:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Every time the</head><p>R4 member@Y(Y, A, ASeqX, TimeY, ALiveX) :-refreshSeq@X(X, S), member@X(X, A, ASeqX, _, AliveX), neighbor@X(X, Y), not member@Y(Y, A, _, _, _), TimeY := f_now@Y().</p><p>This is read as follows: "if a refreshSeq tuple is seen at node X with fields (X, S), and a (X, A, ASeqX, , ALiveX) tuple is in X's member In terms of Narada, rule R4 specifies that whenever a refresh happens at node X, for any of X's members unknown to Y, a copy of X's member tuple for that member appears in Y's table, with Y's insertion time updated. Note here that this logical rule makes no mention of where the complex body of the rule will be executed, or how many network messages will be sent. Alternatively, a programmer could have specified this functionality with explicit message transmissions (see Appendix A).</p><p>Rule R5 below specifies how Y updates an existing member entry when X performs a refresh.</p><p>R5 member@Y(Y, A, ASeqX, TimeY, ALiveX) :-refreshSeq@X(X, S), member@X(X, A, ASeqX, _, ALiveX), neighbor@X(X, Y), member@Y(Y, A, ASeqY, _, _), ASeqY &lt; ASeqX, TimeY := f_now@Y().</p><p>If both X and Y know member A, and if the sequence number that Y knows for A is older than that in X's member entry, then Y updates its own entry for A with X's sequence number and the wall-clock time at Y. Finally, every time X refreshes Y, Y updates its member entry for X itself, as per rule R6.</p><p>R6 member@Y(Y, X, S, TimeY, true) :-refreshSeq@X(X, S), neighbor@X(X, Y), TimeY := f_now@Y().</p><p>To join the mesh, a new node need only know one member of the mesh, placing that member into its neighbor table.</p><p>N1 neighbor@Y(Y, X) :-refreshSeq@X(X, S), neighbor@X(X, Y).</p><p>This rule ensures that neighbor relationships are mutual. Finally, rules L1-4 check neighbor liveness. Every second, rule L1 initiates a neighbor check by which rule L2 declares dead a neighboring member that has failed to refresh for longer than 20 seconds. Dead neighbors are deleted from the neighbor table by rule L3 and rule L4 sets a dead neighbor's member entry to be "dead" and further propagated to the rest of the mesh during refreshes.</p><p>L1 neighborProbe@X(X) :-periodic@X(X, E, 1). L2 deadNeighbor@X(X, Y) :-neighborProbe@X(X), neighbor@X(X, Y), member@X(X, Y, _, YT, _), f_now() -YT &gt; 20. L3 delete neighbor@X(X, Y) :-deadNeighbor@X(X, Y). L4 member@X(X, Neighbor, DeadSeq, T, false) :-deadNeighbor@X(X, Neighbor), member@X(X, Neighbor, S, _, _), DeadSeq := S + 1, T:= f_now().</p><p>Note that rule L3 introduces an additional syntactic construct (delete), used to delete tuples from a stored table.</p><p>Narada continuously improves its mesh by measuring network latency to all members.</p><p>P0 pingEvent@X(X, Y, E, max&lt;R&gt;) :periodic@X(X, E, 2), member@X(X, Y, _, _, _), R := f_rand().</p><p>Every 2 seconds, rule P0 picks a member at random with which to measure round-trip latency. Specifically, it associates a random number with each known member, and then chooses the member associated with the maximum random number. Note that function&lt;fields&gt; denotes an aggregation function, max in this example.</p><p>P1 ping@Y(Y, X, E, T) :-pingEvent@X(X, Y, E, _), T := f_now@X(). P2 pong@X(X, Y, E, T) :-ping@Y(Y, X, E, T). P3 latency@X(X, Y, T) :-pong@X(X, Y, E, T1), T := f_now@X() -T1.</p><p>When a tuple appears in data stream pingEvent, rule P1 pings the randomly chosen member stored in the event, rule P2 echoes that ping, and rule P3 computes the round-trip latency of the exchange. Nodes use such latency measurements -along with the paths computed by a routing protocol operating on top of the mesh -to compute a utility function. A node may add to its neighbors a member that is not currently a neighbor if the utility gain of doing so lies over an addition threshold. Similarly, if the cost of maintaining a current neighbor is greater than a removal threshold, the node may break its link with that neighbor. We show how neighbor addition would work in an OverLog implementation of Narada below. We assume that each node maintains a routing table over the mesh which contains for each member the next hop to that member and the cost of the resulting path; e.g., route@X(X, Y, N, C) indicates that node X must route via next-hop node N to get to destination Y with a path latency of C.</p><p>Rule U1 measures the utility gain that could be obtained if node Z were to become X's immediate neighbor, as per the Narada definition <ref type="bibr" target="#b8">[8]</ref>. For an individual destination Y, this is computed by taking the latency of Z's path to Y and adding the latency between X and Z to it. If this new path latency (assuming Z becomes the next hop from X) is lower than the current latency of X's route to Y, then the relative decrease in latency contributes to the utility gain by adding neighbor Z. If this utility gain is above a threshold addThresh, then rule U2 adds this new neighbor U2 neighbor@X(X, Z) :-ugain@X(X, Z, UGain), UGain &gt; addThresh.</p><p>Appendix A collects the mesh formation portion of our Narada specification in OverLog. This specification consists of just 16 rules and 3 table declarations. The OverLog specification is perhaps not as easy to read as pseudocode, but remarkably it can be directly compiled and executed by a set of P2 nodes to maintain a Narada-style mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Dataflow</head><p>Given that OverLog is a declarative query-like language over distributed nodes, it is natural to consider compiling it into an executable representation akin to a database "query plan." Parallel and distributed database query systems like Gamma <ref type="bibr" target="#b12">[12]</ref>, Volcano <ref type="bibr" target="#b14">[14]</ref> and PIER <ref type="bibr" target="#b16">[16]</ref> use dataflow graphs as their basic query executables: these graphs connect various database "operators" with dataflow edges that represent the passing of tuples among operators, possibly across a network. A query engine runtime can execute these dataflow programs over stored and streaming data sources.</p><p>Traditionally, network implementation models are built on automaton abstractions, which do not appear at first sight to have much in common with database query plans. However software router toolkits like Scout <ref type="bibr" target="#b25">[25]</ref>, Click <ref type="bibr" target="#b18">[18]</ref> and XORP <ref type="bibr" target="#b15">[15]</ref> in recent years have demonstrated that network message handling and protocol implementation can be neatly factored into dataflow diagrams, and that this model provides clarity and extensibility beyond that offered by automata, without sacrificing performance. We adopt the Click term element for a node in a P2 dataflow graph, but as in database query plans, each edge in the graph carries a stream of well structured tuples, rather than annotated IP packets. Note that while all tuples flowing on a single edge share a structure (schema), tuples on one edge may have very different structure than tuples on another -this is a significant distinction with the uniform IP packets of Click.</p><p>P2 dataflows tend to mix together network packet processing elements for tasks like queuing, (de)multiplexing, and congestion control along with relational database operators like joins and aggregations. The use of joins is endemic to P2 because of our choice of OverLog: the unification (matching) of variables in the body of a rule is implemented in a dataflow by an equality-based relational join or equijoin 2 , a point we return to in Section 2.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Discussion</head><p>The combination of a declarative language and a dataflow runtime forms a powerful and surprisingly natural environment for overlay specification and runtime. The obvious alternative to our approach is the automaton approach used in 2 To avoid confusion with the notion of a node "joining" an overlay, we will use the term equijoin to refer to relational joins in the remainder of the paper. traditional protocol specifications and implementations, and in the MACEDON overlay toolkit. Relative to automata, logical specifications and dataflow graphs have a number of software engineering advantages:</p><p>• Scoping: In principle, automata must handle any possible event (message) in each state. While automata can in principle be nested or encapsulated as a matter of design discipline, the potentially arbitrary interplay between states and events leads to relatively few design constraints, making automata difficult both to specify correctly, and to understand once specified. By contrast, in a dataflow diagram compiled from an OverLog program, the inputs to an element are by definition coming from other specific elements whose behavior is well specified. This constrains what needs to be handled in each element implementation, aiding in both specification and comprehension.</p><p>• Typing: Similarly, the events or messages handled in automata are of any type possible in the system. In dataflow diagrams, all tuples that pass along an edge share the same schema, hence a dataflow element implementation need only worry about a stream of similar, well-formed tuples.</p><p>• Encapsulation and Reuse: Because automata interrelate possible events and states, they are difficult to reuse in other contexts that may involve different sets of events, or additional states with different interactions. By contrast, subsets of rules in OverLog programs can be easily extracted and reused in other programs. Moreover, even the compiled dataflow diagrams often have discrete subgraphs that are clearly reusable: a dataflow subgraph typically has a few wellspecified inputs (incoming edges) and outputs (outgoing edges), and in many cases has easily interpretable behavior. This admits the possibility of allowing incoming programs to opportunistically "jump on" to existing dataflows, in the spirit of adaptive stream query engines like TelegraphCQ <ref type="bibr" target="#b7">[7]</ref>.</p><p>The modularity provided by a declarative language is also useful for bootstrapping the system. We can compare P2 to another distributed query processor built over a dataflow framework: PIER <ref type="bibr" target="#b16">[16]</ref>. PIER uses a distributed hash table (Bamboo <ref type="bibr" target="#b29">[29]</ref>) as a basic common substrate, which is then employed to instantiate query-specific overlay networks such as aggregation trees. In contrast, P2 simply uses whatever underlying network is present, and each node can be configured with a relatively small set of "base facts" (such as addresses of a few nearby neighbors). Knowledge of the rest of the network is then built up in the declarative domain. It is possible to construct a DHT over P2 -indeed, our main example in this paper is a version of Chord -but P2 in no way requires a DHT to be present, nor relies on the assumptions a DHT typically exploits (such as full-mesh connectivity between nodes, and lack of explicit control over node and data placement).</p><p>We close with a discussion on the (perhaps surprising) centrality of the database equijoin operator in our system for implementing overlay networks. First, we observe that overlay network maintenance traffic is fundamentally a matter of asynchronous data structure manipulation: matching a stream of incoming structural change messages (node arrivals and departures, neighbor table updates, path changes, etc.) with existing state at a node to produce new state, new messages, or both. This matching of asynchronous messages is naturally representable as an equijoin of a stream and a table, whether or not it is highlighted as such in the execution model. This issue is discussed further in the context of database queries in <ref type="bibr" target="#b28">[28]</ref>.</p><p>To illustrate the utility of equijoins, we consider the example of rule R6 from Section 2.3:</p><p>R6 member@Y(Y, X, S, TimeY, true) :-refreshSeq@X(X, S), neighbor@X(X, Y), TimeY := f_now@Y().</p><p>Since neighbor has already been declared as a table, this rule specifies that the arrival of a refreshSeq event will catch any neighbor entries identified in the last 120 seconds. It translates into a simple equijoin of the refreshSeq stream and the neighbor table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">IMPLEMENTATION</head><p>Our P2 implementation runs over Linux and consists of around 20,000 lines of C++, plus 3rd-party support libraries.</p><p>The design of P2 was inspired by prior work in both databases and networking. Software dataflow architectures like P2 occupy a constrained but surprisingly rich design space that has been explored in a variety of contexts 3 . We based our design in large part on our side-by-side comparison between the PIER peer-to-peer query engine <ref type="bibr" target="#b16">[16]</ref> and the Click router <ref type="bibr" target="#b18">[18]</ref>. Like PIER, P2 can manage structured data tuples flowing through a broad range of query processing operators, which may accumulate significant state and perform substantial asynchronous processing. Like Click, P2 stresses high-performance transfers of data units, as well as dataflow elements with both "push" and "pull" modalities. P2 differs at its core from both PIER and Click, but subsumes many of the architectural features of both.</p><p>At a coarse grain, P2 consists of a Datalog parser, a planner, a set of dataflow element implementations, and a runtime plan executor (Figure <ref type="figure" target="#fig_0">1</ref>). The life of a query is simple: 3 There is also a rich hardware dataflow tradition in Computer Architecture (e.g., <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b36">36]</ref>), with its own terminology and points of reference. For brevity we will not consider those systems here, and when we refer to dataflow architectures, we limit our discussion to software dataflow. the query is parsed into an internal representation, the planner constructs a corresponding dataflow graph of elements, and the graph is executed by the runtime until it is canceled.</p><p>In this section, we describe the system bottom-up, starting with the runtime, then the dataflow framework, and finally the parser and planner that translate from OverLog to dataflow element graphs and tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Runtime</head><p>The P2 runtime consists of a library of useful classes and functions upon which the rest of the system is built. We limit our discussion here to those parts that are essential for understanding the rest of the system.</p><p>As basic data types, P2 uses Values, and Tuples. A Value is a reference-counted object used to pass around any item of information in the system; Value types include strings, integers, timestamps, and large unique identifiers. The Value class, together with the rules for converting between the various value types, constitute the concrete type system of P2.</p><p>A Tuple is a vector of Values, and is the basic unit of data transfer in P2. Dataflow elements, described below, pass tuples between them, and table rows hold tuples.</p><p>Early on in the development of P2 we implemented PEL, a small but powerful expression language for manipulating Values and Tuples. PEL is a stack-based RPN-like postfix language, and provides all the natural operations on the P2 concrete data types. PEL is not intended for human use; rather PEL programs are generated by the planner from OverLog. P2 includes a byte-code compiler for PEL and a simple but fast virtual machine that executes the resulting code.</p><p>Building PEL early in the development process dramatically simplified the construction of the rest of P2. Several dataflow elements benefit greatly from being parameterized by one or more PEL programs, as we describe below.</p><p>P2 is currently based on a single-threaded, event-driven loop using libasync from the SFS toolkit <ref type="bibr" target="#b24">[24]</ref>. Each event handler runs to completion before the next one is called. Long-running computations must therefore be handed off to a separate thread if new events are to be handled in a timely manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Tables</head><p>Our table implementation is relatively straightforward, and we only discuss it briefly here. Tables are queues of tuples that implement the expiry time and size constraints discussed in Section 2. Tables are named using unique IDs, and consequently can be shared between different queries and/or dataflow elements. Queries over tables can be specified by filters written in PEL, providing an expressivity roughly equivalent to a traditional database query over a single table. In-memory indices (implemented using standard balanced binary trees) can be attached to attributes of tables to enable quick equality lookups. Note that the table implementation -including associated indices -is a nodelocal construct. The partitioning of tuples across nodes is controlled by the @X location specifiers in the rules (Section 2.3).</p><p>The current in-memory implementation serves our requirements for implementing the overlays discussed in this paper, all of which tend to view their routing tables as "soft state." The event-driven, run-to-completion model provided by libasync obviates the need for locking or transaction support in our application, and relatively simple indices suffice to meet our performance requirements. In the future, there is clearly scope for table implementations that use stable storage for persistent data placement, or that wrap an existing relational database implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Dataflow framework</head><p>We now describe how we implement the P2 dataflow model described in Section 2. Since P2's architecture is influenced by the Click <ref type="bibr" target="#b18">[18]</ref> modular router, we first give an overview of the Click model, and then describe how and why P2 departs from the design of Click.</p><p>As in Click, nodes in a P2 dataflow graph can be chosen from a set of C++ objects called elements. In database systems these are often called operators, since they derive from logical operators in the relational algebra. Although they perform a similar function, P2 elements are typically smaller and more numerous than database operators. Unlike textbook database query plans, P2 graphs need not be trees; indeed we make heavy use of cyclic dataflow for the kind of recursive queries that occur frequently when querying graph structures.</p><p>Elements have some number of input and output ports. An arc in the dataflow graph is represented by a binding between an output port on one element and an input port on another. Tuples arrive at the element on input ports, and elements emit tuples from their output ports. An input port must be connected to an output port.</p><p>Handoff of a tuple between two elements takes one of two forms, push or pull, determined when the elements are configured into a graph. In a push handoff, the source element invokes a virtual method on the destination, passing the tuple, while in a pull handoff the destination calls the source requesting the tuple, which is returned as the result of the call. We return to the choice of connection types at the end of this section.</p><p>The implementation of dataflow elements in P2 differs from Click in significant ways, as a result of different requirements.</p><p>First, the common case in a router is that a packet traverses a single path through the dataflow graph. Consequently Click implements copy-on-write for packets that must be modified (for example, to implement multicast). This has the additional benefit of very lightweight hand-offs of packets between elements -throughput is of primary concern in Click, and inter-element handoff is simply pointer passing through a virtual function call.</p><p>In contrast, the dataflow graphs that the P2 planner generates from OverLog specifications have many more branching points and tuples traverse more than one path. For example, a tuple might be stored in a table but also forwarded to another element as an event notification. At the same time, raw forwarding performance in P2 is less of a priority. This led to two related design decisions: first, tuples in P2 are completely immutable once they are created, and second, tuples are reference-counted and passed between P2 elements by reference. C++ inlining and templates minimize this overhead at runtime.</p><p>Second, P2 passes tuples between elements rather than annotated packets, and elements in P2 are frequently emulating database operators rather than packet routing functions, which means flows frequently block and unblock. In Click, a flow event is typically initiated by a packet arriving over the network, queues rarely block when full (instead, they implement an explicit drop policy as in most other routers), and consequently Click's design can process packets efficiently using only event-driven scheduling of dataflow, together with "active elements," invoked periodically by the Click scheduler.</p><p>In contrast, not only do P2 dataflow graphs tend to branch more, but tuples are frequently generated inside the dataflow graph in response to the arrival of other tuples -most commonly during equijoin operations, which are fundamental to OverLog's rule constructs.</p><p>Furthermore, the consequences of dropping tuples due to queue overflow in P2 are much more undesirable than the dropping of a packet in a router under high load. Many queue elements in P2 dataflow graphs therefore "block" when full or empty, and a low-latency mechanism is required for restarting a particular dataflow when new tuples arrive or space becomes available.</p><p>P2 therefore implements a simple signaling facility to allow elements to restart flows they have previously blocked. An extra argument to each "push" or "pull" invocation between elements specifies a callback (in effect, a continuation) to be invoked at some later stage if and only if the dataflow has been stalled as a result of the call.</p><p>For a "pull" transition, if the pull call returns no tuple then there is no data available. When a tuple does become available, the callback previously passed with the pull is invoked. This call will typically happen as part of a push transition into the source element (e.g., in the case of equijoins) or the passage of time (e.g., in a rate limiter), and the recipient of the callback will generally schedule a deferred procedure call to retry the pull as soon as possible.</p><p>"Push" transitions operate slightly differently, since the coupling of control flow and dataflow means that the destination of a push has to accept the tuple -if it did not, any state operations that occurred previously in the dataflow chain would have to be undone. As a result, push calls are always assumed to succeed, and return a boolean indicating whether it is acceptable to call push again. If not, the callback will be invoked at some later stage as with pull.</p><p>The use of callbacks in this way removes from the element implementation itself any scheduling decisions, while imposing a minimum of policy. P2's transitions are not as efficient as Click's but are still very fast -most take about 50 machine instructions on an ia32 processor, or 75 if the callback is invoked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Dataflow elements</head><p>This section gives a brief overview of the suite of dataflow elements implemented in P2.</p><p>To start with, P2 provides the relational operators found in most database systems, as well as query processors like PIER <ref type="bibr" target="#b16">[16]</ref>: selection, projection, streaming relational join operations, "group-by," and various aggregation functions. Many of these elements are greatly simplified by parameterizing them with PEL programs; for example, a "project" element implements a superset of a purely logical database projection operator by running a PEL program on each incoming tuple to generate an outgoing tuple.</p><p>Since one of our motivations in designing P2 was to investigate the applicability of the dataflow element model for distributed computing, we have tried to push as much functionality of the system as possible into dataflow elements.</p><p>One example of this is in P2's networking stack. Systems like PIER <ref type="bibr" target="#b16">[16]</ref> abstract details of transport protocols, message formats, marshaling, etc., away from the dataflow framework, and operators only deal with fully unmarshaled tuples. In contrast, P2 explicitly uses the dataflow model to chain together separate elements responsible for socket handling, packet scheduling, congestion control, reliable transmission, data serialization, and dispatch. While P2's networking subsystem exists entirely as a set of dataflow elements, at the OverLog level it is abstracted behind the @ syntax for location specifiers. A fuller exploration of P2's networking subsystem and its high-level specification is ongoing and is beyond the scope of this paper.</p><p>A variety of elements form a bridge between the dataflow graph and persistent state in the form of stored tables. P2 has elements that store incoming tuples in tables, lookup elements that can iteratively emit all tuples in a table matching a search filter expressed in PEL, and aggregation elements that maintain an up-to-date aggregate (such as max, min, count, etc.) on a table and emit it whenever it changes. Tables are frequently shared between elements, though some elements hold private tables. For example, the element responsible for eliminating duplicate results in a dataflow uses a table to keep track of what it has seen so far.</p><p>Finally, like Click, P2 includes a collection of generalpurpose "glue" elements, such as a queue, a multiplexer, a round-robin scheduler (which, when pulled, pulls tuples from its inputs in order), etc.</p><p>It is quite simple to add new elements to the collection provided by P2, but at present the planner is not yet designed to be easily extensible. To use a new element class, one must either "hand-wire" dataflow diagrams as in Click <ref type="bibr" target="#b18">[18]</ref> and PIER <ref type="bibr" target="#b16">[16]</ref>, or modify the planner to translate OverLog into dataflows that use the new element.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">OverLog Translation</head><p>The OverLog parser in our implementation is fairly conventional, and implemented using flex and bison. It converts OverLog files into a canonical form and produces lists of events, rules and table definitions. The heavy lifting of generating the dataflow graphs is performed by the planner, which generates a directed graph of dataflow elements from the query parse tree in a variety of phases. We describe the general process of translating an OverLog description here, and later in Section 4 we explore a concrete example, that of Chord.</p><p>First, all the required tables and indices are created. We create an index for every table's primary key, and secondary indices for table keys participating in equijoins. Each rule head is associated with either a table or a data stream consisting of tuples that pass through the dataflow engine without being stored.</p><p>Next, for each rule the planner identifies matching variables across rule terms and creates a sequence of elements implementing relational equijoins. As noted in Section 2, our current version of OverLog only supports equijoins of a stream and a table. Since tables are implemented as mainmemory data structures with local indices over them, tuples from the stream are pushed into an equijoin element, and all matches in the table are found via an index lookup.</p><p>After the translation of the equijoins in a rule, the planner creates elements for any selection filters. Each filter is compiled into a PEL expression, and a selection element evaluates the expression over each tuple, dropping those for which the result is false. In some cases, we can optimize the dataflow to push a selection upstream of an equijoin, to limit the state and work in the equijoin.</p><p>Aggregate operations like min or count are translated after equijoins and selections, since they usually operate on one of the fields in the rule head. Aggregate elements generally hold internal state, and when a new tuple arrives either compute the aggregate incrementally or run a PEL program to recalculate the new aggregate from scratch.</p><p>The final part of translating each rule is the addition of a "projection" element that constructs a tuple matching the head of the rule, by using a PEL program to select and reorder fields in the incoming tuple.</p><p>In addition to creating the relational operations described above, the planner also constructs the other areas of the dataflow graph: the networking stack, including multiplexing and demultiplexing tuples, marshaling, congestion control, etc. As with Click, it also inserts explicit queue elements where there is a push/pull mismatch between two elements that need to be connected.</p><p>Certain rule terms in OverLog, such as periodic and f now introduced in Section 2.3, refer to "built in" element classes, which the planner also knows about and directly maps to dataflow elements.</p><p>As an aside, we have found it useful to implement a logging facility using the same dataflow framework. The planner can be configured (through additional OverLog directives) to connect a "logging" port on particular elements to a dataflow chain that sends such tuples over the network, providing a flexible way to obtain logging and debugging data at runtime.</p><p>The planner has the potential to implement a number of query optimizations in the database literature such as join reordering <ref type="bibr" target="#b31">[31]</ref>, Magic Sets <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b21">21]</ref>, and multi-query optimization <ref type="bibr" target="#b32">[32]</ref>; however currently these optimizations are achieved by rewriting queries at the input by hand.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A BIGGER EXAMPLE: CHORD</head><p>We now present a more involved P2 example: a full implementation of the Chord distributed lookup service <ref type="bibr" target="#b34">[34]</ref>. We show that the OverLog specification of a complex overlay such as Chord can be intuitive, concise, and reusable for other overlays.</p><p>Chord is essentially a mechanism for maintaining a ring. Nodes join by contacting a landmark node within the ring that they already know. In OverLog, newcomer ni has a "materialized" fact in a table database pointing to its landmark node li (or to the null node otherwise):</p><formula xml:id="formula_0">landmark@ni(ni,li).</formula><p>as well as a fact about its own address ni and identifier n:</p><formula xml:id="formula_1">node@ni(ni,n).</formula><p>To enter the ring, ni generates a join tuple at node ni, whose arrival triggers the following rules:  Figure <ref type="figure">2</ref>: Part of the dataflow that P2 generates from the Chord OverLog specification. Not shown are the elements responsible for stabilization and maintenance of fingers. Following Click conventions, ports are either triangular (for input) or rectangular (for output), black (for push) or white (for pull), and doubly lined for agnostic. The "Network In" and "Network Out" elements represent a longer sequence of network-related elements that we elide here for simplicity.</p><p>Rule C1 starts a join event upon arrival of the join tuple. In rule C2, if the landmark node is known (i.e., non-null), then a joinReq (join request) tuple is sent to that landmark node; otherwise C3 sets the node to point to itself as a successor, forming an overlay by itself and awaiting others to join in. When the landmark receives a joinReq, rule C4 initiates a lookup for the successor of the joining node's identifier N. C5 defines the joining node's successor to be the result of the lookup. Successors and predecessors are materialized in tables, and pending join events are also stored ephemerally.</p><p>A Chord node also holds a finger table, pointing at peers whose ID distances exponentially increase from itself: At time intervals of tFix seconds, a "fix-finger" event is triggered for the I-th finger, in rule F1, where I is in the range of valid finger entry indices. F1 chooses whether to fix each finger entry according to a probability distribution; it could, instead, be made to pick indices in order (by replacing f coinFlip with a counter equated to I) or can be made to pick all indices, by removing f coinFlip altogether. F2 issues a Chord lookup for the identifier that is 2 I away from the local node's identifier. If a successor of that iden-tifier is found, F3 places that successor into all appropriate finger entries: those whose target identifier n + 2 I also lie between the local node's identifier n and that successor on the identifier ring.</p><p>For clarity of exposition, we have kept these finger-fixing rules rather naïve and ignore possible optimizations that speed up the process. In Appendix B we present the actual optimized finger-fixing rules F1-9 that we use for our implementation of Chord.</p><p>Lookups for key K seek the node whose identifier is the immediate successor on the ring of K: Rule L1 returns a successful lookup result if the received lookup seeks a key K found between the receiving node's identifier and that of its best successor (we come back to the best successor below). In parallel, rule L2 finds the minimum distance from the local node's fingers to K, for every finger node BI whose identifier B lies between the local node's identifier N and K. The first address of a finger with that minimum distance to the key K is chosen in L3 to receive the forwarded lookup. The condition B in (N,K) ensures that either L1 or L3 produces a result, not both. In a Chord configuration such as MACEDON's where only a single successor is maintained, a "best successor" can be defined simply as:</p><p>N1 bestSucc@NI(NI,S,SI) :-succ@NI(NI,S,SI).</p><p>However, replacing this rule with the following two allows our Chord specification the maintenance of more successors for resilience of the overlay (a typical value is log n, where n is the estimated size of the network): N1 and N2 define as "best" the successor among those stored in the succ stored table whose identifier distance from the current node's identifier is the lowest. Candidate successors (and predecessor) are supplied during the stabilization phase of the Chord overlay maintenance. In OverLog, one of the several Chord stabilization activities looks as follows:</p><p>SB5 sendSuccessors@SI(SI,NI) :-stabilize@NI(NI,_), succ@NI(NI,_,SI). SB6 succ@PI(PI,S,SI) :-sendSuccessors@NI(NI,PI), succ@NI(NI,S,SI).</p><p>In SB5, a node asks all of its successors to send it their own successors, whenever the stabilize event is issued. SB6 installs at the original node the returned successor. Successor selection, not shown here, only keeps those successors closest to a node in the table, evicting the remaining nodes. Due to space constraints, we limit ourselves here to this 15-rule OverLog specification of a simplistic but functional version of the Chord overlay. However, a fuller specification including all Chord stabilization activities, explicit successor evictions, and connectivity monitoring for fault tolerance requires no more than 47 OverLog rules, which can be input to the P2 parser directly, producing an automatically generated running Chord implementation. This version is available in Appendix B. Figure <ref type="figure">2</ref> illustrates the generated dataflow that captures the lookup rules L1, L2, and L3, following the notational conventions of Click. The dataflow is made up of three parts. First, the three rules are translated into the shaded dataflows in the middle of the diagram. Below them lie the simple dataflows that store into tables any received storeable tuples node, bestSucc and finger.</p><p>Input to these flows comes from a large demultiplexer on the bottom left of the figure, which classifies its push input according to its tuple name, and forwards it to the appropriate rule. Note that lookup tuples are duplicated by the "Dup" element, since they appear on the right hand sides of both L1 and L2. On the other side of the graph, output tuples are merged by the round-robin pull scheduler into a single stream, which is then demultiplexed according to tuples' network destination (the "@" notation of OverLog). Remote tuples are sent via an output queue to the network stack to be packetized, marshaled, and buffered by our UDP transport, while tuples destined for local consumption are wrapped around to the left of the figure and queued along with other input tuples arriving over the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Discussion: OverLog</head><p>The above 15 rules are sufficient to specify a Chord overlay that is reasonably faithful to the original Chord proposal. Having now presented versions of both Narada meshes and Chord, it is reasonable to ask how good a fit the OverLog language is for overlay specification.</p><p>OverLog succeeds in its goal of conciseness. It can capture a complex overlay like Chord remarkably succinctly, in a form that can be automatically translated to a dataflow framework. Moreover, this process is amenable to a number of optimization techniques and presents several opportunities for sharing state, communication, and computation across multiple overlay specifications.</p><p>On the other hand, while succinct, OverLog has a nontrivial learning curve for programmers used to imperative languages like Java and C. One example issue is the trickiness of coding up the equivalent of if-then-else logic. For example, consider the lookup rules above that treat either a locally-satisfied lookup (L1) or forwarding (L2 and L3). The order of evaluating the three rules is unspecified; the two cases are essentially tested "in parallel." Hence it is important in specifying the bodies of these rules that only one or the other case of lookup logic can be satisfied under any circumstances. This has minimal performance impact since the common rule components can easily be compiled to share a dataflow subgraph -indeed, it may have significant performance benefits in a multiprocessor environment, an issue we plan to investigate in the future. That said, the programming style is unusual. Some syntactic sugar would help with this issue, but it highlights the kinds of unconventional thinking that arise for the declarative programmer.</p><p>Similarly, we are sensitive to the fact that the syntax of Datalog -and hence OverLog -is an acquired taste. Our Chord specification is about as long as the pseudocode in the original paper, but harder for most humans to read. Obviously the ability of P2 to execute our specification gives it a qualitative advantage over the Chord pseudocode, but a different syntax might make it more readable to systems programmers. The success of SQL is suggestive here -it is easier for most people to read simple SQL queries than their Datalog equivalents. However, SQL's support for recursive rules is awkward, and recursion is key to networking protocols because of their reliance on graph transitivitye.g., constructing multi-hop paths as with Chord lookups out of single-hop links. Some middle-ground syntax may be appropriate for our purposes.</p><p>More fundamentally, it is less clear that OverLog achieves the goals set out in Section 2 for logical structure of the specification. Our Chord rules have a somewhat operational flavor: rather than declaratively stating the invariants of the Chord data structure -a ring with fingers at increasing powers of two -our specification has rules for the activities of "joining" the overlay and "fixing fingers." In this respect, of course, it closely follows the Chord pseudocode, and the pseudocode itself is operational. It could be argued that our Chord description is still reasonably declarative in nature, but the key observation is that OverLog neither encourages nor requires structural specification of the overlay, and this is a consequence of the language's generality.</p><p>Based on our experience so far, we are designing a replacement for OverLog that has a more readable syntax, and frames the overlay design process more concretely as two separate specifications: structural invariants, and the dynamics of maintenance rules. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>In this section we present performance results from P2. We have two goals in this evaluation. First, we wish to validate that our simple declarative specifications of complex overlays result in the expected network properties, including topological properties and messaging overheads. Second, we examine our raw performance with an eye toward feasibility: we do not expect our per-node performance to be as good as a highly-tuned hand-coded implementation, but we would like it to be acceptable.</p><p>In our experiments, we focus on the full Chord DHT specification in Appendix B. We chose to present Chord results largely because it is a good stress test of our architecture, being relatively complex compared to other examples like gossip and end-system multicast. Chord also has the advantage of being well-studied.</p><p>We deployed P2 on the Emulab testbed <ref type="bibr" target="#b38">[38]</ref>, with instances of P2 spread over a network of 100 machines. Except where noted, the network is a GT-ITM transit-stub topology with 10 transit domains and 100 stubs (one per physical node) emulated using DummyNet on 10 additional machines. The RTT between two transit nodes is 50ms, while the RTT between two nodes in the same domain is 2ms. The link capacity is set to 100Mbps and 10Mbps for domain and stub nodes respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Feasibility Experiments</head><p>We begin with the high-level characteristics of the Chord overlay, to validate that the P2 implementation exhibits the expected properties. We generate a uniform workload of DHT "lookup" requests to a static membership of nodes in the overlay, with no nodes joining or leaving. This is somewhat unrealistic but it allows us to observe the static properties of Chord.</p><p>Figure <ref type="figure" target="#fig_6">3</ref>(i) shows the hop-count distribution for our workload. As expected, the hop-count averages log N/2, where N is the size of the network. Figure <ref type="figure" target="#fig_6">3</ref>(ii) shows the maintenance traffic for the network; this is the bandwidth used by the nodes while idling. As can be seen, our overlay is configured to use relatively low bandwidth -networks aiming at high consistency and low latency typically use about 1 KByte/s per node <ref type="bibr" target="#b29">[29]</ref>.</p><p>Figure <ref type="figure" target="#fig_6">3</ref>(iii) shows the raw latency performance of our implementation. While the latency increases with network size (as might be expected), on a 500-node static network 96% of all lookups complete in 6 seconds or less. Our latency numbers are within the same order of magnitude as the published numbers <ref type="bibr" target="#b34">[34]</ref> of the MIT Chord deployment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Handling Churn</head><p>In our second round of experiments, we focus on the performance of our Chord implementation under varying degrees of membership churn. Again, our goal is to validate that our compact specification of Chord faithfully captures its salient properties. We bring up a 400 node Chord network, and then churn the network for 20 minutes, following the methodology in <ref type="bibr" target="#b29">[29]</ref>.</p><p>Figure <ref type="figure">4</ref> shows our results. The first graph (i) measures the "maintenance traffic" for the network, that is, all traffic not associated with lookups and responses. This includes traffic for checking the status of nodes in the network, and recovery traffic as the nodes come and go. As in the static case, our maintenance traffic is fairly respectable.</p><p>Figure <ref type="figure">4</ref>(ii) examines consistency of lookups (following the experimental setup of Bamboo <ref type="bibr" target="#b29">[29]</ref>), and Figure <ref type="figure">4</ref>(iii) considers raw latency of external (i.e., non-maintenancerelated) lookups under churn. P2 Chord does respectably under low churn (session times of 64 minutes and above), generating at least 97% consistent lookups, most of which complete within 4 seconds. On the other hand, under high churn (session times of 16 minutes and less), P2 Chord does not perform well, producing only 42% and 84% consistent lookups with high latencies.</p><p>Ultimately, an evaluation of a system like P2 rests on an assessment of the ideal tradeoff between code size and performance. Our current Chord overlay written in OverLog performs acceptably, but clearly does not attain the published figures for the MIT implementation (at least 99.9% consistency for a session time of 47 minutes, and mean lookup latency of less than 5 seconds under high churn).</p><p>We conjecture that a carefully crafted and complete MACE-DON implementation of Chord might outperform our 47 OverLog rules, but it would be more than an order of magnitude more complex. We note that the 320-line version supplied with the distribution<ref type="foot" target="#foot_2">4</ref> is not sufficiently complete to evaluate under churn or compare meaningfully to MIT Chord or our implementation over P2; for example, MACE-DON's Chord implements 32-bit node identifiers instead of the traditional 160 bits, and provides only a single successor for each node, making it highly likely that the ring becomes partitioned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>The design of P2 can be viewed as a synthesis of ideas from database systems, particularly recent work in distributed and continuous query processing, with logic languages, and the result applied to overlay networks. Throughout this paper we have highlighted the database systems techniques we have employed in P2; in this section we situate OverLog and P2's approach in the context of existing work on generating overlays from protocol descriptions.</p><p>There is a long tradition of automating the generation of protocol implementations from specifications. Much of the early work focuses on expressing OSI protocols in a finite state machine language (Esterel, Estelle, LOTOS, SDL <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b35">35]</ref>, etc.), and compiling them into CPU-efficient implementations (e.g., <ref type="bibr">[9,</ref><ref type="bibr" target="#b37">37]</ref>). The focus of this body of work is on supporting formal protocol specification (e.g., for verification), ideally without sacrificing CPU performance.</p><p>More recently, there has been increased emphasis on readability and code reuse for network protocol specification languages. This includes domain-specific object-oriented languages like Morpheus <ref type="bibr" target="#b1">[1]</ref> and Prolac <ref type="bibr" target="#b17">[17]</ref>, and functional approaches like the Fox project's TCP implementation <ref type="bibr" target="#b6">[6]</ref>.</p><p>It is typical to think of implementing network protocols in terms of state machines, whose transitions are triggered by timer events or the arrival of messages (either over the network or from a local client application). This is the approach taken in essentially all of the work cited above. Network protocol stacks are typically implemented in such a manner even when hand-coded, and this approach lends itself to object-oriented programming languages, where finite state machines (FSMs) are encapsulated in software objects.</p><p>Overlays built using an FSM approach are generally eventdriven from a Unix "select" loop or equivalent OS functionality, and can be highly efficient in terms of resource usage (CPU, etc.) on a node. A recent example of this approach is MACEDON <ref type="bibr" target="#b30">[30]</ref>, which adopts the FSM approach by encapsulating the event loop, timers, finite state machines, and message formats, and compiling the resulting syntactic elements to C++. Because the output of the MACEDON compiler closely mirrors the structure of the code that a skilled programmer would produce for an overlay, we believe that the performance of a well-tuned MACEDON network could approach a custom implementation with less code than C++ would require, though the current MACEDON overlay suite does not approach this.</p><p>An interesting alternative to state machines is RTAG <ref type="bibr" target="#b3">[3]</ref>, where the protocol is expressed as a grammar. Incoming messages and events are modeled as tokens causing reductions in grammar rules, and the state of a connection is held on the parser stack rather than encapsulated in an FSM.</p><p>The i3 <ref type="bibr" target="#b33">[33]</ref> infrastructure offers a rendezvous-based abstraction that provides significant flexibility in specifying communication structures and patterns. i3 is similar in fundamental ways to the relational abstraction used in P2-the decoupling of senders and receivers via keys in i3 is similar to the keys and foreign keys of relational models, and the same flexible indirections are possible in both. However, i3 is targeted as a fundamental communication abstraction, whereas P2 is a more functional but arguably more special-purpose system.</p><p>Although Click's configuration language unambiguously specifies the dataflow elements and graph to be generated, the idea of using a high-level logic language for describing network protocols seems relatively new. Loo et al. <ref type="bibr" target="#b21">[21]</ref> recently proposed performing IP routing using declarative queries, also written in a variant of Datalog. Our implementation of P2 is focused on overlay construction rather than IP routing, but as we discussed in Section 3.5, some of the optimization techniques suggested in <ref type="bibr" target="#b21">[21]</ref> from the deductive database literature are applicable in P2.</p><p>As in <ref type="bibr" target="#b21">[21]</ref>, by representing the desired network properties in OverLog at a higher level of abstraction than a dataflow graph, protocol grammar, or FSM description, P2 achieves very concise descriptions that can nevertheless generate executable dataflow graphs to maintain the overlay.</p><p>In addition to conciseness, as section 2.2 discusses, a topdown approach like OverLog offers more opportunities for compile-and run-time optimization of overlay descriptions, and OverLog's decomposition of state into tables and flows provides more natural opportunities for code reuse and runtime sharing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION AND FUTURE WORK</head><p>In this paper, we have investigated the feasibility of ex-pressing overlay networks in a declarative language, and then directly executing the resulting specification to construct and maintain the overlay network.</p><p>The approach looks promising: overlays can be specified extremely concisely, yet with enough detail to be executed with performance and robustness acceptable for many applications. Furthermore, OverLog makes it easy to alter overlay routing algorithms without reimplementing complex state machines.</p><p>Our current system successfully compiles and runs specifications for all overlays discussed in this paper. Our planner does not currently handle directly some of the more involved constructs of the OverLog language, such as multinode rule bodies and the logic of negation; slightly wordier rule rewrites allow us to circumvent these limitations, as the next design iteration of the planner takes shape. The appendices contain overlay specifications that are executable by our system as of July 2005.</p><p>We continue our efforts in several directions. Breadth: In the short term, we are working on coding a variety of other overlay networks in OverLog: epidemicbased networks, link-state-and path-vector-based overlays, and further DHT schemes. This has the benefit of exercising the P2 planner and ensuring that OverLog is sufficiently expressive to cover the design space, but will also enable us to start to identify common constructs that can be factored out of particular overlay specifications and shared.</p><p>Sharing: Sharing is intriguing not only in terms of code reuse, but also for the possibility that multiple overlays can execute simultaneously, sharing state, communication, and computation by sharing dataflow subgraphs. Sharing between multiple overlays can allow a single application to achieve different performance goals for different tasks, by efficiently deploying multiple overlay variants simultaneously. For example, a peer-to-peer content distribution network that combines search with parallel download might choose to construct two different overlays for these very different tasks. These overlays might fruitfully share rules for liveness checking, latency and bandwidth estimation, etc. Runtime sharing across overlays can also allow separately deployed systems to co-exist efficiently within a shared network infrastructure; this might become important if overlays emerge as a prevalent usage model for the Internet.</p><p>The naïve approach for sharing is to do so explicitly at the OverLog level, by sharing rule specifications. However, we hope to apply multiquery optimization techniques from the database literature to identify further sharing opportunities automatically, within the P2 planner. This enhancement to the planner is tandem with applying some of the single query optimization techniques we mentioned in section 3.5.</p><p>Transport Protocols: While bringing different overlays to P2, we have rediscovered the multifaceted nature of overlay requirements on network and transport facilities. Different applications require different combinations of reliable, in-order, congestion-, and flow-controlled transports, and different levels of control and inspection for each. For example, going from applying TCP-friendly congestion control on a per-peer basis (as in Bamboo <ref type="bibr" target="#b29">[29]</ref>) to having a single congestion window for the whole node (as in MIT Chord <ref type="bibr" target="#b20">[20]</ref>) is a matter of design requirements that may not be sufficiently addressed by a monolithic transport solution. P2's dataflow architecture makes such choices as simple as rearranging the bindings between a few common elements.</p><p>Similarly, making the transport "layer" a graph of dataflow elements means that different bits of functionality can be broken up and spread out throughout the application logic. For instance, one can push transmission retries to happen upstream of route selection, to allow nodes route flexibility when the next hop is not the ultimate destination for a transmission. Or, an application can push a transmit buffer upstream, near where tuples are first produced, reducing the amount of queuing that tuples encounter outside of P2, which minimizes the time during which they are unavailable for computation. Instead, tuples are available for computation as soon as possible after they arrive on a node, getting pulled out of a table, routed, marshaled, and sent only when the corresponding socket can send data, the congestion window has room, and the outgoing packet scheduler has selected the tuple's dataflow.</p><p>On-line distributed debugging: A unique opportunity offered by our system is its multi-resolution programming paradigm, allowing the programmer to specify a system as a set of logical rules, which are translated to a dataflow graph and then executed at runtime. By exposing the execution history of the system -in terms of rules that fired at a first level, or in terms of actions taken by each dataflow element at a second level -P2 is astonishingly capable to provide introspection support for on-line overlay debugging. In fact, since execution history at any resolution can be exported as a set of relational tables, much as everything else with P2, debugging itself becomes an exercise in writing OverLog rules for high-level invariants or for execution history mining. We are actively building up the infrastructure within P2 to evaluate the exciting debugging possibilities that such support would enable.</p><p>Security: It is a natural, short step (though perhaps a precarious one) to move from system introspection to security assessment. P2's runtime composition of small, simple dataflow elements along with flat state tables implies that we might be able to express security invariants for each element in isolation, which would ideally compose into global security properties for the whole system. We are exploring the application of our earlier work on preserving the historic integrity of a distributed system <ref type="bibr" target="#b22">[22]</ref> to the problem of making the execution of a complex overlay tamper-evident.</p><p>Language: The version of OverLog that we describe in this work is a strawman vehicle, expressive enough to aid us in our initial exploration of the design space. We have produced a preliminary formal semantics for OverLog, to enable reasoning about program properties (safety, termination, etc.). We are also exploring the extensions in the language that would permit a high-level specification of sharing, transport, debugging, and security logic, as described above.</p><p>We expect to revisit the choice of Datalog as a basis for OverLog. As we have discussed, Datalog's generality makes it an ideal choice as a "first cut" declarative language for overlays. How OverLog can be improved by tailoring its syntax and semantics more specifically towards overlay description is an interesting research direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We would like to thank our shepherd Dahlia Malkhi, Brent Chun for initial encouragement and help using his distributed automated testing tool for our evaluation, David Gay for his significant contributions to OverLog's operational semantics, and Tristan Koo for testing code and performance</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Block diagram of a P2 node</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>C1 joinEvent@NI(NI,E) :-join@NI(NI,E). C2 joinReq@LI(LI,N,NI,E) :-joinEvent@NI(NI,E), node@NI(NI,N), landmark@NI(NI,LI), LI != "-". C3 succ@NI(NI,N,NI) :-landmark@NI(NI,LI), joinEvent@NI(NI,_), node@NI(NI,N), LI == "-". C4 lookup@LI(LI,N,NI,E) :-joinReq@LI(LI,N,NI,E). C5 succ@NI(NI,S,SI) :-join@NI(NI,E), lookupResults@NI(NI,_,S,SI,E).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>F1</head><label></label><figDesc>fFix@NI(NI,E,I) :-periodic@NI(NI,E,tFix), range(I,0,fNum-1), f_coinFlip(fFixProb). F2 lookup@NI(NI,K,NI,E) :-fFix@NI(NI,E,I), node(NI,N), K:=N+1&lt;&lt;I. F3 finger@NI(NI,I,B,BI) :-fFix@NI(NI,E,I), lookupResults@NI(NI,K,B,BI,E), K in (N+1&lt;&lt;I,N), node@NI(NI,N).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>L1 lookupResults@R(R,K,S,SI,E) :-node@NI(NI,N), lookup@NI(NI,K,R,E), bestSucc@NI(NI,S,SI), K in (N,S]. L2 bestLookupDist@NI(NI,K,R,E,min&lt;D&gt;) :node@NI(NI,N), lookup@NI(NI,K,R,E), finger@NI(NI,_,B,_), D:=K -B -1, B in (N,K). L3 lookup@BI(min&lt;BI&gt;,K,R,E) :-node@NI(NI,N), bestLookupDist@NI(NI,K,R,E,D), finger@NI(NI,_,B,BI), D == K -B -1, B in (N,K).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>N1 bestSuccDist@NI(NI,min&lt;D&gt;) :-node@NI(NI,N), succ@NI(NI,S,_), D := S -N -1. N2 bestSucc@NI(NI,S,SI) :-succ@NI(NI,S,SI), bestSuccDist@NI(NI,D), node@NI(NI,N), D == S -N -1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Performance of static Chord networks of different sizes. (i) shows hop-count distribution for lookups, (ii) shows maintenance traffic in the absence of churn for different population sizes; and (iii) shows measured cumulative distribution of the latency over all lookups.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>refreshEvent is issued for a node X, rule R2 creates a new refresh sequence number NewSeq for X by incrementing the currently stored sequence number Seq in the sequence table. Rule R3 updates the stored sequence number. Because sequence is a materialized table instead of a data stream, whenever a new sequence tuple is produced, as is done with rule R3, it is implicitly inserted into the associated table.Though not explicitly specified in the materialize directives above, the neighbor table contains tuples of the form</figDesc><table><row><cell>neighbor(MyAddress, NeighborAddress)</cell></row><row><cell>while the member table contains tuples of the form</cell></row><row><cell>member(MyAddress, MemberAddress, MemberSequence,</cell></row><row><cell>MemberInsertionTime, MemberLive)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>table ,</head><label>,</label><figDesc></figDesc><table><row><cell>and a (X, Y) tuple in X's neighbor</cell></row><row><cell>table, and there is no member tuple in Y's table for address A,</cell></row><row><cell>then a member tuple (Y, A, ASeqX, TimeY, ALiveX) should</cell></row><row><cell>appear at node Y, where TimeY is the value of the built-in</cell></row><row><cell>function f now() at Y 1 ." f now returns a node's wall-clock</cell></row><row><cell>time, and as in other languages an underscore denotes a</cell></row><row><cell>"don't care" variable. Because the location specifiers in this</cell></row><row><cell>rule belong to two different nodes, when this rule is executed</cell></row><row><cell>some data are shipped across the network.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We are purposely vague about the type of location specifiers. For simplicity, one can simply think of them as IP addresses. However, we make no assumption about the underlying addressing scheme in the network, and there may be a case for using P2 in contexts where addressing is different.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>U1 ugain@X(X, Z, sum&lt;UGain&gt;) :-latency@X(X, Z, T), not neighbor@X(X, Z), route@Z(Z, Y, _, C), UNew := T + C, route@X(X, Y, _, UCurr), UNew &lt; UCurr, UGain := (UCurr -UNew) / UCurr.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>See chord.mac in MACEDON release 1.2.1-20050531, from http://macedon.ucsd.edu/release/.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>microbenchmarks. We are also indebted to Brent, David, Ryan Huebsch, Kevin Lai, Raghu Ramakrishnan, Sylvia Ratnasamy, and Sean Rhea, for their thoughtful comments on drafts of this paper. Finally, our paper has benefitted significantly from the detailed feedback offered by the anonymous reviewers.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Condie are supported in part by the National Science Foundation under Grants No. 0205647, 0209108, and 0225660, and by a gift from Microsoft Corporation.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. NARADA IN OverLog</head><p>Here we provide an executable OverLog implementation of Narada's mesh maintenance algorithms. Current limitations of the P2 parser and planner require slightly wordier syntax for some of our constructs. Specifically, handling of negation is still incomplete, requiring that we rewrite some rules to eliminate negation. Furthermore, our planner currently handles rules with collocated terms only. The Over-Log specification below is directly parsed and executed by our current codebase.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A language-based approach to protocol implementation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Abbott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1993-02">Feb. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automated protocol implementation with RTAG</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="291" to="300" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Balazinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Cetintemel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cherniack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Convey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Galvez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Salz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tatbul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tibbetts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2004-12">Dec. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<title level="m">The Foundations of Esterel</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="425" to="454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A structured TCP in Standard ML</title>
		<author>
			<persName><forename type="first">E</forename><surname>Biagioni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">TelegraphCQ: Continuous dataflow processing for an uncertain world</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chandrasekaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A case for end system multicast</title>
		<author>
			<persName><forename type="first">Y.-H</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMETRICS</title>
		<meeting>of ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Generating efficient protocol code from an abstract specification</title>
		<author>
			<persName><forename type="first">W</forename><surname>Dabbous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>O'malley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castelluccia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="60" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Designing a DHT for low latency and high throughput</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Blake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multicast routing in datagram internetworks and extended LANs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Deering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="85" to="111" />
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Gamma -a high performance dataflow database machine</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Gerber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Heytens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Muralikrishna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="228" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A success story of formal description techniques: Estelle specification and test generation for MIL-STD 188-220</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fecko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Uyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Amer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Menell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mcmahon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Communications (Special Edition on FDTs in Practice)</title>
		<imprint>
			<biblScope unit="page">23</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Encapsulation of parallelism in the Volcano query processing system</title>
		<author>
			<persName><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1990 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>of the 1990 ACM SIGMOD International Conference on Management of Data<address><addrLine>Atlantic City, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">May 23-25, 1990. 1990</date>
			<biblScope unit="page" from="102" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Designing extensible IP router software</title>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Radoslavov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The architecture of PIER: an Internet-scale query processor</title>
		<author>
			<persName><forename type="first">R</forename><surname>Huebsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">N</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Yumerefendi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="28" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A readable TCP in the Prolac protocol language</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Montgomery</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Click modular router</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="263" to="297" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Introduction to Parallel Algorithms and Architectures: Arrays, Trees, Hypercubes</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">T</forename><surname>Leighton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Morgan Kaufmann</publisher>
			<pubPlace>San Mateo, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Comparing the performance of distributed hash tables under churn</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stribling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IPTPS</title>
		<meeting>IPTPS</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Customizable routing with declarative queries</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third Workshop on Hot Topics in Networks (HotNets-III)</title>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Historic Integrity in Distributed Systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Maniatis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
			<pubPlace>Stanford, CA, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Symphony: Distributed hashing in a small world</title>
		<author>
			<persName><forename type="first">G</forename><surname>Manku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USITS</title>
		<meeting>USITS</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A toolkit for user-level file systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2001 USENIX Technical Conference</title>
		<meeting>of the 2001 USENIX Technical Conference</meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Making paths explicit in the Scout operating system</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mosberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="153" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Query processing, approximation, and resource management in a data stream management system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Arasu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Babcock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Datar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Manku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rosenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Varma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CIDR</title>
		<meeting>CIDR</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Monsoon: An explicit token store architecture</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISCA</title>
		<meeting>ISCA</meeting>
		<imprint>
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Using state modules for adaptive query processing</title>
		<author>
			<persName><forename type="first">V</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Handling Churn in a DHT</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rhea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Geels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2004 USENIX Technical Conference</title>
		<meeting>of the 2004 USENIX Technical Conference<address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Killian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kostic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2004-03">March 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Access path selection in a relational database management system</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Selinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Multiple Query Optimization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="23" to="52" />
			<date type="published" when="1988-03">Mar. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Internet indirection infrastructure</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Adkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhaung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Surana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2004-04">Apr. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Chord: a scalable peer-to-peer lookup protocol for internet applications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liben-Nowell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="32" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Using formal description techniques -An Introduction to Estelle</title>
	</analytic>
	<monogr>
		<title level="j">LOTOS and SDL</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Turner</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Dataflow machine architecture</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Veen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1986-12">Dec. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Semiautomatic implementation of protocols using an Estelle-C compiler</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Vuong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">I</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1988-03">Mar. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An integrated experimental environment for distributed systems and networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lepreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Stoller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ricci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guruprasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Newbold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Barb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Joglekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-12">2002. Dec. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
		<title level="m">Base tables */ materialize(member, infinity, infinity, keys(2)). materialize(sequence, infinity, 1, keys(2)). materialize(neighbor, infinity, infinity, keys</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m">/* Environment table containing configuration values */ materialize(env, infinity, infinity, keys</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">)</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>==</surname></persName>
		</author>
		<title level="m">Setup of configuration values */ E0 neighbor@X(X,Y) :-periodic@X(X,E,0,1), env@X</title>
		<imprint/>
	</monogr>
	<note>neighbor</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
		<idno>Sequence := 0</idno>
		<title level="m">Start with sequence number 0 */ S0 sequence@X(X, Sequence) :-periodic@X(X, E, 0, 1)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Periodically start a refresh */ R1 refreshEvent@X(X) :-periodic@X</title>
		<author>
			<persName><forename type="first">/** ; X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<imprint>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
		<title level="m">Increment my own sequence number */ R2 refreshSequence@X(X, NewSequence) :-refreshEvent@X(X), sequence@X(X, Sequence), NewSequence := Sequence + 1</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Save my incremented sequence */ R3 sequence@X(X, NewSequence) :-refreshSequence</title>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
		<imprint>
			<pubPlace>X(X, NewSequence</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m">Send a refresh to all neighbors with my current membership */ R4 refresh@Y(Y, X, NewSequence, Address, ASequence, ALive) :-refreshSequence@X(X, NewSequence), member@X</title>
		<meeting><address><addrLine>X, Address, ASequence, Time, ALive), neighbor@X(X, Y)</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">How many member entries that match the member in a refresh message (but not myself) do I have?</title>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">/ R5 membersFound@X(X, Address, ASeq, ALive, count&lt;*&gt;) :-refresh@</title>
		<meeting><address><addrLine>X(X, Y, YSeq, Address, ASeq, ALive), member@X(X, Address, MySeq, MyTime, MyLive</addrLine></address></meeting>
		<imprint>
			<publisher>X != Address</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
		<title level="m">If I have none, just store what I got */ R6 member@X(X, Address, ASequence, T, ALive) :-membersFound@X(X, Address, ASequence, ALive, C)</title>
		<imprint/>
	</monogr>
	<note>C == 0, T := f_now(</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">If I have some, just update with the information I received if it has a higher sequence number</title>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">*/ R7 member@X(X, Address, ASequence, T, ALive) :-membersFound@X(X, Address, ASequence, ALive, C), C &gt; 0, T := f_now(</title>
		<imprint>
			<publisher>MySequence &lt; ASequence</publisher>
		</imprint>
	</monogr>
	<note>member@X(X, Address, MySequence, MyT, MyLive)</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Update my neighbor&apos;s member entry */ R8 member@X</title>
		<author>
			<persName><forename type="first">/** ; X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yseq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ylive</surname></persName>
		</author>
		<author>
			<persName><forename type="first">)</forename></persName>
		</author>
		<idno>YLive := 1</idno>
	</analytic>
	<monogr>
		<title level="m">T := f_now(</title>
		<meeting><address><addrLine>X(X, Y, YSeq, A, AS, AL</addrLine></address></meeting>
		<imprint/>
	</monogr>
	<note>refresh</note>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Add anyone from whom I receive a refresh message to my neighbors</title>
		<author>
			<persName><forename type="first">/</forename></persName>
		</author>
		<author>
			<persName><forename type="first">*</forename></persName>
		</author>
		<imprint>
			<pubPlace>1 neighbor@X(X, Y); X(X, Y, YS, A, AS, L)</pubPlace>
		</imprint>
	</monogr>
	<note>refresh</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">T := f_now(</title>
		<author>
			<persName><forename type="first">E</forename><surname>/** ; Neighborprobe@x(x) ; @x(x</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">)</forename><surname>; @x(x</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Member@x(x</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Ys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">)</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">L4 member@X(X, Neighbor, DeadSequence, T, Live) :-deadNeighbor@X</title>
		<meeting><address><addrLine>X, Y) :-deadNeighbor@X(X, Y; X, Neighbor), member@X(X, Neighbor, S</addrLine></address></meeting>
		<imprint>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note>L2 deadNeighbor@X(X, Y) :-neighborProbe@X(X). Live := 0, DeadSequence := S + 1, T:= f_now(</note>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">CHORD IN OverLog Here we provide the full OverLog specification for Chord. This specification deals with lookups, ring maintenance with a fixed number of successors, finger-table maintenance and opportunistic finger table population, joins, stabilization, and node failure detection</title>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">The base tuples */ materialize(node, infinity, 1, keys(1)). materialize(finger, 180, 160, keys(2)). materialize(bestSucc, infinity, 1, keys(1)). materialize(succDist, 10, 100, keys(2)). materialize(succ, 10, 100, keys(2)). materialize(pred, infinity, 100, keys(1)). materialize(succCount, infinity, 1, keys(1)). materialize(join, 10, 5, keys(1)). materialize(landmark, infinity, 1, keys(1)). materialize(fFix, infinity</title>
		<imprint>
			<biblScope unit="volume">160</biblScope>
		</imprint>
	</monogr>
	<note>materialize(nextFingerFix, infinity, 1, keys(1)). materialize(pingNode, 10, infinity, keys(2)). materialize(pendingPing, 10, infinity, keys</note>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>@r(r</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename></persName>
		</author>
		<title level="m">bestSucc@NI</title>
		<imprint/>
	</monogr>
	<note>lookup@NI. K in (N,S</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">D:=K -B -1, B in (N,K)</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bi) ; Min&lt;bi&gt;</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">)</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">node@NI(NI,N), bestLookupDist@NI</title>
		<meeting><address><addrLine>NI,I,B,BI), D == K -B -1, B in (N,K)</addrLine></address></meeting>
		<imprint/>
	</monogr>
	<note>finger@NI</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">D:=S -N -1. N3 bestSuccDist@NI(NI,min&lt;D&gt;) :-succDist@NI</title>
		<author>
			<persName><forename type="first">/** ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">)</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Neighbor Selection */ N1 succEvent@NI</title>
		<imprint/>
	</monogr>
	<note>N2 succDist@NI</note>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">bestSuccDist@NI(NI,D), node@NI(NI,N), D == S -N -1. N5 finger@NI(NI,0,S,SI) :-bestSucc@NI</title>
		<imprint/>
	</monogr>
	<note>bestSucc@NI</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">S2 evictSucc@NI(NI) :-succCount@NI(NI,C), C &gt; 4. S3 maxSuccDist@NI(NI,max&lt;D&gt;) :-succ@NI</title>
		<author>
			<persName><forename type="first">/** ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">*&gt;) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">)</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>==</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">node@NI(NI,N), evictSucc@NI(NI), D:=S -N -1. S4 delete succ@NI(NI,S,SI) :-node@NI(NI,N), succ@NI</title>
		<imprint/>
	</monogr>
	<note>maxSuccDist@NI</note>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<author>
			<persName><forename type="first">/** ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">Finger fixing */ F0 nextFingerFix@NI(NI, 0). F1 fFix@NI</title>
		<imprint/>
	</monogr>
	<note>periodic@NI(NI,E,10), nextFingerFix@NI(NI,I)</note>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">K:=1I &lt;&lt; I + N. F4 eagerFinger@NI</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName><forename type="first">I) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">)</forename></persName>
		</author>
		<author>
			<persName><forename type="first">@</forename><surname>Ni(ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName><forename type="first">I) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bi)</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">lookupResults@NI</title>
		<meeting><address><addrLine>NI,I,B,BI; NI,I,B,BI</addrLine></address></meeting>
		<imprint/>
	</monogr>
	<note>eagerFinger@NI</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">I:=I1 + 1, K:=1I &lt;&lt; I + N, K in (N,B), BI != NI. F7 delete fFix@NI(NI,E,I1) :-eagerFinger@NI(NI,I,B,BI), fFix@NI(NI,E,I1), I &gt; 0, I1 == I -1</title>
		<author>
			<persName><forename type="first">I</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Bi) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">eagerFinger@NI(NI,I1,B,BI)</title>
		<imprint/>
	</monogr>
	<note>node@NI</note>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">(I == 159) || (BI == NI)</title>
		<author>
			<persName><forename type="first">I</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bi)</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">F8 nextFingerFix@NI(NI,0) :-eagerFinger@NI</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">-node@NI(NI,N), eagerFinger@NI(NI,I1,B,BI), I:=I1 + 1, K:=1I &lt;&lt; I + N, K in (B,N)</title>
		<author>
			<persName><forename type="first">@</forename><surname>Ni(ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename></persName>
		</author>
		<imprint>
			<publisher>NI != BI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Churn Handling */ C1 joinEvent@NI(NI,E) :-join@NI(NI,E). C2 joinReq@LI</title>
		<author>
			<persName><forename type="first">/** ;</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><forename type="middle">)</forename><surname>Li !=</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">joinEvent@NI(NI,E), node@NI(NI,N), landmark@NI</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ni) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">)</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">I</forename><surname>==</surname></persName>
		</author>
		<title level="m">landmark@NI(NI,LI), joinEvent@NI(NI,E), node@NI</title>
		<editor>
			<persName><forename type="first">@</forename><surname>Ni</surname></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">C5 succ@NI</title>
		<author>
			<persName><forename type="first">@</forename><surname>Li(li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">)</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">join@NI(NI,E), lookupResults@NI</title>
		<imprint/>
	</monogr>
	<note>joinReq@LI</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">SB3 sendPredecessor@PI1(PI1,P,PI) :-stabilizeRequest@NI(NI,PI1), pred@NI</title>
		<author>
			<persName><forename type="first">/** ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">"- ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">)</forename><surname>Pi !=</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">periodic@NI(NI,E,15). SB2 stabilizeRequest@SI(SI,NI) :-stabilize@NI(NI,E), bestSucc@NI</title>
		<imprint/>
	</monogr>
	<note>Stabilization */ SB0 pred@NI</note>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pi) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Pi) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">sendPredecessor@NI</title>
		<imprint/>
	</monogr>
	<note>bestSucc@NI. P in (N,S)</note>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">(</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ni) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">-stabilize@NI(NI,E), succ@NI</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Pi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">sendSuccessors@NI(NI,PI), succ@NI</title>
		<imprint/>
	</monogr>
	<note>returnSuccessor@NI</note>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">(</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ni) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">stabilize@NI(NI,E), node@NI(NI,N), succ@NI</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">pred@NI(NI,P1,PI1), ((PI1 ==</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pi) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Pi</forename><forename type="middle">)</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">node@NI(NI,N), notifyPredecessor@NI</title>
		<imprint/>
	</monogr>
	<note>pred@NI. P in (P1,N)</note>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<author>
			<persName><forename type="first">/** ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">Connectivity Monitoring */ CM0 pingEvent@NI(NI,E) :-periodic@NI(NI,E,5). CM1 pendingPing@NI</title>
		<imprint/>
	</monogr>
	<note>pingEvent@NI(NI,E), pingNode@NI(NI,PI)</note>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">CM3 delete pendingPing@NI</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename><surname>Pi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">)</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">pendingPing@NI</title>
		<imprint/>
	</monogr>
	<note>pingResp@NI</note>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">CM5 pingNode@NI(NI,SI) :-succ@NI</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename><surname>Ri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">)</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si != Ni ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">)</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Pi !=</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><surname>Pi !=</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CM6 pingNode@NI(NI,PI) :-pred@NI</title>
		<imprint/>
	</monogr>
	<note>pingResp@RI</note>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Si) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">CM7 succ@NI</title>
		<imprint/>
	</monogr>
	<note>pingResp@NI</note>
</biblStruct>

<biblStruct xml:id="b78">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pi) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Pi) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">pingResp@NI</title>
		<imprint/>
	</monogr>
	<note>pred@NI</note>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<author>
			<persName><forename type="first">"- ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E) ;</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Pi</forename><forename type="middle">)</forename></persName>
		</author>
		<title level="m">pingEvent@NI(NI,E), pendingPing@NI</title>
		<imprint/>
	</monogr>
	<note>pred@NI</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
