<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An expressive aspect language for system applications with Arachne</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">R</forename><surname>Émi Douence</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">OBASCO project École des Mines de Nantes/INRIA</orgName>
								<address>
									<addrLine>4 rue Alfred Kastler</addrLine>
									<postCode>44307, Cedex 3</postCode>
									<settlement>Nantes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Fritz</surname></persName>
							<email>tfritz@emn.fr</email>
							<affiliation key="aff0">
								<orgName type="department">OBASCO project École des Mines de Nantes/INRIA</orgName>
								<address>
									<addrLine>4 rue Alfred Kastler</addrLine>
									<postCode>44307, Cedex 3</postCode>
									<settlement>Nantes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicolas</forename><surname>Loriant</surname></persName>
							<email>nloriant@emn.fr</email>
							<affiliation key="aff0">
								<orgName type="department">OBASCO project École des Mines de Nantes/INRIA</orgName>
								<address>
									<addrLine>4 rue Alfred Kastler</addrLine>
									<postCode>44307, Cedex 3</postCode>
									<settlement>Nantes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jean-Marc</forename><surname>Menaud</surname></persName>
							<email>jmenaud@emn.fr</email>
							<affiliation key="aff0">
								<orgName type="department">OBASCO project École des Mines de Nantes/INRIA</orgName>
								<address>
									<addrLine>4 rue Alfred Kastler</addrLine>
									<postCode>44307, Cedex 3</postCode>
									<settlement>Nantes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marc</forename><forename type="middle">S</forename><surname>Égura-Devillechaise</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">OBASCO project École des Mines de Nantes/INRIA</orgName>
								<address>
									<addrLine>4 rue Alfred Kastler</addrLine>
									<postCode>44307, Cedex 3</postCode>
									<settlement>Nantes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mario</forename><forename type="middle">S</forename><surname>Üdholt</surname></persName>
							<email>sudholt@emn.fr</email>
							<affiliation key="aff0">
								<orgName type="department">OBASCO project École des Mines de Nantes/INRIA</orgName>
								<address>
									<addrLine>4 rue Alfred Kastler</addrLine>
									<postCode>44307, Cedex 3</postCode>
									<settlement>Nantes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An expressive aspect language for system applications with Arachne</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">79F696DACEA1D900FD840C5CC9568B35</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>aspect language</term>
					<term>sequence pointcut</term>
					<term>dynamic weaving</term>
					<term>system applications</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>C applications, in particular those using operating system level services, frequently comprise multiple crosscutting concerns: network protocols and security are typical examples of such concerns. While these concerns can partially be addressed during design and implementation of an application, they frequently become an issue at runtime, e.g., to avoid server downtime. A deployed network protocol might not be efficient enough and may thus need to be replaced. Buffer overflows might be discovered that imply critical breaches in the security model of an application. A prefetching strategy may be required to enhance performance.</p><p>While aspect-oriented programming seems attractive in this context, none of the current aspect systems is expressive and efficient enough to address such concerns. This paper presents a new aspect system to provide a solution to this problem. While efficiency considerations have played an important part in the design of the aspect language, the language allows aspects to be expressed more concisely than previous approaches. In particular, it allows aspect programmers to quantify over sequences of execution points as well as over accesses through variable aliases. We show how the former can be used to modularize the replacement of network protocols and the latter to prevent buffer overflows. We also present an implementation of the language as an extension of Arachne, a dynamic weaver for C applications. Finally, we present performance evaluations supporting that Arachne is fast enough to extend high performance applications, such as the Squid web cache.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Real-world applications typically comprise multiple crosscutting concerns. This applies, in particular, to C applications using operating system level services. We have examined three concerns which are typical for this domain in the context of a large application, the open source web cache Squid <ref type="bibr" target="#b36">[36]</ref>. More concretely, we have considered translation of network protocols (which may be necessary for efficiency reasons), insertion of checks for buffer overflows (which are at the heart of many of today's security issues), and introduction of prefetching strategies within the cache (which can be used to enhance efficiency of the web cache). We have found that all these concerns are scattered over large portions of the code of Squid.</p><p>Hence, the three concerns are crosscutting in the sense of Aspect-Oriented Programming (AOP) <ref type="bibr" target="#b24">[24]</ref> and aspects should therefore be a means of choice for their modularization. The concerns have three important characteristics. First, they must frequently be applied at runtime, e.g., in order to rapidly fix a buffer overflow and thus prevent security breaches without incurring server downtime. A dynamic aspect weaver is therefore needed. Second, they expose intricate relationships between execution points, e.g., network protocols are most concisely expressed in terms of sequences of execution points, not individual ones. The aspect system must therefore support expressive means for the definition of aspects, in particular pointcuts. Third, efficiency is crucial in the application domain we consider.</p><p>To our knowledge, none of the current aspect systems for C meet these three requirements and is suitable for the modularization of such concerns. Moreover, requirements for dynamic weaving and efficiency often trade off with expressivity. Squid should be as efficient as possible and therefore exploit any suitable operating system and hardware particularity. Its code base is therefore difficult to understand and manipulate, thus hindering in particular modularization efforts. It is therefore highly questionable that the considered modularization problems can be solved without aspects.</p><p>In this paper we propose a solution to the aspectization of such concerns of C applications. More concretely, we provide three main contributions. First, we provide a new expressive aspect language featuring a construct for quantification over sequences of execution points as well as over accesses to local aliases of global variables. We show how this aspect lan-guage permits concise expression of the considered concerns as aspects. Second, we present how the aspect language can be implemented efficiently through runtime weaving into binary code. Concretely, this is done by integrating the aspect language into our tool Arachne, a dynamic weaver for C applications. Furthermore, we present how Arachne improves on our previous work µDyner <ref type="bibr" target="#b32">[32]</ref>. Finally, we give evidence that our approach meets strong efficiency requirements by showing performance evaluations in the context of Squid.</p><p>The paper is structured as follows. Section 2 presents the motivating concerns we identified within Squid. Section 3 shows how to modularize these concerns as aspects and defines our aspect language. Section 4 describes its implementation within Arachne. Section 5 assesses the performance of our implementation. Section 6 describes related work. Section 7 concludes and suggests futures work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MOTIVATIONS</head><p>Legacy C applications involve multiple crosscutting concerns. Many of them remain challenging, both in terms of expressiveness required to handle them properly in an aspect-oriented language and in terms of constraints posed on the weaver. This section describes three such concerns in C applications: switching the network protocol, buffer overflows and prefetching. The network protocol concern is typically scattered through the entire application. It is an issue when administrators discover at runtime that the retained protocol is not efficient enough. Likewise the security threats posed by buffer overflows is a real concrete problem for administrators. While guarding all buffers against overflows might decrease performance considerably, administrators are left with no other option than accepting the tradeoff between security and performance chosen at application's design time. Prefetching is another well-known crosscutting concern <ref type="bibr" target="#b12">[12]</ref>. Since prefetching aims at increasing performance, prefetching aspects make only sense with an efficient weaver. Yet, it is still difficult to modularize these three concerns in today's aspect-oriented language. In this section, we first describe the context in which the concerns arise before showing their crosscutting nature and finally explaining the lack in current aspect-oriented languages to handle them properly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">TCP to UDP protocol</head><p>HTTP was essentially designed as a file transfer protocol running on top of TCP, a connection-oriented protocol ensuring communication reliability. While the average Web page size does not exceed 8 KB <ref type="bibr" target="#b4">[4]</ref>, the cost of retrieving a Web page is often dominated by data exchanged for control purposes of TCP rather than by the page content itself. This is not a new problem, many researches have already pointed out that TCP is not suitable for short-lived connections. While HTTP 1.1 has introduced persistent connections allowing a client to retrieve multiple pages from the same server through the same TCP connection, the number of simultaneous TCP connections is limited by operating systems. Servers have a strong incentive to close HTTP connections as soon as possible. Hence, despite the persistent connection mechanism, many studies conclude that TCP should be replaced by UDP to retrieve short pages <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b7">7]</ref>. In spite of its performance improvements, the number of legacy Web applications has prevented a wide adoption of this solution. Typical legacy Web applications have to be stopped to switch the protocol. The traditional approach to avoid depriving a subnetwork from Internet connectivity while stopping the cache is to swap the application between different machines. This approach is not only expensive in terms of hardware, it complicates the administrative task of the Web cache administrator and poses the problem of consistently transferring the runtime state of the application before restarting it. Stopping an e-commerce Web server means a loss of money and many small companies can not afford the cost of redundant servers. For a wide acceptance, a HTTP dialect using UDP as transport protocol should thus be deployable on demand at runtime.</p><p>In addition, replacing TCP by UDP in an application is relatively difficult. The choice of a transport protocol is usually based on standards believed to be ever-lasting and made at an early design stage. Hence no particular effort is made to localize this design decision in a single piece of code. For example, despite a modularization effort, the TCP API provided by the operating system is used directly in 7 of the 104 ".c" source files of the Squid Web cache.</p><p>As shown in Fig. <ref type="figure" target="#fig_0">1</ref>, the TCP API is built around a set of C functions to be invoked sequentially by the application. In a properly written program, TCP functions are first used to establish the connection (typically with socket, connect, bind and listen), exchange data through the connection (typically with read and write) and then close it (typically close). UDP uses similar but less functions. UDP applications first direct the operating system to dedicate the appropriate resources to exchange data (typically with socket and bind), then exchange data through these resources (typically with sendto and recvfrom) before releasing them (typically with close). Hence, the problem is not only difficult because TCP-related function invocations are scattered but because the relative order of each invocation is important in order to map it onto the appropriate UDP function.</p><p>This example is typical of protocol based APIs. When such an API is used in an undisciplined way, it becomes quickly impossible to replace it by another one. Today, aspect-oriented systems lack an appropriate sequencing construct in their language. Moreover, many do not provide the ability to weave aspects dynamically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Buffer overflows</head><p>In C, the size of an array is fixed at allocation time. According to ISO and ANSI standards <ref type="bibr" target="#b2">[2]</ref>, an invalid array access does not result in an immediate error but leads to an implementation-dependent behavior. Such behavior is increasingly exploited by hackers to circumvent security re-strictions <ref type="bibr" target="#b37">[37]</ref>. It is therefore crucial for C programmers to ensure every access to an array to be valid. On the other hand, bound checking code is error prone: it is easy to forget to check an access and even when the access is checked, it is easy to compare the index locating the access with an inappropriate bound. Therefore, researchers have proposed to make compilers responsible for enforcing proper array access <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b31">31]</ref>. The problem is that even the most efficient system (CRED <ref type="bibr" target="#b31">[31]</ref>) slows down an application up to 130%. Moreover, most frequently used compilers like gcc do not support bound checking.</p><p>Today, administrators discovering a buffer overflow in production software are left with no other option than stopping the application and restarting a bug free version. This was the solution chosen when a buffer overflow was discovered in Squid in <ref type="bibr" target="#b6">[6]</ref>. While widely used, this solution suffers from three major drawbacks. First, it does not enforce continuous servicing since the service delivered by the application is not available during the update. Second, this solution entails an important information loss: an administrator has no means to learn whether the buffer overflow has been exploited by a hacker or not. Third, it misunderstands the performance trade-off, i.e. it is not necessary to check every array access, it is only necessary to perform enough checking to discourage hackers. Therefore, bound checking code should only run when an environment becomes hostile <ref type="bibr" target="#b23">[23]</ref>.</p><p>Bound checking code tends to crosscut the entire application. For example, properly written C functions accepting an array argument commonly take a second argument holding the array size: the first one allows the function to access the array while the second is used to ensure correctness of accesses. In Squid, bound checking code can be found in any of the 104 ".c" files of its source code. On the 57635 lines composing these ".c" files, at least 485 check bounds.</p><p>This problem fails to be handled properly in current aspect languages as they lack the ability to trigger advices upon access made through the alias of a variable. Again, many aspect-oriented systems offer only static weaving capabilities preventing the administrator to choose the tradeoff security/performance suiting his needs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">From fetching to prefetching</head><p>Operations like retrieving a file on a local disk or over the Web can be sped up if the underlying software anticipates user requests and start to fetch documents beforehand. Such prefetching schemes distinguish themselves from each other in the way they predict future user requests. These "oracles" actually prevent a clean encapsulation of prefetching in a single module communicating with the rest of the application through well-defined interfaces since predictions are based on information meant to be private to other modules. In addition, it is very likely that there is no universal perfect oracle <ref type="bibr" target="#b19">[19]</ref>. A statically linked prefetching module is therefore inappropriate, but prefetching modules along with the necessary oracles should be loaded and unloaded on the fly. Due to their crosscutting nature, prefetching modules including such oracles are better written with aspects <ref type="bibr" target="#b32">[32]</ref>.</p><p>Coady et al. have already pointed out the crosscutting nature of prefetching in the FreeBSD OS <ref type="bibr" target="#b12">[12]</ref>. In our previous work considering the Squid Web cache, we reached a similar conclusion <ref type="bibr" target="#b32">[32]</ref>. We have previously shown that this concern can be addressed with cflow-like constructs.</p><p>Despite potential performance improvements, prefetching also increases resource consumption (e.g. network prefetching consumes local storage and bandwidth). When the pressure on resources is too high, prefetching computation competes for them against regular user requests, and slows down their treatment instead of speeding it up. In such cases, prefetching should therefore be, temporarily, disabled. Squid essentially manages file descriptors, a resource only available in a limited quantity. A file descriptor is used between the underlying operating system and applications to describe a network connection or a file on the disk. Squid's file descriptor management is based on a global variable that tracks the number of file descriptors currently in use. By comparing its value with the maximum number of file descriptors allowed by the operating system, it is possible to estimate that prefetching should be disabled or resumed.</p><p>For this problem of file descriptor consumption, the current practice of checking if prefetching should be disabled or not within the advice, is a bad practice that impedes both readability and maintainability. A mechanism is needed within the aspect language to restraint the advice execution at times where the pressure on resources is too high. This problem were not addressed in our previous work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">AN EXPRESSIVE ASPECT LANGUAGE FOR SYSTEM PROGRAMMING IN C</head><p>While AOP seems to be the obvious choice to tackle the crosscutting concerns introduced above, none of the existing AO systems provides explicit support for some of their essential elements, in particular, join point sequences for protocols, and references to aliases which are local to a function.</p><p>In this section we introduce a new aspect language for system programming in C that allows such crosscutting concerns to be expressed concisely. In order to make this point, we first revisit the examples by concisely aspectizing them using our language. (Note that our aspect language is expressive in the sense of enabling the concise definition of certain types of aspects, especially compared to other tools for system-level manipulations, but not necessarily more expressive than existing approaches in a language-theoretic sense.) We then define the join point model underlying our language precisely, followed by the definition of its syntax and informal semantics. Finally, we illustrate how its semantics can be formally defined in terms of a small-step operational semantics using the framework introduced in <ref type="bibr" target="#b14">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Example crosscutting concerns revisited</head><p>We now revisit the concerns discussed in section 2 in order to show our language in action and give evidence that it allows such concerns to be concisely modularized.</p><p>The aspect shown in Fig. <ref type="figure" target="#fig_1">2</ref> translates transport protocols from TCP to UDP. A protocol defines a sequence of function calls, so the top-level operator of this aspect is seq. The sequence aspect syntactically consists of a list of pairs of pointcut and advice (separated by then). In the example, the TCP protocol starts with a call to socket() with three constant arguments: AF INET, SOCK STREAM and 0. When such a call is matched, the second parameter is replaced by SOCK DGRAM as required by the UDP protocol. The result of this transformed call, the file descriptor, is bound to fd by return(fd). Then the next call to connect() with the same file descriptor fd as its first parameter is matched. In this case the values of the other parameters seq( call(int socket(int, int, int)) &amp;&amp; args(AF INET, SOCK STREAM, 0) &amp;&amp; return(fd) then socket(AF INET, SOCK DGRAM, 0); call(int connect(int, struct socketaddr * , socklen t)) &amp;&amp; args(fd, address, length) then returnZero(); // where int returnZero() { return 0; } ( call(size t read(int, void * , size t)) &amp;&amp; args(fd, readBuffer, readLength) then recvfrom(fd, readBuffer, readLength, 0, address, length); || call(size t write(int, void * , size t)) &amp;&amp; args(fd, writeBuffer, writeLength) then sendto(fd, writeBuffer, writeLength, 0, address, length); ) * call(int close(int)) &amp;&amp; args(fd) ; ) &amp;&amp; args(allocatedSize) &amp;&amp; return(buffer) ; write(buf f er) &amp;&amp; size(writtenSize)</p><p>&amp;&amp; if(writtenSize &gt; allocatedSize) then reportOverflow (); * call(void free(void * )) )</p><p>Figure <ref type="figure">3</ref>: An Aspect for Detecting Buffer Overflow are bound to arguments address and length, and the original call is replaced by returnZero(). Indeed, there is no connect step in the UDP protocol. After that, calls to read() and write() (using the 'or' on aspects: ||) on the same file descriptor fd are translated to UDP recvfrom() and sendto(), respectively. Note that sequences of such access are potentially translated (due to use of the repetition operator * ). Finally, a call to close() on fd terminates the TCP protocol as well as the UDP protocol and thus is not modified (i.e., there is no then clause). This last step is required to free the variables used in the sequence (here, fd, address and length). Indeed, this aspect can use numerous (instances of these) variables when it deals with interleaved sequences, as each call to socket() creates a new instance of the sequence.</p><p>The aspect shown in Fig. <ref type="figure">3</ref> detects buffer overflows. The corresponding sequence starts when the function malloc() returns the buffer address which is then bound to buffer. Then, each time this address is accessed (through a global variable or a local alias) the size of the data to be written is compared with the size of the initially allocated memory. If the former exceeds the latter, an overflow is indicated. The sequence ends when the memory is deallocated using free().</p><p>The aspect in Fig. <ref type="figure">4</ref> introduces prefetching in a web cache. The first controlflow phrase initializes prefetching when an HTTP response is built (clientBuildReply()) within the control flow of a client request (clientSendMoreData()). The until clause stops prefetching when the number of connection becomes too large, a situation where prefetching would effectively degrade performance. The second controlflow phrase analyzes hyperlinks in a page being transmitted (i.e., when comm write mbuf() is called within the control flow of clientSendMoreData()). Finally, the last call phrase prefetches hyperlinks analyzed by the second aspect. It does so by replacing the method call to clientWriteComplete() with retrieveHyperlinks(). Finally, note that the two require clauses at the top of the aspect declare the types of the global variables of the base program used in the aspects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Join points</head><p>A join point model defines the points in the execution of the base program to which pointcuts may refer. In our </p><formula xml:id="formula_0">JP ::= callJP(val funId( -→ val)) | readGlobalJP(varId, val) | readJP(@, val) | writeGlobalJP(varId, val, size) | writeJP(@, val, size) | controlflowJP( ----→ f unId, cfEnd) | controlflowstarJP( ----→ f unId, cfEnd) cf End ::= callJP(val funId( -→ val)) | readGlobalJP(varId, val) | writeGlobalJP(varId, val, size) val ::= 0 | 1 | 2 | ... // int | @0 | @1 | @2 | ... // int* | ... // values of other C types</formula><formula xml:id="formula_1">• A call of a function callJP(v 1 funId( -→ v 2 )</formula><p>) with function name funId , return value v 1 and a vector of arguments -→ v 2 .</p><p>• A read access which comes in two variants: readGlobalJP(varId, v) denotes reading a global variable with name varId holding the value v ; readJP(@, v) denotes reading a global variable or a local alias with address @ holding the value v .</p><p>• Write access which also comes in two variants: writeGlobalJP(varId, v, size) denotes assignment to a global variable with name varId of the value v of size size. writeJP(@, v, size) denotes assignment to a global variable or a local alias with address @ of the value v of size size.</p><formula xml:id="formula_2">• A cflow expression controlflowJP( ----→ f unId, c), where ----→ f unId = [funId1 , ..,</formula><p>funIdn ] is a stack of function names, and c (either a function call or an access to a global variable) occurs within the body of function f unId n . Such a join point requires a call to f unId i+1 within the body of f unId i . </p><formula xml:id="formula_3">• A cflow expression controlflowstarJP( ----→ f unId, c), where ----→ f unId = [funId1 , ..,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Pointcuts</head><p>We now present a pointcut language (see Fig. <ref type="figure">6</ref>) that provides constructs to match individual join points.</p><p>Primitive pointcuts are defined by PPrim and comprise three basic pointcuts matching calls, global variable accesses, and control flow join points. Primitive pointcuts can also be combined using a logical "or" noted ||.</p><p>A call pointcut PCall selects all function call join points callJP(val funId( -→ val)), i.e., all calls to a function matching the signature type funId ( --→ type), where the arguments of the function can be bound to pointcut variables using argument binder args( -----→ pattern ) and the return value can be bound to a pointcut variable using a return clause return( pattern ). The two constructs args( -----→ pattern ) and return( pattern ) can also provide pattern matching by using values (or already bound pointcut variables) in pattern. Pointcuts can also depend on a boolean condition using the if-constructor.</p><p>A global access pointcut PAccGlobal selects either all read join points readGlobalJP(varId, val) or all write join points writeGlobalJP(varId, val, size) on the global base program variable varId . In these cases, the read or written value can be bound to a variable using value(pattern); in addition, the size of the written value can be bound with size(varName). Pattern matching can also be used for variable access.</p><p>A control flow pointcut PCf of the form controlflow( PCallSig 1 , ..., PCallSig n , PCfEnd ) matches all join points of the form controlflowJP(funId 1 , ..., funId n , cfEnd), where the function identifier in P CallSigi is f unIdi. Similarly, a control flow pointcut may match a global variable access for a given stack configuration. The pointcuts of the form controlflowstar(. . . ) select calls or global variable accesses in a stack context allowing for calls that are not directly nested within one another.</p><p>Finally, P Acc, an access pointcut for a global variable or all of its local aliases, matches all join points of the form readJP or writeJP.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Aspect Language</head><p>The aspect language we propose is defined in Fig. <ref type="figure" target="#fig_4">7</ref>. Aspects Asp are either primitive AspP rim, or sequences of primitive aspects AspSeq.</p><p>A primitive aspect AspPrim combines a primitive pointcut with an advice that will be applied to all join points selected by the pointcut. If the primitive pointcut has the form p 1 || p 2 , then all variables used in the advice have to be bound in both, p 1 and p 2 .</p><p>An advice (Advice) is a C function call that replaces a join point in the base program execution (similarly to around in AspectJ). It must have the same return type as the join point it replaces: the type of the global variable in case of a read access, void for a write access and the return type of the function for a call. When the advice is empty (no then clause), the original join point is executed. The original join point can be skipped by calling an empty C function.</p><p>A sequence aspect is composed of a sequence of primitive aspects. A sequence starts when the first primitive aspect matches. Then the second primitive aspect becomes active instead of the first one. When it matches, the third aspect becomes active instead of the second one. And so on, until the last primitive aspect in the sequence. All but the first and last primitive aspects can be repeated zero or multiple times by using * : in this case, the primitive aspect is ac- tive as long as the following one in the sequence does not match. Branching, i.e., a logical 'or' between two primitive aspects, can be introduced in a sequence by the operator ||.</p><p>An element of the sequence can also match a global variable of the base program and accesses to its local aliases, as soon as its address is known (i.e., a previous primitive pointcut has already bound its address to a pointcut variable).</p><p>Hence, an aspect matching accesses cannot start a sequence. Every join point matching the first primitive pointcut of a sequence starts a new instance of the sequence. The different instances are matched in parallel.</p><p>A primitive or a sequence aspect a can be used in combination with an expression until(a1 ), to restrict its scope. In this case, once a join point has been matched by a, the execution of a proceeds as previously described until a 1 matches.</p><p>To conclude the presentation of our language, note that it does not include some features, such as named pointcuts as arguments to controlflows and conjunctive terms, which are not necessary for the examples we considered but which could easily be added. (As an aside, note that such extensions of the pointcut language may affect the computability of advanced algorithmic problems, such as whether a pointcut matches some part of any base program <ref type="bibr" target="#b25">[25]</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Towards a formal semantics for expressive aspects</head><p>In the previous sections, we have given an informal semantics of our aspect language. We now illustrate how the aspect language could be formally defined by translating one of the example aspects into formal aspect language by extension of that used in the formal framework of <ref type="bibr" target="#b14">[14]</ref>.</p><p>The original formal language must be extended in order to deal with halting aspects, an unbounded number of sequential aspects and arbitrary join point predicates. The grammar of the extension, our tiny aspect language, is defined in Figure <ref type="figure">8</ref>. In this language, aspect expressions A consists of parallel combinations of aspects, C is a join point predicate (similar to our pointcut language) expressed as a conjunction of a term pattern and possibly an expression from the constraint logic programming language CLP(R) <ref type="bibr" target="#b20">[20]</ref>.</p><p>An aspect A is either:</p><p>• A recursive definition.</p><p>• A sequence formed using the prefix operation C £ I ; X, where X is an aspect or a recursion variable and I a piece of code (i.e., an advice).</p><p>• A choice construction A 1 P A 2 which chooses the first aspect that matches a join point (the other is thrown away).</p><p>If both match the same join point, A 1 is chosen.</p><p>• A parallel composition of two aspects A 1 || A 2 that cannot occur in choice construction.</p><p>• A halting aspect STOP.</p><p>The semantics of the protocol translation aspect (from TCP to UDP) is given in Fig. <ref type="figure">9</ref>. A sequence can have several instances. This is translated into the language A by the expression a 1 || ... which starts a new sequence a 1 once the first join point has been matched and continue to match the rest of the sequence in progress.  <ref type="figure">9</ref>: Definition of the protocol translation using the tiny aspect language P. Finally, the last primitive aspect of the sequence occurs as the first aspect of a choice to get priority over the join points read and write because of the * . Note that we use pattern matching in A and that an overbar marks the first occurrence of a variable (i.e., its definition not a use).</p><p>Note that formal definitions such as that of the protocol translation aspect precisely define several important issues, in particular, when new instances of the sequence aspect are created, and disambiguate of potentially non-deterministic situations, e.g., when two pointcuts of consecutive primitive aspects in the sequence match at the same time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DYNAMIC WEAVING WITH ARACHNE</head><p>Arachne is built around two tools, an aspect compiler and a runtime weaver. The aspect compiler translates the aspect source code into a compiled library that, at weaving time, directs the weaver to place the hooks in the base program. The hooking mechanisms used in Arachne are based on improved techniques originally developed for µDyner <ref type="bibr" target="#b32">[32]</ref>. These techniques allow to rewrite the binary code of executable files on the fly i.e.without pausing the base program, as long as these files conform to the mapping defined by the Unix standard <ref type="bibr" target="#b35">[35]</ref> between the C language and x86 assembly language. Arachne's implementation is structured as an open framework that allows to experiment with new kinds of join points and pointcut constructs. Another important difference between Arachne and µDyner is, that µDyner requires a compile time preparation of the base program, whereas Arachne does not. Hence Arachne is totally transparent for the base program while µDyner is not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Arachne Open Architecture</head><p>The Arachne open architecture is structured around three main entities: the aspect compiler, the instrumentation kernel, and the different rewriting strategies. The aspect compiler translates the aspect source code into C before compiling it. Weaving is accomplished through a command line tool weave that acts as a front end for the instrumentation kernel. weave relays weaving requests to the instrumentation kernel loaded in the address space of the program through Unix sockets. Upon reception of a weaving request, the instrumentation kernel selects the appropriate rewriting strategies referred by the aspects to be woven and instruments the base program accordingly. The rewriting strategy consults the pointcut analysis performed by the aspect compiler to locate the places where the binary code of the base program needs to be rewritten. It finally modifies the binary code to actually tie the aspects to the base program.</p><p>With this approach, the Arachne core is independent of a particular aspect, of the aspect language, of the particular processor architecture, and of a particular base program. In fact, all dependencies to aspect language implementation are limited to the aspect compiler. All dependencies to the operating system are localized in the instrumentation kernel and finally all dependencies to the underlying hardware architecture are modularized in the rewriting strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">The Arachne aspect compilation process</head><p>The aspect compilation scheme is relatively straightforward: it transforms advices into regular C functions. Pointcuts are rewritten as C code driving hook insertions into the base program at weaving time. There are however cases where the sole introduction of hooks is insufficient to determine whether an advice should be executed. In this case, the aspect compiler generates functions that complement the hooks with dynamic tests on the state of the base program. These dynamic tests are called residues in AspectJ and the rewritten instructions within the base program the shadow <ref type="bibr" target="#b16">[16]</ref>. Once the aspects have been translated into C, the Arachne compiler uses a legacy C compiler to generate a dynamically linked library (DLL) for the compiled aspects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">The Arachne weaving process</head><p>From a user viewpoint, the Arachne weave and deweave command line programs the same syntax than µDyner's version. They both take two arguments. The first identifies the process to weave aspects in or deweave aspects from, and the second indicates the aspect DLL. However, Arachne can target potentially any C application running on the machine while µDyner was limited to applications compiled with it running on the machine. When Arachne's weave receives a request to weave an aspect in a process that does not contain the Arachne instrumentation kernel, it loads the kernel in the process address space using standard techniques <ref type="bibr" target="#b11">[11]</ref>.</p><p>The instrumentation kernel is transparent for the base program as the latter cannot access the resources (memory and sockets essentially) used by the former. Once injected, the kernel creates a thread with the Linux system call: clone. This thread handles the different weaving requests. Compared to the POSIX pthread create function, the usage of clone allows the instrumentation thread to prevent the base program to access its sockets. The instrumentation kernel allocates memory by using side effect free allocation routines (through the Linux mmap API). Because the allocation routines are side effect free, Arachne's memory is totally invisible to the base program. It is up to the aspect to use Arachne's memory allocation routines or base program specific allocation functions. This transparency turns out to be crucial in our experiments. Legacy applications such as Squid use dedicated resource management routines and expect any piece of code they run to use these routines. Failures will result in an application crash.</p><p>After loading an aspect, the instrumentation kernel rewrites the binary code of the base program. These rewriting strategies are not included in the kernel and must be fetched on demand by each loaded aspect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Rewriting strategies</head><p>Rewriting strategies are responsible for transforming the binary code of the base program to effectively tie aspects to  the base program at weaving time. These strategies localize Arachne's main dependencies to the underlying hardware architecture. In general, rewriting strategies need to collect information about the base program. These information typically consist of the addresses of the different shadows, their size, the symbol (i.e.function or global variable name) they manipulate, their length etc. In order to keep compiled aspects independent from the base program, this information is gathered on demand at runtime. The mapping between a symbol name in the base program source code and its address in memory is inferred from linking information contained in the base program executable. However because these information can be costly to retrieve, Arachne collects and stores it into meta-information DLLs. these DLLs behave as a kind of cache and lessen the problem of collecting the information required to instrument the base program. To implement our aspect language, Arachne provides a set of eight rewriting strategies that might eventually use each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Strategies for call, readGlobal and writeGlobal</head><p>In Arachne, call, readGlobal and writeGlobal allow an advice to be triggered upon a function call, a read on a global variable or a write respectively. While the implementation of readGlobal and writeGlobal in Arachne is close to the one in µDyner, Arachne implements the strategy for call by rewriting function invocations found in the base program. µDyner instead rewrites the function body of the callee. On the Intel architecture, function calls benefit from the direct mapping to the x86 call assembly instruction that is used by almost, if not all, compilers. Write and read accesses to global variables are translated into instructions using immediate, hard coded addresses within the binary code of the base program. By comparing these addresses with linking information contained in the base program executable, Arachne can determine where the global variable is being accessed. Therefore those primitive pointcuts do not involve any dynamic tests. The sole rewriting of the binary base program code is enough to trigger advice and residue<ref type="foot" target="#foot_0">1</ref> executions at all appropriate points.</p><p>The size of the x86 call instruction and the size of an x86 jump (jmp) instruction are the same. Since the instruction performing an access to a global variable involves a hard coded address, x86 instructions that read or write a global variable have at least the size of a x86 jmp instruction. Hence at weaving time, Arachne rewrites them as a jmp instruction to a hook. Hooks are generated on the fly on freshly allocated memory. As shown in figure <ref type="figure" target="#fig_7">10</ref>, hooks contain a few assembly instructions that save and restore the appropriate registers before and after an advice (or shadow) execution. A generic approach is to have hooks save the whole set of registers, then execute the appropriate residue and/or advice code before restoring the whole set of registers; finally the instructions found at the join point shadow are executed to perform the appropriate side effects on the processor registers. This is accomplished by relocating the instructions found at the join point shadow. Relocating the instructions makes the rewriting strategies handling read and write access to global variable independent from the instruction generated by the compiler to perform the access<ref type="foot" target="#foot_1">2</ref> . The limited number of x86 instructions used to invoke a function allows Arachne's rewriting strategy to exploit more efficient, relocation free, hooks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Strategies for controlflow and controlflowstar</head><p>Every time a C function is called, the Linux runtime creates an activation record on the call stack <ref type="bibr" target="#b35">[35]</ref>. Like µDyner, Arachne's implementation of the rewriting strategy for controlflow uses the most deeply nested function call (or global read or write access) in the control flow pointcut as shadow. This shadow triggers a residue. This residue uses the activation record's chaining to check whether the remaining function calls of the control flow, are on the call stack maintained by the Linux runtime. An appropriate usage of hashtables that store the linking information contained in the base program executables can thereby decrease the cost of determining if a specific function is the caller of another to a pointer comparison. Therefore, the residue for a controlflow with n directly nested functions implies exactly n pointer comparisons. However, the residue worst case runtime for the indirect control flow operator controlflowstar that allows for not directly nested functions, is proportional to the base program stack depth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Strategies for read and write</head><p>read and write are new join points not included in µDyner that have been added to the latest version of Arachne. Their implementation relays on a page memory protection as allowed by the Linux operating system interface (i.e. mprotect) and the Intel processor specifications <ref type="bibr" target="#b18">[18]</ref>. A read or write pointcut triggers a residue to relocate the bound variable into a memory page that the base program is not allowed to access and adds a dedicated signal handler. Any attempt made by the base program to access the bound variable identified will then trigger the execution of the previously added signal handler. This handler will then inspect the binary instruction trying to access the protected page to determine whether it was a read or a write access before eventually executing the appropriate advice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Strategies for seq</head><p>Like read and write, seq is a new language feature of Arachne. µDyner offers no equivalent construct. Arachne's rewriting strategy of this operator associates a linked list to every stage inside the sequence except the last one. Each stage in a sequence triggers a residue that updates these linked lists to reflect state transitions of currently matching execution flows. Upon matching of the first pointcut of the first primitive aspect in the seq, a node is allocated and added to the associated linked list. This node contains a structure holding variables shared among the different pointcuts within the sequence. Once a join point matches a pointcut of an primitive aspect denoting a stage in the sequence, Arachne consults every node in the linked list associated with the previous stage and executes the corresponding advice <ref type="foot" target="#foot_2">3</ref> . Arachne eventually updates the node and in the absence of a * moves it to the list associated with the currently matched pointcut.If the matching pointcut corresponds to the end of the sequence, structures are not moved into another list but freed. Our aspect compiler includes an optimization where structures are allocated from a resizable pool and upon a sequence termination, structures are not freed but returned to the pool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Arachne limitations</head><p>Aggressive optimizations of the base program might prevent Arachne to seamlessly weave aspects. Two optimizations are not yet supported by Arachne. First if the compiler inlines a function in another one within the binary code of the base program, the Arachne weaver will fail to properly handle pointcuts referring to that function. Second, control flow pointcuts are based on the chaining of activation records. On the x86 architecture, in leaf functions, optimizing compilers sometimes do not maintain this chaining to free one register for the rest of the computation. This however has not been a problem during our experiments as we used the open source C compiler gcc. Arachne supports two of the three optimization levels proposed by gcc. Stripping that removes linking information and aggressive optimizations that break the interoperability between compilers and/or debuggers are incompatible with Arachne. In practice, Arachne can be used on applications compiled like squid with two of the three gcc optimization level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PERFORMANCE EVALUATION</head><p>Aspect-oriented solutions will be used if the aspect system's language is expressive enough and if the aspect system overhead is low enough, for the task at hand. The purpose of this section is to study Arachne's performance. We first present the speed of each Arachne language construct and compare it to similar C language constructs. We then study the overhead of extending Squid with a prefetching policy. This case study shows that even if the cost of some Arachne aspect language constructs might be high compared to C language constructs, this overhead is largely amortized in real applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Evaluation of the language constructs</head><p>This performance evaluation focuses on studying the cost of each construct of our aspect language. To estimate the cost for each construct of our aspect language, we wrote an aspect using this construct that behaves as an interpreter of the base program. For example, to study the performance of readGlobal, we wrote an aspect whose action returns the value of the global variable referred in the pointcut, i.e., we wrote aspects behaving like the base program. For each of these aspects, we compare the time required to perform the operation matching the pointcut, in case the operation is interpreted by the woven aspect with the time required to carry out the operation natively (without the woven aspect).</p><p>For example, to study the performance of readGlobal, we first evaluate the time needed to retrieve the global variable value through the code generated by the C compiler gcc without any aspect woven and compare this value to the time needed to retrieve the global variable value through the aspect once it has been woven in the base program. We express our measurements as a ratio between these two durations to abstract from the experimentation platform. This approach requires the ability to measure short periods of time. For instance, a global variable value is usually retrieved (readGlobal in our aspect language) in a single clock tick. Since standard time measurement APIs were not precise enough, our benchmarking infrastructure relies on the rdtsc assembly instruction <ref type="bibr" target="#b18">[18]</ref>. This instruction returns the number of clock cycles elapsed since power up. The Pentium 4 processor has the ability to dynamically reorder the instructions it executes. To ensure the validity of our measurement, we thus insert mfence instructions in the generated code whose execution speed is being measured. An mfence forces the preceding instructions to be fully executed before going on. The pipeline mechanism in the Pentium 4 processor entails that the speed of a piece of assembly code depends from the preceding instructions. To avoid such hidden dependencies, we place the operation whose execution time is being measured in a loop. We use gcc to unroll the loop at compile time and we measure the time to execute the complete loop. This measure divided by the number of loop repetitions yields an estimation of the time required to execute the operation. The number of times the loop is executed is chosen after the relative variations of the measures ,i.e., we increased the number of repetitions until ten runs yields an average relative variation not exceeding 5%.</p><p>To check the correctness of our experimental protocol, we measured the time needed to execute a nop assembly instruction, that requires one processor cycle according to the Intel specification. The measures of nop presented a relative variation of 1.6%.</p><p>Table <ref type="table" target="#tab_2">1</ref> summarizes our experimental results. Using the aspect language to replace a function that returns immediately is only 1.3 times slower than a direct, aspect-less, call to that empty function. Since the aspect compiler packages advices as regular C functions, and because a call pointcut involves no residue, this good result is not surprising. When seq and controlflow can refer to several points in the execution of the base program (i.e. different stages for seq and different function invocations for the controlflow). The runtime of these pointcuts grows linearly with the number of execution points they refer to and with the number of matching instances. Figure <ref type="figure" target="#fig_0">11</ref> summarizes a few experimental results for controlflow and seq proving these points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Case Study on a real application</head><p>Since, depending on the aspect construct used, interpreting the base program with aspects can slow it down by a factor ranging between 1.3 and 9729, we studied Arachne's performance on a real world application, the Web cache Squid.  We extended Squid with a prefetching policy <ref type="bibr" target="#b9">[9]</ref>. As described in section 3.1, we implemented this policy as a set of aspects and made a second implementation of this policy by editing the Squid source code and recompiling it. This section compares the performance of these two implementations using standard Web cache performance indicators: throughput, response time and hit ratio.</p><p>Obtaining access traces adequate to study a Web cache performance is difficult. The trace must be long enough to fill the cache. Due to privacy issues, traces are usually not publicly available. Since traces do not include the content of the accessed pages, these pages must be downloaded again. In the meantime the page contents may have changed and even the URLs may have disappeared.</p><p>Instead of traces, we based our evaluation on Web Polygraph <ref type="bibr" target="#b30">[30]</ref>. Polygraph is a benchmarking tool developed by the Squid team and featuring a realistic HTTP and SSL traffic generator and a flexible content simulator.</p><p>We filled up the cache and simulated a one day workload with its two request rate peaks observed in real life environments <ref type="bibr" target="#b30">[30]</ref>. Table <ref type="table" target="#tab_5">2</ref> shows results of our simulation. Measures have been made during the two request peaks. The hit time and the miss time, time needed to deliver a document present, respectively not present, in the cache are very similar. It shows that differences are imperceptible between the version of Squid extended by Arachne and the one extended manually (less than 1%). Hence, even if the cost of Arachne's aspect language constructs might seem high, they are largely amortized in real applications. To give a typical example observed on our experimental platform: in case of a cache hit, a 3.8 MB page was retrieved in a single second, the time spent in prefetching advices amounted to 1801 µsec, and the time spent within Arachne to execute the hooks and dynamic tests to 0.45 µsec. In a miss case, on the average, a client retrieved the same page in 1.3 seconds, 16679 µsec were spent in the advices and 0.67 µsec within Arachne itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Our work is directly related to other aspect weavers for C, approaches for expressive aspect languages, and dynamic weaving, in particular for C. In this section, we consider related work in each of these fields in turn.</p><p>Apart from µDyner and Arachne, there are few aspect weavers for C (or even C like languages); some noteworthy exceptions are AspectC <ref type="bibr" target="#b12">[12]</ref> (no available implementation), AspectC++ and <ref type="bibr" target="#b33">[33]</ref>. All of these rely on source-code transformation and thus cannot apply aspects to running C applications as required by the applications we consider. Furthermore, none of these systems provides explicit support for aspects over join point sequences.</p><p>There is quite a large body of work now on the notion of expressive aspect languages where "more expressive" typically compares to w.r.t. AspectJ's pointcut and advice models. Our work has been inspired by Event-based AOP <ref type="bibr" target="#b15">[15]</ref>, which aims at the definition of pointcuts in terms of arbitrary relations between events. Nevertheless, many other approaches to expressive aspect languages exist: e.g., dataflow relations <ref type="bibr" target="#b26">[26]</ref>, logic programming <ref type="bibr" target="#b13">[13]</ref>, process algebras <ref type="bibr" target="#b3">[3]</ref>, graphs <ref type="bibr" target="#b5">[5]</ref>, and temporal logics <ref type="bibr" target="#b1">[1]</ref>, have all been proposed as a basis for the definition of expressive aspect languages. However, few of these encompass dynamic weaving and only the latter has been applied to C code under efficiency considerations similar to our setting.</p><p>Dynamic weaving is commonly realized in Java through preprocessing at load-time like <ref type="bibr">[8]</ref> or through the JVM Debugging Interface <ref type="bibr" target="#b28">[28]</ref>. These tools rely on bytecode rewriting techniques, have typically limited expressivity (some do not support field accesses) and incur a huge performance overhead. Dynamic weaving through modification at runtime is found infrequently for compiled languages. An exception for Java is JasCo <ref type="bibr" target="#b21">[21]</ref> whose most recent version (0.7) supports dynamic weaving through the new instrumentation API of Java 5.</p><p>Many instrumentation techniques have been proposed to rewrite binary code on the fly. In these approaches, difficulty issues range from the complexity to rewrite binary code to the lack of a well-defined relationship between source code and the compiler generated binary code. Hence many approaches work on an intermediate representation of the binary code and source language <ref type="bibr" target="#b34">[34]</ref>. Producing this representation first and then regenerating the appropriate binary executable code has proven to be costly both in terms of memory consumption and in CPU time.</p><p>A few other approaches have considered a direct rewriting of the binary code at runtime. Dyninst <ref type="bibr" target="#b17">[17]</ref> and dynamic probes <ref type="bibr" target="#b27">[27]</ref> allow programmers to modify any binary instruction belonging to an executable. Dyninst however relies on the Unix debugging API: ptrace. ptrace allows a third party process to read and write the base program memory. It is however highly inefficient: before using ptrace, the third party process has to suspend the execution of the base program and resume its execution afterwards. In comparison, Arachne uses ptrace at most once, to inject its kernel DLL into the base program process. In addition, Dyninst does not free the programmer from dealing with low level details. For example, it seems difficult to trigger an advice execution upon a variable access with Dyninst: the translation from the variable identifier to an effective address is left to the user. Worse, Dyninst does not grant that the manipulation of the binary instructions it performs will succeed. Dyninst uses an instrumentation strategy where several adjacent instructions are relocated. This is unsafe as one of the relocated instructions can be the target of branching instructions. In comparison, Arachne join point model has been carefully chosen to avoid these kind of issues; if an aspect can be compiled with Arachne, it can always be woven.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION AND FUTURE WORK</head><p>In this paper we have discussed three different crosscutting concerns which are typical for C applications using OSlevel services and which frequently need to be applied at runtime. We have motivated that such concerns can be expressed as aspects and have defined a suitable aspect language. This language is more expressive than those used in other aspect weavers for C in that it provides support for aspects defined over sequences of execution points as well as for variable aliases. We have presented an integration of this language into Arachne, a weaver for runtime weaving of aspects in C applications. Finally, we have provided evidence that the integration is efficient enough to apply such aspects dynamically to high-performance applications, in particular the web cache "squid."</p><p>As future work, we intend to investigate the suitability of the proposed aspect language for other C-applications. We also intend to investigate Arachne extension to the C++ language. Indeed, object-oriented programming heavily uses protocol-based interfaces collaboration (hence sequence aspects). Along with its open architecture, extending Arachne to support C++, will pave the way to a relatively language independent aspect and weaving infrastructure. Finally, Arachne's toolbox should be extended with support for aspect interactions (e.g., analyses and composition operators).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Typical usage of the TCP and UDP APIs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: An Aspect for Switching Transport Protocols, from TCP to UDP seq( call(void * malloc(size t))&amp;&amp; args(allocatedSize) &amp;&amp; return(buffer) ; write(buf f er) &amp;&amp; size(writtenSize)&amp;&amp; if(writtenSize &gt; allocatedSize) then reportOverflow (); * call(void free(void * )) )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Join point model case, join points are defined by JP in the grammar shown in Fig. 5. A join point is either:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Asp ::= AspP rim [ &amp;&amp; until( AspP rim ) ] | AspSeq [ &amp;&amp; until( AspP rim ) ] AspP rim ::= P P rim Advice AspSeq ::= seq( AspP rim AspSeqElts AspSeqElt ) AspSeqElts ::= [AspSeqElts] AspSeqElt [ * ] AspSeqElt ::= AspP rim | P Acc Advice | (AspSeqElt || AspSeqElt) Advice ::= [ then f unId( -----→ pattern) ] ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Aspect language</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :Figure 8 :</head><label>68</label><figDesc>Figure 6: Pointcut language</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Generic hook operations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>funIdn ] is a partial stack of function names, and c (either a function call or an access to a global variable) occurs within the control flow of function f unId n . Such a join point requires a call to f unId i+1 within the control flow of (i.e., not necessarily in the body of) f unIdi. Two features of this join point model may be surprising at first sight: distinction of accesses to aliases from those to global variables and explicit representation of control flow require N umber Of F d as int * ; require Squid M axF d as int * ; controlflow(call(void clientSendMoreData(void * , char * , size t)), call(HttpReply * clientBuildReply(clientHttpRequest * , char * , size t)) &amp;&amp; args( request, buf f er, buf f erSize )) then startPrefetching(request, buffer, bufferSize); &amp;&amp; until(writeGlobal(int * N umber Of F d) &amp;&amp; if(( * N umber Of F d) * 100/( * Squid M axF d) ≥ 75) ; )</figDesc><table><row><cell>controlflow( call(void clientSendMoreData(void * , char * , size t)),</cell></row><row><cell>call(void comm write mbuf(int, MemBuf, void * , void * ))</cell></row><row><cell>&amp;&amp; args(fd, mb, handler, handlerData) &amp;&amp; if(! isP ref etch(handler)) )</cell></row><row><cell>then parseHyperlinks(fd, mb, handler, handlerData);</cell></row><row><cell>call(void clientWriteComplete(int, char * , size t, int, void * ))</cell></row><row><cell>&amp;&amp; args(fd, buf, size, error, data) &amp;&amp; if(! isP ref etch(handler))</cell></row><row><cell>then retrieveHyperlinks(fd, buf, size, error, data);</cell></row><row><cell>Figure 4: An Aspect for Prefetching</cell></row><row><cell>expressions. Both are motivated by our quest for efficiency</cell></row><row><cell>and are grounded in strong implementation constraints in</cell></row><row><cell>the context of dynamic weaving of binary C code: an access</cell></row><row><cell>to a local alias is several magnitudes slower than that to a</cell></row><row><cell>global variable and matching of control flow join points can</cell></row><row><cell>be done using an atomic test on the implementation level.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The repetition operator * is translated into recursion on variable the a 2 . The branching operator || is translated into the choice operator µa 1 . callJP(fd socket(AF INET, SOCK STREAM, 0)) £ socket(AF INET, SOCK DGRAM, 0); a1 || ( callJP(a connect(fd, address, length)) £ returnZero(); µa2. callJP(b close(fd)) £ skip; STOP P callJP(c read(fd, readBuffer, readLength)) £ recvfrom(fd, readBuffer, readLength, 0, address, length); a 2 P callJP(d write(fd, writeBuffer, writeLength)) £ recvfrom(fd, writeBuffer, writeLength, 0, address, length); a 2</figDesc><table><row><cell>Figure</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Speed of each language construct used to interpret the base program compared to a native execution.</figDesc><table><row><cell></cell><cell cols="2">Execution times (cycles)</cell><cell></cell></row><row><cell></cell><cell>Arachne</cell><cell>Native</cell><cell>Ratio</cell></row><row><cell>call</cell><cell>28 ±2.3%</cell><cell>21 ±1.9%</cell><cell>1.3</cell></row><row><cell>seq</cell><cell>201 ±0.5%</cell><cell>63 ±1.7%</cell><cell>3.2</cell></row><row><cell>cflow</cell><cell>228 ±1.6%</cell><cell>42 ±1.8%</cell><cell>5.4</cell></row><row><cell cols="2">readGlobal 2762 ±4.3%</cell><cell>1 ±0.2%</cell><cell>2762</cell></row><row><cell>read</cell><cell>9729 ±4.9%</cell><cell>1 ±0.6%</cell><cell>9729</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>a global variable is replaced by an advice execution, the hooks generated by the rewriting strategy need to prepare the processor to call the advice function. This increases the time spent in the hooks. In addition, while an access to a global variable is often performed by a single x86 instruction, an empty function is often composed of four instructions. Hence the relative cost of an aspect triggered upon a global variable access and a direct, aspectless, access to a global variable is slightly higher than the corresponding ratio for functions. A seq of three invocations of empty functions is only 3.2 time slower than the direct, aspect-less, three successive functions calls. Compared to the pointcuts used to delimit the different stages, the seq overhead is limited to a few pointer exchanges between the linked lists holding the bound variable. On Intel x86, global variable accesses benefit from excellent hardware support. In the absence of aspects, a direct global variable read is usually carried out in a single unique cycle. To trigger the advice execution, the Arachne runtime has to save and restore the processor state to ensure the execution coherency, as advices are packaged as regular C functions (see also 4.2.1). It is therefore not surprising that a global variable readGlobal appears as being 2762 times slower than a direct, aspect-less global variable read. read performance can be accounted in the same way: in the absence of aspect, local variables are accessed in a single unique cycle. The signal mechanism used in the read requires that the operating system detects the base program attempt to read into a protected memory page before locating and triggering the signal handler set up by Arachne, as shown in 4.2.3. Such switches to and from kernel space remain slow. Using read to read a local variable is 9729 times slower than retrieving the local variable value directly, without aspects.</figDesc><table><row><cell>Ratio with a normal function call</cell><cell>10 20 30</cell><cell>28 Cycles</cell><cell>228 Cycles</cell><cell cols="3">Controlflow 327 Cycles 424 Cycles 522 Cycles</cell><cell>Ratio with 3 calls</cell><cell>10 5</cell><cell>200.6 Cycles</cell><cell>293.2 Cycles</cell><cell>380.8 Cycles</cell><cell>Sequence 466.3 Cycles 577 Cycles</cell><cell>1000 3000 Ratio 2000</cell></row><row><cell></cell><cell></cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell></cell><cell></cell><cell>1</cell><cell>2</cell><cell cols="2">3</cell><cell>4</cell><cell>5</cell></row><row><cell></cell><cell></cell><cell cols="5">Number of imbricated calls</cell><cell></cell><cell cols="5">Number of matching instances</cell></row><row><cell cols="13">Figure 11: controlflow, seq, and read performances</cell></row><row><cell cols="4">an access to</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>Performances comparison between manual modification and Arachne, for prefechting policy integration in Squid</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Residues (i.e. dynamic tests on the base program state) are required when these primitive pointcuts are combined with conditional pointcuts or when pattern matching is involved.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>About 250 x86 instruction mnemonics can directly manipulate a global variable. This corresponds to more than one thousand opcodes.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>In case the previous stage pointcut was used with a star * , Arachne examines nodes from linked list associated with the last two previous stages, and so on, until a not starred primitive aspect in the sequence is reached.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the automatic evolution of an os kernel using temporal logic and AOP</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Åberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Südholt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-F</forename><forename type="middle">L</forename><surname>Meur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Automated Software Engineering (ASE&apos;03)</title>
		<meeting>Automated Software Engineering (ASE&apos;03)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="196" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">ANSI/ISO/IEC 9899-1999: Programming Languages -C</title>
		<imprint>
			<biblScope unit="page">1430</biblScope>
		</imprint>
		<respStmt>
			<orgName>American National Standards Institute ; American National Standards Institute</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Process-algebraic foundations of aspect-oriented programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Andrews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Conference on Metalevel Architectures and Separation of Crosscutting Concerns</title>
		<meeting>the 3rd International Conference on Metalevel Architectures and Separation of Crosscutting Concerns</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2001-09">Sept. 2001</date>
			<biblScope unit="volume">2192</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A workload characterization study of the 1998 world cup web site</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arlitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="30" to="37" />
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Aspect weaving by graph rewriting</title>
		<author>
			<persName><forename type="first">U</forename><surname>Aßmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ludwig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Generative Component-based Software Engineering (GCSE)</title>
		<editor>
			<persName><forename type="first">U</forename><forename type="middle">W</forename><surname>Eisenecker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</editor>
		<meeting><address><addrLine>Erfurt</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-10">Oct. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Vulnerability note vu#613459</title>
		<ptr target="http://www.kb.cert.org/vuls/id/613459" />
		<imprint>
			<date type="published" when="2002-02">Feb. 2002</date>
		</imprint>
		<respStmt>
			<orgName>CERT -Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Catp: A context-aware transportation protocol for http</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mohapatra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on New Advances in Web Servers and Proxy Technologies Held with ICDCS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Josh: An open AspectJ-like language</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nakagawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the third international conference on Aspect-oriented software development</title>
		<meeting>the third international conference on Aspect-oriented software development</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004-03">Mar. 2004</date>
			<biblScope unit="page" from="102" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An interactive prefetching proxy server for improvement of WWW latency</title>
		<author>
			<persName><forename type="first">K.-I</forename><surname>Chinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yamaguchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seventh Annual Conference of the Internet Society (INET&apos;97)</title>
		<meeting><address><addrLine>Kuala Lumpur</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hybrid tcp-udp transport for web traffic</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cidon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schuba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th IEEE International Performance, Computing, and Communications Conference (IPCCC&apos;99)</title>
		<meeting>the 18th IEEE International Performance, Computing, and Communications Conference (IPCCC&apos;99)</meeting>
		<imprint>
			<date type="published" when="1990-02">Feb. 1990</date>
			<biblScope unit="page" from="177" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Injectso: Modifying and spying on running processes under linux</title>
		<author>
			<persName><forename type="first">S</forename><surname>Clowes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Black hat briefings</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Using AspectC to improve the modularity of Path-Specific customization in operating system code</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Coady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Feeley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smolyn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Joint 8th European Software Engeneering Conference and 9th ACM SIGSOFT Symposium on the Foundation of Software Engeneering (ESEC/FSE-01)</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Gruhn</surname></persName>
		</editor>
		<meeting>of the Joint 8th European Software Engeneering Conference and 9th ACM SIGSOFT Symposium on the Foundation of Software Engeneering (ESEC/FSE-01)<address><addrLine>New York, Sept</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="10" to="14" />
		</imprint>
	</monogr>
	<note>of SOFTWARE ENGINEERING NOTES</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Aspect-oriented logic meta programming</title>
		<author>
			<persName><forename type="first">K</forename><surname>Volder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Meta-Level Architectures and Reflection, 2nd International Conference on Reflection</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Cointe</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1616</biblScope>
			<biblScope unit="page" from="250" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A framework for the detection and resolution of aspect interactions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN/SIGSOFT Conference on Generative Programming and Component Engineering (GPCE&apos;02), volume 2487 of LLNCS</title>
		<meeting>the ACM SIGPLAN/SIGSOFT Conference on Generative Programming and Component Engineering (GPCE&apos;02), volume 2487 of LLNCS</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002-10">Oct. 2002</date>
			<biblScope unit="page" from="173" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A formal definition of crosscuts</title>
		<author>
			<persName><forename type="first">R</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Motelet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Conference on Metalevel Architectures and Separation of Crosscutting Concerns</title>
		<meeting>the 3rd International Conference on Metalevel Architectures and Separation of Crosscutting Concerns</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2001-09">Sept. 2001</date>
			<biblScope unit="volume">2192</biblScope>
			<biblScope unit="page" from="170" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Advice weaving in aspectj</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hilsdale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hugunin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd international conference on Aspect-oriented software development</title>
		<meeting>the 3rd international conference on Aspect-oriented software development</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="26" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">MDL: A language and compiler for dynamic program instrumentation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Hollingsworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J R</forename><surname>Goncalves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Naim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Parallel Architectures and Compilation Techniques (PACT)</title>
		<imprint>
			<date type="published" when="1997-11">Nov. 1997</date>
			<biblScope unit="page" from="201" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">IA-32 Intel Architecture Software Developer&apos;s Manual</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Intel Corportation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Quality of service and electronic newspaper: The Etel solution</title>
		<author>
			<persName><forename type="first">V</forename><surname>Issarny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Banâtre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Charpiot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Menaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1752</biblScope>
			<biblScope unit="page" from="472" to="496" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The clp( r ) language and system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michaylov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H C</forename><surname>Yap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="339" to="395" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<ptr target="http://ssel.vub.ac.be/jasco/" />
		<title level="m">JasCo home page</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Backwards-compatible bounds checking for arrays and pointers in c programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kelly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Workshop on Automatic Debugging</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Kamkar</surname></persName>
		</editor>
		<meeting>the Third International Workshop on Automatic Debugging</meeting>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="13" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Patch on Demand&quot; Saves Even More Time?</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="94" to="96" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menhdhekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Loingtier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Irwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings European Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Akşit</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</editor>
		<meeting>European Conference on Object-Oriented Programming<address><addrLine>Jyväskylä, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
			<biblScope unit="volume">1241</biblScope>
			<biblScope unit="page" from="220" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Expressiveness and complexity of crosscut languages</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Lieberherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Palm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sundaram</surname></persName>
		</author>
		<idno>NU-CCIS-04-10</idno>
		<imprint>
			<date type="published" when="2004-09">Sept. 2004</date>
		</imprint>
		<respStmt>
			<orgName>Northeastern University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Dataflow pointcut in aspect-oriented programming</title>
		<author>
			<persName><forename type="first">H</forename><surname>Masuhara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kawauchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First Asian Symposium on Programming Languages and Systems (APLAS&apos;03)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Dynamic probes and generalised kernel hooks interface for Linux</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Annual Linux Showcase and Conference</title>
		<meeting>the 4th Annual Linux Showcase and Conference<address><addrLine>Atlanta; Atlanta, Georgia, USA, Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2000">October 10-14, 2000. 2000</date>
		</imprint>
	</monogr>
	<note>USENIX</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Just-in-time aspects: efficient dynamic weaving for Java</title>
		<author>
			<persName><forename type="first">A</forename><surname>Popovici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd international conference on Aspect-oriented software development</title>
		<meeting>the 2nd international conference on Aspect-oriented software development<address><addrLine>Boston, Massachusetts</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003-03">Mar. 2003</date>
			<biblScope unit="page" from="100" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">DHTTP: An efficient and cache-friendly transfer protocol for web traffic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rabinovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="1597" to="1606" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">High-performance benchmarking with Web Polygraph</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rousskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wessels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="187" to="211" />
			<date type="published" when="2004-02">Feb. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A practical dynamic buffer overflow detector</title>
		<author>
			<persName><forename type="first">O</forename><surname>Ruwase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Annual Network and Distributed System Security Symposium</title>
		<meeting>the 11th Annual Network and Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2004-02">Feb. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Web cache prefetching as an aspect: Towards a dynamic-weaving based solution</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ségura-Devillechaise</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Menaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd international conference on Aspect-oriented software development</title>
		<meeting>the 2nd international conference on Aspect-oriented software development<address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003-03">Mar. 2003</date>
			<biblScope unit="page" from="110" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">AspectC++: an aspect-oriented extension to the C++ programming language</title>
		<author>
			<persName><forename type="first">O</forename><surname>Spinczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schroeder-Preikschat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fortieth International Conference on Tools Pacific</title>
		<meeting>the Fortieth International Conference on Tools Pacific</meeting>
		<imprint>
			<publisher>Australian Computer Society, Inc</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="53" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Vulcan: Binary transformation in a distributed environment</title>
		<author>
			<persName><forename type="first">A</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Edwards</surname></persName>
		</author>
		<idno>MSR-TR-2001-50</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Microsoft Research Tech. Rpt.</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">System Unix. System V Application Binary Interface Intel 386 Architecture Processor Supplement</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">S L</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Prentice Hall Trade</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Squid: The Definitive Guide. O&apos;Reilly and Associates</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wessels</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004-01">Jan. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A comparison of publicly available tools for dynamic buffer overflow prevention</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wilander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kamkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Network and Distributed System Security Symposium</title>
		<meeting>the 10th Network and Distributed System Security Symposium<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-02">February 2003</date>
			<biblScope unit="page" from="149" to="162" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
