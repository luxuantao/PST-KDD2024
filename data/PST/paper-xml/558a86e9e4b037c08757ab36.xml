<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Improved Decoding of Reed-Solomon and Algebraic-Geometry Codes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1999-10-23">October 23, 1999</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Venkatesan</forename><surname>Guruswami</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratory for Computer Science</orgName>
								<orgName type="institution">MIT</orgName>
								<address>
									<addrLine>545 Technology Square</addrLine>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratory for Computer Science</orgName>
								<orgName type="institution">MIT</orgName>
								<address>
									<addrLine>545 Technology Square</addrLine>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Improved Decoding of Reed-Solomon and Algebraic-Geometry Codes</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1999-10-23">October 23, 1999</date>
						</imprint>
					</monogr>
					<idno type="MD5">6E8F3B2DF16BAA28C56EDC273DEDCDE7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Error-correcting codes</term>
					<term>Reed-Solomon codes</term>
					<term>Algebraic-Geometry codes</term>
					<term>Decoding algorithms</term>
					<term>List decoding</term>
					<term>Polynomial time algorithms</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Given an error-correcting code over strings of length Ò and an arbitrary input string also of length Ò, the list decoding problem is that of finding all codewords within a specified Hamming distance from the input string. We present an improved list decoding algorithm for decoding Reed-Solomon codes. The list decoding problem for Reed-Solomon codes reduces to the following "curve-fitting" problem over a field : Given Ò points ´Ü Ý µ Ò ½ , Ü Ý ¾ , and a degree parameter and error parameter , find all univariate polynomials Ô of degree at most such that Ý Ô´Ü µ for all but at most values of ¾ ½ Ò . We give an algorithm that solves this problem for Ò Ô Ò, which improves over the previous best result [27], for every choice of and Ò. Of particular interest is the case of Ò ½ ¿ , where the result yields the first asymptotic improvement in four decades <ref type="bibr" target="#b20">[21]</ref>.</p><p>The algorithm generalizes to solve the list decoding problem for other algebraic codes, specifically alternant codes (a class of codes including BCH codes) and algebraic-geometry codes. In both cases, we obtain a list decoding algorithm that corrects up to Ò Ô Ò´Ò ¼ µ errors, where Ò is the block length and ¼ is the designed distance of the code. The improve- ment for the case of algebraic-geometry codes extends the methods of <ref type="bibr" target="#b23">[24]</ref> and improves upon their bound for every choice of Ò and ¼ . We also present some other consequences of our algorithm including a solution to a weighted curve fitting problem, which may be of use in soft-decision decoding algorithms for Reed-Solomon codes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>An error correcting code of block length AE, rate Ã, and distance over a Õ-ary alphabet ¦ ( AE Ã ℄ Õ code, for short) is a mapping from ¦ Ã (the message space) to ¦ AE (the codeword space) such that any pair of strings in the range of differ in at least locations out of AE ½ . We focus on linear codes so that the set of codewords form a linear subspace of ¦ AE . Reed-Solomon codes are a classical, and commonly used, construction of linear error-correcting codes that yield AE Ò Ã • ½ Ò ℄ Õ codes for any Ò Õ. The alphabet ¦ for such a code is a finite field . The message specifies a polynomial of degree at most over in some formal variable Ü (by giving its • ½ coefficients). The mapping maps this code to its evaluation at Ò distinct values of Ü chosen from (hence it needs Õ Ò). The distance property follows immediately from the fact that two degree polynomials can agree in at most places.</p><p>The decoding problem for an AE Ã ℄ Õ code is the problem of finding a codeword in ¦ AE that is within a distance of from a "received" word Ê ¾ ¦ AE . In particular it is interesting to study the error-rate ¯ AE that can be corrected as a function of the information rate Ã AE. For a family of Reed-Solomon codes of constant message rate and constant error rate, the two bruteforce approaches to the decoding problem (compare with all codewords, or look at all words in the vicinity of the received word) take time exponential in AE. It is therefore a non-trivial task to solve the decoding problem in polynomial time in AE. Surprisingly, a classical algorithm due to Peterson <ref type="bibr" target="#b20">[21]</ref> manages to solve this problem in polynomial time, as long as</p><formula xml:id="formula_0">AE Ã•½ ¾ (i.e. achieves</formula><p>¯ ´½ µ ¾). Faster algorithms, with running time Ç´AE ¾ µ or better, are also well-known: in particular the classical algorithms of Berlekamp and Massey (see <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b18">19]</ref> for a description) achieve such running time bounds. It is also easily seen that if</p><formula xml:id="formula_1">AE Ã•½ ¾</formula><p>then there may exist several different codewords within distance of a received word, and so the decoding algorithm cannot possibly always recover the "correct" message if it outputs only one solution.</p><p>This motivates the list decoding problem, first defined in <ref type="bibr" target="#b6">[7]</ref> (see also <ref type="bibr" target="#b7">[8]</ref>) and sometimes also termed the bounded-distance decoding problem, that asks, given a received word Ê ¾ ¦ AE , to reconstruct a list of all codewords within a distance from the received word. List decoding offers a potential for recovery from errors beyond the tradi tional "error-correction" bound (i.e., the quantity ¾) of a code. Loosely, we refer to a list decoding algorithm reconstructing all codewords within distance of a received word as an " error-correcting" algorithm. Again, for a family of AE Ò Ã</p><p>• ½ Ò ℄ Õ Reed-Solomon codes, we can study ¯ Ò as a function of</p><p>´ •½µ Ò Ò. Till recently, no significant benefits were achieved using the list decoding approach to recover from errors. The only improvements known over the algorithm of <ref type="bibr" target="#b20">[21]</ref> were decoding algorithms due to Sidelnikov <ref type="bibr" target="#b24">[25]</ref> and Dumer <ref type="bibr" target="#b5">[6]</ref> which correct Ò ¾ •¢´ÐÓ Òµ errors, i.e., achieve ¯ ´½ µ ¾•Ó´½µ. Recently, Sudan <ref type="bibr" target="#b26">[27]</ref>, building upon previous work of Ar et al. <ref type="bibr" target="#b0">[1]</ref>, presented a polynomial time list decoding algorithm for Reed-Solomon codes correcting more than ´Ò µ ¾ errors, provided Ò ¿. The exact description of the number of errors ¯ corrected by this algorithm is rather complicated and can be found in <ref type="bibr" target="#b27">[28]</ref> or Figure <ref type="figure" target="#fig_0">1</ref>. One lower bound on the number of errors corrected is Ò Ô ¾ Ò, thus achieving ¯ ¯ ½ Ô ¾ . A more efficient list decoding algorithm, running in time Ç´Ò ¾ ÐÓ ¾ Òµ, correcting the same number of errors has been given by Roth and Ruckenstein <ref type="bibr" target="#b22">[23]</ref>. For</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¼, this algorithm corrects an error</head><p>½ Usually an error correcting code is defined as a set of codewords, but for ease of exposition we describe it in terms of the underlying mapping, which also specifies the encoding method, rather than just the set of codewords. rate ¯ ½, thus allowing for nearly twice as many errors as the classical approach. For codes of rate greater than ½ ¿, however, this algorithm does not improve over the algorithm of <ref type="bibr" target="#b20">[21]</ref>. This case is of interest since applications in practice tend to use codes of high rates. In this paper we present a new polynomial-time algorithm for list-decoding of Reed-Solomon codes (in fact Generalized Reed-Solomon codes, to be defined in Section 2) that corrects up to (exactly) Ð Ò Ô Ò ½ Ñ errors (and thus achieves ¯ ½ Ô</p><p>). Thus our algorithm has a better error-correction rate than previous algorithms for every c hoice of ¾ ´¼ ½µ; and in particular, for ½ ¿ our result yields the first asymptotic improvement in the error-rate ¯, since the original algorithm of <ref type="bibr" target="#b20">[21]</ref>. (See Figure <ref type="figure" target="#fig_0">1</ref> for a graphical depiction of the relative error handled by our algorithm in comparison to previous ones.)</p><p>We solve the decoding problem by solving the following (more general) curve fitting problem:</p><p>Given Ò pairs of elements ´Ü½ Ý ½ µ ´ÜÒ Ý Ò µ where Ü Ý ¾ , a degree parameter and an error parameter , find all univariate polynomials Ô such that Ô´Ü µ Ý for at least Ò values of ¾ ½ Ò . Our algorithm solves this curve fitting problem for Ò Ô Ò .</p><p>Our algorithm is based on the algorithm of <ref type="bibr" target="#b26">[27]</ref> in that it uses properties of algebraic curves in the plane. The main modification is in the fact that we use the properties of "singularities" of these curves. As in the case of <ref type="bibr" target="#b26">[27]</ref> our algorithm uses the notion of plane curves to reduce our problem to a bivariate polynomial factorization problem over (actually only a root-finding problem for univariate polynomials over the rational function field ´ µ). This task can be solved deterministically over finite fields in time polynomial in the size of the field or probabilistically in time polynomial in the logarithm of the size of the field and can also be solved deterministically over the rationals and reals <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18]</ref>. Thus our algorithm ends up solving the curve-fitting problem over fairly general fields.</p><p>It is interesting to contrast our algorithm with results which show bounds on the number of codewords that may exist with a distance of from a received word. One such result, due to Goldreich et al. <ref type="bibr" target="#b12">[13]</ref>, shows that the number of solutions to the list decoding problem for a code with block length Ò and minimum distance , is bounded by a polynomial in Ò as long as Ò Õ Ò´Ò µ. (A similar result has also been shown by Radhakrishnan <ref type="bibr" target="#b21">[22]</ref>.) Our algorithm proves this best known combinatorial bound "constructively" in that it produces a list of all such codewords in polynomial time. More recently, Justesen <ref type="bibr" target="#b15">[16]</ref> has obtained upper bounds on the maximum number of errors Ò for which the output of a list decoding algorithm can be guaranteed to have at most solutions, for constant . The results of Justesen show that in the limit of large , Ò Ò converges to ½ Õ ½ Ò as we fix Ò and let Ò ½. These bounds are of interest in that they hint at a potential limitation to further improvements to the list decoding approach.</p><p>Finally we point out that the main focus of this paper is on getting polynomial time algorithms maximizing the number of errors that may be corrected, and not optimizing the runtime of any of our algorithms.</p><p>Extensions to Algebraic-Geometry Codes Algebraic-geometry codes are a class of algebraic codes that include the Reed-Solomon codes as a special case. These codes are of significant interest because they yield explicit construction of codes that beat the Gilbert-Varshamov bound over small alphabet sizes <ref type="bibr" target="#b28">[29]</ref> (i.e., achieve higher value of for infinitely many choices of Ò and than that given by the probabilistic method). Decoding algorithms for algebraic-geometry codes are typically based on decoding algorithms for Reed-Solomon codes. In particular, Shokrollahi and Wasserman <ref type="bibr" target="#b23">[24]</ref> generalize the algorithm of Sudan <ref type="bibr" target="#b26">[27]</ref> for the case of algebraic-geometry codes. Specifically, they provide algorithms for factoring polynomials over some algebraic function fields; and then show how to decode using this factoring algorithm. Using a similar approach, we extend our decoding algorithm to the case of algebraic-geometry codes and obtain a list decoding algorithm correcting an Ò ℄ Õ algebraic-geometry code for up to Ò Õ Ò´Ò µ errors, improving the previously known bound of Ò Õ ¾Ò´Ò µ • ½ errors (here is the genus of the algebraic curve underlying the code). This algorithm uses a root-finding algorithm for univariate polynomials over algebraic function fields as a subroutine and some additional algorithmic assumptions about the underlying algebraic structures: The assumptions are described precisely in Section 4.</p><p>Other extensions One aspect of interest with decoding algorithms is how they tackle a combination of erasures (i.e, some letters are explicitly lost in the transmission) and errors. Our algorithm generalizes naturally to this case. Another interesting extension of our algorithm is the solution to a weighted version of the curve-fitting problem ¾ : Given a set of Ò pairs ´Ü Ý µ and associated non-negative integer weights Û ½ Û Ò , find all polynomials Ô such that</p><formula xml:id="formula_2">È Ô´Ü µ Ý Û</formula><p>¾ The evolution of the solution to the "curve-fitting" problem is somewhat interesting. The initial solutions of Peterson <ref type="bibr" target="#b20">[21]</ref> did not explicitly solve the curve fitting problem at all. The solution provided by Welch and Berlekamp <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b2">3]</ref> do work in this setting, even though the expositions there do not mention the curve fitting problem (see in particular, Õ ¡ È Ò ½ Û ¾ . This generalization may be of interest in "soft-decision" decoding of Reed-Solomon codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Generalized Reed-Solomon Decoding</head><p>We fix some notation first. In what follows is a field and we will assume arithmetic over to be of unit cost. Ò℄ will denote the set ½ Ò . For a vector Ü ¾ Ò and ¾ Ò℄, the notation Ü will denote the th coordinate of Ü. ¡´ Ü Ýµ is the Hamming distance between strings Ü and Ý, i.e., Ü Ý . Definition 1 (Generalized Reed-Solomon codes) For parameters Ò and a field of cardinality Õ, a vector « of distinct elements « ½ « ¾ « Ò ¾ (hence we need Ò Õ), and a vector Ú of non-zero elements Ú ½ Ú Ò ¾ , the Generalized Reed-Solomon code ÊË Ò « Ú , is the function mapping the messages</p><formula xml:id="formula_3">•½ to code space Ò , given by ÊË Ò « Ú ´ Ñµ Ú ¡ È ¼ Ñ •½ ´« µ , for Ñ ¾ •½ and ½ Ò.</formula><p>Problem 1 (Generalized Reed-Solomon decoding)</p><p>INPUT: Field , Ò, , Ú ¾ Ò specifying the code ÊË Ò « Ú . A vector Ý ¾ Ò and error parameter .</p><p>OUTPUT: All messages Ñ ¾ •½ such that ¡´ ÊË Ò « Ú ´ Ñµ Ýµ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem 2 (Polynomial reconstruction)</head><p>INPUT: Integers Ø and Ò points ´Ü Ý µ Ò ½ where Ü Ý ¾ . OUTPUT: All univariate polynomials Ô of degree at most such that Ý Ô´Ü µ for at least Ø values of ¾ Ò℄.</p><p>The following proposition is easy to establish:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2 The generalized Reed-Solomon decoding problem reduces to the polynomial reconstruction problem.</head><p>Proof: It is easily verified that the instance ´ Ò « Ú Ý µ of the GRS decoding problem reduces to the instance ´ Ò Ò ´« Ý Ú µ Ò ½ µ of the polynomial reconstruction problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Informal description of the algorithm</head><p>Our algorithm is based on the algorithm of <ref type="bibr" target="#b26">[27]</ref>, and so we review that algorithm first. The algorithm has two phases: In the first phase it finds a polynomial É in two variables which "fits" the points ´Ü Ý µ, where fitting implies É´Ü Ý µ ¼ for all ¾ Ò℄. Then in the second phase it finds all small degree roots of É i.e finds all polynomials Ô of degree at most such that É´Ü Ô´Üµµ ¼ the description in <ref type="bibr" target="#b11">[12]</ref>). Their problem statement, however, disallows repeated values of Ü . Sudan's <ref type="bibr" target="#b26">[27]</ref> allows for repeated Ü 's but does not allow for repeated pairs of ´Ü Ý µ. Our solution generalizes this one more step by allowing a weighting of ´Ü Ý µ! or equivalently Ý Ô´Üµ is a factor of É´Ü Ýµ; and these polynomials Ô form candidates for the output. The main assertions are that (1) if we allow É to have a sufficiently large degree then the first phase will be successful in finding such a bivariate polynomial, and (2) if É and Ô have low degree in comparison to the number of points where Ý Ô´Ü µ É´Ü Ý µ ¼, then Ý Ô´Üµ will be a factor of É.</p><p>Our algorithm has a similar plan. We will find É of low weighted degree that "fits" the points.</p><p>But now we will expect more from the "fit". It will not suffice that É´Ü Ý µ is zero -we will require that every point ´Ü Ý µ is a "singularity" of É. Informally, a singularity is a point where the curve given by É´Ü Ýµ ¼ intersects itself. We will make this notion formal as we go along.</p><p>In our first phase the additional constraints will force us to raise the allowed degree of É. However we gain (much more) in the second phase. In this phase we look for roots of É and now we know that Ô passes through many singularities of É, rather than just points on É. In such a case we need only half as many singularities as regular points, and this is where our advantage comes from.</p><p>Pushing the idea further, we can force É to intersect itself at each point ´Ü Ý µ as many times as we want: in the algorithm described below, this will be a parameter Ö. There is no limit on what we can choose Ö to be: only our running time increases with Ö. We will choose Ö sufficiently large to handle as many errors as feasible. (In the weighted version of the curve fitting problem, we force the polynomial É to pass through different points a different number Ö times, where Ö is proportional to the weight of the point.) Finally, we come to the question of how to define "singularities". Traditionally, one uses the partial derivatives of É to define the notion of a singularity. This definition is, however, not good for us since the partial derivatives over fields with small characteristic are not well-behaved. So we avoid this direction and define a singularity as follows: We first shift our coordinate system so that the point ´Ü Ý µ is the origin. In the shifted world, we insist that all the monomials of É with a non-zero coefficient be of sufficiently high degree. This will turn out to be the correct notion. (The algorithm of <ref type="bibr" target="#b26">[27]</ref> can be viewed as a special case, where the coefficient of the constant term of the shifted polynomial is set to zero.)</p><p>We first define the shifting method precisely: For a polynomial É´Ü Ýµ and « ¬ ¾ we will say that the shifted polynomial É « ¬ ´Ü Ýµ is the polynomial given by É « ¬ ´Ü Ýµ É´Ü•« Ý•¬µ.</p><p>Observe that the following explicit relation between the coefficients Õ of É and the coefficients</p><formula xml:id="formula_4">´Õ« ¬ µ of É « ¬ holds: ´Õ« ¬ µ ¼ ¼ ¼ ¼ Õ ¼ ¼ « ¼ ¬ ¼</formula><p>In particular observe that the coefficients are obtained by a linear transformation of the original coefficients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Algorithm</head><p>Definition 3 (weighted degree) For non-negative weights Û ½ Û ¾ , the ´Û½ Û ¾ µ-weighted degree of the monomial Ü Ý is defined to be Û ½ • Û ¾ . For a bivariate polynomial É´Ü Ýµ, and nonnegative weights Û ½ Û ¾ , the ´Û½ Û ¾ µ-weighted degree of É, denoted ´Û½ Û ¾ µ-ÛØ-´Éµ, is the maximum over all monomials with non-zero coefficients in É of the ´Û½ Û ¾ µ-weighted degree of the monomial.</p><p>We now describe our algorithm for the polynomial reconstruction problem.</p><p>Algorithm Poly-Reconstruct:</p><formula xml:id="formula_5">Inputs: Ò Ø, ´Ü Ý µ Ò ½ , where Ü Ý ¾ .</formula><p>Step 0: Compute parameters Ö Ð such that</p><formula xml:id="formula_6">ÖØ Ð and Ò Ö • ½ ¾ Ð´Ð • ¾µ ¾ In particular, set Ö ½ • Ò • Õ ¾ Ò ¾ • ´Ø¾ Òµ ¾´Ø ¾ Òµ Ð ÖØ ½</formula><p>Step 1: Find a polynomial É´Ü Ýµ such that ´½ µ-ÛØ-´Éµ Ð, i.e., find values for its coefficients Õ ½ ¾ ½ ¾ ¼ ½ • ¾ Ð such that the following conditions hold:</p><formula xml:id="formula_7">1. At least one Õ ½ ¾ is non-zero 2. For every ¾ Ò℄, if É ´ µ is the shift of É to ´Ü Ý µ, then all coefficients of É ´ µ of total degree less than Ö are ¼. More specifically: ¾ Ò℄ ½ ¾ ¼ s.t. ½ • ¾ Ö Õ ´ µ ½ ¾ ¼ ½ ½ ¼ ¾ ¾ ¼ ½ ½ ¼ ¾ ¾ Õ ¼ ½ ¼ ¾ Ü ¼ ½ ½ Ý ¼ ¾ ¾ ¼</formula><p>Step 2: Find all polynomials Ô ¾ Õ ℄ of degree at most such that Ô is a root of É (i.e, Ý Ô´Üµ is a factor of É´Ü Ýµ). For each such polynomial Ô check if Ô´Ü µ Ý for at least Ø values of ¾ Ò℄, and if so, include Ô in output list.</p><p>End Poly-Reconstruct</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Correctness of the Algorithm</head><p>We now prove the correctness of our algorithm. In Lemmas 4 and 5, É can be any polynomial returned in Step 1 of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4</head><p>If ´Ü Ý µ is an input point and Ô is any polynomial such that Ý Ô´Ü µ, then ´Ü Ü µ Ö divides ´Üµ É´Ü Ô´Üµµ.</p><p>Proof: Let Ô ¼ ´Üµ be the polynomial given by Ô ¼ ´Üµ Ô´Ü •Ü µ Ý . Notice that Ô ¼ ´¼µ ¼. Hence Ô ¼ ´Üµ ÜÔ ¼¼ ´Üµ, for some polynomial Ô ¼¼ ´Üµ. Now, consider ¼ ´Üµ É ´ µ ´Ü Ô ¼ ´Üµµ. We first argue that ¼ ´Ü Ü µ ´Üµ. To see this, observe that</p><formula xml:id="formula_8">´Üµ É´Ü Ô´Üµµ É ´ µ ´Ü Ü Ô´Üµ Ý µ É ´ µ ´Ü Ü Ô ¼ ´Ü Ü µµ ¼ ´Ü Ü µ</formula><p>Now, by construction, É ´ µ has no coefficients of total degree less than Ö. Thus by substituting Ý ÜÔ ¼¼ ´Üµ for Ý, we are left with a polynomial ¼ such that Ü Ö divides ¼ ´Üµ. Shifting back we have ´Ü Ü µ Ö divides ¼ ´Ü Ü µ ´Üµ.</p><p>Lemma 5 If Ô´Üµ is a polynomial of degree at most such that Ý Ô´Ü µ for at least Ø values of ¾ Ò℄ and ÖØ Ð, then Ý Ô´Üµ divides É.</p><p>Proof: Consider the polynomial ´Üµ É´Ü Ô´Üµµ. By the definition of weighted degree, and the fact that the ´½ µ-weighted degree of É is at most Ð, we have that is a polynomial of degree at most Ð. By Lemma 4, for every such that Ý Ô´Ü µ, we know that ´Ü Ü µ Ö divides ´Üµ. Thus if Ë is the set of such that Ý Ô´Ü µ, then É ¾Ë ´Ü Ü µ Ö divides ´Üµ. (Notice in particular that Ü Ü for any pair ¾ Ë, since then we would have ´Ü Ý µ ´Ü Ô´Ü µµ ´Ü Ô´Ü µµ ´Ü Ý µ.) By the hypothesis Ë Ø, and hence we have a polynomial of degree at least ÖØ dividing which is a polynomial of degree at most Ð ÖØ. This can happen only if</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¼. Thus we find that</head><p>Ô´Üµ is a root of É´Ü Ýµ (where the latter is viewed as a polynomial in Ý with coefficients from the ring of polynomials in Ü). By the division algorithm, this implies that Ý Ô´Üµ divides É´Ü Ýµ.</p><p>All that needs to be shown now is that a polynomial É as sought for in Step 1 does exist. The lemma below shows this conditionally.</p><formula xml:id="formula_9">Lemma 6 If Ò Ö•½ ¾ Ð´Ð•¾µ ¾</formula><p>, then a polynomial É as sought in Step 1 does exist (and can be found in polynomial time by solving a linear system).</p><p>Proof: Notice that the computational task in Step 1 is that of solving a homogeneous linear system. A non-trivial solution exists as long as the rank of the system is strictly smaller than the number of unknowns. The rank of the system may be bounded from above by the number of constraints, which is Ò Ö•½ ¾ . The number of unknowns equals the number of monomials of ´½ µ-weighted degree at most Ð and this number equals</p><formula xml:id="formula_10">Ð ¾ ¼ Ð ¾ ½ ¼ ½ Ð ¾ ¼ ´Ð • ½ ¾ µ ´Ð • ½µ °Ð ± • ½ ¾ °Ð ± °Ð ± • ½ °Ð ± • ½ Ð • ½ Ð ¾ Ð ¡ Ð • ¾ ¾</formula><p>and the result follows. Proof: Since Ð ÖØ ½ in our algorithm, ÖØ Ð certainly holds. Using Ð ÖØ ½, we now need to satisfy the constraint</p><formula xml:id="formula_11">Ò Ö • ½ ¾ ´ÖØ ½µ´ÖØ • ½µ ¾ which simplifies to Ö ¾ Ø ¾ ½ Ò´Ö ¾ • Öµ or, equivalently, Ö ¾ ´Ø¾ Òµ ÒÖ ½ ¼</formula><p>Hence it suffices to pick Ö to be an integer greater than the larger root of the above quadratic, and therefore picking We can also infer an upper bound on the number of codewords within radius Ò Ô Ò in a Generalized Reed-Solomon code. This bound is already known even for general (even non-linear codes) <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b21">22]</ref>. Our result can be viewed as a constructive proof of this bound for the specific case of Generalized Reed-Solomon codes.</p><formula xml:id="formula_12">Ö ½ • Ò • Õ ¾ Ò ¾ • ´Ø¾ Òµ ¾´Ø ¾ Òµ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 9 The number of codewords that lie within an Hamming ball of radius</head><formula xml:id="formula_13">Ò Ô Ò in an Ò • ½ ℄ Õ Generalized Reed-Solomon code is Ç´Ô Ò ¿ µ (which is in turn Ç´Ò ¾ µ).</formula><p>Proof: By Lemma 5, the number Å of such codewords is at most the degree Ý ´Éµ of the bivariate polynomial É in Ý. Since the ´½ µ-weighted degree of É is at most Ð, Ý ´Éµ Ð .</p><p>Choosing Ø Ô Ò • ½ (which corresponds to the largest permissible value of the radius ), we have, by the choice of Ð, that Å Ç´Ð µ Ç´ ÒØ µ Ç´Ô Ò ¿ µ as desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 10 For a family of constant (relative) rate Generalized Reed-Solomon codes, the number of codewords in a Hamming ball of (relative) radius</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>½ ´½ • µ Ô</head><p>, for any constant ¼, is Ç´½ ¾ µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Runtime of the Algorithm</head><p>We now verify that the algorithm above can be implemented to run efficiently (in polynomial in Ò time) and also provide rough (but explicit) upper bounds on the number of operations it performs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 11</head><p>The algorithm above can be implemented to run using Ç´Ñ Ü ¿ Ò Ø ´Ø¾ Òµ Ø ¿ µ field operations over , provided ¾ Ò . ¿</p><p>Proof: (Sketch) The homogeneous system of equations solved in Step 1 of the algorithm clearly has at most Ç´Ð ¾ µ unknowns (since Ý ´Éµ Ð and Ü ´Éµ Ð). Hence using standard methods, Step 1 can be implemented using Ç´´Ð ¾ µ ¿ µ Ç´Ð ¿ µ field operations. We claim that this is the dominant portion of the runtime and that Step 2 can be implemented to run within this time using standard bivariate polynomial factorization techniques. We sketch some details on the implementation of Step 2 below.</p><p>To implement Step 2, we first compute the discriminant Ì ´Üµ × Ý ´É´Ü Ýµµ of É´Ü Ýµ with respect to Ý (treating it as a polynomial in Ý with coefficients in ℄). Therefore Ì ¾ ℄, and also ´Ìµ ¾ Ü Ý where Ü , Ý are the degrees of É in Ü and Ý respectively. This bound on the degree of Ì follows easily from the definition of the discriminant (see for instance <ref type="bibr" target="#b4">[5]</ref>), and it is also easy to prove that the discriminant Ì can be computed in Ç´ Ü Ý µ field operations.</p><p>Next we find an « ¾ such that Ì ´«µ ¼. This can be done deterministically by trying out an arbitrary set of ´¾ Ü Ý • ½µ field elements because of the bound we know on the degree of Ì . Now, by the definition of the discriminant, for such an «, É´« Ýµ is square-free as an element of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>℄.</head><p>We then compute the shifted polynomial É ¼ ´Ü Ýµ É´Ü •« Ýµ, so that É ¼ ´¼ Ýµ is square-free. Now we use the algorithm in <ref type="bibr" target="#b10">[11]</ref> that can compute all roots Ô ¾ Ü℄ of a bivariate polynomial Ê´Ü Ýµ such that Ê´¼ Ýµ ¾ ℄ is square-free, in Ç´ ¾ Ý ¾ ´Êµµ time. This gives us a list of all polynomials Ô ¼ ´Üµ such that Ý Ô ¼ ´Üµ divides É ¼ ´Ü Ýµ; by computing Ô´Üµ Ô ¼ ´Ü «µ for each such Ô ¼ gives us the desired list of roots Ô´Üµ of É´Ü Ýµ. It is clear that once « is computed, all the above steps can be performed in at most Ç´ ¾ ¾ Ý µ field operations.</p><p>Summing up, Step 2 can be performed using</p><formula xml:id="formula_14">Ç´ Ü Ý • Ü Ý • ¾ ¾ Ý µ Ç Ð • Ð ¾ Ç Ð ¿ field operations.</formula><p>The entire algorithm can thus be implemented to run in Ç´Ð ¿ µ field operations and since</p><formula xml:id="formula_15">Ð Ç´Ñ Ü ÒØ Ø ¾ Ò Ø µ</formula><p>the claimed bound on the runtime follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 12</head><p>The polynomial reconstruction problem can be solved in time Ç´Ò ½ µ, provided Ø Ô Ò, for any field of cardinality at most ¾ Ò . Furthermore, if Ø ¾ ´½ • AEµ Ò, then the problem can be solved in time Ç´Ò ¿ AE µ.</p><p>¿ In this analysis as well as the rest of the paper, we use the big-Oh notation to hide constants. We stress that these are universal constants and not functions of the field size .</p><p>Proof: Follows from Proposition 11 and Theorem 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 13 Given a family of Generalized Reed-Solomon codes of constant message rate , an</head><p>error-rate of ¯ ½ Ô can be list-decoded in time Ç´Ò ½ µ. When ¯ ½ Ô</p><p>, then the decoding time reduces to Ç´Ò ¿ ´½ ¯ Ô µ ½¾ µ Ç´Ò ¿ µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Some Consequences</head><p>First of all, since the classical Reed-Solomon codes are simply a special case of Generalized Reed-Solomon codes, Corollary 13 above holds for Reed-Solomon codes as well. We now describe some other easy consequences and extensions of the algorithm of Section 2. The first three results are just applications of the curve-fitting algorithm. The fourth result revisits the curve-fitting algorithm to get a solution to a weighted curve-fitting problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Alternant codes</head><p>We first describe a family of codes called alternant codes that includes a wide family of codes such as BCH codes, Goppa codes etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 14 (Alternant Codes ([19], Ü12.2))</head><p>For positive integers Ñ ¼ Ò, prime power Õ, the field ´ÕÑ µ, a vector « of distinct elements « ½ « Ò ¾ ´ÕÑ µ, and a vector Ú of nonzero elements Ú ½ Ú Ò ¾ ´ÕÑ µ, the alternant code Õ Ò ¼ « Ú comprises of all the codewords of the Generalized Reed-Solomon code defined by ÊË Ò ¼ « Ú that lie in ´Õµ Ò .</p><p>Since the Generalized Reed-Solomon code has distance exactly Ò ¼ • ½, it follows that the respective alternant code, being a subcode of the Generalized Reed-Solomon code, has distance at least Ò ¼ • ½. We term this the designed distance ¼ Ò ¼ • ½ of the alternant code.</p><p>The actual rate and distance of the code are harder to determine. The rate lies somewhere between Ò Ñ´Ò ¼ µ and ¼ and thus the distance lies between ¼ and Ñ ¼ . Playing with the vector Ú might alter the rate and the distance (which is presumably why it is used as a parameter). The decoding algorithm of the previous section can be used to decode alternant codes as well.</p><p>Given a received word ´Ö½ Ö Ò µ ¾ ´Õµ Ò , we use as input to the polynomial reconstruction problem the pairs ´Ü Ý µ Ò ½ , where Ü « and Ý Ö Ú are elements of ´ÕÑ µ. The list of polynomials output includes all possible codewords from the alternant code. Thus the decoding algorithm for the earlier section is really a decoding algorithm for alternant codes as well; with the caveat that its performance can only be compared with the designed distance, rather than the actual distance. The following theorem summarizes the scope of the decoding algorithm. (We note that decoding algorithms for alternant codes given in classical texts seem to correct ¼ ¾ errors. For the more restricted BCH codes, there are algorit hms that decode beyond half the designed distance (cf. <ref type="bibr" target="#b8">[9]</ref> and also <ref type="bibr" target="#b3">[4,</ref><ref type="bibr">Chapter 9]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Errors and Erasures decoding</head><p>The algorithm of Section 2 is also capable of dealing with other notions of corruption of information. A much weaker notion of corruption (than an "error") in data transmission is that of an "erasure": Here a transmitted symbol is either simply "lost" or received in obviously corrupted shape. We now note that the decoding algorithm of Section 2 handles the case of errors and erasure naturally. Suppose Ò symbols were transmitted and Ò ¼ Ò were received and × symbols got erased. (We stress that the problem definition specifies that the receiver knows which symbols are erased.) The problem just reduces to a polynomial reconstruction problem on Ò ¼ points. An application of Theorem 12 yields that errors can be corrected provided </p><formula xml:id="formula_16">Ò ¼ Ô Ò ¼ .</formula><formula xml:id="formula_17">Ò ´× • µ Ò × • ¾ while our result requires that Ò ´× • µ Õ ´Ò ×µ</formula><p>By the AM-GM inequality it is clear that the second one holds whenever the first holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Decoding with uncertain receptions</head><p>Consider the situation when, instead of receiving a single word Ý Ý ½ Ý ¾ Ý Ò , for each ¾ Ò℄ we receive a list of Ð possibilities Ý ½ Ý ¾ Ý Ð such that one of them is correct (but we do not know which one). Once again, as in normal list decoding, we wish to find out all possible codewords which could have been possibly transmitted, except that now the guarantee given to us is not in terms of the number of errors possible, but in terms of the maximum number of uncertain possibilities at each position of the received word. Let us call this problem decoding from uncertain receptions. Applying Theorem 12 (in particular by applying the theorem on point sets where the Ü 's are not distinct) we get the following result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 17</head><p>List decoding from uncertain receptions on a Ò • ½ Ò ℄ Õ Reed-Solomon code can be done in polynomial time provided the number of "uncertain possibilities" Ð at each position ¾ Ò℄ is (strictly) less than Ò .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Weighted curve fitting</head><p>Another natural extension of the algorithm of Section 2 is to the case of weighted curve fitting. This case is somewhat motivated by a decoding problem called the soft-decision decoding problem (see <ref type="bibr" target="#b30">[31]</ref> for a formal description), as one might use the reliability information on the individual symbols in the received word more flexibly by encoding them appropriately as the weights below instead of declaring erasures. At this point we do not have any explicit connection between the two. Instead we just state the weighted curve fitting problem and describe our solution to this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem 3 (Weighted polynomial reconstruction)</head><p>INPUT: Ò points ´Ü½ Ý ½ µ ´ÜÒ Ý Ò µ , Ò non-negative integer weights Û ½ Û Ò , and parameters and Ø.</p><p>OUTPUT: All polynomials Ô such that È Ô´Ü µ Ý Û is at least Ø. The algorithm of Section 2 can be modified as follows: In Step 1, we could find a polynomial É which has a singularity of order Û at the point ´Ü Ý µ. Thus we would now have È Ò ½ Û •½ ¾ constraints. If a polynomial Ô passes through the points ´Ü Ý µ for ¾ Ë, then Ý Ô´Üµ will appear as a factor of É´Ü Ýµ provided È ¾Ë Û is greater than ´½ µ-ÛØ-´Éµ. Optimizing over the weighted degree of É yields the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 18</head><p>The weighted polynomial reconstruction problem can be solved in time polynomial</p><formula xml:id="formula_18">in the sum of Û 's provided Ø Õ È Ò ½ Û ¾ .</formula><p>Remark: The fact that the algorithm runs in time pseudo-polynomial in Û 's should not be a serious problem. Given any vector of real weights, one can truncate and scale the Û 's without too much loss in the value of Ø for which the problem can be solved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algebraic-Geometry Codes</head><p>We now describe the extension of our algorithm to the case of algebraic-geometry codes. Our extension follows along the lines of the algorithm of Shokrollahi and Wasserman <ref type="bibr" target="#b23">[24]</ref>. Our extension shows that the algebra of the previous section extends to the case of algebraic function fields, yielding an approach to the list decoding problem for algebraic-geometry codes. In particular it reduces the decoding problem to some basis computations in an algebraic function field and to a factorization (actually root-finding) problem over the algebraic function field. However neither of these tasks is known to be solvable efficiently given only the generator matrix of the linear code. It is conceivable however that given some polynomial amount of additional information about the linear code, one can solve both parts efficiently. In fact for the former task we show that this is indeed the case; for the latter part we are not aware of any such results. For certain representations of some function fields, Shokrollahi and Wasserman <ref type="bibr" target="#b23">[24]</ref> give factorization algorithms that run in time polynomial in the representation of the field. It is not however still clear if these representations are of size that is bounded by some polynomial in the block length of the code. Thus the results of this section are best viewed as reductions of the list-decoding problem to a factorization problem over algebraic function fields.</p><p>Much of the work of this section is in ferreting out the axioms satisfied by these constructions, so as to justify our steps. We do so in Section 4.1. Then we present our algorithm for list decoding modulo some algorithmic assumptions about the underlying structures. Under these assumptions, our algorithm yields an algorithm for list decoding which corrects up to Ò Õ Ò´Ò µ errors in an Ò ℄ Õ code, improving over the result of <ref type="bibr" target="#b23">[24]</ref>, which corrects up to Ò Õ ¾Ò´Ò µ • ½ errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definitions</head><p>An algebraic-geometry code is built over a structure termed an algebraic function field. Definitions and basic properties of these codes can be found in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b25">26]</ref>; for purposes of self-containment and ease of exposition, we now develop a slightly different notation to express our results. An algebraic function field is described by a six-tuple</p><p>´ Õ Ã ÓÖ µ, where:</p><p>Õ is a finite field with Õ elements, with Õ denoting its algebraic closure.</p><p>is a set of points (typically some subset of (variety in) Õ Ð , but this will be irrelevant to us).</p><p>is a subset of , called the rational points of .</p><p>Ã is a set of functions from to Õ ½ (where ½ is a special symbol representing an undefined value). It is usually customary to refer to just Ã as the function field (and letting the other components of be implicit).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ÓÖ Ã ¢</head><p>. ÓÖ ´ Üµ is called the order of the function at point Ü.</p><p>is a non-negative integer called the genus of . The components of always satisfy the following properties:</p><p>1. Ã is a field extension of Õ : Ã is endowed with operations • and £ giving it a field structure. Furthermore, for ¾ Ã, the functions • and £ satisfy ´Üµ • ´Üµ ´ • µ´Üµ and ´ £ µ´Üµ ´Üµ £ ´Üµ, provided ´Üµ and ´Üµ are defined. Finally, corresponding to every « ¾ Õ , there exists a function « ¾ Ã s.t. «´Üµ « for every ¾ . (In what follows we let « denote the function « £ .)</p><p>2. Rational points: For every ¾ Ã and Ü ¾ , ´Üµ ¾ Õ ½ .</p><p>3. Order properties: (The order is a common generalization of the degree of a function as well as its zeroes. Informally, the quantity È Ü¾ ÓÖ ´ Üµ ¼ ÓÖ ´ Üµ is analogous to the degree of a function. If ÓÖ ´ Üµ ¼, then the negative of ÓÖ ´ Üµ is the number of zeroes has at the point Ü. The following axioms may make a lot of sense when this is kept in mind.) For every ¾ Ã ¼ , « ¬ ¾ Õ , Ü ¾ : the order function ÓÖ satisfies:  ÓÖ ´ Üµ form a vector space over Õ , for any Ü ¾ and ¾ . Of particular interest will be functions which may have positive order at only one point Ü ¼ ¾ and nowhere else.</p><formula xml:id="formula_19">(a) ´Üµ ¼ ´µ ÓÖ ´ Üµ ¼; ´Üµ ½ ´µ ÓÖ ´ Üµ ¼. (b) ÓÖ ´ £ Üµ ÓÖ ´ Üµ • ÓÖ ´ Üµ. (c) ÓÖ ´« • ¬ Üµ Ñ Ü ÓÖ ´ Üµ ÓÖ ´ Üµ</formula><p>Let Ä Ü denote the set</p><formula xml:id="formula_20">¾ Ã ÓÖ ´ Üµ ÓÖ ´ Ýµ ¼ Ý ¾ Ü . Since Ä Ü</formula><p>Ü ´ Ý¾ Ü ¼ Ý µ, we have that Ä is also a vector space over Õ . The rate prop- erty is that for every ¾ , Ü ¾ , Ä Ü is a vector space of dimension at least</p><p>• ½.</p><p>(This property is obtained from the famed Riemann-Roch theorem for the actual realizations of , and in fact the dimension is exactly</p><formula xml:id="formula_21">• ½ if ¾ ¾.)</formula><p>The following lemma shows how to construct a code from an algebraic function field, given Ò • ½ rational points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 19 If there exists an algebraic function field</head><p>´ Õ Ã ÓÖ µ with Ò•½ distinct rational points Ü ¼ Ü ½ Ü Ò , then the linear space</p><p>´ ´Ü½ µ ´ÜÒ µµ ¾ Ä • ½ Ü ¼ form an Ò ¼ ¼ ℄ Õ code for some ¼ and ¼ Ò</p><p>• ½.  <ref type="figure">ÓÖ</ref> ´ ½ ¾ Ü µ ¼. Furthermore, we have that for every Ü ¾ Ü ¼ , ÓÖ ´ ½ ¾ Üµ ¼. Finally at Ü ¼ we have ÓÖ ´ ½ ¾ Ü ¼ µ</p><p>• ½. Thus summing over all Ü ¾ , we have È Ü¾ ÓÖ ´ ½ ¾ Üµ ¼ and thus ½ ¾ ¼ using Property 4 above. This yields the distance property as required.</p><p>Codes constructed as above and achieving Ò Ò ¼ (in the limit of large Ò) are known for constant alphabet size Õ. In fact, such codes achieving bounds better than those known by probabilistic constructions are known for Õ <ref type="bibr" target="#b28">[29]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Decoding Algorithm</head><p>We now describe the extension of our algorithm to the case of algebraic-geometry codes. As usual we will try to describe the data points ´Ü Ý µ by some polynomial É. We follow <ref type="bibr" target="#b23">[24]</ref> and let É be a polynomial in a formal variable Ý with coefficients from Ã (i.e., É Ý℄ ¾ Ã Ý℄). Now given a value of Ý ¾ Õ , É Ý ℄ will yield an element of Ã. By definition such an element of Ã has a value at Ü ¾ and just as in <ref type="bibr" target="#b23">[24]</ref> we will also require É´Ü Ý µ É Ý ℄´Ü µ to evaluate to zero. We, however, will require more and insist that ´Ü Ý µ "behave" like a zero of multiplicity Ö of É;</p><p>since Ü ¾ and Ý ¾ Õ , we need to be careful in specifying the conditions to achieve this. We, as in <ref type="bibr" target="#b23">[24]</ref>, also insist that É has a small (but positive) order Ð at Ü ¼ for any substitution of Ý with a function in Ã of order at most « • ½ at the point Ü ¼ . Having found such a É, we then look for roots ¾ Ã of É. What remains to be done is to explicitly express the conditions (i) ´Ü Ý µ behaves like a zero of order Ö of É for ½ Ò, and (ii) ÓÖ ´É ℄ Ü ¼ µ Ð for any ¾ Ä « Ü ¼ , where Ð is a parameter that will be set later (and which will play the same role as the Ð in our decoding algorithm for Reed-Solomon codes). To do so, we assume that we are explicitly given functions</p><formula xml:id="formula_22">½ Ð •½ such that ÓÖ ´ Ü ¼ µ • ½ and such that ÓÖ ´ Ü ¼ µ ÓÖ ´ •½ Ü ¼ µ. Let × Ð « . We will then look for coefficients Õ ½ ¾ such that É Ý℄ × ¾ ¼ Ð •½ « ¾ ½ ½ Õ ½ ¾ ½ Ý ¾<label>(1)</label></formula><p>By explicitly setting up É as above, we impose the constraint (ii) above. To get constraint (i) we need to "shift" our basis. This is done exactly as before with respect to Ý , however, Ü ¾ and hence a different method is required to handle it. The following lemmas show how this may be achieved.</p><p>Lemma 20 For every</p><formula xml:id="formula_23">¾ Ã and Ü ¾ with ÓÖ ´ Üµ ÓÖ ´ Üµ, there exist « ¼ ¬ ¼ ¾ Õ Ò ¼ , such that ÓÖ ´«¼ • ¬ ¼ Üµ Ñ Ü ÓÖ ´ Üµ ÓÖ ´ Üµ Proof: Let ÓÖ ´ Üµ ÓÖ</formula><p>´ Üµ and ½ be the multiplicative inverse of in Ã. Then ÓÖ ´ £ ½ Üµ ¼ and hence ÓÖ ´ ½ Üµ and finally ÓÖ ´ £ ½ Üµ ¼. Let ´ £ ½ µ´Üµ « and ´ £ ½ µ´Üµ ¬. By Property 3a, « ¬ ¾ ¼ ½ , and since Ü is a rational point, « ¬ ¾ Õ . Thus we find that ´¬ £ ½ « £ ½ µ´Üµ ¼. Thus ÓÖ ´¬ £ ½ « £ ½ Üµ ¼ and so ÓÖ ´¬ « Üµ as required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 21 Given functions</head><formula xml:id="formula_24">½ Ô of distinct orders at Ü ¼ ¾ satisfying ¾ Ä • ½ Ü ¼ and a rational point Ü Ü ¼ , there exist functions ½ Ô ¾ Ã with ÓÖ ´ Ü µ ½ and such that there exist « Ü ½ ¿ ¾ Õ for ½ ½ ¿ Ô such that ½ È Ô ¿ ½ « Ü ½ ¿ ¿ .</formula><p>Proof: We prove a stronger statement by induction on Ô: If ½ Ô are linearly independent (over Õ ) functions such that ÓÖ ´ Ü µ Ñ for ¾ Ô℄, then there are functions ½ Ô such that ÓÖ ´ Ü µ Ñ • ½ that generate the 's over Õ . Note that this will imply our lemma as ½ ¾ Ô are linearly independent using Property 3(c) and the fact that the 's have distinct pole orders at Ü ¼ . W.l.o.g. assume that ½ is a function with largest order at Ü , by assumption ÓÖ ´ ½ Ü µ Ñ. We let ½ ½ . Now, for ¾ We are now ready to express condition (i) on ´Ü Ý µ being a zero of order at least Ö. Using the above lemma and (1), we know that É´Ü Ýµ has the form</p><formula xml:id="formula_25">Ô, set ¼ if ÓÖ ´ Ü µ ÓÖ ´ ½ Ü µ. If ÓÖ ´ Ü µ ÓÖ ´ ½ Ü µ, using Lemma 20 to the pair ´ ½ µ of functions, we get « ¬ ¾ Õ ¼ such that the function ¼ « ½ • ¬ satisfies ÓÖ ´ ¼ Ü µ ÓÖ ´ ½ Ü µ Ñ. Since in this case ¬ ½ ¼ « ¬ ½ ½ ,</formula><formula xml:id="formula_26">É´Ü Ýµ × ¾ ¼ Ð •½ ¿ ½ Ð •½ ¾ « ½ ½ Õ ½ ¾ « Ü ½ ¿ ¿ Ü ´ÜµÝ ¾</formula><p>The shifting to Ý is achieved by defining É ´ µ ´Ü Ýµ É´Ü Ý • Ý µ. The terms in É ´ µ ´Ü Ýµ that are divisible by Ý Ô contribute Ô towards the multiplicity of ´Ü ¼µ as a zero of É ´ µ , or, equivalently, the multiplicity of ´Ü Ý µ as a zero of É. We have</p><formula xml:id="formula_27">É ´ µ ´Ü Ýµ × ¼ Ð •½ ¿ ½ Õ ´ µ ¿ ¿ Ü ´ÜµÝ<label>(2)</label></formula><p>where</p><formula xml:id="formula_28">Õ ´ µ ¿ × ¾ Ð •½ « ¾ ½ ½ ¾ Ý ¾ ¡ Õ ½ ¾ « Ü ½ ¿</formula><p>Since ÓÖ ´ ¿ Ü Ü µ ´ ¿ ½µ, we can achieve our condition on ´Ü Ý µ being a zero of multiplicity at least Ö by insisting that Õ ´ µ ¿ ¼ for all ¿ ½, ¼ such that • ¿ ½ Ö.</p><p>Having developed the necessary machinery, we now proceed directly to the formal specification of our algorithm.</p><p>Implicit Parameters: Ò; Ü ¼ Ü ½ Ü Ò ¾ ; ; .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Assumptions:</head><p>We assume that we "know" functions ½ ¾ Ã ½ ¾ Ð •½℄ of distinct orders at Ü ¼ with ÓÖ ´ ½ Ü ¼ µ ½ • ½, as well as functions ¿ Ü ¾ Ã ¿ ¾ Ð •½℄ ¾ Ò℄ such that for any ¾ Ò℄, the functions ¿ Ü ¿ satisfy ÓÖ ´ ¿ Ü Ü µ ½ ¿ . The notion of "knowledge" is explicit in the following two objects that we assume are available to our algorithm.</p><p>1. The set « Ü ½ ¿ ¾ Õ ¾ Ò℄ ½ ¿ ¾ Ð • ½℄ such that for every ½ , ½ È ¿ « Ü ½ ¿ ¿ Ü . This assumption is a very reasonable one since Lemma 21 essen- tially describes an algorithm to compute this set given the ability to perform arithmetic in the function field Ã. 2. A polynomial-time algorithm to find roots (in Ã) of polynomials in Ã Ý℄ where the coefficients (elements of Ã) are specified as a formal sum of ½ 's. (The cases for which such algorithms are known are described in <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b10">11]</ref>.)</p><p>The Algorithm:</p><formula xml:id="formula_29">Inputs: Ò, , Ý ½ Ý Ò ¾ Õ .</formula><p>Step 0: Computer parameters Ö Ð such that </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Concluding Remarks</head><p>We have given a polynomial time algorithm to decode up to ½ Ô errors for a rate Reed-Solomon code and generalized the algorithm for the broader class of Algebraic-Geometry codes. Our algorithm is able to correct a number of errors exceeding half the minimum distance for any rate.</p><p>A natural question not addressed in our work is more efficient implementation of these decoding algorithms. Subsequent work in <ref type="bibr" target="#b22">[23]</ref> addresses this issue for Reed-Solomon codes, and <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b19">20]</ref> addresses this issue for both Reed-Solomon codes and Algebraic-Geometry codes.</p><p>The list decoding problem remains an interesting question and it is not clear what the true limit is on the number of efficiently correctable errors. Deriving better upper or lower on the number of correctable errors remains a challenging and interesting pursuit.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Error-correcting capacity plotted against the rate of the code for known algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 7</head><label>7</label><figDesc>If Ò Ø satisfy Ø ¾ Ò, then for the choice of Ö Ð made in our algorithm, Ò Ö•½ ¾ Ð´Ð•¾µ ¾ and ÖØ Ð both hold.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 8</head><label>8</label><figDesc>suffices, and this is exactly the choice made in the algorithm. Algorithm Poly-Reconstruct on inputs Ò Ø and the points ´Ü Ý µ ½ Ò , correctly solves the polynomial reconstruction problem provided Ø Ô Ò.Proof: Follows from Lemmas 5, 6 and 7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 15</head><label>15</label><figDesc>Let be an Ò •½ ℄ Õ alternant code with designed distance ¼ (and thus satisfying Ñ ¼ ). Then there exists a polynomial time list decoding algorithm for decoding up to Ò Õ Ò´Ò ¼ µ errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>4 .) 5 .</head><label>45</label><figDesc>Distance property: If È Ü¾ ÓÖ ´ µ ¼, then ¼. (This property is just the generalization of the well-known theorem showing that a degree polynomial may have at most zeroes.Rate property: Observe that, by Property 3(c) above, the set of functions Ü</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Ô</head><label></label><figDesc>are linearly independent (since ½ ¾ Ô are) and ÓÖ ´ ¼ Ü µ Ñ ½ for ¾ Ô, so the inductive hypothesis applied to the functions ¼ ¾ ¼ Ô now yields ¾ Ô as required.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>( 22 Theorem 27</head><label>2227</label><figDesc>Recall that « • ½.) In particular set Ö ½• ¾ Ø•«Ò• Õ ´¾ Ø•«Òµ ¾ ´ ¾ ½µ´Ø ¾ «Òµ ¾´Ø ¾ «Òµ Ð ÖØ ½If Ø ¾ «Ò ¼, it suffices to pick Ö to be an integer greater than the larger root of the above quadratic, and therefore pickingÖ ½• ¾ Ø•«Ò• Õ ´¾ Ø•«Òµ ¾ ´ ¾ ½µ´Ø ¾ «Òµ ¾´Ø ¾ «Òµsuffices, and this is exactly the choice made in the algorithm. Our main theorem now follows from Lemmas 24-26 and the runtime bound proved in Proposition Let be an Ò ℄ Õ algebraic-geometry code over an algebraic function field Ã of genus (with ¼ Ò •½), Then there exists a polynomial time list decoding algorithm for that works for up to Ò Õ Ò´ • ½µ Ò Õ Ò´Ò ¼ µ errors (provided the assumptions of the algorithm of Section 4.2 are satisfied).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Theorem<ref type="bibr" target="#b15">16</ref> The list-decoding problem for Ò •½ ℄ Õ Reed-Solomon codes allowing for errors and × erasures can be solved in polynomial time, provided • × Ò Õ ´Ò ×µ .The classical results of this nature show that one can solve the decoding problem if ¾ • × Ò . To compare the two results we restate both result. The classical result can be rephrased as</figDesc><table><row><cell>Thus we</cell></row><row><cell>get:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>For½, by Property 2, we have that ´Ü µ ¾ Õ ½ , and by Property 3a we have that ´Ü µ ½. Thus that agree in • places. If ½ and ¾ agree at Ü , then ´ ½ ¾ µ´Ü µ ¼ and thus by Property 3a,</figDesc><table><row><cell>Ò Õ . By Property 4, the map Ú Ä • ½ Ü ¼ ´ÜÒ µµ is one-one, and hence Ñ´ µ Ñ´Ä • ½ Ü ¼ µ. By Property 5, Ò Õ given by this implies has dimension at least , yielding ¼ ´ ´Ü½ µ ´Ü¾ µ . Finally, consider ½ ¾ ¾ Ä • ½ Ü ¼</cell></row></table><note><p>Proof:</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to the anonymous referees for numerous comments which improved and clarified the presentation a lot. We would like to express our thanks to Elwyn Berlekamp, Peter Elias, Jorn Justesen, Ronny Roth, Amin Shokrollahi and Alex Vardy for useful comments on the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Step 1:</p><p>Õ ½ ¾ ½ Ý ¾ , i.e find values of the coefficients Õ ½ ¾ such that the following conditions hold:</p><p>1. At least one Õ ½ ¾ is non-zero.</p><p>2. For every ¾ Ò℄, ¿ , ¿ ½, ¼ such that ¿ • Ö,</p><p>´Ü µ Ý for at least Ø values of ¾ Ò℄, and if so, include in output list. (This step can be performed by either completely factoring É using algorithms presented in <ref type="bibr" target="#b23">[24]</ref>, or more efficiently by using the root-finding algorithm of <ref type="bibr" target="#b10">[11]</ref>.)</p><p>The following proposition says that the above algorithm can be implemented efficiently modulo some (reasonable) assumptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 22</head><p>Given the ability to perform field operations in the subset Ä Ð Ü ¼ of the function field Ã when elements are expressed as a formal combination of the ½ 's for ½ ¾ Ð •½℄, the above algorithm reduces the decoding problem of an Ò ℄ Õ algebraic geometry code (with designed</p><p>to a root-finding problem over the function field Ã of a univariate polynomial of degree at most Ð ´Ò ¼ µ with coefficients having pole order at most Ð, where Ð Ç´Ñ Ü Ø•Ò´Ò ¼ µ Ø ¾ Ò´Ò ¼ µ Ø µ.</p><p>Proof: First of all, note that the computation of all the « Ü ½ ¿ 's can be done in Ç´ÒÐ ¾ µ operations over Ã. The system of equations set up in Step 1 has at most Ð´Ð µ « Ç´Ð ¾ ´Ò ¼ µµ unknowns, and hence can be solved in Ç´Ð ´Ò ¼ µ ¿ µ operations (over Õ ). Also, it is clear that the degree of É ¾ Ã ℄ thus found is at most ´Ð µ « Ç´Ð ´Ò ¼ µµ and that all coefficients of É have at most Ð poles at Ü ¼ and no poles elsewhere. The claimed result now follows once we note that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Analysis of the Algorithm</head><p>We start by looking at É ℄. Recall that for any ¾ Ã, É ℄ ¾ Ã. By the condition (ii) which we imposed on É, we have É ℄ ¾ Ä Ð Ü ¼ whenever ¾ Ä • ½ Ü ¼ .</p><p>Lemma 23 For ¾ Ò℄, if ¾ Ã satisfies ´Ü µ Ý , then ÓÖ ´É ℄ Ü µ Ö.</p><p>Proof: We have, for any such , É ℄´Üµ É´Ü ´Üµµ É ´ µ ´Ü ´Üµ Ý µ É ´ µ ´Ü ´Üµ ´Ü µµ and using (2), this yields</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and if</head><p>´ µ ¾ Ã is defined by ´ µ ´Üµ ´Üµ ´Ü µ, then ÓÖ ´´ ´ µ µ Ü µ</p><p>, we get ÓÖ ´É ℄ Ü µ Ö as desired.</p><p>Thus is a root of É Ý℄ and hence Ý divides É Ý℄.</p><p>, then a É Ý℄ as sought in Step 1 does exist (and can be found in polynomial time by solving a linear system).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The proof follows that of Lemma 6. The computational task in Step 1 is once again that of solving a homogeneous linear system. A non-trivial solution exists as long as the number of unknowns exceeds the number of constraints. The number of constraints in the linear system is</p><p>, while the number of unknowns equals </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reconstructing algebraic functions from mixed data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="488" to="511" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Berlekamp</surname></persName>
		</author>
		<title level="m">Algebraic Coding Theory</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>McGraw Hill</publisher>
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Bounded Distance •½ Soft-Decision Reed-Solomon Decoding</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Berlekamp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="704" to="720" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Theory and Practice of Error Control Codes</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Blahut</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Course in Computational Algebraic Number Theory</title>
		<author>
			<persName><forename type="first">H</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">GTM</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<date type="published" when="1993">1993</date>
			<publisher>Springer Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Two algorithms for the decoding of linear codes</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">I</forename><surname>Dumer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Problems of Information Transmission</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="32" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">List decoding for noisy channels</title>
		<author>
			<persName><forename type="first">P</forename><surname>Elias</surname></persName>
		</author>
		<idno>335</idno>
	</analytic>
	<monogr>
		<title level="j">Research Laboratory of Electronics</title>
		<imprint>
			<date type="published" when="1957">1957</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>MIT</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Error-correcting codes for list decoding</title>
		<author>
			<persName><forename type="first">P</forename><surname>Elias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="5" to="12" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A generalization of the Berlekamp-Massey algorithm for multisequence shift register synthesis with application to decoding cyclic codes</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Tzeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="1274" to="1287" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Generalized Minimum Distance Decoding</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Forney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="125" to="131" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Computing roots of polynomials over function fields of curves</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Shokrollahi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Highly resilient correctors for multivariate polynomials</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gemmell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="169" to="174" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Learning polynomials with queries: The highly noisy case</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FOCS</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Factorization of Polynomials over a Finite Field and the Solution of Systems of Algebraic Equations. Translated from Zapiski Nauchnykh Seminarov Lenningradskogo Otdeleniya Matematicheskogo Instituta im</title>
		<author>
			<persName><forename type="first">D</forename><surname>Grigoriev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Steklova AN SSSR</title>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">137</biblScope>
			<biblScope unit="page" from="20" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Algebraic Geometry Codes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Holdt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Van Lint And R</surname></persName>
		</author>
		<author>
			<persName><surname>Pellikaan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Coding Theory</title>
		<editor>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Pless</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Huffamn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">A</forename></persName>
		</editor>
		<imprint>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Bounds on list decoding of MDS codes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Justesen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-04">April 1998</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Polynomial-Time Reduction from Bivariate to Univariate Integral Polynomial Factorization</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kaltofen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FOCS</title>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Kaltofen</surname></persName>
		</author>
		<title level="m">Polynomial factorization 1987-1991. LATIN &apos;92</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Simon</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer LNCS</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">583</biblScope>
			<biblScope unit="page" from="294" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The Theory of Error-Correcting Codes</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Macwilliams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A displacement structure approach to efficient list decoding of algebraic geometric codes</title>
		<author>
			<persName><forename type="first">V</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Shokrollahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proccedings of the 31st Annual ACM Symposium on Theory of Computing</title>
		<meeting>cedings of the 31st Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Encoding and error-correction procedures for Bose-Chaudhuri codes</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Transactions on Information Theory, IT</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="459" to="470" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Personal communication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Radhakrishnan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-01">January, 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient decoding of Reed-Solomon codes beyond half the minimum distance</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ruckenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Submitted to IEEE Transactions on Information Theory</title>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Decoding algebraic-geometric codes beyond the error-correction bound</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Shokrollahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wasserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STOC</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Decoding Reed-Solomon codes beyond ´ ½µ ¾ and zeros of multivariate polynomials. Problems of Information Transmission</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">M</forename><surname>Sidelnikov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="44" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Algebraic Function Fields and Codes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Stichtenoth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Decoding of Reed-Solomon codes beyond the error-correction bound</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Complexity</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="180" to="193" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Decoding of Reed-Solomon codes beyond the error-correction diameter</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual Allerton Conference on Communication, Control and Computing</title>
		<meeting>the 35th Annual Allerton Conference on Communication, Control and Computing</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Modular curves, Shimura curves, and codes better than the Varshamov-Gilbert bound</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Tsfasman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Vl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Nachrichten</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="page" from="21" to="28" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Introduction to Coding Theory</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Van Lint</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Algorithmic complexity in coding theory and the minimum distance problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vardy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STOC</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Error correction of algebraic block codes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Welch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Berlekamp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">US Patent Number</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1986-12">December 1986</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
