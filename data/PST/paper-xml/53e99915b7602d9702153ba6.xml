<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Simulatable certificateless two-party authenticated key agreement protocol</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Lei</forename><surname>Zhang</surname></persName>
							<email>lei.zhang@urv.cat</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Engineering and Mathematics</orgName>
								<orgName type="institution" key="instit1">Universitat Rovira i Virgili</orgName>
								<orgName type="institution" key="instit2">UNESCO Chair in Data Privacy</orgName>
								<address>
									<addrLine>Av. Paı ¨sos Catalans 26</addrLine>
									<postCode>E-43007</postCode>
									<settlement>Tarragona</settlement>
									<region>Catalonia</region>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Nanjing Normal University</orgName>
								<address>
									<postCode>210097</postCode>
									<settlement>Nanjing</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Futai</forename><surname>Zhang</surname></persName>
							<email>zhangfutai@njnu.edu.cn</email>
							<affiliation key="aff2">
								<orgName type="department">Jiangsu Engineering Research Center on Information Security and Privacy Protection Technology</orgName>
								<address>
									<settlement>Nanjing</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Qianhong</forename><surname>Wu</surname></persName>
							<email>qianhong.wu@urv.cat</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Engineering and Mathematics</orgName>
								<orgName type="institution" key="instit1">Universitat Rovira i Virgili</orgName>
								<orgName type="institution" key="instit2">UNESCO Chair in Data Privacy</orgName>
								<address>
									<addrLine>Av. Paı ¨sos Catalans 26</addrLine>
									<postCode>E-43007</postCode>
									<settlement>Tarragona</settlement>
									<region>Catalonia</region>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Nanjing Normal University</orgName>
								<address>
									<postCode>210097</postCode>
									<settlement>Nanjing</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department" key="dep1">School of Computer</orgName>
								<orgName type="department" key="dep2">Ministry of Education</orgName>
								<orgName type="laboratory">Key Lab. of Aerospace Information Security and Trusted Computing</orgName>
								<orgName type="institution">Wuhan University</orgName>
								<address>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Josep</forename><surname>Domingo-Ferrer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Engineering and Mathematics</orgName>
								<orgName type="institution" key="instit1">Universitat Rovira i Virgili</orgName>
								<orgName type="institution" key="instit2">UNESCO Chair in Data Privacy</orgName>
								<address>
									<addrLine>Av. Paı ¨sos Catalans 26</addrLine>
									<postCode>E-43007</postCode>
									<settlement>Tarragona</settlement>
									<region>Catalonia</region>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer Engineering and Mathematics</orgName>
								<address>
									<addrLine>Av. Països Catalans 26</addrLine>
									<postCode>E-43007</postCode>
									<settlement>Tarragona</settlement>
									<region>Catalonia</region>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Simulatable certificateless two-party authenticated key agreement protocol</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D4EF95E4DC9FF5EC23ABDC55B0F35C24</idno>
					<idno type="DOI">10.1016/j.ins.2009.11.036</idno>
					<note type="submission">Received 20 February 2009 Received in revised form 18 November 2009 Accepted 21 November 2009</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Information security Protocol design Certificateless cryptography Authenticated key agreement Provable security</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Key agreement (KA) allows two or more users to negotiate a secret session key among them over an open network. Authenticated key agreement (AKA) is a KA protocol enhanced to prevent active attacks. AKA can be achieved using a public-key infrastructure (PKI) or identity-based cryptography. However, the former suffers from a heavy certificate management burden while the latter is subject to the so-called key escrow problem. Recently, certificateless cryptography was introduced to mitigate these limitations. In this paper, we first propose a security model for AKA protocols using certificateless cryptography. Following this model, we then propose a simulatable certificateless two-party AKA protocol. Security is proven under the standard computational Diffie-Hellman (CDH) and bilinear Diffie-Hellman (BDH) assumptions. Our protocol is efficient and practical, because it requires only one pairing operation and five multiplications by each party.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Key agreement (KA) is one of the fundamental cryptographic primitives. It allows two or more parties to establish a secret key over open networks; each party can encrypt any message such that only the parties sharing the secret session key can decrypt the message. This kind of plain KA protocols <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b27">28]</ref> are only secure against passive adversaries who limit themselves to eavesdropping communications between parties. In the real world, the adversary may mount more powerful attacks, e.g., by impersonating one party to communicate with another party. The notion of authenticated key agreement (AKA) <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b24">25]</ref> has been proposed to defeat such active adversaries. AKA protocols can be realized using a public-key infrastructure (PKI) or identity-based (ID-based) cryptography. However, PKI-based systems suffer from a heavy certificate management burden while ID-based cryptographic systems require all participants to fully trust an authority. The latter is a very strong assumption, hard to meet in practice, especially over open networks. This paper focuses on AKA protocols which do not suffer from such limitations. In particular, we investigate two-party AKA protocols based on certificateless cryptography.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Related work</head><p>The first two-party KA protocol in the literature is the Diffie-Hellman protocol <ref type="bibr" target="#b10">[11]</ref>. However, the basic Diffie-Hellman protocol does not authenticate the two communicating entities and it is insecure against active attacks, e.g., the man-in-the-middle 0020-0255/$ -see front matter Ó 2009 Elsevier Inc. All rights reserved. doi:10.1016/j.ins.2009.11.036 attack in which an adversary talks to both participants and impersonates one participant in front of the other participant. The notion of authenticated KA aims at ensuring security versus active adversaries who may impersonate one party to cheat another party during the execution of KA protocols. A number of KA protocols <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b28">29]</ref> have been proposed to achieve security against active attacks, an essential feature of secure communications in the real world.</p><p>The security of KA protocols has to be formally proven before they are deployed. The first work on formal security of KA protocols is due to Bellare and Rogaway <ref type="bibr" target="#b1">[2]</ref>. Their model was further investigated by Blake-Wilson et al. <ref type="bibr" target="#b4">[5]</ref> and Bellare et al. <ref type="bibr" target="#b3">[4]</ref>. Although these models are generally accepted to formalize the security of KA protocols, few key agreement protocols can be proven secure in these models. The main obstacle in proofs is that, without knowledge of the private key owned by the participants or the ability to solve the underlying hard problems, it is hard for the simulator to answer the reveal query which captures the known-key security property (see Section 2.2).</p><p>Several proposals have been presented to deal with the key reveal query. In <ref type="bibr" target="#b9">[10]</ref>, Cheng et al. introduced the concept of coin queries, which are used to force the adversary to reveal her ephemeral secret and hence make it possible for the simulator to deal with the reveal query. However, the possibility of an adversary breaking a protocol without knowing the ephemeral secret is not modeled. Another approach was proposed by Kudla and Paterson <ref type="bibr" target="#b14">[15]</ref>. Their approach relies on Gap assumptions <ref type="bibr" target="#b19">[20]</ref> which assume that it is still difficult to solve the computational version of some hard problems, even with the help of a corresponding decisional oracle. However, it is unknown whether such an oracle is available for many hard problems used to build KA protocols. Recently, Chen et al. <ref type="bibr" target="#b7">[8]</ref> presented a new approach referred to as built-in decision function to deal with the key reveal query. This approach is employed to convert a hard decisional problem into an easy decisional one.</p><p>AKA protocols can be realized in the PKI-or ID-based cryptographic setting. In the PKI setting, each user has a public key and a partially trusted certificate authority signs it and generates a certificate to bind the user to her public key. Then any two users can authenticate their communication in an explicit or implicit way when they run the KA protocol. To validate the established session key, each party needs to verify the certificate of the other party. It is a heavy burden to generate, deliver, maintain, and verify certificates in open networks. An alternative is to realize AKA protocols in an ID-based cryptographic setting <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b20">21]</ref>. In this scenario, a fully trusted authority called Private Key Generator (PKG) generates a private key for each user in the system taking as input the user's identity. The user's identity serves as the public key of the user. Henceforth, AKA protocols are realized similarly to those in the PKI setting. In this way, the system eliminates the certificate management burden but suffers from the key escrow problem, because all parties must fully trust PKG. Some ID-based AKA protocols <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b17">18]</ref> claim that they are free from session key escrow in the sense that PKG cannot recover the agreed session key. One may observe that this is not entirely true, since PKG knows each entity's private key and a malicious PKG can always launch a man-in-the-middle attack to obtain the secret session key.</p><p>AKA protocols can also be implemented in the certificateless cryptographic setting. Certificateless cryptography (CLC) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b29">30]</ref> was recently introduced to circumvent the key escrow problem inherent to ID-based cryptography and the certificate management burden in traditional PKI-based cryptosystems. In CLC, a partially trusted authority called Key Generation Center (KGC) helps to generate the private key for each user but cannot access the full private key of any user. Hence, CLC avoids the key escrow problem. The public key of a user is computed from KGCs public parameters and a secret value chosen by the user. Hence, CLC does not need an additional certificate to bind the user to her public key. Several certificateless two-party AKA protocols <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b26">27]</ref> have been presented. Nevertheless, none of them has been proven secure with a formal proof. As for efficiency, most of the existing protocols suffer from heavy pairing computation during the session key establishment phase. Thus, to really take advantage of certificateless cryptography, it is essential to build certificateless two-party AKA protocols which are provably secure and efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Contributions</head><p>By integrating certificateless cryptography and KA protocols, this paper investigates provably secure and efficient certificateless AKA protocols to facilitate their application. We define a formal security model for certificateless AKA protocols and we propose a novel implementation based on bilinear pairings. Our proposal is equipped with the following useful properties: Key escrow avoidance. Our protocol is free from the long-term authentication key escrow problem. This is due to the fact that, in our proposal, the KGC does not know the private key serving as the long-term authentication key of each participant. Our protocol is also free from the session key escrow problem in the sense that a malicious KGC can impersonate neither party to launch the man-in-the middle attack if she does not replace the users' public keys, unlike previous AKA proposals based on ID-based cryptography. In fact, the proposed protocol achieves a trust level similar to the one of AKA protocols in the traditional PKI setting but it does not suffer from the certificate management burden. Provable security. Security depends only on some standard assumptions, i.e. the bilinear Diffie-Hellman (BDH) and the computational Diffie-Hellman (CDH) assumptions. Furthermore, in our protocol, the adversary is allowed to ask key reveal queries without employing any artificial oracles or additional non-standard assumptions (e.g., the Gap assumption) as in previous protocols.</p><p>Efficiency. Our protocol offers strong security without sacrificing efficiency. Indeed, the proposed protocol is efficient in terms of number of rounds, communication, and computation. In particular, to establish a session key, each entity is required to execute only one pairing operation and five multiplications.</p><p>The rest of the paper is organized as follows. Section 2 defines the security model for certificateless two-party AKA protocols. We propose our simulatable certificateless two-party AKA protocol in Section 3. In Section 4, the protocol is formally analyzed under the standard BDH and CDH assumptions. Section 5 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Modeling certificateless two-party AKA protocols</head><p>Before modeling certificateless two-party AKA protocols, we first review the adversaries in CLC. A certificateless twoparty AKA protocol should resist the attacks from two types of adversaries known as 'Type I adversary' and 'Type II adversary'. Type I adversary A I : This adversary models an adversary who does not know the master-key of KGC, but who has the ability to replace the public key of any entity with a value of her choice. Type II adversary A II : This adversary models a malicious KGC who knows the master-key, but who cannot replace the target user's public key.</p><p>Note that our definitions of Types I and II adversaries are stronger than those in <ref type="bibr" target="#b0">[1]</ref>. In fact, the adversaries in our definitions have a power similar to the ''super adversaries" defined in <ref type="bibr" target="#b13">[14]</ref>, which are the most powerful adversaries considered in the CLC literature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Algorithms of a certificateless two-party AKA protocol</head><p>A certificateless two-party AKA protocol consists of six polynomial-time algorithms: Setup, Partial-Private-Key-Extract, Set-Secret-Value, Set-Private-Key, Set-Public-Key and Key-Agreement. These algorithms are defined as follows.</p><p>Motivated by the security model of Chen et al. <ref type="bibr" target="#b7">[8]</ref> derived from <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref>, we present a security model for AKA protocols in the setting of CLC. The model is defined by the following game between a challenger CH and an adversary A 2 fA I ; A II g. The adversary controls the communications from and to the protocol participants. Each participant i has an identity ID i . The adversary's behavior is modeled by a number of oracles maintained by CH. We use the oracle Q s i;j to represent the sth instance of participant i and partner participant j in a session.</p><p>At the beginning of the game, CH runs the Setup algorithm, takes as input a security parameter ' to obtain the master-key and the system parameter list params. If A is a Type I adversary A I ; CH sends params to A and keeps the master-key secret; otherwise, A is a Type II adversary A II , and CH sends params with master-key to A.</p><p>A is modeled by a probabilistic polynomial-time turing machine. All communications go through the adversary A. Participants only respond to the queries by A and do not communicate directly among themselves. A can relay, modify, delay, interleave or delete all the message flows in the system. Note that A can act as a benign adversary, which means that A is deterministic and restricts her action to choosing a pair of oracles Q n i;j and Q t j;i and then faithfully conveying each message flow from one oracle to the other. Furthermore, A may ask a polynomially bounded number of the following queries, including one Test query defined as follows.</p><p>CreateðID i Þ: This allows A to ask CH to set up a new participant i with identity ID i . On receiving such a query, CH generates the public/private key pair for i. Public-KeyðID i Þ: A can request the public key of a participant i whose identity is ID i . To respond, CH outputs the public key P i of participant i. Partial-Private-KeyðID i Þ: A can request the partial private key of a participant i whose identity is ID i . To respond, CH outputs the partial private key D i of participant i. CorruptðID i Þ: A can request the private key of a participant i whose identity is ID i . To respond, CH outputs the private key S i of participant i. Public-Key-ReplacementðID i ; P 0 i Þ: For a participant i whose identity is ID i ; A can choose a new public key P 0 i and then set P 0 i as the new public key of this participant. CH will record these replacements which will be used later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sendð</head><p>Q n i;j ; MÞ: A can send a message M of her choice to an oracle, say Q n i;j , in which case participant i assumes that the message has been sent by participant j. A may also make a special Send query with M ¼ k to an oracle Q n i;j , which instructs i to initiate a protocol run with j. An oracle is an initiator oracle if the first message it has received is k. If an oracle does not receive a message k as its first message, then it is a responder oracle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Revealð</head><p>Q n i;j Þ: A can ask a particular oracle to reveal the session key (if any) it currently holds to A. Testð Q T I;J Þ: At some point, A may choose one of the oracles, say Q T I;J , to ask a single Test query. This oracle must be fresh (see Definition 2). To answer the query, the oracle flips a fair coin b 2 f0; 1g, and returns the session key held by Q T I;J if b ¼ 0, or a random sample from the distribution of the session key if b ¼ 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An oracle</head><p>Q n i;j will be in one of the following states: Note that this definition allows the participant i to be corrupted, and thus can be used to address the key-compromise impersonation property as well as the partial forward secrecy property.</p><formula xml:id="formula_0">Accepted:</formula><p>After a Test query, the adversary can continue to query the oracles except that it cannot make a Reveal query to the test oracle Q T I;J or to Q t J;I who has a matching conversation with Q T I;J (if it exists), and it cannot corrupt participant J. In addition, if A is a Type I adversary, A cannot request the partial private key of the participant J; and if A is a Type II adversary, A cannot replace the public key of the participant J. At the end of the game, A must output a guess bit b 0 . A wins if and only if b 0 ¼ b.</p><p>A's advantage to win the above game, denoted by Advantage A ðkÞ, is defined as:</p><formula xml:id="formula_1">Advantage A ðkÞ ¼ jPr½b 0 ¼ b À 1=2j:</formula><p>Computational Diffie-Hellman (CDH) problem: In G 1 : Given a generator P of G 1 and ðaP; bPÞ for unknown a; b 2 Z Ã q , compute abP. The CDH assumption states that the probability of any polynomial-time algorithm to solve the CDH problem is negligible.</p><p>Bilinear Diffie-Hellman (BDH) problem: Given a tuple ðP; aP; bP; cPÞ 2 G 1 for random unknown a; b; c 2 Z Ã q , compute eðP; PÞ abc . The BDH assumption states that the probability of any polynomial-time algorithm to solve the BDH problem is negligible.</p><p>Assuming that the CDH and BDH problems are hard, we now prove the security of the above key agreement protocol according to Definition 3. Lemma 1. In the presence of a benign adversary on Q n i;j and Q t j;i , both oracles always agree on the same session key as if there was no adversary, and this key is distributed uniformly at random.</p><p>Proof. Suppose that the two participants i and j follow the protocol and A is benign. In this case, both oracles receive correctly formatted messages looking exactly as originally sent by the other oracle; hence, they will agree on the same session key. Since r i and r j are randomly selected by participants i and j, respectively, the session key can be considered as the output of the hash function H 2 on a random input. Based on the properties of cryptographic hash functions, the session key is uniformly distributed over f0; 1g l . h Lemma 2. Under the assumption that the BDH problem is intractable, the advantage of a Type I adversary against our certificateless two-party AKA protocol is negligible in the random oracle model <ref type="bibr" target="#b2">[3]</ref>. Specifically, suppose that, in the attack, a Type I adversary A, who makes at most q H 2 times H 2 queries and creates at most q c participants, wins the game with advantage Advantage A ðkÞ.</p><p>Then there exists an algorithm CH to solve the BDH problem with advantage</p><formula xml:id="formula_2">1 q 2 c Áq s Áq H 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Advantage</head><p>A ðkÞ, where q s is the maximal number of sessions each participant may be involved in.</p><p>Proof. Suppose that there exists a Type I adversary A who can win the game defined in Section 2 with a non-negligible advantage Advantage A ðkÞ in polynomial-time t. Then we show that there is an algorithm CH that solves the BDH problem with a non-negligible probability. Suppose that CH is given an arbitrary input ðP; aP; bP; cPÞ of the BDH problem. We show how CH can use A to solve the BDH problem, i.e. to compute eðP; PÞ abc .</p><p>All queries by the adversary A now pass through CH. CH sets P 0 ¼ aP and selects the system parameters params = ðG 1 ; G 2 ; e; P; P 0 ; H 1 ; H 2 ; lÞ. params is sent to A. In this way, the game is initialized.</p><p>H 1 query: CH maintains an initially empty list H 1 which contains tuples of the form ðID i ; d i ; Q i Þ. Suppose A can query H 1 for at most q H 1 times. CH chooses distinct I; J 2 ½1; q H 1 . On receiving a query H 1 ðID i Þ, the same answer from the list H 1 will be given if the request has been asked before. If ID i -ID J ; CH picks a random d i 2 Z Ã q and computes Q i ¼ d i P; while ID i ¼ ID J ; CH sets d i ¼ null; Q i ¼ bP. In both cases, CH returns Q i as the answer and adds ðID i ;</p><formula xml:id="formula_3">d i ; Q i Þ to H 1 .</formula><p>CreateðID i Þ: CH maintains an initially empty list C consisting of tuples of the form ðID i ; D i ; x i ; P i Þ. For simplicity, we assume that all the Create queries are distinct. On receiving a Create query on ID i ; CH first makes an H 1 query H 1 ðID i Þ to obtain a tuple ðID i ; d i ; Q i Þ, then does as follows.</p><p>If ID i -ID J , choose a random x i 2 Z Ã q , and compute the public key P i ¼ x i P and the partial private key D i ¼ d i P 0 . The tuple</p><formula xml:id="formula_4">ðID i ; D i ; x i ; P i Þ is added to C. If ID i ¼ ID J , choose a random x i 2 Z Ã q , set P i ¼ x i P, set D i ¼ null, then add ðID i ; D i ; x i ; P i Þ to C.</formula><p>Without loss of generality, we assume that, before asking the following queries, A has already asked some Create queries on the related identities.</p><p>H 2 query: Suppose A can query H 2 for at most q H 2 times. CH maintains a list H 2 which contains tuples of the form</p><formula xml:id="formula_5">ðID a i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; Y i ; Z i ; h i Þ. On receiving a query H 2 ðID a i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; Y i ; Z i Þ</formula><p>, the same answer from the list H 2 will be given if the request has been asked before. Otherwise, CH does as follows.</p><p>If there exists a tuple ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ on S (maintained in the Send query below) such that ID i -ID J and  , the same answer from the list S will be given if the query has been asked before; if the query has not been asked, CH does as follows.</p><formula xml:id="formula_6">Á Q n i;j is an initiator, ID a i ¼ ID i ; ID b i ¼ ID j ; R a i ¼ M n i;j ; R b i ¼ M n j;i ; X i ¼ r n i;j M n j;i ; y i ¼ eðM n j;i þ Q j ; r n i;j P 0 þ D i Þ; P a i ¼ P n i ; P b i ¼ P n j ; Y i ¼</formula><formula xml:id="formula_7">ID i ), or Á Q n i;j is a responder, ID a i ¼ ID j ; ID b i ¼ ID i ; R a i ¼ M n j;i ; R b i ¼ M n i;j ; X i ¼ r n i;j M n j;i ; y i ¼ eðM n j;i þ Q j ; r n i;j P 0 þ D i Þ; P a i ¼ P n j ; P b i ¼ P n i ; eðY i ; PÞ ¼ eðP n i ; M n j;i Þ; Z i ¼</formula><p>If n ¼ T; ID i ¼ ID I and ID j ¼ ID J , set SK n i;j ¼ r n i;j ¼ null, set M n i;j ¼ cP, return M n i;j as the answer and add ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ to S. Else, if ID i -ID J , choose random r n i;j 2 Z Ã q , compute M n i;j ¼ r n i;j P, return M n i;j as the answer, set SK n i;j ¼ null and add ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ to S. Else, choose a random r n i;j 2 Z Ã q , compute M n i;j ¼ r n i;j P 0 , return M n i;j as answer, set SK n i;j ¼ null, and add ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ;  </p><formula xml:id="formula_8">P n i ; P n j ; SK n i;j Þ to S. Revealð Q n i;j Þ:</formula><formula xml:id="formula_9">i ; Z i ; h i Þ in H 2 such that ID i ¼ ID a i ; ID j ¼ ID b i ; M n i;j ¼ R a i ; M n j;i ¼ R b i ; r n i;j M n j;i ¼ X i ; eðM n j;i þ Q j ; r n i;j P 0 þ D i Þ ¼ y i ; P n i ¼ P a i ; P n j ¼ P b i ; r n i;j P n j ¼ Y i ; eðP n i ; M n j;i Þ ¼ eðZ i ;</formula><formula xml:id="formula_10">i ; Z i ; h i Þ in H 2 such that ID j ¼ ID a i ; ID i ¼ ID b i ; M n j;i ¼ R a i ; M n i;j ¼ R b i ; r n i;j M n j;i ¼ X i ; eðM n j;i þ Q j ; r n i;j P 0 þ D i Þ ¼ y i ; P n j ¼ P a i ; P n i ¼ P b i ; eðP n i ; M n j;i Þ ¼ eðY i ;</formula><p>PÞ; r n i;j P n j ¼ Z i , set SK n i;j ¼ h i and return SK n i;j as the answer. Á Otherwise, randomly sample SK n i;j 2 f0; 1g l and return SK n i;j as the answer. Else (ID i ¼ ID J ) Á If Q n i;j is an initiator and there exists a tuple ðID a i ;</p><formula xml:id="formula_11">ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; Y i ; Z i ; h i Þ in H 2 such that ID i ¼ ID a i ; ID j ¼ ID b i ; M n i;j ¼ R a i ; M n j;i ¼ R b i ; eðM n i;j ; M n j;i Þ ¼ eðX i ; PÞ; P n i ¼ P a i ; P n j ¼ P b i ; eðM n i;j ; P n j Þ ¼ eðY i ; PÞ; eðP n i ; M n j;i Þ ¼ eðZ i ; PÞ, compute y n</formula><p>i as follows:   </p><formula xml:id="formula_12">y n i ¼ e M n j;i þ d j P; aM n i;j þ D i ¼ e 1 r n i;j a X i þ d j P; r n i;j aaP þ abP ! ¼ e X i ; aP þ 1</formula><formula xml:id="formula_13">i ; Z i ; h i Þ in H 2 such that ID j ¼ ID a i ; ID i ¼ ID b i ; M n j;i ¼ R a i ; M n i;j ¼ R b i ; eðM n i;j ; M n j;i Þ ¼</formula><formula xml:id="formula_14">i ; Z i ; h i Þ in H 2 such that R a i ¼ cP; R b i ¼ M n j;i or Q T I;J is a responder and there is a tuple in H 2 such that R b i ¼ cP; R a i ¼ M n j;i (if M is the received message, then it holds that M ¼ M n j;i Þ; CH checks whether eðR a i ; R b i Þ ¼ eðX i ;</formula><formula xml:id="formula_15">y n i ¼ e M þ Q J ; cP 0 þ D I À Á ¼ e M þ bP; acP þ l I aP ð Þ ¼ eðP; PÞ abc e bP; l I aP ð Þ e M; acP þ l I aP ð Þ</formula><p>¼ eðP; PÞ abc eðbP; l I aPÞeðX i ; aPÞeðl I M; aPÞ ¼ eðP; PÞ abc Á u Algorithm CH randomly chooses y i from H 2 and returns y i =u as the response to the BDH challenge.</p><p>Claim 1. If CH does not abort the above game, A cannot find any inconsistency between the simulation and the real world.</p><p>Proof. The simulations of all the random oracles are valid and the messages of the oracles are uniformly distributed in the message space. The simulator makes use of the programmability of random oracle H 2 and the bilinearity of the pairing to instantiate a Decisional Diffie-Hellman (DDH) oracle and keep the consistency with responses to the H 2 queries and the Reveal queries. Hence, A cannot notice any difference with the real world. h</p><formula xml:id="formula_16">Claim 2. Let Event 6 be that j ¼ eðM þ Q J ; cP 0 þ D I Þ</formula><p>was not queried on H 2 . Then Pr½Event 5 ^Event 6 P Advantage A ðkÞ.</p><p>Proof. Because H 2 is a random oracle, if Event 5 or Event 6 happens, A can only win the game in two ways:</p><p>Case 1: A randomly guesses whether x is SK T I;J or not, if SK T I;J has not been decided yet. Case 2: A knows that it has revealed an oracle Q n i;j which has the same session key as the challenge oracle</p><formula xml:id="formula_17">Q T I;J .</formula><p>Note here that Event 5 or Event 6 could happen in Case 2 in general. This is because we make use of the programmability of random oracle H 2 and CH may have responded to the Reveal query without knowing the corresponding j in the simulation. Since the random oracle should respond uniquely to each query in the simulation, the adversary can surely win the game if it knows the session key, even if it was not generated by a query to the random oracle H 2 .</p><p>One may notice that the identifiers and the transcript are used as the inputs of H 2 to generate the session key. Hence, Q n i;j and Q T I;J obtain the same session key with probability greater than 1=2 ' only if Q n i;j is either the chosen fresh oracle Q T I;J or an oracle Q m J;I which has the same transcript of Q T I;J for some m. According to the rules of the game, A is allowed to reveal neither oracle. That is, neither the fresh test oracle nor the oracle with matching conversation should be revealed. Since the identifiers and the transcript are part of the input of H 2 , in this protocol, Case 2 happens with probability at most 1=2 ' . It follows that:</p><formula xml:id="formula_18">Pr½A winsjEvent 5 _ Event 6 ¼ 1=2 Hence, we have Advantage A ðkÞ þ 1=2 ¼ Pr½A wins ¼ Pr½A winsjEvent 5 _ Event 6Pr½Event 5 _ Event 6 þ Pr½A winsjEvent 5 _ Event 6Pr½Event 5 _ Event 6 6 1=2 þ Pr½Event 5 _ Event 6 ¼ 1=2 þ Pr½Event 5 ^Event 6</formula><p>The claim follows. h Let Event 7 be that, in the attack, adversary A indeed chose oracle Q T I;J as the challenge oracle. It is clear that Events 1, 2, 3, 4 will not happen if Event 7 happens and vice versa. Therefore,</p><formula xml:id="formula_19">Pr½Event 1 _ Event 2_Event 3 _ Event 4 ¼ Pr½Event 7 P 1 q 2 c Á q s</formula><p>Let Event 8 be that A did not abort in the game, and Event 9 be that CH found the correct y i . Accordingly, we have Pr½CH wins ¼ Pr½Event 8 ^Event 6 ^Event 9 ¼ Pr½Event 7 ^Event 5 ^Event 6 ^Event 9</p><formula xml:id="formula_20">P 1 q 2 c Á q s Á q H 2 Pr½Event 5 ^Event 6 P 1 q 2 c Á q s Á q H 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Advantage</head><p>A ðkÞ: Ã Lemma 3. The advantage of a Type II adversary against our certificateless two-party AKA protocol is negligible in the random oracle model assuming that the CDH problem is hard. Specifically, suppose that, in the attack, a Type II adversary A, which makes at most q H 2 H 2 queries and creates at most q c participants, wins the game with advantage Advantage A ðkÞ. Then there exists an algorithm CH to solve the CDH problem with advantage</p><formula xml:id="formula_21">1 q 2 c Áq s Áq H 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Advantage</head><p>A ðkÞ, where q s is the maximal number of sessions each participant may be involved in.</p><p>Proof. Suppose that there exists a Type II adversary A who can win the game defined in Section 2 with a non-negligible advantage Advantage A ðkÞ in polynomial-time t. Then we show that there is an algorithm CH that solves the CDH problem with non-negligible probability. Suppose CH is given an arbitrary input ðP; aP; bPÞ of the CDH problem. We show how CH can use A to solve the CDH problem, i.e. to compute abP.</p><p>All queries of the adversary A now pass through CH. CH chooses master-key s 2 Z Ã q andcomputes P 0 ¼ sP. CH sets the system parameter as params=ðG 1 ; G 2 ; e; P; P 0 ; H 1 ; H 2 ; lÞ. params and s are sent to A. In this way, the game is initialized.</p><p>H 1 query: CH maintains an initially empty list H 1 which contains tuples of the form ðID i ; Q i Þ. Suppose A can make at most q H 1 times H 1 queries. CH chooses I; J 2 ½1; q H 1 at random. On receiving a query H 1 ðID i Þ, the same answer from the list H 1 will be given if the request has been asked before. Otherwise, CH picks a random </p><formula xml:id="formula_22">Q i 2 G Ã 1 ,</formula><formula xml:id="formula_23">ID a i ¼ ID i ; ID b i ¼ ID j ; R a i ¼ M n i;j ; R b i ¼ M n j;i ; X i ¼ r n i;j M n j;i ; y i ¼ eðM n j;i þ Q j ; sM n i;j þ sH 1 ðID i ÞÞ; P a i ¼ P n i ; P b i ¼ P n j ; Y i ¼ r n i;j P n j ; eðZ i ; PÞ ¼ eðP a i ; R b i Þ; SK n i;j -null, or Á Q n i;j</formula><p>is a responder and </p><formula xml:id="formula_24">ID a i ¼ ID j ; ID b i ¼ ID i ; R a i ¼ M n j;i ; R b i ¼ M n i;j ; X i ¼ r n i;j M n j;i ; y i ¼ eðM n j;i þ Q j ; sM n i;j þ</formula><formula xml:id="formula_25">i ; Z i ; h i Þ to H 2 .</formula><p>CreateðID i Þ: Without loss of generality, we assume that all Create queries are distinct. CH maintains an initially empty list C of the form ðID i ; x i ; P i Þ. On receiving a Create query on ID i ; CH does as follows.</p><p>If ID i -ID J , choose a random x i 2 Z Ã q , compute the public key P i ¼ x i P, and add ðID i ; x i ; P i Þ to C. Else if ID i ¼ ID J , set P i ¼ aP and add ðID i ; null; P i Þ to C.</p><p>Without loss of generality, we assume that, before making the following queries, A has already made Create queries on some related identities.</p><p>Public-KeyðID i Þ: On receiving this query, CH first searches for a tuple ðID i ; x i ; P i Þ in C which is indexed by ID i , and then returns P i as the answer.</p><p>CorruptðID  and returns Y j as the response to the CDH challenge; otherwise Q T I;J is a responder and there is a tuple in H 2 such that P a i ¼ aP; R b i ¼ bP, so CH randomly chooses Z j from H 2 and returns Z j as the response to the CDH challenge. If there exists no such tuple in H 2 ; CH aborts (Event 5). Claim 3. If CH does not abort the game, A cannot find any inconsistency between the simulation and the real world.</p><formula xml:id="formula_26">i ; Z i ; h i Þ in H 2 such that Á Q n i;j is an initiator and ID i ¼ ID a i ; ID j ¼ ID b i ; M n i;j ¼ R a i ; M n j;i ¼ R b i ; r n i;j M n j;i ¼ X i ; eðM n j;i þ Q j ; sM n i;j þ sH 1 ðID i ÞÞ ¼ y i ; P n i ¼ P a i ; P n j ¼ P b i ; r n i;j P n j ¼ Y i ; eðP a i ; R b i Þ ¼ eðZ i ; PÞ, or Á Q n i;j is a responder and ID j ¼ ID a i ; ID i ¼ ID b i ; M n j;i ¼ R a i ; M n i;j ¼ R b i ; r n i;j M n j;i ¼ X i ; eðM n j;i þ Q j ; sM n i;j þ</formula><p>Proof. The simulations of all the random oracles are valid and the messages of the oracles are uniformly distributed in the message space. So the adversary cannot notice any difference with the real world. h Claim 4. Let Even 6 be that abP was not queried on H 2 . Then Pr½Event 5 ^Event 6 P Advantage A ðkÞ.</p><p>Proof. The analysis is similar to that of Claim 2. We omit it here to avoid repetition. h Let Event 7 be the event that, in the attack, adversary A chooses oracle Q T I;J as the challenger oracle. It is clear that Events 1, 2, 3, 4 will not happen if Event 7 happens and vice versa. Therefore, Pr½Event 1 _ Event 2_Event 3 _ Event 4 ¼ Pr½Event 7 P 1 q 2 c Á q s Let Event 8 be the event that A does not abort in the game, and Event 9 be the event that CH found the correct solution abP of the CDH problem. Accordingly, we have Pr½CH wins ¼ Pr½Event 8 ^Event 6 ^Event 9 ¼ Pr½Event 7 ^Event 5 ^Event 6 ^Event 9 P 1 q 2 c Á q s Á q H 2 Pr½Event 5 ^Event 6 P 1 q 2 c Á q s Á q H 2 Advantage A ðkÞ: Ã Theorem 1. Our protocol is a secure certificateless two-party AKA protocol.</p><p>Proof. The theorem follows directly from Lemmas 1-3. h Theorem 2. Our protocol has the perfect forward secrecy property if the CDH problem in G 1 is hard.</p><p>Proof. Suppose that A and B established a session key K using our certificateless two-party AKA protocol, and later, their private keys S A and S B were compromised. Let r A and r B be the secret random numbers used by A and B, respectively, during the establishment of their session key. It is easy to see that, to compute the established session key K, the adversary who owns S A ; S B ; R A ¼ r A P and R B ¼ r B P for unknown r A ; r B must know the value of r A r B P. However, to compute the value of r A r B P without the knowledge of either r A or r B , the adversary must have the ability to solve the CDH problem in G 1 . Under the CDH assumption, this probability is negligible. Hence, our protocol has the perfect forward secrecy property. h</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>Certificateless two-party AKA protocols are important tools to secure communications over open networks. We have presented a formal definition of the security model for two-party AKA protocols in the certificateless cryptographic setting. Following this definition, we have instantiated an efficient certificateless two-party AKA protocol. The proposed protocol has been proven secure under some well-studied assumptions. Our scheme is also efficient and practical, because each party needs only one pairing operation and five multiplications to negotiate a session key.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>A has never requested the partial private key of participant j; and, if A is a Type II adversary, A has never replaced the public key of participant j.</figDesc><table><row><cell>Definition 2 (Fresh oracle). An oracle j -i is not corrupted; (4) there is no oracle Q n i;j is fresh if (1) Q t j;i in the state Opened having a matching conversation with Q n i;j is in the state Accepted; (2) Q n i;j is not in the state Opened; (3) party Q n i;j ; (5) if A is a Type</cell></row><row><cell>I adversary,</cell></row></table><note><p>This oracle is in the state Accepted if it has accepted the request to establish a session key. Rejected: This oracle is in the state Rejected if it has rejected the request to establish a session key and has aborted the protocol. State *: This oracle is in the state * if it has not made any decision to accept or reject. Opened: This oracle is in the state Opened if it has answered a Reveal query. Definition 1 (Matching conversation). Let the session ID be the concatenation of the messages in a session. Two oracles Q n i;j and Q t j;i are said to have a matching conversation with each other if they have the same session ID.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>null (where D i is the partial private key of the participant whose identity is</figDesc><table><row><cell>r n i;j P n j ; eðZ i ; PÞ ¼ eðP n i ; M n j;i Þ; SK n i;j</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>where d j can be found in H 1 of the form ðID j ; d j ; Q j Þ). If y n i ¼ y i , set h i ¼ SK n i;j , return h i as the answer and add Y i ; Z i ; h i Þ to H 2 . Otherwise, randomly choose h i 2 f0; 1g l , return h i as the answer and add Y i ; Z i ; h i Þ to H 2 . Else, randomly choose h i 2 f0; 1g l , return h i as the answer and add ðID a On receiving this query, CH first searches for a tuple ðID i ; D i ; x i ; P i Þ in C which is indexed by ID i , then returns P i as the answer.Partial-Private-KeyðID i Þ: Whenever CH receives this query, if ID i ¼ ID J ; CH aborts (Event 1); else, CH searches for a tuple ðID i ; D i ; x i ; P i Þ in C which is indexed by ID i and returns D i as the answer.CorruptðID i Þ: Whenever CH receives this query, if ID i ¼ ID J ; CH aborts (Event 2); else, CH searches for a tuple ðID i ; D i ; x i ; P i Þ in C which is indexed by ID i and if x i ¼ null; CH returns null; otherwise, CH returns ðx i ; D i Þ as the answer. Public-Key-ReplacementðID i ; P 0 i Þ: On receiving this query, CH searches for a tuple ðID i ; D i ; x i ; P i Þ in C which is indexed by ID i , then updates P i to P 0 i and sets x i ¼ null.</figDesc><table><row><cell>y n i ¼ e M n j;i þ d j P; aM n i;j þ D i</cell><cell>¼ e</cell><cell>1 r n i;j a</cell><cell>X i þ d j P; r n i;j aaP þ abP</cell><cell>!</cell><cell>¼ e X i ; aP þ</cell><cell>1 i;j r n</cell><cell>bP</cell><cell>! e d j aP; r n i;j aP þ bP</cell></row><row><cell cols="9">ðID a i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; ðID a i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; Y Sendð Q n i;j ; MÞ: CH maintains an initially empty list S consisting of tuples of the form ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ, which means that M n j;i is the incoming message, P n j is the public key of the participant j that Q n i;j received, P n i is the current public key owned by participant i; r n i;j ; M n i;j are defined below. On receiving a query Sendð Q n i;</cell></row><row><cell>set h i ¼ SK n i;j , add ðID a i ; ID b i ; R a i ; R b</cell><cell cols="3">r n i;j P n j ; SK n i;j -null,</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p><p>i ; X i ; y i ; P a i ; P b i ; Y i ; Z i ; h i Þ to H 2 and return h i as the answer. Else if there exists a tuple ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ on S such that ID i ¼ ID J and Á Q n i;j is an initiator and</p>ID a i ¼ ID i ; ID b i ¼ ID j ; R a i ¼ M n i;j ; R b i ¼ M n j;i ; eðX i ; PÞ ¼ eðM n i;j ; M n j;i Þ; P a i ¼ P n i ; P b i ¼ P n j ; eðY i ; PÞ ¼ eðM n i;j ; P n j Þ; eðZ i ; PÞ ¼ eðP n i ; M n j;i Þ; SK n i;j -null, Á or Q n i;j is a responder and ID a i ¼ ID j ; ID b i ¼ ID i ; R a i ¼ M n j;i ; R b i ¼ M n i;j ; eðX i ; PÞ ¼ eðM n i;j ; M n j;i Þ; P a i ¼ P n j ; P b i ¼ P n i ; eðY i ; PÞ ¼ eðP n i ; M n j;i Þ; eðZ i ; PÞ ¼ eðM n i;j ; P n j Þ; SK n i;j -null, compute (i ; Z i ; h i Þ to H 2 .</p>Public-KeyðID i Þ: j ; MÞ (if Mk; CH sets M n j;i ¼ M; otherwise, at the end of the protocol, a message will be returned; if Q n i;j is in Accepted, then CH sets this message to be M n j;i )</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>CH returns SK n i;j as the answer. Otherwise, CH searches for a tuple ðID i ; D i ; x i ; P i Þ which is indexed by ID i in C and does as follows.Abort if n ¼ T; ID i ¼ ID I and ID j ¼ ID J , or</figDesc><table><row><cell>ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ. If SK n i;j -null; Q n i;j is the oracle who has a matching conversation with</cell><cell>Q T I;J (Event 3).</cell></row><row><cell>Else if ID i -ID J . Á If Q n i;j is an initiator and there is a tuple ðID a i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; Y</cell><cell></cell></row></table><note><p>On receiving a query Revealð Q n i;j Þ; CH first calls Sendð Q n i;j ; MÞ, then looks up the list S for a tuple</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>PÞ holds. If no such tuple exists, CH aborts (Event 5). Otherwise, CH computes</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>returns Q i as the answer and adds ðID i ;Q i Þ to H 1 .H 2 query: Suppose A can make at most q H 2 times H 2 queries. CH maintains an initially empty list H 2 which contains tuples of the form ðID a Y i ; Z i Þ, the same answer from the list H 2 will be given if the request has been asked before. Otherwise, CH does as follows.</figDesc><table><row><cell>i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; Y i ; Z i ; h i Þ. On receiving a query H 2 ðID a i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; If there exists a tuple ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ in S such that Á Q n i;j is an initiator and</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>sH 1 ðID i ÞÞ; Y i ; Z i ; h i Þ to H 2 and return h i as the answer. Else, randomly choose h i 2 f0; 1g l , return h i as the answer and add ðID a</figDesc><table><row><cell>P a i ¼ P n j ; P b i ¼ P n i ; eðY i ; PÞ ¼ eðP b i ; R a i Þ; Z i ¼ r n i;j P n j ; SK n i;j -null, set h i ¼ SK n i;j , add ðID a i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; i ; ID b i ; R a i ; R b i ; X i ; y i ; P a i ; P b i ; Y</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>On receiving this query, CH searches for a tuple ðID i ; x i ; P i Þ in C which is indexed by ID i . If ID i ¼ ID J ; CH aborts (Event 1); otherwise, CH returns ðx i ; D i ¼ sH 1 ðID i ÞÞ as the answer.Public-Key-ReplacementðID i ; P 0 i Þ: On receiving this query, if ID i ¼ ID J ; CH aborts (Event 2); otherwise, CH searches for a tuple ðID i ; x i ; P i Þ in C which is indexed by ID i , then updates P i to P 0 i and sets x i ¼ null.</figDesc><table><row><cell cols="2">Sendð Q n i;j ; MÞ: CH maintains an initially empty list S which contains tuples ð query Sendð Q n i;j ; MÞ (if M -k; CH sets M n j;i ¼ M; otherwise, at the end of the protocol, a message will be returned; if Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ. On receiving Q n i;j is in Accepted, then CH sets this message to be M n j;i ), CH does as follows.</cell></row><row><cell cols="2">If n ¼ T; ID i ¼ ID I and ID j ¼ ID J , set SK n i;j ¼ r n i;j ¼ null; M n i;j ¼ bP, return M n i;j ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ to S. Otherwise, choose a random r n i;j 2 Z Ã q , compute M n i;j ¼ r n i;j P, return M n i;j as answer, set SK n as the answer and add i;j ¼ null and add ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ to S.</cell></row><row><cell cols="2">Revealð Q n i;j Þ: On receiving this query, CH looks up the list S for a tuple ð Q n i;j ; r n i;j ; M n i;j ; M n j;i ; P n i ; P n j ; SK n i;j Þ. If SK n i;j -null; CH re-turns SK n i;j as the answer. Otherwise, CH does as follows.</cell></row><row><cell>Abort if n ¼ T; ID i ¼ ID I and ID j ¼ ID J , or Else if there exists a tuple ðID a i ; ID b i ; R a i ; R b Q n i;j is the oracle who has a matching conversation with i ; X</cell><cell>Q T I;J (Event 3).</cell></row></table><note><p>i Þ: i ; y i ; P a i ; P b i ; Y</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>sH 1 ðID i ÞÞ ¼ y i ; P n At some point, A will ask a Test query to some oracle. If A does not choose one of the oracles Q T I;J to ask the test query, then CH aborts (Event 4). Else if A does pick Q T I;J for the Test query, CH simply outputs a random value in f0; 1g l . Once A finishes the queries and returns her guess bit (a tuple ð Q T I;J ; null; cP; M T J;I ; P T I ; P T J ; SK T I;J Þ must be in S), CH proceeds as follows. For every tuple in H 2 which is indexed by ðR a i ; R b i ; P a i ; P b i ; Y b i ; Z i Þ, if Q T I;J is an initiator oracle and there is a tuple in H 2 such that P b i ¼ aP; R a i ¼ bP; CH randomly chooses Y j from H 2</figDesc><table><row><cell cols="2">Else, randomly sample SK n i;j 2 f0; 1g l and return SK n i;j as the answer.</cell></row><row><cell>Testð</cell><cell>Q T I;J Þ:</cell></row><row><cell cols="2">¼ P a i ; P n i ¼ P b i ; eðP b i ; R a i Þ ¼ eðY i ; PÞ; r n i;j P n j ¼ Z i ; set SK n i;j ¼ h i and return SK n i;j as the answer.</cell><cell>j</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>L. Zhang et al. / Information Sciences 180 (2010) 1020-1030</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments and disclaimer</head><p>This work is supported by the Spanish Government through Projects TSI2007-65406-C03-01 ''E-AEGIS" and CONSOLIDER INGENIO 2010 CSD2007-00004 ''ARES", and by the Government of Catalonia under Grant 2009 SGR 1135, and by the Chinese NSF Projects 60673070, 60970114, 60970115 and 60970116 and the Natural Science Foundation of Jiangsu Province (No. BK2006217) of China. The fourth author is partly supported as an ICREA Acadèmia Researcher by the Government of Catalonia. The views of the author with the UNESCO Chair in Data Privacy do not necessarily reflect the position of UNESCO nor commit that organization.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Definition 3. A certificateless two-party AKA protocol is said to be secure if: <ref type="bibr" target="#b0">(1)</ref> In the presence of a benign adversary on Q n i;j and Q t j;i , both oracles always agree on the same session key, and this key is distributed uniformly at random. <ref type="bibr">(</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) For any adversary, Advantage</head><p>A ðkÞ is negligible.</p><p>Similarly to <ref type="bibr" target="#b8">[9]</ref>, if a certificateless two-party AKA protocol is secure under Definition 3, it achieves implicit mutual key authentication and the following general security properties: known-key security, key-compromise impersonation, unknown key-share and partial forward secrecy. The key control property can be easily achieved and we do not elaborate on it here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">An efficient certificateless two-party AKA protocol</head><p>Our protocol is implemented in bilinear pairings which have been extensively exploited to devise efficient cryptosystems <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b27">28]</ref>. We briefly review the basic notions of bilinear pairings. Let G 1 be an additive group of prime order q and G 2 be a multiplicative group of the same order. A mapping e : G 1 Â G 1 ! G 2 is called a bilinear map if it satisfies the following properties:</p><p>(1)</p><p>(3) Computability: There exists an efficient algorithm to compute eðP; Q Þ for any P; Q 2 G 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Protocol description</head><p>Motivated by <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b28">29]</ref>, we construct a secure certificateless two-party AKA protocol as follows.</p><p>Setup: On input a security parameter ', this algorithm runs as follows.</p><p>(1)</p><p>Select a cyclic additive group G 1 of prime order q, a cyclic multiplicative group G 2 of the same order, a generator P of G 1 , and a bilinear map e :</p><p>Choose a random master-key s 2 Z Ã q and set P 0 ¼ sP.</p><p>Choose cryptographic hash functions</p><p>1 ! f0; 1g l . The system parameters are params = (G 1 ; G 2 ; e; P; P 0 ; H 1 ; H 2 ; l). The master-key is s 2 Z Ã q . Partial-Private-Key-Extract: This algorithm takes as input params, the master-key s and an entity's identity ID i 2 f0; 1g Ã , and generates the partial private key for the entity as follows. <ref type="bibr" target="#b0">(1)</ref> Compute</p><p>Output the partial private key D i ¼ sQ i . Set-Secret-Value: This algorithm takes as input params, an entity's identity ID i , and a random value x i 2 Z Ã q . It outputs x i as the entity's secret value. Set-Private-Key: This algorithm takes as input params, an entity's identity ID i , the entity's partial private key D i and the entity's secret value x i 2 Z Ã q . The output of the algorithm is the private key S i ¼ ðx i ; D i Þ. Set-Public-Key: This algorithm takes as input params, an entity's identity ID i , and the entity's secret value x i 2 Z Ã q to produce the entity's public key P i ¼ x i P. Key-Agreement: Assume that an entity A with identity ID A has private key S A ¼ ðx A ; D A Þ and public key P A ¼ x A P, an entity B with identity ID B has private key S B ¼ ðx B ; D B Þ and public key P B ¼ x B P. A and B run the protocol as follows.</p><p>(1)</p><p>A randomly chooses r A 2 Z Ã q , computes R A ¼ r A P and sends ðID A ;</p><p>When B receives ðID A ; P A ; R A Þ from A, she selects r B 2 Z Ã q at random, computes R B ¼ r B P, and sends ðID B ; P B ; R B Þ to A. Finally, B computes the session key</p><p>In such a protocol run, the session ID of the protocol instance is</p><p>We briefly check the correctness of the protocol. Since</p><p>it is easy too see K AB ¼ K BA holds. Hence, the correctness of the protocol holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Security analysis</head><p>The security of our protocol relies on the standard CDH and BDH assumptions, which are briefly reviewed in the sequel.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Al-Riyami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Certificateless public key cryptography</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2894</biblScope>
			<biblScope unit="page" from="452" to="473" />
		</imprint>
	</monogr>
	<note>Proceedings of the ASIACRYPT 2003</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Entity authentication and key distribution</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the CRYPTO 1993</title>
		<meeting>the CRYPTO 1993</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">773</biblScope>
			<biblScope unit="page" from="232" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Random oracles are practical: a paradigm for designing efficient protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM CCCS 1993</title>
		<meeting>the ACM CCCS 1993</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Authenticated key exchange secure against dictionary attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the EUROCRYPT 2000</title>
		<meeting>the EUROCRYPT 2000</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1807</biblScope>
			<biblScope unit="page" from="139" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Key agreement protocols and their security analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blake-Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Crytography and Coding 1997</title>
		<meeting>the Crytography and Coding 1997</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1355</biblScope>
			<biblScope unit="page" from="30" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the Weil pairing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the CRYPTO</title>
		<meeting>the CRYPTO</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="213" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ins.2009.06.017</idno>
	</analytic>
	<monogr>
		<title level="m">Certificateless threshold ring signature</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Identity-based key agreement protocols from pairings</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Information Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="213" to="241" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Identity based authenticated key agreement from pairings</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kudla</surname></persName>
		</author>
		<ptr target="&lt;http://eprint.iacr.org/2002/184&gt;" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2002">2002/184, 2002</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the indistinguishability-based security model of key agreement protocols-simple cases</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nistazakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Comley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vasiu</surname></persName>
		</author>
		<ptr target="&lt;http://eprint.iacr.org/2005/129&gt;" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2005">2005/129</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">New directions in cryptography</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="644" to="654" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Certificateless undeniable signature scheme</title>
		<author>
			<persName><forename type="first">S</forename><surname>Duan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">178</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="742" to="755" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design of DL-based certificateless digital signatures</title>
		<author>
			<persName><forename type="first">L</forename><surname>Harn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="789" to="793" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<author>
			<persName><forename type="first">X</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACISP 2007</title>
		<meeting>the ACISP 2007</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4586</biblScope>
			<biblScope unit="page" from="308" to="322" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Modular security proofs for key agreement protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kudla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ASIACRYPT 2005</title>
		<meeting>the ASIACRYPT 2005</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3788</biblScope>
			<biblScope unit="page" from="549" to="565" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An enhanced authentication and key agreement mechanism for SIP using certificateless public-key cryptography</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE ICYCS</title>
		<meeting>the IEEE ICYCS</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="1577" to="1582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Certificateless authenticated two-party key agreement protocols</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ASIAN 2006</title>
		<meeting>the ASIAN 2006</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4435</biblScope>
			<biblScope unit="page" from="37" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A new two-party identity-based authenticated key agreement</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mccullagh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barreto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the CT-RSA 2005</title>
		<meeting>the CT-RSA 2005</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3376</biblScope>
			<biblScope unit="page" from="262" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Identity-based instantaneous broadcast system in mobile ad-hoc networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 International Workshop on Mobile Systems, E-commerce and Agent Technology</title>
		<meeting>the 2004 International Workshop on Mobile Systems, E-commerce and Agent Technology</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="35" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The gap-problems: a new class of problems for the security of cryptographic schemes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the PKC 2001</title>
		<meeting>the PKC 2001</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1992</biblScope>
			<biblScope unit="page" from="104" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Identity based cryptosystems and signature schemes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the CRYPTO 1984</title>
		<meeting>the CRYPTO 1984</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">196</biblScope>
			<biblScope unit="page" from="47" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Two-party authenticated key agreement in certificateless public key cryptography</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wuhan University Journal of Natural Sciences</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="71" to="74" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient ID-based authenticated key agreement protocol based on the Weil pairing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronics Letters</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="653" to="654" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Breaking the short certificateless signature scheme</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">179</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="303" to="306" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An identity based authenticated key agreement protocol based on the Weil pairing</title>
		<author>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronics Letters</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="630" to="632" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A new provably secure authentication and key agreement mechanism for SIP using certificateless public-key cryptography</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Communications</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="2142" to="2149" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Certificateless authenticated key agreement based on the MTI/CO protocol</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Information and Computational Science</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="575" to="581" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<author>
			<persName><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Domingo-Ferrer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the EUROCRYPT 2009</title>
		<meeting>the EUROCRYPT 2009</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="153" to="170" />
		</imprint>
		<respStmt>
			<orgName>Asymmetric group key agreement</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A new efficient ID-based authenticated key agreement protocol</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<ptr target="&lt;http://eprint.iacr.org/2005/309&gt;" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2005">2005/309</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A new certificateless aggregate signature scheme</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Communications</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1079" to="1085" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
