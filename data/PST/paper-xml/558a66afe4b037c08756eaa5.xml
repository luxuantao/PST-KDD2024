<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Functional Coverage Driven Test Generation for Validation of Pipelined Processors</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2004-03-12">March 12, 2004</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Prabhat</forename><surname>Mishra</surname></persName>
							<email>pmishra@cecs.uci.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Center for Embedded Computer Systems</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92697</postCode>
									<settlement>Irvine</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nikil</forename><surname>Dutt</surname></persName>
							<email>dutt@cecs.uci.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Center for Embedded Computer Systems</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92697</postCode>
									<settlement>Irvine</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Functional Coverage Driven Test Generation for Validation of Pipelined Processors</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2004-03-12">March 12, 2004</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Functional verification of microprocessors is one of the most complex and expensive tasks in the current system-on-chip design process. A significant bottleneck in the validation of such systems is the lack of a suitable functional coverage metric. This report presents a functional coverage based test generation technique for pipelined architectures. The proposed methodology makes three important contributions. First, a general graph-theoretic model is developed that can capture the structure and behavior (instruction-set) of a wide variety of pipelined processors. Second, we propose a functional fault model that is used to define the functional coverage for pipelined architectures. Finally, test generation procedures are presented that accept the graph model of the architecture as input and generate test programs to detect all the faults in the functional fault model. Our experimental results on two pipelined processor models demonstrate that the number of test programs generated by our approach to obtain a fault coverage is an order of magnitude less than those generated by traditional random or constrained-random test generation techniques.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>As embedded systems continue to face increasingly higher performance requirements, deeply pipelined processor architectures are being employed to meet desired system performance. Functional validation of such programmable processors is one of the most complex and expensive tasks in the current Systems-on-Chip (SOC) design methodology. Simulation is the most widely used form of microprocessor verification: millions of cycles are spent during simulation using a combination of random and directed test cases in traditional validation flow. Several coverage measures are commonly used, such as code coverage, toggle coverage and fault coverage. Unfortunately, these measures do not have any direct relationship to the functionality of the device. For example, none of these determine if all possible interactions of hazards, stalls and exceptions are tested in a processor pipeline. Thus there is a need for a coverage metric based on the functionality of the design.</p><p>To define a useful functional coverage metric, we need to define a fault model of the design that is described at the functional level and independent of the implementation details. In this report, we present a functional fault model for pipelined processors. The fault model should be applicable to the wide varieties of today's microprocessors from various architectural domains (such as RISC, DSP, VLIW and Superscalar) that differ widely in terms of their structure (organization) and behavior (instruction-set). We have developed a graph-theoretic model that can capture a wide spectrum of pipelined processors, coprocessors, and memory subsystems. We have defined functional coverage based on the effects of faults in the fault model applied at the level of the graph-theoretic model. This allows us to compute functional coverage of a pipelined processor for a given set of random or constrained-random test sequences.</p><p>We have developed test generation procedures that accept the graph model of the pipelined processor as input and generate test programs to detect all the faults in the functional fault model. We applied our methodology on two pipelined processors: a VLIW implementation of the DLX architecture <ref type="bibr" target="#b3">[4]</ref>, and a RISC implementation of the SPARC V8 architecture <ref type="bibr" target="#b15">[16]</ref>. Our experimental results demonstrate two important aspects of our technique. First, it shows how our functional coverage can be used in an existing validation flow that uses random or directed-random test programs. Second, it demonstrates that the required number of test sequences generated by our algorithms to obtain a given fault (functional) coverage is an order of magnitude less than the random or constrained-random test programs.</p><p>The rest of the report is organized as follows. Section 2 presents related work addressing validation of pipelined processors. Section 3 presents a graph-based modeling of pipelined architectures. The functional fault models are described in Section 4. Section 5 defines the functional coverage based on the fault model. Section 6 presents the test generation procedures followed by a case study in Section 7. Finally, Section 8 concludes the report.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Traditionally, validation of a microprocessor has been performed by applying a combination of random and directed test programs using simulation techniques. Many techniques have been proposed for generation of directed test programs. Aharon et al. <ref type="bibr" target="#b2">[3]</ref> have proposed a test program generation methodology for functional verification of PowerPC processors in IBM. Miyake et al. <ref type="bibr" target="#b4">[5]</ref> have presented a combined scheme of random test generation and specific sequence generation. A coverage driven test generation technique is presented by Fine et al. <ref type="bibr" target="#b0">[1]</ref>. Shen et al. <ref type="bibr" target="#b7">[8]</ref> have used the processor to generate tests at run-time by self-modifying code, and performed signature comparison with the one obtained from emulation. These techniques do not consider pipeline behavior for generating test programs.</p><p>Ur and Yadin <ref type="bibr" target="#b13">[14]</ref> presented a method for generation of assembler test programs that systematically probe the micro-architecture of a PowerPC processor. Iwashita et al. <ref type="bibr" target="#b10">[11]</ref> use an FSM based processor modeling to automatically generate test programs. Campenhout et al. <ref type="bibr" target="#b12">[13]</ref> have proposed a test generation algorithm that integrates high-level treatment of the datapath with low-level treatment of the controller. Kohno et al. <ref type="bibr" target="#b9">[10]</ref> have presented a tool that generates test programs for verifying pipeline behavior in the presence of hazards and exceptions. Ho et al. <ref type="bibr" target="#b1">[2]</ref> have presented a technique for generating test vectors for verifying the corner cases of the design. Mishra et al. <ref type="bibr" target="#b8">[9]</ref> have proposed a graph-based functional test program generation technique for pipelined processors using model checking. None of these techniques provides a comprehensive metric to measure the coverage of the pipeline interactions.</p><p>Many researchers have proposed techniques for generation of functional test programs for manufacturing testing of microprocessors ( <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b11">[12]</ref>). These techniques use stuck-at fault coverage to demonstrate the quality of the generated tests. The applicability of these test programs are not shown for functional validation of microprocessors. To the best of our knowledge, there are no previous approaches that describe functional fault models for pipelined architectures, use it to define functional coverage, and generate test programs to detect all the functional faults in the fault model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Architecture Model of a Pipelined Processor</head><p>Modeling plays a central role in the generation of test programs for validation of pipelined processors. There are three important aspects that need to be considered for designing an efficient architecture model. First, the architecture model should be based on a functional description available in a typical user's manual. Second, the model should be able to treat the processor organization and instruction-set as parameters of the test generation procedures. Finally, the architecture model should be able to support a functional fault model describing faults in various computations. This will allow fault model developers to describe faulty behavior without knowing the details of the implementation. In this section, we briefly describe how the graph model captures the structure and behavior of the processor using the information available in the architecture manual.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Structure</head><p>The structure of an architecture pipeline is based on a block diagram view available in the processor manual, and is modeled as a graph G S = (V S , E S ), where V S denotes a set of components and E S consists of a set of edges. V S consists of two types of components: V unit and V storage . V unit is a set of functional units (e.g., ALU) and V storage is a set of storages (e.g., register files). E S consists of two types of edges. E data trans f er is a set of data-transfer edges and E pipeline is a set of pipeline edges. An edge (pipeline or data-transfer) indicates connectivity between two components. A data-transfer edge transfers data between units and storages. A pipeline edge transfers instruction (operation) between two units.</p><formula xml:id="formula_0">V S = V unit ∪V storage E S = E data trans f er ∪ E pipeline E data trans f er ⊆ {V unit , V storage } × {V unit , V storage } E pipeline ⊆ V unit ×V unit</formula><p>For illustration, we use a simple multi-issue architecture consisting of a processor, a co-processor and a memory subsystem. Figure <ref type="figure" target="#fig_0">1</ref> shows the graph-based model of this architecture that can issue up to three operations (an ALU operation, a memory access operation, and a coprocessor operation) per cycle. In the figure, oval boxes denote units, dotted ovals are storages, bold edges are pipeline edges, and dotted edges are data-transfer edges. A path from a root node (e.g., Fetch) to a leaf node (e.g, WriteBack) consisting of units and pipeline edges is called a pipeline path. For example, one of the pipeline path is {Fetch, Decode, ALU, WriteBack}. A path from a unit to main memory or register file consisting of storages and data-transfer edges is called a data-transfer path. For example, {MemCntrl, L1, L2, MainMemory} is a data-transfer path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Behavior</head><p>The behavior of the architecture is typically captured by the instruction-set (ISA) description in the processor manual. It consists of a set of operations<ref type="foot" target="#foot_0">1</ref> that can be executed on the architecture. Each operation in turn consists of a set of fields (e.g. opcode, arguments) that specify, at an abstract level, the execution semantics of the operation. We model the behavior as a graph G B = (V B , E B ), where V B is a set of nodes and E B is a set of edges. The nodes represent the fields of each operation, while the edges represent orderings between the fields. The behavior graph G B is a set of disjointed sub-graphs, and each sub-graph is called an operation graph (or simply an operation). Figure <ref type="figure" target="#fig_1">2</ref> describes a portion of the behavior (consisting of two operation graphs) for the example processor shown in Figure <ref type="figure" target="#fig_0">1</ref>.</p><formula xml:id="formula_1">V B = V opcode ∪V argument E B = E operation ∪ E execution E operation ⊆ V opcode ×V argument ∪ V argument ×V argument E execution ⊆ V argument ×V argument ∪ V argument ×V opcode</formula><p>Nodes are of two types. V opcode is a set of opcode nodes that represent the opcode (i.e. mnemonic), and V argument is a set of argument nodes that represent argument fields (i.e., source and destination arguments). In Figure <ref type="figure" target="#fig_1">2</ref>, the ADD and STORE nodes are opcode nodes, while the others are argument nodes. Edges are also of two types. E operation is a set of operation edges that link the fields of the operation and also specify the syntactical ordering between them. On the other hand, E execution is a set of execution edges that specify the execution ordering between the fields. In Figure <ref type="figure" target="#fig_1">2</ref>, the solid edges represent operation edges while the dotted edges represent execution edges. For the ADD operation, the operation edges specify that the syntactical ordering is opcode followed by DEST, SRC1 and SRC2 arguments (in that order), and the execution edges specify that the SRC1 and SRC2 arguments are executed (i.e., read) before the ADD operation is performed. Finally, the DEST argument is written. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. A Fragment of the Behavior Graph</head><p>The architecture manual also provides information regarding the mapping between the structure and behavior. We define a set of mapping functions that map nodes in the structure to nodes in the behavior (and vice-versa). The unit-to-opcode (opcode-to-unit) mapping is a bi-directional function that maps unit nodes in the structure to opcode nodes in the behavior. The unit-to-opcode mappings for the architecture in Figure <ref type="figure" target="#fig_0">1</ref> include mappings from Fetch unit to opcodes {ADD, STORE}, ALU unit to opcode ADD, AddrCalc unit to opcode STORE etc. The argument-to-storage (storage-to-argument) mapping is a bi-directional function that maps argument nodes in the behavior to storage nodes in the structure. For example, the argument-storage mappings for the ADD operation are mappings from {DEST, SRC1, SRC2} to RegisterFile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Functional Fault Models</head><p>In this section, we present fault models for various functions in a pipelined processor. We categorize various computations in a pipelined processor into register read/write, operation execution, execution path and pipeline execution. We outline the underlying fault mechanisms for each fault model, and describe the effects of these faults at the level of the architecture model presented in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Fault Model for Register Read/Write</head><p>To ensure fault-free execution, all registers should be written and read correctly. In the presence of a fault, reading of a register will not return the previously written value. The fault could be due to an error in reading, register decoding, register storage, or prior writing. The outcome is an unexpected value. If V R i is written in register R i and read back, the output should be V R i in fault-free case. In the presence of a fault, output = V R i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Fault Model for Operation Execution</head><p>All operations must execute correctly if there are no faults. In the presence of a fault, the output of the computation is different from the expected output. The fault could be due to an error in operation decoding, control generation or final computation. Erroneous operation decoding might return an incorrect opcode. This can happen if incorrect bits are decoded for the opcode. Selection of incorrect bits will also lead to erroneous decoding of source and destination operands. Even if the decoding is correct, due to an error in control generation an incorrect computation unit can be enabled. Finally, the computation unit can be faulty. The outcome is an unexpected result. Let val i , where val i = f opcode i (src 1 , src 2 , ...), denote the result of computing the operation "opcode i dest, src 1 , src 2 , ...". In the fault-free case, the destination will contain the value val i . Under a fault, the destination is not equal to val i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Fault Model for Execution Path</head><p>During execution of an operation in the pipeline, one pipeline path and one or more data-transfer paths get activated. We define all these activated paths as the execution path for that operation. An execution path ep op i is faulty if it produces incorrect result during execution of operation op i in the pipeline. The fault could be due to an error in one of the paths (pipeline or data-transfer) in the execution path. A path is faulty if any one of its nodes or edges are faulty. A node is faulty if it accepts valid inputs and produces incorrect outputs. An edge is faulty if it does not transfer the data/instruction correctly.</p><p>Without loss of generality, let us assume that the processor has p pipeline paths (PP = ∪ p i=1 pp i ) and q data-transfer paths (DP = ∪ q j=1 d p j ). Furthermore, each pipeline path pp i is connected to a set of data-transfer paths DPgrp i (DPgrp i ⊆ DP). During execution of an operation op i in the pipeline path pp i , a set of data-transfer paths DP op i (DP op i ⊆ DPgrp i ) are used (activated). Therefore, the execution path ep op i for operation op i is, ep op i = pp i ∪ DP op i . Let us assume, operation op i has one opcode (opcode i ), m sources (∪ m j=1 src j ) and n destinations (∪ n k=1 dest k ). Each data-transfer path d p i (d p i ∈ DP op i ) is activated to read one of the sources or write one of the destinations of op i in execution path ep op i . Let val i , where val i = f opcode i (∪ m j=1 src j ), denote the result of computing the operation op i in execution path ep i . The val i has n components (∪ n k=1 val k i ). In the fault-free case, the destinations will contain correct values, i.e., ∀k dest k = val k i . Under a fault, at least one of the destinations will have incorrect value, i.e., ∃k dest k = val k i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Fault Model for Pipeline Execution</head><p>The previous fault models consider only one operation at a time. An implementation of a pipeline is faulty if it produces incorrect result due to execution of multiple operations in the pipeline. The fault could be due to incorrect implementation of the pipeline controller. The faulty controller might have erroneous hazard detection, incorrect stalling, erroneous flushing, or wrong exception handling schemes.</p><p>Let us define stall set for a unit u (SS u say) as all possible ways to stall that unit. Therefore, the stall set for the architecture StallSet = ∪ ∀u SS u . Let us also define exception set for a unit u (ES u ) as all possible ways to create an exception in that unit. We define the set of all possible multiple exception scenarios as MESS. Hence, the exception set for the architecture ExceptionSet = ∪ ∀u ES u ∪ MESS. We consider two types of pipeline interactions: stalls and exceptions. Therefore, all possible pipeline interactions (PIs) can be defined as: PIs = StallSet ∪ ExceptionSet. Let us assume a sequence of operations ops pi causes a pipeline interaction pi (i.e., pi ∈ PIs), and updates n storage locations. Let val pi denote the result of computing the operation sequence ops pi . The val pi has n components (∪ n k=1 val k pi ). In the fault-free case, the destinations will contain correct values, i.e., ∀k dest k = val k i . Under a fault, at least one of the destinations will have incorrect value, i.e., ∃k dest k = val k i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Functional Coverage Estimation</head><p>We define functional coverage based on the fault models described in Section 4. Consider the following cases:</p><p>• a fault in register read/write is covered if the register is written first and read later.</p><p>• a fault in operation execution is covered if the operation is performed, and the result of the computation is read.</p><p>• a fault in execution path is covered if the execution path is activated, and the result of the computation is read.</p><p>• a fault in pipeline execution is covered if the fault is activated due to execution of multiple operations in the pipeline, and the result of the computation is read.</p><p>We compute functional coverage of a pipelined processor for a given set of test programs as the ratio between the number of faults detected by the test programs and the total number of detectable faults in the fault model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Test Generation Techniques</head><p>In this section, we present test generation procedures for detecting faults covered by the fault models presented in Section 4. Different architectures have specific instructions to observe the contents of registers and memories. In this report, we use load and store instructions to make the register and memory contents observable at the output data bus. We first describe a procedure createTestProgram that is used by the test generation algorithms. Procedure 1 accepts a list of operations as input and returns modified list. It assigns appropriate values to the unspecified locations (opcodes or operands). Next, it creates initialization instructions for the uninitialized source operands. It also creates instructions to read the destination operands. Finally, it returns the modified list that contains the initialization operations, modified input operations, and the read operations (in that order).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Test Generation for Register Read/Write</head><p>Algorithm 1 presents the procedure for generating test programs for detecting faults in register read/write functions. The fault model for the register read/write function is described in Section 4.1. For each register in the architecture, the algorithm generates an instruction sequence consisting of a write followed by a read for that register. The function GenerateUniqueValue returns unique value for each register based on register name. A test program for register R i will consist of two assembly instructions: "MOVI R i , #val i " and "STORE R i , R j , #0". The moveimmediate (MOVI) instruction writes val i in register R i . The STORE instruction reads the content of R i and writes it in memory addressed by R j (offset 0). Proof Algorithm 1 generates one test program for each register in the architecture. A test program consists of two instructions -a write followed by a read. Each register is written with a specific value. If there is a fault in register read/write function, the value read would be different than the written value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Test Generation for Operation Execution</head><p>Algorithm 2 presents the procedure for generating test programs for detecting faults in operation execution. The fault model for the operation execution is described in Section 4.2. The algorithm traverses the behavior graph of the architecture, and generates one test program for each operation graph using createTestProgram. For example, a test program for the operation graph with opcode ADD in Figure <ref type="figure" target="#fig_1">2</ref> has three operations: two initialization operations ("MOV R3 #333", "MOV R5 #212") followed by the ADD operation ("ADD R2 R3 R5"), followed by the reading of the result ("STORE R2, Rx, #0"). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The test sequence generated using Algorithm is capable of detecting any detectable fault in the operation execution fault model.</head><p>Proof Algorithm 2 generates one test program for each operation in the architecture. If there is a fault in operation execution, the computed result would be different than the expected output.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Test Generation for Execution Path</head><p>Algorithm 3 presents the procedure for generating test programs for detecting faults in execution path. The fault model for the execution path is described in Section 4.3. The algorithm traverses the structure graph of the architecture, and for each pipeline path it generates a group of operations supported by that path. It randomly selects one operation from each operation group. There are two possibilities. If all the edges in the execution path (containing the pipeline path) are activated by the selected operation, the algorithm generates all possible source/destination assignments for that operation. However, if different operations in the operation group activates different set of edges in the execution path, it generates all possible source/destination assignments for each operation in the operation group. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>The proof is by contradiction. The only way a detectable fault will be missed is if a pipeline or data-transfer edge is not activated (used) by the generated test programs. Let us assume, an edge e pp is not activated by any operation. If the e pp is not part of (connected to) any pipeline path, the to generate stall conditions using structural hazards. Finally, the last loop (L5) computes test sequences for multiple exceptions involving more than one units. The composeTestProgram function uses ordered<ref type="foot" target="#foot_1">2</ref> n-tuple units and combines their test programs. The function also removes dependencies across test programs to ensure the generation of multiple exceptions during the execution of the combined test program. Theorem 6. <ref type="bibr" target="#b3">4</ref> The test sequence generated using Algorithm 4 is capable of detecting any detectable fault in the pipeline execution fault model.</p><p>Proof Algorithm 4 generates test programs for all possible interactions during pipeline execution. The first for loop (L1) generates all possible hazard and exception scenarions for each functional unit in the pipeline. The test programs for creating all possible exceptions in each node are generated by the second for loop (L2). The third for loop (L3) generates test programs for creating all possible data and control hazards in each node. Similarly, the fourth loop (L4) generates tests for creating all possible structural hazards in a node. Finally, the last loop (L5) generates test programs for creating all possible multiple exception scenarios in the pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">A Case Study</head><p>We applied our methodology on two pipelined architectures: a VLIW implementation of the DLX architecture <ref type="bibr" target="#b3">[4]</ref>, and a RISC implementation of the SPARC V8 architecture <ref type="bibr" target="#b15">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Experimental Setup</head><p>We developed our test generation and coverage analysis framework using Verisity's Specman Elite <ref type="bibr">[18]</ref>. We captured executable specification of the architectures using Verisity's "e" language. This includes description of 91 instructions for the DLX, and 106 instructions for the SPARC V8 architecture. We refer to these as specifications. We implemented a VLIW version of the DLX architecture using Verisity's "e" language. Figure <ref type="figure" target="#fig_3">3</ref> shows the simplified version of the VLIW DLX architecture. It contains 5 pipeline stages: fetch, decode, execute, memory and writeback. The execute stage has four parallel execution paths: an ALU, a four-stage floating-point adder, a seven-stage multiplier, and a multi-cycle divider. We used the LEON2 processor <ref type="bibr" target="#b16">[17]</ref> that is a VHDL model of a 32-bit processor compliant with the SPARC V8 architecture. We refer these models (VLIW DLX and LEON2) as implementations.</p><p>Our framework generates test programs in three different ways: random, constrained-random, and our approach. Specman Elite [18] is used to generate both random and constrained-random test programs from the specification. Several constraints are used for constrained-random test generation. For example, to generate test programs for register read/write, we used the highest probability for choosing register-type operations in DLX. Since register-type operations have 3 register operands, the chances of reading/writing registers are higher than immediate type (2 register operands) or branch type (one register operand) operations. The test programs generated by our approach uses the algorithms described in Section 6. To ensure that the generated test programs are executed correctly, our framework applies the test programs on the implementation as well as the specification, and compares the contents of the program counter, registers and memory locations after execution of each test program as shown in Figure <ref type="figure" target="#fig_4">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pipeline edge</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data-transfer edge</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functional unit Storage</head><p>The Specman Elite framework allows definition of various coverage measures that enables us to compute the functional coverage described in Section 5. We defined each entry in the instruction definition (e.g. opcode, destination and sources) as a coverage item in Specman Elite. The coverage for the destination operand gives the measure of which registers are written. Similarly, the coverage of source operands gives the measure of which registers are read. We used a variable for each register to identify a read after a write. Computation of coverage for operation execution is done by observing the coverage of the opcode field. The computation of coverage for execution path is performed by observing if all the registers are used for computation of all/selected opcodes. This is performed by using cross coverage of instruction fields in Specman Elite that computes every combination of values of the fields. Finally, we compute the coverage for pipeline execution by maintaining variables for stalls and exceptions in each unit. The coverage for multiple exceptions is obtained by performing cross coverage of the exception variables (events) that occur simultaneously.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Register</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Results</head><p>In this section, we compare the test programs generated by our approach against the random and constrained-random test programs generated by the Specman Elite. The number 100% implies that the generated test programs covered all the faults in that fault model. For example, the Random technique covered all the faults in "Register Read/Write" function using 3900 tests. The number of test programs for operation execution are similar for both random and constrained-random approaches. This is because the constraint used in this case (same probability for all opcodes) may be the default option used in random test generation approach.</p><p>We performed an initial study to evaluate the quality of our functional fault model using existing coverage measures. Table <ref type="table" target="#tab_6">2</ref> compares our functional coverage against HDL code coverage. The first column indicates the functional fault models. The second column presents the minimum number of test programs necessary to cover all the functional faults in the corresponding fault model. The last column presents the code coverage obtained for the DLX implementation <ref type="bibr" target="#b14">[15]</ref> using the test programs mentioned in the second column. As expected, our fault model performed well -a small number of test programs generated a high code coverage. Table <ref type="table" target="#tab_7">3</ref> shows the comparative results for different test generation approaches for the LEON2 processor. The trend is similar in terms of number of operations and fault coverage for both the DLX and LEON2 architectures. The random and constrained-random approaches obtained 100% functional coverage for the first three fault models using an order of magnitude more test vectors than our approach. We analyzed the cause for the low fault coverage in pipeline execution for the random and constraint-driven test generation approaches. These two approaches covered all the stall scenarios and majority of the single exception faults. However, they could not activate any multiple exception scenarios. Due to bigger pipeline structure (larger set of pipeline interactions) in the VLIW DLX, it has lower fault coverage than the LEON2 architecture in pipeline execution. This functional coverage problem will be even more important for today's deeply pipelined embedded processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>Functional verification is widely acknowledged as a major bottleneck in microprocessor design due to lack of a suitable functional coverage estimation technique. This report presented a functional coverage based test generation technique for pipelined architectures. The methodology made three important contributions. First, a general graph model was developed that can capture the structure and behavior (instruction-set) of a wide variety of pipelined processors. Second, we proposed a functional fault model that is used in defining the functional coverage. Finally, test generation procedures were presented that accept the graph model of the microprocessor as input and generate test programs to detect all the faults in the functional fault model. We are able to measure the goodness of a given set of random test sequences using our functional coverage metric. Our experimental results demonstrate that the required number of test sequences generated by our algorithms to obtain a given fault (functional) coverage is an order of magnitude less than the random or constrained-random test programs.</p><p>Our future work includes application of these test programs for functional validation of today's microprocessors. We also plan to perform further comparative studies with our functional coverage metric against existing coverage measures, such as code coverage, FSM coverage and stuck-at coverage.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. A Structure Graph of a Simple Architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 2 :</head><label>2</label><figDesc>Test Generation for Operation Execution Input: Graph model of the architecture G. Output: Test programs for detecting faults in operation execution. begin /*** TestProgramList = {} ***/ for each operation oper in architecture G test prog oper = createTestProgram(oper); TestProgramList = TestProgramList ∪ test prog oper ; endfor return TestProgramList. end Theorem 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 3 : 3</head><label>33</label><figDesc>Test Generation for Execution Path Input: Graph model of the architecture G. Output: Test programs for detecting faults in execution path. begin /*** TestProgramList = {} ***/ for each pipeline path path in architecture G opgroup path = operations supported in path. exec path = path and all data-transfer paths connected to it oper path = randomly select an operation from opgroup path if (oper path activates all edges in exec path ) ops path = oper path else ops path = opgroup path endif for all operations oper in ops path for all source/destination operands opnd of oper for all possible register values val of opnd newOper = assign val to opnd of oper. test prog oper = createTestProgram(newOper). TestProgramList = TestProgramList ∪ test prog oper ; The test sequence generated using Algorithm 3 is capable of detecting any detectable fault in the execution path fault model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. VLIW DLX architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Validation of the implementation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Operation Edge Execution Edge Argument Node Opcode Node SRC1 STORE SRC OFFSET SRC2 ADD DEST SRC1</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The test sequence generated using Algorithm 1 is capable of detecting any detectable fault in the register read/write fault model.</figDesc><table><row><cell>Algorithm 1: Test Generation for Register Read/Write</cell></row><row><cell>Input: Graph model of the architecture G.</cell></row><row><cell>Output: Test programs for detecting faults in register read/write.</cell></row><row><cell>begin /*** TestProgramList = {} ***/</cell></row><row><cell>for each register reg in architecture G</cell></row><row><cell>value reg = GenerateUniqueValue(reg);</cell></row><row><cell>writeInst = an instruction that writes value reg in register reg.</cell></row><row><cell>test prog reg = createTestProgram(writeInst)</cell></row><row><cell>TestProgramList = TestProgramList ∪ test prog reg ;</cell></row><row><cell>endfor</cell></row><row><cell>return TestProgramList.</cell></row><row><cell>end</cell></row><row><cell>Theorem 6.1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Memory PC IMP: Implementation REF: Reference Model REF.Memory == IMP.Memory ? REF.RegFile == IMP.RegFile ? REF.PC == IMP.PC ? Implementation successfully executed the test program Incorrect Implementation . . ADD R1, R2, R3 /* Test Program */ XORI R7, R5, 0x43 . . .</head><label></label><figDesc></figDesc><table><row><cell></cell><cell>Initialize</cell><cell>PC</cell><cell>L o a d P r o g r a m</cell><cell cols="2">Initialize</cell><cell>Fetch</cell><cell>Load Program</cell></row><row><cell>File</cell><cell cols="2">EXECUTE</cell><cell>Memory</cell><cell>Register File</cell><cell>IntALU</cell><cell>... Decode . .</cell><cell>. .</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>.</cell><cell>.</cell><cell>LdSt</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Write Back</cell></row><row><cell cols="2">Completed Execution</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Completed Execution</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Yes</cell><cell cols="2">No</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Table 1 shows the comparative results for the DLX architecture. The rows indicate the fault models, and the columns indicate test generation techniques. An entry in the table has two numbers. The first one represents the minimum number of test programs generated by that test generation technique for that fault model. The second number (in parenthesis) represents the functional coverage obtained by the generated test programs for that fault model.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1 . Test Programs for validation of DLX architecture</head><label>1</label><figDesc></figDesc><table><row><cell>Fault Models</cell><cell cols="3">Test Generation Techniques</cell></row><row><cell></cell><cell>Random</cell><cell cols="2">Constrained Our Approach</cell></row><row><cell>Register Read/Write</cell><cell>3900 (100%)</cell><cell>750 (100%)</cell><cell>130 (100%)</cell></row><row><cell>Operation Execution</cell><cell>437 (100%)</cell><cell>443 (100%)</cell><cell>182 (100%)</cell></row><row><cell>Execution Path</cell><cell cols="2">12627 (100%) 1126 (100%)</cell><cell>320 (100%)</cell></row><row><cell>Pipeline Execution</cell><cell cols="2">30000 (25%) 30000 (30%)</cell><cell>626 (100%)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 . Quality of the proposed functional fault model</head><label>2</label><figDesc></figDesc><table><row><cell>Fault Models</cell><cell cols="2">Test Programs HDL Code Coverage</cell></row><row><cell>Register Read/Write</cell><cell>130</cell><cell>85%</cell></row><row><cell>Operation Execution</cell><cell>182</cell><cell>91%</cell></row><row><cell>Execution Path</cell><cell>320</cell><cell>86%</cell></row><row><cell>Pipeline Execution</cell><cell>626</cell><cell>100%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 . Test Programs for Validation of LEON2 Processor</head><label>3</label><figDesc></figDesc><table><row><cell>Fault Models</cell><cell cols="3">Test Generation Techniques</cell></row><row><cell></cell><cell>Random</cell><cell cols="2">Constrained Our Approach</cell></row><row><cell cols="2">Register Read/Write 1746 (100%)</cell><cell>654 (100%)</cell><cell>130 (100%)</cell></row><row><cell>Operation Execution</cell><cell>416 (100%)</cell><cell>467 (100%)</cell><cell>212 (100%)</cell></row><row><cell>Execution Path</cell><cell>1500 (100%)</cell><cell>475 (100%)</cell><cell>192 (100%)</cell></row><row><cell>Pipeline Execution</cell><cell cols="2">30000 (40%) 30000 (50%)</cell><cell>248 (100%)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">In this report we use the terms operation and instruction interchangeably.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">The unit closer to completion has higher order</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Acknowledgments</head><p>This work was partially supported by NSF grants CCR-0203813 and CCR-0205712. We would like to thank Verisity [18]  for giving us access to the Specman Elite tool for our research. We also like to thank Dr. Yaron Kashai for his help during this work.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>fault is not detectable. Let us further assume, e pp is part of pipeline path pp. If the pipeline path pp does not support any operations, the fault is not detectable. If it does support operations, Algorithm 3 will generate operation sequences that exercises this pipeline path and all the data-transfer paths connected to it. Since, the edge e pp is connected to pipeline path pp, it is activated. Algorithm 4 presents the procedure for generating test programs for detecting faults in pipeline execution. The fault model for the pipeline execution is described in Section 4.4. The first loop (L1) traverses the structure graph of the architecture in a bottom-up manner, starting at leaf nodes. The second loop (L2) computes test programs for generating all possible exceptions in each unit using templates. The third loop (L3) computes test programs for creating stall conditions due to data and control hazards in each unit using templates. The fourth loop (L4) creates test programs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Test Generation for Pipeline Execution</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Coverage directed test generation for functional verification using bayesian networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ziv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation Conference (DAC)</title>
				<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="286" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Architecture validation for processors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">A</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Symposium on Computer Architecture (ISCA)</title>
				<meeting>International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Test program generation for functional verification of PowerPC processors in IBM</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aharon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Levinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lichtenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Malka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Metzger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Molcho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Shurek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation Conference (DAC)</title>
				<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="279" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Computer Architecture: A Quantitative Approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Patterson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Mateo, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatic test generation for functional verification of microprocessors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Miyake</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ueda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nishiyama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Asian Test Symposium (ATS)</title>
				<meeting>Asian Test Symposium (ATS)</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="292" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fully automatic test program generation for microprocessor cores</title>
		<author>
			<persName><forename type="first">F</forename><surname>Corno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cumani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reorda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Squillero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation and Test in Europe (DATE)</title>
				<meeting>Design Automation and Test in Europe (DATE)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="1006" to="1011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Test generation for microprocessors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Abraham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers, C</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="429" to="441" />
			<date type="published" when="1980-06">June 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Functional verification of the equator MAP1000 microprocessor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hurson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kinkade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gervasio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation Conference (DAC)</title>
				<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="169" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Graph-based functional test program generation for pipelined processors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation and Test in Europe (DATE)</title>
				<meeting>Design Automation and Test in Europe (DATE)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="182" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A new verification methodology for complex pipeline behavior</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Matsumoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation Conference (DAC)</title>
				<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="816" to="821" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic test pattern generation for pipelined processors</title>
		<author>
			<persName><forename type="first">H</forename><surname>Iwashita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kowatari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nakata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hirose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Computer-Aided Design</title>
				<meeting>International Conference on Computer-Aided Design</meeting>
		<imprint>
			<publisher>IC-CAD</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="580" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A scalable software-based self-test methodology for programmable processors</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation Conference (DAC)</title>
				<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="548" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">High-level test generation for design verification of pipelined microprocessors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Campenhout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mudge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation Conference (DAC)</title>
				<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="185" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Micro architecture coverage directed generation of test programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yadin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design Automation Conference (DAC)</title>
				<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="175" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://www.rs.e-technik.tu-darmstadt.de/TUD/res/dlxdocu/SuperscalarDLX.html" />
		<title level="m">A Superscalar Version of the DLX Processor</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The SPARC Architecture Manual</title>
		<ptr target="http://www.sparc.com/resource.htm#V8" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<ptr target="http://www.gaisler.com/leon.html" />
		<title level="m">LEON2 Processor</title>
				<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
