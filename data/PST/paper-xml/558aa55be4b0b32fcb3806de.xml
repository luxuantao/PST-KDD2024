<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Test Data Compression for System-on-a-Chip Using Golomb Codes 1</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Anshuman</forename><surname>Chandra</surname></persName>
							<email>achandra@ee.duke.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering Duke University Durham</orgName>
								<address>
									<postCode>27708</postCode>
									<region>NC</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Krishnendu</forename><surname>Chakrabarty</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering Duke University Durham</orgName>
								<address>
									<postCode>27708</postCode>
									<region>NC</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Test Data Compression for System-on-a-Chip Using Golomb Codes 1</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">744942A71C88D80CAD29B70EB6A19D6D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:12+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a new test data compression method and decompression architecture based on Golomb codes. The proposed method is especially suitable for encoding precomputed test sets for embedded cores in a system-on-achip (SOC). The major advantages of Golomb include very high compression, analytically predictable compression results, and a low-cost and scalable on-chip decoder. In addition, the novel interleaving decompression architecture allows multiple cores in an SOC to be tested concurrently using a single ATE I/O channel. We demonstrate the effectiveness of the proposed approach by applying it to the ISCAS benchmark circuits and to two industrial production circuits. We also use analytical and experimental means to highlight the superiority of Golomb codes over run-length codes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Core-based system-on-a-chip (SOC) designs present a number of test challenges <ref type="bibr" target="#b0">[1]</ref>. In order to effectively test these systems, each intellectual property (IP) core must be adequately exercised with a set of precomputed test patterns provided by the core vendor (Figure <ref type="figure">1</ref>). However, the I/O channel capacity, speed and accuracy, and data memory of automatic test equipment (ATE) are limited. Thus, it is becoming increasingly difficult to apply the enormous volume of test data to the SOC (which can be as high as 2.5 Gbits for an industrial ASIC <ref type="bibr" target="#b1">[2]</ref>) without increasing testing time and test cost substantially.</p><p>The reduction in test data volume will not only reduce ATE memory requirements but also lower testing time. The testing time of an SOC depends on the test data volume, the time required to transfer the data to the cores, and the rate at which the test data is transferred (measured by the cores test data bandwidth and ATE channel capacity). Lower testing time will increase production capacity as well as reduce test cost and time-to-market for SOC. New techniques are therefore needed for decreasing test data volume in order to overcome memory bottlenecks and to reduce testing time.</p><p>Built-in self-test (BIST) has emerged as a useful approach for alleviating the above problems <ref type="bibr" target="#b2">[3]</ref>. BIST reduces dependencies on expensive ATEs and it allows precomputed test sets to be embedded in test sequences generated by onchip hardware <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref>. However, BIST can be applied directly to SOC designs only if the embedded cores are BISTready. Since most IP cores that are currently available from core vendors are not BIST-ready, considerable redesign is necessary for incorporating BIST.</p><p>Test data compression offers a promising solution to the problem of reducing the test data volume for SOCs, especially if the IP cores in the system are not BIST-ready <ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref>. In this approach, a precomputed test set T D for an IP core is compressed (encoded) to a much smaller test set T E , which is stored in ATE memory. An on-chip decoder is used for pattern decompression to obtain T D from T E during test application (Figure <ref type="figure">2</ref>).</p><p>Test data compression using statistical coding of test sequences for synchronous sequential (non-scan) circuits was presented in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. Statistical coding was successfully applied to test sets for full-scan circuits in <ref type="bibr" target="#b8">[9]</ref>. While the compression method in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> is restricted to sequential circuits with a large number of flip-flops and relatively few primary inputs, the work presented in <ref type="bibr" target="#b8">[9]</ref> does not conclusively demonstrate that statistical coding provides greater compression than standard ATPG compression methods for full-scan circuits <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>.</p><p>An alternative approach to test data compression is motivated by the fact that successive test patterns in a test sequence often differ in only a small number of bits. This was exploited in <ref type="bibr" target="#b9">[10]</ref>, where instead of compressing the test sequence T D , a "difference vector" sequence T diff determined from T D was compressed using run-length coding. A test architecture employing difference vectors and based on cyclical scan registers (CSRs) is sketched in Figure <ref type="figure" target="#fig_1">3</ref>. Note that existing registers on the SOC may be used as CSRs in order to reduce overhead <ref type="bibr" target="#b9">[10]</ref>.</p><p>A drawback of the compression method described in <ref type="bibr" target="#b9">[10]</ref> is that it relies on variable-to-fixed-length codes, which are less efficient than more general variable-to-variablelength codes <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>. Instead of using a run-length code with a fixed block size b, we can achieve greater compression by using Golomb codes that map variablelength runs of 0s in a difference vector to variable-length codewords <ref type="bibr" target="#b12">[13]</ref>.</p><p>In this paper, we present a new test data compression and decompression method based on Golomb codes for testing SOCs using precomputed test sets. The proposed method is applicable to both full-scan and non-scan circuits. For full-scan circuits, the test patterns in a precomputed test set T D can be reordered to obtain a difference vector with very few 1s. For non-scan circuits however, the order of pattern application must be preserved; therefore no reordering is possible. Nevertheless, we show that Golomb coding is effective for encoding T D for these circuits. An encoded test set T E derived using Golomb coding is considerably smaller than the original precomputed test set T D . Furthermore we show that T E is also much smaller than the smallest test sets that have been derived for the ISCAS benchmark circuits using ATPG compaction. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Wrapper</head><p>Core n We derive upper and lower bounds on the amount of compression with Golomb and run-length codes that can be achieved for any given T diff . These simple bounds provide useful guidelines to the designer and they reveal the inherent superiority of Golomb codes over run-length codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Timing and synchronization</head><p>We also design a low-cost decoder for decompressing Golomb-encoded test patterns. We implement the decoder using Synopsys Design Compiler <ref type="bibr" target="#b14">[15]</ref> and show that overhead due to the decoder is very small. In addition, the decoder is scalable and independent of the core under test and the precomputed test set T D . We then present a decompression architecture that allows multiple cores to be tested in parallel without requiring additional ATE I/O channels. This benefit is a direct consequence of the structure of the Golomb code.</p><p>The organization of the paper is as follows. In Section 2, we present the basic concept of Golomb coding and bounds on the amount of compression that can be achieved using Golomb and run-length codes. Section 3 presents encoding procedures and describes the decoder that is necessary for onchip decompression. Section 4 presents the overall test architecture and a decompression method for an SOC with multiple cores. Experimental results for the ISCAS benchmarks and two industrial production circuits are reported in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Golomb coding</head><p>In this section, we describe Golomb coding and analyze its effectiveness for test data compression. As discussed in Section 1, the first step in encoding a test set T D is to generate its difference vector test set T diff . Let the (ordered) precomputed test set be T D = {t 1 , t 2 , t 3 , ⋅⋅⋅, t n }. Its difference vector is then given by T diff = {t 1 , t 1 ⊕ t 2 , t 2 ⊕ t 3 , ⋅⋅⋅, t n-1 ⊕ t n }. This assumes that the CSR starts in the all-0 state. Other starting states can be considered similarly. The next step in the encoding procedure is to select the Golomb code parameter m, referred to as the group size. The choice of m has received a lot of attention in the information theory literature-for certain distributions of the input data stream (T diff in our case), the group size m can be optimally determined. For example, if the input data stream is random with 0-probability p, then m should be chosen such that p m ≈ 0.5 <ref type="bibr" target="#b13">[14]</ref>. However, since T diff does not satisfy the randomness assumption, the best value of m for test data compression can only be determined through actual experimentation.</p><p>Once m is determined, the runs of 0s in T diff are mapped to groups of size m (each group corresponding to a run length). The number of such groups is determined by the length of the longest run of 0s in T diff . The set of run-lengths {0, 1, 2, ⋅⋅⋅, m -1} forms group A 1 ; the set {m, m + 1, m + 2, ⋅⋅⋅, 2m -1}, group A 2 ; etc. In general, the set of run-lengths <ref type="bibr" target="#b14">[15]</ref>. To each group A k , we assign a group prefix of (k -1) 1s followed by a 0. We denote this by 1 (k -1) 0. If m is chosen to be a power of 2 i.e., m = 2 N , each group contains 2 N members and a log 2 m-bit sequence (tail) uniquely identifies each member within the group. Thus, the final code word for a run-length L that belongs to group A k is composed of two parts-a group prefix and tail. The prefix is 1 (k -1) 0 and the tail is a sequence of log 2 m bits. The encoding process is illustrated in Figure <ref type="figure">4</ref> for m = 4.</p><formula xml:id="formula_0">{(k -1)m, (k -1)m + 1, (k -1)m + 2, ⋅⋅⋅, k m -1} comprises group A k</formula><p>We now analyze the effectiveness of Golomb coding for a given T diff . We derive upper and lower bounds on |T E | for any given m = 2 N . The patterns in T diff can be considered as a single stream of data as shown in Figure <ref type="figure" target="#fig_3">5</ref>. Let there be n bits and r 1s in T diff . Also, without loss of generality, let the sequence always end with a 1. Therefore T diff will contain r runs of 0s. Let these runs be of length l 1 , l 2 , l 3 , ⋅⋅⋅, l r respectively. Thus, T diff can be represented by the sequence</p><formula xml:id="formula_1">l 1 1 l 2 1 l 3 1 … l r 1 such that (l 1 + l 2 + l 3 + ⋅⋅⋅ + l r ) + r = n.</formula><p>The following theorem provides a bound on G, the size of the encoded sequence T E . The proof is omitted for conciseness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1: Let the total number of bits in the difference vector set T diff be n and the total number of 1s be r. Then the size G (in bits) of the encoded test data T E is bounded as follows</head><formula xml:id="formula_2">: n/m + rlog 2 m ≤ G ≤ n/m + rlog 2 m + r(1-1/m).</formula><p>The following corollary shows that Theorem 1 provides tight bounds on G, especially if the number of 1s in T diff is small. The proof of the corollary follows from Theorem 1.  As an illustration of these bounds, consider a hypothetical example where n = 256 and r = 30. The upper and lower bounds for various values of m are shown in Figure <ref type="figure">6</ref>(b) and the corresponding graph is plotted in Figure <ref type="figure">6</ref>(a). We note that the lower and upper bound on the compression G follows a "bathtub curve", and the best value of m depends on T diff and therefore needs to be determined experimentally. These bounds are obtained from the parameters n and r and they do not depend on the distribution of 1s in T diff . They can be used as predictors for the effectiveness of Golomb coding for a particular T D .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 1: Consider any difference vector set T diff with r 1s. Let G max (G min ) be the upper (lower) bound on the size of the encoded test set T E , as predicted by Theorem</head><formula xml:id="formula_3">1. Then r/2 ≤ G max -G min ≤ r.</formula><p>We next present upper and lower bounds on the compression achieved by run-length coding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 Let the total number of bits in test set T diff be n and the total number of 1s be r. In addition, suppose block size b is used for run-length coding. The size RL (in bits) of the encoded test data T E is given by</head><formula xml:id="formula_4">: bn/(2 b -1) ≤ RL ≤ bn(2 b -1) + br(2 b -2)/(2 b -1) ≈ bn/(2 b -1) + br.</formula><p>We can now compare the efficiency of Golomb coding (m = 4) and run-length coding for block size b = 3. For runlength coding, a lower bound from Theorem 2 is given by RL min = 3n/7 = 0.428n. An upper bound for Golomb coding from Theorem 1 is given by G max = n/4 + 11r/4. If we make the realistic assumption (based on experimental data) that r ≤ 0.05n, we get G max = 0.39n, which is smaller than RL min . In fact as r becomes smaller relative to n, G max → 0.25n. Therefore, we note that as long as r is sufficiently small compared to n, the best compression that can be achieved with run-length coding is less than the worst compression with Golomb coding. This provides an analytical justification for the use of Golomb codes instead of run-length codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Test data compression/decompression</head><p>In this section, we describe the test data compression procedure, the decompression architecture, and the design of the on-chip decoder. Additional practical issues related to the decompression architecture are discussed in the following section. We show that the decoder is simple and scalable, and independent of both the core under test and the precomputed test set. Moreover, due to its small size, it does not introduce significant hardware overhead.</p><p>The encoding procedure for a block of data using Golomb codes was outlined in Section 2. Let T D be the test set with p patterns and n primary inputs and T diff be the corresponding difference vector test set. A straightforward algorithm is used for generating T diff . For full-scan cores, reordering of the test patterns is allowed, therefore the patterns can be arranged such that the runs of 0s are long in T diff . The problem of determining the best ordering is equivalent to the NP-Complete Traveling Salesman problem. Therefore, a greedy algorithm is used to generate T diff . Let every pattern in T D correspond to a node in a complete directed graph G and let the weight (w ij ) equal the number of 0s in the difference vector obtained from t i ⊕ t j (weight of the edge from t i to t j ). Starting from the first pattern t 1 , we choose the next pattern that is at the least distance from t 1 . (The distance between two nodes is given by n-w ij .) We continue this process until all the patterns are covered, i.e. all nodes in G are visited. The same procedure can be used to generate T E for non-scan cores by disabling the reordering step. For test cubes, the don't-cares have to be mapped to 0s or 1s before they can be compressed. The don't-cares are therefore assigned binary values such that w ij is maximum for the edge between t i and t j .  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Pattern decompression</head><p>The decoder decompresses the encoded test set T E and outputs T diff . The exclusive-or gate and the CSR are used to generate the test patterns from the difference vectors. The decoder can be efficiently implemented by a log 2 m-bit counter and a finite-state machine (FSM). The block diagram of the decoder is shown in Figure <ref type="figure">7</ref>. The bit_in is the input to the FSM and an enable (en) signal is used to input the bit whenever the decoder is ready. The signal inc is used to increment the counter and rs indicates that the counter has finished counting. The signal out is the decode output and v indicates when the output is valid. The operation of the decoder is as follows:</p><p>• Whenever the input is 1, the counter counts upto m. The signal en is low while the counter is busy counting and enables the input at the end of m cycles to accept another bit. The decoder outputs m 0s during this operation and makes the valid signal v high.</p><p>• When the input is 0, the FSM starts decoding the tail of the input codeword. Depending on the tail bits, the number of 0s outputted is different. The en and v signals are used to synchronize the input and output operation of the decoder.</p><p>The state diagram corresponding to the decoder for m = 4 is shown in Figure <ref type="figure">8</ref>. The states S0 to S3 and S4 to S8 correspond to the prefix and tail decoding respectively. We also synthesized the FSM using Synopsys Design Compiler to access the hardware overhead of the decoder. The synthesized circuit contains only 4 flip-flops and 34 combinational gates. For any circuit whose test set is compressed using m = 4, the synthesized logic is the only additional hardware required other than the log 2 m-bit counter. Thus the decoder is independent of not only the core under test but also its precomputed test set. The extra logic required for decompression is very small and can be implemented very easily. This is in contrast to a run-length decoder, which is not scalable and becomes increasingly complex for higher values of the block length b.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Decompression architecture</head><p>In this section, we present a decompression architecture for testing SOC designs when Golomb coding is used for test data compression. We describe the application of Golomb codes to non-scan and full-scan circuits and we present a new technique for testing several cores simultaneously using a single ATE I/O channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Application to sequential (non-scan) cores</head><p>For sequential cores, a boundary scan register is required at the functional inputs for decompression. This register is usually available for cores that are wrapped. In addition, a two input exclusive-or gate is required to translate the difference vectors to the patterns of T D . Figure <ref type="figure">9(a)</ref> shows the overall test architecture for the sequential core. The encoded data is fed bit-wise to the decoder, which produces a sequence of difference vectors. The decompression hardware then translates the difference vectors into the test patterns, which are applied to the core. If an existing boundary-scan register is used to decompress the test data, the decoder and a small amount of synchronizing logic are the only additional logic required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Application to full-scan cores</head><p>Most cores in use today contain one or more internal scan chains. However, since the scan chains are used for capturing test responses, they cannot be used for decompression. An additional cyclical scan register (CSR), with length equal to the length of the internal scan chain, is required to generate the test patterns. Figure <ref type="figure">9</ref>(b) shows the decompression architecture for full-scan cores.</p><p>As discussed in <ref type="bibr" target="#b9">[10]</ref>, there are a number of ways in which the various scan chains in a SOC can be configured to test the cores in the system. If an SOC contains both nonscan and full-scan cores, the boundary-scan register associated with a non-scan core C 1 can be first used to decompress and apply test patterns to C 1 and then it can be used to decompress the test patterns and feed the internal scan of a full-scan core C 2 . Similarly the internal scan of a core can be used to decompress and feed the test patterns to the internal scan of the core under test if the length of the internal scan chain being used for decompression is smaller than or equal to the internal scan chain being fed. If the scan chain is smaller, extra scan elements can be added to make the lengths of the two scan chains equal. In this way, the proposed scheme provides the core integrator with flexibility in configuring the various scan chains to minimize hardware overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Application to multiple cores</head><p>We now highlight another important advantage of Golomb coding. In addition to reducing testing time and the size of the test data to be stored in the ATE memory, Golomb coding also allows multiple cores to be tested simultaneously using a single ATE I/O channelin this way, the I/O channel capacity of the ATE can be increased. This is a direct consequence of the structure of the Golomb code, and such a design is not possible for variable-to-fixedlength (run-length) coding.</p><p>As discussed in Section 2, when Golomb coding is applied to a block of data containing a run of 0s followed by a single 1, the code word contains two partsa prefix and tail. For a given code parameter m (group size), the length of the tail (log 2 m) is independent of the run-length. Note further that every 1 in the prefix corresponds to m 0s in the decoded difference vector. Thus the prefix consists of a string of 1s followed by a 0, and the 0 can be used to identify the beginning of the tail.</p><p>The FSM in the decoder runs the counter for m decode cycles whenever a 1 is received and starts decoding the tail as soon as a 0 is received. The tail decoding takes at most m cycles. During prefix decoding, the FSM has to wait for m cycles before the next bit of the prefix can be decoded. Therefore, we can use interleaving to test m cores together, such that the decoder corresponding to each core is fed with encoded prefix data after every m cycles. (This can also be used to feed multiple scan chains in parallel as long as the capture cycles of the scan chains are synchronized.) Whenever the tail is to be decoded (identified by a 0 in the encoded bit stream), the respective decoder is fed with the entire tail of log 2 m bits in a single burst of log 2 m cycles. This interleaving scheme is based on the use of a demultiplexer and it works as follows. First the encoded test data for m cores is combined to generate a composite bit stream T C that is stored in the ATE. Next T C is fed to the demultiplexer and a small FSM with only i = log 2 m states is used to detect beginning of each tail. An i-bit counter is used to select the outputs to the decoders of the various cores. Now we outline how T C is generated from the different encoded test data. T C is obtained by interleaving the prefix parts of the compressed test sets of each core, but the tails are included unchanged in T C . An example is shown in the Figure <ref type="figure" target="#fig_5">10</ref> where compressed data for two cores (generated using group size m = 2) have been interleaved to obtain the final encoded test set to be applied through the decompression scheme for multiple cores.</p><p>Every scan chain has its dedicated decoder. This decoder receives either a 1 or the tail of the compressed data corresponding to the various cores connected to the scan chain. The i-bit counter connected to the select lines of the demultiplexer selects a decoder after every m clock cycles. If the FSM detects that a portion of the tail has arrived, the 0 that is used to identify the tail, is passed to the decoder and then the counter is stopped for log 2 m (tail length) cycles so that the test data is transferred continuously to the appropriate core.</p><p>The tail decoding takes at most m cycles. This is because the number of states traversed by the decode FSM depends on the bits of T E that it receives; see Figure <ref type="figure">8</ref>. This number can be at most m. In order to make the prefix and tail decoding cycles equal, two additional states must be added to the FSM state diagram as shown in the Figure <ref type="figure">11</ref>. This ensures that the decoder works in synchronization with the demultiplexer. Moreover, now the tail bits may not be passed on to the decoder as a single block. Thus, the interleaving of test data to generate T C changes slightly. The additional states do not increase the number of flip-flops in the decoder.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experimental results</head><p>In this section, we experimentally evaluate the proposed test data compression/decompression method for the ISCAS benchmark circuits, and for two industrial circuits. We considered both full-scan and non-scan sequential circuits in our experiments. The test set for each full-scan circuit was reordered to increase compression; on the other hand, no reordering was done for the non-scan circuits. The amount of compression obtained was computed as follows: The first set of experimental data that we present is based on the use of partially-specified test sets (test cubes). The system integrator can determine the best Golomb code parameter and encode test cubes if they are provided by the core vendor. Alternatively, the core vendor can encode the test set for the core and provide the encoded test set along with the value of m to the core user, who can then use m to design the decoder. In a third possible scenario, the core vendor can encode the test set and provide it to the core user without disclosing the value of m used for encoding. Thus T E now serves as an encryption of the test data for IP protection and m serves as the "secret key". In this case however, the core vendor must also design the decoder for the core and provide it to the core user.</p><formula xml:id="formula_5">Compression (percent)=(|T D | -G)/|T D |</formula><p>Table <ref type="table">1</ref> presents the experimental results for the ISCAS benchmark circuits with test cubes obtained from the Mintest ATPG program with dynamic compaction <ref type="bibr" target="#b8">[9]</ref>. We carried out our experiments using a Sun Ultra 10 workstation with a 333 MHz processor and 256 MB of DRAM. The table lists the sizes of the precomputed (original) test sets, the amount of compression achieved for several values of m, and the size of the smallest encoded test set.</p><p>As is evident from Table <ref type="table">1</ref>, the best value of m depends on the test set. Not only do we achieve very high test data compression with a suitable choice of m, but we also observe that in a majority of cases (e.g. for all but one of the ISCAS 89 circuits), the size of T E is less than the smallest tests that have been derived for these circuits using ATPG compaction <ref type="bibr" target="#b10">[11]</ref>. (These cases are shown shaded in Table <ref type="table">1</ref>.) Hence ATPG compaction may not always be necessary for saving memory and reducing testing time. This comparison is essential in order to show that storing T E in ATE memory is more efficient than simply applying ATPG compaction to test cubes and storing the resulting compact test sets. For example, the effectiveness of statistical coding for full-scan circuits was not completely established in <ref type="bibr" target="#b8">[9]</ref> since no comparison was drawn with ATPG compaction in that work.</p><p>We next present results on Golomb coding for non-scan circuits. For this set of experiments, we used HITEC <ref type="bibr">[17]</ref> to generate test sequences (cubes) for some of the ISCAS 89 benchmark circuits (including the three largest ones), and  <ref type="table">1</ref>: Experimental results on Golomb coding for the combinational and full-scan ISCAS benchmark circuits with test patterns generated using Mintest <ref type="bibr" target="#b10">[11]</ref>.</p><p>determined the size of T E in each case. Table <ref type="table">3</ref>(a) illustrates the amount of compression achieved for these circuits. We also applied Golomb coding to two non-scan industrial circuits. These production circuits are microcontrollers, whose test data were provided to us by Delphi Delco Electronics Systems. The first circuit CKT1 contains 16.8K gates, 145 flip-flops, and 35 latches. The second (smaller) circuit contains 6.8 K gates, 88 flip-flops, and 32 latches. The test sequences for these circuits were fully-specified and they were derived using functional methods targeted at single stuck-at faults in their subcircuits. The results on Golomb coding for these circuits are presented in Table <ref type="table">3</ref>(b) and Table <ref type="table">3</ref>(c). We achieved significant compression (over 80% on average) in all cases. Thus the results show that the compression scheme is very effective for the non-scan circuits as well.</p><p>We next revisit the lower and upper bounds derived in Section 2 for test data compression using Golomb codes. In Table <ref type="table" target="#tab_3">2</ref>, we list these bounds and the actual compression obtained for the ISCAS circuits. Table <ref type="table">3</ref> shows the number of 1s in T diff , size of the encoded test set T E , and lower and upper bounds corresponding to each circuit. These results show that the experimental results are consistent with the theoretically-predicted bounds.</p><p>An analytical comparison between run-length coding and Golomb coding was presented in Section 2. Here we present experimental results to reinforce that comparison. Table <ref type="table" target="#tab_5">4</ref> compares the amount of compression obtained with run-length coding for b = 3 with Golomb coding for the large ISCAS benchmark circuits. Golomb codes give better compression in all cases. For example, the compression is almost 20% better for s13207. While run-length coding may yield slightly better compression for higher values of b, the complexity of the run-length decoder increases considerably with an increase in b.</p><p>If the precomputed test set T D is already compacted using ATPG methods, then the compression obtained using Golomb codes is considerably less. Nevertheless, we have seen that a significant amount of compression is often achieved if Golomb coding is applied to an ATPGcompacted T D . Table <ref type="table">5</ref> lists the compression achieved for some ISCAS benchmark circuits with test sets derived using SIS <ref type="bibr" target="#b17">[19]</ref>. We also present results for I99C1, a combinational benchmark circuit extracted from an industrial design and presented at ITC-99. The corresponding compression results achieved with run-length coding (block size b = 3) are also shown, and are seen to be significantly less.  (c) Table <ref type="table">3</ref>: Experimental results for (a) ISCAS 89 benchmark circuits (b) various test sequences for industrial non-scan circuit CKT1 (c) various test sequences for industrial non-scan circuit CKT2.</p><p>we were unable to directly compare our results with <ref type="bibr" target="#b9">[10]</ref> since the test sets used in <ref type="bibr" target="#b9">[10]</ref> are no longer available. However, we note that Golomb coding indirectly outperforms <ref type="bibr" target="#b9">[10]</ref> since T E is much smaller and the compression is significantly higher for Golomb-coded test sets in all cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>We have presented a new test vector compression method and decompression architecture for testing embedded cores in a SOC. The proposed method is based on variable-tovariable-length Golomb codes. We have shown that Golomb codes can be used for efficient compression of test data for SOCs and to save ATE memory and the testing time. Golomb coding is inherently superior then run-length coding; we have demonstrated this analytically and through experimental results.</p><p>The on-chip decoder is small and easy to implement. In addition, it is scalable and independent of the core under test and the precomputed test set. We have also presented a novel decompression architecture for testing multiple cores simultaneously. This reduces the testing time of an SOC further and increases the ATE I/O channel capacity considerably. The novel decompression architecture is a direct consequence of the structure of the Golomb codes.</p><p>Experimental results for the ISCAS benchmark show that the compression technique is very efficient for combinational and full-scan circuits. Significant compression is achieved not only for test cubes, but also for compacted fully-specified test sets. The results show that ATPG compaction may not be always necessary for saving ATE memory and reducing testing time. We also achieved substantial compression for two non-scan industrial circuits and for the non-scan ISCAS 89 circuits using HITEC test sets. These results show that Golomb coding is also attractive for compressing (ordered) test sequences of non-scan circuits.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: A conceptual architecture for SOC testing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Decompression architecture based on a cyclical scan register (CSR).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :Figure 6 :</head><label>46</label><figDesc>Figure 4: An example of Golomb coding for m = 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>≡Figure 5 :</head><label>5</label><figDesc>Figure 5: T diff and its encoded T E .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>Figure 7: Block diagram of the decoder used for decompression.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Composite encoded test data for two cores with group size m = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 11 :Figure 9 :</head><label>119</label><figDesc>Figure 11: Modified state diagram of the decode FSM to make the tail and prefix decode cycles equal.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>× 100</figDesc><table><row><cell>ISCAS</cell><cell>Number of</cell><cell>Lower</cell><cell>Size of</cell><cell>Upper</cell></row><row><cell>circuit</cell><cell>1s</cell><cell>bound</cell><cell>encoded</cell><cell>bound</cell></row><row><cell></cell><cell>(r)</cell><cell>G min</cell><cell>test set</cell><cell>G max</cell></row><row><cell></cell><cell></cell><cell>(bits)</cell><cell>G(bits)</cell><cell>(bits)</cell></row><row><cell>c1355</cell><cell>572</cell><cell>2353</cell><cell>2627</cell><cell>2782</cell></row><row><cell>c1908</cell><cell>700</cell><cell>2456</cell><cell>2876</cell><cell>3071</cell></row><row><cell>c2670</cell><cell>1728</cell><cell>7717</cell><cell>8903</cell><cell>9229</cell></row><row><cell>c3450</cell><cell>1303</cell><cell>4218</cell><cell>4868</cell><cell>5195</cell></row><row><cell>c5315</cell><cell>2206</cell><cell>8283</cell><cell>9443</cell><cell>9938</cell></row><row><cell>c7552</cell><cell>6475</cell><cell>19102</cell><cell>21338</cell><cell>22339</cell></row><row><cell>s641</cell><cell>296</cell><cell>998</cell><cell>1098</cell><cell>1146</cell></row><row><cell>s713</cell><cell>290</cell><cell>931</cell><cell>1080</cell><cell>1148</cell></row><row><cell>s1196</cell><cell>589</cell><cell>2290</cell><cell>2570</cell><cell>2731</cell></row><row><cell>s1238</cell><cell>599</cell><cell>2414</cell><cell>2685</cell><cell>2863</cell></row><row><cell>s5378</cell><cell>3239</cell><cell>12416</cell><cell>14085</cell><cell>14845</cell></row><row><cell>s9234</cell><cell>5039</cell><cell>19896</cell><cell>22250</cell><cell>23675</cell></row><row><cell>s13207</cell><cell>6716</cell><cell>37189</cell><cell>41658</cell><cell>43485</cell></row><row><cell>s15850</cell><cell>8702</cell><cell>36650</cell><cell>40717</cell><cell>43177</cell></row><row><cell>s35932</cell><cell>5340</cell><cell>55886</cell><cell>59573</cell><cell>61216</cell></row><row><cell>s38417</cell><cell>20165</cell><cell>81514</cell><cell>92054</cell><cell>96637</cell></row><row><cell>s38584</cell><cell>23320</cell><cell>96416</cell><cell>104111</cell><cell>113906</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Comparison between G (obtained experimentally) with the theoretical bounds G min and G max . The test set used is obtained from the Atalanta ATPG program<ref type="bibr" target="#b15">[16]</ref>. (The Mintest test set with dynamic compaction is almost fully compacted.) The maximum compression was obtained for group size m = 512. Table</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>No of</cell><cell>Best</cell><cell>No of</cell><cell>No of</cell></row><row><cell>Circuit</cell><cell cols="5">Percentage compression for various values of m</cell><cell>bits</cell><cell>comp-</cell><cell>bits</cell><cell>bits</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>in</cell><cell>ression</cell><cell>G in</cell><cell>for</cell></row><row><cell></cell><cell>m = 2</cell><cell>m = 4</cell><cell>m = 8</cell><cell>m = 16</cell><cell>m = 32</cell><cell>T D</cell><cell>(percent)</cell><cell>T E</cell><cell>Mintest</cell></row><row><cell>c1355</cell><cell>34.86</cell><cell>45.70</cell><cell>44.58</cell><cell>37.63</cell><cell>28.00</cell><cell>4838</cell><cell>45.70</cell><cell>2627</cell><cell>3444</cell></row><row><cell>c1908</cell><cell>30.17</cell><cell>37.30</cell><cell>32.63</cell><cell>21.93</cell><cell>8.06</cell><cell>4587</cell><cell>37.30</cell><cell>2876</cell><cell>3498</cell></row><row><cell>c2670</cell><cell>38.64</cell><cell>53.34</cell><cell>56.08</cell><cell>53.02</cell><cell>47.08</cell><cell>20271</cell><cell>56.08</cell><cell>8903</cell><cell>10252</cell></row><row><cell>c3450</cell><cell>23.48</cell><cell>24.52</cell><cell>13.90</cell><cell>-2.40</cell><cell>-21.36</cell><cell>6450</cell><cell>24.52</cell><cell>4868</cell><cell>4200</cell></row><row><cell>c5315</cell><cell>31.33</cell><cell>39.02</cell><cell>35.08</cell><cell>25.46</cell><cell>13.26</cell><cell>15486</cell><cell>39.02</cell><cell>9443</cell><cell>6586</cell></row><row><cell>c7552</cell><cell>15.50</cell><cell>9.80</cell><cell>-6.99</cell><cell>-29.51</cell><cell>-54.17</cell><cell>25254</cell><cell>15.50</cell><cell>21338</cell><cell>15111</cell></row><row><cell>s641</cell><cell>21.79</cell><cell>21.58</cell><cell>10.32</cell><cell>-6.83</cell><cell>-26.63</cell><cell>1404</cell><cell>21.79</cell><cell>1098</cell><cell>1134</cell></row><row><cell>s713</cell><cell>22.43</cell><cell>23.07</cell><cell>11.96</cell><cell>-4.70</cell><cell>-24.07</cell><cell>1404</cell><cell>23.07</cell><cell>1080</cell><cell>1134</cell></row><row><cell>s1196</cell><cell>32.80</cell><cell>42.22</cell><cell>40.06</cell><cell>31.67</cell><cell>20.21</cell><cell>4448</cell><cell>42.22</cell><cell>2570</cell><cell>3616</cell></row><row><cell>s1238</cell><cell>34.21</cell><cell>44.79</cell><cell>43.62</cell><cell>36.26</cell><cell>25.94</cell><cell>4864</cell><cell>44.79</cell><cell>2685</cell><cell>3872</cell></row><row><cell>s5378</cell><cell>32.11</cell><cell>40.70</cell><cell>37.60</cell><cell>28.72</cell><cell>17.19</cell><cell>23754</cell><cell>40.70</cell><cell>14085</cell><cell>20758</cell></row><row><cell>s9234</cell><cell>33.44</cell><cell>43.34</cell><cell>41.53</cell><cell>33.47</cell><cell>22.33</cell><cell>39273</cell><cell>43.34</cell><cell>22250</cell><cell>25935</cell></row><row><cell>s13207</cell><cell>44.78</cell><cell>65.03</cell><cell>72.97</cell><cell>74.78</cell><cell>73.44</cell><cell>165200</cell><cell>74.78</cell><cell>41658</cell><cell>163100</cell></row><row><cell>s15850</cell><cell>35.37</cell><cell>47.11</cell><cell>46.79</cell><cell>40.45</cell><cell>31.07</cell><cell>76986</cell><cell>47.11</cell><cell>40717</cell><cell>57434</cell></row><row><cell>s35932 *</cell><cell>49.83</cell><cell>74.68</cell><cell>87.04</cell><cell>93.15</cell><cell>96.14</cell><cell>4007299</cell><cell>98.51</cell><cell>59573</cell><cell>19393</cell></row><row><cell>s38417</cell><cell>33.55</cell><cell>44.12</cell><cell>42.38</cell><cell>35.22</cell><cell>25.20</cell><cell>164736</cell><cell>44.12</cell><cell>92054</cell><cell>113152</cell></row><row><cell>s38584</cell><cell>35.65</cell><cell>47.71</cell><cell>47.67</cell><cell>41.65</cell><cell>32.71</cell><cell>199104</cell><cell>47.71</cell><cell>104111</cell><cell>161040</cell></row></table><note><p>*</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Unfortunately,    </figDesc><table><row><cell>ISCAS</cell><cell>Size</cell><cell>Percentage</cell><cell>Percentage</cell><cell>Difference</cell></row><row><cell>circuit</cell><cell>of</cell><cell>compression</cell><cell>compression</cell><cell>G -RL</cell></row><row><cell>(full-</cell><cell>T D</cell><cell>(Golomb</cell><cell>(run-length</cell><cell>(percent)</cell></row><row><cell>scan)</cell><cell>(bits)</cell><cell>coding)</cell><cell>coding)</cell><cell></cell></row><row><cell>s5378</cell><cell>23754</cell><cell>40.70</cell><cell>35.57</cell><cell>5.13</cell></row><row><cell>s9234</cell><cell>39273</cell><cell>43.34</cell><cell>40.08</cell><cell>3.26</cell></row><row><cell>s13207</cell><cell>165200</cell><cell>74.78</cell><cell>55.50</cell><cell>19.28</cell></row><row><cell>s15850</cell><cell>76986</cell><cell>47.11</cell><cell>42.10</cell><cell>5.01</cell></row><row><cell cols="2">s35932 4007299</cell><cell>98.51</cell><cell>62.32</cell><cell>36.19</cell></row><row><cell>s38417</cell><cell>164736</cell><cell>44.12</cell><cell>37.16</cell><cell>6.96</cell></row><row><cell>s38584</cell><cell>199104</cell><cell>47.71</cell><cell>42.40</cell><cell>5.31</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>Comparison between the compression obtained withGolomb coding and run-length coding.</figDesc><table><row><cell>ISCAS 89</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Size of</cell><cell>Best</cell><cell>Size of</cell></row><row><cell>circuit</cell><cell></cell><cell cols="4">Percentage compression for group size m</cell><cell></cell><cell>T D</cell><cell>compression</cell><cell>T E</cell></row><row><cell>(non-scan)</cell><cell>m = 2</cell><cell>m = 4</cell><cell>m = 8</cell><cell>m = 16</cell><cell>m = 32</cell><cell>m = 64</cell><cell>(bits)</cell><cell>(percent)</cell><cell>(bits)</cell></row><row><cell>s953</cell><cell>41.78</cell><cell>58.56</cell><cell>63.78</cell><cell>62.58</cell><cell>57.87</cell><cell>51.62</cell><cell>1168</cell><cell>63.78</cell><cell>423</cell></row><row><cell>s5378</cell><cell>41.07</cell><cell>57.68</cell><cell>62.24</cell><cell>60.79</cell><cell>-</cell><cell>-</cell><cell>169995</cell><cell>62.24</cell><cell>64176</cell></row><row><cell>s13207</cell><cell>49.24</cell><cell>73.36</cell><cell>85.21</cell><cell>90.81</cell><cell>93.30</cell><cell>94.21</cell><cell>42284</cell><cell>94.21</cell><cell>2491</cell></row><row><cell>s35932</cell><cell>48.10</cell><cell>71.41</cell><cell>82.31</cell><cell>87.03</cell><cell>88.58</cell><cell>88.74</cell><cell>147070</cell><cell>88.74</cell><cell>16554</cell></row><row><cell>s15850</cell><cell>48.32</cell><cell>71.81</cell><cell>82.97</cell><cell>87.91</cell><cell>89.62</cell><cell>89.68</cell><cell>430353</cell><cell>89.68</cell><cell>46872</cell></row><row><cell>s38417</cell><cell>47.05</cell><cell>69.08</cell><cell>78.06</cell><cell>81.79</cell><cell>82.11</cell><cell>80.34</cell><cell>22624</cell><cell>82.11</cell><cell>4046</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(a)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Test</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Size of</cell><cell>Best</cell><cell>Size</cell></row><row><cell>sequence</cell><cell></cell><cell cols="4">Percentage compression for group size m</cell><cell></cell><cell>T D</cell><cell>compression</cell><cell>of T E</cell></row><row><cell>for CKT1</cell><cell>m = 2</cell><cell>m = 4</cell><cell>m = 8</cell><cell>m = 16</cell><cell>m = 32</cell><cell>m = 64</cell><cell>(bits)</cell><cell>(percent)</cell><cell>(bits)</cell></row><row><cell>TS1</cell><cell>46.71</cell><cell>68.53</cell><cell>78.12</cell><cell>81.56</cell><cell>81.71</cell><cell>80.38</cell><cell>25130</cell><cell>81.71</cell><cell>4595</cell></row><row><cell>TS2</cell><cell>47.77</cell><cell>70.68</cell><cell>81.14</cell><cell>85.61</cell><cell>86.75</cell><cell>86.38</cell><cell>23230</cell><cell>86.75</cell><cell>3078</cell></row><row><cell>TS3</cell><cell>46.06</cell><cell>66.90</cell><cell>75.98</cell><cell>79.02</cell><cell>78.40</cell><cell>76.30</cell><cell>5660</cell><cell>79.02</cell><cell>1187</cell></row><row><cell>TS4</cell><cell>48.17</cell><cell>71.25</cell><cell>82.12</cell><cell>86.85</cell><cell>88.23</cell><cell>88.12</cell><cell>18830</cell><cell>88.23</cell><cell>2216</cell></row><row><cell>TS5</cell><cell>47.95</cell><cell>70.71</cell><cell>81.20</cell><cell>85.80</cell><cell>86.84</cell><cell>86.47</cell><cell>21550</cell><cell>86.84</cell><cell>2835</cell></row><row><cell>TS6</cell><cell>47.05</cell><cell>69.05</cell><cell>79.05</cell><cell>82.88</cell><cell>83.19</cell><cell>82.03</cell><cell>18800</cell><cell>83.19</cell><cell>3160</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(b)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Percentage compression for group size m</head><label></label><figDesc></figDesc><table><row><cell>Test</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Size of</cell><cell>Best</cell><cell>Size</cell></row><row><cell>sequence</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>T D</cell><cell>compression</cell><cell>of T E</cell></row><row><cell>for CKT2</cell><cell>m = 2</cell><cell>m = 4</cell><cell>m = 8</cell><cell>m = 16</cell><cell>m = 32</cell><cell>m = 64</cell><cell>(bits)</cell><cell>(percent)</cell><cell>(bits)</cell></row><row><cell>TS1</cell><cell>46.89</cell><cell>68.81</cell><cell>78.44</cell><cell>82.12</cell><cell>82.66</cell><cell>81.34</cell><cell>11079</cell><cell>82.66</cell><cell>1921</cell></row><row><cell>TS2</cell><cell>37.60</cell><cell>51.70</cell><cell>54.27</cell><cell>50.85</cell><cell>43.16</cell><cell>-</cell><cell>234</cell><cell>54.27</cell><cell>107</cell></row><row><cell>TS3</cell><cell>45.94</cell><cell>67.20</cell><cell>76.29</cell><cell>79.71</cell><cell>79.55</cell><cell>-</cell><cell>14562</cell><cell>79.71</cell><cell>2954</cell></row><row><cell>TS4</cell><cell>46.89</cell><cell>68.81</cell><cell>78.44</cell><cell>82.12</cell><cell>82.66</cell><cell>81.34</cell><cell>11079</cell><cell>82.66</cell><cell>1921</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors thank Dr. Mark Hansen of Delphi Delco Electronics Systems for providing test sequences for the industrial circuits, Dr. Andrej Morosov of University of Potsdam for generating test sets using SIS, and Dr. Scott Davidson of Sun Microsystems for providing the test set for I99C1.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="bibr" target="#b0">1</ref> <p>This research was supported in part by the National Science Foundation under grant no. CCR-9875324, by a contract from Delphi Delco Electronics Systems, and by an equipment grant from Sun Microsystems.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Circuit</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Size of T D (bits)</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Testing embedded-core based systems chip</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zorian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Marinissen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Test Conference</title>
		<meeting>International Test Conference</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="130" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Logic BIST for large industrial designs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hetheringten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Fryars</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tamarapalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kassab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rajski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Test Conference</title>
		<meeting>International Test Conference</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="358" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Testing ICs: Getting to the core of the problem</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="32" to="38" />
			<date type="published" when="1996-11">November 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient BIST TPG design and test set compaction via input reduction</title>
		<author>
			<persName><forename type="first">C.-A</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="692" to="705" />
			<date type="published" when="1998-08">August 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Design of built-in test generator circuits using width compression</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chakrabarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1044" to="1051" />
			<date type="published" when="1998-10">October 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Built-in pattern generation for high-performance circuits using twisted-ring counters</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chakrabarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Iyengar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE VLSI Test Symposium</title>
		<meeting>IEEE VLSI Test Symposium</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="22" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Built-in self testing of sequential circuits using precomputed test sets</title>
		<author>
			<persName><forename type="first">V</forename><surname>Iyengar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chakrabarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE VLSI Test Symposium</title>
		<meeting>IEEE VLSI Test Symposium</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="418" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Deterministic built-in pattern generation for sequential circuits</title>
		<author>
			<persName><forename type="first">V</forename><surname>Iyengar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chakrabarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Electronic Testing: Theory and Applications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="97" to="114" />
			<date type="published" when="1999-10">August/October, 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scan vector compression/decompression using statistical coding</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ghosh-Dastidar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Touba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE VLSI Test Symposium</title>
		<meeting>IEEE VLSI Test Symposium</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="114" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Test vector decompression via cyclical scan chains and its application to testing core-based design</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Touba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Test Conference</title>
		<meeting>International Test Conference</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="458" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Test set compaction algorithms for combinational circuits</title>
		<author>
			<persName><forename type="first">I</forename><surname>Hamzaoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Test Conference on CAD</title>
		<meeting>International Test Conference on CAD</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="283" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On compacting test sets by addition and removal of vectors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kajihara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pomeranz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kinoshita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLSI Test Symposium</title>
		<meeting>VLSI Test Symposium</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="202" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Run-Length Encoding</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Golomb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="399" to="401" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Image data compression by predictive coding, Part I: Prediction Algorithm</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Bahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research &amp; Develoment</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page">164</biblScope>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Design compiler reference manual</title>
		<author>
			<persName><forename type="first">Synopsys</forename><surname>Inc</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">On the generation of test patterns for combinational circuits</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Ha</surname></persName>
		</author>
		<idno>no. 12_93</idno>
		<imprint/>
		<respStmt>
			<orgName>Department of Electrical Engineering, Virginia Tech ; The University of Illinois</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. report</note>
	<note>www.crhc.uiuc.edu/IGATE</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Test requirements for embedded core-based systems and IEEE P1500</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zorian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Test Conference</title>
		<meeting>International Test Conference</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="191" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">SIS: A system for sequential circuit synthesis</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Sentovich</surname></persName>
		</author>
		<idno>UCB/ERL M92/41</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
			<pubPlace>Berkeley, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Electronic Research Laboratory, University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
