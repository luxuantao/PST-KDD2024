<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Trustrace: Mining Software Repositories to Improve the Accuracy of Requirement Traceability Links</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Nasir</forename><surname>Ali</surname></persName>
							<email>nasir.ali@polymtl.ca</email>
							<affiliation key="aff0">
								<orgName type="department">De´partement de Ge´nie Informatique et Ge´nie Logiciel</orgName>
								<orgName type="institution">Ecole Polytechnique de Montre´al</orgName>
								<address>
									<addrLine>succursale Centre-Ville Montre´al</addrLine>
									<postCode>C.P. 6079, H3C 3A7</postCode>
									<region>QC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Trustrace: Mining Software Repositories to Improve the Accuracy of Requirement Traceability Links</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">232D55C78E5B0AEB43BF085AC80938D5</idno>
					<idno type="DOI">10.1109/TSE.2012.71</idno>
					<note type="submission">received 20 Mar. 2012; revised 4 July 2012; accepted 22 Oct. 2012; published online 26 Oct. 2012.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Traceability</term>
					<term>requirements</term>
					<term>feature</term>
					<term>source code</term>
					<term>repositories</term>
					<term>experts</term>
					<term>trust-based model</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Traceability is the only means to ensure that the source code of a system is consistent with its requirements and that all and only the specified requirements have been implemented by developers. During software maintenance and evolution, requirement traceability links become obsolete because developers do not/cannot devote effort to updating them. Yet, recovering these traceability links later is a daunting and costly task for developers. Consequently, the literature has proposed methods, techniques, and tools to recover these traceability links semi-automatically or automatically. Among the proposed techniques, the literature showed that information retrieval (IR) techniques can automatically recover traceability links between free-text requirements and source code. However, IR techniques lack accuracy (precision and recall). In this paper, we show that mining software repositories and combining mined results with IR techniques can improve the accuracy (precision and recall) of IR techniques and we propose Trustrace, a trust-based traceability recovery approach. We apply Trustrace on four medium-size open-source systems to compare the accuracy of its traceability links with those recovered using state-of-the-art IR techniques from the literature, based on the Vector Space Model and Jensen-Shannon model. The results of Trustrace are up to 22.7 percent more precise and have 7.66 percent better recall values than those of the other techniques, on average. We thus show that mining software repositories and combining the mined data with existing results from IR techniques improves the precision and recall of requirement traceability links.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>R EQUIREMENT traceability is defined as "the ability to describe and follow the life of a requirement, in both a forwards and backwards direction (i.e., from its origins, through its development and specification, to its subsequent deployment and use, and through all periods of ongoing refinement and iteration in any of these phases)" <ref type="bibr" target="#b0">[1]</ref>. Traceability links between the requirements 1 of a system and its source code are helpful in reducing system comprehension effort. They are also essential to ensuring that a system's source code is consistent with its requirements and that all and only the specified requirements have been implemented by developers. Yet, during software maintenance and evolution, as developers add, remove, or modify features, requirement traceability links become obsolete because developers do not/cannot devote effort to updating them <ref type="bibr" target="#b1">[2]</ref>. Yet, recovering these traceability links later is a daunting and costly task for developers.</p><p>Consequently, the literature has proposed methods, techniques, and tools to recover these traceability links semiautomatically or automatically <ref type="bibr" target="#b2">[3]</ref>.</p><p>Requirements traceability has received much attention over the past decade in the scientific literature. Many researchers used information retrieval (IR) techniques, e.g., <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, to recover traceability links between high-level documents, e.g., requirements, manual pages, and design documents, and low-level documents, e.g., source code and UML diagrams <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>. IR techniques assume that all software artifacts are/can be put in some textual format. Then, they compute the textual similarity between two software artifacts, e.g., the source code of a class and a requirement. A high textual similarity means that the two artifacts probably share several concepts <ref type="bibr" target="#b2">[3]</ref> and that, therefore, they are likely linked to one another.</p><p>The effectiveness of IR techniques is measured using IR metrics: recall, precision, or some average of both, like the F 1 score <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b6">[7]</ref>. For a given requirement, recall is the percentage of correct recovered links over the total number of pertinent, expected links, while precision is the percentage of correct recovered links over the total number of recovered links. High recall could be achieved by linking each requirement to all source code entities (classes, structures, methods, and functions), but precision would be close to zero. High precision could be achieved by reporting only obvious links, but recall would be close to zero. Either extreme cases are undesirable because developers then would need to manually review numerous candidate links to remove false positives and/or study the source code to recover missing links <ref type="bibr" target="#b2">[3]</ref>. Hence, the literature has proposed IR-based techniques that sought a balance between precision and recall.</p><p>During software maintenance and evolution, developers often evolve requirements and source code differently. Indeed, they often do not update requirements and requirement-traceability links with source code. Requirements and source code consequently diverge from each other, which decreases their textual similarity. Thus, IR techniques (or any combination thereof <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>) typically produce links with low precision and/or recall because, due to their very nature, they depend on the textual similarity between requirements and source code <ref type="bibr" target="#b9">[10]</ref>. Yet, while developers may not evolve requirements in synchronization with source code, they frequently update other sources of information, including CVS/SVN repositories, bug-tracking systems, mailing lists, forums, and blogs. We believe that we can exploit these other sources of information to build improved traceability-recovery approaches.</p><p>Consequently, we conjecture that: 1) We can mine software repositories, e.g., CVS/SVN repositories, to support the traceability recovery process and improve the precision and recall of IR-based traceability recovery approaches; 2) we can think of heterogeneous sources of information as experts whose opinions we can combine using a trust model to discard/rerank the traceability links provided by the IR techniques to improve accuracy; and 3) we can use an automatic, dynamic, per-link weighting technique rather than some global static weights to combine the opinions of experts to avoid the need of manually built oracles to tune weights.</p><p>Consequently, we design, implement, and evaluate Trustrace, a traceability-recovery approach between requirements and source code, which we use to support our conjectures. Trustrace uses heterogeneous sources of information to dynamically discard/rerank the traceability links reported by an IR technique. Trustrace consists of three parts:</p><p>1. Histrace mines software repositories to create links between requirements and source code using information from the repositories. Histrace stores all the recovered links between requirements and software repositories in dedicated sets, e.g., Histrace commits and Histrace bugs , which are considered as experts whose opinions will be used to discard/rerank baseline traceability links. For example, Histrace mines CVS/SVN repository to link requirements and source code using commit messages and provide the set of expert Histrace commits .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Trumo combines the requirement traceability links</head><p>obtained from an IR technique and discards/reranks them using the an expert's opinions and a trust model inspired by web-trust models <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>. It compares the similarity of the recovered links with those provided by the experts and with the number of times that the link appears in each expert's set. It is not tied to any specific IR-based traceability-recovery approach and can use any expert's opinion to adjust the ranking of recovered links. For example, the experts can be Histrace commits and/or Histrace bugs , taking advantage of CVS/SVN repositories and bug-tracking systems.</p><p>3. DynWing computes and assigns weights to the experts in the trust model dynamically, i.e., on a per-link basis. As combining different experts' opinions is still an active research area <ref type="bibr" target="#b8">[9]</ref>, researchers used either static weights computed using oracles <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b7">[8]</ref> or other techniques, e.g., principal component analysis (PCA) <ref type="bibr" target="#b8">[9]</ref>, for each source of information. However, defining a static weight for all the links for each expert may not be feasible because oracles may not be available or might be too costly to build. Thus, dynamic-weighting techniques are promising to assign weights for each link. DynWing analyzes each expert's similarity value for each link and assigns weights according to these values. We empirically evaluate Trustrace on four medium-size open-source systems, i.e., jEdit v4.3, Pooka v2.0, Rhino v1.6, and SIP Communicator v1.0-draft, to compare the accuracy of its recovered requirement traceability links with those of state-of-the-art IR techniques. As state-of-the-art IR techniques, we choose the Vector Space Model (VSM), a representative of the algebraic family of techniques, and Jensen-Shannon model (JSM), a representative of the probabilistic family of techniques. We use the IR measures of precision, recall, and the F 1 score. We also compare two different weighting techniques: PCA and DynWing. We thus report evidence that Trustrace improves, with statistical significance, the precision and recall of the recovered traceability links.</p><p>Hence, we found the evidence supporting our three conjectures about the benefits of 1) mining software repositories and considering the links recovered through these repositories as experts, 2) using a trust model inspired by web-trust models to combine these experts' opinions, and 3) weighting the experts' opinions dynamically for each link recovered using an IR technique. We also bring the following contribution with respect to our previous work <ref type="bibr" target="#b1">[2]</ref>:</p><p>. We implement and use two experts, i.e., Histrace commits when mining CVS/SVN and Histrace bugs when mining bug reports. . We propose DynWing, a dynamic weighting technique to automatically assign weights to different experts on a per-link basis. . We compare DynWing with a PCA-based weighting technique and with a static weighting technique to analyze the potential improvement of using different weighting techniques. . We study the impact of Trustrace on another IR technique, i.e., the Jensen-Shannon similarity model. . We perform detailed statistical analyses of the data distribution to select an appropriate statistical test as well as to measure the effect size of Trustrace over JSM and VSM. . We perform experiments on four medium-size opensource systems, i.e., two additional systems, jEdit and Rhino, in addition to Pooka and SIP, to analyze the impact of Trustrace. Section 2 describes our approach, Trustrace, and our three novel techniques: Histrace, Trumo, and DynWing. Section 3 presents our empirical evaluation of Trustrace, while Section 4 reports its results. Section 5 provides a discussion of the results and a qualitative analysis. Section 6 puts our work in perspective with respect to previous work. Finally, Section 7 concludes and sketches future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">TRUSTRACE: TRUST-BASED TRACEABILITY</head><p>We now present Trustrace. Trustrace uses software repositories, e.g., CVS/SVN repositories and bug-tracking systems, as experts to trust more or less some baseline links recovered by an IR technique and, thus, to discard/rerank the links to improve the precision and recall of the IR-based techniques. Fig. <ref type="figure" target="#fig_0">1</ref> shows the high-level architecture of Trustrace, whose conceptual steps we detail in the following sections: Section 2.1 provides the definitions of the terms that we use to describe Trustrace; Section 2.2 describes Histrace, our traceability recovery technique based on mining software repositories; Section 2.3 describes our trust model; and Section 2.4 details our dynamic weighting technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">In a Nutshell</head><p>In the following, without loss of generality, we target objectoriented systems and use classes as representative of source code files. We also consider classes because considering packages is likely to be too coarse grained, as a package contributes to the implementation of several requirements, while considering methods is likely to be too fine grained as a method only participates in the implementation of some requirement(s) and rarely implements them entirely. Moreover, CVS/SVN software repositories only consider files, not packages or methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Definitions</head><p>In Trustrace, we represent a traceability link as a triple {source document, target document, similarity} and we use the following notations. Let R ¼ fr 1 ; . . . ; r N g be a set of requirements and C ¼ fc 1 ; . . . ; c M g be a set of classes supposed to implement these requirements. Let T ¼ fT 1 ; . . . ; T P g be a collection of sets where each T i ¼ ft 1 ; . . . ; t Ni g is a set of homogeneous pieces of information, e.g., the set of all CVS/SVN commits or of all bug reports for a given system. P is the total number of experts.</p><p>Then, let us assume that, for each T i 2 T , we define a function T i mapping one element of T i into a subset of C. For example, if T i is a set of bug reports, then, for a given bug report t k , T i ðt k Þ returns the set of classes affected by t k , with Ti ðt k Þ C.</p><p>Let R2C be the set of baseline traceability links recovered between R and C by any standard IR technique, such as VSM, and further, assume that, for each set T i 2 T , we build a set R2CT i;rj;tk for each expert T i as follows:</p><formula xml:id="formula_0">R2CT i;rj;tk ¼ fðr j ; c s ; 0 i ðr j ; t k ÞÞjc s 2 Ti ðt k Þ &amp; t k 2 T i g:</formula><p>Finally, let us define two functions and . The first function, ðr j ; c s ; 0 ðr j ; c s ÞÞ, returns the pair of documents (or set of pairs) involved in a link, e.g., requirements and source code, i.e., ðr j ; c s Þ. The second function, ðr j ; c s ; 0 ðr j ; c s ÞÞ, returns the similarity score 0 ðr j ; c s Þ of the link.</p><p>Given these definitions, Trustrace works as follows: It first builds the set R2C from R and C using an IR technique. Then, it calls Histrace to build the sets R2CT i;r j ;t k using CVS/SVN commit messages and bug reports. Second, it uses Trumo to evaluate the trustworthiness of each link using DynWing to compute the weights i ðr j ; c s Þ to assign to each link in the sets R2CT i;rj;tk , and to rerank the similarity values of the link, using the experts' opinions R2CT i;r j ;t k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Information Retrieval Technique</head><p>Trustrace uses IR techniques for two different purposes: 1) to create the baseline set of traceability links R2C, whose similarity values will be recomputed using Trumo and DynWing using the output of Histrace, and 2) to create the output sets of Histrace, R2CT i;rj;tk .</p><p>IR techniques consider all the software artifacts as textual documents. They extract all the terms from the documents and compute the similarity between two documents based on the similarity of their terms and/or their distributions. With any IR technique, a high similarity value between two documents suggests a potential link between them. IR techniques take some preprocessed documents, as explained in the following, as input to build an m Â n termby-document matrix, where m is the number of all unique terms that occur in the documents and n is the number of documents in the corpus. Then, each cell of the matrix contains a value w i;j , which represents the weight of the ith term in the jth document, i.e., the importance of the term in the corpus. Various term weighting schemes are available to compute the weight of a term <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b14">[15]</ref>. Different IR techniques <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref> can be used to compute the similarity between two documents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Histrace</head><p>Histrace creates links between the set of requirements, R and the source code, C, using the software repositories T i , i.e., in the following, T 1 stands for CVS/SVN commit messages and T 2 for bug reports. Histrace considers the requirements' textual descriptions, CVS/SVN commit messages, bug reports, and classes as separate documents. It uses these sources of information to produce two experts, R2CT 1;r j ;t k , which we call Histrace commits in the following for simplicity, and R2CT 2;r j ;t k , which we call Histrace bugs , which use CVS/SVN commit messages and bug reports, respectively, to create traceability links between R and C through the T i . Below, we discuss each step of Histrace in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Document Preprocessing</head><p>Depending on the input information source (i.e., requirements, source code, CVS/SVN commit messages, or bug reports), we perform specific preprocessing steps to remove irrelevant details from the source, (e.g., CVS/SVN commit number, source code punctuation, or language keywords), split identifiers, and, finally, normalize the resulting text using stop-word removal and stemming.</p><p>Requirements and source code: Histrace first processes source code files to extract all the identifiers and comments from each class. Histrace then uses underscore and the CamelCase convention <ref type="bibr" target="#b2">[3]</ref> to split identifiers into terms, thus producing a separate document for each class.</p><p>Histrace then performs the following steps to normalize requirements and source code documents: 1) converting all upper case letters into lower case and removing punctuation, 2) removing all stop words (such as articles, numbers, and so on), and 3) performing word stemming using the Porter Stemmer <ref type="bibr" target="#b17">[18]</ref>, bringing back inflected forms to their morphemes.</p><p>CVS/SVN commit messages: We use Ibdoos<ref type="foot" target="#foot_0">2</ref> to convert CVS/SVN commit logs into a unified format and put all commit messages into a database for ease of treatment. Ibdoos provides parsers for various formats of commit logs, including CVS, Git, and SVN.</p><p>To build Histrace commits , Histrace first extracts CVS/ SVN commit logs and excludes those that 1) are tagged as "delete" because they concern classes that have been deleted from the system and thus cannot take part in any traceability link, 2) do not concern source code (e.g., if a commit only contains HTML or PNG files), 3) have messages of length shorter than or equal to one English word because such short messages would not have enough semantics to participate in creating R2CT 1;rj;tk .</p><p>Histrace then extracts the CVS/SVN commit messages as well as the classes that 1) are still part of the source code and 2) have been part of the commits. Histrace applies the same normalization steps on CVS/SVN commit messages as those for requirements and source code.</p><p>Following our definitions, T 1 is the set of all remaining CVS/SVN commit messages and, for any t k 2 T 1 , we have a function T1 that returns a subset of the classes C 0 k &amp; C ¼ fc 1 ; . . . ; c M g modified in the commits. Histrace uses commit messages and an IR-based technique to compute 0 r i ;t k . Using T1 , Histrace builds R2CT 1;rj;tk .</p><p>For example, Histrace could use an IR technique, e.g., VSM, to link the CVS/SVN log Logs 1741 of Pooka, containing NewMessageInfo.java, to the requirement r 21 . This means that Histrace can simply link r 21 to NewMessageInfo.java and add it to the Histrace commits set for Pooka.</p><p>Bug reports: To build Histrace bugs , Histrace extracts all the bug reports from a bug-tracking system. Usually, bug reports do not contain explicit information about the source code files that developers updated to fix a bug. All the details about the updated, deleted, or added source code files are stored in some CVS/SVN repository. Therefore, Histrace must link CVS/SVN commit messages to bug reports before being able to exploit bug reports for traceability.</p><p>Histrace uses regular expressions, i.e., a simple text matching approach but with reasonable results, to link CVS/SVN commit messages to bug reports. However, Histrace could also use more complex techniques, such as those in <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>. Consequently, Histrace assumes that developers assigned to each bug a unique ID that is a sequence of digits recognizable via regular expressions. The same ID must be referred to by developers in the CVS/SVN commit messages.</p><p>Then, to link CVS/SVN commit messages to bug reports concretely, Histrace performs the following steps: 1) extracts all CVS/SVN commit messages, along with commit status and committed files, 2) extracts all the bug reports, along with time/date and textual descriptions, and 3) links each CVS/SVN commit message and bug reports using regular expressions, e.g., ððbÞ½ugf0; 2gns Ã ½idf0; 3gjidjfixjprj#Þ ½ns# ¼ Ã ½?ð½0 À À9f4; 6gÞ? which is the regular expression tuned to the naming and numbering conventions used by the developers of Rhino. This expression must be updated to match other naming and numbering conventions, as discussed in Section 3.6.4.</p><p>In its last step, Histrace removes false-positive links by imposing the following constraint: fixðe½dsÞ?jbugs?jproblems?jdefects?patch 00 : This regular-expression constraint only keeps a CVS/ SVN commit if it contains a keyword, i.e., fix(es), fixed, bug(s), problem(s), defect(s), or patch, followed by a number, i.e., if it follows naming conventions for bug numbering usual in open-source development. It thus returns the bug reports linked to CVS/SVN commit messages.</p><p>Following our definitions, T 2 is the set of all bug reports and, for any t k 2 T 2 , we have a function T 2 that returns a subset of classes C 0 k &amp; C ¼ fc 1 ; . . . ; c M g modified to fix a bug. Histrace uses the bug reports and an IR-based technique to compute 0 r i ;t k . Using T1 , Histrace builds R2CT 2;r j ;t k as explain above.</p><p>For example, Histrace could use an IR technique to link the bug report bug 434 to requirement r 11 . Then, it could link the bug report bug 434 to the CVS/SVN log Logs 4912 in SIP using the appropriate regular expression. Logs 4912 contains FirstWizardPage.java and DictAccountRegistra-tionWizard.java. Thus, Histrace could link r 11 to FirstWizardPage.java and DictAccountRegistra-tionWizard.java to build the Histrace bugs set for SIP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Trumo</head><p>Trumo assumes that different experts Histrace commits (also known as R2CT 1;rj;tk ) and Histrace bugs (R2CT 2;rj;tk ) know useful information to discard or rerank the traceability links between two documents, e.g., requirements and source code classes. Trumo is thus similar to a web model of the users' trust: The more users buy from a web merchant, the higher the users' trust of this merchant <ref type="bibr" target="#b13">[14]</ref>.</p><p>By the definitions in Section 2.1, in (1), r j is a requirement with r j 2 R; c s is a class with c s 2 T i ðt k Þ because we use the sets T i 2 T to build a set of trustable links T r; 0 i is the similarity score between the requirement r j and some class t k such that t k 2 T i and ðR2CT i;rj;tk Þ returns a pair ðr j ; t k Þ. With (1), Trumo uses the set of candidate links l rc ¼ ðr j ; c s ; i ðr j ; c s ÞÞ with j 2 ½1; . . . ; N and s 2 ½1; . . . ; M and the sets of candidate links l rt ¼ ðr j ; c s ; 0 i ðr j ; t k ÞÞ with j 2 ½1; . . . ; N and k 2 ½1; . . . ; N i generated from each expert T i and, for each requirement r j 2 R: T r ¼ fðr j ; c s ; 0 i ðr j ; t k ÞÞj 9 t k 2 T i :</p><formula xml:id="formula_1">ðr j ; c s Þ 2 ðR2CT i;r j ;t k Þ &amp; ðr j ; c s Þ 2 ðR2CÞg:<label>ð1Þ</label></formula><p>Fig. <ref type="figure" target="#fig_1">2</ref> shows the Venn diagram of the R2C, R2CT i;rj;tk , and T r sets. The last constraint ðr j ; c s Þ 2 ðR2CÞ imposes that a link be present in the baseline set R2C and in any of the R2CT i;rj;tk sets. If a link does not satisfy this constraint, then Trumo discards it. Then, Trumo reranks the similarity of the remaining links in T r as follows: Let T C i ðr j ; c s Þ be the restriction of T r on ðr j ; c s Þ for the source T i , i.e., the set fðr j ; c s ; 0 i ðr j ; t k ÞÞ 2 T rg, then Trumo assigns to the links in</p><formula xml:id="formula_2">T C i ðr j ; c s Þ a new similarity Ã i ðr j ; c s Þ computed as Ã i ðr j ; c s Þ ¼ ðr j ; c s Þ þ P l2T C i ðr j ;c s Þ ðlÞ 1 þ jT C i ðr j ; c s Þj ;<label>ð2Þ</label></formula><p>where ðr j ; c s Þ is the similarity between the requirement r j and the class c s as computed in R2C and ðlÞ is the similarity of the documents linked by the link l of T C i ðr j ; c s Þ, i.e., derived from t k , which means 0 i ðr j ; t k Þ. Finally, jT C i ðr j ; c s Þj is the number of elements in T C i ðr j ; c s Þ. The higher the evidence (i.e., P l2T C i ðr j ;c s Þ ðlÞ) provided by links in T C i ðr j ; c s Þ, the higher the new similarity Ã i ðr j ; c s Þ; on the contrary, little evidence decreases Ã i ðr j ; c s Þ. Finally, Trumo assigns weight to each expert and combines their similarity values to assign a new similarity value to each link in T r using the function:</p><formula xml:id="formula_3">r j ;c s ðT rÞ ¼ X P i¼1 i ðr j ; c s Þ Ã i ðr j ; c s Þ þ P þ1 ðr j ; c s Þ jT rðr j ; c s Þj max n;m jT rðr N ; C M Þj ;<label>ð3Þ</label></formula><p>where T rðr j ; c s Þ is the subset of T r restricted to the links between r j and c s , i ðr j ; c s Þ 2 ½0; 1 and</p><formula xml:id="formula_4">1 ðr j ; c s Þ þ 2 ðr j ; c s Þ þ Á Á Á þ P þ1 ðr j ; c s Þ ¼ 1;</formula><p>recall that P is the total number of experts. With the function, the more often a pair ðr j ; c s Þ exists in T r, the more we can trust this link (if such a link is also present in R2C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">DynWing</head><p>To automatically decide the weights i ðr j ; c s Þ for each expert, we apply a dynamic weighting technique. Existing techniques <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b7">[8]</ref> to define weights use static weights for all the experts. Thus, they require oracles to decide a "good" weight or range of weights. However, with real, legacy systems, no such oracle exists, i.e., no a priori-known set of traceability links exists. Moreover, using the same static weight may not be beneficial for all the recovered links. Therefore, we consider each link recovered by a baseline IR technique and by the different experts as an independent link and dynamically assign weights to baseline links and each expert. Choosing the right weight per link is a problem that we formulate as a maximization problem. Basically, we have different experts, i.e., CVS/SVN commits, bug reports, and others, to trust a link. Each expert has its own trust into the link. By maximizing the similarity value r j ;c s ðT rÞ (and hence determining the optimal i ðr j ; c s Þ values), DynWing automatically identifies the experts that are most trustworthy (highest i ðr j ; c s Þ values) and those that are less trustworthy (lowest i ðr j ; c s Þ values): max 1ðrj;csÞ;:::;Pþ1ðrj;csÞ</p><formula xml:id="formula_5">f rj;cs ðT rÞg;<label>ð4Þ</label></formula><p>with the following constraints: </p><formula xml:id="formula_6">0 i ðr j ; c s Þ 1; i ¼ 1; Á Á Á ; P þ 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EMPIRICAL EVALUATION</head><p>We now report on an empirical evaluation of Trustrace with four systems to assess its accuracy in terms of precision and recall. We use two state-of-the-art IR techniques, i.e., JSM and VSM, for evaluation purposes. We use the names T rustrace V SM and T rustrace JSM to denote the IR techniques that Trustrace uses. We also compare the DynWing weighting technique of Trustrace with the PCA weighting technique <ref type="bibr" target="#b8">[9]</ref>. We implement Trustrace and its three novel techniques in FacTrace 3 (artiFACT TRACEability). FacTrace provides several modules with activities ranging from traceability recovery to the manual verification of traceability links.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Goal</head><p>The goal of our empirical evaluation is to study the accuracy of Trustrace when recovering traceability links against that of a single IR technique, JSM and VSM, using requirements, source code, CVS/SVN commits, and/or bug reports as experts. The quality focus is the accuracy of Trustrace in terms of precision and recall <ref type="bibr" target="#b20">[21]</ref>. It is also the improvement brought by the dynamic weighting technique, DynWing, with respect to a PCA-based technique in terms of F 1 score. The perspective is that of practitioners interested in recovering traceability links with greater precision and recall values than that of currently available traceability recovery IR-based techniques. It is also that of researchers interested in understanding whether or not we can support our conjectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Research Questions</head><p>Our research questions are:</p><p>. RQ1: How does the accuracy of the traceability links recovered by Trustrace compare with that of approaches based on JSM and VSM alone? . RQ2: How does the accuracy of the traceability links recovered using DynWing compare to that using PCA? To answer RQ1, we assess the accuracy of JSM, Trustrace, and VSM in terms of precision and recall by applying them on four systems seeking to reject the four null hypotheses:</p><p>. H 01 : There is no difference in the precision of the recovered traceability links when using Trustrace or VSM. . H 02 : There is no difference in the precision of the recovered traceability links when using Trustrace or JSM. . H 03 : There is no difference in the recall of the recovered traceability links when using Trustrace or VSM. . H 04 : There is no difference in the recall of the recovered traceability links when using Trustrace or JSM. To answer RQ2, we use the DynWing and PCA weighting techniques and compute the F 1 score of Trustrace to analyze which weighting technique provides better results. We try to reject the two null hypotheses:</p><p>. H 05 : DynWing does not provide automatically better i ðr j ; c s Þ than a PCA-based weighting technique for T rustrace V SM . . H 06 : DynWing does not provide automatically better i ðr j ; c s Þ than a PCA-based weighting technique for T rustrace JSM .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Variables</head><p>We use precision, recall, and F 1 score as dependent variables. All measures have values in the range ½0; 1:</p><formula xml:id="formula_7">P recision ¼ jfrelevant linksg \ fretrieved linksgj jfretrieved linksgj ; Recall ¼ jfrelevant linksg \ fretrieved linksgj jfrelevant linksgj :</formula><p>The F 1 score is the harmonic mean of precision and recall, which is computed as</p><formula xml:id="formula_8">F 1 ¼ 2 1 R þ 1 P ;</formula><p>where R is the recall, P is the precision, and F 1 is the harmonic mean of R and P . We use the F 1 score to compare DynWing and PCA because F 1 equally weighs precision and recall. Thus, it shows which weighting technique provides the best precision and recall values. We use the approaches, either single IR technique, i.e., JSM and VSM, or Trustrace, as independent variables. The independent variable corresponding to Trustrace also includes varying values of i using the DynWing and PCAbased weighting techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Objects</head><p>We select the four open-source systems, jEdit 4.3, Pooka v2.0, Rhino 1.6, and SIP Communicator 1.0-draft, because they satisfy our key criteria. First, we choose open-source systems so that other researchers can replicate our evaluation. Second, all systems are small enough so that we could recover and validate their traceability links manually in previous work <ref type="bibr" target="#b1">[2]</ref> while still being a real-world system.</p><p>jEdit 4 is a text editor for developers written in Java. jEdit includes a syntax highlighter that supports over 130 file formats. It also allows developers to add additional file formats using XML files. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Oracles</head><p>We use four oracles, i.e., Oracle jEdit , Oracle Pooka , Oracle Rhino , and Oracle SIP , to compute the precision and recall values of JSM, Trustrace, and VSM when applied on our four object systems.</p><p>For Pooka and SIP, the first author and another PhD student created traceability links between the requirements of the two systems and their source code classes. They read the requirements and manually looked for classes in the source code that implement these requirements. They used Eclipse to search for the source code and stored all manually built links in FacTrace database. The second and third authors used the FacTrace voting system to accept or reject all manually built links. At no point of the process did we use any automated technique or software repository to create the oracles. This process is the same as used in our previous work <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b21">[22]</ref>.</p><p>For jEdit and Rhino, we use the same oracles as previous researchers (Eaddy et al. <ref type="bibr" target="#b22">[23]</ref> and Dit et al. <ref type="bibr" target="#b23">[24]</ref>), which helps mitigating threats to the validity of our evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Preprocessing</head><p>We now detail how we gather and prepare the input data necessary to perform our empirical evaluation of Trustrace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.1">Requirements</head><p>jEdit contains 34 requirements. These requirements were manually identified and extracted from the jEdit source code repository <ref type="bibr" target="#b23">[24]</ref>. In previous work <ref type="bibr" target="#b1">[2]</ref>, we used PREREQUIR <ref type="bibr" target="#b6">[7]</ref> to recover requirements for Pooka and SIP. We recovered 90 and 82 requirements for both systems, respectively. Rhino contains 268 requirements that we extracted from the related ECMAScript specifications by considering each ECMAScript section as a requirement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.2">Source Code</head><p>We downloaded the source code of jEdit v4.3, Pooka v2.0, Rhino v1.6, and SIP v1.0-draft from their respective CVS/ SVN repositories. We made sure that we had the correct files for each system before building traceability links by setting up the appropriate environments and by downloading the appropriate libraries. We thus could compile and run all the systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.3">CVS/SVN Commit Messages</head><p>Fig. <ref type="figure" target="#fig_2">3</ref> shows an excerpt of a commit of Pooka. There are 3,762, 1,743, 3,261, and 8,079 SVN commits for jEdit, Pooka, Rhino, and SIP, respectively. We performed the data preprocessing steps described in Section 2.2.1 on all SVN commits with the help of FacTrace.</p><p>After performing the preprocessing steps, we obtained 2,911, 1,393, 2,508, and 5,188 SVN commits for jEdit, Pooka, Rhino, and SIP, respectively. There were many SVN commits that did not concern source code files. Also, some commit messages contained both source code files and other files. For example, revision 1604 in Pooka points only to HTML files except for one Java file, FolderInternalFrame.java. Therefore, we only kept the Java file and removed any reference to the HTML files. We stored all filtered SVN commit messages and related files in a FacTrace database.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.4">Bug Reports</head><p>We cannot use jEdit <ref type="bibr" target="#b23">[24]</ref> and Pooka bug reports because the first system does not have a publicly available bug repository and the second one has too few recorded bugs <ref type="bibr" target="#b15">(16)</ref>. Rhino is part of the Mozilla browser and its bug reports are available via the Mozilla Bugzilla bug tracker. We extracted all 770 bugs reported against Rhino and used Histrace to link them with the CVS repository as described in Section 2.2. Histrace automatically linked 457 of the bug reports to their respective commits. In the case of SIP, we downloaded 413 bug reports. SIP developers did not follow any rule while fixing bugs to link bug reports and commits. Hence, there was no bug ID in the commit messages. However, developers referenced SVN revision numbers in the bug reports' comments, e.g., bug ID 237 contains the revision ID r4550. We tuned the regular expression of Histrace to find the revision IDs in the descriptions of the SIP bug reports. Histrace thus extracted all the bug IDs and linked them to SVN commits. Overall, Histrace automatically linked 169 bugs reported against SIP to their respective commits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.5">Last Preprocessing Step</head><p>We automatically extracted all the identifiers from the jEdit, Pooka, Rhino, and SIP requirements, source code, filtered CSV/SVN commit messages, and filtered bug reports, using FacTrace. The output of this step is four corpora that we use for creating traceability links, as explained in Sections 2.2 and 2.3. 6. http://www.mozilla.org/rhino/. 7. http://www.jitsi.org.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">IR Techniques</head><p>To build the sets of traceability links, we use the VSM (from the algebraic family of techniques) and JSM (from the probabilistic family of techniques) techniques. Abadi et al. <ref type="bibr" target="#b14">[15]</ref> performed experiments using different IR techniques to recover traceability links. Their results show that the Vector Space Model and the Jensen-Shannon model outperform other IR techniques. In addition, these two techniques do not depend on any parameter. Thus, we use both JSM and VSM to recover traceability links and compare their results in isolation with those of Trustrace. These techniques both essentially use term-by-document matrices. Consequently, we choose the well-known T F =IDF measure <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b26">[27]</ref> for VSM and the normalized term frequency measure <ref type="bibr" target="#b14">[15]</ref> for JSM. These two measures and IR techniques are state-of-the-art IR techniques. In the following, we explain both techniques in details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.1">Vector Space Model</head><p>Many traceability recovery techniques use VSM as the base algorithm <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref>. In VSM, documents are represented as vector in the space of all the terms. Different term weighting schemes can be used to construct these vectors. We use the standard T F =IDF weighting scheme <ref type="bibr" target="#b27">[28]</ref>: A document is a vector of T F =IDF weights. T F is often called the local weight. The most frequent terms will have more weight in T F , but this by itself does not mean that they are important terms. The inverse document frequency, IDF , of a term is calculated to measure the global weight of a terms and is computed as</p><formula xml:id="formula_9">IDF ¼ log 2 ð jDj jd:t i 2dj Þ. Then, T F =IDF is defined as ðT F =IDF Þ i;j ¼ n i;j P k n k;j Â log 2 jDj jd : t i 2 dj ;</formula><p>where n i;j are the occurrences of a term t i in document d j , P k n k;j is the sum of the occurrences of all the terms in document d j , jDj is the total number of documents d in the corpus, and jd : t i 2 dj is the number of documents in which the term t i appears.</p><p>Once documents are represented as vectors of terms in a VSM, traceability links are created between every two documents with their own similarity value depending on each pair of documents, e.g., a requirement and a class. The similarity between two documents is measured by the positive cosine of the angle between their corresponding vectors (because the similarity between two documents cannot be negative). The ranked list of recovered links and a similarity threshold are used to divide links into a set of candidate links to be manually verified <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.2">Jensen-Shannon Model</head><p>JSM is an IR technique proposed by Abadi et al. <ref type="bibr" target="#b14">[15]</ref>. It is driven by a probabilistic approach and hypothesis testing technique. JSM represents each document through a probability distribution, i.e., a normalized term-by-document matrix. The probability distribution of a document is</p><formula xml:id="formula_10">p ¼ nðw; dÞ T d ;</formula><p>where nðw; dÞ is the number of times a word appears in a document d and T d is the total number of words appearing in d. The empirical distribution can be modified to take into account the term's global weight, e.g., IDF . After considering the global weight, each document distribution must be normalized. Once the documents are represented as probability distribution, JSM computes the distance between two documents' probability distribution and returns a ranked list of links. JSM ranks target documents via the "distance" of their probability distributions to that of the source documents:</p><formula xml:id="formula_11">JSMðq; dÞ ¼ H p q þ p d 2 À Hðp q Þ þ Hðp d Þ 2 ; HðpÞ ¼ X hðpðwÞÞ; hðxÞ ¼ Àx log x;</formula><p>where HðpÞ is the entropy of the probability distribution p, and p q and p d are the probability distributions of the two documents (a "query" and a "document"), respectively. By definition, hð0Þ 0. We compute the similarity between two documents using 1 À JSMðq; dÞ. The similarity values are in ½0; 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Building Sets of Traceability Links</head><p>First, we use JSM and VSM to create traceability links, i.e., R2C JSM and R2C V SM , between requirements and source code. Second, we apply Histrace commits , as described in Section 2.2, to process jEdit, Pooka, Rhino, and SIP CVS/SVN commit messages (T 1 ), and requirements to create the traceability link set R2CT 1;rj;tk . We process SIP and Rhino bug reports (T 2 ) to create the traceability link sets R2CT 2;rj;tk using Histrace bug .</p><p>For example, we trace Pooka requirement "it should have spam filter option" to the SVN commit message "adding prelim support for spam filters." SVN commit revision number 1133. Then, we recover all the source code classes related to this commit, i.e., SpamSearchTerm.java and SpamFilter.java. Finally, we create a direct traceability link between the files SpamSearchTerm.java and SpamFilter.java to the requirement "it should have spam filter option."</p><p>Third, we apply Trumo as described in Section 2.3 using traceability links recovered with JSM and VSM. We thus compute two sets R2C, R2C JSM and R2C V SM , one with each IR technique. We then apply the Trumo equation via CVS/SVN commit messages and-or bug reports to discard/ rerank links by computing new similarity values using <ref type="bibr" target="#b2">(3)</ref>. These values help to answer RQ1 and to attempt rejecting our null hypotheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9">Weighting Technique</head><p>We use DynWing as presented in Section 2.4 and compare with PCA <ref type="bibr" target="#b8">[9]</ref>. We use these two weighting techniques on the recovered traceability links of jEdit, Pooka, Rhino, and SIP to answer RQ2 and attempt rejecting our null hypotheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9.1">Principal Component Analysis</head><p>PCA is a mathematical analysis used in a recent case study on traceability <ref type="bibr" target="#b8">[9]</ref> to combine different IR techniques and to define weights for each technique. PCA defines a single static weight for each expert.</p><p>PCA uses an orthogonal transformation to convert a set of correlated variables into a set of values of uncorrelated variables, called principal components. This transformation is defined in such a way that the proportion of variance for each principal component (PC) is P C 1 &gt; PC 2 &gt; . . . P C n . The number of PCs is less than or equal to the number of original variables.</p><p>Gethers et al. <ref type="bibr" target="#b8">[9]</ref> compute the weights for different IR techniques using PCA as follows: 1) They use the value of the proportion of variance based on the PC with the highest correlation and 2) they normalize values to obtain weights for each technique. For example, if P C 1 's proportion of variance is 71.29 percent and CVS/SVN has a correlation of 0.99, we would assign 71.29 percent to CVS/SVN. Likewise, if a bug report has a higher correlation than P C 1 when compared to other P Cs, it would also receive a value of 71.29 percent. After assigning values of proportions of variances to all experts, we normalize the values so their sum equals to one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.10">Experimental Settings</head><p>We must choose only one setting before applying Trustrace: our global trust of the experts. This global trust helps DynWing to assign weights to each link according to our a priori trust in each expert as mentioned in Section 2.4. In our empirical evaluation, we define the global trust as commits ! bugs ! pþ1 &gt; 0:</p><p>This global weight ensures that DynWing gives more weight to the Histrace commits expert than to the Histrace bugs expert. We choose to favor Histrace commits based on the quality of the semantic information contained in the commit messages, the bug reports, and the source code classes, as further discussed in Section 5.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.11">Analysis Method</head><p>We use Oracle jEdit , Oracle Pooka , Oracle Rhino , and Oracle SIP to compute the precision and recall values of the links recovered using JSM, Trustrace, and VSM. JSM and VSM assign a similarity value to each and every traceability link whereas Trustrace uses its model, defined in Section 2.3, to reevaluate the similarity values of the links provided by a baseline technique.</p><p>To answer RQ1, we perform several experiments with different threshold values on the recovered links to perform statistical tests on precision and recall values. We use a threshold t to prune the set of traceability links, keeping only links whose similarities values are greater than or equal to t 2 ½0; 1. We use different values of t from 0.01 to 1 per steps of 0.01 to obtain different sets of traceability links with varying precision and recall values, for all approaches. We then perform paired-statistical tests to measure the improvements brought by Trustrace. In the paired-statistical tests, two chosen approaches must have the same number of data points. Therefore, we keep the same threshold t values for both approaches. For example, if VSM discards all traceability links whose textual similarity values are below the 0.7 threshold, then we also use the same 0.7 threshold for Trustrace.</p><p>Then, we assess whether the differences in precision and recall values, in function of t, are statistically significant between the JSM, Trustrace, and VSM approaches. To select an appropriate statistical test, we use the Shapiro-Wilk test to analyze the distributions of our data points. We observe that these distributions do not follow a normal distribution. Thus, we use a nonparametric test, i.e., Mann-Whitney test, to test our null hypotheses to answer RQ1.</p><p>An improvement might be statistically significant, but it is also important to estimate the magnitude of the difference between the accuracy levels achieved with a single IR technique and Trustrace. We use a nonparametric effect size measure for ordinal data, i.e., Cliff's d <ref type="bibr" target="#b26">[27]</ref>, to compute the magnitude of the effect of Trustrace on precision and recall as follows:</p><formula xml:id="formula_12">d ¼ #ðx 1 &gt; x 2 Þ À #ðx 1 &lt; x 2 Þ n 1 n 2 ;</formula><p>where x 1 and x 2 are precision or recall values with JSM, Trustrace, and VSM, and n 1 and n 2 are the sizes of the sample groups. The effect size is considered small for 0:15 d &lt; 0:33, medium for 0:33 d &lt; 0:47, and large for d ! 0:47.</p><p>To answer RQ2, we use PCA and DynWing to assign weights to the traceability links recovered using Trustrace. We use different values of t from 0.01 to 1 per steps of 0.01 to obtain different sets of traceability links with varying F 1 scores. We use the Mann-Whitney to reject the null hypotheses H 05 and H 06 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>We now present the results and answers to our two research questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">RQ1: How Does the Accuracy of the Traceability</head><p>Links Recovered by Trustrace Compare with that of Approaches Based on JSM and VSM Alone?</p><p>Fig. <ref type="figure">4</ref> shows the precision and recall graphs of JSM, Trustrace, and VSM. Trustrace provides better precision and recall values than the two IR techniques by themselves. Table <ref type="table">1</ref> shows the average precision and recall values calculated by comparing the differences between the JSM, Trustrace, and VSM approaches. Trustrace with DynWing has better precision and recall than the other weighting techniques. The recall value for Pooka improves on average but without statistical significance when compared to VSM results. In the case of SIP with only the Histrace bugs expert, recall values decrease with statistical significance when compared to VSM values, as discussed in Section 5.1. There is no statistically significant decrease in recall when compared to JSM results. We explored the reason for the recall values to decrease in the case of SIP with Histrace bugs . We found that only 4 percent of SIP SVN commits are linked to bug reports. Therefore, we did not find much evidence for many links and this lack of evidence yielded many links from the baseline set to be removed, following our constraints in (1), and, consequently, a lower recall. We performed the statistical tests described in Section 3.11 to verify whether or not the average improvements in precision and recall are statistical significant. We have statistically significant evidence to reject H 01 and H 02 . Table <ref type="table">1</ref> shows that the p-values for the precision values are below the standard significant value, ¼ 0:05. The reported figures show that, for most values of precision and recall, we can reject H 03 and H 04 in all but three cases (in bold in Table <ref type="table">1</ref>). Thus, we cannot claim to always reject H 03 and H 04 : In two cases for VSM and one for JSM, recall values do not improve.</p><p>We use Cliff's d as introduced in Section 3.11 to measure the effect of Trustrace over single IR techniques. Table <ref type="table">1</ref> shows that Trustrace has a large effect on the improvements in precision and recall values in 66 percent, medium in 19 percent, small in 9 percent of the improvements. Only in the case of SIP, i.e., 6 percent, with only Histrace bugs did Trustrace recall values decrease with one large and one small effect size. Overall, the obtained effect size values indicate a practical improvement with Trustrace.</p><p>We answer RQ1: How does the accuracy of the traceability links recovered by Trustrace compare with that of approaches based on JSM and VSM alone? as follows: Trustrace helps to recover more correct links than IR techniques alone. When two experts are available, Trustrace is always better. In only one case and with just a single expert due to a lack of external source of information, did recall go down.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">RQ2: How Does the Accuracy of the Traceability</head><p>Links Recovered Using DynWing Compare to that Using PCA?</p><p>When comparing DynWing with a PCA-based weighting technique, Fig. <ref type="figure" target="#fig_5">5</ref> shows that DynWing provides better results than PCA. PCA tends to provide higher precision than recall in some cases, whereas DynWing tends to find a better balance between precision and recall in all cases. We performed a Mann-Whitney test to analyze if DynWing statistically provides better F 1 scores or not. Table <ref type="table">2</ref> shows that p-values are below the standard significant value ¼ 0:05 for T rustrace V SM . Thus, we reject H 05 . In the case of JSM, for SIP, using two experts does not yield any difference between DynWing and PCA-based weighting. Thus, we cannot reject H 06 because in one case DynWing and PCAbased weighting provide the same results.</p><p>Thus, we answer RQ2: How does the accuracy of the traceability links recovered using DynWing compare to that using PCA? as follows: DynWing provides better weights for different experts than a PCA-based weighting technique. However, it is possible that in some cases PCA-based weighting provides the same (but not better) results as DynWing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>We now provide qualitative analyses of our results and discuss observations from our empirical evaluation of Trustrace. We also return to our three conjectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Data Set Quality Analysis</head><p>Fig. <ref type="figure">4</ref> shows that Trustrace has a better accuracy, on average, when compared to JSM and VSM for jEdit and Rhino but less for Pooka and SIP. We explain the differences in improvements by the many other factors that can impact the accuracy of traceability-recovery approaches, as discussed elsewhere <ref type="bibr" target="#b9">[10]</ref>. One of these factors is quality of source code identifiers. If there is a low similarity between the identifiers used by requirements and source code, then no matter how good an IR-based technique is, it would not yield results with high precision and recall values.</p><p>To analyze the quality of the identifiers in our datasets and measure their similarity values, we use our previous approach, Coparvo <ref type="bibr" target="#b21">[22]</ref>, which helps to identify poor semantic areas in source code. We want to compute the similarity value between the set of requirements R, all merged into a single document R all ¼ S j r j , and the set of classes C, all merged into C all ¼ S j c j . We build the normalized term-by-document matrix to avoid any effect from the document lengths. Then, we use JSM and VSM to compute the similarity between S j r j and S j c j . The similarity between these sets shows how close two documents are in terms of semantics.        precision and recall values for the traceability links <ref type="bibr" target="#b9">[10]</ref>. Fig. <ref type="figure" target="#fig_3">6</ref> shows that JSM provides better similarity values between documents than VSM. Fig. <ref type="figure">4</ref> shows that JSM tends to provide better precision and recall values than VSM.</p><formula xml:id="formula_13">• • • • • • • • • • 0 5 10<label>15</label></formula><formula xml:id="formula_14">• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • Pooka MSW SIP MSW</formula><formula xml:id="formula_15">• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • Pooka MSW SIP MSW</formula><p>A second factor from Ali et al. <ref type="bibr" target="#b9">[10]</ref> is the knowledge of the developers who wrote the requirements. In our empirical evaluation, we recovered requirements for Pooka and SIP using Prereqir <ref type="bibr" target="#b6">[7]</ref>. All the requirements were written by subjects who use e-mail clients and instant messengers on a regular basis, not by developers of such systems. Therefore, the subjects used nontechnical terms in their requirements, which have little semantic similarity with the source code.</p><p>jEdit is an open-source Java text editor targeting the Java programming language. Although some jEdit users must be Java developers, we could not find any indication that all new feature requests were written by Java developers. Moreover, it is likely that jEdit users are not all Java developers. Users can ask for new features or report bugs in its online bug-tracking system. If a new requested feature is considered important by the community, then it is included in a following version of jEdit. In this paper, we considered such features requested by users as genuine requirements. Yet, users used technical terms to define requirements which result in higher similarity values with the source code than Pooka and SIP.</p><p>In the case of Rhino, we used the ECMAScript specifications as requirements. ECMAScript specifications are detailed and written by technical writers. Thus, the similarity values between Rhino requirements and source code is higher than those of the other three datasets. We also observe that CVS/SVN commit messages are not always informative. Developers often did not provide relevant messages for the CVS/SVN commits or only some very generic message, e.g., "changed," "updated files," and/or "fixed bug." Yet, the CVS commit messages of Rhino were better than those of the other three datasets.</p><p>Thus, we can say that high semantic similarity between requirements, source code, CVS/SVN commit messages, and bug reports affect the results of any requirements traceability approach. However, Table <ref type="table">1</ref> shows that even with low similarity values between documents, Trustrace improves the precision and recall values of the recovered links.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">DynWing versus MSW versus PCA</head><p>Manually tuning the weights used to combine the opinions of experts allows favoring precision over recall or vice versa. However, this manual tuning requires a labeled corpus, i.e., an oracle, that is almost never available. Consequently, previous approaches <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b7">[8]</ref> used multiple-static weights (MSW) to define a range of weights to tune their approaches. We analyzed the links recovered when using MSW to compare DynWing with carefully manually tuned weights.</p><p>We use MSW in Trumo, then compute the precision and recall of the obtained links in comparison to our four oracles, Oracle jEdit , Oracle Pooka , Oracle Rhino , and Oracle SIP , to find the optimal values for (3) in the Trustrace model in Section 2.3 for jEdit, Pooka, Rhino, and SIP, respectively. We use different values to assess which value provides better results. We use 2 ½0; 1 values with a 0.1 increment.</p><p>We observe in Fig. <ref type="figure" target="#fig_5">5</ref> that DynWing is close to the optimal solution that MSW provides, but still there is room for improvement in terms of precision and recall. For example, in the case of Pooka, with only Histrace commits , DynWing (cross signs) provides on average 52.46 and 12.52 precision and recall values, whereas MSW provides on average 51.31 and 14.63: DynWing increased the recall value by 2.11 at the cost of a decrease in precision by 1.14. In the case of Rhino and SIP, we only show the average precision and recall of two experts in the graph for the clarity of the graph. Fig. <ref type="figure" target="#fig_5">5</ref> and Table <ref type="table">1</ref> show that using more than one expert provides better results than the MSW weighting technique. However, Fig. <ref type="figure" target="#fig_5">5</ref> shows that for each system, the ranges of weights vary. Thus, we cannot identify one range of weights that would yield traceability links with reasonable precision and recall values for all the four systems. As the number of experts increases, it would become more difficult to identify the most appropriate weights or range of weights. Instead, DynWing would relieve project managers from choosing static weights.</p><p>We observe that treating each and every link independently helps to increase precision and recall. Some researchers <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> performed several experiments using various weights to provide a range of weights that work well with their approaches/datasets. However, we cannot generalize such kinds of weights because every dataset is unique <ref type="bibr" target="#b9">[10]</ref>. In addition, a range of weights is only a start to recover traceability links and, without an oracle, it is impossible to identify what weights and/or ranges of weights are suitable. Moreover, Fig. <ref type="figure" target="#fig_5">5</ref> shows that we cannot provide a reasonable range using MSW in the cases of Pooka and SIP: The MSW weight range for JSM is not suitable for VSM. Thus, we cannot impose the same weight range on all the datasets and IR techniques as proposed by other researchers <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>.</p><p>Gethers et al. <ref type="bibr" target="#b8">[9]</ref> proposed a PCA-based weighting technique that does not require an oracle to define weights. Fig. <ref type="figure" target="#fig_5">5</ref> shows that the PCA-based weighting technique favors precision over recall. Sometimes it provides better results than DynWing in term of precision only. DynWing increases both precision and recall.</p><p>This comparison of DynWing with MSW also supports the answer of RQ2 that DynWing tends to provide a better tradeoff between precision and recall. We conclude that DynWing does not require any previous knowledge of an oracle and that treating each link separately and assigning weights on a per-link basis provides better precision and recall values than other weighting techniques. The achieved improvements are statistically significant and, most of the time, with large effect sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Number of Experts</head><p>Fig. <ref type="figure">4</ref> shows the results of two experts only, in the case of Rhino and SIP, for the sake of clarity. All the detailed figures and results are available online. 8 We only include one figure of two experts as an example in this paper to show that adding more experts does impact precision and recall positively. Fig. <ref type="figure" target="#fig_8">7</ref> shows that using one expert provides better results than an IR-based technique alone. As we increase the number of experts, the graph shows a clear improvement in precision and recall. Table <ref type="table">1</ref> reports that, in the case of Rhino and SIP, using two experts increases the precision and recall values more than using a single expert. It supports the idea that increasing the number of experts increases the precision and recall values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Other Observations</head><p>The empirical evaluation supports our claim that Trustrace combined with IR techniques is effective in increasing the precision and recall values of some baseline requirements' traceability links. Our novel approach performs better than JSM and VSM.</p><p>While creating Oracle Pooka and Oracle SIP , we tagged some requirements as unsupported features. While we performed the empirical evaluation, we found that Histrace produced links to some unsupported features. We manually verified these links and found that the source code related to these features indeed existed. We updated our oracles accordingly, which are the ones used in the previous sections.</p><p>For example, in Pooka, we declared the drag-and-drop requirement as an unsupported feature. Yet, Histrace produced some traceability links to this requirement. We manually verified these links and found that developers implemented the drag-and-drop feature partially, but named it "dnd" while commenting "this is drag and drop feature" in some related SVN commit messages. This example shows that Trustrace can indeed help developers in recovering missing links from human mistakes and the limitations of automated approaches. In the cases of jEdit and Rhino, we did not find such missing links.</p><p>This observation shows that Histrace not only helps to recover traceability links but also may help in evolving traceability links: If a developer creates traceability links and, after some years, wants to update the traceability links, then she does not need to create/verify all the links again. She could run Histrace and/or Trustrace to obtain possible missing links that she can verify.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Practical Applicability of Trustrace</head><p>Trustrace enables practitioners to automatically recover traceability links between requirements and source code. The current model of Trustrace is general in the sense that all the conceptual steps of Trustrace, shown in Fig. <ref type="figure" target="#fig_0">1</ref>, can be changed. Indeed, Histrace could be customized to accommodate other software repositories, e.g., mailing lists. Trumo could be applied to other problems, e.g., feature location. For example, we recently customized Trumo to address bug location in combination with binary-class relationships. The most important aspect of Trustrace is that it does not require the tuning of some parameters for every dataset on which it is applied. DynWing is an automatic weighting scheme that assigns weights to the different experts at runtime. In contrast, a project manager would need to guess and assign weights to each expert.</p><p>The Trustrace model could be implemented in any software development environment. It does not require particular inputs or parameter tuning. Trustrace could mine any software repository and use them as experts to recover traceability links. A project manager could also use the output of Trustrace for other purposes than requirement traceability as well. For example, Trustrace could tell a project manager which requirements require more maintenance, in particular which requirements are causing more bugs and CVS/SVN commits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Revisiting the Conjectures</head><p>In the introduction, we stated three conjectures regarding the use of other sources of information, of a trust model, and of a dynamic weighting technique to improve the accuracy of the requirement traceability links recovered using an IR technique.</p><p>Within the limits of the threats to the validity of the results of our empirical study, we conclude that our conjectures are true. Indeed, our empirical study shows that the requirement traceability links recovered through mining software repositories, i.e., CVS/SVN repositories and Bugzilla bug-tracking systems, can be considered as experts whose opinions can be used in a trust model to discard/rerank the links provided by an IR technique. The experts' opinions must be combined dynamically, i.e., on a per-link basis, to reap the full benefits of the trust model.  To the best of our knowledge, this paper is the first stating these conjectures and reporting on the benefits of combining software repositories to improve the accuracy of requirement traceability links. It is also the first use of a dynamic weighting technique in combination with a trust model. We expect that other software repositories could be useful during the traceability recovery process and that other models of trust and weighting techniques could improve the accuracy of the links recovered by an IR technique even further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Threats to Validity</head><p>Several threats potentially impact the validity of our experimental results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.1">Construct Validity</head><p>Construct validity concerns the relation between theory and observations. We quantified the degree of inaccuracy of our automatic requirement traceability approach by means of a validation of the precision and recall values using manually built oracles. First, two authors created manual traceability oracles and then the third author verified their content to avoid inaccuracy in the oracles. We manually verified some of the automatically recovered links by our approach to discover any imperfection in manually built oracles. We improved the oracles after applying Trustrace and discovering missing links.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.2">Internal Validity</head><p>The internal validity of a study is the extent to which a treatment's effects change the dependent variable. The internal validity of our empirical study could be threatened by our choice of the value: Other values could lead to different results. We mitigated this threat by studying the impact of on the precision and recall values of our approach in Section 4 and using MSW-and PCA-generated values. The global trust over an expert could also impact the validity of results. We mitigated this threat by using the same setting for all the experiments and found the same trends of improvements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.3">External Validity</head><p>The external validity of a study relates to the extent to which we can generalize its results. Our empirical study is limited to four systems, i.e., jEdit, Pooka, Rhino, and SIP. Yet, our approach is applicable to any other systems. However, we cannot claim that the same results would be achieved with other systems. Different systems with different SVN commit logs, requirements, bug descriptions, and source code may lead to different results. Yet, the four selected systems have different SVN commit logs, SVN commit messages, requirements, bug reports, and source code quality. Our choice reduces the threat to the external validity of our empirical study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.4">Conclusion Validity</head><p>Conclusion validity threats deal with the relation between the treatment and the outcome. The appropriate nonparametric test, Mann-Whitney, was performed to statistically reject the null hypotheses, which does not make any assumption on the data distribution. We also mitigated this threat by applying the Shapiro-Wilk test to verify the distribution of our data points to select an appropriate statistical test and effect size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK</head><p>Traceability recovery and web trust models are related to our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Traceability Approaches</head><p>Sherba and Anderson <ref type="bibr" target="#b29">[30]</ref> proposed an approach, TraceM, based on techniques from open hypermedia and information integration. TraceM manages traceability links between requirements and architecture. An open hypermedia system enables the creation and viewing of relationships in heterogeneous systems. TraceM allows the creation, maintenance, and viewing of traceability relationships in tools that software professionals use on a daily basis. Maider et al. <ref type="bibr" target="#b30">[31]</ref> proposed an approach to support automated traceability maintenance by recognizing development activities. Development activities are formally specified and changes to certain model elements trigger a LinkUp-dateManager. This manager is responsible for updating traceability links that are related to the changed elements. However, the authors did not mention how traceability links are actually created and updated. Poshyvanyk et al. <ref type="bibr" target="#b7">[8]</ref> combined a scenario-based probabilistic ranking of events and an IR technique that uses latent semantic indexing for feature location. Their empirical study shows that combining different approaches can perform better than a single IR technique.</p><p>Lucia et al. <ref type="bibr" target="#b31">[32]</ref> proposed an approach helping developers to keep source code identifiers and comments consistent with high-level artifacts. The approach computes textual similarity between source code and related high-level artifacts, e.g., requirements. The textual similarity helps developers to improve their source code lexicon. Maletic and Collard <ref type="bibr" target="#b5">[6]</ref> proposed an XML-based traceability query language, TQL. TQL supports queries across multiple artifacts and multiple traceability link types. TQL has primitives to allow complex query construction and execution support. Zou et al. <ref type="bibr" target="#b32">[33]</ref> performed empirical studies to investigate Query Term Coverage, Phrasing, and Project Glossary term-based enhancement methods that are designed to improve the performance of a probabilistic automated tracing tool. The authors proposed a procedure to automatically extract critical keywords and phrases from a set of traceable artifacts to enhance the automated trace retrieval. Gethers et al. <ref type="bibr" target="#b8">[9]</ref> proposed an integrated approach to combine orthogonal IR techniques, which have been statistically shown to produce dissimilar results. Their approach combines VSM, JSM, and relational topic modeling. Their proposed approach uses each IR technique as an expert and uses a PCA-based weighting scheme to combine them.</p><p>The precision and the recall <ref type="bibr" target="#b2">[3]</ref> of the links recovered during traceability analyses are influenced by a variety of factors, including the conceptual distance between highlevel documentation and low-level artifacts, the way in which queries are formulated, and the applied IR technique. Comparisons have been made among different IR techniques, e.g., <ref type="bibr" target="#b28">[29]</ref> and <ref type="bibr" target="#b14">[15]</ref>, with inconclusive results. On several datasets, the vector space model and Jensen-Shannon similarity model perform favorably in comparison to more complex techniques, such as latent semantic analyses <ref type="bibr" target="#b14">[15]</ref> or latent Dirichlet allocation <ref type="bibr" target="#b16">[17]</ref>. Yet, algebraic models, e.g., the vector space model <ref type="bibr" target="#b2">[3]</ref>, and probabilistic models, e.g., the Jensen-Shannon similarity model <ref type="bibr" target="#b14">[15]</ref>, are a reference baseline for both feature location <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b33">[34]</ref> and traceability recovery <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b28">[29]</ref>.</p><p>Kagdi et al. <ref type="bibr" target="#b34">[35]</ref> presented a heuristic-based approach to recover traceability links between software artifacts using the software system's version history. Their approach assumes that, if two or more files cochange <ref type="bibr" target="#b35">[36]</ref> in the system history, then there is a possibility that they have a link between them. However, it is quite possible that two files are cochanging, but that they do not have any semantic relationship. It is also likely that some documents evolve outside the system's version control repository and, in such a case, their approach cannot find a link from/to these documents, e.g., requirement specifications. In addition, their approach does not analyze the contents of the CVS/ SVN commit logs and files that were committed in CVS/ SVN. More importantly, in co-change-based traceability <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b36">[37]</ref>, if two or more files have a link but they were not co-changed, then these approaches fail to find a link. Our proposed novel approach is not dependent on cochanges and overcomes these limitations.</p><p>Table <ref type="table" target="#tab_6">3</ref> summarizes the related works on traceability recovery approaches. The column external information in Table <ref type="table" target="#tab_6">3</ref> shows whether the approach uses any external information, e.g., execution traces, software repositories, human knowledge, or not. The multiple expert column shows if the current approach accommodates more than one expert opinion. The automated weights column shows if the approach is capable of assigning weights to each expert. Only <ref type="bibr" target="#b8">[9]</ref> provides an automated support for assigning weights to multiple experts. In <ref type="bibr" target="#b8">[9]</ref>, the authors proposed a PCA-based weighting scheme for multiple experts. We compared DynWing with this PCA-based weighting scheme. Our results show that DynWing can provide better results than the PCA-based weighting scheme. To the best of our knowledge, all the above-mentioned approaches use textual similarity among various software artifacts to recover traceability links. The work presented in this paper is complementary to existing IR-based techniques because it uses current state-of-the-art techniques to create links and uses a trust model to filter out false-positive links and increase the trust over remaining links.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Web Trust Model</head><p>Our proposed novel approach is influenced by the web trust model <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>. There are two types of trust in e-commerce: first, a customer's initial trust <ref type="bibr" target="#b13">[14]</ref> when she interacts with a website for the first time and, second, the website's reputation trust <ref type="bibr" target="#b37">[38]</ref> that develops over time and after repeated experiences. When customers hesitate to buy things online, they may ask their friends, family, and other buyers to make sure that they can trust a website. Many researchers investigated <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b38">[39]</ref> the problem of increasing customers' trust in a website. Some researchers <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b12">[13]</ref> suggested that using other sources of information can increase the trust in a website.</p><p>Berg and Van <ref type="bibr" target="#b10">[11]</ref> attempted to develop the equivalent of symbolons, for e-commerce. Their study deals with a specific type of electronic medium, the World Wide Web. In particular, it focuses on the so-called web assurance services, which provide certification of the legitimacy of websites. The authors highlight business-to-consumer commerce, but also pay attention to the challenges regarding web assurance services in the business-tobusiness environment.</p><p>Palmer et al. <ref type="bibr" target="#b12">[13]</ref> presented an empirical investigation of how firms can improve customers' trust by exploring and using Trusted Third Parties (TTPs) and privacy statements. Their exploratory data show that the use of TTPs and privacy statements increase a customer's trust in a website. Wang et al. <ref type="bibr" target="#b39">[40]</ref> presented a novel content trust learning algorithm that uses the content of a website as a trust point to distinguish trustable web contents and spam contents.</p><p>McKnight et al. <ref type="bibr" target="#b11">[12]</ref> empirically tested the factors that may influence initial trust in a web-based company. The authors tested a trust building model for new customers of a fictitious legal advice website and found that perceived company reputation and perceived site quality both had a significant positive relationship with initial trust with the company.</p><p>Koufaris and Hampton-Sosa <ref type="bibr" target="#b13">[14]</ref> propose a model to explain how new customers of a web-based company develop initial trust in the company after their first visit. The authors empirically tested their hypothesis using a questionnaire-based field study. The results indicate that perceived company reputation and willingness to customize products and services can significantly affect initial trust.</p><p>Our proposed approach uses traceability from requirements to source code as initial trust and then uses CVS/ SVN commit logs and also uses bug reports, mailing lists, temporal information and so on, as reputation trust for a traceability link. As the reputation of a link increases, the trust in this link also increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>The literature <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b40">[41]</ref> showed that IR techniques are useful to recover traceability links between requirements and source code. However, IR techniques lack accuracy (precision and recall). In this paper, we conjectured that: 1) We could mine software repositories to support the traceability recovery process; 2) we could consider heterogeneous sources of information to discard/rerank the traceability links provided by an IR technique to improve its accuracy; and 3) we could use an automatic, per-link experts' weighting technique to avoid the need of manually built oracles to tune weights.</p><p>To support our conjectures, we proposed a new approach, Trustrace, to improve the precision and recall values of some baseline traceability links. Trustrace is based on mining techniques, on a trust model, and a dynamic weighting technique. Trustrace consists of three parts:</p><p>1. Histrace is a technique to create experts supporting the identification of traceability links between requirements and source code. We implemented two instances of Histrace: Histrace commits uses CVS/SVN commit messages and Histrace bugs uses bug reports to build traceability links between requirements and source code. The rationale of Histrace is that commits and bugs are tied to changed source-code entities and thus can be used to infer traceability links between requirements and source code. 2. Trumo, inspired by web-trust models <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, improves the precision and recall values of some baseline traceability links. It uses any traceability-link recovery approach and various experts' opinions, i.e., Histrace commits and Histrace bugs , to discard and/or rerank the traceability links provided by the recovery approach, thus improving their accuracy. Fig. <ref type="figure" target="#fig_0">1</ref> shows that Trumo indeed improves the accuracy of traceability links recovered by either JSM or VSM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DynWing combines and assigns weights to the</head><p>Histrace experts' opinions using a dynamic weighting technique that considers each link separately. Experts' opinions are then used by Trumo to rerank the traceability links. We compared the DynWing weighting technique with a PCA weighting technique and a multiple-static weighting technique and reported that DynWing provides better results in terms of precision and recall. Trustrace is the first approach to integrate time information (from CVS/SVN commit logs) and bug information (from Bugzilla reports) to recover requirement traceability links. We applied Trustrace on jEdit, Pooka, Rhino, and SIP to compare its requirement-traceability links with those recovered using only the JSM or VSM techniques, in terms of precision and recall. We showed that Trustrace improves, with statistical significance, the precision and recall values of the traceability links. We also compared DynWing with a PCA-based weighting technique in terms of F 1 score. We thus showed that our trust-based approach indeed improves precision and recall and also that CVS/SVN commit messages and bug reports are useful in the traceability recovery process.</p><p>We thus conclude that our conjectures are supported: The accuracy of the traceability links between requirements and source code recovered by an IR technique are improved by 1) mining software repositories and considering the links recovered through these repositories as experts, 2) using a trust model inspired by web-trust models to combine these experts' opinions, and 3) weighting the experts' opinions on a per-link basis for each link recovered by the IR technique.</p><p>In future work, we plan to implement more instances of Histrace, in particular using e-mails and threads of discussions in forums. We will use our Trumo model in other software engineering fields, in particular, test-case prioritization using various prioritisation approaches, antipattern detection using users' feedback, and concept location using execution traces. We will deploy Trustrace in a development environment and perform experiments with real developers to analyze how effectively Trustrace can help developers in recovering traceability links. We also plan to use advanced matching techniques between bug reports and CVS/SVN commit messages, such as those in <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Trust-based requirement traceability process.</figDesc><graphic coords="3,38.95,51.17,488.58,175.47" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Overlapping of R2C, R2CT i;rj;tk , and T r.</figDesc><graphic coords="5,70.58,51.17,162.26,118.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Excerpt of Pooka SVN Log.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6</head><label>6</label><figDesc>indeed shows that in the case of Pooka and SIP both JSM and VSM return low similarity values. Low similarity values among different documents would result in low</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Precision and recall values, with the threshold t varying from 0.01 to 1 by steps of 0.01. The X-axis shows precision values and Y -axis recall values. DW represents the DynWing results.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Similarity between merged requirements and source code documents.</figDesc><graphic coords="12,30.39,51.17,242.70,142.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>8 .</head><label>8</label><figDesc>http://www.ptidej.net/download/experiments/tse12/.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Rhino precision and recall graph for T rustrace using one and two experts. The X-axis shows precision values and the Y -axis recall values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>It supports UTF-8 and many other encoding techniques. It has extensive code folding and text folding capabilities, as well as text wrapping that takes indentation into account. It is highly customizable and can be extended with macros written in BeanShell, Jython, JavaScript, and some other scripting languages. jEdit version 4.3 has 483 classes, measures 109 KLOC, and implements 34 requirements. Pooka 5 is an e-mail client written in Java using the JavaMail API. It supports reading e-mails through the IMAP and POP3 protocols. Outgoing emails are sent using SMTP. It supports folder search, filters, and context-sensitive colors. Pooka version 2.0 has 298 classes, weighs 244 KLOC, and implements 90 requirements. Rhino 6 is an open-source JavaScript engine entirely developed in Java. Rhino converts JavaScript scripts into objects before interpreting them and can also compile them. It is intended to be used in server-side systems but can also be used as a debugger by making use of the Rhino shell. Rhino version 1.6 has 138 classes, measures 32 KLOC, and implements 268 requirements. SIP Communicator 7 is an audio/video Internet phone and instant messenger that supports some of the most popular instant messaging and telephony protocols, such as AIM/ ICQ, Bonjour, IRC, Jabber, MSN, RSS, SIP, Yahoo! Messenger. SIP Communicator version 1.0-draft has 1,771 classes, measures 486 KLOC, and implements 82 requirements.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 2 F 1</head><label>21</label><figDesc>Values for jEdit, Pooka, Rhino, and SIP, and Mann-Whitney Test Results</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE 3</head><label>3</label><figDesc></figDesc><table><row><cell>Related Work Summary</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>http://www.ptidej.net/download/ibdoos/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>ðr j ; c s Þ þ</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>ðr j ; c s Þ þ Á Á Á þ P þ1 ðr j ; c s Þ ¼ 1 k 1 ðr j ; c s Þ ! k 2 ðr j ; c s Þ ! Á Á Á ! k P þ1 ðr j ; c s Þ:Given the three previous constraints, it is possible that DynWing assigns i ðr j ; c s Þ ¼ 1 to a single expert i. To avoid such an assignment, a developer can define her global trust into the experts. For example, CVS/SVN commit messages may be considered by the developer more trustworthy than bug reports. Therefore, the developer may further constrain (4) by imposing commits ðr j ; c s Þ ! bugs ðr j ; c s Þ &gt; 0:</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors thank Dr. Bram Adams, assistant professor at the Ecole Polytechnique de Montre ´al, for his invaluable feedback. This work is partly supported by the NSERC Research Chairs on Software Cost-effective Change and Evolution and on Software Patterns and Patterns of Software.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An Analysis of the Requirements Traceability Problem</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">C Z</forename><surname>Gotel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Finkelstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First Int&apos;l Conf. Requirements Eng</title>
		<meeting>First Int&apos;l Conf. Requirements Eng</meeting>
		<imprint>
			<date type="published" when="1994-04">Apr. 1994</date>
			<biblScope unit="page" from="94" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Trust-Based Requirements Traceability</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-G</forename><surname>Gue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th IEEE Int&apos;l Conf. Program Comprehension</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Sim</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Ricca</surname></persName>
		</editor>
		<meeting>19th IEEE Int&apos;l Conf. Program Comprehension</meeting>
		<imprint>
			<date type="published" when="2011-06">June 2011</date>
			<biblScope unit="page" from="111" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Recovering Traceability Links between Code and Documentation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Canfora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Casazza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Merlo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="970" to="983" />
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Recovering Documentation-to-Source-Code Traceability Links Using Latent Semantic Indexing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">I</forename><surname>Maletic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th Int&apos;l Conf. Software Eng</title>
		<meeting>25th Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="125" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Helping Analysts Trace Requirements: An Objective Look</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dekhtyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Howard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th IEEE Int&apos;l Requirements Eng</title>
		<meeting>12th IEEE Int&apos;l Requirements Eng</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="249" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">TQL: A Query Language to Support Traceability</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">I</forename><surname>Maletic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Collard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICSE Workshop Traceability in Emerging Forms of Software Eng</title>
		<meeting>ICSE Workshop Traceability in Emerging Forms of Software Eng</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="16" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">PREREQIR: Recovering Pre-Requirements via Cluster Analysis</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Working Conf. Reverse Eng</title>
		<meeting>15th Working Conf. Reverse Eng</meeting>
		<imprint>
			<date type="published" when="2008-10">Oct. 2008</date>
			<biblScope unit="page" from="165" to="174" />
		</imprint>
	</monogr>
	<note>Gue ´he ´neuc</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Feature Location Using Probabilistic Ranking of Methods Based on Execution Scenarios and Information Retrieval</title>
		<author>
			<persName><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-G</forename><surname>Gue ´he ´neuc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rajlich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="420" to="432" />
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On Integrating Orthogonal Information Retrieval Methods to Improve Traceability Recovery</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gethers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oliveto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Lucia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th IEEE Int&apos;l Conf. Software Maintenance</title>
		<meeting>27th IEEE Int&apos;l Conf. Software Maintenance</meeting>
		<imprint>
			<date type="published" when="2011-09">Sept. 2011</date>
			<biblScope unit="page" from="133" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Gue ´he ´neuc, and G. Antoniol, Factors Impacting the Inputs of Traceability Recovery Approaches</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-G</forename></persName>
		</author>
		<editor>A. Zisman, J. Cleland-Huang, and O. Gotel</editor>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Finding Symbolons for Cyberspace: Addressing the Issues of Trust in Electronic Commerce</title>
		<author>
			<persName><forename type="first">R</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M L</forename><surname>Van</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Production Planning and Control</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="514" to="524" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Mcknight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Kacmar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Impact of Initial Consumer Trust on Intentions to Transact with a Web Site: A Trust Building Model</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="297" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The Role of Intermediaries in the Development of Trust on the WWW: The Use and Prominence of Trusted Third Parties and Privacy Statements</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Faraj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computer-Mediated Comm</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Development of Initial Trust in an Online Company by New Customers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Koufaris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hampton-Sosa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information &amp; Management</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="377" to="397" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Traceability Technique for Specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nisenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Simionovici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th IEEE Int&apos;l Conf. Program Comprehension</title>
		<meeting>16th IEEE Int&apos;l Conf. Program Comprehension</meeting>
		<imprint>
			<date type="published" when="2008-06">June 2008</date>
			<biblScope unit="page" from="103" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Recovering Documentation-to-Source-Code Traceability Links Using Latent Semantic Indexing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">I</forename><surname>Maletic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Eng</title>
		<meeting>Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
			<biblScope unit="page" from="125" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Software Traceability with Topic Modeling</title>
		<author>
			<persName><forename type="first">H</forename><surname>Asuncion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Asuncion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 32nd ACM/IEEE Int&apos;l Conf. Software Eng</title>
		<meeting>32nd ACM/IEEE Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="95" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An Algorithm for Suffix Stripping</title>
		<author>
			<persName><forename type="first">M</forename><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Program: Electronic Library and Information Systems</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="130" to="137" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Missing Links: Bugs and Bug-Fix Commits</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bachmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rahman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th ACM SIGSOFT Int&apos;l Symp. Foundations of Software Eng</title>
		<meeting>18th ACM SIGSOFT Int&apos;l Symp. Foundations of Software Eng</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="97" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Relink: Recovering Links between Bugs and Changes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cheung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th ACM SIGSOFT Symp. and 13th European Conf. Foundations of Software Eng</title>
		<meeting>19th ACM SIGSOFT Symp. and 13th European Conf. Foundations of Software Eng</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="15" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Frakes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baeza-Yates</surname></persName>
		</author>
		<title level="m">Information Retrieval: Data Structures and Algorithms</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Requirements Traceability for Object Oriented Systems by Partitioning Source Code</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-G</forename><surname>Gue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th Working Conf. Reverse Eng</title>
		<meeting>18th Working Conf. Reverse Eng</meeting>
		<imprint>
			<date type="published" when="2011-10">Oct. 2011</date>
			<biblScope unit="page" from="45" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Do Crosscutting Concerns Cause Defects?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Eaddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nagappan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="497" to="515" />
			<date type="published" when="2008-08">July/Aug. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Feature Location in Source Code: A Taxonomy and Survey</title>
		<author>
			<persName><forename type="first">B</forename><surname>Dit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Revelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gethers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Software Maintenance and Evolution: Research and Practice</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A Framework for Comparing Requirements Tracing Experiments</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dekhtyar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l J. Software Eng. and Knowledge Eng</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="751" to="782" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Improving Software Maintenance through Traceability Recovery</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dekhtyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Holbrook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadlamudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>April</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Innovations in Systems and Software Eng</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="193" to="202" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>Requirements Tracing on Target</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Improving IR-Based Traceability Recovery Using Smoothing Filters</title>
		<author>
			<persName><forename type="first">A</forename><surname>De Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oliveto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Panichella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Panichella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th IEEE Int&apos;l Conf. Program Comprehension</title>
		<meeting>19th IEEE Int&apos;l Conf. Program Comprehension</meeting>
		<imprint>
			<date type="published" when="2011-06">June 2011</date>
			<biblScope unit="page" from="21" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Baeza-Yates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ribeiro-Neto</surname></persName>
		</author>
		<title level="m">Modern Information Retrieval</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Recovering Traceability Links in Software Artifact Management Systems Using Information Retrieval Methods</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fasano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oliveto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tortora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Software Eng. Methodology</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A Framework for Managing Traceability Relationships between Requirements and Architectures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Sherba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Second Int&apos;l Software Requirements to Architectures Workshop, part of Int&apos;l Conf. Software Eng</title>
		<imprint>
			<biblScope unit="page" from="150" to="156" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Enabling Automated Traceability Maintenance by Recognizing Development Activities Applied to Models</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gotel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Philippow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd IEEE/ACM Int&apos;l Conf. Automated Software Eng</title>
		<meeting>23rd IEEE/ACM Int&apos;l Conf. Automated Software Eng</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="49" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Improving Source Code Lexicon via Traceability and Information Retrieval</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oliveto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="205" to="227" />
			<date type="published" when="2011-03">Mar. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Improving Automated Requirements Trace Retrieval: A Study of Term-Based Enhancement Methods</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Settimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cleland-Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Empirical Software Eng</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="119" to="146" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">SNIAFL: Towards a Static Noninteractive Approach to Feature Location</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Software Eng. Methodology</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="195" to="226" />
			<date type="published" when="2006-04">Apr. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Mining Software Repositories for Traceability Links</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kagdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maletic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sharif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th IEEE Int&apos;l Conf. Program Comprehension</title>
		<meeting>15th IEEE Int&apos;l Conf. Program Comprehension</meeting>
		<imprint>
			<date type="published" when="2007-06">June 2007</date>
			<biblScope unit="page" from="145" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Software Repositories: A Source for Traceability Links</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kagdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maletic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Workshop Traceability in Emerging Forms of Software Eng</title>
		<meeting>Int&apos;l Workshop Traceability in Emerging Forms of Software Eng</meeting>
		<imprint>
			<date type="published" when="2007-03">Mar. 2007</date>
			<biblScope unit="page" from="32" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Mining Sequences of Changed-Files from Version Histories</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kagdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yusuf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">I</forename><surname>Maletic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Workshop Mining Software Repositories</title>
		<meeting>Int&apos;l Workshop Mining Software Repositories</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="47" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A Survey of Trust in Computer Science and the Semantic Web</title>
		<author>
			<persName><forename type="first">D</forename><surname>Artza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Web Semantics: Science, Services and Agents on the World Wide Web</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="58" to="71" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A Survey of Trust in Internet Applications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Grandison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sloman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Surveys Tutorials</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="2" to="16" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>Fourth Quarter</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Using Evidence Based Content Trust Model for Spam Detection</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wanga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zenga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Systems with Applications</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="5599" to="5606" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Feature Location via Information Retrieval Based Filtering of a Single Scenario Execution Trace</title>
		<author>
			<persName><forename type="first">L</forename><surname>Dapeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Andrian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Denys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Vaclav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd IEEE/ACM Int&apos;l Conf. Automated Software Eng</title>
		<meeting>22nd IEEE/ACM Int&apos;l Conf. Automated Software Eng</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="234" to="243" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
