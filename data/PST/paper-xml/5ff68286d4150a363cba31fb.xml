<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Leibo</forename><surname>Liu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">;</forename><surname>Jie</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Honglan</forename><surname>Jiang</surname></persName>
							<email>jianghonglan@mails.tsinghua.edu.cn</email>
						</author>
						<author>
							<persName><forename type="first">Hai</forename><surname>Mo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Francisco</forename><surname>Javier</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Hernandez</forename><surname>Santiago</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institute of Microelectronics</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of Alberta</orgName>
								<address>
									<postCode>T6G 1H9</postCode>
									<settlement>Edmonton</settlement>
									<region>AB</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Institute of Microelectronics</orgName>
								<orgName type="department" key="dep2">Beijing National Research Center for Information Science and Technology</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Alberta</orgName>
								<address>
									<postCode>T6G 1H9</postCode>
									<settlement>Edmonton</settlement>
									<region>AB</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Cornell University Library</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Cornell University Library</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="department">Institute of Microelectronics</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country>China, in</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution" key="instit1">the Institute of Microelectronics</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">929860626A2AB014BCAAD4CA78F57A95</idno>
					<idno type="DOI">10.1109/JPROC.2020.3006451</idno>
					<note type="submission">received January 30, 2020; revised May 18, 2020; accepted June 17, 2020.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Adders</term>
					<term>approximate computing (AC)</term>
					<term>arithmetic circuits</term>
					<term>deep neural networks (DNNs)</term>
					<term>dividers</term>
					<term>image processing</term>
					<term>multipliers Jiang et al.: Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications Jiang et al.: Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications Jiang et al.: Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications Jiang et al.: Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Approximate computing has emerged as a new paradigm for high-performance and energy-efficient design of circuits and systems. For the many approximate arithmetic circuits proposed, it has become critical to understand a design or approximation technique for a specific application to improve performance and energy efficiency with a minimal loss in accuracy. This article aims to provide a comprehensive survey and a comparative evaluation of recently developed approximate arithmetic circuits under different design constraints. Specifically, approximate adders, multipliers, and dividers are synthesized and characterized under optimizations for performance and area. The error and circuit characteristics are then generalized for different classes of designs.</p><p>The applications of these circuits in image processing and Manuscript</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. I N T R O D U C T I O N</head><p>With increasing importance of big data processing and artificial intelligence, an unprecedented challenge has arisen due to the massive amounts of data and complex computations required in these applications. Energyefficient and high-performance general-purpose compute engines, as well as application-specific integrated circuits, are highly demanded to facilitate the development of these new technologies. Meanwhile, exact or high-precision computation is not always necessary. Instead, some small errors can compensate each other or will not have a significant effect in the computed results. Hence, approximate computing (AC) has emerged as a new approach to energyefficient design, as well as to increasing the performance of a computing system, at a limited loss in accuracy <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Motivation</head><p>In the past few decades, the feature size of transistors has decreased exponentially, as governed by Moore's law <ref type="bibr" target="#b1">[2]</ref>, which has resulted in a continuous improvement in the performance and power efficiency of integrated circuits. However, at the nanometer scale, the supply voltage cannot be further reduced, which has led to a significant increase in power density. Thus, a percentage of transistors in an integrated circuit must be powered off to alleviate the thermal issues; the powered-off transistors are called "dark silicon" <ref type="bibr" target="#b2">[3]</ref>. A study has shown that the area of "dark silicon" may reach up to more than 50% for an 8-nm technology <ref type="bibr" target="#b3">[4]</ref>. This indicates an increasing challenge to improve circuit performance and power efficiency by using conventional technologies. New design methodologies have been investigated to address this issue, including multicore architectures, heterogeneous integration, and AC <ref type="bibr" target="#b4">[5]</ref>.</p><p>AC is driven by the observation that many applications, such as multimedia, recognition, classification, and machine learning, can tolerate the occurrence of some errors. Due to the perceptual limitations of humans, some errors do not impose noticeable degradation in the output quality of image, audio, and video processing. Moreover, the external input data to a digital system are usually noisy and quantized, so there is already a limit in the precision or accuracy in representing useful information. Probability-based computing, such as stochastic computing, performs arithmetic functions on random binary bit streams using simple logic gates <ref type="bibr" target="#b5">[6]</ref>, where trivial errors do not result in a significantly different result. Lastly, many applications including machine learning are based on iterative refinement. This process can attenuate or compensate the effects of insignificant errors <ref type="bibr" target="#b6">[7]</ref>. AC has thus become a potentially promising technique to benefit a variety of error-tolerant applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Development History of Approximate Arithmetic Circuits</head><p>Since the 1960s, the Newton-Raphson algorithm has been utilized for computing an approximate quotient to speed up division <ref type="bibr" target="#b7">[8]</ref>, followed by many other functional iteration-based algorithms such as Goldschmidt <ref type="bibr" target="#b8">[9]</ref>. Multiple precision dividers can, therefore, be obtained by terminating the computing process at different stages <ref type="bibr" target="#b9">[10]</ref>.</p><p>Also in the early 1960s, Mitchell <ref type="bibr" target="#b10">[11]</ref> proposed a logarithm-based algorithm for multiplication and division. Although specific approximation techniques aimed at arithmetic circuits were not significantly developed in the following few decades, some straightforward approximation (or rounding) techniques have gradually been considered, for example, in truncation-based multipliers to obtain an output with the same bit width as the inputs. This type of multipliers is referred to as a fixed-width multiplier. The approximation is obtained by accumulating some most significant partial products (PPs), along with a correction constant obtained by a statistical analysis as an approximation for the sum of the least significant PPs <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>.</p><p>In 2004, the concept of approximation was applied to adders and Booth multipliers in a superscalar processor to increase the clock frequency of a microprocessor <ref type="bibr" target="#b13">[14]</ref>. The approximate adder is designed by observing that the effective carry chain of an adder is much shorter than the full carry chain for most inputs. On average, the longest carry chain in an n-bit addition is not longer than the binary logarithm of n, or log (n), as discussed by Burks et al. <ref type="bibr" target="#b14">[15]</ref>. Thus, a carry in an n-bit adder is obtained from its previous k input bits rather than from all of the previous bits (so, k &lt; n). Compared to an accurate adder (AccuA), the critical path of this approximate adder is significantly shorter. The approximate adder was suggested for use in the generation of the 3× multiplicand required in the radix-8 encoding algorithm for a Booth multiplier.</p><p>Since around 2008, approximate adders and multipliers have received significant attention, resulting in various designs; the early ones include the almost correct adder (ACA) <ref type="bibr" target="#b15">[16]</ref>, the error-tolerant adder <ref type="bibr" target="#b16">[17]</ref>, the lower-part-OR adder (LOA) <ref type="bibr" target="#b17">[18]</ref>, the equal segmentation adder (ESA) <ref type="bibr" target="#b18">[19]</ref>, the approximate mirror adder <ref type="bibr" target="#b19">[20]</ref>, the broken-array multiplier (BAM) <ref type="bibr" target="#b17">[18]</ref>, the error-tolerant multiplier (ETM) <ref type="bibr" target="#b20">[21]</ref>, and the underdesigned multiplier (UDM) <ref type="bibr" target="#b21">[22]</ref>. In addition, logic synthesis methods have been developed to reduce the circuit area and power dissipation for a given error constraint <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>. Automated processes have also been considered to generate approximate adders and multipliers <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>. Moreover, various computing and memory architectures have been proposed to support AC applications <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>. In particular, a programming language can support approximate data types for low-power computing <ref type="bibr" target="#b28">[29]</ref>. Recently, approximate designs include those for dividers <ref type="bibr" target="#b29">[30]</ref>- <ref type="bibr" target="#b32">[33]</ref>, multiply-and-accumulate (MAC) units <ref type="bibr" target="#b33">[34]</ref>, squaring circuits <ref type="bibr" target="#b34">[35]</ref>- <ref type="bibr" target="#b37">[38]</ref>, square root circuits <ref type="bibr" target="#b38">[39]</ref>, and a coordinate rotation digital computer (CORDIC) <ref type="bibr" target="#b39">[40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Applications of AC</head><p>AC has been considered for many applications with error resilience, such as image processing and machine learning, for a higher performance and energy efficiency <ref type="bibr" target="#b40">[41]</ref>- <ref type="bibr" target="#b47">[48]</ref>.</p><p>The approximation techniques at algorithm, architecture, and circuit levels have been synergistically applied in the design of an energy-efficient programmable vector processor for recognition and data mining <ref type="bibr" target="#b40">[41]</ref>. This design achieves an energy reduction of 16.7%-56.5% compared to a conventional one without any quality loss, and 50.0%-95.0% when the output quality is insignificantly reduced.</p><p>As basic image processing applications, sharpening, smoothing, and multiplication have been used to assess the quality of approximate adders and unsigned multipliers <ref type="bibr" target="#b48">[49]</ref>- <ref type="bibr" target="#b50">[51]</ref>. Image compression algorithms have been considered for evaluating approximate signed multipliers <ref type="bibr" target="#b42">[43]</ref>, <ref type="bibr" target="#b43">[44]</ref>.</p><p>Approximate adders and multipliers have been integrated in deep learning accelerators for reducing delay and saving energy <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b44">[45]</ref>- <ref type="bibr" target="#b46">[47]</ref>, <ref type="bibr" target="#b51">[52]</ref>. In <ref type="bibr" target="#b41">[42]</ref>, truncated 16bit multipliers with constant error compensation are used in lieu of 32-bit floating-point multipliers in an accelerator for large-scale convolutional neural networks (CNNs) and deep neural networks (DNNs). Up to 83.6% and 86.4% reductions in area and power consumption have, respectively, been achieved. Designs with various error and circuit characteristics have also been exploited in reconfigurable systems to enhance the reconfiguration flexibility. In <ref type="bibr" target="#b44">[45]</ref> and <ref type="bibr" target="#b45">[46]</ref>, approximate adders and multipliers with various levels of accuracy are integrated in a coarsegrained reconfigurable array for different configurations determined on-the-fly by the application requirements. In this way, different performance and energy improvements can be obtained by trading off various levels of processing quality.</p><p>In the implementation of a state-of-the-art wireline transceiver, an approximate multiplier is used for lowpower digital signal processing <ref type="bibr" target="#b47">[48]</ref>. Compared to the accurate design, power is reduced by 40% and the maximum performance is improved by 25%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Scope of This Article</head><p>Recent research on AC has spanned from algorithms to circuits and programming languages <ref type="bibr" target="#b50">[51]</ref>, <ref type="bibr" target="#b52">[53]</ref>- <ref type="bibr" target="#b55">[56]</ref>. This article aims to provide an overview of approximate arithmetic circuits, various design methodologies, an evaluation and characterization of approximate adders, multipliers, and dividers with respect to accuracy and circuit measurements. Three image processing applications and a CNN are implemented to show the capability and performance advantage of approximate arithmetic circuits. Some preliminary results have been presented in <ref type="bibr" target="#b50">[51]</ref> and <ref type="bibr" target="#b56">[57]</ref>; however, this article presents the following new, distinctive contributions. Instead of undergoing a generic synthesis process, approximate circuits are synthesized and optimized for delay and area, respectively. The results can be used to guide the selection of appropriate designs for an application-specific requirement (e.g., high performance or low power). In addition, hardware efficiency and accuracy are jointly considered to show the hardware improvements at the cost of a certain loss of accuracy. Furthermore, a larger class of approximate adders, multipliers, and dividers including many recent designs are evaluated; in particular, approximate dividers are extensively analyzed and characterized in detail. Finally, image compression and a DNN are implemented for assessing the quality of approximate adders and signed multipliers to obtain insights into the application of approximate arithmetic circuits in image processing and artificial intelligence systems.</p><p>This article is organized as follows. Section II briefly reviews the design methodologies and evaluation metrics. The approximate adders, multipliers, and dividers are then presented, synthesized, and comparatively evaluated in Sections III-V, respectively. Section VI presents the applications. Finally, Section VII concludes this article and discusses current challenges and future prospects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. B A C K G R O U N D A. Design Methodologies</head><p>An approximate arithmetic circuit can be obtained by using the voltage overscaling (VOS) technique <ref type="bibr" target="#b57">[58]</ref>- <ref type="bibr" target="#b59">[60]</ref>, redesigning a logic circuit into an approximate one <ref type="bibr" target="#b50">[51]</ref>, and using a simplification algorithm <ref type="bibr" target="#b10">[11]</ref>.</p><p>Using VOS, a lower supply voltage is provided to efficiently reduce the power consumption of a circuit, without having to change the circuit structure. However, a reduced voltage increases the critical path delay, possibly resulting in timing errors <ref type="bibr" target="#b57">[58]</ref>. Thus, the output can be erroneous due to the violated timing constraint. Moreover, the error characteristics of such an approximate operation are nondeterministic, as affected by parametric variations <ref type="bibr" target="#b60">[61]</ref>. When the most significant bits (MSBs) are affected, the output error can be large <ref type="bibr" target="#b61">[62]</ref>.</p><p>More commonly, an approximate design is derived from an accurate circuit by modifying, removing, or adding some elements. For instance, some transistors in a mirror adder are removed to implement a low-power and high-speed full adder (FA) <ref type="bibr" target="#b19">[20]</ref>. In addition, an approximate circuit can be obtained by simplifying the truth table or Karnaugh map (K-map) <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b62">[63]</ref>. This method results in circuits with deterministic error characteristics. Due to the same structure and design principles, however, the hardware improvements are hardly significant especially when a high accuracy is required.</p><p>Compared to addition and subtraction, multiplication, division, and square root computation are more complex. Therefore, their functions can be converted into some simpler operations. Mitchell's binary logarithm-based algorithm enables the utilization of adders and subtractors to implement multipliers and dividers, respectively <ref type="bibr" target="#b10">[11]</ref>. It is the origin of most current simplification algorithms for approximate multiplier and divider designs <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b63">[64]</ref>, in parallel with the functional iteration-based algorithms for divider designs <ref type="bibr" target="#b9">[10]</ref>. By using algorithmic simplification, the performance and energy efficiency of an arithmetic circuit can be significantly improved because of the simplification in the basic circuit structure. Nevertheless, the accuracy of such a design is relatively low, and many peripheral circuits are required to achieve a high accuracy, which may limit the hardware efficiency.</p><p>Practically, several approximation techniques are often simultaneously utilized in a hybrid approximate circuit <ref type="bibr" target="#b64">[65]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Evaluation Metrics</head><p>Both error characteristics and circuit measurements need to be considered for approximate circuits. approximate arithmetic circuits <ref type="bibr" target="#b48">[49]</ref>, <ref type="bibr" target="#b65">[66]</ref>- <ref type="bibr" target="#b72">[73]</ref>. Monte Carlo simulation is widely employed to acquire data for analysis. The following metrics have been used to assess the error characteristics.</p><p>Two basic error metrics are the error rate (ER) and error distance (ED). The ER indicates the probability that an erroneous result is produced. The ED shows the arithmetic difference between the approximate and accurate results. Given the approximate and accurate results M and M, respectively, the ED is calculated by ED = |M -M|. Additionally, the relative ED (RED) shows the relative difference with respect to the accurate result, given by RED = |ED/M|. ED and RED reveal two important features of an approximate design. For two input combinations leading to the same ED, the one that produces a smaller accurate result, M, would result in a larger RED. As the average values of all obtained EDs and REDs, the mean ED (MED) and mean relative ED (MRED) are often used to assess the accuracy of an approximate design. They are given by</p><formula xml:id="formula_0">MED = N i=1 ED i • P(ED i ) (1)</formula><p>and</p><formula xml:id="formula_1">MRED = N i=1 RED i • P(RED i ) (<label>2</label></formula><formula xml:id="formula_2">)</formula><p>where N is the total number of considered input combinations for a circuit, and ED i and RED i are the ED and RED for the i th input combination, respectively. P(ED i ) and P(RED i ) are the probabilities that ED i and RED i occur, which are also the probability of the i th input combination. The NMED is defined as the normalization of MED by the maximum output of the accurate design, useful in comparing the error magnitudes of approximate designs of different sizes.</p><p>The mean squared error (MSE) and root-mean-square error (RMSE) are also widely used to measure the arithmetic error magnitude. They are computed by</p><formula xml:id="formula_3">MSE = N i=1 ED 2 i • P(ED i ) (3) and RMSE = √ MSE.<label>(4)</label></formula><p>In addition, the error bias is given by the average error that is the mean value of all possible errors (M -M). The normalized average error is commonly considered as the average error divided by the maximum output of the accurate design.</p><p>Last but not least, the worst case error of an approximate circuit reflects the largest ED possible. Generally, it is normalized by the maximum accurate result.</p><p>2) Circuit Measurements: The basic circuit metrics include the critical path delay, power dissipation, and area. Some compound metrics include the power-delay product (PDP), area-delay product (ADP), and energy-delay product (EDP).</p><p>Electronic design automation (EDA) tools are indispensable for circuit implementation and measurement. In general, the circuit is measured based on different process technologies and component libraries, for example, the 45-nm open source NanGate <ref type="bibr" target="#b73">[74]</ref>, the 45-nm predictive technology model (PTM) <ref type="bibr" target="#b74">[75]</ref>, 28-nm CMOS, and 15-nm FinFET models. The configurations for the supply voltage, temperature, and optimization options also affect the simulation results. For a fair comparison, the same configuration should be used for different designs.</p><p>Conventionally, high performance and power efficiency are, respectively, pursued as independent design considerations. For instance, to cope with aging-induced timing errors, approximate adders and multipliers are developed for a high speed <ref type="bibr" target="#b75">[76]</ref>. High-performance arithmetic circuits are also preferred in real-time machine learning systems <ref type="bibr" target="#b76">[77]</ref>. For mobile and embedded devices, however, power efficiency is key to the extended use of a limited battery life.</p><p>In this article, approximate circuits are evaluated for maximizing performance (through delay) or minimizing power (through area). Specifically, approximate designs are implemented in hardware description languages (HDLs) and synthesized using the Synopsys Design Compiler (DC, 2011.09 release) in ST's 28-nm CMOS technology, with a supply voltage of 1.0 V at a temperature of 25 • C. To compare speed and power, the approximate circuits are synthesized under different constraints. The critical path delay of a design is set to the smallest value without incurring a timing violation for the delayoptimized synthesis, whereas the area is minimized for the area-optimized synthesis. The DesignWare library and "ultra compile" are used in the synthesis for optimization. The critical path delay and area are reported by the Synopsys DC. Power dissipation is measured by the PrimeTime-PX tool with ten million random input combinations. As widely used EDA tools in industry and academia, Synopsys DC and PrimeTime-PX provide estimations of timing, area, and power dissipation with a prediction error of less than 10% compared with physical implementations <ref type="bibr" target="#b77">[78]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) Comprehensive Measurements:</head><p>To provide an overall evaluation of an approximate circuit, both error and circuit characteristics must be considered. Several figures of merit (FOMs) have been developed by combining some error and circuit metrics in an analytical form <ref type="bibr" target="#b78">[79]</ref>, <ref type="bibr" target="#b79">[80]</ref>. However, these FOMs are heuristic-based and lead to different comparison results. In this work, therefore, the delay, power, and PDP of approximate circuits are directly compared with respect to their ERs, NMEDs, and MREDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. A P P R O X I M A T E A D D E R S A. Preliminaries</head><p>An adder performs the addition of two binary numbers and is one of the fundamental arithmetic circuits in a computer. Two basic designs are the ripple-carry adder (RCA) and the carry lookahead adder (CLA). An n-bit RCA consists of n FAs connected in series, each of which generates a sum (s i ) and a carry-out (c i+1 ) by implementing s i = a i ⊕ b i ⊕ c i and c i+1 = a i b i + a i c i + b i c i , where a i and b i are the i th least significant bits (LSBs) of the two inputs, and c i is the carry-in, i = 0, 1, . . . , n -1. In an n-bit RCA, the carry of each FA propagates to the next FA, thus the delay and circuit size increase proportionally with n, denoted by O (n). An n-bit CLA consists of n units in parallel; each unit produces the signals of a generate (g i = a i b i ), a propagate ( p i = a i ⊕ b i ), and a sum, where the former two signals are used for generating the lookahead carries. In a CLA, the carry is computed by</p><formula xml:id="formula_4">c i+1 = g i + p i c i = g i + p i (g i-1 + p i-1 c i-1 ) = • • • = i j =0 g j i k= j +1 p k + c 0 i k=0 p k .</formula><p>The delay of a CLA is approximately logarithmic in n or O (log (n)), which is significantly shorter than the delay of an RCA. However, a CLA requires a larger circuit area [in O (n log (n))], so it incurs a higher power dissipation.</p><p>For an adder with a width equal to or larger than 32 bits, the simple carry lookahead structure of CLA is not very efficient due to the large fan-in and fan-out of the constituent gates that lower the speed and increase the circuit area and power consumption. Thus, multiple levels of lookahead structures have been proposed to construct a large-width adder, which is usually referred to as a parallelprefix adder. The parallel-prefix adders exploit the fact that the carry signals in a CLA can be generated by grouping g i and p i in various ways. By varying the group size and the connection pattern, many parallel-prefix adders have been designed to improve the speed or reduce the circuit area, including the Kogge-Stone adder <ref type="bibr" target="#b80">[81]</ref>, the Ladner-Fischer adder <ref type="bibr" target="#b81">[82]</ref>, the Ling adder <ref type="bibr" target="#b82">[83]</ref>, the Brent-Kung adder <ref type="bibr" target="#b83">[84]</ref>, and the Han-Carlson adder <ref type="bibr" target="#b84">[85]</ref>. Another type of adders uses addition blocks of variable sizes, including the carry-select adder <ref type="bibr" target="#b85">[86]</ref>, the carry-skip adder <ref type="bibr" target="#b86">[87]</ref>, the conditional-sum adder <ref type="bibr" target="#b87">[88]</ref>, and the carry-increment adder <ref type="bibr" target="#b88">[89]</ref>. The architectures and characteristics of these adders are discussed in <ref type="bibr" target="#b89">[90]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Review</head><p>Conventional design methodology to accelerate an adder often comes with a cost in circuit area and power dissipation. However, approximate adders tradeoff accuracy for an overall improvement in hardware efficiency. Based on the approximation schemes to reduce the critical path and hardware complexity, approximate adders are classified into four categories. 1) Speculative Adders: As an early scheme, a speculative design leverages the fact that the effective carry chain of an n-bit adder is much shorter than n in most cases <ref type="bibr" target="#b13">[14]</ref>. Thus, an n-bit speculative adder uses the previous k bits (k &lt; n) to predict the carry for computing each sum bit, as shown in Fig. <ref type="figure" target="#fig_0">1</ref>. In this way, the critical path delay is reduced to O (log (k)) (for a parallel implementation, such as a CLA, the same below). Compared to the design in <ref type="bibr" target="#b13">[14]</ref>, the hardware overhead is reduced in the ACA by sharing some components among the subcarry generators <ref type="bibr" target="#b15">[16]</ref>.</p><p>2) Segmented Adders: A segmented adder is implemented by several parallel subadder blocks with an independent carry-in <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b90">[91]</ref>, <ref type="bibr" target="#b91">[92]</ref>. Hence, the carry propagation chain is truncated into shorter segments. Fig. <ref type="figure" target="#fig_1">2</ref> shows a basic structure for many segmented adders. As the simplest design, an n-bit ESA uses n/k k-bit subadders without any carry-in <ref type="bibr" target="#b18">[19]</ref>. Different from ACA, the input bits used for carry computation do not overlap in ESA; thus, for the same k, its hardware cost is significantly lower than ACA.</p><p>In an n-bit accuracy-configurable approximate adder (ACAA), n/k -1 2k-bit subadders are utilized to add 2k consecutive bits without carry inputs and k bits are overlapped between two neighboring subadders <ref type="bibr" target="#b90">[91]</ref>. The accuracy of ACAA can be configured at runtime by changing the bit width of the subadders. The generic accuracy configurable adder (GeAr) generalizes the structure of ACAA by varying the number of overlapped bits used for carry prediction <ref type="bibr" target="#b92">[93]</ref>, whereas the quality-area optimal low-latency approximate adder (QuAd) further utilizes subadders of variable width <ref type="bibr" target="#b93">[94]</ref>.</p><p>An n-bit error-tolerant adder type II (ETAII) consists of n/k k-bit carry generators that are connected in parallel with the k-bit sum generators <ref type="bibr" target="#b16">[17]</ref>. For the same k, ETAII utilizes a carry generator to predict the carry for the next sum generator, so it is more accurate than ESA and ACA. However, the circuit of ETAII is more complex than that of ESA, and its delay is larger due to the longer 2k-bit critical path. For a fixed k, ETAII uses the same carry propagation path as ACAA for each sum, so they share the same error characteristics.</p><p>The dithering adder uses a more significant (accurate) subadder and a less significant subadder with upper and lower bounding modules <ref type="bibr" target="#b67">[68]</ref>. An additional control signal is used as the carry-in of the more significant (accurate) subadder, which is also used to select the sum output of the less significant subadder. To reduce the error due to the ignored carry inputs, an error control and compensation method is developed to tradeoff computing efficiency for an improved accuracy of a segmented adder in <ref type="bibr" target="#b91">[92]</ref>.</p><p>Generally, the critical paths of the segmented adders are in O (log (k)) due to the carry-ignored segmentation. The circuit complexities are in</p><formula xml:id="formula_5">O (n log (k)) for ESA and ETAII, in O ((n -k) log (k)) for ACAA, and in O (((n -L)/k + 1) L log (L)) for GeAr.</formula><p>3) Approximate Carry-Select Adders: The structure used in the classic carry-select adder <ref type="bibr" target="#b85">[86]</ref> is employed in <ref type="bibr" target="#b94">[95]</ref>- <ref type="bibr" target="#b101">[102]</ref> to introduce approximation in the selection of the carry-in and sum for each subadder. This type of adders is referred to as an approximate carry-select adder with either sum or carry-in selection, as shown in Figs. <ref type="figure" target="#fig_2">3</ref> and<ref type="figure">4</ref>, respectively. An n-bit approximate carry-select adder consists of m = n/k blocks and uses several common signals. For the i th block, generate g i, j = a i, j b i, j , propagate p i, j = a i, j ⊕ b i, j , and P i = k-1 j =0 p i, j are defined, where a i, j and b i, j are the j th LSBs of the inputs in block i , where j = 0, 1, . . . , k -1. P i = 1 indicates that all k propagate signals in the i th block are logic "1."</p><p>In the speculative carry selection adder (SCSA) <ref type="bibr" target="#b94">[95]</ref> and the consistent carry approximate adder (CCA) <ref type="bibr" target="#b98">[99]</ref>, a sum is selected from adder0 (with carry-in "0") and adder1 (with carry-in "1") by using a multiplexer. In the SCSA, the carry-out of adder0 in the (i -1)th block is connected to the Sel i signal of the multiplexer in the i th </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 4. Approximate carry-select adder with carry-in selection.</head><p>block (see Fig. <ref type="figure" target="#fig_2">3</ref>). The SCSA, ETAII, and ACAA achieve the same accuracy for the same value of k due to the identical carry predict function. In the CCA, the Sel i of the multiplexer is determined by the propagate signals in the current and previous blocks. The carry prediction of the CCA depends not only on its LSBs, but also on the more significant bits.</p><p>In Fig. <ref type="figure">4</ref>, each block consists of a carry generator and a sum generator. The approximate carry skip adder (CSA) <ref type="bibr" target="#b95">[96]</ref>, the generate signal-exploited carry speculation adder (GCSA) <ref type="bibr" target="#b99">[100]</ref>, and the block-based carry speculative approximate adder (BCSA) <ref type="bibr" target="#b102">[103]</ref> use different selection schemes for the carry-in of a carry generator. In the CSA, the carry-in of the (i + 1)th block is determined by the propagate signals of the i th block: it is the carryout of the (i -1)th subcarry generator when all propagate signals are true (P i = 1); otherwise, it is the carry-out of the i th subcarry generator. The generate signals are used in the GCSA for the carry speculation; the carry-in for the (i + 1)th block is selected by its own propagate signals rather than its previous block. The carry-in is the most significant generate signal g i,k-1 of the i th block if P i = 1, or else it is the carry-out of the i th carry generator. The carry-in of the (i + 1)th block in BCSA is selected between the most significant generate signal g i,k-1 and the carry-out of the i th block, that is, C i+1,in = S i C i,out + S i g i,k-1 , where S i = a i+1,0 + b i+1,0 + g i,k-1 <ref type="bibr" target="#b102">[103]</ref>. An error detection-and-recovery scheme is further proposed to partially compensate the errors by modifying the LSB of the sum output in each block.</p><p>In the carry speculative adder (CSPA), each block contains one sum generator, two internal carry generators with carry-0 and carry-1, respectively, and a simple carry predictor <ref type="bibr" target="#b97">[98]</ref>. The carry-out of the i th carry predictor selects a carry-in for the (i + 1)th sum generator. The carry predictor uses k l rather than k input bits (k l &lt; k), so it leads to a simpler circuit than SCSA for the same block size k.</p><p>Some control signals are added to the gracefully degrading accuracy-configurable adder (GDA) to configure the accuracy by selecting an accurate or approximate carryin for each subadder <ref type="bibr" target="#b96">[97]</ref>. Thus, the delay of GDA varies with the carry propagation path determined by the control signals.</p><p>In the carry cut-back adder (CCBA), the full carry propagation is prevented by a multiplexer or an OR gate <ref type="bibr" target="#b101">[102]</ref>. The carry-in for a segment is determined by a cut signal from a carry propagate block at a higher position, a carry speculated from a short chain at a lower position, and the carry-out of the previous segment. The delay and accuracy of the CCBA depend on the distance between the propagate block and the multiplexer or OR gate.</p><p>The critical path delay of the approximate carry-select adders can be given by O (log (k)), when the bit width of the input operands in each block is k. The circuit area varies with the complexity of the carry prediction and selection schemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4) Approximate Full Adders:</head><p>Another method for reducing the critical path and power dissipation of an adder is to approximate an FA. The approximate FA (AFA) is then used to implement l LSBs in an n-bit adder (l &lt; n), whereas the (nl) MSBs are computed by an AccuA, as shown in Fig. <ref type="figure" target="#fig_3">5</ref>. In the LOA, an OR gate is used as a simple AFA, and an AND gate is used to generate the carry-in for the AccuA <ref type="bibr" target="#b17">[18]</ref>.</p><p>Other AFA designs include the mirror adder <ref type="bibr" target="#b19">[20]</ref>, the approximate XOR/XNOR-based FAs <ref type="bibr" target="#b103">[104]</ref>, the inexact adder cells proposed in <ref type="bibr" target="#b104">[105]</ref>, and the approximate reverse carry propagate FA <ref type="bibr" target="#b105">[106]</ref> (specific for the RCA structure). Additionally, emerging technologies such as magnetic tunnel junctions have been considered for the design of AFAs for a shorter delay, a smaller area, and a lower power consumption <ref type="bibr" target="#b106">[107]</ref>, <ref type="bibr" target="#b107">[108]</ref>. Finally, a simply truncated adder (TruA) that works with a lower precision is considered as a baseline design.</p><p>The critical path of this type of adders is typically in O (log (nl)) when there is no carry propagation for the AFAs. LOA is selected as the reference design in the evaluation due to its logic-level implementation while most other AFAs are designed at the transistor level.</p><p>In addition to the above four categories, a library of 430 approximate 8-bit adders has been automatically generated by using Cartesian genetic programming (CGP) and a multiobjective genetic algorithm <ref type="bibr" target="#b108">[109]</ref>. Due to the restricted bit width of 8 bits, however, this group of designs is not considered in the evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Evaluation</head><p>In this evaluation, we consider 16-bit approximate adders. In the circuit implementations, all subadders in the designs are implemented by CLAs for a high efficiency.</p><p>To obtain the error characteristics, the functions of the 16-bit approximate adders are implemented in MATLAB and simulated with ten million uniformly distributed random input combinations. The simulation results show similar trends in MRED and NMED for the approximate adders <ref type="bibr" target="#b50">[51]</ref>, so only the MRED is reported here. For circuit measurements, the 16-bit approximate adders are implemented in HDLs and synthesized as described in Section II-B2. The clock period used in the power estimation is 1 ns. Fig. <ref type="figure">6</ref> shows the delay comparison of approximate adders with respect to MRED and ER (for delay-optimized synthesis), whereas Fig. <ref type="figure" target="#fig_4">7</ref> shows the power comparison (for area-optimized synthesis). The overall comparison in PDP and MRED is shown in Fig. <ref type="figure" target="#fig_5">8</ref> (for both delay-and area-optimized syntheses). A Pareto front is delineated in each figure to show the designs with the highest efficiency. As ETAII, ACAA, and SCSA share the same error characteristics for a certain k, only ETAII is shown in the figures due to its lower hardware overhead.</p><p>As can be seen in Fig. <ref type="figure">6</ref>, most approximate adders have very close ERs between 0.5% and 35% except for GeAr (R4_P8) and CSA (for k &gt; 3) with ERs smaller than 0.5%, and CCBA, ESA, LOA, and TruA with very high ERs, although CCBA, LOA, and TruA can have relatively small MREDs. CSA can be very accurate, whereas ESA, BCSA, and CSPA show a low accuracy with relatively large MREDs and ERs.</p><p>1) Performance/Power Versus Accuracy: As also shown in Fig. <ref type="figure">6</ref>, LOA, CCBA, and GeAr can be faster than the other designs for a relatively small MRED, so they exhibit a balanced tradeoff in performance and accuracy (in MRED). ESA and CSPA are the fastest at a large MRED and ER. For a similar ER, some configurations of CSA, GeAr, and ETAII can be faster than others (i.e., in the Pareto front). As shown in Fig. <ref type="figure" target="#fig_4">7</ref>, CCBA, LOA, and TruA achieve the best power and accuracy tradeoffs (in terms of MRED). GeAr, BCSA, and CCBA are in the Pareto set for power consumption and ER.</p><p>2) Energy Versus Accuracy: To consider both error and circuit characteristics, the MRED and PDP are selected as representative metrics. As shown in Fig. <ref type="figure" target="#fig_5">8</ref>, a similar trend is obtained for both the delay-and area-optimized syntheses in the PDP and MRED of the approximate adders. Overall, CCBA, LOA, and TruA achieve the best tradeoffs between accuracy (in MRED) and energy (in PDP); however, they have the highest ERs. Nevertheless, these approximate adders show a decent tradeoff in error magnitude and hardware efficiency. In particular, they are suitable for applications in which a high ER is not as detrimental as a large error magnitude.</p><p>In summary, truncation is an effective approach to a hardware-efficient design, albeit resulting in a high ER. On the other hand, the carry select scheme can be very effective in highly accurate designs such as the CSA. A speculative adder results in a very high power dissipation PROCEEDINGS OF THE IEEE 7</p><p>Authorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 6. Optimized delay versus accuracy for the approximate 16-bit adders using different error metrics. (a) Optimized delay versus MRED. (b) Optimized delay versus ER.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note: The number of approximate or truncated LSBs for LOA and TruA ranges from 3 to 9, the subadder width of ESA is from 8 down to 3, the number of bits used for carry speculation for ACA is from 8 down to 3 from left to right. The block width for CSA is from 5 down to 3, and it is from 6 down to 3 for the other adders from left to right. In CSPA, the size of the carry predictor is k/2. The global speculative carry for</head><p>CCA is "0," which leads to a more accurate result than using "1." For GeAr, the configurations from left to right are R4_P8, R6_P4, R4_P4, and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R2_P4 (Rm_Pk means k previous bits are used for generating m bits of sum results). For CCBA, the configurations with the smallest PDPs are chosen for a similar MRED.</head><p>and a large error magnitude (e.g., ACA). The advantages and disadvantages of the approximate adders with at least one prominent property are summarized in Table <ref type="table" target="#tab_0">1</ref>. In this table, ED stands for both MRED and NMED. As can be seen, the ESA is very hardware-efficient for applications with high error tolerance, whereas CSA is suited for applications that require a high accuracy. When a high ER is not an issue, CCBA, LOA, and TruA are the most efficient designs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. A P P R O X I M A T E M U L T I P L I E R S A. Preliminaries</head><p>Typically, a combinational multiplier consists of three processing stages: PP generation, PP accumulation, and a final carry propagate addition, as shown in Fig. <ref type="figure" target="#fig_6">9</ref>. Let the two input operands of an n × n unsigned multiplier be</p><formula xml:id="formula_6">A = n-1 i=0 A i 2 i and B = n-1 i=0 B i 2 i</formula><p>, where A i and B i are the i th least significant bits of inputs A and B, This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.  respectively, and i starts from 0. A PP is often generated by an AND gate, that is, PP i, j = A j B i . To accumulate the PPs, three structures are widely used: the carry-save adder array <ref type="bibr" target="#b109">[110]</ref>, the Wallace tree <ref type="bibr" target="#b110">[111]</ref>, and the Dadda tree <ref type="bibr" target="#b111">[112]</ref>.</p><p>Fig. <ref type="figure" target="#fig_7">10</ref> shows a carry-save adder array for a 4 × 4 unsigned multiplier, where the carry and sum signals generated by the adders in a row are passed on to the adders in the next row. The carry signals propagate through the adders in a diagonal direction. Hence, the critical path for an n × n multiplier is approximately in O (n). Due to its regular layout, the array structure in Fig. <ref type="figure" target="#fig_7">10</ref> requires mostly short wires and is easy to scale to large arrays.</p><p>A Wallace tree utilizes FAs, half adders (HAs), and 4:2 compressors for a fast accumulation of the PPs, as shown in the dotted box in Fig. <ref type="figure" target="#fig_6">9</ref> for a 4 × 4 unsigned multiplier. The adders in each stage operate in parallel without carry propagation, and the same operation repeats until two rows of the PPs are left. For an n × n multiplier, about log 1.5 (n/2) stages are required in a Wallace tree <ref type="bibr" target="#b109">[110]</ref>. Therefore, the delay is in O (log (n)), which is shorter than that of the array structure. The Dadda tree has a similar structure as the Wallace tree, but it uses as few adders as possible rather than reducing PPs as early as possible in a Wallace tree. Compared to the array structure, a tree-based PP accumulation is faster; however, a tree structure requires longer and more complex wiring, which can result in a larger circuit area <ref type="bibr" target="#b112">[113]</ref>.</p><p>Signed multiplication uses two's complement representation. The input operands are given as</p><formula xml:id="formula_7">A = -A n-1 2 n-1 + n-2 i=0 A i 2 i and B = -B n-1 2 n-1 + n-2 i=0 B i 2 i</formula><p>. The Booth algorithm is then used to recode the multiplier for generating PPs <ref type="bibr" target="#b113">[114]</ref>. MacSorley modified the Booth algorithm to the radix-4 Booth algorithm <ref type="bibr" target="#b114">[115]</ref>, which reduces the number of PPs by half. The radix-2 r Booth algorithm can be obtained by using the same principles of the radix-4 scheme. In addition, the Baugh-Wooley algorithm <ref type="bibr" target="#b115">[116]</ref> and the modified Baugh-Wooley algorithm <ref type="bibr" target="#b116">[117]</ref> can simplify the signed multiplication by adding the two's complements of the PP rows and preprocessing the constant additions. The modified Baugh-Wooley algorithm is also widely used to eliminate the sign extension in Booth multipliers <ref type="bibr" target="#b117">[118]</ref>. To approximate an unsigned multiplier, five methodologies have been considered: 1) approximation in generating the PPs <ref type="bibr" target="#b21">[22]</ref>; 2) approximation (including truncation) in the PP tree <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b118">[119]</ref>, <ref type="bibr" target="#b119">[120]</ref>; 3) using approximate adders <ref type="bibr" target="#b120">[121]</ref>, counters <ref type="bibr" target="#b62">[63]</ref>, or compressors <ref type="bibr" target="#b78">[79]</ref>, <ref type="bibr" target="#b79">[80]</ref>, <ref type="bibr" target="#b121">[122]</ref>- <ref type="bibr" target="#b125">[126]</ref> in the PP reduction; 4) using logarithmic approximation <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b63">[64]</ref>, <ref type="bibr" target="#b126">[127]</ref>- <ref type="bibr" target="#b129">[130]</ref>; and 5) using an automated process such as a genetic programming method <ref type="bibr" target="#b108">[109]</ref>, <ref type="bibr" target="#b130">[131]</ref>. For signed multiplication, approximate Booth multipliers have been designed for its fast operation on a reduced number of PPs.</p><p>Therefore, approximate multipliers are classified into five unsigned categories and signed Booth multipliers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Approximate Unsigned Multipliers</head><p>1) Approximation in Generating PPs: As an early design, the UDM utilizes an approximate 2 × 2 multiplier to construct larger multipliers <ref type="bibr" target="#b21">[22]</ref>. The 2 × 2 multiplier approximates the product "1001" with "111" when both the inputs are "11," so saving one output bit and simplifying the logic circuit. The ER of this 2 × 2 multiplier is 0.5 4 = 6.25% if each input bit is equally likely to be "0" or "1."</p><p>2) Approximation in the PP Tree: A BAM omits some carry-save adders in an array multiplier in both the horizontal and vertical directions <ref type="bibr" target="#b17">[18]</ref>. A more straightforward approximation is to truncate some LSBs on the input operands so that a smaller multiplier is sufficient for the remaining MSBs. This truncated multiplier (TruM) is considered as a baseline design for comparison. Different from BAM and TruM, several consecutive rows of PPs that do not necessarily start from the LSB are ignored for the PP reduction in <ref type="bibr" target="#b131">[132]</ref>. This design is referred to as a PP perforation-based multiplier (PPAM).</p><p>The ETM consists of a multiplication section, a nonmultiplication section, and a control block <ref type="bibr" target="#b20">[21]</ref>. The NOR gates-based control block determines: 1) if all k MSBs in at least one of the two n-bit input operands are zeros, the multiplication section (using an accurate k × k multiplier, where k &lt; n) is activated to multiply the LSBs without any approximation and 2) otherwise, the accurate multiplier (AccuM) is used to multiply the MSBs, while the nonmultiplication section is used to approximately process the LSBs. The static segment multiplier (SSM) uses a similar partition scheme, but the approximation section is omitted for not processing the LSBs <ref type="bibr" target="#b132">[133]</ref>. If the MSBs of one input are all zeros, its LSBs are multiplied by either the MSBs or the LSBs of the other input depending on whether MSBs are all zeros.</p><p>Similarly, an exact k × k submultiplier is used in the design of an n × n dynamic range unbiased multiplier (DRUM) <ref type="bibr" target="#b119">[120]</ref>. However, the k-bit inputs of the reducedwidth multiplier are dynamically selected starting from the leading "1"s or the most significant "1"s in the two n-bit input operands. If the leading "1" position is higher than k, the redundant LSBs are truncated and the LSB of the k selected bits is set to "1." Otherwise, the leading "1" position is ignored, and the k LSBs of the input operands are selected as the inputs of the submultiplier. The final output is then obtained by using a barrel shifter to restore the computed result. As the input bits are more effectively processed, DRUM is more accurate than ETM and SSM. Moreover, it produces unbiased errors, so it is suited for accumulative operations. However, it uses a more complex circuit for the dynamic selection of inputs.</p><p>An approximate Wallace tree multiplier (AWTM) utilizes a bit-width-aware approximate multiplication and a carryin prediction <ref type="bibr" target="#b118">[119]</ref>. An n × n AWTM is implemented by four n/2 × n/2 submultipliers, where the most significant submultiplier A H B H is further divided into four n/4 × n/4 submultipliers. By using different numbers of approximate n/4×n/4 submultipliers in A H B H , the AWTM is configured into four modes. The three less significant n/2 × n/2 submultipliers ( A H B L , A L B H , and A L B L ) are approximate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) Using Approximate Counters or Compressors in the PP</head><p>Reduction: An inaccurate 4 × 4 Wallace multiplier uses a 4:2 counter that approximates the output of the carry and sum, "100," with "10" when all four inputs are "1" <ref type="bibr" target="#b62">[63]</ref>. For uniformly distributed inputs, the probability of one bit being "1" is 0.5, so the probability that a PP is "1" is 0.25. The ER of the approximate 4:2 counter is, therefore, only 0.25 4 = 0.39%. Larger multipliers can be constructed using the inaccurate counter-based 4 × 4 multiplier (ICM, in general). In the approximate counters in <ref type="bibr" target="#b133">[134]</ref>, the more significant output bits are ignored for an efficient implementation of several signed multipliers.</p><p>Two approximate designs that implement simplified functions of 4:2 compressors are considered for Dadda multipliers <ref type="bibr" target="#b122">[123]</ref>. To lower the error probability, the PPs are encoded by propagate (i.e., PP i, j + PP j,i ) and generate (i.e., PP i, j • PP j,i ) signals, which enable the design of several approximate compressors with a relatively low error probability <ref type="bibr" target="#b123">[124]</ref>. Similarly, an approximate 4:2 compressor with encoded inputs is proposed for 4 × 4 multipliers, which is then used to construct larger multipliers <ref type="bibr" target="#b124">[125]</ref>.</p><p>The dual-quality 4:2 compressors in <ref type="bibr" target="#b78">[79]</ref> can switch between exact and approximate operating modes using power gating techniques. These compressors are then used in the PP accumulation of a Dadda multiplier and the accuracy can be dynamically configured. Using a three-input majority gate, a FinFET-based imprecise 4:2 compressor is designed for an approximate 8 × 8 Dadda multiplier with truncation in the PP array <ref type="bibr" target="#b79">[80]</ref>.</p><p>In the high-order compressor-based multiplier (HOCM), each column of PPs is accumulated by only one compressor <ref type="bibr" target="#b125">[126]</ref>. An allocation algorithm is then developed to determine the use of exact and approximate compressors at different stages of the accumulation with the truncation of the lower half PPs.</p><p>In <ref type="bibr" target="#b120">[121]</ref>, a novel approximate adder uses two adjacent inputs to generate a sum and an error bit for accumulating the PPs. To alleviate the error due to the approximate adder, two error recovery schemes are considered to use either OR gates to accumulate the error bits in the socalled approximate multiplier 1 (AM1) or both OR gates and the approximate adders in the approximate multiplier 2 (AM2). Moreover, TAM1 and TAM2 are obtained by truncating the lower half of the PPs in AM1 and AM2, respectively <ref type="bibr" target="#b49">[50]</ref>, <ref type="bibr" target="#b134">[135]</ref>.</p><p>4) Using Logarithmic Approximation: Mitchell's algorithm leverages the logarithmic and anti-logarithmic approximations of a binary number. It serves as the basis of logarithmic multipliers (LMs) <ref type="bibr" target="#b10">[11]</ref>. In this algorithm, the two unsigned binary input operands A and B of a multiplier are expressed as</p><formula xml:id="formula_8">A = 2 k 1 (1 + x 1 )<label>(5)</label></formula><p>and</p><formula xml:id="formula_9">B = 2 k 2 (1 + x 2 ) (<label>6</label></formula><formula xml:id="formula_10">)</formula><p>where k 1 and k 2 indicate the leading "1" positions of A and B, respectively, and x 1 and x 2 are the fractional numbers that represent the bits to the right of the leading "1"s normalized by 2 k 1 and 2 k 2 , respectively. The product of A and B is then given by</p><formula xml:id="formula_11">M = A × B = 2 k 1 +k 2 (1 + x 1 ) (1 + x 2 ) . (<label>7</label></formula><formula xml:id="formula_12">)</formula><p>Thus</p><formula xml:id="formula_13">log 2 M = k 1 + k 2 + log 2 (1 + x 1 ) + log 2 (1 + x 2 ) . (<label>8</label></formula><formula xml:id="formula_14">)</formula><formula xml:id="formula_15">As 0 ≤ x 1 , x 2 &lt; 1, log 2 (1 + x 1 ) ≈ x 1 , and log 2 (1 + x 2 ) ≈ x 2 .</formula><p>Hence, ( <ref type="formula" target="#formula_13">8</ref>) is approximated by</p><formula xml:id="formula_16">log 2 M ≈ k 1 + k 2 + x 1 + x 2 . (<label>9</label></formula><formula xml:id="formula_17">)</formula><p>The multiplication is then completed by performing an antilogarithmic approximation, that is,</p><formula xml:id="formula_18">M ≈ 2 k 1 +k 2 (x 1 + x 2 + 1) , if x 1 + x 2 &lt; 1 2 k 1 +k 2 +1 (x 1 + x 2 ) , if x 1 + x 2 ≥ 1. (<label>10</label></formula><formula xml:id="formula_19">)</formula><p>To improve the accuracy of an LM, the ALM-SOA uses a truncated binary-logarithm converter and a set-one-adder (SOA) for the addition <ref type="bibr" target="#b126">[127]</ref>. The SOA simply sets the LSBs to constant "1"s and generates a carry-in for the MSBs using an AND gate. Moreover, an improved algorithm using exact and approximate adders (ILM-EA and ILM-AA) is proposed in <ref type="bibr" target="#b63">[64]</ref> and <ref type="bibr" target="#b127">[128]</ref>. In <ref type="bibr" target="#b128">[129]</ref>, the input operands between two consecutive powers of two are partitioned into several segments. An error reduction factor is then analytically determined for each segment and compensated to the result of the basic LM. A two-stage design that uses two truncated LMs for error correction achieves a low and unbiased average error <ref type="bibr" target="#b129">[130]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5) Using an Automated Process:</head><p>In <ref type="bibr" target="#b108">[109]</ref>, 471 8 × 8 approximate unsigned multipliers are automatically generated by using CGP and a multiobjective genetic algorithm. As CGP can provide better implementations of a circuit than conventional synthesis tools, it is used to denote a circuit using this design method. An approximate circuit is generated by randomly removing some connections of several accurate designs. A genetic algorithm is then applied for design space exploration to obtain the optimal approximate circuits with respect to MRED. These 8 × 8 multipliers are then used to construct 16 × 16 approximate multipliers, referred to as CGPM1-CGPM6 <ref type="bibr" target="#b130">[131]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Evaluation of Approximate Unsigned Multipliers</head><p>The error and circuit characteristics of 16 × 16 approximate unsigned multipliers are obtained with the same experimental setup as in the evaluation of approximate adders, except that the clock period used in the power estimation is 4 ns.</p><p>As shown in <ref type="bibr" target="#b50">[51]</ref>, most of the approximate multipliers result in large ERs close to 100%. However, ICM has a low ER of 5.45% because only one approximate counter with an ER of 0.39% is used in a 4 × 4 multiplier block. Some configurations of CGPM1, CGPM2, and CGPM3 also show lower ERs than the other designs. Additionally, the ER of UDM is 80.99%, which is lower than most of the other designs. Hence, the accuracy is only compared here in MRED and NMED. For circuit measurements, Fig. <ref type="figure" target="#fig_8">11</ref> shows the critical path delay of the multipliers synthesized under delay-optimized constraints with respect to MRED and NMED, while Fig. <ref type="figure" target="#fig_9">12</ref> shows the power consumption for area-optimized synthesis. Based on the preliminary results in <ref type="bibr" target="#b56">[57]</ref>, the designs with good tradeoffs are selected from each category for comparison here. The array and Wallace </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note: The number of truncated LSBs for TruMA and TruMW is from 2 to 8 from left to right, and from 11 to 22 for BAM. The number of MSBs used for error compensation is from 16 to 10 for TAM1. The size of the accurate submultiplier is from 10 to 8 for SSM, and 10 to 6 for DRUM.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The configurations for HOCM are 1StepFull (with approximate compressors in the first accumulation stage), 1StepTrunc (1StepFull with a truncation of LSBs), 2StepFull (with approximate compressors in both the first and second stages), and 2StepTrunc (2StepFull with a truncation of LSBs) from left to right. For CGPM1 and CGPM3, which, respectively, use one and three 8 × 8 approximate multipliers for constructing a 16 × 16 multiplier, the configurations with the smallest PDPs are shown for a specific MRED, selected from 500 configurations for each design.</head><p>architectures are considered for TruM, which are denoted as TruMA and TruMW, respectively.</p><p>1) Performance Versus Accuracy: Fig. <ref type="figure" target="#fig_8">11</ref> shows that most approximate unsigned multipliers exhibit a similar performance trend versus both MRED and NMED except for ICM and DRUM. CGPM1 is the most accurate design with very small values of MRED and NMED, and a reasonable performance. As expected, the LMs (ALM-SOA and ILM-AA) are good in performance, but poor in accuracy. HOCM, TAM1, ILM-AA, and ALM-SOA show the best tradeoffs between performance and accuracy. PPAM can have the shortest delay but largest error.</p><p>2) Power Versus Accuracy: As shown in Fig. <ref type="figure" target="#fig_9">12</ref>, LMs are very power-efficient albeit with a very low accuracy, whereas CGPM1 is relatively power-hungry but with a high accuracy. At a medium accuracy, BAM consistently consumes a low power, followed by CGPM3. Some configurations of HOCM also show good tradeoffs in power This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.</p><p>Jiang et al.: Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 13. Comparison of PDP and MRED for the approximate 16 × 16 unsigned multipliers. (a) PDP (delay-optimized) versus MRED. (b) PDP (area-optimized) versus MRED.</head><p>Table <ref type="table">2</ref> Summary of Approximate Unsigned Multipliers efficiency and accuracy. HOCM (1StepTrunc) shows the best tradeoff in power and accuracy.</p><p>3) Energy Versus Accuracy: The PDPs of the unsigned multipliers with respect to MRED are shown in Fig. <ref type="figure" target="#fig_2">13</ref>. The overall trend is slightly different between the delay-optimized [see Fig. <ref type="figure" target="#fig_2">13(a)</ref>] and area-optimized [see Fig. <ref type="figure" target="#fig_2">13(b)</ref>] synthesis results. As shown in Fig. <ref type="figure" target="#fig_2">13(a)</ref>, the 1StepFull in HOCM, TAM1, CGPM1, and CGPM3 exhibit the best energy-accuracy tradeoffs, located in the center of the plot. In Fig. <ref type="figure" target="#fig_2">13(b),</ref><ref type="figure" target="#fig_2">CGPM3</ref>, HOCM, TAM1, and TruMA show slightly better tradeoffs than the other designs. At a very low accuracy, ALM-SOA and PPAM are the most hardware-efficient with the smallest PDP values.</p><p>In summary, truncation is effective in reducing the delay and energy consumption of unsigned multipliers. An LM tends to be hardware-efficient but with a rather low accuracy. The automatically generated multipliers can be highly accurate with a reasonable hardware consumption. A brief summary of the error and circuit characteristics is shown in Table <ref type="table">2</ref> for the approximate unsigned multiplier in the Pareto fronts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 14. PP partition for an 8 × 8 fixed-width modified Booth multiplier [136]. PP i,j is the jth PP in the ith PP vector, PP i,j is the inverted PP i,j , and n i is the sign of the ith encoded digit.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Approximate Booth Multipliers</head><p>The modified (or radix-4) Booth algorithm is commonly used in the design of approximate Booth multipliers <ref type="bibr" target="#b117">[118]</ref>, <ref type="bibr" target="#b135">[136]</ref>- <ref type="bibr" target="#b139">[140]</ref>. Initially aimed at a fixed-width signed multiplier, a widely used method is to truncate the lower half of the PPs to generate an output with the same width as the input. This truncation saves the circuits for PP accumulation, but it introduces a large error. Hence, many error compensation schemes have been proposed to increase accuracy <ref type="bibr" target="#b117">[118]</ref>, <ref type="bibr" target="#b135">[136]</ref>, <ref type="bibr" target="#b136">[137]</ref>, <ref type="bibr" target="#b138">[139]</ref>.</p><p>Inspired by the BAM, the broken Booth multiplier (BBM) omits the adder cells to the right of a vertical line <ref type="bibr" target="#b137">[138]</ref>, whereas directly truncating k LSBs of the input operands leads to a truncated Booth multiplier (TBM-k). The TBM is considered as a baseline design for comparing the Booth multipliers.</p><p>Generally, a fixed-width Booth multiplier is based on a partition of the PP array, as shown in Fig. <ref type="figure" target="#fig_0">14</ref>. For an 8 × 8 fixed-width modified Booth multiplier, the PP array is divided into two parts: the upper half denoted as the main part (MP) and the lower half truncation part (TP). The TP is further divided into TP major and TP minor . The final</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROCEEDINGS OF THE IEEE 13</head><p>Authorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply. product of a fixed-width multiplier is the addition of the MP and the carry signals generated from the TP.</p><p>In <ref type="bibr" target="#b135">[136]</ref>, the carry signals include the exact carry from the TP major and an approximate carry from the TP minor (see Fig. <ref type="figure" target="#fig_0">14</ref>). The approximate carry is generated by the output of the modified Booth encoders. This multiplier is referred to as BM04. Using a similar partition scheme, BM11 relies on a simplified sorting network to generate the carries for error compensation <ref type="bibr" target="#b117">[118]</ref>. This error compensation makes the errors symmetrical and centered zero, which reduces the error bias and MSE. In BM15, the error due to truncation is compensated by the outputs of the Booth encoders and the multiplicand <ref type="bibr" target="#b140">[141]</ref>. In BM07, the number of PP columns in TP major is adaptively variable to compensate for the quantization error in a fixed-width multiplier <ref type="bibr" target="#b136">[137]</ref>. Another design is based on a probabilistic estimation-based bias <ref type="bibr" target="#b138">[139]</ref>, referred to as PEBM. In this design, an error compensation formula is derived from a probability analysis, where the number of PP columns in TP major varies in accordance with the desired tradeoff between hardware and accuracy.</p><p>To reduce the additional delay due to the radix-8 Booth algorithm, an approximate recoding adder is proposed for calculating the triple multiplicands in <ref type="bibr" target="#b141">[142]</ref>. A Wallace tree and a truncation technique are then utilized for the PP accumulation. To be consistent with the fixed-width Booth multipliers, the most efficient approximate radix-8 Booth multiplier, ABM2_R15 (with the truncation of 15 bits, resulting in a fixed-width multiplier), is considered and denoted as ABM2.</p><p>To speed up the PP generation, two approximate radix-4 Booth encoders are proposed by simplifying the K-Map to generate k least significant PP columns for an n × n multiplier (k = 1, 2, . . . , 2n) <ref type="bibr" target="#b139">[140]</ref>. By changing the value of k, different tradeoffs can be achieved between accuracy and hardware efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Evaluation of Approximate Booth Multipliers</head><p>In this evaluation, we consider 16 × 16 approximate (or fixed-width) Booth multipliers for signed multiplication. The clock period for the power estimation is 4 ns. Fig. <ref type="figure" target="#fig_10">15</ref> shows the optimized delay with respect to NMED and MRED, while the power is shown in Fig. <ref type="figure" target="#fig_11">16</ref> for areaoptimized synthesis. Fig. <ref type="figure" target="#fig_12">17</ref> shows the tradeoff between PDP (for both delay-and area-optimized syntheses) and MRED for the approximate Booth multipliers.</p><p>1) Performance/Power Versus Accuracy: As revealed in Figs. <ref type="figure" target="#fig_10">15</ref> and<ref type="figure" target="#fig_11">16</ref>, most fixed-width Booth multipliers show similar NMEDs except for BBM and BM15 with relatively large values. Compared to the fixed-width Booth multipliers, TBM can have a similar MRED and higher NMED, with a higher speed and power dissipation. With a moderate accuracy, ABM2 is the fastest and the most power-efficient. With a very high accuracy, BM07 is the slowest design with a relatively high power consumption, followed by BM11. PEBM shows a moderate speed and power dissipation, with a relatively high accuracy.</p><p>2) Energy Versus Accuracy: Fig. <ref type="figure" target="#fig_12">17</ref> shows that BM07, BM11, and PEBM exhibit the best tradeoffs between accuracy and PDP. ABM2 and BBM stand out too for  power-optimized synthesis. A summary of the error and circuit characteristics is shown in Table <ref type="table" target="#tab_1">3</ref>. Overall, BM07 and BM11 are relatively accurate but slow. PEBM shows small values of NMED and PDP, as well as a high speed. ABM2 is efficient in both power and performance with a moderate accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. A P P R O X I M A T E D I V I D E R S A. Preliminaries</head><p>Although the divider is not as frequently used as adders and multipliers, the system performance can be significantly degraded if it is not appropriately implemented, whereas it is hard to reduce the latency of dividers without significant overhead in area <ref type="bibr" target="#b142">[143]</ref>. A straightforward approach to divider design is to follow the pencil-andpaper algorithm. In general, the quotient of a division is computed by iteratively subtracting a multiple of the divisor from the partial remainder that is initially set to the dividend. In a restoring divider, the partial remainder is corrected or reserved when the subtraction yields a negative number, while it is not corrected in a nonrestoring divider <ref type="bibr" target="#b109">[110]</ref>. Fig. <ref type="figure" target="#fig_5">18</ref> shows an 8/4 unsigned restoring array divider that uses a multiplexer and the borrow signal in the subtractor cell to retain the partial remainder. Generally, n 2 subtractor cells are required in a 2n/n array divider. The critical path is in O n 2 due to the ripple borrow propagations among subtractor cells, whereas it is in O (n) for an n × n array multiplier. Therefore, an array divider is much slower than an array multiplier. However,  the delay of an array divider can be reduced by using carry-save reduction and carry-lookahead principles, with an increased cost in area and power consumption <ref type="bibr" target="#b143">[144]</ref>.</p><p>To reduce the critical path, Sweeney <ref type="bibr" target="#b144">[145]</ref>, Robertson <ref type="bibr" target="#b145">[146]</ref>, and Tocher <ref type="bibr" target="#b146">[147]</ref> (SRT) algorithm speculates a quotient bit based on a few MSBs of the divisor and the partial remainder. In an SRT divider, therefore, the bit width of the subtractors is smaller than that in an array divider, thus resulting in a faster operation. The performance can be further improved by using a high-radix divider that generates several quotient bits rather than one at each iteration <ref type="bibr" target="#b147">[148]</ref>. The quotient in an SRT division is usually in a redundant form, so an on-the-fly conversion algorithm <ref type="bibr" target="#b148">[149]</ref> is required to convert the quotient into a nonredundant representation. Notably, the performance of these dividers is improved by trading off circuit area and power consumption.</p><p>Several iterative algorithms, including the Newton-Raphson <ref type="bibr" target="#b9">[10]</ref> and Goldschmidt <ref type="bibr" target="#b8">[9]</ref> algorithms, have been developed for large division using multiplication and addition. The performance of this type of dividers is significantly affected by the presumed initial parameter values. Several approximate subtractor/adder cells have recently been proposed for an array divider <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b149">[150]</ref>- <ref type="bibr" target="#b151">[152]</ref>. Another type of approximate dividers uses a reduced-width exact divider for large division <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b152">[153]</ref>, while several others are based on functional approximation (e.g., using a logarithmic algorithm) <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b153">[154]</ref>- <ref type="bibr" target="#b155">[156]</ref> and curve fitting <ref type="bibr" target="#b156">[157]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Review</head><p>1) Approximation in Subtractor/Adder Cells: In <ref type="bibr" target="#b30">[31]</ref>, three approximate subtractors obtained by simplifying the circuit of an exact cell are used for processing some LSBs in a vertical, horizontal, square, or triangle region in an array divider. This design is referred to as an approximate unsigned nonrestoring divider (AXDnr). Compared to the AXDnrs, similarly designed approximate restoring dividers (AXDrs) show better tradeoffs with slightly higher accuracy and lower power dissipation <ref type="bibr" target="#b149">[150]</ref>.</p><p>In <ref type="bibr" target="#b150">[151]</ref>, an approximate signed-digit adder is proposed for use in high-radix dividers, together with replacement, truncation, and error compensation in an array structure. For an array divider, a high-radix design can be faster but consumes more power compared to a radix-2 design <ref type="bibr" target="#b151">[152]</ref>.</p><p>2) Using a Reduced-Width Exact Divider: A dynamic approximate divider (DAXD) selects the inputs and uses a reduced-width restoring array divider <ref type="bibr" target="#b152">[153]</ref>, in a way similar to the design of DRUM <ref type="bibr" target="#b119">[120]</ref>. This selection scheme could lead to overflows that cause a low accuracy in division. To implement a DAXD, two leading-1 detectors, two multiplexers, a reduced-width array divider, a subtractor, and a barrel shifter are needed.</p><p>Depending on the positions of the leading "1"s, an adaptively approximate divider (AAXD) employs two pruning schemes to determine the inputs for a reduced-width exact divider <ref type="bibr" target="#b38">[39]</ref>. Different from the DAXD, zeros are appended to the LSBs for selecting k input bits when the leading "1" is within the k LSBs. In addition, an error-correction unit is used to ensure a high accuracy with a very low maximum ED.</p><p>3) Approximate Dividers Based on Functional Approximation: In the high-speed and energy-efficient approximate divider (SEERAD) <ref type="bibr" target="#b153">[154]</ref>, the division is implemented by a simple multiplication by rounding the divisor B to a form of 2 K +L /D, where K indicates the leading "1" position of B, and L and D are constant integers estimated via an exhaustive simulation for achieving the lowest mean relative error. For a division of A/B, it is then sufficient to use a multiplier for computing AD, a barrel shifter, and some lookup tables for storing L and D. Different accuracy levels are obtained by varying D and L.</p><p>A binary logarithm-based functional approximation performs division by computing the antilogarithm of the difference between the logarithmic values of the dividend A given by <ref type="bibr" target="#b4">(5)</ref>, and divisor B given by <ref type="bibr" target="#b5">(6)</ref>. It leads to</p><formula xml:id="formula_20">log 2 Q = log 2 (A/B) ≈ k 1 -k 2 + x 1 -x 2<label>(11)</label></formula><p>where k 1 and k 2 specify the leading one positions of A and B, respectively,</p><formula xml:id="formula_21">x 1 = A/2 k 1 -1, and x 2 = B/2 k 2 -1.</formula><p>Using Mitchell's algorithm, an approximate division can be implemented by performing the antilogarithm of <ref type="bibr" target="#b10">(11)</ref>, that is</p><formula xml:id="formula_22">Q ≈ 2 k 1 -k 2 (x 1 -x 2 + 1), if x 1 -x 2 ≥ 0 2 k 1 -k 2 -1 (x 1 -x 2 + 2), if x 1 -x 2 &lt; 0. (<label>12</label></formula><formula xml:id="formula_23">)</formula><p>Error correction is considered in <ref type="bibr" target="#b32">[33]</ref> to compensate an offset to the computed quotient. Additionally, a number of LSBs are truncated in the subtractors for implementing <ref type="bibr" target="#b11">(12)</ref>. These techniques enable the design of approximate integer and floating-point dividers with near-zero error bias, denoted as INZeD and FaNZeD, respectively. In a high-speed divider (HSD) <ref type="bibr" target="#b29">[30]</ref>, a piecewise linear approximation is utilized to implement the antilogarithm directly on the two input operands, thus only lookup tables and multiplications are required. Compared to a divider implemented using Mitchell's algorithm, the HSD is more accurate and faster with a larger area.</p><p>An approximate hybrid divider (AXHD) is based on a restoring array structure and logarithmic approximation <ref type="bibr" target="#b154">[155]</ref>. In this design, the p MSBs in a 2n/n divider is accurately implemented as a restoring array divider, while the (2np) LSBs are approximately processed using Mitchell's algorithm as per <ref type="bibr" target="#b11">(12)</ref>.</p><p>In <ref type="bibr" target="#b155">[156]</ref>, the mantissa in floating-point division is approximately computed by a subtractor; the approximation is then tuned by using an error compensation lookup table (storing precomputed values) and a subtractor. This design is denoted as the configurable approximate divider for energy efficiency (CADE) as its accuracy varies with the size of the lookup table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4) Curve Fitting-Based Approximate Dividers:</head><p>In the design of a floating-point divider, the curved surfaces of the quotient are partitioned into several square or triangular regions that are linearly approximated by curve fitting <ref type="bibr" target="#b156">[157]</ref>. The mantissa division is then implemented by a comparison module, a lookup table, shifters, and adders. With a similar circuit structure to the HSD, this approximate divider achieves a higher accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Evaluation</head><p>In this evaluation, we consider approximate 16/8 unsigned integer dividers, including AXDr, DAXD, AAXD, SEERAD, and INZeD. The high-radix and floatingpoint dividers are not considered. Three designs of AXDr with the triangle replacement (that shows the best tradeoff <ref type="bibr" target="#b149">[150]</ref>) are selected for evaluation, i.e., AXDr1, AXDr2, and AXDr3 using three different approximate subtractors. For DAXD and AAXD, the reduced-width exact dividers are implemented using an array structure. An exhaustive simulation is performed for the error evaluation, that is, all valid combinations in the range of [0, 65535] and (0, 255] that do not cause overflow in an accurate 16/8 divider, are used as the input dividends and divisors. The same tools, technologies, and configurations as for the evaluation of adders and multipliers are applied here. The clock period for the power estimation is set to 5 ns. As MRED and NMED show a similar pattern in the simulation results, only MRED is plotted in Fig. <ref type="figure" target="#fig_14">19(a</ref>) and (b), respectively, against which the optimized delay and power consumption for area-optimized synthesis are shown. Fig. <ref type="figure" target="#fig_15">20</ref> presents the comparison in PDP versus MRED for both delay-and area-optimized syntheses.</p><p>1) Hardware Versus Accuracy: As can be seen in Fig. <ref type="figure" target="#fig_14">19</ref>, AXDr1 and AXDr3 can be very accurate with a moderate power consumption, but quite slow, whereas DAXD is the least accurate in general. For a medium-low MRED, AAXD, and INZeD show the highest performance and the lowest power consumption; thus, they achieve the best accuracyhardware tradeoff. This is also evident in the PDP and MRED figure in Fig. <ref type="figure" target="#fig_15">20</ref>. SEERAD is the fastest at a low accuracy (see Fig. <ref type="figure" target="#fig_14">19</ref>) and with the lowest PDP for delayoptimized synthesis (see Fig. <ref type="figure" target="#fig_15">20</ref>).</p><p>In summary, AAXD is an efficient design for applications that require a high accuracy and high performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROCEEDINGS OF THE IEEE 17</head><p>Authorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply.</p><p>This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.  Although some configurations of AXDr1 and AXDr3 are very accurate, they are generally slow with high energy consumption. INZeD is the most efficient design for a moderate accuracy. For an application that can tolerate a high level of inaccuracies, SEERAD-1 is suitable with a low hardware cost. A qualitative summary of these features is shown in Table <ref type="table" target="#tab_2">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. A P P L I C A T I O N S A. Image Processing</head><p>To assess the capabilities of the approximate designs, we consider three image-processing applications: image sharpening using unsigned multipliers and adders, image compression using signed multipliers and adders, and change detection using unsigned dividers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Image Sharpening:</head><p>This technique enhances the edges in an image to obtain a clearer view. An image with a pixel matrix I is sharpened by using R(x, y) = 2I(x, y) -S(x, y) <ref type="bibr" target="#b157">[158]</ref>, where R(x, y) is a resultant image pixel, and S(x, y) is obtained by a convolution</p><formula xml:id="formula_24">S(x, y) = 1 273 2 m=-2 2 n=-2 G(m + 3, n + 3)I(x -m, y -n) (13)</formula><p>where G is a 5 × 5 convolution matrix given by </p><formula xml:id="formula_25">G = ⎡ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎣ 1 4<label>7</label></formula><formula xml:id="formula_26">⎤ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎦ . (<label>14</label></formula><formula xml:id="formula_27">)</formula><p>Equation <ref type="bibr" target="#b12">(13)</ref> shows that 25 multiplications, 24 additions, and a division are required for computing S(x, y). In this simulation, the inputs are normalized by the maximum numbers and scaled to a number in 16-bit unsigned integer representation, so 16 × 16 approximate unsigned multipliers and 16-bit approximate adders are used to implement the sum of products in <ref type="bibr" target="#b12">(13)</ref>. Note that the 32-bit products are rounded to 16 bits as inputs to the adders. The division by 273 is implemented by a multiplication of a constant input 1/273.</p><p>Among the approximate adders and multipliers in each category, one or two designs with the best accuracy and energy tradeoffs are selected for this application. Hence, ACA, GeAr, ETAII, CCBA, LOA, and TruA are considered for addition; UDM, BAM, DRUM, HOCM, TAM1, ICM, ALM-SOA, CGPM3, and TruMW are selected for multiplication. The configurations that lead to similar PDPs compared to other designs are considered for designs with variable parameters.</p><p>Fig. <ref type="figure" target="#fig_16">21</ref> shows the PSNRs of the sharpened images, which are infinite for the combinations of the AccuA and AccuM, and AccuA and ICM. The input image is a blurred "Lena" with 512 × 512 pixels. Because ICM has a very low ER (5.45%), and the error seldom occurs in this application, the ICM is as effective as AccuM for image sharpening.</p><p>This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination. For the same reason, the images sharpened by using the UDM have very close PSNRs to the ones processed by an AccuM. These results illustrate the advantages of designs with low ERs in certain applications.</p><p>Although DRUM-7 and DRUM-6 show larger values of MRED and NMED than the other designs, they lead to higher PSNRs due to their unbiased errors. Also, HOCM results in images with a higher quality than many other multipliers, when used with the same adder. With a larger MRED and NMED, the performance of ALM-SOA is similar to BAM-16 and TAM1-16, because BAM and TAM1 generate single-sided errors that can be accumulated in the sum of products.</p><p>When an approximate adder (or multiplier) has a very low accuracy (e.g., BAM-18, TruM-4, ACA-6, GeAr-R4P4, and ETAII-4), increasing the accuracy of the collaborating multiplier (or adder) does not improve the quality of the processed image. It is worth noting that using some combinations of approximate adders and multipliers can lead to a higher image quality than using solely an approximate adder or an approximate multiplier. For example, the use of LOA-7 and BAM-16 results in an image with a higher PSNR than BAM-16 and AccuA, and the combination of CCBA-3 and DRUM-6 outperforms the duo of CCBA-3 and AccuM.</p><p>The circuit designs for image sharpening are synthesized for the optimized area (the same for the other applications). The clock period for the power estimation is 10 ns. In the simulation, the CLA and Wallace multiplier are utilized for the AccuA and AccuM, respectively. Fig. <ref type="figure" target="#fig_17">22(a)</ref> shows that the implementations using TAM1-16 are the fastest, followed by HOCM, whereas the ones using DRUM-6 are the slowest, followed by ICM. The delay values are not as consistent as the area results for different adder and multiplier combinations because the syntheses are optimized for area.</p><p>As shown in Fig. <ref type="figure" target="#fig_17">22</ref>(b) and (c), using different adder designs does not significantly affect the area or power dissipation when a specific multiplier is used. Thus, the multiplier dominates the area and power dissipation for this application. On the contrary, the adder plays a more significant role on the critical path delay, as shown in Fig. <ref type="figure" target="#fig_17">22(a)</ref>, because the 25 multipliers work in parallel, whereas the 24 adders work in a tree structure, resulting in a critical path of one multiplier and five adders. Among the multipliers, ALM-SOA and TAM1-16 are very energyefficient, as shown in the PDP values in Fig. <ref type="figure" target="#fig_17">22(d)</ref>.</p><p>Fig. <ref type="figure" target="#fig_18">23</ref> shows the comparison of PDP reductions of different implementations compared with the accurate This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination. design, in the descending order of PSNRs larger than 30 dB. For an implementation that produces sharpened images with a PSNR higher than 35 dB, ETAII-6 and HOCM lead to the most significant saving in PDP (by about 50%). For a PSNR between 30 and 35 dB, LOA-9 and ALM-SOA are the most efficient with 69% reduction in PDP. DRUM-6 achieves the largest reductions in PDP for a high image quality (with a PSNR larger than 40 dB), whereas ALM-SOA is the most efficient for a relatively low image quality (with a PSNR lower than 35 dB).</p><p>2) JPEG Compression: Based on the discrete cosine transform (DCT), JPEG is a widely used lossy compression algorithm for digital images <ref type="bibr" target="#b158">[159]</ref>. The image pixels in the spatial domain are first converted into the frequency domain via a DCT. In the DCT, the pixel matrix of an image in 16-bit two's complement is divided into 8 × 8 blocks. Each block B is converted to the frequency domain by</p><formula xml:id="formula_28">D = TBT' (<label>15</label></formula><formula xml:id="formula_29">)</formula><p>where T is an 8 × 8 DCT coefficient matrix given by</p><formula xml:id="formula_30">T(x, y) = ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ 1 √ 8 , if x = 0 1 2 cos (2y + 1)xπ 16 , if x &gt; 0<label>(16)</label></formula><p>where x = 0, 1, . . . , 7 and y = 0, 1, . . . , 7.</p><p>The high-frequency information is then discarded by the quantization</p><formula xml:id="formula_31">C(x, y) = round D(x, y) Q(x, y) (<label>17</label></formula><formula xml:id="formula_32">)</formula><p>where Q is a quantization matrix of unsigned integers determined by the required quality level. The quality level can be from 1 to 100, where 1 corresponds to the highest compression ratio and thus the poorest image quality.</p><p>To reconstruct the image, the above operations are inverted by dequantization and inverse DCT (IDCT)</p><formula xml:id="formula_33">R(x, y) = C(x, y) × Q(x, y)<label>(18)</label></formula><p>and</p><formula xml:id="formula_34">I = T'RT. (<label>19</label></formula><formula xml:id="formula_35">)</formula><p>In this simulation, the signed coefficients in matrix T are scaled to 16-bit two's complement format, and the image pixels are normalized by the maximum number followed by a subtraction of 0.5 and scaled to 16-bit two's complement format. The signed multiplications in the DCT and IDCT are implemented by approximate Booth multipliers, including the 16 × 16 designs with good tradeoffs in accuracy and hardware, BM07, PEBM, ABM2, BBM, and TBM. The same 16-bit adder designs as in the image sharpening are used. The quality level for the compression is 50.</p><p>This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination. The qualities of the decompressed images using different adder and multiplier combinations are shown in Fig. <ref type="figure" target="#fig_19">24</ref>. As can be seen, ACA, GeAr, and ETAII are not suitable for this application although they have very low ERs. Note that the errors of these approximate adders are single-sided (or negative) due to the dropping of some carry bits; thus, the error biases for these types of adders are very large <ref type="bibr" target="#b50">[51]</ref>. As a result, errors are accumulated in the multiple matrix multiplications and cannot be tolerated in DCT or IDCT. Similarly, BBM has a larger error bias than the other approximate Booth multipliers due to the truncation of the PPs. Thus, the use of BBM also produces images with a low quality in most cases. Among the approximate adders, LOA-3 performs the best, followed by TruA-1, while for the approximate multipliers, BM07, PEBM, and TBM-2 outperform the other designs when the same adder is used.</p><p>It is worth noting that using some approximate Booth multipliers along with some approximate adders, e.g., PEBM and TruA-1, PEBM and TruA-2, generate a significantly higher quality than the other designs (even when an AccuM is used). Except for these special cases, the image quality in PSNRs increases with the decrease in the MREDs of the utilized approximate Booth multipliers.</p><p>Additionally, the results in Fig. <ref type="figure" target="#fig_19">24</ref> shows that a more complex computation involving multiple matrix multiplications is more sensitive to errors in addition than those in multiplication with the same bit width. Thus, a larger approximation can be tolerated in multiplication than in addition. The tolerable approximation in addition is to a lesser extent in JPEG compression than in image sharpening for an acceptable accuracy, e.g., LOA-3 is required for JPEG compression while LOA-8 is sufficient for image sharpening.</p><p>Fig. <ref type="figure" target="#fig_20">25</ref> shows the resulting PDP reductions of the DCT implementations using different multiplier and adder combinations compared with the accurate design. The clock period used for the power estimation is 10 ns. The accurate DCT design utilizes a 16-bit post-truncated fixedwidth Booth multiplier and a 16-bit CLA. As shown in Fig. <ref type="figure" target="#fig_20">25</ref>, a combination of AccuA and PEBM shows the best tradeoff in this implementation, achieving the highest PDP reduction (about 20%) with a relatively high PSNR (nearly 30 dB). Using an approximate adder with PEBM rather significantly degrades the image quality. Among the approximate Booth multipliers, PEBM, TBM-3, and ABM2 lead to higher energy efficiency than the other designs for this application.</p><p>3) Change Detection: The changes in two images can be detected by finding the ratios between the corresponding pixels. Thus, change detection can be used to assess the approximate dividers. In each design, one configuration is selected to ensure that a similar PDP (e.g., AXDr1-11, AXDr2-11, AXDr3-11, DAXD-8, AAXD-8, SEERAD-1, and INZeD-2), or MRED (e.g., AXDr1-9, AXDr2-8, AXDr3-10, DAXD-12, AAXD-10, SEERAD-4, and INZeD-0) occurs for the considered designs. The 16/8 unsigned integer dividers are utilized to obtain the pixel ratios. As shown in Table <ref type="table" target="#tab_4">5</ref>, AXDr1-9, AXDr3-10, AXDr3-11, AAXD-10, INZeD-0, INZeD-2, and SEERAD-4 perform similarly well as an accurate divider, whereas AXDr2-11, DAXD-12, DAXD-8, and SEERAD-1 produce results with a lower quality. AXDr2-8 and AAXD-8 produce images that are acceptable for a visual inspection. As the implementation of change detection mainly consists of dividers, the circuit measurements are similar to those for approximate dividers; thus, they are not shown here. Fig. <ref type="figure" target="#fig_15">20</ref> shows that </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROCEEDINGS OF THE IEEE 21</head><p>Authorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply.  to achieve a result with a PSNR higher than 33 dB, INZeD-2 consumes the smallest energy followed by INZeD-0 and AAXD-10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Deep Neural Networks</head><p>Face detection and alignment are two common tasks in machine learning. Using DNNs, the accuracy of face detection and alignment have been significantly improved since the early 2010s. Due to the correlation of these two tasks, a multitask CNN (MTCNN) has been proposed for joint face detection and alignment <ref type="bibr" target="#b159">[160]</ref>. An accelerator specifically designed for this MTCNN achieves a high energy efficiency and throughput <ref type="bibr" target="#b160">[161]</ref>. In this MTCNN, three CNNs cascade as the proposal network (P-Net), the refine network (R-Net), and the output network (O-Net). The basic operation in a CNN is the convolution based on multiplications and additions.</p><p>To assess the viability of approximate circuits in DNNs, the 16 × 16 approximate Booth multipliers and 16-bit adders are integrated into the architecture of an MTCNN for face detection and alignment, as shown in Fig. <ref type="figure" target="#fig_21">26</ref>. Here, the convolutional (CONV) layers account for the most computations. The max pooling is used for all pooling layers. Two fully connected (FC) layers to the end of the R-Net and are implemented by vector multiplications. The approximate Booth multipliers with good tradeoffs in accuracy and hardware, as those used in the JPEG compression, are considered in this application. One approximate adder with single-sided errors (i.e., ETAII), one with a small error bias (i.e., LOA), and the TruA are selected for additions.</p><p>Fig. <ref type="figure" target="#fig_22">27</ref> shows some face detection (in the bottom row) and face alignment (in the top row) results using different adders and multipliers. For the face detection, a square is drawn to show the detected area. To align a face, five landmarks are used to mark the eyes, nose, and mouth. Compared to the accurate implementation using AccuM and AccuA, BM07 and ETAII-7 perform poorly in face detection and alignment, as indicated by the squares and landmarks far away from the target positions, whereas BM07 and LOA-4 result in a better quality.</p><p>To quantitatively assess the accuracy of the face detection, the true positive rate (TPR) is measured for each implementation on the FDDB data set <ref type="bibr" target="#b161">[162]</ref>, as shown in Table <ref type="table" target="#tab_5">6</ref>. The TPRs in Table <ref type="table" target="#tab_5">6</ref> show that the approximate Booth multipliers (except for BBM), when working with LOA-3, LOA-4 and TruA-1, perform well in face detection, resulting in close TPRs to the accurate implementation. ETAII-7 leads to very small TPRs due to its large error bias. Similarly, TruA-2 (except for the combination with PEBM) and BBM (except for the combinations with LOA-3 and LOA-4) result in relatively low TPRs. Interestingly, ABM2 and TBM-4 working with the AccuA result in higher TPRs than the accurate design. Similar results have been observed in <ref type="bibr" target="#b46">[47]</ref>.</p><p>In addition, the number of MACs required to detect the faces in one image averaged over the FDDB data set is This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.   <ref type="table" target="#tab_6">7</ref> as an indicator for energy efficiency. Overall, ABM2 and LOA-3, AccuM and TruA-1, BM07 and TruA-1, PEBM and TruA-1, and PEBM and TruA-2, are effective combinations for face detection, which result in high TPRs and require a smaller number of MACs (thus, a higher energy efficiency) than the accurate implementation. Hence, the energy efficiency of a DNN can be improved by using approximate arithmetic circuits while achieving a similar or even higher detection accuracy.</p><p>Finally, the normalized mean errors (NMEs) for the face alignment are obtained by comparing the coordinate values of the five landmarks with their standard values for the AFLW data set <ref type="bibr" target="#b162">[163]</ref>, as shown in Table <ref type="table" target="#tab_7">8</ref>. The combinations of designs that result in small TPRs are omitted. It is interesting that the MTCNNs using LOA-3 and LOA-4 consistently achieve smaller NMEs than those using AccuAs. Although TruA-1 performs well in face detection, it results in large NMEs in face alignment, LOA-3 performs the best among the approximate adders. Among the approximate multipliers, BM07 and PEBM are effective designs producing smaller NMEs than the accurate design. Note that the approximate adders and multipliers that result in low accuracy in face detection and alignment (BBM, ETAII-7, TruA-1, and TruA-2) share the same feature, single-sided errors. Similar to the JPEG compression, the face detection and alignment are more sensitive to errors in additions than in multiplications (with the same bit width), so a deeper approximation can be tolerated in approximate multipliers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. C O N C L U S I O N , C H A L L E N G E S , A N D P R O S P E C T S</head><p>In this article, approximate arithmetic circuits are reviewed, characterized, and comparatively evaluated, using functional simulation, circuit synthesis optimized for performance and area, and image processing and machine learning applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Characterization</head><p>1) Approximate Adders: Most of the approximate adders have been designed for high performance and low error (in ER) by reducing the critical path delay. Most speculative adders, segmented adders, and carry-select adders show low ERs. Due to the reduction of some carries, singlesided errors are prevalent in these designs that result in large error biases, especially in applications that require iterative or repetitive additions. However, the designs using approximate FAs in the LSBs often have high ERs, low MREDs, and low power dissipation. With a reduced precision, a TruA produces a biased error with a high ER close to 100%, but it consumes a very low power. Considering practically effective error and circuit metrics, such as MRED and PDP, LOA, CCBA, and the TruAs, achieve the best accuracy-energy tradeoffs.</p><p>2) Approximate Multipliers: For unsigned designs, truncating part of the PPs or some LSBs of the input operands is an effective scheme to reduce circuit area, while preserving a moderate and variable accuracy in terms of NMED and MRED, depending on the number of bits truncated; examples include the BAM, TAM1, and, even, the TruMs. LMs are relatively inaccurate, but they can be very efficient in performance and power consumption. The truncated Wallace multiplier, compressor-based HOCM and TAM1 are among the designs with a high performance, while the truncated array multiplier is more power efficient at a moderate accuracy. The CGPMs can be very accurate with a moderate performance. TAM1, HOCM, and the logarithmic design ALM-SOA show the best tradeoffs between energy and accuracy. For signed multipliers, most fixed-width Booth multipliers provide a better design tradeoff than the TBMs due to the efficient error compensation.</p><p>3) Approximate Dividers: For the fewer divider designs, those approximated in the subtractor/adder cells are slow, and their accuracy varies with the approximate subtractor/adder design. The dividers based on functional approximation are relatively fast. Among the considered designs, the logarithmic INZeD and inputadaptive AAXD provide balanced tradeoffs with both low PDPs and MREDs.</p><p>The above observations are based on the investigation of 16-bit designs, so the circuit and error characteristics may vary for adders of different sizes, although some adders are based on regular structures. Multipliers and dividers of different sizes may exhibit more significantly different characteristics as some designs are tailored and optimized for a specific bit-width; thus, the performance may degrade even though the approximation scheme is scalable.</p><p>In general, rather limited improvements in circuit measurements are observed for the approximate arithmetic circuits simplified from an accurate design. Many ad hoc designs underperform simply truncated circuits. A functional approximation algorithm such as the binary logarithm can lead to designs with significant savings in circuit area and power consumption, albeit at the cost of a low accuracy. With the potential of breaking away from the original (limiting) architecture, nevertheless, functional approximation might be promising for hardware-efficient approximate arithmetic circuits, though leaving the challenge of enhancing its accuracy with low hardware overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Applications</head><p>For image processing, the approximate adders, multipliers, and dividers with smaller error magnitudes (in MREDs) generally produce results with a higher quality. For simple operations such as the sum of products, the approximate multipliers with lower ERs outperform those with higher ERs. Although with very low ERs, the approximate adders with large error biases (e.g., ACA, ETAII, and TruA) do not work well for more complex computations such as cascaded matrix multiplications. In an accumulative operation, the approximate designs with low error biases or double-sided errors consistently perform better than those with single-sided errors.</p><p>The more complex computation that involves multiple matrix multiplications is more vulnerable to errors in addition than those in multiplication. In other words, a larger approximation can be tolerated in multipliers than in adders to achieve a reasonably accurate result. In such applications, the multiplier dominates the area and power dissipation of the circuit, whereas more adders are in the critical path, so the adder plays a more important role on the delay.</p><p>By using approximate adders and multipliers, an MTCNN can achieve a comparable face detection quality to the accurate design. The accuracy of the face detection generally decreases with the increase of the MREDs for the approximate multipliers, so the MRED is an indicator of the quality of an approximate multiplier. For this more complex application, the approximate adders and multipliers with large error biases result in significantly poor accuracy in face detection and alignment. Compared to the accurate design, a smaller number of MACs is required for face detection when some approximate designs are used in an MTCNN. Hence, the use of approximate arithmetic circuits can reduce the power consumption and improve the energy efficiency of an MTCNN.</p><p>Interestingly, some combinations of approximate multipliers and adders lead to higher accuracy than the accurate implementation, even though these circuits, by themselves, do not show advantages over the others. Hence, it might be more effective to design approximate arithmetic circuits from a system's or application's perspective. A rigorous evaluation framework with trustworthy error metrics would be imperative to ensure the reliability and robustness of the system with respect to the effect due to the propagation and statistical distributions of errors. Approximate arithmetic circuits could also be integrated with other approximate components in a system hierarchy, such as memory and interconnects, for a more significant improvement in hardware efficiency as well as processing quality.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Approximate speculative adder.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Basic structure of a segmented adder. a i,h-1:0 and b i,h-1:0 are the h-bit inputs for the segment i. The inputs can beoverlapped between neighboring segments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Approximate carry-select adder with sum selection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. n-bit adder using AFAs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Power consumption versus accuracy for the area-optimized approximate 16-bit adders using different error metrics. (a) Power (area-optimized) versus MRED. (b) Power (area-optimized) versus ER.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>JiangFig. 8 .</head><label>8</label><figDesc>Fig. 8. Comparison of PDP and MRED for the approximate 16-bit adders. (a) PDP (delay-optimized) versus MRED. (b) PDP (area-optimized)versus MRED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Basic arithmetic process of a 4 × 4 unsigned multiplication.•: an input, a PP, or an output bit; : an HA, an FA, or a 4:2 compressor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. 4 × 4 unsigned multiplier using a carry-save adder array.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Optimized delay versus accuracy for the approximate 16 × 16 unsigned multipliers using different error metrics. (a) Optimized delay versus MRED. (b) Optimized delay versus NMED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Power consumption versus accuracy in MRED and NMED for the area-optimized approximate 16 × 16 unsigned multipliers. (a) Power (area-optimized) versus MRED. (b) Power (area-optimized) versus NMED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Delay versus accuracy for the approximate 16 × 16 Booth multipliers. The number of truncated LSBs for TBM is from 2 to 6 from left to right. (a) Optimized delay versus MRED. (b) Optimized delay versus NMED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Power consumption versus accuracy for the approximate 16 × 16 multipliers. (a) Power (area-optimized) versus MRED. (b) Power (area-optimized) versus NMED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. Comparison of PDP and MRED for the approximate 16 × 16 Booth multipliers. (a) PDP (delay-optimized) versus MRED. (b) PDP (area-optimized) versus MRED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 18 . 7 i=0</head><label>187</label><figDesc>Fig. 18. 8/4 unsigned restoring array divider. A = È 7 i=0 a i 2 i and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 19 .</head><label>19</label><figDesc>Fig. 19. Optimized delay and power consumption versus MRED for the approximate 16/8 unsigned integer dividers. (a) Delay (delay-optimized) versus MRED. (b) Power (area-optimized) versus MRED. Note: The replacement depths of AXDr1, AXDr2, and AXDr3 are from 8 to 11 from left to right. The accuracy levels of SEERAD are from 4 down to 1 from left to right. The dividend width after pruning is from 12 down to 8 with a decrement of 2 for DAXD and AAXD from left to right. In INZeD, the number of LSBs truncated in the subtractor is 0, 2, 3, and 4, from left to right.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>JiangFig. 20 .</head><label>20</label><figDesc>Fig. 20. Comparison of the PDP and MRED for the approximate 16/8 unsigned integer dividers. (a) PDP (delay-optimized) versus MRED. (b) PDP (area-optimized) versus MRED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>JiangFig. 21 .</head><label>21</label><figDesc>Fig. 21. PSNR comparison of image sharpening results. Note: AccuA and AccuM denote the accurate adder and multiplier, respectively. The numerical value the name of each design indicates the parameter value. The design 1StepTrunc is considered for HOCM; the configuration of 280 is selected for CGPM3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 22 .</head><label>22</label><figDesc>Fig. 22. Circuit measurements of image sharpening. (a) Delay. (b) Area. (c) Power. (d) PDP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>JiangFig. 23 .</head><label>23</label><figDesc>Fig. 23. Comparison of PDPs in the descending order of PSNRs for various adder-multiplier implementations of image sharpening.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>JiangFig. 24 .</head><label>24</label><figDesc>Fig. 24. Comparison of JPEG compression and decompression quality using different adder and multiplier designs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. 25 .</head><label>25</label><figDesc>Fig. 25. Comparison of PDPs in the descending order of PSNRs forDCT implementations using different adder and multiplier designs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Fig. 26 .</head><label>26</label><figDesc>Fig. 26. Architecture of the implemented MTCNN.</figDesc><graphic coords="22,54.22,186.94,467.33,137.57" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>JiangFig. 27 .</head><label>27</label><figDesc>Fig. 27. Some face detection (at bottom) and alignment (on top) results using different adders and multipliers. (a) AccuM and AccuA. (b) BM07 and ETAII-7. (c) BM07 and LOA-4. (d) TBM-4 and TruA-1.</figDesc><graphic coords="23,94.30,124.06,92.45,60.29" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Summary of Approximate Adders</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3</head><label>3</label><figDesc>Summary of the Approximate Booth Multipliers</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 4</head><label>4</label><figDesc>Summary of Approximate 16/8 Unsigned Integer Divider Designs</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5</head><label>5</label><figDesc>Change Detection Results Using Different Dividers</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6</head><label>6</label><figDesc>TPRs of the Face Detection on FDDB Data Set (%). The Values Higher Than 90% are Highlighted in Bold, and the Ones Larger Than That of the Accurate Design are in Red</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 7</head><label>7</label><figDesc>Number of MACs Required to Detect the Faces in One Image Averaged Over the FDDB Data Set (in Billions). The Numbers Smaller Than That of the Accurate Design are in Bold reported in Table</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 8</head><label>8</label><figDesc>NMEs for the Face Alignment on AFLW Data Set (%). The Errors Smaller Than That of the Accurate Design are Highlighted in Bold</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>PROCEEDINGS OF THE IEEEAuthorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>PROCEEDINGS OF THE IEEEAuthorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Authorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by the China Postdoctoral Science Foundation under Grant 2019M650679, the National Natural Science Foundation of China (Grant No. 61834002), the National Key R&amp;D Program of China (Grant No. 2018YFB2202101), the National Science and Technology Major Project of the Ministry of Science and Technology of China (Grant No. 2018ZX01027101-002), the National Council of Science and Technology (CONACYT) and Mexican Foundation for Education, Technology and Science (FUNED) and the Natural Sciences and Engineering Research Council (NSERC) of Canada under Project RES0025211.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Authorized licensed use limited to: Cornell University Library. Downloaded on August 20,2020 at 13:33:13 UTC from IEEE Xplore. Restrictions apply.</p><p>This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A B O U T T H E A U T H O R S</head><note type="other">Honglan</note></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Approximate computing: An emerging paradigm for energy-efficient design</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Orshansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ETS</title>
		<meeting>ETS</meeting>
		<imprint>
			<date type="published" when="2013-05">May 2013</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cramming more components onto integrated circuits</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronics</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page">114</biblScope>
			<date type="published" when="1965-04">Apr. 1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Toward dark silicon in servers</title>
		<author>
			<persName><forename type="first">N</forename><surname>Hardavellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="6" to="15" />
			<date type="published" when="2011-07">Jul. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Dark silicon and the end of multicore scaling</title>
		<author>
			<persName><forename type="first">H</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Blem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>St</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Amant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sankaralingam</surname></persName>
		</author>
		<author>
			<persName><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISCA</title>
		<meeting>ISCA</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="365" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The EDA challenges in the dark silicon era: Temperature, reliability, and variability perspectives</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Henkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marculescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The promise and challenge of stochastic computing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Alaghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Design Integr. Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1515" to="1531" />
			<date type="published" when="2018-08">Aug. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Approximate computing and the quest for computing efficiency</title>
		<author>
			<persName><forename type="first">S</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page">120</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multiple-precision division</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rabinowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">98</biblScope>
			<date type="published" when="1961-02">Feb. 1961</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Applications of division by convergence</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Goldschmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ph.D. dissertation, Massachusetts Inst. Technol</title>
		<imprint>
			<date type="published" when="1964">1964</date>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On division by functional iteration</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Flynn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="702" to="706" />
			<date type="published" when="1970-08">Aug. 1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Computer multiplication and division using binary logarithms</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Electron. Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="512" to="517" />
			<date type="published" when="1962-08">Aug. 1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Single-precision multiplier with reduced circuit complexity for signal processing applications</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Lim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1333" to="1336" />
			<date type="published" when="1992-10">Oct. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Truncated multiplication with correction constant [for DSP]</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Schulte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">E</forename><surname>Swartzlander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Workshop VLSI Signal Process</title>
		<meeting>IEEE Workshop VLSI Signal ess</meeting>
		<imprint>
			<date type="published" when="1993-10">Oct. 1993</date>
			<biblScope unit="page" from="388" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Speeding up processing with approximation circuits</title>
		<author>
			<persName><forename type="first">S.-L</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="67" to="73" />
			<date type="published" when="2004-03">Mar. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Preliminary Discussion of the Logical Design of an Electronic Computing Instrument</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Burks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Goldstine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Von Neumann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1947">1947</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Variable latency speculative addition: A new paradigm for arithmetic circuit design</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brisk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ienne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2008-03">Mar. 2008</date>
			<biblScope unit="page" from="1250" to="1255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Enhanced low-power high-speed adder for error-tolerant application</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Yeo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISIC</title>
		<meeting>ISIC</meeting>
		<imprint>
			<date type="published" when="2010-11">Nov. 2010</date>
			<biblScope unit="page" from="69" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Bio-inspired imprecise computational blocks for efficient VLSI implementation of soft-computing applications</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Mahdiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ahmadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Fakhraie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="850" to="862" />
			<date type="published" when="2010-04">Apr. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Design of voltage-scalable meta-functions for approximate computing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Chippa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2011-03">Mar. 2011</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Low-power digital signal processing using approximate adders</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Design Integr. Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="124" to="137" />
			<date type="published" when="2013-01">Jan. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Low-power high-speed multiplier for error-tolerant application</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Y</forename><surname>Kyaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Yeo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EDSSC</title>
		<meeting>EDSSC</meeting>
		<imprint>
			<date type="published" when="2010-12">Dec. 2010</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Trading accuracy for power with an underdesigned multiplier architecture</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ercegovac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLSID</title>
		<meeting>VLSID</meeting>
		<imprint>
			<date type="published" when="2011-01">Jan. 2011</date>
			<biblScope unit="page" from="346" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Approximate logic synthesis for error tolerant applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="957" to="960" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">SALSA: Systematic logic synthesis of approximate circuits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kozhikkottu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="796" to="801" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Evolutionary approach to approximate digital circuits design</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sekanina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evol. Comput</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="432" to="444" />
			<date type="published" when="2015-06">Jun. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Design of power-efficient approximate multipliers for approximate artificial neural networks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Mrazek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Sarwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sekanina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Architecture support for disciplined approximate programming</title>
		<author>
			<persName><forename type="first">H</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="301" to="312" />
			<date type="published" when="2012-04">Apr. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Doppelgánger: A cache for approximate computing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Miguel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Albericio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Jerger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MICRO</title>
		<meeting>MICRO</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="50" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">EnerJ: Approximate data types for safe and general low-power computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dietl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fortuna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gnanapragasam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="164" to="174" />
			<date type="published" when="2011-06">Jun. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Non-iterative high speed division computation based on Mitchell logarithmic method</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y L</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Jong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISCAS</title>
		<meeting>ISCAS</meeting>
		<imprint>
			<date type="published" when="2013-05">May 2013</date>
			<biblScope unit="page" from="2219" to="2222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Design of approximate unsigned integer non-restoring divider for inexact computing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GLSVLSI</title>
		<meeting>GLSVLSI</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="51" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Adaptive approximation in arithmetic circuits: A low-power unsigned divider design</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2018-03">Mar. 2018</date>
			<biblScope unit="page" from="1411" to="1416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Approximate integer and floating-point dividers with near-zero error bias</title>
		<author>
			<persName><forename type="first">H</forename><surname>Saadat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Javaid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parameswaran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page">161</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Low-power approximate MAC unit</title>
		<author>
			<persName><forename type="first">D</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G M</forename><surname>Strollo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alioto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PRIME</title>
		<meeting>PRIME</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="81" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Fast compensative design approach for the approximate squaring function</title>
		<author>
			<persName><forename type="first">M.-H</forename><surname>Sheu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-H</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Solid-State Circuits</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="95" to="97" />
			<date type="published" when="2002-01">Jan. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Area-efficient fixed-width squarer with dynamic error-compensation circuit</title>
		<author>
			<persName><forename type="first">Y.-H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. II, Exp. Briefs</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="851" to="855" />
			<date type="published" when="2015-09">Sep. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Low-power approximate logarithmic squaring circuit design for DSP applications</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Cockburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<idno type="DOI">10.1109/TETC.2020.2989699</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Emerg. Topics Comput., early access</title>
		<imprint>
			<date type="published" when="2020-04-24">Apr. 24, 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Design of approximate booth squarer for error-tolerant computing</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Manikantta</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Vasantha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">B</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dwivedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1230" to="1241" />
			<date type="published" when="2020-05">May 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Low-power unsigned divider and square root circuit designs using adaptive approximation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1635" to="1646" />
			<date type="published" when="2019-11">Nov. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Algorithm and design of a fully parallel approximate coordinate rotation digital computer (CORDIC)</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Multi-Scale Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="139" to="151" />
			<date type="published" when="2017-07">Jul. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Energy-efficient recognition and mining processor using scalable effort design</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Chippa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jayakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CICC</title>
		<meeting>CICC</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">DianNao: A small-footprint high-throughput accelerator for ubiquitous machine-learning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="269" to="284" />
			<date type="published" when="2014-04">Apr. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Optimal design of JPEG hardware under the approximate computing paradigm</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">S</forename><surname>Snigdha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Sapatnekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">106</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Approximate DCT image compression using inexact computing</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A F</forename><surname>Almurib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="159" />
			<date type="published" when="2018-02">Feb. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Approximate on-the-fly coarse-grained reconfigurable acceleration for general-purpose applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Brandalero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C S</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Carro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">PX-CGRA: Polymorphic approximate coarse-grained reconfigurable architecture</title>
		<author>
			<persName><forename type="first">O</forename><surname>Akbari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pedram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="413" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Improving the accuracy and hardware efficiency of neural networks using approximate multipliers</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mrazek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Cockburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sekanina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="317" to="328" />
			<date type="published" when="2020-02">Feb. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A 56 Gb/s 7.7 mW/Gb/s PAM-4 wireline transceiver in 10 nm FinFET using MM-CDR-based ADC timing skew control and low-power DSP with approximate multiplier</title>
		<author>
			<persName><forename type="first">B.-J</forename><surname>Yoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">IEEE Int. Solid-State Circuits Conf. (ISSCC) Dig. Tech. Papers</title>
		<imprint>
			<biblScope unit="page" from="122" to="124" />
			<date type="published" when="2020-02">Feb. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">An analytical framework for evaluating the error characteristics of approximate adders</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1268" to="1281" />
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Low-power approximate unsigned multipliers with configurable error recovery</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="189" to="202" />
			<date type="published" when="2019-01">Jan. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A review, classification, and comparative evaluation of approximate arithmetic circuits</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM J. Emerg. Technol. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">34</biblScope>
			<date type="published" when="2017-08">Aug. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">ApproxANN: An approximate computing framework for artificial neural network</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="701" to="706" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Circuits, systems, and methods implementing approximations for logarithm, inverse logarithm, and reciprocal</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Allred</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">U.S. Patent</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="171" to="435" />
			<date type="published" when="2007-01-30">Jan. 30, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A low power high performance radix-4 approximate squaring circuit</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Datla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Thornton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Matula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ASAP</title>
		<meeting>ASAP</meeting>
		<imprint>
			<date type="published" when="2009-07">Jul. 2009</date>
			<biblScope unit="page" from="91" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Introduction to approximate computing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VTS</title>
		<meeting>VTS</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A retrospective and prospective view of approximate computing [Point of View]</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shulte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2020-03">Mar. 2020</date>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="394" to="399" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Characterizing approximate adders and multipliers optimized under different design constraints</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GLSVLSI</title>
		<meeting>GLSVLSI</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="393" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Computation error analysis in digital signal processing systems with overscaled supply voltage</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Parhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="517" to="526" />
			<date type="published" when="2010-04">Apr. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Design of voltage-scalable meta-functions for approximate computing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Chippa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Energy-efficient digital signal processing via voltage-overscaling-based residue number system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1322" to="1332" />
			<date type="published" when="2013-07">Jul. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Parameter variation tolerance and error resiliency: New design paradigm for the nanoscale era</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2010-10">Oct. 2010</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="1718" to="1751" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Scalable effort hardware design</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Chippa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2004" to="2016" />
			<date type="published" when="2014-09">Sep. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">High accuracy approximate multiplier with error correction</title>
		<author>
			<persName><forename type="first">C.-H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCD</title>
		<meeting>ICCD</meeting>
		<imprint>
			<date type="published" when="2013-10">Oct. 2013</date>
			<biblScope unit="page" from="33" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A hardware-efficient logarithmic multiplier with improved accuracy</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Cockburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="928" to="931" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Hybrid approximate multiplier architectures for improved power-accuracy trade-offs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Zervakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Xydis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tsoumanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pekmestzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISLPED</title>
		<meeting>ISLPED</meeting>
		<imprint>
			<date type="published" when="2015-07">Jul. 2015</date>
			<biblScope unit="page" from="79" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">New metrics for the reliability of approximate and probabilistic adders</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1760" to="1771" />
			<date type="published" when="2013-09">Sep. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">A methodology for energy-quality tradeoff using imprecise hardware</title>
		<author>
			<persName><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Robins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="504" to="509" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Modeling and synthesis of quality-energy optimal approximate adders</title>
		<author>
			<persName><forename type="first">J</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gerstlauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Orshansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="728" to="735" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">MACACO: Modeling and analysis of circuits for approximate computing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="667" to="673" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Probabilistic error modeling for approximate adders</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mazahir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hafiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="515" to="530" />
			<date type="published" when="2017-03">Mar. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Statistical error analysis for low power approximate adders</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Ayub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Formal probabilistic analysis of low latency approximate adders</title>
		<author>
			<persName><forename type="first">A</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Design Integr. Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="177" to="189" />
			<date type="published" when="2019-01">Jan. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">PEMACx: A probabilistic error analysis methodology for adders with cascaded approximate units</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hanif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hafiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title/>
		<ptr target="https://www.silvaco.com/products/nangate/Library_Design_Services/index.html" />
	</analytic>
	<monogr>
		<title level="j">Open Cell Library</title>
		<imprint>
			<date type="published" when="2019-09-20">Sep. 20, 2019</date>
			<publisher>Silvaco, Inc. Nangate</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">New generation of predictive technology model for sub-45 nm early design exploration</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Electron Devices</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2816" to="2823" />
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Towards aging-induced approximations</title>
		<author>
			<persName><forename type="first">H</forename><surname>Amrouch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Khaleghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gerstlauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Real-time learning capability of neural networks</title>
		<author>
			<persName><forename type="first">G.-B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q.-Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Siew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Neural Netw</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="863" to="878" />
			<date type="published" when="2006-07">Jul. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title/>
		<author>
			<persName><surname>Dc Ultra</surname></persName>
		</author>
		<author>
			<persName><surname>Synopsys</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
			<pubPlace>Mountain View, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Dual-quality 4:2 Compressors for utilizing in dynamic accuracy configurable multipliers</title>
		<author>
			<persName><forename type="first">O</forename><surname>Akbari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1352" to="1361" />
			<date type="published" when="2017-04">Apr. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">A majority-based imprecise multiplier for ultra-efficient approximate image multiplication</title>
		<author>
			<persName><forename type="first">F</forename><surname>Sabetzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Moaiyeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ahmadinejad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="4200" to="4208" />
			<date type="published" when="2019-11">Nov. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">A parallel algorithm for the efficient solution of a general class of recurrence equations</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Kogge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Stone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="786" to="793" />
			<date type="published" when="1973-08">Aug. 1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Parallel prefix computation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="831" to="838" />
			<date type="published" when="1980-10">Oct. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">High-speed binary adder</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. Res. Develop</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="156" to="166" />
			<date type="published" when="1981-03">Mar. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">A regular layout for parallel adders</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Brent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="260" to="264" />
			<date type="published" when="1982-03">Mar. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Fast area-efficient VLSI adders</title>
		<author>
			<persName><forename type="first">T</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Carlson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ARITH</title>
		<meeting>ARITH</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Carry-select adder</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">J</forename><surname>Bedrij</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Trans. Electron. Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="340" to="346" />
			<date type="published" when="1962-06">Jun. 1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">A way to build efficient carry-skip adders</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guyot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hochet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1144" to="1152" />
			<date type="published" when="1987-10">Oct. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Conditional-sum addition logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sklansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Electron. Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="226" to="231" />
			<date type="published" when="1960-06">Jun. 1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">A reduced-area scheme for carry-select adders</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tyagi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1163" to="1170" />
			<date type="published" when="1993-10">Oct. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<monogr>
		<title level="m" type="main">Digital Arithmetic</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ercegovac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Elsevier</publisher>
			<pubPlace>Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Accuracy-configurable adder for approximate arithmetic designs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="820" to="825" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Approximate adder with hybrid prediction and error compensation technique</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Qiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISVLSI</title>
		<meeting>ISVLSI</meeting>
		<imprint>
			<date type="published" when="2016-07">Jul. 2016</date>
			<biblScope unit="page" from="373" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">A low latency generic accuracy configurable adder</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hafiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">QuAd: Design and analysis of quality-area optimal low-latency approximate adders</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hanif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hafiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shafique</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2017-06">Jun. 2017</date>
			<biblScope unit="page">42</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">High performance reliable variable latency carry select addition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Varman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mohanram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2012-03">Mar. 2012</date>
			<biblScope unit="page" from="1257" to="1262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">An energy efficient approximate adder with carry skip for error resilient neuromorphic VLSI systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/ACM Int. Conf. Comput.-Aided Design (ICCAD)</title>
		<meeting>IEEE/ACM Int. Conf. Comput.-Aided Design (ICCAD)</meeting>
		<imprint>
			<date type="published" when="2013-11">Nov. 2013</date>
			<biblScope unit="page" from="130" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">On reconfiguration-oriented approximate adder design and its application</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="48" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">High-performance low-power carry speculative addition with variable latency</title>
		<author>
			<persName><forename type="first">I</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1591" to="1603" />
			<date type="published" when="2015-09">Sep. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">On error modeling and analysis of approximate adders</title>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2014-11">Nov. 2014</date>
			<biblScope unit="page" from="511" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">A new approximate adder with low relative error and correct sign calculation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1449" to="1454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Energy-efficient inexact speculative adder with high performance and accuracy control</title>
		<author>
			<persName><forename type="first">V</forename><surname>Camus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schlachter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Enz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISCAS</title>
		<meeting>ISCAS</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="45" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">A low-power carry cut-back approximate adder with fixed-point implementation and floating-point precision</title>
		<author>
			<persName><forename type="first">V</forename><surname>Camus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schlachter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Enz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">127</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Block-based carry speculative approximate adder for energy-efficient applications</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ebrahimi-Azandaryani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Akbari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. II, Exp. Briefs</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="137" to="141" />
			<date type="published" when="2019-01">Jan. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Approximate XOR/XNOR-based adders for inexact computing</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE-NANO</title>
		<meeting>IEEE-NANO</meeting>
		<imprint>
			<date type="published" when="2013-08">Aug. 2013</date>
			<biblScope unit="page" from="690" to="693" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Inexact designs for approximate low power addition by cell replacement</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A F</forename><surname>Almurib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="660" to="665" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Approximate reverse carry propagate adder for energy-efficient DSP applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pashaeifar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2530" to="2541" />
			<date type="published" when="2018-11">Nov. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Approximate computing in MOS/spintronic non-volatile full-adder</title>
		<author>
			<persName><forename type="first">H</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A B</forename><surname>Naviner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NANOARCH</title>
		<meeting>NANOARCH</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="203" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Majority-based spin-CMOS primitives for approximate computing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Angizi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Demara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Nanotechnol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="795" to="806" />
			<date type="published" when="2018-07">Jul. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">EvoApprox8b: Library of approximate adders and multipliers for circuit design and benchmarking of approximation methods</title>
		<author>
			<persName><forename type="first">V</forename><surname>Mrazek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hrbacek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sekanina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="258" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Behrooz</surname></persName>
		</author>
		<title level="m">Computer Arithmetic: Algorithms and Hardware Designs</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford Univ. Press</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">A suggestion for a fast multiplier</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jacobsohn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Electron. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">754</biblScope>
			<date type="published" when="1964-12">Dec. 1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">Some schemes for parallel multipliers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Dadda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Alta Frequenza</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="349" to="356" />
			<date type="published" when="1965-03">Mar. 1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<monogr>
		<title level="m" type="main">CMOS VLSI Design: A Circuits and Systems Perspective</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H E</forename><surname>Weste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>Pearson</publisher>
			<pubPlace>New Delhi, India</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">A signed binary multiplication technique</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Booth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Quart. J. Mech. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="236" to="240" />
			<date type="published" when="1951">1951</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">High-speed arithmetic in binary computers</title>
		<author>
			<persName><forename type="first">O</forename><surname>Macsorley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IRE</title>
		<meeting>IRE</meeting>
		<imprint>
			<date type="published" when="1961-01">Jan. 1961</date>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="67" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">A two&apos;s complement parallel array multiplication algorithm</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Baugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Wooley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1045" to="1047" />
			<date type="published" when="1973-12">Dec. 1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">A 70-MHz 8-bit×8-bit parallel pipelined multiplier in 2.5-μm CMOS</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hatamian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Cash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Solid-State Circuits</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="505" to="513" />
			<date type="published" when="1986-08">Aug. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">High-accuracy fixed-width modified booth multipliers for lossy applications</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-R</forename><surname>Kuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-C</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="52" to="60" />
			<date type="published" when="2011-01">Jan. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">Powerand area-efficient approximate wallace tree multiplier for error-resilient systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Mane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISQED</title>
		<meeting>ISQED</meeting>
		<imprint>
			<date type="published" when="2014-03">Mar. 2014</date>
			<biblScope unit="page" from="263" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">DRUM: A dynamic range unbiased multiplier for approximate applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="418" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">A low-power, high-performance approximate multiplier with configurable partial error recovery</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<analytic>
		<title level="a" type="main">High-speed area-efficient and power-aware multiplier design using approximate compressors along with bottom-up tree topology</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Jeong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPIE</title>
		<meeting>SPIE<address><addrLine>Art</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-03">Mar. 2013</date>
			<biblScope unit="volume">8784</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<analytic>
		<title level="a" type="main">Design and analysis of approximate compressors for multiplication</title>
		<author>
			<persName><forename type="first">A</forename><surname>Momeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="984" to="994" />
			<date type="published" when="2015-04">Apr. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">Design of power and area efficient approximate multipliers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatachalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-B</forename><surname>Ko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1782" to="1786" />
			<date type="published" when="2017-05">May 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">Low-power approximate multipliers using encoded partial products and approximate compressors</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Cockburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Emerg. Sel. Topics Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="404" to="416" />
			<date type="published" when="2018-09">Sep. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">Approximate multipliers based on new approximate compressors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G M</forename><surname>Strollo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">De</forename><surname>Caro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Petra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="4169" to="4182" />
			<date type="published" when="2018-12">Dec. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<analytic>
		<title level="a" type="main">Design and evaluation of approximate logarithmic multipliers for low power error-tolerant applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2856" to="2868" />
			<date type="published" when="2018-09">Sep. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications improved logarithmic multiplier for energy-efficient neural computing</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Cockburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><surname>Jiang</surname></persName>
		</author>
		<idno type="DOI">10.1109/TC.2020.2992113</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput., early access</title>
		<imprint>
			<date type="published" when="2020-05-06">May 6, 2020</date>
		</imprint>
	</monogr>
	<note>An This article has been accepted for inclusion in a future issue of this journal. Content is final as presented</note>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">REALM: Reduced-error approximate log-based integer multiplier</title>
		<author>
			<persName><forename type="first">H</forename><surname>Saadat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Javaid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ignjatovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parameswaran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2020-03">Mar. 2020</date>
			<biblScope unit="page" from="1366" to="1371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<analytic>
		<title level="a" type="main">A cost-efficient iterative truncated logarithmic multiplication for convolutional neural networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Del Barrio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bagherzadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ARITH</title>
		<meeting>ARITH</meeting>
		<imprint>
			<date type="published" when="2019-06">Jun. 2019</date>
			<biblScope unit="page" from="108" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">Scalable construction of approximate multipliers with formally guaranteed worst case error</title>
		<author>
			<persName><forename type="first">V</forename><surname>Mrazek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sekanina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2572" to="2576" />
			<date type="published" when="2018-11">Nov. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">Design-efficient approximate multiplication circuits through partial product perforation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Zervakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tsoumanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Xydis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pekmestzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="3105" to="3117" />
			<date type="published" when="2016-10">Oct. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">Energy-efficient approximate multiplication for digital signal processing and classification applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanamoorthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Moghaddam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1180" to="1184" />
			<date type="published" when="2015-06">Jun. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">Approximate signed binary integer multipliers for arithmetic data value speculation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Al-Sarawi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECSI</title>
		<meeting>ECSI</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="97" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">Design and analysis of approximate adders and multipliers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dept. Elect. Comput. Eng., Univ. Alberta</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<pubPlace>Edmonton, AB, Canada</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">M.S. thesis</note>
</biblStruct>

<biblStruct xml:id="b135">
	<analytic>
		<title level="a" type="main">Design of low-error fixed-width modified booth multiplier</title>
		<author>
			<persName><forename type="first">K.-J</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-G</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Parhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Very Large Scale Integr. (VLSI) Syst</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="522" to="531" />
			<date type="published" when="2004-05">May 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<analytic>
		<title level="a" type="main">Adaptive low-error fixed-width booth multipliers</title>
		<author>
			<persName><forename type="first">M.-A</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-D</forename><surname>Van</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-Y</forename><surname>Kuo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Trans. Fundamentals Electron., Commun. Comput. Sci</title>
		<imprint>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1180" to="1187" />
			<date type="published" when="2007-06">Jun. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<analytic>
		<title level="a" type="main">New approximate multiplier for low power digital signal processing</title>
		<author>
			<persName><forename type="first">F</forename><surname>Farshchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Abrishami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Fakhraie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CADS</title>
		<meeting>CADS</meeting>
		<imprint>
			<date type="published" when="2013-10">Oct. 2013</date>
			<biblScope unit="page" from="25" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">A high-accuracy adaptive conditional-probability estimator for fixed-width booth multipliers</title>
		<author>
			<persName><forename type="first">Y.-H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-Y</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="594" to="603" />
			<date type="published" when="2012-03">Mar. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<analytic>
		<title level="a" type="main">Design of approximate radix-4 booth multipliers for error-tolerant computing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1435" to="1441" />
			<date type="published" when="2017-08">Aug. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b140">
	<analytic>
		<title level="a" type="main">Array-based approximate arithmetic computing: A general model and applications to multiplier and squarer design</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1081" to="1090" />
			<date type="published" when="2015-04">Apr. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<analytic>
		<title level="a" type="main">Approximate radix-8 booth multipliers for low-power and high-performance operation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Qiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="2638" to="2644" />
			<date type="published" when="2016-08">Aug. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b142">
	<analytic>
		<title level="a" type="main">Design issues in division and other floating-point operations</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Oberman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Flynn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="154" to="161" />
			<date type="published" when="1997-02">Feb. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b143">
	<analytic>
		<title level="a" type="main">An augmented iterative array for high-speed binary division</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cappa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C</forename><surname>Hamacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="172" to="175" />
			<date type="published" when="1973-02">Feb. 1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
		<title level="a" type="main">Divider device for skipping a string of zeros or radix-minus-one digits</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Sweeney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">U.S. Patent</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="145" to="296" />
			<date type="published" when="1964-08-18">Aug. 18, 1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<analytic>
		<title level="a" type="main">A new class of digital division methods</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Robertson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Trans. Electron. Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="218" to="222" />
			<date type="published" when="1958-09">Sep. 1958</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b146">
	<analytic>
		<title level="a" type="main">Techniques of multiplication and division for automatic binary computers</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Tocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Quart. J. Mech. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="364" to="384" />
			<date type="published" when="1958">1958</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b147">
	<analytic>
		<title level="a" type="main">Power efficient division and square root unit</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nannarelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1059" to="1070" />
			<date type="published" when="2012-08">Aug. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b148">
	<analytic>
		<title level="a" type="main">On-the-fly conversion of redundant into conventional representations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ercegovac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="895" to="897" />
			<date type="published" when="1987-07">Jul. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b149">
	<analytic>
		<title level="a" type="main">On the design of approximate restoring dividers for error-tolerant applications</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="2522" to="2533" />
			<date type="published" when="2016-08">Aug. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b150">
	<analytic>
		<title level="a" type="main">Design of approximate high-radix dividers by inexact binary signed-digit addition</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GLSVLSI</title>
		<meeting>GLSVLSI</meeting>
		<imprint>
			<date type="published" when="2017-05">May 2017</date>
			<biblScope unit="page" from="293" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b151">
	<analytic>
		<title level="a" type="main">Design, evaluation and application of approximate high-radix dividers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Multi-Scale Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="299" to="312" />
			<date type="published" when="2018-07">Jul. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b152">
	<analytic>
		<title level="a" type="main">A low-power dynamic divider for approximate applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">105</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b153">
	<analytic>
		<title level="a" type="main">SEERAD: A high speed yet energy-efficient rounding-based approximate divider</title>
		<author>
			<persName><forename type="first">R</forename><surname>Zendegani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fayyazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Safari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1481" to="1484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b154">
	<analytic>
		<title level="a" type="main">Combining restoring array and logarithmic dividers into an approximate hybrid design</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ARITH</title>
		<meeting>ARITH</meeting>
		<imprint>
			<date type="published" when="2018-06">Jun. 2018</date>
			<biblScope unit="page" from="92" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b155">
	<analytic>
		<title level="a" type="main">CADE: Configurable approximate divider for energy efficiency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Imani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rosing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="2019-03">Mar. 2019</date>
			<biblScope unit="page" from="586" to="589" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b156">
	<analytic>
		<title level="a" type="main">A curve fitting approach for non-iterative divider design with accuracy and performance trade-off</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Jong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NEWCAS</title>
		<meeting>NEWCAS</meeting>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b157">
	<analytic>
		<title level="a" type="main">Energy-aware probabilistic multiplier: Design and analysis</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S K</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-V</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Chu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CASES</title>
		<meeting>CASES</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="281" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b158">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Woods</surname></persName>
		</author>
		<title level="m">Digital Image Processing</title>
		<meeting><address><addrLine>Upper Saddle River, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>rd ed</note>
</biblStruct>

<biblStruct xml:id="b159">
	<analytic>
		<title level="a" type="main">Joint face detection and alignment using multitask cascaded convolutional networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Qiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Process. Lett</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1499" to="1503" />
			<date type="published" when="2016-10">Oct. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b160">
	<analytic>
		<title level="a" type="main">A 1.17 TOPS/W, 150fps accelerator for multi-face detection and alignment</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2019-06">Jun. 2019</date>
			<biblScope unit="page">80</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b161">
	<analytic>
		<title level="a" type="main">FDDB: A benchmark for face detection in unconstrained settings</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Learned-Miller</surname></persName>
		</author>
		<idno>UM-CS-2010-009</idno>
	</analytic>
	<monogr>
		<title level="j">Univ. Massachusetts</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Amherst, Amherst, MA, USA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b162">
	<analytic>
		<title level="a" type="main">Annotated facial landmarks in the wild: A large-scale, real-world database for facial landmark localization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kostinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wohlhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bischof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCV Workshops</title>
		<meeting>ICCV Workshops</meeting>
		<imprint>
			<date type="published" when="2011-11">Nov. 2011</date>
			<biblScope unit="page" from="2144" to="2151" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
