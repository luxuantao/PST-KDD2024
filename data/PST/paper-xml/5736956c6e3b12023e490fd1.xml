<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fair and Robust Multi-party Computation Using a Global Transaction Ledger</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aggelos</forename><surname>Kiayias</surname></persName>
							<email>aggelos@di.uoa.gr</email>
							<affiliation key="aff0">
								<orgName type="institution">National and Kapodistrian University of Athens</orgName>
								<address>
									<settlement>Athens</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hong-Sheng</forename><surname>Zhou</surname></persName>
							<email>hszhou@vcu.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">Virginia Commonwealth University</orgName>
								<address>
									<settlement>Richmond</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vassilis</forename><surname>Zikas</surname></persName>
							<email>vzikas@cs.rpi.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Rensselaer Polytechnic Institute</orgName>
								<address>
									<settlement>Troy</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fair and Robust Multi-party Computation Using a Global Transaction Ledger</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">ECDC26B7FE4E394D44BDC26BAD333F0C</idno>
					<idno type="DOI">10.1007/978-3-662-49896-5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Classical results on secure multi-party computation (MPC) imply that fully secure computation, including fairness (either all parties get output or none) and robustness (output delivery is guaranteed), is impossible unless a majority of the parties is honest. Recently, cryptocurrencies like Bitcoin where utilized to leverage the fairness loss in MPC against a dishonest majority. The idea is that when the protocol aborts in an unfair manner (i.e., after the adversary receives output) then honest parties get compensated by the adversarially controlled parties.</p><p>Our contribution is three-fold. First, we put forth a new formal model of secure MPC with compensation and show how the introduction of suitable ledger and synchronization functionalities makes it possible to describe such protocols using standard interactive Turing machines (ITM) circumventing the need for the use of extra features that are outside the standard model as in previous works. Second, our model, is expressed in the universal composition setting with global setup and is equipped with a composition theorem that enables the design of protocols that compose safely with each other and within larger environments where other protocols with compensation take place; a composition theorem for MPC protocols with compensation was not known before. Third, we introduce the first robust MPC protocol with compensation, i.e., an MPC protocol where not only fairness is guaranteed (via compensation) but additionally the protocol is guaranteed to deliver output to the parties that get engaged and therefore the adversary, after an initial round of deposits, is not even able to mount a denial of service attack without having to suffer a monetary penalty. Importantly, our robust MPC protocol requires only a constant number of (coin-transfer and communication) rounds.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Secure multiparty computation (MPC) enables a set of parties to evaluate the output of a known function f (•) on inputs they privately contribute to the protocol execution. The design of secure MPC protocols, initiated with the seminal works of Yao <ref type="bibr" target="#b34">[31]</ref> and Goldreich et al. <ref type="bibr" target="#b22">[21]</ref> has evolved to a major effort in computer security engineering. Beyond privacy, a secure MPC protocol is highly desirable to be fair (either all parties learn the output or none) and robust (the delivery of the output is guaranteed and the adversary cannot mount a "denial of service" against the protocol). Achieving fairness and robustness in a setting where there is an arbitrary number of corruptions, as desirable as it may appear, is prohibited by strong impossibility results stemming from the work of Cleve <ref type="bibr" target="#b17">[16]</ref> who showed that coin-flipping is infeasible in any setting where there is no honest majority among parties that execute the protocol. These impossibility results, combined with the importance of the properties that they prevent, strongly motivate the exploration of alternate -yet still realistic -models that would enable fair and robust MPC protocols.</p><p>With the advent of Bitcoin <ref type="bibr" target="#b31">[28]</ref> and other decentralized cryptocurrencies, the works of <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b30">27]</ref> showed a new direction for circumvention of the impossibility results regarding the fairness property: enforcing fairness could be achieved through imposing monetary penalties. In this setting a breach of fairness by the adversary is still possible but it results in the honest parties collecting a compensation in a way that is determined by the protocol execution. At the same time, in case fairness is not breached, it is guaranteed that no party loses any money (despite the fact that currency transfers may have taken place between the parties). The rationale here is that a suitable monetary penalty suffices in most practical scenarios to force the adversary to operate in the protocol fairly.</p><p>While the main idea of fairness with penalties sounds simple enough, its implementation proves to be quite challenging. The main reason is that the way a crypto-currency operates does not readily provide a trusted party that will collect money from all participants and then either return it or redistribute it according to the pre-agreed penalty structure. This is because crypto-currencies are decentralized and hence no single party is ever in control of a money transfer beyond the owner of a set of coins. The mechanism used in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b30">27]</ref> to circumvent the above problem is the capability<ref type="foot" target="#foot_0">1</ref> of the Bitcoin network to issue transactions that are "time-locked", i.e., become valid only after a specific time and prior to that time may be superseded by other transactions that are posted in the public ledger. Superseded time-locked transactions become invalid and remain in the ledger without ever being redeemed.</p><p>While the above works are an important step for the design of MPC protocols with properties that circumvent the classical impossibility results, several critical open questions remain to be tackled; those we address herein are as follows.</p><p>Our Results. Our contribution is three-fold. First, we put forth a new formal model of secure MPC with compensation and we show how the introduction of suitable ledger and synchronization functionalities makes it possible to express completely such protocols using standard interactive Turing machines (ITM) circumventing the need for the use of extra features that are outside the standard model (in comparison, the only previous model <ref type="bibr" target="#b7">[7]</ref> resorted to specialized ITM's that utilize resources outside the computational model<ref type="foot" target="#foot_1">2</ref> ). Second, our model is equipped with a composition theorem that enables the design of protocols that compose safely with each other and within larger environments where other protocols with compensation take place; a composition theorem for this class of protocols was not known before and requires a new framework for synchronization in the global UC setting that can be of independent interest. Third, we introduce the first robust MPC protocol with compensation, i.e., an MPC protocol where not only fairness is guaranteed (via compensation) but additionally the protocol is guaranteed to deliver output to the parties that get engaged and therefore the adversary is not even able to mount a denial of service attack without having to suffer a monetary penalty. In more details we have the following.</p><p>-We put forth a new model that utilizes two ideal functionalities and expresses the ledger of transactions and a clock in the sense of <ref type="bibr" target="#b26">[24]</ref> that is connected to the ledger and enables parties to synchronize their protocol interactions.</p><p>Our ledger functionality enable us to abstract all the necessary features of the underlying cryptocurrency. Contrary to the only previous formalization approach <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b30">27]</ref>, our modeling allows the entities that participate in an MPC execution to be regular interactive Turing machines (ITM) and there is no need to equip them with additional physical features such as "safes" and "locks." Furthermore the explicit inclusion of the clock functionality (which is only alluded to in <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b30">27]</ref>) and a synchronous framework for protocol design given such clock reveal the exact dependencies between the ledger and the clock functionality that are necessary in order for MPC with compensation protocols to be properly described. We express our model within a general framework that we call Q-fairness and robustness and may be of independent interest as it can express meaningful relaxations of fairness and robustness in the presence of a global ideal functionality. -We prove a composition theorem that establishes that protocols in our framework are secure in a universally composable fashion. Our composition proof treats the clock and ledger functionalities as global setups in the sense of <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b14">13]</ref>. We emphasize that this is a critical design choice: the fact that the ledger is a global functionality ensures that any penalties that are incurred to the adversary that result to credits towards the honest parties will be globally recognized. This should be contrasted to an approach that utilizes regular ideal functionalities which may be only accessible within the scope of a single protocol instance and hence any penalty bookkeeping they account may vanish with the completion of the protocol. Providing a composition theorem for MPC protocols with compensation was left as an open question in <ref type="bibr" target="#b7">[7]</ref>. -We finally present a new protocol for fair and robust secure MPC with compensation. Our robustness property guarantees that once the protocol passes an initial round of deposits, parties are guaranteed to obtain output or be compensated. This is in contrast to fair MPC with compensation <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b30">27]</ref> where the guarantee is that compensation takes place only in case the adversary obtains output while an honest party does not. To put it differently, it is feasible for the adversary to lead the protocol to a deadlock where no party receives output however the honest parties have wasted resources by introducing transactions in the ledger. We remark that it is in principle possible to upgrade the protocols of <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b30">27]</ref> to the robust MPC setting by having them perform an MPC with identifiable abort, cf. <ref type="bibr" target="#b22">[21,</ref><ref type="bibr" target="#b25">23]</ref>, (in such protocol the party that causes the abort can be identified and excluded from future executions). However even using such protocol the resulting robust MPC with compensation will need in the worst case a linear number of deposit/communication rounds in the number of malicious parties. Contrary to that, our robust protocol can be instantiated so that it requires a constant number of deposit/communication rounds independently of the number of parties that are running the protocol. Our construction uses time-locked transactions in a novel way to ensure that parties do progress in the MPC protocol or otherwise transactions are suitably revertible to a compensation for the remaining parties. The structure of our transactions is quite more complex than what can be presently supported by bitcoin; we describe in high-level how our protocol can be implemented via Ethereum<ref type="foot" target="#foot_2">3</ref> contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work.</head><p>In addition to the previous works <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b30">27]</ref> in fair MPC with compensation, very recently, Ruffing et al. <ref type="bibr" target="#b33">[30]</ref> address equivocation issues via penalty mechanism, and design decentralized "non-equivocation" contracts.</p><p>There are a number of other works that attempted to circumvent the impossibility results for fairness in the setting of dishonest majority by considering alternate models. Contrary to the approach based on cryptocurrencies these works give an advantage to the protocol designer with respect to the adversarial strategy for corruption. For instance, in <ref type="bibr" target="#b19">[18]</ref> a rational adversary is proposed and the protocol designer is privy to the utility function of the adversary. In <ref type="bibr" target="#b2">[3]</ref> a reputation system is used and the protocol designer has the availability of the reputation information of the parties that will be engaged in the protocol. Finally in <ref type="bibr" target="#b18">[17]</ref> a two tiered model is proposed where the protocol designer is capable of distinguishing two distinct sets of servers at the onset of the computation that differ in terms of their corruptibility.</p><p>Global setups were first put forth in <ref type="bibr" target="#b12">[11]</ref> motivated by notion of deniability in cryptographic protocols. In our work we utilize global functionalities for universal composition (without the deniability aspect) as in <ref type="bibr" target="#b14">[13]</ref> where a similar approach was taken for the case of the use of the random oracle as a global setup functionality for MPC.</p><p>Fairness was considered from the resource perspective, cf. <ref type="bibr" target="#b9">[8,</ref><ref type="bibr" target="#b20">19,</ref><ref type="bibr" target="#b32">29]</ref>, where it is guaranteed due to the investment of proportional resources between the parties running the protocol, and the optimistic perspective, cf. <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b10">9]</ref>, where a trusted mediator can be invoked in the case of an abort. We finally note that without any additional assumptions, due to the impossibility results mentioned above, one can provide fairness only with certain high probability that will be affecting the complexity of the resulting protocol, see, e.g., <ref type="bibr" target="#b23">[22]</ref> and references therein.</p><p>In concurrent and independent work, Kosba et al. <ref type="bibr" target="#b29">[26]</ref> propose a framework for composable protocols based on a ledger. and explore a notion of fairness with compensation. Our work goes beyond fairness and provides a treatment of robustness. Furthermore we provide a synchronous framework with a global clock (of independent interest) that uses the ledger as a global setup to achieve fairness and robustness and we prove a composition theorem for our framework.</p><p>Organization. We start with preliminaries in Sect. 2. Then in Sects. 3 and 4, we lay down a formal framework for designing composable fair protocols in the presence of globally available trusted resources. In Sect. 3, we introduce two shared functionalities Ḡclock and Ḡledger respectively to formulate the trust resources that are provided by Bitcoin-like systems. Subsequently, in Sect. 4, we put forth a new formal framework for secure MPC with compensation: we introduce the notions of Q-fairness, and Q-robustness via wrapper functionalities; we then consider the realization of such wrapper functionalities, and further provide a composition theorem. In Sect. 5, we present a protocol in our new framework to achieve our new notions of fairness and robustness. We refer the reader to the full version of our work <ref type="bibr" target="#b28">[25]</ref> for a discussion about implementing our protocol within Ethereum, supplementary material for Sects. 2 and 3, and for the formal proofs of our theorems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Throughout the paper we assume an (often implicit) security parameter denoted as κ. For a number n ∈ N we denote by [n] the set [n] = {1, . . . , n} and denote by 0 n (resp. 1 n ) the all-zero (resp. all-ones) string of length n. For a randomized algorithm Alg we denote by Alg(x; r) the output of Alg on input x and random coins r. To avoid always explicitly writing the coins r, we shall denote by y $ ← Alg(x) the operation of running Alg on input x (and uniformly random coins) and storing the output on variable y. We write f : X $ → Y to denote a probabilistic function with domain X and range Y . We use the standard definition of negligible and overwhelming (e.g., see <ref type="bibr" target="#b21">[20]</ref>).</p><p>For a multiparty function f : ({0, 1} * ∪ {λ}) n → ({0, 1} * ∪ {⊥}) n for parties in P = {p 1 , . . . , p n } and for a set P ⊆ P, we denote by f | |P | the restriction of f to the parties in P , namely, if each p i ∈ P has input x i , then the output of f | |P | is the output of f evaluated on inputs x i for each p i ∈ P and x j = λ for each p j ∈ P\P .</p><p>We describe our results in the extension of Canetti's UC framework <ref type="bibr" target="#b11">[10]</ref> to allow for global setups, known as GUC <ref type="bibr" target="#b12">[11]</ref>. As argued above, this is the natural model to consider execution in the present of a globally synchronized clock and a ledger/bulletin board. Consistently with the (G)UC notation, we denote local (UC) functionalities by calligraphic letters, as in F, and add a bar to denote global functionalities, as in Ḡ. Furthermore, we denote by φ, the dummy protocol. Note that in GUC φ might receive inputs for its (UC) hybrids and/or for the global setup, where an implicit mechanism is assumed to allow the environment to define the intended recipient of each submitted input to φ. For a protocol π, a (local) UC functionality F and a global setup Ḡ we denote by Exec Ḡ,F π,A,Z the output of the environment Z in an execution of π having hybrid access to Ḡ and F in the presence of adversary A. We assume some familiarity with the UC and/or the GUC framework.</p><p>Correlated Randomness as a Sampling Functionality. Our protocols are in the correlated randomness model, i.e., they assume that the parties initially, before receiving their inputs, receive appropriately correlated random strings. In particular, the parties jointly hold a vector R = (R 1 , . . . , R n ) ∈ ({0, 1} * ) n , where P i holds R i , drawn from a given efficiently samplable distribution D. This is, as usual, captured by giving the parties initial access to an ideal functionality F D corr , known as a sampling functionality, which, upon receiving a default input from any party, samples R from D and distributes it to the parties (see <ref type="bibr" target="#b28">[25]</ref> for details). Hence, a protocol in the correlated randomness model is formally an F D corr -hybrid protocol. Formally, a sampling functionality F D corr is parameterized by an efficiently computable sampling distribution D and the (ID's of the parties in) the player set P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Model</head><p>In this section and next section, we lay down a formal framework for designing composable fair protocols in the presence of globally available trusted resources. We introduce in the current section, shared (in the sense of the GUC model <ref type="bibr" target="#b12">[11]</ref>) functionalities Ḡclock and Ḡledger respectively to formulate the trust resources that are provided by Bitcoin-like systems. We stress that these two functionalities can be thought of as a single global functionality and in our description are allowed to communicate. Nonetheless, we choose to describe then as two separate functionalities, because as we argue, the clock Ḡclock can also be used alone (without Ḡledger ) to naturally model synchronous computation with a global notion of time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Global Clock Functionality and Synchronous Protocol Executions</head><p>In this section we describe how to model execution of synchronous protocols that can access a global-clock setup. This is an adaptation of the original idea by Katz et al. <ref type="bibr" target="#b26">[24]</ref>, where a clock was modelled as UC functionality that is local to the calling protocol, and is of independent interest as a model for the design of synchronous protocols. In addition to being a more realistic model for capturing time in UC, the notion of the global clock allows for synchronous execution of any protocols that choose to use it. Before defining our clock, we recall the reader the clock and model of synchronous execution from <ref type="bibr" target="#b26">[24]</ref> and then highlight the main differences. The clock in <ref type="bibr" target="#b26">[24]</ref> is a UC functionality that keeps an indicator bit b originally set to 0. The parties can send to the clock special "update" messages, and once the clock sees that all honest parties agree to update the state it sets b := b ⊕ 1. The clock then continues to receive "update" messages, and again, once it sees that all honest parties have requested to update after the last switch of the bit b it switches it again. To make sure that the adversary is given enough activations, whenever the clock receives an "update" message from the honest party it notifies the adversary. In addition to "update" messages, the parties can send the clock a "read" message which the clock replies with the current value of b.</p><p>The use of such a clock to keep a round structure is as follows: Whenever a party observes a switch of the bit b, it interprets it as a round advance. Thus, a synchronous protocol with access to such a clock is executed as follows. In each round, every party performs all its protocol instructions for the current round, and at the end sends an "update" message to the clock; from the point where the party updates (its round has finished) it queries ("reads") the clock with each following activation to detect when all parties have also finished their rounds (i.e., when the value of b switches). Once this happens, the party starts its next protocol round.</p><p>An issue with the above clock is that in order to execute two protocols using the same clock we need to make use of the joint-state UC theorem <ref type="bibr" target="#b16">[15]</ref>. Instead, in this work we take an alternative modelling approach and define a shared clock functionality Ḡclock . This functionality can be viewed as a shared version of the clock functionality which was defined by Katz et al. <ref type="bibr" target="#b26">[24]</ref>. The main intuition behind our clock functionality is that all honest parties can use it to ensure that they proceed with their rounds at the same pace. On a high level, the clock operates as follows: any party that wishes to be synchronised with the global clock can send (register, sid) to the clock and subsequently it can send it (clock-update, sid) commands, where sid is Ḡclock 's identifier. The clock stores a global-time counter τ (initially set to 0), and as soon it is instructed by all currently honest parties and by associated shared functionalities<ref type="foot" target="#foot_3">4</ref> to advance the time (i.e., receives (clock-update, sid) it increases its state-counter τ by 1.</p><p>The main difference between our formulation and that by Katz et al. <ref type="bibr" target="#b26">[24]</ref> is that in <ref type="bibr" target="#b26">[24]</ref> the clock is a UC functionality which is local to a single protocol and waits for an "update" message by every honest party to advance its state; however, here we intend to have the clock to be accessed globally and used by arbitrary protocols. Therefore we give the power to the environment to define the clock's speed. Indeed, if there are no associated shared functionalities, the environment can instruct dummy parties to send inputs (clock-update, sid) to Ḡclock and advance the clock whenever it wishes. An additional difference is that in <ref type="bibr" target="#b26">[24]</ref>, the clock state is binary while here, in our formulation, the state τ is a positive integer which indicates the time that has passed from point zero (i.e., from the beginning of time).</p><p>Next, we elaborate and explain how to use the global clock to design synchronous protocols. We remark that the model of synchronous protocol execution of <ref type="bibr" target="#b26">[24]</ref> cannot be used in our setting as the environment can make the clock advance before honest parties have time to take actions in any round. Indeed, in the ideal setting the environment can keep sending (clock-update, sid) to the dummy parties, which will forward it to the clock making its state to advance; to make sure that the protocol is indistinguishable, honest parties would have to do the same, thereby giving away the activations that they need for executing their protocol instructions such as send and receive operations. <ref type="foot" target="#foot_4">5</ref> This might, at first, seem like a bug but it is in fact a feature. It captures the fact that since time is a quantity that should be in the control of the environment, if the environment chooses to advance time too fast then some protocol might not have enough time to perform their operations for each round, and might therefore need to give up.</p><p>To make sure that the environment cannot exploit such fast-forwarding of the clock we use the following idea: We allow the clock to receive from honest parties or (non-shared) ideal functionalities a special (Clock-Fast) message, which makes it set an internal indicator from 0 to 1. This indicator will be added onto the response of the clock to clock-read queries, and will make any synchronous protocol or corresponding functionality that reads the clock and observes this indicator being set to one to immediately terminate with a default value. This way we ensure that an environment that tries such a fast-forward distinguishing attack will be forced to make any synchronous protocol behave in a default way, a behavior which, as we see, is easily imitated in the ideal world. The detailed description of the clock functionality can be found in Fig. <ref type="figure">1</ref>.</p><p>We stress that having a global Ḡclock -hybrid model makes the mode of execution of synchronous protocols more intuitive compared to <ref type="bibr" target="#b26">[24]</ref>. Here is how synchronous protocols are executed in this setting. First, as is the case in real-life synchronous protocols, we assume that the protocol participants have agreed on the starting time τ 0 of their protocol and also on the duration of each round. <ref type="foot" target="#foot_5">6</ref> We abstract this knowledge by assuming the parties know a function Round2Time : Z → Z which maps protocol rounds to time (according to the global clock) in which the round should be completed. For ρ ∈ Z, Round2Time(ρ) is the time in which the ρth round of the protocol should be completed. To make sure that no party proceeds to round ρ + 1 of the protocol before all honest parties have completed round ρ, we require that any two protocol rounds are at least two clock-ticks apart (see <ref type="bibr" target="#b26">[24]</ref> for a discussion); formally, for all ρ ≥ 0, it holds that Round2Time(ρ + 1) ≥ Round2Time(ρ) + 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functionality Ḡclock</head><p>Shared functionality Ḡclock is globally available to all participants. The shared functionality is parameterized with variables τ , a bit d Ḡledger a set P and a bit fast and is associated with a ledger shared functionality Ḡledger. Initially, τ := 0, d Ḡledger := 0, fast := 0 and P := ∅.</p><p>-Upon receiving (register, sid) from some party P , set P := P ∪{P } and if P was not registered before, set dP := 0; subsequently, forward (register, sid, P ) to A. -Upon receiving (clock-update, sid) from Ḡledger set d Ḡledger := 1 and forward (clock-update, sid, Ḡledger) to A -Upon receiving (clock-update, sid) from some honest party P ∈ P set di := 1; then if d Ḡledger := 1 and dP = 1 for all honest parties in P , then set τ := τ + 1 and reset d Ḡledger := 0 and dP := 0 for all parties in P . Forward (clock-update, sid, P ) to A. -Upon receiving (clock-read, sid) from any participant (including the environment, the adversary, or any ideal-shared or local-functionality) return (clock-read, sid, τ, fast) to the requestor. -Upon receiving (Clock-Fast) from any honest party or ideal functionality, set fast := 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 1. The clock functionality</head><p>A synchronous protocol in the above setting proceeds as follows where the parties keep locally track of the current round ρ in the protocol they are in:</p><p>-Upon receiving a (clock-update, sid) input (from its environment) where sid is the ID of Ḡclock , party P i forwards it to Ḡclock . -Upon receiving a (clock-read, sid) input (from its environment), party P i forwards it to Ḡclock and outputs the response to the environment. -Upon receiving a (Clock-Fast) input (from its environment), party P i forwards it to Ḡclock . -Upon receiving any message (Input, sid ) where sid is the session ID of a protocol P i is involved in, do the following: Send (clock-read, sid) to Ḡclock and denote the response by (clock-read, sid, τ, fast); if fast = 1 then output Clock-Fast to the environment. Otherwise do:</p><formula xml:id="formula_0">• if τ ≤ Round2Time(ρ -1) halt; • else, if Round2Time(ρ-1) &lt; τ ≤ Round2Time(ρ)</formula><p>execute the next pending round-ρ instruction (if all the instructions for round ρ are finished halt.) • else, if τ &gt; Round2Time(ρ) and there are still pending instructions for the current round, send (Clock-Fast) to Ḡclock . • else, i.e., if τ &gt; Round2Time(ρ) and P i has completed all round-ρ instruction, then set ρ := ρ + 1 and halt.</p><p>It is easy to verify that the above mode of operation will guarantee that the parties are never out-of-sync, since as soon as the first party issues a Clock-Fast message for the clock, all synchronous protocols will enter the mode of outputting Clock-Fast for every input that the environment hands them (that is not intended for the clock). However, there is one more thing that needs to be taken care of. Since in the real-world the parties go to a default mode (where they output Clock-Fast to every query) when the environment does not give them sufficient time, this should also be the case in the ideal world. To achieve this we use another idea inspired by the guaranteed termination functionality from <ref type="bibr" target="#b26">[24]</ref>: Let π be a synchronous protocol with round-to-time function Round2Time : Z → Z, where in each round, each party needs exactly m activations to perform its instructions <ref type="foot" target="#foot_6">7</ref> . We introduce a wrapper W which, at a high level, forwards messages to and from its wrapped functionality but stores a round-index and checks, as the protocol would, that every party issues to the wrapped functionality, at least m activations for each round ρ in the intended interval. If this is not the case the wrapper sends (Clock-Fast) to Ḡclock and responds with Clock-Fast form that point on. The detailed description can be found in the full version <ref type="bibr" target="#b28">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Global Ledger Functionality</head><p>Functionality Ḡledger provides the abstraction of a public ledger in Bitcoin-like systems (e.g., Bitcoin, Litecoin, Namecoin, Ethereum, etc.). Intuitively, the public ledger could be accessed globally by protocol parties or other entities including the environment Z. Protocol parties or the environment can generate transactions; and these valid transactions will be gathered by a set of ledger maintainers (e.g., miners in Bitcoin-like systems) in a certain order as the state of the ledger. More concretely, whenever the ledger maintainers receive a vector of transactions tx, they first add the transactions in a buffer, assuming they are valid with respect to the existing transactions and the state of the ledger; thus, in this way a vector of transactions is formed in the buffer. After a certain amount of time, denoted by T, which will be also referred to as a ledger round, all transactions in the buffer will be "glued" into the ledger state in the form of a block. The adversary is allowed to permute the buffer prior to its addition to the ledger. In Bitcoin, T is 10 min (approximately); thus in about every 10 min, a new block of transactions will be included into the ledger, and the ledger state will be updated correspondingly.</p><p>To enable the ledger to be aware of time, the ledger maintainers are allowed to "read" the state of another publicly available functionality Ḡclock defined above. Furthermore, to ensure that the ledger is activated at least once in each timetick<ref type="foot" target="#foot_7">8</ref> (i.e., each advance of the Ḡclock state) we have the ledger, with every message it gets from a party other than the adversary, send a (clock-update, sid) message to Ḡclock . (Recall that, as defined, Ḡclock always waits for at least one such message from the ledger before advancing its time counter.)  We remark that all gathered transactions should be "valid" which is defined by a predicate Validate. In different systems, predicate Validate will take different forms. For example, in the Bitcoin system, the predicate Validate should make sure that for each newly received transaction that transfers v coins from the original wallet address address o to the destination wallet address address d , the original wallet address address o should have v or more than v coins, and the transaction should be generated by the original wallet holder (as shown by the issuance of a digital signature). Furthermore, prior to each vector of transactions becoming block, the vector is passed through a function Blockify(•) that homogenizes the sequence of transactions in the form of a block. Moreover, in some systems like Bitcoin, it may add a special transaction called a "coinbase" transaction that implements a reward mechanism for the ledger maintainers.</p><p>In Fig. <ref type="figure" target="#fig_0">2</ref> we provide the details of the ledger functionality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Q-Fairness and Q-Robustness</head><p>In this section, we provide a formal framework for secure computation with fair and robust compensation. In the spirit of <ref type="bibr" target="#b20">[19]</ref>, our main tool is a wrapper functionality. Our wrapper functionality is equipped with a predicate Q Ḡ which is used to make sure that the outcome of the protocol execution is consistent with appropriate conditions on the state of the global setup Ḡ. Intuitively, the predicate Q Ḡ works as a filter, such that if certain "bad" event occurs (e.g., an abort), then the wrapped functionality will restrict the simulators influence. More concretely, the predicate</p><formula xml:id="formula_1">Q Ḡ has three modes Q Init Ḡ , Q Dlv Ḡ and, Q Abt Ḡ , where Q Init Ḡ</formula><p>specifies under which condition (on the global setup's state) the protocol should start executing; Q Dlv Ḡ specifies under which condition parties should receive their output; and Q Abt Ḡ specifies under which condition the simulator is allowed to force parties to abort. With foresight Q Init Ḡ will ensure that the protocol is executed only if all honest participants have enough coins; Q Dlv Ḡ will ensure that honest parties do not lose coins if they execute the protocol; and Q Abt Ḡ will ensure that honest parties might be forced to an "unfair" abort (i.e., where the adversary has received his output) only if they are compensated by earning coins (from the corrupted parties). We will call an implementation of a wrapped version of F a Q-fair implementation of F. <ref type="foot" target="#foot_8">9</ref>Our definition of Q Ḡ -fairness can be instantiated with respect to any global setup that upon receiving a read symbol (from any protocol participant or functionality) it returns its public state trans. Concretely, let Ḡ be global ideal functionality and let Q Ḡ a predicate, as above, with respect to such Ḡ. Let also F be a non-reactive functionality<ref type="foot" target="#foot_9">10</ref> which allows for fair evaluation of a given function (SFE) in the sense of <ref type="bibr" target="#b20">[19]</ref>, i.e., it has two modes of delivering output: (i) delayed delivery: (deliver, sid, m, P ) signifying delayed output delivery <ref type="foot" target="#foot_10">11</ref> of m to party P , (ii) fair delivery: (fair-deliver, sid, (m, P i1 ), . . . , (m, P i k ), (m S , S)) that results in simultaneous delivery of outputs m i1 , . . . m i k to parties P i1 , . . . , P i k and output m S to S. We note that (G)UC does not have an explicit mechanism for simultaneous delivery of outputs. Thus, when we refer to simultaneous delivery of a vector (m i1 , . . . , m i k ) to parties P i1 , . . . , P i k , respectively, we imply that the functionality prepares all the output to be delivered in a "fetch mode" as defined in <ref type="bibr" target="#b26">[24]</ref>; that is:</p><p>-The functionality registers the pairs (m i1 , P i1 ), . . . , (m, P i k ) as "ready to fetch" and sends the set {(m ij , P ij )|P ij is corrupted} to S. -Upon receiving an input (fetch-output, P i ) from party P i , if a message (m i , P i ) has been registered as "ready to fetch" then remove it from the "ready to fetch" set and output it to P i (if more than one such messages are registered, deliver and remove from the "ready to fetch" set the first, chronologically, registered such pair); otherwise send (fetch-output, P i ) to S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Q Ḡ -Fairness</head><p>The wrapper functionality W that will be used in the definition of Q-fair (secure) computation is given in Fig. <ref type="figure" target="#fig_1">3</ref>. The intuition is as follows: Prior to handing inputs to the (wrapped) functionality F, the parties can request the wrapper to generate on their behalf a resource-setup (by executing an associated resourcesetup generation algorithm Gen) which allows them to update the global setup Ḡ; this resource setup consists of a public component RS pub P,sid and a private component RS priv P,sid . <ref type="foot" target="#foot_11">12</ref> Both these values are given to the simulator, and the public component is handed to the party.</p><p>From the point when parties receive their inputs the Q predicate is used as a filter to specify the wrapper's behavior and add the fairness guarantees. More concretely, upon receiving an input from a party, the wrapper checks on the global setup to ensure that Q Init is true, and if it is not true it aborts (i.e., sets all honest parties' outputs to ⊥ and blocks any communication between F and the adversary). This means that if the environment has not set up the experiment properly, <ref type="foot" target="#foot_12">13</ref> then the experiment will not be executed and the wrapped functionality will become useless. This formally resolves the question "What happens if some party does not have sufficient coins to play the protocol?" which leads to some ambiguity in existing bitcoin-based definitions of computation with fair compensation <ref type="bibr" target="#b7">[7]</ref>.</p><p>The predicates Q Dlv and Q Abt are used to filter out attempts of the simulator to deliver outputs or abort when Q Dlv and Q Abt are violated. <ref type="foot" target="#foot_13">14</ref> Concretely, any such attempt will be ignored if the corresponding predicate is not satisfied.</p><p>Intuitively, by requiring the protocol to implement such a wrapped version of a functionality, we will ensure that the parties might only abort if Q Abt is true, and might output a valid (non-⊥) value if Q Dlv . As we shall see in Sect. 4.2, by a trivial modification of the fairness wrapper, we can capture a stronger property which we will call Q-robustness; the latter, roughly, guarantees that honest parties which start the protocol will either receive their output (and Q Dlv being true) or will abort and increase their revenue. (I.e., there is no way for the adversary to make the protocol abort after the first honest party has sent its first input-dependent message). Definition 1. We say protocol π realizes functionality F with Q Ḡ -fairness with respect to global functionality Ḡ, provided the following statement is true. For all adversaries A, there is a simulator S so that for all environments Z it holds:</p><formula xml:id="formula_2">Exec Ḡ π,A,Z ≈ Exec Ḡ,W Q, Ḡ (F ) S,Z</formula><p>More generally, the protocol σ realizes H with Q Ḡ fairness using a functionality F with fairness Q Ḡ provided that for all adversaries A, there is a simulator</p><formula xml:id="formula_3">Wrapper Functionality W Q, Ḡ (F )</formula><p>The wrapper W Q, Ḡ (F ) interacts with a set of parties P = {P1, . . . , Pn}, the adversary S and the environment Z, as well as shared functionality Ḡ. It is parameterized with a predicate Q = (Q Init , Q Dlv , Q Abt ) and a resource-setup generating algorithm Gen : 1 * $ → ({0, 1} * ) 2 and wraps any given non-reactive n-party functionality F with the two output-delivery modes (delayed and fair) described in Section 4.1. The functionality also keeps an indicator bit b, initially set to 0, indicating whether or not S is blocked from sending messages to F.</p><p>-Allocating Resources. Upon receiving (alocate, sid) from a party P , if a message (alocate, sid) has already been received for P then ignore it; else send (Coins, sid, P ) to S and upon receiving (Coins, sid, P, r) from S compute (RS pub P,sid , RS priv P,sid ) ← Gen(1 κ ; r) and sends a delayed output (deliver, sid, RS pub P,sid , P ) to P . -Upon receiving any message M from F to be delivered to its simulator, if b = 0 forward M to S. -Upon receiving a message (Forward, M) from S, if b = 0 then forward M to F as a message coming from its simulator. -Receiving input for F. Upon receiving (input, sid, x) from a party P , send read to Ḡ, denote the response by trans and if ¬Q Init (RS pub P,sid , trans) then set b := 1 and issue a message (fair-deliver, sid, (⊥, P1), . . . , (⊥, Pn), (⊥, S)) (i.e., simultaneously deliver ⊥ to all parties and ignore all future messages except (fetch-output, •) messages. Otherwise, forward (input, sid, x) to F as input for P .</p><p>-Generating delayed output. Upon receiving a message from F marked (deliver, sid, m, P ) forwards m to party P via delayed output. -Registering fair output. Upon receiving a message from F that is marked for fair delivery (fair-deliver, sid, mid, (m1, Pi 1 ), . . . , (m k , Pi k ), (mS , S)), it forwards (mid, Pi 1 , . . . , Pi k , mS ) to S. -Q-fair delivery. Upon receiving (Q-deliver, sid, mid) from S then provided that a message (mid, . . .) has been delivered to S operate as follows. For each pair of the form (m, P ) associated with mid: Let L = {(m, P )| P is uncorrupted}. Send {(m, P )|P is corrupted} to S. (If some currently honest P becomes corrupted later on, remove (m, P ) from sending and send (m, P ) to S.) Subsequently perform the following.</p><p>• On input a message (deliver, sid, mid, P ) from S, provided that the record mid contains the pair (m, P ) ∈ L, send read to Ḡ, denote the response by trans and if ¬Q Dlv (sid, P, RS pub P,sid , trans) then ignore the message. Else, remove (m, P ) from L and register (m, P ) as "ready to fetch".</p><p>• On input a message (abort, sid, mid, P ) from S, provided that the record mid contains the pair (m, P ) ∈ L, send read to Ḡ, denote the response by trans and if ¬Q Abt (sid, P, RS pub P,sid , trans) then ignore the message. Else, remove (m, P ) from L and register (⊥, P ) as "ready to fetch". -Upon receiving an input (fetch-output, P ) from party P , if a message (m, P ) has been registered as "ready to fetch" then remove it from the "ready to fetch" set and output it to Pi (if more than one such messages are registered, deliver and remove from the "ready to fetch" set the first, chronologically, registered such pair); otherwise send (fetch-output, Pi) to S. S so that for all environments Z, it holds:</p><formula xml:id="formula_4">Exec Ḡ,W Q, Ḡ (F ) π,A,Z ≈ Exec Ḡ,W Q , Ḡ (H)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S,Z</head><p>We note that, both protocol π and the functionality (W Q, Ḡ (F), Ḡ) are with respect to the global functionality<ref type="foot" target="#foot_14">15</ref> Ḡ. By following the very similar proof idea in <ref type="bibr" target="#b12">[11]</ref>, we can prove the following lemma and theorem: Lemma 1. Let Q Ḡ be a predicate with respect to global functionality Ḡ. Let π be a protocol that realizes the functionality F with Q Ḡ -fairness. Let σ be a protocol in (W Q, Ḡ (F), Ḡ)-hybrid world. Then for all adversaries A, there is a simulator S so that for all environments Z, it holds</p><formula xml:id="formula_5">Exec Ḡ σ π ,A,Z ≈ Exec Ḡ,W Q, Ḡ (F )</formula><p>σ,S,Z Theorem 1. Let Q Ḡ and Q Ḡ be predicates with respect to global functionality Ḡ. Let π be a protocol that realizes the functionality F with Q Ḡ -fairness. Let σ be a protocol in (W Q, Ḡ (F), Ḡ)-hybrid world that realizes the functionality H with Q Ḡ -fairness. Then for all adversaries A, there is a simulator S so that for all environments Z it holds:</p><formula xml:id="formula_6">Exec Ḡ σ π ,A,Z ≈ Exec Ḡ,W Q , Ḡ (H) S,Z</formula><p>Is the Ledger Functionality Sufficient for Q Fairness? We will construct secure computation protocols based on the ledger functionality Ḡledger together with other trusted setups. We may wonder if we can construct secure computation protocol from Ḡledger only. The answer if negative. Indeed, we prove the following statement.</p><p>Theorem 2. Let Q Ḡ be a predicate with respect to global functionality Ḡ = Ḡledger . There exists no protocol in the Ḡledger hybrid world which realizes the commitment functionality F com with Q Ḡ fairness.</p><p>The proof idea is very similar to the well-known Canetti-Fischlin <ref type="bibr" target="#b13">[12]</ref> impossibility proof and can be found in <ref type="bibr" target="#b28">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Q Ḡ -Robustness</head><p>The above wrapper W allows the simulator to delay delivery of messages arbitrarily. Thus, although the predicates do guarantee the promised notion of fairness, the resulting functionality lacks the other relevant property that we discussed in the introduction, namely robustness. In the following we define Q-robustness which will ensure that if any party starts executing the protocol on its input (i.e., the protocol does not abort due to lack of resources for some party), then every honest party is guaranteed to either receive its output without loosing revenue, or receive bottom and a compensation. This property can be obtained by modifying the wrapper W using an idea from <ref type="bibr" target="#b26">[24]</ref> so that in addition to the global-setup-related guarantees induced by predicate Q, it also preserves the guaranteed termination property of the wrapped functionality. <ref type="foot" target="#foot_15">16</ref>More concretely, in <ref type="bibr" target="#b26">[24]</ref>, a functionality was augmented to have guaranteed termination, by ensuring that given appropriately many activations (i.e., dummy inputs), from its honest interface, it computes its output. <ref type="foot" target="#foot_16">17</ref> In the same spirit, a wrapper which ensures Q-robustness is derived from W via the following modification: As soon as a fair-output is registered (i.e., upon the wrapper receiving (fair-deliver, sid, mid, (m 1 , P i1 ), . . . , (m k , P i k ), (m S , S)) from its inner functionality) it initiates a counter λ = 0 and an indicator variable λ ij := 0 for each P ij ∈ {P i1 , . . . , P i k }; whenever a message is received from some P ij ∈ {P i1 , . . . , P i k }, the wrapper sets λ ij := 1 and does the following check: if λ ij = 1 for all P ij ∈ {P i1 , . . . , P i k } then increase λ := λ + 1 and reset λ ij = 0 for all P ij ∈ {P i1 , . . . , P i k }. As soon as λ reaches a set threshold T , the wrapper simultaneously delivers each ((m 1 , P i k ), . . . , (m k , P i k ) (i.e., prepares them to be fetched) without waiting for the simulator and does not accept any inputs other than (fetch-output, •) from that point on. When this happens, we will say that the wrapper reached its termination limit. We denote by ŴT the wrapper from Fig. <ref type="figure" target="#fig_1">3</ref> modified as described above. Note that the wrapper is parameterized by the termination threshold T .</p><p>The intuition why this modification ensures guaranteed termination is the same as in <ref type="bibr" target="#b26">[24]</ref>: if the environment wishes the experiment to terminate, the it can make it terminate irrespective of the simulator's strategy. Thus a protocol which realizes such a wrapper should also have such a guaranteed termination (the adversary cannot stall the computation indefinitely.) Definition 2. We say protocol π realizes functionality F with Q Ḡ -robustness with respect to global functionality Ḡ, provided the following statement is true. There exists a threshold T such that for all adversaries A, there is a simulator S so that for all environments Z it holds:</p><formula xml:id="formula_7">Exec Ḡ π,A,Z ≈ Exec Ḡ, ŴT Q, Ḡ (F ) S,Z .</formula><p>Moreover, whenever the wrapper reaches its termination limit, then for the state trans of the global setup Ḡ upon termination it holds that Q Dlv Ḡ (sid, P, RS pub P,sid , trans) for every party P ∈ P.</p><p>The composition theorems for Q-fairness from Sect. 4.1 can be adapted in a straight-forward manner to Q-robustness. The statements and proofs are as in the previous section and are omitted. We note in passing that since the wrapper Ŵ is in fact a wrapper which restricts the behavior of S on top of the restrictions which are applied by the Q-fairness wrapper W, a protocol which is Q-robustness is also Q-fair with respect to the same predicate Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Computation with Fair/Robust Compensation</head><p>We are now ready to instantiate the notion of Q-fairness with a compensation mechanism. For the case when Ḡ corresponds to a Bitcoin-like ledger, e.g., Ḡ = Ḡledger , and Q Ḡ provides compensation of c coins, where c &gt; 0, in the case of an abort, the resource-setup generation algorithm Gen a pair of (address, sk) where address is a bitcoin address and sk is the corresponding secret-key and the predicate</p><formula xml:id="formula_8">Q coin Ḡ = (Q C-Init Ḡ , Q C-Dlv Ḡ , Q C-Abt Ḡ</formula><p>) operates as follows. On input a session ID sid, a party id P , a wallet address RS pub P,sid , and a string trans which is parsed as a bitcoin ledger that contains transactions: 18   -Q C-Init Ḡ outputs true if and only if the balance of all transactions (both incoming and outgoing) that concern RS pub P,sid in trans and carry the meta-data sid is higher than a fixed pre-agreed initialization amount. 19  -Q C-Dlv Ḡ outputs true if and only if the balance of all transactions (both incoming and outgoing) that concern RS pub P,sid in trans and carry the meta-data sid is greater or equal to 0. -Q C-Abt Ḡ outputs true if and only if the balance of all transactions (both incoming and outgoing) that concern RS pub P,sid in trans and carry the meta-data sid is greater or equal to a fixed pre-agreed compensation amount.</p><p>If a protocol π realizes a functionality F with Q coin Ḡ -fairness (resp. Q coin Ḡrobustness), i.e., with respect to the global functionality Ḡledger , we say that π realizes F with fair compensation (resp. with robust compensation). Because our results are proved for Q coin Ḡ , to keep the notation simple in the remainder of the paper we might drop the superscript from Q coin Ḡ , i.e., we write</p><formula xml:id="formula_9">Q or Q Ḡ instead of Q coin Ḡ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Our Q Coin Ḡ -Robust Protocol Compiler</head><p>In this section we present our fair and robust protocol compiler. Our compiler compiles a synchronous protocol π SH which is secure (i.e., private) against a corrupted majority in the semi-honest correlated randomness model (e.g., an OT-hybrid protocol where the OT's have been pre-computed) into a protocol π which is secure with fair-compensation in the malicious correlated randomness model. The high-level idea is the following: We first compile π SH into a protocol in 18 Transactions in trans can also be marked with metadata. 19 In our construction Q C-Init Ḡ will check additional properties for the initial set of transactions that concern RS pub P,sid ; specifically, not only that a fixed amount µ is present but also that it is distributed in a special way.</p><p>the malicious correlated randomness model, which is executed over a broadcast channel and is secure with publicly identifiable abort. (Roughly, this means that someone observing the protocol execution can decide, upon abort, which party is not executing its code.) This protocol is then transformed into a protocol with fair compensation as follows: Every party (after receiving his correlated randomness setup) posts to the ledger transactions that the other parties can claim only if they, later, post transactions that prove that they follow their protocol. Transactions that are not claimed this way are returned to the source address; thus, if some party does not post such a proof it will not be able to claim the corresponding transaction, and will therefore leave the honest parties with a positive balance as their transactions will be refunded. Observe that these are not standard Bitcoin transactions, but they have a special format which is described in the following.</p><p>Importantly, the protocol we describe is guaranteed to either produce output in as many (Bitcoin) rounds as the rounds of the original malicious protocol, or to compensate all honest parties. This robustness property is achieved by a novel technique which ensures that once the honest parties make their initial transaction, the adversary has no way of preventing them from either computing their output or being compensated. Informally, our technique consists of splitting the parties into "islands" depending on the transactions they post (so that all honest parties are on the same island) and then allowing them to either compute the function within their island, or if they abort to get compensated. (The adversary has the option of being included or not in the honest parties' island.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">MPC with Publicly Identifiable Abort</head><p>As a first step in our compiler we invoke the semi-honest to malicious with identifiable abort compiler of Ishai, Ostrovsky, and Zikas <ref type="bibr" target="#b25">[23]</ref> (hereafter referred to as the IOZ compiler). This compiler takes a semi-honest protocol π SH in the correlated randomness model and transforms it to a protocol in the malicious correlated randomness model (for an appropriate setup) which is secure with identifiable abort, i.e., when it aborts, every party learns the identity of a corrupted party. The compiler in <ref type="bibr" target="#b25">[23]</ref> follows the so called GMW paradigm <ref type="bibr" target="#b22">[21]</ref>, which in a nutshell has every party commit to its input and randomness for executing the semi-honest protocol π SH and then has every party run π SH over a broadcast channel, where in each round ρ every party broadcasts his round ρ messages and proves in zero-knowledge that the broadcasted message is correct, i.e., that he knows the input and randomness that are consistent with the initial commitments and the (public) view of the protocol so far. The main difference of the IOZ compiler and the GMW compiler is that the parties are not only committed to their randomness, but they are also committed to their entire setup string, i.e., their private component of the correlated randomness. In the following, for the sake of completeness, we enumerate some key properties of the resulting maliciously secure protocol π Mal (which is based on the compiler in <ref type="bibr" target="#b25">[23]</ref>) that will be important for our construction:</p><p>-Every party is committed to his setup, i.e., the part of the correlated randomness it holds. That is, every party P i receives from the setup his randomness (which we refer to as P i 's private component of the setup) along with one-tomany commitments <ref type="foot" target="#foot_17">20</ref> on the private components of all parties. Without loss of generality, we also assume that a common-reference string (CRS) and a public-key infrastructure (PKI) are included in every party's setup. We refer to the distribution of this correlated randomness as D Mal . -The protocol π Mal uses only the broadcast channel for communication.</p><p>-Given the correlated randomness setup, the protocol π Mal is completely deterministic. This is achieved in <ref type="bibr" target="#b25">[23]</ref> by ensuring that all the randomness used in the protocol, even the one needed for the zero-knowledge proofs, is part of the private components that are distributed by the sampling functionality.<ref type="foot" target="#foot_18">21</ref> -π Mal starts off by having every party broadcast a one-time pad encryption of its input with its (committed) randomness and a NIZK that it knows the input and randomness corresponding to the broadcasted message. -By convention, the next-message function of π Mal is such that if in any round the transcript seen by a party is an aborting transcript, i.e., is not consistent with an accepting run of the semi-honest protocol, then the party outputs ⊥. Recall that the identifiable abort property ensures that in this case every party will also output the identity of a malicious party (the same for all parties). -There is a (known) upper bound on the number ρ c of rounds of π Mal .</p><p>We remark that, given appropriate setup, the IOZ-compiler achieves information-theoretic security, and needs therefore to build information-theoretic commitments and zero-knowledge proofs. As in this work we are only after computational security, we modify the IOZ compiler so that we use (computationally) UC secure one-to-many commitments <ref type="bibr" target="#b15">[14]</ref> and computationally UC secure noninteractive zero-knowledge proofs (NIZKs) instead if their information-theoretic instantiation suggested in <ref type="bibr" target="#b25">[23]</ref>. Both the UC commitment and the NIZKs can be built in the CRS model. Moreover, the use of UC secure instantiations of zero-knowledge and commitments ensures that the resulting protocol will be (computationally) secure. Using the Setup Within a Subset of Parties. A standard property of many protocols in the correlated-randomness model is that once the parties in P have received the setup, any subset P ⊂ P is able to use it to perform a computation of a |P |-party function amongst them while ignoring parties in P \ P . More concretely, assume the parties in P have been handed a setup allowing them to execute some protocol π for computing any |P|-party function f ; then for any P ⊆ P, the parties in P can use their setup within a protocol π| P to compute any |P |-party function f | |P | . This property which will prove very useful for obtaining computation with robustness or compensation, is also satisfied public setup and wants to follow the protocol execution and decide whether it should abort or not given the parties' messages. Looking ahead, the judge's code in the protocol will be used by the ledger to decide whether or not a transaction that claims some committed coins is valid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Special Transactions Supported by Our Ledger</head><p>In this section we specify the Validate and the Blockify predicates that are used for achieving our protocol's properties. More specifically, our protocol uses the following type of transactions which transfer v coins from wallet address i to wallet address j conditioned on a statement Σ:</p><formula xml:id="formula_10">B v,addressi,addressj ,Σ,aux,σi,τ<label>(1)</label></formula><p>where σ i is a signature of the transaction, which can be verified under wallet address i ; τ is the time-stamp, i.e., the current value of the clock when this transaction is added to the state by the ledger-note that this timestamp is added by the ledger and not by the users,-aux ∈ {0, 1} * is an arbitrary string <ref type="foot" target="#foot_19">22</ref> ; and the statement Σ consists of three arguments, i.e., Σ = (arg1, arg2, arg3), which are processed by the Validate predicate in order to decide if the transaction is valid (i.e., if it will be included in the ledger's next block).</p><p>The Validate Predicate. The validation happens by processing the arguments of Σ in a sequential order, where if while processing of some argument the validation rejects, algorithm Validate stops processing at that point and this transaction is dropped. The arguments are defined/processed as follows:</p><p>Time-Restrictions: The first argument is a pair arg1 = (τ -, τ + ) ∈ Z × (Z + ∪ {∞}) of points in time. If τ -&gt; τ + then the transaction is invalid (i.e., it will be dropped by the ledger). Otherwise, before time τ -the coins in the transaction "remain" blocked, i.e., no party can spend them; from time τ -until time τ + , the money can be spent by the owner of wallet address j provided that the spending statement satisfies also the rest of the requirements/arguments in statement Σ (listed below). After time τ + the money can be spent by the owner of wallet address i without any additional restrictions (i.e., the rest of the arguments in Σ are not parsed). As a special case, if τ + = ∞ then the transferred coins can be spent from address j at any point (provided the spending statement is satisfied); we say then that the transaction is timeunrestricted, <ref type="foot" target="#foot_20">23</ref> otherwise we say that the transaction is time restricted. Spending Link: Provided that the processing of the first argument, as above, was not rejecting, the Validate predicate proceeds to the second argument, which is a unique "anchor", arg2 = α ∈ {0, 1} * . Informally, this serves as a unique identifier for linked transactions <ref type="foot" target="#foot_21">24</ref> ; that is, when α =⊥, then the Validate algorithm of the ledger looks in the ledger's state and buffer to confirm that the balance of transactions to/from the wallet address address i with this anchor arg2 is at least v ≥ v coins. That is, the sum of coins in the state or in the buffer with receiver address address i and anchor arg2 minus the sum of coins in the state or in the buffer with sender address address i and anchor arg2 is greater equal to v. If this is not the case then the transaction is rendered invalid; otherwise the validation of this argument succeeds and the algorithm proceeds to the next argument. State-Dependent Condition: The last argument to be validated is arg3, which is a relation R : S × B × T → {0, 1}, where S, B, and T are the domains of possible ledger-states, ledger-buffers, and transactions, respectively (in a given encoding). This argument defines which type of transactions can spend the coins transferred in the current transaction. That is, in order to spend the coins, the receiver needs to submit a transaction tx ∈ T such that R(state, buffer, tx) = 1 at the moment when tx is to be validated and inserted in the buffer. In our construction this is the part of the transaction that we will take advantage to detect cheating (and thus R will encode a NIZK verifier etc.).</p><p>We point out that as with standard Bitcoin transactions, the validation predicate will always also check validity of the signature σ i with respect to the wallet address i . Moreover, the standard Bitcoin-like transactions can be trivially casted as transactions of the above type by setting α =⊥ and Σ = ((0, ∞), ⊥ , R ∅ ), where R ∅ denotes the relation which is always true.</p><p>To simplify the structure of our special transactions and ease their implementation, we impose the following additional constraints: whenever a timerestriction is given, i.e., arg 1 = (τ -, τ + ) then it must be that α = ⊥. Furthermore, if a time-restricted transaction is present with anchor α from address 1 to address 2 , the only transactions that are permitted with anchor α in the ledger would be time-unrestricted transactions originating from either address 2 within the specified time-window, or address 1 after the specified time window.</p><p>The BlockifyAlgorithm. This algorithm simply groups transactions in the current buffer and adds a timestamp from the current round. We choose to ignore any additional functionality (e.g., such as a reward mechanism for mining that is present in typical cryptocurrencies -however such mechanism can be easily added independently of our results).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">The Protocol</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let π +1</head><p>Mal denote the protocol described in Sect. 5.1. Let Round2Time(1) denote the time in which the parties have agreed to start the protocol execution. Without loss of generality we assume that Round2Time(1) &gt; T + 1 where T is the number clock ticks for each block generation cf. Fig. <ref type="figure" target="#fig_0">2</ref>. <ref type="foot" target="#foot_22">25</ref> Furthermore, for simplicity, we assume that each party P i receives its input x i with its first activation from the environment at time Round2Time(1) (if some honest party does not have an input by that time it will execute the protocol with a default input, e.g., 0).</p><p>Informally, the protocol proceeds as follows: In a pre-processing step, before the parties receive input, the parties invoke the sampling functionality for π +1 Mal to receive their correlated randomness. <ref type="foot" target="#foot_23">26</ref> The public component of this randomness includes their protocol-associated wallet address i which they output (to the environment). This corresponds to the resources allocation step in the Q-robustness wrapper Ŵ. The environment is then expected to submit ρ c special (as above) transactions for each pair of parties P i ∈ P and P j ∈ P; the source wallet-address for each such transaction is P i 's, i.e., address i and the target wallet-address for is P j 's, i.e., address j , and the corresponding anchors are as follows: α i,j,ρ = (pid, i, j, ρ), for (i, j, ρ)</p><formula xml:id="formula_11">∈ [n] 2 × [ρ c ],</formula><p>where <ref type="foot" target="#foot_24">27</ref> pid is the (G)UC protocol ID for π +1</p><p>Mal . Since by assumption, Round2Time(1) &gt; T + 1, the environment has sufficient time to submit these transaction so that by the time the protocol starts they have been posted on the ledger.</p><p>At time Round2Time(1) the parties receive their inputs and initiate the protocol execution by first checking that sufficient funds are allocated to their wallets linked to the protocol executions by appropriate anchors, as above. If some party does not have sufficient funds then it broadcasts an aborting message and all parties abort. <ref type="foot" target="#foot_25">28</ref> This aborting in case of insufficient funds is consistent with the behavior of the wrapper Ŵ when Q C-Init Ḡ is false. Otherwise, parties make the special transactions that commit them (see below) into executing the protocol, and then proceed into claiming them one-by-one by executing their protocol in a round-by-round fashion.</p><p>Note that each protocol round lasts one ledger round so that the parties have enough time to claim their transactions. This means that Round2Time(i + 1) -Round2Time(i) ≥ T, which guarantees that any transaction submitted for round ρ, ρ = 1, . . . , ρ c -1, of the protocol, has been posted on the ledger by the beginning of round ρ + 1. Observe that by using a constant round protocol π +1</p><p>Mal (e.g., the modified compiled protocol from <ref type="bibr" target="#b25">[23]</ref> instantiated with a constant round semi-honest protocol) we can ensure that our protocol will terminate in a constant number of ledger rounds and every honest party will either receive its input, or will have a positive balance in its wallet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 1 (On availability of funds).</head><p>Unlike existing works, we choose to explicitly treat the issue of how funds become available to the protocol by making the off-line transfers external to the protocol itself (i.e., the environment takes care of them). However, the fact that the environment is in charge of "pouring" money into the wallets that are used for the protocol does not exclude that the parties might be actually the ones having done so. Indeed, the environment's goal is to capture everything that is done on the side of, before, or after the protocol, including other protocols that the parties might have participated in. By giving the environment enough time to ensure these transactions are posted we ensure that some honest party not having enough funds corresponds to an environment that makes the computation abort (in a fair way and only in the pre-processing phase, before the parties have invested time into posting protocol transactions).</p><p>Here is how we exploit the power of our special transactions in order to arrange that the balance of honest parties is positive in case of an abort. We require that the auxiliary string of a transaction of a party P j which claims a committed transaction for some round ρ includes his ρ-round protocol message. We then have the relation of this transaction be such that it evaluates to 1 if only if this is indeed P j 's next message. Thus, effectively the validate predicate implements the judge in π +1</p><p>Mal and can, therefore, decide if some party aborted: if some party broadcasts a message that would make the judge abort, then the validate predicate drops the corresponding transaction and all claims for committed transactions corresponding to future rounds, thus, all other parties are allowed to reclaim their committed coins starting from the next round.</p><p>Before we give the protocol description there is a last question: how is the ledger able to know which parties should participate in the protocol? Here is the problem: The adversary might post in the first round (as part of the committing transaction for the first round) a fake, maliciously generated setup. Since the ledger is not part of the correlated randomness sampling, it would be impossible to decide which is the good setup. We solve this issue by the following technique that is inspired by <ref type="bibr" target="#b5">[6]</ref>: The ledger <ref type="foot" target="#foot_26">29</ref> groups together parties that post the same setup; these parties form "islands", i.e., subsets of P. For each such subset P ⊆ P ∪ {P n+1 } which includes the judge P n+1 , the ledger acts as if the parties in P are executing the protocol π +1</p><p>Mal | P (which, recall, is the restriction of π +1 Mal to the parties in P ) for computing the |P |-party function f +1 | P (x) defined as follows: let the function to be computed be f (x), where x = (x 1 , . . . , x n ), and f +1 be as above, then f +1 | P (x) = f +1 (x P ) where x P = (x 1 , . . . , x n ) with x i = x i for P i ∈ P and x i being a default value for every P i ∈ P . This solves the problem as all honest parties will be in the same island P ⊂ P (as they will all post the same value for public randomness); thus if the adversary chooses not to post this value on behalf of some corrupted party, he is effectively setting this party's input to a default value, a strategy which is easily simulatable. (Of course, the above solution will allow the adversary to also have "islands" of only corrupted parties that might execute the protocol, but this is also a fully simulatable strategy and has no effect on fair-compensation whatsoever-corrupted parties are not required to have a positive balance upon abort).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The final protocol π B</head><p>Mal is detailed in the following. The protocol ID is sid. The function to be computed is f (x 1 , . . . , x n ). The protocol parties are P = {P 1 , . . . , P n }. We assume all parties have registered with the clock functionality in advance and are therefore synchronized once the following steps start.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Phase 1: Setup Generation</head><formula xml:id="formula_12">Time τ -2 = Round2Time(1) -T -2:</formula><p>The parties invoke the sampling functionality for D Mal , i.e., every party P i ∈ P starts off by sending the sampling functionality a message (request, sid); the sampling functionality returns (R priv i , R pub ) to P i where R priv i is P i 's private component (including all random coins he needs to run the protocol, along with his signing key sk i ) of the setup and R pub is the public component (the same for every party P j ) which includes the vector of UC commitments (Com 1 , . . . , Com n ), where for j ∈ [n], Com j is a commitment to R priv j , along with a vector of public (verification) keys (vk 1 , . . . , vk n ) corresponding to the signing keys (sk 1 , . . . , sk n ) and a common reference string CRS. Every party outputs its own public key, as its wallet address for the protocol, i.e., address i = vk i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Phase 2: Inputs and Protocol Execution</head><p>Time τ -1 = Round2Time(1) -1: Every party P i ∈ P receives its input x i (x i = 0 if no input is received in the first activation of P i for time Round2Time(1)) and does the following to check that it has sufficient fund available: P i reads the current state from the ledger. If the state does not include for each (i, j, ρ) ∈ [n] 2 × [ρ c ] a transaction B c,address,addressi,Σ 0 i,j,ρ ,aux 0 i,j,ρ ,σ,τ , for some arbitrary address and where Σ 0 i,j,ρ = ((0, ∞), (sid, i, j, ρ), R ∅ ) then P i broadcasts ⊥ and every party aborts the protocol execution with output ⊥ (i.e., no party does anything from that point on. Recall that ρ c is the upper bound on the number of rounds of π +1 Mal , cf. Sect. 5.1. Time τ 0 = Round2Time(1):</p><p>Every P i submits to the ledger the following "commitment" transactions: <ref type="foot" target="#foot_27">30</ref>1. For each P j ∈ P : B c,addressi,addressj ,Σi,j,1,auxi,j,1,σ,τ , where aux i,j,1 = R pub and Σ i,j,1 = (arg1 i,j,1 , arg2 i,j,1 , arg3 i,j,1 ) with -arg1 i,j,1 = (Round2Time(1) + T, Round2Time(1) + 2T -1) -arg2 i,j,1 = (sid, i, j, 1) -arg3 i,j,1 = R i,j,1 defined as follows: Let P +1 = P ∪ {P n+1 }, where P n+1 denotes the judge, be the player set implicit in R pub , <ref type="foot" target="#foot_28">31</ref> and let P +1 i ⊆ P +1 denote the island of party i including the judge, i.e., the set of parties (wallets), such that in the first block posted after time Round2Time(1) all parties P k ∈ P +1 i have exactly one transaction for every P j ∈ P with arg1 k,j,1 = (Round2Time(1) + T, Round2Time(1) + 2T -1), arg2 k,j,1 = (sid, k, j, 1), and aux , and transcript (aux i1,1 , . . . , aux im,1 ), . . . , (aux i1,ρ-1 , . . . , aux im,ρ-1 ) for the first r -1 rounds does not abort, then compute P i 's message for round ρ, denoted as msg ρ , and submit to the ledger for each P k ∈ P +1 i a transaction B c,addressi,address,Σ k,i,ρ ,aux ρ k,i,ρ ,σ,τ , where aux ρ k,i,ρ = msg ρ , address is the address that was the input of the first transaction with link (sid, i, k, ρ) and Σ k,i,ρ = (arg1, arg2, arg3) instantiated as follows: arg1 = (0, ∞); arg2 = (sid, k, i, ρ); arg3 = R ∅ . For each such transaction posted enter (sid, k, i, ρ) in a set of "claimed" transactions CLAIM i . 4. Otherwise, i.e., if the state state is aborting, then prepare for each round r = 1, . . . , ρ -1, and each P k ∈ P a transaction by which the committed transaction towards P k corresponding to round r is claimed back to address i , i.e., B c,address k ,addressi,Σ,aux,σ,τ , where aux =⊥ and Σ = (arg1, arg2, arg3) instantiated as follows: arg1 = (0, ∞); arg2 = (sid, i, k, r); arg3 = R ∅ . The above transaction is posted as long as it is not claimed already, i.e., (sid, i, k, r) ∈ CLAIM i in a previous step.</p><p>This completes the description of the protocol. The protocol terminates in O(ρ c ) ledger rounds. A depiction of the transactions that are associated with a protocol round is given in Fig. <ref type="figure" target="#fig_2">4</ref>. Observe that by using a constant-round protocol π Mal <ref type="bibr" target="#b25">[23]</ref>, we obtain a protocol with constantly many ledger rounds. Furthermore, as soon as an honest party posts a protocol-related transaction, he is guaranteed to either receive his output or have a positive balance (of at least c coins) after O(ρ c ) ledger rounds. The following theorem states the achieved security. We assume the protocol is executed in the synchronous model of Sect. Proof (sketch). We first prove that the above protocol is simulatable, by sketching the corresponding simulator S. If the protocol aborts already before the parties make their transactions, then the simulator can trivially simulate such an abort, as he needs to just receive the state of the ledger and see if all wallets corresponding to honest parties have sufficient funds to play the protocol. In the following we show that the rest of the protocol (including the ledger's contents) can be simulated so that if there is an abort, honest parties' wallets have a positive balance as required by Q fairness. First we observe that the simulator S can easily decide the islands in which the parties are split, as he internally simulates the sampling functionality. Any island other than the one of honest parties (all honest parties will be in the same island because they will post transactions including the same public setup-component) is trivially simulatable as it only consists of adversarial parties and no guarantee is given about their wallets by Q-fairness. Therefore, it suffices to provide a simulator for the honest parties' island. To this direction, the simulator uses the simulator S π +1 Mal which is guaranteed to exist from the security of π +1</p><p>Mal to decide which messages to embed in the transactions of honest parties (the messages corresponding to corrupted parties are provided by the adversary). If S π +1 Mal would abort, then S interacts the ideal functionality to abort and continues by claiming back all the committed transactions to the honest parties' wallets, as the protocol would. The soundness of the simulation of S π +1 Mal ensure that the output of the parties and the contents of the ledger in the real and the ideal world are indistinguishable.</p><p>The fact that the protocol will eventual terminate given sufficient rounds of activating every party (i.e., in the terminology of Definition 2, given a sufficiently high threshold T ) follows by inspection of the protocol: in each round every party needs at most a (fixed) polynomial number of activations to post the transactions corresponding to his current-round message-vector. (In fact, the polynomial is only needed in the initial committing-transactions round and from that point on it is linear). To complete the proof, we argue that (1) when the protocol does not abort, every honest party has a non-negative balance, and (2) when the protocol aborts, then honest parties have a positive balance of at least c coins as required by predicate Q for the simulator to be able to complete its simulation and deliver the (possibly aborting) outputs. These properties are argued as follows:</p><p>Property (1): The parties that are not in the honest parties' islands cannot claim any transaction that honest parties make towards them as the ledger will see they as not in the island and reject them. Thus by the last round every honest party will have re-claimed all transactions towards parties not in his island. As far as parties in the honest island are concerned, if no abort occurs then every party will claim all the transactions from parties in his island, and therefore his balance will be 0. Property (2): Assume that the protocol aborts because some (corrupted) P i broadcasts an inconsistent message in some round ρ. By inspection of the protocol one can verify that honest parties will be able to claim all transactioncommitments done to them up to round ρ (as they honestly execute their protocol) plus all committed transactions that they made for rounds ρ + 1 . . . , ρ c . Additionally, because P i broadcasts an inconsistent message in round ρ, he will be unable to claim transactions of honest parties done from round ρ and on; these bitcoins will be reclaimed by the honest parties, thus giving their wallets a positive balance of at least c coins.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The public ledger functionality.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The Q-Fairness wrapper functionality.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The transactions associated with the first round r of our protocol compiler. Ri(•) is a relation which is true given the r-th round message of Pi (for the given correlated randomness and previous messages); mi is the message of player Pi for round r. Player 3 aborts in the r-th round of the protocol and players 1,2 collect their reward.</figDesc><graphic coords="27,89.46,162.56,274.03,189.07" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>3 . 1 . 3 .</head><label>313</label><figDesc>Theorem Let Ḡ = ( Ḡledger , Ḡclock ), The above protocol in the ( Ḡ, F DMal corr )hybrid world realizes W(F) with robust compensation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Functionality Ḡledger Shared functionality Ḡledger is globally available to all participants. The shared functionality is parameterized with a predicate Validate, a constant T, and variables state, buffer and counter. Initially, state := ε, buffer := ε, and counter := 0. (buffer, tx)) = 1, then set buffer := buffer||tx. Go to State Extend. -Upon receiving (read, sid) from a party P or A, if P is honest set b = state else set b = (state, buffer). 1. Execute State Extend. 2. Return (read, sid, b) to the requestor. -Upon receiving (permute, sid, π) from A apply permutation π on the elements of buffer.</figDesc><table><row><cell>-Upon</cell><cell>receiving</cell><cell>(submit, sid, tx)</cell><cell>from</cell><cell>some</cell><cell>participant,</cell><cell>If</cell></row><row><cell cols="2">Validate(state,</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>State Extend: Send (clock-read, sid) to Ḡclock and receive (clock-read, sid, τ) from Ḡclock. If |τ -T • counter| &gt; T, then set state := state||Blockify(τ, buffer) and buffer := ε and counter := counter + 1. Subsequently, send (clock-update, sid) to Ḡclock where sid is the ID of Ḡclock.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>(state, buffer, tx) = 1 if and only if the protocol of the judge with public setup R pub | P +1 i accepts the auxiliary string aux tx in tx as P i 's first message in Then R i,j,ρ (state, buffer, tx) = 1 if and only if, for each r = 1, . . . , ρ -1 and each party P i k ∈ P +1 i , the state state includes transactions in which the auxiliary input is aux i k ,r and the protocol of the judge with public setup R pub | P +1 i , and transcript (aux i1,1 , . . . , aux im,1 ), . . . , (aux i1,ρ-1 , . . . , aux im,ρ-1 ), accepts the auxiliary string aux in tx as P i 's next (ρ-round) message in π +1Mal | P +1 im }, i.e., it includes for each r = 1, . . . , ρ -1 and each party P i k ∈ P +1 i a transaction in which the auxiliary input is aux i k ,r such that P i executing π +1Mal | P +1 i with public setup R pub | P +1</figDesc><table><row><cell cols="2">1 k,j,1 = R pub . Furthermore,</cell></row><row><cell cols="2">let π +1 Mal | P +1 i f +1 | P +1 i , described above and denote by R pub | P +1 be the protocol with public identifiability for computing the restriction of the i public setup to the parties in P +1 i . Then R i,j,1 π +1 Mal | P +1 (i.e., it does not abort in the first round). i 2. For each protocol round ρ = 2, . . . , ρ c and each P j ∈ P: each party posts</cell></row><row><cell cols="2">the transaction: B c,addressi,addressj ,Σi,j,ρ,aux 1 i,j,ρ ,σ,τ , where aux 1 i,j,ρ = R pub</cell></row><row><cell>and Σ i,j,ρ = (arg1, arg2, arg3) with</cell><cell></cell></row><row><cell cols="2">-arg1 = (Round2Time(ρ) + T, Round2Time(ρ + 1) + 2T -1)</cell></row><row><cell>-arg2 = (sid, i, j, ρ).</cell><cell></cell></row><row><cell>-arg3 = R i,j,ρ defined as follows: Let P +1 i , π +1 Mal | P +1 i (and assume P +1</cell><cell>be defined as above</cell></row></table><note><p><p><p><p><p><p><p>i</p>= {P i1 , . . . , P im }. i (i.e., it does not abort in the ρ-th round).</p>Phase 3: Claiming Committed Transactions/Executing the Protocol</p>Time τ ≥ Round2Time(1):</p>For each ρ = 1, . . . , ρ c +1, every P i does the following at time Round2Time(ρ):</p>1. If τ = Round2Time(ρ c + 1)</p>then go to Step 4; otherwise do the following: 2. Read the ledger's state, and compute P +1 i , π +1 Mal | P +1 i as above. 3. If the state state is not aborting for P +1 i = {P i1 , . . . , P i , private setup R priv i</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that this feature is currently not fully supported.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>An ITM with the special features of "wallet" and "safe" was introduced in<ref type="bibr" target="#b7">[7]</ref> to express the ability of ITM's to store and transfer "coins." Such coins were treated as physical quantities that were moved between players but also locked in safes in a way that parties were then prevented to use them in certain ways (in other words such safes were not local but were affected from external events).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://www.ethereum.org.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Certain global functionalities, such as the ledger defined in the following section, might depend on time and, therefore, need to be synchronized with the clock.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>The communication channels we are using are fetch-type bounded delivery channels as in<ref type="bibr" target="#b26">[24]</ref>. In such channels, the receiver needs to issue "fetch"-requests which are answered only if a message is ready for delivery. We refer to<ref type="bibr" target="#b26">[24]</ref> for details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Different protocols might proceed at a different pace.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>One can make any synchronous protocol have this form by introducing dummy instructions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>This is essential to ensure that updates are done in a time-consistent manner.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>We note that whenever it is clear from the context we may drop the subscript Ḡ inQ Ḡ , Q Init Ḡ , Q Dlv Ḡ , Q Abt Ḡ .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>A non-reactive functionality does not accept any input from honest parties after generating output.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>Delayed output delivery is a standard (G)UC mechanism where the adversary is allowed to schedule the output at a time of its choosing.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>In the case of bitcoin-like ledgers these will correspond to a wallet (public-key) and a corresponding secret key.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_12"><p>In the case of a bitcoin-ledger this corresponds to the environment not transferring to some protocol-related wallet sufficient funds to execute the protocol.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_13"><p>As we will see, in bitcoin-like instantiations, Q Dlv will be satisfied when no honest party has a negative balance, and Q Abt will be satisfied when every honest party has a (strictly) positive balance.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_14"><p>In GUC framework<ref type="bibr" target="#b12">[11]</ref>, this is also called, Ḡ-subroutine respecting.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_15"><p>That is, we want to ensure that if the functionality F has guaranteed termination then the wrapped functionality will also have guaranteed termination.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_16"><p>Of course, the simulator needs to be given sufficiently many activation so that he can provide its own inputs and perform the simulation (please see<ref type="bibr" target="#b26">[24]</ref> for details).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="20" xml:id="foot_17"><p>These are commitments that can be opened so that every party agrees on whether or not the opening succeeded.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="21" xml:id="foot_18"><p>As an example, the challenge for the zero-knowledge proofs is generated by the parties opening appropriate parts of their committed random strings.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_19"><p>This string will be included to the Ledger's state as soon as the transaction is posted and can be, therefore, referred to by other spending statements.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="23" xml:id="foot_20"><p>This is the case with standard Bitcoin transactions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="24" xml:id="foot_21"><p>Looking ahead arg2 will be used to point to specific transactions of a protocol instance. The mechanism may be simulated by generating multiple addresses however it is more convenient for the protocol description and for this reason we adopt it.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="25" xml:id="foot_22"><p>That is we assume that at least one ledger rounds plus one extra clock-ticks have passed from the beginning of the time.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="26" xml:id="foot_23"><p>In an actual application, the parties will use an unfair protocol for computing the correlated randomness. As this protocol has no inputs, an abort will not be unfair (i.e., the simulator can always simulate the view of the adversary in an aborting execution.).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="27" xml:id="foot_24"><p>Recall that we assume |P| = n.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="28" xml:id="foot_25"><p>Note that this is a fair abort, i.e., no party has spent time into making transactions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="29" xml:id="foot_26"><p>Throughout the following description, we say that the ledger does some check to refer to the process of checking a corresponding relation, as part of validating a special transaction.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="30" xml:id="foot_27"><p>Recall that, by definition of the clock, every party has as much time as it needs to complete all the steps below before the clock advances time.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="31" xml:id="foot_28"><p>Recall that R pub includes commitments to all parties' private randomness (including the judge's P d ) used for running the protocol, which is an implicit representation of the player set.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. The first author was supported by ERC project CODAMODA # 259152, and the third author was supported partly by the Swiss National Science Foundation (SNF) Ambizione grant PZ00P2-142549. This work was done (in part) while the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467 and (in part) when visiting the National Kapodistrian University of Athens. The authors thank Andrew Miller for helpful discussions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>by the IOZ protocol, as the parties in P can simply ignore the commitments (public setup component) corresponding to parties in P\P . It should be noted that this is not an inherent property of the correlated randomness model: e.g., protocols based on threshold encryption do not immediately satisfy this property (as players would have to readjust the threshold).</p><p>Making Identifiability Public. The general idea of our protocol is to have every party issue transactions by which he commits to transferring a certain amount of coins per party for each protocol round. All these transactions are issued at the beginning of the protocol execution. Every party can claim the "committed" coins transferred to him associated to some protocol round ρ only under the following conditions: (1) the claim is posted in the time-interval corresponding to round ρ; (2) the party has claimed all his transferred coins associated to the previous rounds; and <ref type="bibr" target="#b2">(3)</ref> the party has posted a transaction which includes his valid protocol message for round ρ.</p><p>In order to ensure that a party cannot claim his coins unless he follows the protocol, the ledger (more concretely the validation predicate) should be able to check that the party is indeed posting its valid next message. In other words, in each round ρ, P i 's round-ρ message acts as a witness for P i claiming all the coins committed to him associated with this round ρ. To this direction we make the following modification to the protocol: Let f (x 1 , . . . , x n ) = (y 1 , . . . , y n ) denote the n-party function we wish to compute, and let f +1 be the (n + 1)-party function which takes input x i from each P i , i ∈ [n], and no input from P n+1 and outputs y i to each P i and a special symbol (e.g., 0) to P n+1 . Clearly, if π SH is a semi-honest n-party protocol for computing f over broadcast, then the n + 1 protocol π +1 SH (in which every P i with i ∈ [n] executes π SH and P n+1 simply listens to the broadcast channel and outputs 0) is a semi-honest secure protocol for f +1 . Now if π +1 Mal denotes the (n + 1)-party malicious protocol which results by applying the above modified IOZ compiler on the (n + 1)-party semi-honest protocol π +1 SH for computing the function f +1 , then, by construction this protocol computes function f +1 with identifiable abort and has the following additional properties:</p><p>-Party P n+1 does not make any use of his private randomness whatsoever; this is true because he broadcasts no messages and simply verifies the broadcasted NIZKs. -If some party P i , i ∈ [n] deviates from running π SH with the correlated (committed) randomness as distributed from the sampling functionality, then this is detected by all parties, including P n+1 (and protocol π +1 Mal aborts identifying P i as the offender). This follows by the soundness of the NIZK which P i needs to provide proving that he is executing π SH in every round.</p><p>Due to P n+1 's role as an observer who gets to decide if the protocol is successful (P n+1 outputs 0) or some party deviated (P n+1 observes that the corresponding NIZK verification failed) in the following we will refer to P n+1 in the above protocol as the judge. The code of the judge can be used by anyone who has the</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fair two-party computations via the bitcoin deposits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andrychowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dziembowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Malinowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mazurek</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2013/837" />
	</analytic>
	<monogr>
		<title level="j">1st Workshop on Bitcoin Research</title>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
	<note>Assocation with Financial Crypto</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Secure multiparty computations on bitcoin</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andrychowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dziembowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Malinowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mazurek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2014-05">May 2014</date>
			<biblScope unit="page" from="443" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fair and efficient secure multiparty computation with reputation systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Asharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zarosim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2013, Part II</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8270</biblScope>
			<biblScope unit="page" from="201" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Optimistic protocols for fair exchange</title>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 1997</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997-04">April 1997</date>
			<biblScope unit="page" from="7" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Optimistic fair exchange of digital signatures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1998</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1403</biblScope>
			<biblScope unit="page" from="591" to="606" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Secure computation without authentication</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2005</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="361" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">How to use bitcoin to design fair protocols</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2014, Part II</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">8617</biblScope>
			<biblScope unit="page" from="421" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Timed commitments</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2000</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1880</biblScope>
			<biblScope unit="page" from="236" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Optimistic fair secure computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Camenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2000</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1880</biblScope>
			<biblScope unit="page" from="93" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Universally composable security: a new paradigm for cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">42nd FOCS</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001-10">October 2001</date>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Universally composable security with global setup</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2007</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4392</biblScope>
			<biblScope unit="page" from="61" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Universally composable commitments</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2001</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="19" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Practical UC security with a global random oracle</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scafuro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<editor>
			<persName><forename type="first">G.-J</forename><surname>Ahn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Li</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2014-11">2014. November 2014</date>
			<biblScope unit="page" from="597" to="608" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Universally composable twoparty and multi-party secure computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th ACM STOC</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002-05">May 2002</date>
			<biblScope unit="page" from="494" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Universal composition with joint state</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2003</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="265" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Limits on the security of coin flips when half the processors are faulty (extended abstract)</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cleve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Hartmanis</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="364" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A little honesty goes a long way</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gelles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2015, Part I. LNCS</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9014</biblScope>
			<biblScope unit="page" from="134" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Rational protocol design: cryptography against incentive-driven adversaries</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Tackmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Zikas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th FOCS</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2013-10">October 2013</date>
			<biblScope unit="page" from="648" to="657" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Resource fairness and composability of cryptographic protocols</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2006</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3876</biblScope>
			<biblScope unit="page" from="404" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<title level="m">Foundations of Cryptography: Basic Tools</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">How to play any mental game or a completeness theorem for protocols with honest majority</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th ACM STOC</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Aho</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1987-05">May 1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Complete fairness in multi-party computation without an honest majority</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2009</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Secure multi-party computation with identifiable abort</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Zikas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2014, Part II</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8617</biblScope>
			<biblScope unit="page" from="369" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Universally composable synchronous computation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Tackmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Zikas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2013</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7785</biblScope>
			<biblScope unit="page" from="477" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Fair and robust multi-party computation using a global transaction ledger</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-S</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Zikas</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2015/574" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">574</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
	<note>Report</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Hawk: The blockchain model of cryptography and privacy-preserving smart contracts</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2015/675" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2015">2015/675. 2015</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">How to use bitcoin to incentivize correct computations</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kumaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 2014</title>
		<editor>
			<persName><forename type="first">G.-J</forename><surname>Ahn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Li</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2014-11">November 2014</date>
			<biblScope unit="page" from="30" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Bitcoin: A peer-to-peer electronic cash system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nakamoto</surname></persName>
		</author>
		<ptr target="http://bitcoin.org/bitcoin.pdf" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Fair secure two-party computation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2003</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="87" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Liar, liar, coins on fire!: penalizing equivocation by loss of bitcoins</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ruffing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 2015</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Ray</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Li</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2015-10">October 2015</date>
			<biblScope unit="page" from="219" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Protocols for secure computations (extended abstract)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd FOCS</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1982-11">November 1982</date>
			<biblScope unit="page" from="160" to="164" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
