<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PEREGRINE: A Pattern-Aware Graph Mining System *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2020-04-06">6 Apr 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kasra</forename><surname>Jamshidi</surname></persName>
							<email>kjamshid@cs.sfu.ca</email>
						</author>
						<author>
							<persName><forename type="first">Rakesh</forename><surname>Mahadasa</surname></persName>
							<email>rmahadas@cs.sfu.ca</email>
						</author>
						<author>
							<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University British Columbia</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University British Columbia</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University British Columbia</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">PEREGRINE: A Pattern-Aware Graph Mining System *</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2020-04-06">6 Apr 2020</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:2004.02369v1[cs.DC]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graph mining workloads aim to extract structural properties of a graph by exploring its subgraph structures. General purpose graph mining systems provide a generic runtime to explore subgraph structures of interest with the help of userdefined functions that guide the overall exploration process. However, the state-of-the-art graph mining systems remain largely oblivious to the shape (or pattern) of the subgraphs that they mine. This causes them to: (a) explore unnecessary subgraphs; (b) perform expensive computations on the explored subgraphs; and, (c) hold intermediate partial subgraphs in memory; all of which affect their overall performance. Furthermore, their programming models are often tied to their underlying exploration strategies, which makes it difficult for domain users to express complex mining tasks.</p><p>In this paper, we develop PEREGRINE, a pattern-aware graph mining system that directly explores the subgraphs of interest while avoiding exploration of unnecessary subgraphs, and simultaneously bypassing expensive computations throughout the mining process. We design a patternbased programming model that treats graph patterns as first class constructs and enables PEREGRINE to extract the semantics of patterns, which it uses to guide its exploration. Our evaluation shows that PEREGRINE outperforms state-ofthe-art distributed and single machine graph mining systems, and scales to complex mining tasks on larger graphs, while retaining simplicity and expressivity with its 'pattern-first' programming approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Graph mining based analytics has become popular across various important domains including bioinformatics, computer vision, and social network analysis <ref type="bibr" target="#b16">[3,</ref><ref type="bibr" target="#b22">9,</ref><ref type="bibr" target="#b41">28,</ref><ref type="bibr" target="#b49">36,</ref><ref type="bibr" target="#b54">41,</ref><ref type="bibr" target="#b72">59</ref>]. These tasks mainly involve computing structural properties of the graph, i.e., exploring and understanding the substructures within the graph. Since the search space is exponential, graph mining problems are computationally intensive and their solutions are often difficult to program in a parallel or distributed setting.</p><p>Table <ref type="table">1</ref>. PEREGRINE performance summary. PRG-U indicates PEREGRINE without symmetry breaking, to model systems that are not fully pattern-aware (e.g., AutoMine).</p><p>To address these challenges, general-purpose graph mining systems like Arabesque <ref type="bibr" target="#b65">[52]</ref>, RStream <ref type="bibr" target="#b70">[57]</ref>, Fractal <ref type="bibr" target="#b25">[12]</ref>, G-Miner <ref type="bibr" target="#b21">[8]</ref> and AutoMine <ref type="bibr" target="#b47">[34]</ref> provide a generalized exploration framework and allow user programs to guide the overall exploration process. At the heart of these graph mining systems is an exploration engine that exhaustively searches subgraphs of the graph, and a series of filters that prune the search space to continue exploration for only those subgraphs that are of interest (e.g., ones that match a specific pattern) and are unique (to avoid redundancies coming from structural symmetries). The exploration happens in a step-by-step fashion where small subgraphs are iteratively extended based on their connections in the graph. As these subgraphs are explored, they get verified via canonicality checks to guarantee uniqueness, and get analyzed via isomorphism computations to understand their structure (or pattern). After that, the subgraphs either get pruned out because they don't match the pattern of interest, or are forwarded down the pipeline where their information is aggregated at the pattern level.</p><p>While such an exploration process is general enough to compute different mining use cases including Frequent Subgraph Mining and Motif Counting, we observe that it remains largely oblivious to the patterns that are being mined. Hence, state-of-the-art graph mining systems face three main issues, as described next: (1) These systems perform a large number of unnecessary computations; specifically, every subgraph explored from the graph, even in intermediate steps, is processed to ensure canonicality, and is analyzed to either extract its pattern or to verify whether it is isomorphic to another pattern. Since the exploration space for graph mining use cases is very large, performing those computations on every explored subgraph severely limits the performance of these systems. <ref type="bibr" target="#b15">(2)</ref> The exhaustive exploration in these systems ends up generating a large amount of intermediate subgraphs that need to be held (either in memory or on disk) so that they can be extended. While systems based on breadth-first exploration <ref type="bibr" target="#b65">[52,</ref><ref type="bibr" target="#b70">57]</ref> demand high memory capacity, other systems like Fractal <ref type="bibr" target="#b25">[12]</ref> and AutoMine <ref type="bibr" target="#b47">[34]</ref> use guided exploration strategies to reduce this impact; however, because they are not fully pattern-aware, they process a large number of intermediate subgraphs which severely limits their scalability as graphs grow large. <ref type="bibr" target="#b16">(3)</ref> The programming model in these systems is strongly tied to the underlying exploration strategy, which makes it difficult for domain experts to express complex mining use cases. For example, subgraphs containing certain pairs of strictly disconnected vertices (i.e., absence of edges) are useful for providing recommendations based on missing edges; mining such subgraphs with constraints on their substructure cannot be directly expressed in any of the existing systems.</p><p>In this paper, we take a 'pattern-first' approach towards building an efficient graph mining system. We develop PEREGRINE 1 , a pattern-aware graph mining system that directly explores the subgraphs of interest while avoiding exploration of unnecessary subgraphs, and simultaneously bypassing expensive computations (isomorphism and canonicality checks) throughout the mining process. PEREGRINE incorporates a pattern-based programming model that enables easier expression of complex graph mining use cases, and reveals patterns of interest to the underlying system. Using the pattern information, PEREGRINE efficiently mines relevant subgraphs by performing two key steps. First, it analyzes the patterns to be mined in order to understand their substructures and to generate an exploration plan describing how to efficiently find those patterns. And then, it explores the data graph using the exploration plan to guide its search and extract the subgraphs back to the user space.</p><p>Our pattern-based programming model treats graph patterns as first class constructs: it provides basic mechanisms to load, generate and modify patterns along with interfaces to query patterns in the data graph. Furthermore, we introduce two novel abstractions, an ANTI-EDGE and an ANTI-VERTEX, that express advanced structural constraints on patterns to be matched. This allows users to directly operate on patterns and express their analysis as 'pattern programs' on PEREGRINE. Moreover, it enables PEREGRINE to extract the semantics of patterns which it uses to generate efficient exploration plans for its pattern-aware processing model.</p><p>We rely on theoretical foundations from existing subgraph matching research <ref type="bibr" target="#b18">[5,</ref><ref type="bibr" target="#b29">16]</ref> to generate our exploration plans. Since PEREGRINE directly finds the subgraphs of interest, it does not incur additional processing over those subgraphs throughout its exploration process; this directly results in much lesser computation compared to the state-of-the-art graph mining systems. Moreover, PEREGRINE does not maintain intermediate partial subgraphs in memory, resulting in much lesser memory consumption compared to other systems. 1 PEREGRINE source code: https://github.com/pdclab/peregrine PEREGRINE runs on a single machine and is highly concurrent. We demonstrate the efficacy of PEREGRINE by evaluating it on several graph mining use cases including frequent subgraph mining, motif counting, clique finding, pattern matching (with and without structural constraints), and existence queries. Our evaluation on real-world graphs shows that PEREGRINE running on a single 16-core machine outperforms state-of-the-art distributed graph mining systems including Arabesque <ref type="bibr" target="#b65">[52]</ref>, Fractal <ref type="bibr" target="#b25">[12]</ref> and G-Miner <ref type="bibr" target="#b21">[8]</ref> running on a cluster with eight 16-core machines; and significantly outperforms RStream <ref type="bibr" target="#b70">[57]</ref> running on the same machine. Furthermore, PEREGRINE could easily scale to large graphs and complex mining tasks which could not be handled by other systems. Table <ref type="table">1</ref> summarizes PEREGRINE's performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background &amp; Motivation</head><p>We first briefly review graph mining fundamentals, and then discuss performance and programmability issues in state-ofthe-art graph mining systems. In the end, we give an overview of PEREGRINE's pattern-aware mining techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Graph Mining Overview</head><p>Graph Terminology. Given a graph д, we use V (д) and E(д) to denote its set of vertices and edges respectively. If the graph is labeled, we use L(д) to denote its set of labels. A subgraph s of д is a graph containing a subset of edges in д and their endpoints.</p><p>Graph Mining Model. Graph mining problems involve finding subgraphs of interest in a given input graph. We use P to denote the pattern graph (representing structure of interest) and G to denote the input data graph. We define a match M as a subgraph of G that is isomorphic to P, where isomorphism is defined as a one-to-one mapping between V (P) and V (M) such that if two vertices are adjacent in P, then their corresponding vertices are adjacent in M. There are two kinds of matches depending on how vertices and edges from G are extracted in M. An edge-induced match is any subgraph of G that is isomorphic to P. A vertex-induced match is a subgraph of G that is isomorphic to P while containing all the edges in E(G) that are incident on V (M).</p><p>Since there can be sub-structure symmetries within P (e.g., a triangle structure looks the same when it is rotated), the same subgraph of G can result in multiple different matches each with a different one-to-one mapping with V (P). These matches are automorphisms of each other, where automorphic matches are defined as two matches M 1 and M 2 such that V (M 1 ) = V (M 2 ). A canonical match is the unique representative of a set of automorphic matches. Hence, uniqueness is ensured by choosing the canonical match from every set of automorphic matches in G. </p><formula xml:id="formula_0">4 1 2 + + + 1 2 3 + 1 3 2 _ 1 3 4 + 1 4 3 _ 1 2 3 1 3 4</formula><p>Step 1</p><p>Step 2</p><p>Step 3  <ref type="bibr" target="#b70">[57]</ref>, Arabesque <ref type="bibr" target="#b65">[52]</ref> and Fractal <ref type="bibr" target="#b25">[12]</ref>. Numbers in brackets indicate the magnitude of matches explored relative to result size.</p><p>While the techniques presented in this paper work for both directed and undirected graphs, for easier exposition, we assume that P and G are undirected.</p><p>Graph Mining Problems. We briefly describe common graph mining problems. While the problems listed below focus on counting subgraphs of interest, they are often generalized to listing (or enumerating) as well.</p><p>-Motif Counting. A motif is any connected, unlabeled graph pattern. The problem involves counting the occurrences of all motifs in G up to a certain size.</p><p>-Frequent Subgraph Mining (FSM). The problem involves listing all labeled patterns with k edges that are frequent in G (i.e., frequency of their matches in G exceed a threshold τ ). The frequency of a pattern (also called support) is measured in a variety of ways <ref type="bibr" target="#b43">[30,</ref><ref type="bibr" target="#b51">38,</ref><ref type="bibr" target="#b52">39,</ref><ref type="bibr" target="#b71">58]</ref>, but most systems choose the minimum node image (MNI) <ref type="bibr" target="#b19">[6]</ref> support measure since it can be computed efficiently. MNI is anti-monotonic, i.e., given two patterns p and p ′ such that p is a subgraph of p ′ , support of p will be at least as high as that of p ′ . -Clique Counting. A k-clique is a fully-connected graph with k vertices. The problem involves counting the number of k-cliques in G. Variations of this problem include counting pseudo-cliques, i.e., patterns whose edges exceed some density threshold; maximal cliques, i.e., cliques that are not contained in any other clique; and, frequent cliques, i.e., cliques that are frequent (exceeding a frequency threshold).</p><p>-Pattern Matching. The problem involves matching (counting) the number of subgraphs in G that are isomorphic to a given pattern. A variation of this problem is counting constrained subgraphs, i.e., subgraphs with structural constraints (e.g., certain vertices in the subgraph must not be adjacent).</p><p>All of the above graph mining use cases can be modelled in 3 steps: pattern selection, pattern matching, and aggregation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Issues with Graph Mining Systems</head><p>While several graph mining systems have been developed <ref type="bibr" target="#b21">[8,</ref><ref type="bibr" target="#b25">12,</ref><ref type="bibr" target="#b47">34,</ref><ref type="bibr" target="#b65">52,</ref><ref type="bibr" target="#b70">57]</ref>, they are not pattern-aware. Hence, they demand high computation power and require large memory (or storage) capacity, while also lacking the ability to easily express mining programs at a high level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Performance.</head><p>(A) High Computation Demand. Graph mining systems explore subgraphs in a step-by-step fashion by starting with an edge and iteratively extending matches depending on the structure of the data graph. Since they do not analyze the structure of the pattern to guide their exploration, they perform a large number of: (a) unnecessary explorations; (b) canonicality checks; and, (c) isomorphism checks. Figure <ref type="figure">1a</ref> shows an example of step-by-step exploration starting from vertex 1 and vertex 3. In step 1, both the vertices get extended generating 6 partial matches each of size 1 (edges). These are tested for canonicality which prunes out (3, 1) and (3, 2) (non-canonical matches are marked with −). For applications like FSM, isomorphism checks are performed on each of the canonical matches to identify their structure and compute metrics. Then, the remaining 4 matches progress to the next step and the entire process repeats. While explorations get pruned via both canonicality and isomorphism checks, every valid partial match is extended to multiple matches which may no longer be valid; generation of intermediate matches which do not result into valid final matches is unnecessary. Furthermore, all intermediate partial matches (unnecessary and valid matches) are operated upon to identify their structure (i.e., isomorphism check) and to verify their uniqueness (i.e., canonicality check). In our example, 13 intermediate matches get generated, 5 of which are unnecessary; 13 canonicality checks and 8 isomorphism checks are performed. If these checks are not performed at every step (as done in Fractal <ref type="bibr" target="#b25">[12]</ref> by delaying its filter step), a massive amount of partial and complete matches that do not contribute to final result would get generated.</p><p>We verified the above behavior by profiling graph mining systems on clique counting and motif counting applications. As shown in Figure <ref type="figure">1b</ref> and Figure <ref type="figure">1c</ref>, on Patents <ref type="bibr" target="#b30">[17]</ref> (a realworld graph dataset), RStream <ref type="bibr" target="#b70">[57]</ref> and Arabesque <ref type="bibr" target="#b65">[52]</ref> generate over a billion partial matches for clique counting while the total number of cliques is only ∼3.5M (∼99.7% matches were unnecessary); similarly for motif counting, RStream generates over 40 billion partial matches (∼99.2% unnecessary) and Arabesque generates over 685 million partial matches (∼52% unnecessary). They also perform a large number (hundreds of millions to billions) of canonicality checks and isomorphism checks. Since Fractal <ref type="bibr" target="#b25">[12]</ref> explores in depth-first fashion, its numbers are better than RStream and Arabesque; however, they are still very high.</p><p>(B) High Memory Demand. Graph mining systems often hold massive amounts of (partial and complete) matches in memory and/or in external storage. Systems based on stepby-step exploration require valid partial matches so that they can be extended in subsequent steps; the total size (in bytes) required by all matches (partial and complete) quickly grows (often beyond main memory capacity) as the size of the pattern or data graph increases. Such a memory demand is lower in DFS-based exploration (as done in Fractal <ref type="bibr" target="#b25">[12]</ref>). For clique and motif counting in Figure <ref type="figure">1</ref>, Arabesque consumes ∼101GB main memory while Fractal requires ∼32GB memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Programmability.</head><p>Programming in graph mining systems is done at vertex and edge level, with semantics of constructing the required matches defined explicitly by user's mining program. This means, mining programs expressed in those systems contain the logic for: (a) validating partial and complete matches; (b) extending matches via edges and/or vertices; and, (c) processing the final valid matches. As the size of subgraph structure to be mined grows, the complexity of validating partial matches increases, making mining programs difficult to write. For example, the multiplicity algorithm to avoid over-counting in AutoMine <ref type="bibr" target="#b47">[34]</ref> cannot be used if the user wants to enumerate patterns, which leaves the responsibility of identifying unique matches to the user. Furthermore, complicated structural constraints beyond the presence of vertices, edges and labels cannot be easily expressed in any of the existing systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Overview of PEREGRINE</head><p>We develop a pattern-aware graph mining system that directly finds subgraphs of interest without exploring unnecessary matches while simultaneously avoiding expensive isomorphism and canonicality checks throughout the mining process. We do so by designing a pattern-based programming model that treats graph patterns as first class constructs, and by developing a processing model that uses the pattern's substructure to guide the exploration process.</p><p>Pattern-based Programming. In PEREGRINE, graph mining tasks are directly expressed in terms of subgraph structures (i.e., graph patterns). Our pattern-aware programming model allows declaring (statically and dynamically generated) patterns, modifying patterns, and performing user-defined operations over matches explored by the runtime. This allows concisely expressing mining programs by abstracting out the underlying runtime details, and focusing only on the substructures to be explored. Moreover, we introduce two novel abstractions, anti-edges and anti-vertices: an anti-edge enforces strict disconnection between two vertices in the match whereas an anti-vertex captures strict absence of a common neighbor among vertices in the match. These abstractions allow users to easily express advanced structural constraints on patterns to be mined.</p><p>Automatic Generation of Exploration Plan. With patterns of interest directly expressed, PEREGRINE analyzes the patterns and computes an exploration plan which is later used to guide the exploration in the data graph. Specifically, the pattern is first analyzed to eliminate symmetries within itself so that expensive canonicality checks during exploration can be avoided. Then the pattern is reduced to its core substructure that enables identifying matches using simple graph traversals and adjacency list intersection operations without performing explicit isomorphism checks.</p><p>Guided Pattern Exploration. After the exploration plan is generated, PEREGRINE starts the exploration process using our pattern-aware processing model. The exploration process matches the core substructure of the pattern to generate partial matches using recursive graph traversals in the data graph. As partial matches get generated, they are extended to form final complete matches by intersecting the adjacency lists of vertices in the partial matches. Since the entire exploration is guided by the plan generated from the pattern of interest, the exploration does not require intermediate isomorphism and canonicality checks for any of the partial and complete matches that it generates. This reduces the amount of computation done in PEREGRINE compared to state-of-the-art graph mining systems. Moreover, since matches are recursively explored and instantly extended to generate complete final results, partial state is not maintained in memory throughout the exploration process which significantly reduces the memory requirement for PEREGRINE.</p><p>Finally, we reduce load imbalance in PEREGRINE by enforcing a strict matching order based on vertex degrees. Furthermore, we incorporate on-the-fly aggregation and early termination features to provide global updates as mining progresses so that exploration can be stopped once the conditions required to compute final results are met. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PEREGRINE Programming Model</head><p>Since graph mining fundamentally involves finding subgraphs that satisfy certain structural properties, we design our programming model around graph patterns as first class constructs. This allows users to easily express the subgraph structures of interest, without worrying about the underlying mechanisms of how to explore the graph and find those structures. With such a declarative style of expressing patterns, PERE-GRINE enables users to program complex mining queries as operations over the matches. The clear separation of what to find and what to do with the results helps users to quickly reason about correctness of their mining logic, and develop advanced mining-based analytics.</p><p>We first present how patterns are directly expressed in PEREGRINE, and then show how common graph mining use cases can be programmed with patterns in PEREGRINE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">PEREGRINE Patterns</head><p>Figure <ref type="figure" target="#fig_1">2</ref> shows our API to directly express, construct and modify connected graph patterns. Patterns can be constructed statically and loaded using <ref type="bibr">[L1]</ref>, or can be constructed dynamically [G1-G2, C1-C2, S1-S3]. <ref type="bibr">[G1]</ref> and <ref type="bibr">[G2]</ref> generate all unique patterns that can be induced by certain number of edges and vertices respectively. [S1-S3] generate special well-known patterns. [C1-C2] take a group of patterns as input, and extend one of them by an edge or a vertex, to return all of the unique new patterns that result from these extensions. This allows constructing patterns stepby-step which is useful to perform guided exploration. The Pattern class provides a standard interface to access and modify the pattern graph structure.</p><p>In most common applications, the edges and vertices in the pattern graph are sufficient for PEREGRINE to find subgraph structures that match the pattern. For advanced mining use cases that require structural constraints within the pattern, we introduce anti-edges and anti-vertices. 3.1.1 Anti-Edges. Anti-edges are used to model constraints between vertex pairs in the pattern. They are special edges indicating disconnections between pairs of vertices. For example, in a social network graph where vertices model people and edges model their friendships, extracting unrelated people with at least two mutual friends can be achieved using p a in Figure <ref type="figure" target="#fig_2">3</ref> where (u 2 , u 4 ) is an anti-edge.</p><p>An anti-edge ensures that the two vertices in the match do not have an edge between them in the data graph. If two vertices u 1 and u 2 are connected via an anti-edge in a pattern p, then any match for p guarantees the anti-edge constraint:</p><formula xml:id="formula_1">m(u 1 ) = v 1 ∧ m(u 2 ) = v 2 =⇒ (v 1 , v 2 ) E(G)</formula><p>where m is the function mapping vertices in p to vertices in G. The two vertices connected by an anti-edge are called anti-adjacent. Figure <ref type="figure" target="#fig_2">3</ref> shows another example pattern (p b ) with anti-adjacent vertices u 1 -u 3 and u 2 -u 4 , and their corresponding anti-edges (u 1 , u 3 ) and (u 2 , u 4 ). PEREGRINE natively supports anti-edges (discussed in §4.2), and hence, it directly matches only those subgraphs that do not contain an edge between the two anti-adjacent vertices.</p><p>3.1.2 Anti-Vertices. Anti-vertices are used to model constraints among shared neighborhoods of vertices in the pattern. They are special vertices that are only connected to other vertices via anti-edges. For example, extracting pairs of friends with only one mutual friend in a social network graph can be achieved using p e in Figure <ref type="figure" target="#fig_2">3</ref> where u 4 is an anti-vertex. Such a query cannot be directly expressed using anti-edges alone.</p><p>Anti-vertices represent absence of a vertex. So a match of a pattern with an anti-vertex will not contain a data vertex matching the anti-vertex. If u is an anti-vertex in a pattern p and S is the set of data vertices matching the neighbors of u, then any match for p guarantees the anti-vertex constraint:</p><formula xml:id="formula_2">S = m(adj(u)) =⇒ v ∈S adj(v) \ m(adj(m −1 (v))) = ∅</formula><p>where m is the function mapping vertices in p to vertices in G, and m −1 is its inverse.</p><p>To distinguish anti-vertices, we call a vertex with at least one regular edge (i.e., not anti-edge) a regular vertex. Figure <ref type="figure" target="#fig_2">3</ref> shows different patterns with anti-vertices: In a match for p c , the matches for u 1 and u 2 have no common neighbors. On the other hand, in a match for p d , the match for u 2 has no neighbors other than the matches for u 1 and u 3 . Finally, p f has two anti-vertices which combines constraints from p c and p d . PEREGRINE natively supports anti-vertices (discussed in  3.1.3 Edge-Induced and Vertex-Induced Patterns. Depending on the mining use case, the matches for a given pattern must be either edge-induced or vertex-induced. For example, Frequent Subgraph Mining (FSM) relies on edgeinduced matches, whereas Motif Counting requires vertexinduced matches (programs shown in §3.2). Our pattern-based programming model allows exploring subgraphs in both edgebased and vertex-based fashion as discussed next.</p><p>An edge-induced match is a subgraph s e of G such that the subgraph of G induced by E(s e ) is isomorphic to p. Note that, by definition, the subgraph induced by E(s e ) is equal to s e . Hence, edge-induced matches are directly expressed by the pattern.</p><p>A vertex-induced match, on the other hand, is a subgraph s v of G such that the subgraph of G induced by V (s v ) is isomorphic to p. Hence, the sets of vertex-induced and edge-induced matches of p are not equal mainly because the vertices of s e can have more edges between them in G than are present in p (in general, the subgraph induced by V (s e ) is not isomorphic to p). In our pattern-based programming approach, the vertexinduced requirement gets directly expressed using anti-edges. Specifically, to find vertex-induced matches of a pattern p, we use the following result: Theorem 3.1. Let p be a pattern, and p ′ be another pattern such that p ′ has the same vertices and edges as p, and every pair of vertices in p that are not adjacent are anti-adjacent in p ′ . The set of vertex-induced matches of p is equal to the set of edge-induced matches of p ′ . Proof. To prove equivalence of the two sets, we first show that every edge-induced match of p ′ is a vertex-induced match of p, and then we show that every vertex-induced match of p is an edge-induced match of p ′ .</p><p>Let m be an edge-induced match for p ′ . Observe that as p and p ′ contain the same edges and vertices, m is also a match for p. By definition of p ′ , for any edge (u, v) E(p), there is an anti-edge constraint between u and v in p ′ . Since m is a match for p ′ , it satisfies this anti-edge constraint, such that m(u) and m(v) are not adjacent in the data graph. This means there is an edge between m(u) and m(v) if and only if (u, v) ∈ E(p). Therefore, m is a vertex-induced match of p.</p><p>Conversely, let m be a vertex-induced match for p. Since m is isomorphic to p, it contains all edges of p. Furthermore, m is vertex-induced, so if a pair of pattern vertices u 1 , u 2 in p are not adjacent, then the corresponding data vertices m(u 1 ) and m(u 2 ) are not adjacent either. Hence, m satisfies the anti-edge constraint for u 1 , u 2 . As this holds for all pairs of non-adjacent vertices in p, m is also a match for p ′ . Hence, our pattern-based programming doesn't need to separately define the exploration strategy, as done in other pattern-unaware systems <ref type="bibr" target="#b65">[52,</ref><ref type="bibr" target="#b70">57]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Pattern-Aware Mining Programs in PEREGRINE</head><p>Figure <ref type="figure" target="#fig_4">4</ref> shows PEREGRINE programs for motif counting, frequent subgraph mining (FSM), clique counting, pattern matching, an existence query for global clustering coefficient bound, and an existence query for k-sized clique. All the programs first express patterns by dynamically generating them or by loading them from external source. Then they invoke PEREGRINE engine to find (match()) and process matches of those patterns. For every match for the pattern, user-defined function (e.g., updateSupport(), countAndCheck(), found(), etc.) gets invoked to perform desired analysis. The count() function is a syntactic sugar and is equivalent to match() with a function that increments a counter. Most of the programs are straightforward; we discuss FSM and existence queries in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">FSM:</head><p>Anti-Monotonicity &amp; Label Discovery. FSM leverages anti-monotonicity in support measures (discussed in §2.1). PEREGRINE natively provides MNI support computation where it internally constructs the domain of patterns, i.e., a table mapping vertices in G to those in p (similar to <ref type="bibr" target="#b14">[1]</ref>). After exploration ends for a single iteration, the support measure maintained by PEREGRINE can be directly used to prune infrequent patterns using a threshold, as shown in Figure <ref type="figure" target="#fig_4">4a</ref>, and only the remaining frequent patterns are then programmatically extended to be explored.</p><p>Before finding the first small frequent labeled patterns, the FSM program has no information about which labelings are frequent. PEREGRINE provides dynamic label discovery by starting with unlabeled (or partially labeled) patterns as input and returning labeled matches. Hence, the FSM program in Figure <ref type="figure" target="#fig_4">4a</ref> first starts with unlabeled patterns of size 2, and discovers frequent labeled patterns. It then iteratively extends the frequent labeled patterns with unlabeled vertices to discover frequent labeled patterns of larger sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Existence</head><p>Queries. Existence queries allow quickly verifying whether certain structural properties hold within a given data graph. PEREGRINE allows dynamically stopping exploration when the required conditions get satisfied. Figure <ref type="figure" target="#fig_4">4b</ref> shows a PEREGRINE program to verify if the global clustering coefficient <ref type="bibr" target="#b40">[27]</ref> of graph G is above a certain bound. The global clustering coefficient is the ratio of three times the number of triangles and the number of triplets (all connected subgraphs with three vertices, including duplicates) in G. The number of triplets is equal to twice the number of edge-induced 3-star matches since the endpoints of a 3-star are symmetric. Hence, the program quickly computes the number of 3-stars, and then starts counting triangles. During exploration, if the number of triangles reaches the requisite number to exceed the bound, exploration stops immediately.</p><p>Figure <ref type="figure" target="#fig_4">4f</ref> shows PEREGRINE program to check whether a clique of a certain size is present in G. As soon as the exploration finds at least one match, it stops and returns True.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Pattern-Aware Matching Engine</head><p>PEREGRINE is pattern-aware, and hence, it directly finds patterns in any given data graph. In this section, we discuss our core pattern matching engine that directly finds canonical subgraphs from a given vertex in the data graph. In §5, we will use this engine to build PEREGRINE. For simplicity, we assume the data graph and the pattern are unlabeled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Directly Matching A Given Pattern</head><p>To avoid the overheads of a straightforward exhaustive search, we develop our pattern matching solution based on wellestablished techniques <ref type="bibr" target="#b18">[5,</ref><ref type="bibr" target="#b29">16,</ref><ref type="bibr" target="#b37">24]</ref>. Since patterns are much smaller than the data graph, we analyze the given pattern to develop an exploration plan. This plan guides the data graph exploration to ensure generated matches are unique.</p><p>Figure <ref type="figure" target="#fig_5">5</ref> shows how the exploration plan is computed from a given pattern p. First, to avoid non-canonical matches we break the symmetries of p by enforcing a partial ordering on matched vertices <ref type="bibr" target="#b29">[16]</ref>. This involves enumerating all automorphisms of p to identify symmetries, and iteratively ordering pairs of symmetric vertices until the only automorphism satisfying the ordering is the one mapping each vertex to itself. For our example pattern in Figure <ref type="figure" target="#fig_6">6</ref>, we obtain the partial ordering u 1 &lt; u 3 and u 2 &lt; u 4 .</p><p>In the next step, we compute the core of p (called p C ) as the subgraph induced by its minimum connected vertex cover <ref type="foot" target="#foot_0">2</ref> . Given a match m for p C , all matches of p which contain m  can be computed from the adjacency lists of vertices in m. In our example, p C is the subgraph induced by u 2 and u 4 .</p><p>To simplify the problem of matching p C , we generate matching orders to direct our exploration in the data graph. A matching order is a graph representing an ordered view of p C . The vertices of the matching order are totally-ordered such that the partial ordering of V (p) restricted to V (p C ) is maintained. This allows matching p C by traversing vertices with increasing vertex ids without canonicality checks.</p><p>We compute matching orders by enumerating all sequences of vertices in p C that meet the partial ordering, and for each sequence we create a copy of p C where the id of each vertex is remapped to its position in the sequence. Then, we discard duplicate matching orders. For our example pattern (Figure <ref type="figure" target="#fig_6">6</ref>), its core substructure has only one valid vertex sequence, {u 2 , u 4 }, so we obtain only one matching order. Note that there can be multiple matching orders for a given p C depending on the partial orders. We call the i th matching order p Mi .</p><p>Thus, to match p C it suffices to match its matching orders p Mi . A match for p Mi results in 1 match for p C per valid vertex sequence. In our example, a match for p M 1 , say {v 2 , v 3 }, is converted to a single match for p</p><formula xml:id="formula_3">C , v 2 → w 1 → u 1 , v 3 → w 2 → u 2 .</formula><p>It is important to note that the exploration plan is generated by analyzing the pattern graph only, i.e., all the computations explained above are applied on p (and its derivatives). Hence, exploration plans are computed quickly (often in less than half a millisecond). matchFrom()</p><formula xml:id="formula_4">v 3 v 1 v 3 v 2 v 3 v 2 v 3 v 1 v 5 v 5 v 2 v 3 v 1 completeMatch() matchFrom() completeMatch()</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Time</head><p>Figure <ref type="figure">8</ref>. Pattern-guided exploration in PEREGRINE for pattern and data graph in Figure <ref type="figure" target="#fig_6">6</ref> with matching order high-to-low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Matching Anti-Edges</head><p>To enforce an anti-edge constraint, we perform a set difference between the adjacency lists of its endpoints. For example, if v i , v j match u 1 , u 2 of p a in Figure <ref type="figure" target="#fig_2">3</ref>, the candidates for u 4 are the elements of adj(v i ) \ adj(v j ).</p><p>To perform the set difference, we need to ensure that one of the vertices of the anti-edge is already matched so that its adjacency list is available. Hence, when computing the vertex cover we also cover the anti-edge by including one of its endpoints. When computing partial orders, however, we do not need to consider anti-edges since they don't generate automorphic matches and we only verify absence of edges (i.e., we never traverse through anti-edges).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Matching Anti-Vertices</head><p>The anti-vertex semantics offer flexibility to match them differently compared to anti-edges. Anti-vertices break symmetries and do not impact the core graph (i.e., vertex cover computation) as described next.</p><p>Checking Anti-Vertices. The anti-vertex constraint can only be verified after the common neighbors of an antivertex's neighbor have been matched. Thus, we perform the check after all true vertices are already matched.</p><p>For example, consider p e in Figure <ref type="figure" target="#fig_2">3</ref>, with anti-vertex u 4 . If v i , v j , v k in the data graph match u 1 , u 2 , u 3 respectively, then we verify the anti-vertex constraint for u 4 as follows:</p><formula xml:id="formula_5">(adj(v i ) \ {v j }) ∩ (adj(v k ) \ {v j }) = ∅</formula><p>Since anti-vertices do not participate while matching regular vertices and edges, we keep the pattern core p C the same as the core pattern when anti-vertices are removed.</p><p>Breaking Symmetries with Anti-Vertices. Anti-vertices introduce asymmetries in the pattern. We extract these asymmetries to ensure that valid matches do not get incorrectly pruned. We first explain how a partial ordering generated without considering anti-vertices would end up pruning valid matches, and then we showcase how anti-vertices get used to generate the correct partial ordering.</p><p>Let p ′ be the sub-graph of p e (in Figure <ref type="figure" target="#fig_2">3</ref>) with the antivertex removed. Notice that p ′ is simply a triangle. In our data graph from Figure <ref type="figure" target="#fig_6">6</ref>, the vertices v 1 , v 4 , v 6 form a triangle, and the pairs ⟨v 4 , v 6 ⟩ and ⟨v 1 , v 6 ⟩ have no common neighbors outside of the triangle. However, ⟨v 1 , v 4 ⟩ have v 2 as a common neighbor. Thus, according to anti-vertex semantics, p e should match the subgraphs induced by {v 1 , v 4 , v 6 } and {v 1 , v 6 , v 4 }. But since p ′ does not include the anti-vertex u 4 , it is fully symmetric and hence would only match {v 1 , v 4 , v 6 }. Therefore, we cannot ignore anti-vertices in the symmetry-breaking algorithm: otherwise the resulting partial ordering would prune matches that are valid according to the anti-vertex constraint.</p><p>To generate a correct partial ordering, we expose the asymmetries introduced by anti-vertices to the symmetry-breaking algorithm, which treats the anti-edges of an anti-vertex differently than regular edges when computing automorphisms.</p><p>Considering p e again, our symmetry-breaking algorithm finds that u 2 is not symmetric with u 1 and u 3 since it is not connected to the anti-vertex u 4 . Meanwhile, u 2 and u 4 will not be considered symmetric either, because u 2 is connected to u 1 and u 3 with true edges whereas u 4 is connected with antiedges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PEREGRINE: Pattern-Aware Mining</head><p>We will now discuss how PEREGRINE performs pattern-aware mining using the matching engine presented in §4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Pattern-Aware Processing Model</head><p>Mining in PEREGRINE is achieved by matching patterns starting from each vertex and invoking the user function to process those patterns. Hence, a task in PEREGRINE is defined as the data vertex where the matching process begins. As shown in Figure <ref type="figure" target="#fig_7">7</ref>, each mining task takes a start vertex and the exploration plan generated in §4 (matching orders, partial orders, pattern core p C ). From the starting vertex, we recursively match vertices in the matching order. At each recursion level, a data vertex is matched to a matching order vertex. To avoid non-canonical matches, we maintain sorted adjacency lists and use binary search to generate candidate sets comprised only of vertices that meet the total ordering.</p><p>Once a matching order is fully matched, it is converted to matches for p C . Matches for p C are then completed by performing set intersections (for true edges) and set differences (for anti-edges) on sections of adjacency lists that satisfy the partial orders. Each completed match is passed to a userdefined callback for further processing. Figure <ref type="figure">8</ref> shows a complete exploration example.</p><p>Note that our processing model doesn't incur expensive isomorphism and canonicality checks for every match in the data graph, while simultaneously avoiding mis-matches and only exploring subgraphs that match the given pattern. Furthermore, tasks in our processing model are independent of each other since explorations starting from two different vertices do not require any coordination. Threads dynamically pick up new tasks when they finish their current ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Early Pruning for Dynamic Load Balancing</head><p>While a matching order enforces a total ordering on the data vertices matching p C , there is flexibility in the order in which its vertices are matched. To reduce the load imbalance across our matching tasks, we: (a) follow matching orders high-tolow, e.g. in our example in Figure <ref type="figure" target="#fig_6">6</ref> we match w 2 before w 1 ; and, (b) order vertices by their degree such that v i &lt; v j in the data graph if and only if deдree(v i ) ≤ deдree(v j ).</p><p>High-degree vertices have fewer neighbors with degrees higher than or equal to their own, so the degree-based ordering ensures that when a high-degree vertex is matched to w 2 , only those few neighbors can be matched to w 1 . Thus, explorations of neighbors with lower degrees are pruned. Note that the total number of matches generated remains the same; the high-tolow matching order traversal, along with degree-based vertex ordering, reduces the workload imbalance of matching across high-degree and low-degree vertices by dynamically pruning more explorations from high-degree tasks while enabling those explorations in low-degree tasks.</p><p>Finally, it is important to note that this process does not 'eliminate' workload imbalance simply because the mining workload is dynamic and depends on the pattern and data graphs. Hence, to avoid stragglers and maximize parallelism, we process tasks in the order defined by the degree of the starting vertex, beginning with the highest-degree vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Early Termination for Existence Queries</head><p>For existence queries, PEREGRINE allows actively monitoring the required conditions so that the exploration process terminates as quickly as possible. When the matching thread observes the required conditions, the user function calls stopExploration() to notify other matching threads. Threads monitor their notifications periodically while matching, and when a notification is observed, the thread-local values computed up to that point are aggregated and returned to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">On-the-fly Aggregation</head><p>PEREGRINE performs on-the-fly aggregation to provide global updates as mining progresses. This is useful for early termination and for use cases like FSM where patterns that meet the support threshold can be deemed frequent while matching continues for other patterns.</p><p>We achieve this using an asynchronous aggregator thread that periodically performs aggregation as values arrive from threads. Table <ref type="table">2</ref>. Real-world graphs used in evaluation. '-' indicates unlabeled graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Implementation Details</head><p>PEREGRINE is implemented in C++ where concurrent threads operate on exploration tasks, each starting at a different vertex in the data graph. The data graph is represented using adjacency lists, and the tasks are distributed dynamically using a shared atomic counter indicating the next vertex to be processed. To minimize coordination, threads maintain information regarding their exploration tasks, including candidate sets for each pattern vertex as exploration proceeds. PEREGRINE provides native computation of support values for frequency-based mining tasks like FSM. Domains are implemented as a vector of bitmaps representing the data vertices that can be mapped to each pattern vertex. They are aggregated by merging their contents via logical-or. To scale to large datasets, we use compressed Roaring bitmaps <ref type="bibr" target="#b20">[7]</ref>, which are more memory efficient than dense bitmaps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We evaluate the performance of PEREGRINE on a wide variety of graph mining applications and compare the results with the state-of-the-art general purpose graph mining systems 3 : Fractal <ref type="bibr" target="#b25">[12]</ref>, Arabesque <ref type="bibr" target="#b65">[52]</ref>, RStream <ref type="bibr" target="#b70">[57]</ref> and G-Miner <ref type="bibr" target="#b21">[8]</ref>. Fractal (FCL), Arabesque (ABQ) and G-Miner (GM) were evaluated using both a cluster of 8 nodes (denoted by the suffix '-8'), as well as in single node configuration (denoted by the suffix '-1').</p><p>RStream was evaluated on a c5.4xlarge (RS-16) as well as a c5.metal (RS-96) equipped with an Intel Xeon Scalable Processor containing 48 physical cores (96 logical cores with hyper-threading), and 192GB RAM. Both instances were provisioned with a 500GB SSD. 3 We could not evaluate AutoMine <ref type="bibr" target="#b47">[34]</ref> since its source code is not available.  In all performance comparisons, we ran PEREGRINE on a c5.4xlarge, and we used c5.metal to study PERE-GRINE's scalability and resource utilization.</p><p>Datasets. Table <ref type="table">2</ref> lists the data graphs used in our evaluation. Mico (MI) is a co-authorship graph labeled with each author's research field. Patents (PA) is a patent citation graph. In the labeled version, each patent is labeled with the year it was granted. Orkut (OK) and Friendster (FR) are unlabeled social network graphs where edges represent friendships between users. Mico and labeled Patents have been used by previous systems <ref type="bibr" target="#b25">[12,</ref><ref type="bibr" target="#b65">52,</ref><ref type="bibr" target="#b70">57]</ref> to evaluate FSM while Orkut and Friendster were used by <ref type="bibr" target="#b21">[8]</ref>. Except for FSM and labeled pattern matching, all experiments on Patents use its larger, unlabeled version.</p><p>Applications. We evaluated PEREGRINE on a wide array of applications: counting motifs with 3 and 4 vertices, labeled 3-and 4-motifs; counting k-cliques, for k ranging from 3 to 5; FSM with patterns of 3 edges on labeled datasets using various supports; matching the patterns shown in Figure <ref type="figure" target="#fig_8">9</ref>; and checking the existence of 14-cliques. We selected the patterns in Figure <ref type="figure" target="#fig_8">9</ref> to cover all the patterns used in <ref type="bibr" target="#b25">[12]</ref> and <ref type="bibr" target="#b21">[8]</ref>; note that patterns like triangles and empty squares are covered via applications like cliques and motifs. Since G-Miner's pattern matching program is specific to labeled p 2 (in Figure <ref type="figure" target="#fig_8">9</ref>), we used labels on p 2 for all the systems to enable direct comparison. To match it on Orkut and Friendster graphs, which are unlabeled, we added synthetic labels (integers 1-6 as done in <ref type="bibr" target="#b21">[8]</ref>) with uniform probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Comparison with Breadth-First Enumeration</head><p>Table <ref type="table" target="#tab_5">3</ref> compares PEREGRINE's performance with Arabesque and RStream on motif-counting, clique-counting, and FSM (these systems do not support pattern matching). As we can see, PEREGRINE outperforms the breadth-first systems by at least an order of magnitude on every application except FSM. RStream, despite being an out-of-core system, runs out of memory during FSM computations because of the massive amounts of aggregation information, as well as during 4-and 5-cliques on Mico where it could not handle the size of a single expansion step.</p><p>It was interesting to observe that Arabesque performed better in single-node mode compared to 8-node configuration across all experiments except FSM on Patents, where it ran out of memory. This is because its breadth-first exploration generates large amounts of partial matches which must be  <ref type="bibr" target="#b65">[52]</ref> and RStream <ref type="bibr" target="#b70">[57]</ref>. '×' indicates the execution did not finish within 5 hours.</p><p>'-' indicates the system ran out of memory. '/' indicates the system ran out of disk space.</p><p>synchronized across the entire cluster between supersteps, incurring high communication costs that impact its scalability.</p><p>When support thresholds are high, Arabesque on 8 nodes computes FSM more quickly than PEREGRINE. This is because its breadth-first strategy leverages parallelism when there are few frequent patterns to explore and aggregate. However, this approach is sensitive to the support threshold, which stops Arabesque from scaling to lower threshold values where there are more frequent patterns. In these scenarios Arabesque simply fails due to the memory burden of maintaining the vast amount of intermediate matches and aggregation values. We suspect that even with more main memory per node, the intermediate computations (canonicality, isomorphism, etc.) for each individual match in Arabesque would significantly limit its performance. Since PEREGRINE is pattern-aware, it only needs to maintain aggregation values for the patterns it is currently matching, allowing it to scale to inputs that yield many frequent patterns. Similar to Arabesque, Fractal's pattern-unawareness requires it to maintain global aggregation values throughout its computation. In FSM, the aggregation values consume O(|V |) memory per vertex in each pattern in the worst case, and thus quickly become a scalability bottleneck. On the other hand, PEREGRINE only needs to maintain aggregation values for the current patterns being matched, which allows it to achieve comparable performance and superior scalability while matching up to 15,817 patterns on Mico and 6,739 patterns on Patents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>App</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Comparison with Purpose-Built Algorithms</head><p>G-Miner is a general-purpose subgraph-centric system that targets expert users to implement the mining algorithms using a low-level subgraph data structure. Since expressing common mining algorithms requires domain expertise, we only evaluated the applications that are already implemented in G-Miner: 3-clique counting and pattern matching on p 2 (pattern matching for other patterns is not supported). This experiment serves to showcase how PEREGRINE compares to custom algorithms for matching specific patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G</head><p>Existence Anti-Vertex Anti-Edge ), matching with an anti-edge (p 8 ), and 14-clique existence query.</p><p>Table <ref type="table" target="#tab_7">5</ref> compares PEREGRINE's performance with G-Miner. As we can see, PEREGRINE is 3× to 77× faster than G-Miner when counting 3-cliques even though G-Miner implements an algorithm designed specifically to count 3-cliques. When matching p 2 , PEREGRINE is 6× to 131× faster on Mico and Patents. On Orkut, however, G-Miner performs better on finding p 2 ; this is because G-Miner indexes vertices by labels when preprocessing the data graph, whereas PEREGRINE discovers labels dynamically. Due to these indexes, G-Miner could not handle Friendster even with 240GB disk space on the cluster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Mining with Constraints in PEREGRINE</head><p>We evaluate PEREGRINE on mining tasks with structural constraints. We match a pattern containing an anti-vertex (p 7 ), one containing an anti-edge (p 8 ), and perform an existence query of a 14-clique. The results are show in Table <ref type="table" target="#tab_8">6</ref>.</p><p>Mining with Anti-Vertices. Pattern p 7 expresses a maximal clique of size 3 (triangle) using a fully-connected antivertex, i.e., it matches all triangles that are not contained in a 4-clique. While satisfying the anti-vertex constraint requires computing set-intersections across all vertices of the triangle, PEREGRINE takes less than a minute on Orkut, and under eight minutes on the billion scale Friendster graph.</p><p>Mining with Anti-Edges. Pattern p 8 represents a vertexinduced chordal square using an anti-edge constraint. Satisfying the anti-edge constraint is computationally demanding, since it requires computing set differences of adjacency lists, which is twice as many operations as the sum of the adjacency list sizes. Nevertheless, PEREGRINE still easily completes it on all the datasets. Existence Query. The goal of this query is to determine whether a 14-clique exists in the data graph. PEREGRINE stops exploration immediately after finding an instance of 14-clique. We observe that Patents and Orkut performed similarly; this is because the rarer the target pattern for an existence query, the longer it takes to find it. Patents does not contain a 14-clique, so the entire graph was searched, but in the much larger and denser Orkut graph, a 14-clique gets found quickly during exploration. Friendster is both large and sparse, and hence, 14-cliques are rare. Furthermore, since 14-clique is a large pattern, several partial explorations do not lead to a complete 14-clique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">PEREGRINE's Pattern-Aware Runtime</head><p>Benefits of Symmetry Breaking. Symmetry breaking is a well-studied technique for subgraph matching that PERE-GRINE uses to guide its graph exploration. However, recent systems like Fractal <ref type="bibr" target="#b25">[12]</ref> and AutoMine <ref type="bibr" target="#b47">[34]</ref> are not fully pattern-aware and do not leverage symmetry breaking for common graph mining use cases. We showcase the importance of symmetry breaking in PEREGRINE by disabling it and running 4-motifs and FSM with low support thresholds. These are expensive subgraph matching workloads: 4-motifs contains complex patterns with many matches and FSM involves a large number of patterns to match. Figure <ref type="figure" target="#fig_9">10</ref> summarizes the results.</p><p>We observe that symmetry breaking improves performance by an order of magnitude for 4-motifs on Mico and Patents. Orkut 4-motifs without symmetry breaking did not even finish matching even a single size 4 pattern within 5 hours. This shows the importance of symmetry breaking when scaling to large patterns and large datasets. For instance, Orkut contains over 22 trillion unique vertex-induced 4-stars, and so without symmetry breaking, the system must process six times that many matches (a 4-star's automorphisms are the permutations of its 3 endpoints: resulting in 3! = 6 automorphic subgraphs).</p><p>FSM achieves 3× performance improvement through symmetry breaking. This is because with symmetry breaking, FSM's expensive aggregation values are only written to once per unique match in the data graph, whereas the naive approach without symmetry breaking would incur dozens of redundant write (and read) accesses per unique match.</p><p>Breakdown on Mining Time. Figure <ref type="figure" target="#fig_10">11</ref> shows the ratio of time spent in each stage of matching during 4-motif execution: finding the range of sorted candidate sets that meet the pattern's partial order (PO), performing adjacency list intersections and differences to match the pattern core (Core) and finally, intersecting the adjacency lists of the pattern core to complete the match (Non-Core). Some time is also spent on the other requirements of matching, for example, fetching adjacency lists and mapping vertices (Other). We observe that the majority of execution is spent intersecting adjacency lists of candidate vertices to complete matches. In comparison to the overall execution time, matching the core pattern is insignificant. This is because the core pattern is matched according to all valid total orderings of its vertices, and hence, the traversal is fully guided. In contrast, the non-core vertices may or may not be ordered with respect to each other, and with respect to the core vertices; so the runtime usually has less guidance when exploring the graph. Furthermore, in most patterns the core is small and involves fewer intersections than the non-core component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7">System Characteristics</head><p>Scalability. We study PEREGRINE's scalability by matching pattern p 1 on Orkut using c5.metal instance. Note that we do not perform a COST analysis <ref type="bibr" target="#b50">[37]</ref> with this experiment since we already compared PEREGRINE with optimized algorithms in §6.4, and state-of-the-art serial pattern matching solutions like <ref type="bibr" target="#b32">[19,</ref><ref type="bibr" target="#b66">53]</ref> performed much slower than our single threaded execution.</p><p>Figure <ref type="figure" target="#fig_11">12a</ref> shows how PEREGRINE scales as number of threads increase from 1 to 96. As we can see, PEREGRINE scales linearly until 48 threads, after which speedups increase gradually. This is mainly because c5.metal has 48 physical cores, and scheduling beyond 48 threads happens with hyper-threading. We verified this effect by alternating how threads get scheduled across different cores; the dashed lines in Figure <ref type="figure" target="#fig_11">12a</ref> show speedups when every pair of PEREGRINE threads is pinned to two logical CPUs on one physical CPU. As we can see, with 48 threads but only 24 physical cores, PEREGRINE only achieves a 30× speedup, whereas with 48 physical cores it achieves a 41× speedup. Since pattern exploration involves continuous random memory accesses throughout execution, hyper-threading helps in hiding memory latencies only up to an extent. Figure <ref type="figure" target="#fig_11">12b</ref> verifies this, as memory bandwidth grows considerably higher when using more cores, though CPU utilization remains similar. for 24 cores (blue), 47 cores (green) and 94 cores (red).</p><p>We observe that speedups also decline slightly between 24 cores and 48 cores. This is because c5.metal has two NUMA nodes, each allocated to 24 physical cores. We measured remote memory accesses to observe the NUMA effects: when running on 48 cores, cross-numa memory traffic was 86GB as opposed to only 4.9MB when running on 24 cores.</p><p>Resource Utilization. Figure <ref type="figure" target="#fig_11">12b</ref> shows CPU utilization and memory bandwidth consumed by PEREGRINE while matching p 1 on Orkut on c5.metal with 24, 47, and 94 threads. We reserve a core for profiling to avoid its overhead. We observe that PEREGRINE maintains high CPU utilization throughout its execution. The memory bandwidth curve increases over time; as high degree vertices finish processing, low degree vertices do less computation and incur more memory accesses as they get processed.</p><p>Figure <ref type="figure" target="#fig_12">13</ref> compares the peak memory usage for PERE-GRINE and other systems. For distributed systems we report the sum of all nodes' peak memory. PEREGRINE consistently uses less memory than all the systems, mainly because of its direct pattern-aware exploration strategy. It is interesting to note that changing the pattern size in cliques and motifs does not impact PEREGRINE's memory usage. The usage is high for FSM compared to other applications due to large domain maps for support calculation.</p><p>Load Balancing. Since PEREGRINE threads dynamically pick up tasks as they become free, we observe near-zero load imbalance while matching p 1 across all our datasets. The difference between times taken by threads to finish all of their work was only up to 71 ms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>There has been a variety of research to develop efficient graph mining solutions. To the best of our knowledge, PEREGRINE is the first general-purpose graph mining system to leverage pattern-awareness in its programming and processing models.</p><p>General-Purpose Graph Mining Systems. Several general-purpose graph mining systems have been developed <ref type="bibr" target="#b21">[8,</ref><ref type="bibr" target="#b25">12,</ref><ref type="bibr" target="#b35">22,</ref><ref type="bibr" target="#b47">34,</ref><ref type="bibr" target="#b65">52,</ref><ref type="bibr" target="#b70">57]</ref>. Arabesque <ref type="bibr" target="#b65">[52]</ref> is a distributed graph mining system that follows a filter-process model developed on top of map-reduce. It proposed the "Think Like an Embedding" processing model. Fractal <ref type="bibr" target="#b25">[12]</ref> extends this to the concept of fractoids, which expose parts of the user program to the system; in conjunction with depth-first exploration, fractoids allow the system to more intelligently plan its execution. G-Miner <ref type="bibr" target="#b21">[8]</ref> is a task-oriented distributed graph mining system that enables building custom graph mining use cases using a distributed task queue. RStream <ref type="bibr" target="#b70">[57]</ref> is a single machine out-of-core graph mining system that leverages SSDs to store intermediate solutions. It uses relational algebra to express mining tasks as table joins.</p><p>AutoMine <ref type="bibr" target="#b47">[34]</ref> is a recent single-machine system that generates efficient code to match patterns for common graph mining tasks. As discussed in §2.2, none of these systems are fully pattern-aware, the way PEREGRINE is: these systems perform unnecessary explorations and computations, require large memory (or storage) capacity, and lack the ability to easily express mining tasks at a high level. While Fractal uses symmetry breaking for pattern matching use case, other applications like FSM and motif counting are not guided by symmetry breaking, and hence they end up performing unnecessary explorations. Similarly, AutoMine also does not employ symmetry breaking for any of the use cases, requiring users to filter duplicate matches by individually examining every single match when enumerating patterns. Lack of full pattern-awareness not only makes these systems slower, but also limits their applicability to more complex mining use cases. Finally, ASAP <ref type="bibr" target="#b35">[22]</ref> is a programmable distributed system for approximate graph mining where users write programs based on sampling edges and vertices to reason about the probabilistic counts of patterns.</p><p>Purpose-Built Graph Mining Solutions. These works efficiently perform specific graph mining tasks. ApproxG <ref type="bibr" target="#b48">[35]</ref> is an efficient system for computing approximate graphlet (motif) counts with accuracy guarantees. <ref type="bibr" target="#b15">[2]</ref> uses combinatorial arguments to obtain counts for size 3 and 4 motifs after counting smaller motifs. <ref type="bibr" target="#b23">[10]</ref> efficiently lists k-cliques in sparse graphs and <ref type="bibr" target="#b17">[4]</ref> is aimed at k-plexes which are cliquelike structures. GraMi <ref type="bibr" target="#b26">[13]</ref> leverages anti-monotonicity for FSM on a single machine while ScaleMine <ref type="bibr" target="#b14">[1]</ref> is a distributed system for FSM that uses efficiently computable approximate stats to inform its graph exploration. <ref type="bibr" target="#b64">[51]</ref> is also a distributed system focusing on FSM. <ref type="bibr" target="#b63">[50,</ref><ref type="bibr" target="#b74">61]</ref> are recent works aimed at analyzing small graphs whose edges have large attribute sets.</p><p>Several systems aim to perform efficient pattern matching. OPT <ref type="bibr" target="#b38">[25]</ref> is a fast single-machine out-of-core trianglecounting system whose techniques are generalized by Dual-Sim <ref type="bibr" target="#b37">[24]</ref> to match arbitrary patterns. <ref type="bibr" target="#b62">[49]</ref> proposes several provably cache-friendly parallel triangle-counting algorithms which provide order-of-magnitude speedups over previous algorithms. DistTC <ref type="bibr" target="#b33">[20]</ref> presents a distributed triangle-counting technique that leverages a novel graph partitioning strategy to count triangles with minimal communication overhead.</p><p>[31] is a distributed map-reduce based pattern matching system that first finds small patterns and joins them into large ones. QFrag <ref type="bibr" target="#b60">[47]</ref> is another map-reduce based distributed pattern matching system that focuses on searching graphs for large patterns using the TurboISO <ref type="bibr" target="#b32">[19]</ref> algorithm. Prune-Juice <ref type="bibr" target="#b56">[43]</ref> is a distributed pattern matching system that focuses on pruning data graph vertices that cannot contribute to a match. <ref type="bibr" target="#b31">[18]</ref> is a scalable subgraph isomorphism algorithm while TurboFlux <ref type="bibr" target="#b39">[26]</ref> performs pattern matching on dynamically changing data graphs. <ref type="bibr" target="#b53">[40]</ref> presents a pattern matching plan optimizer incorporated in Graphflow <ref type="bibr" target="#b36">[23]</ref> that uses both binary and multi-way joins. <ref type="bibr" target="#b57">[44]</ref> is a resource-aware distributed graph querying system for property graphs.</p><p>Graph Processing Systems. Several works enable processing static and dynamic graphs <ref type="bibr" target="#b24">[11,</ref><ref type="bibr" target="#b27">14,</ref><ref type="bibr" target="#b28">15,</ref><ref type="bibr" target="#b34">21,</ref><ref type="bibr" target="#b42">29,</ref><ref type="bibr" target="#b45">32,</ref><ref type="bibr" target="#b46">33,</ref><ref type="bibr" target="#b55">42,</ref><ref type="bibr" target="#b58">45,</ref><ref type="bibr" target="#b59">46,</ref><ref type="bibr" target="#b61">48,</ref><ref type="bibr" target="#b67">[54]</ref><ref type="bibr" target="#b68">[55]</ref><ref type="bibr" target="#b69">[56]</ref><ref type="bibr" target="#b75">62]</ref>. These systems typically compute values on vertices and edges rather than analyzing substructures in graphs. They decompose computation at vertex and edge level, which is not suitable for graph mining use cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We presented PEREGRINE, a pattern-aware graph mining system that efficiently explores subgraph structures of interest, and scales to complex graph mining tasks on large graphs. PEREGRINE uses 'pattern-based programming' that treats patterns as first class constructs. We further introduced two novel abstractions: ANTI-EDGE and ANTI-VERTEX, that express advanced structural constraints on patterns to be matched. This allows users to directly operate on patterns and easily express complex mining use cases as 'pattern programs' on PEREGRINE.</p><p>Our extensive evaluation showed that PEREGRINE outperforms the existing state-of-the-art by several orders of magnitude, even when it has access to up to 8× fewer CPU cores. Furthermore, PEREGRINE successfully handles resource-intensive graph mining tasks on billion-scale graphs on a single machine, while the state-of-the-art fails even with a cluster of 8 such machines or access to large SSDs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. PEREGRINE Pattern Interface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Example patterns with Anti-Edges and Anti-Vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Void updateSupport(Match m) { mapPattern(m.getDomain()); } Bool isFrequent(Pattern p, Domain d) { return (d[p].support() &gt;= threshold); } DataGraph G = loadDataGraph("labeledInput.graph"); Set&lt;Pattern&gt; patterns = generateAllEdgeInduced(2); while (patterns not empty) { Map&lt;Pattern, Domain&gt; results = match(G, patterns, updateSupport); Set&lt;Pattern&gt; frequentPatterns = results.filter(isFrequent).keys(); patterns = extendByEdge(frequentPatterns); } (a) Frequent Subgraph Mining Int numTriplets = 0; Void countAndCheck(Match m) { Int numTriangles = loadAggregatedValue(m); if (numTriangles * 3/numTriplets &gt; bound) stopExploration(); else mapPattern(m, 1); } DataGraph G = loadDataGraph("input.graph"); Pattern wedge = generateStar(3); numTriplets = 2 * count(G, wedge); Pattern triangle = generateClique(3); Map&lt;Pattern, Int&gt; result = match(G, triangle, countAndCheck); (b) Global Clustering Coefficient Bound DataGraph G = loadDataGraph("input.graph"); Void output(Match m) { write(m); } Pattern p = loadPattern("pattern.txt"); match(G, p, output); (c) Pattern Matching DataGraph G = loadDataGraph("input.graph"); Pattern p = generateClique(desiredSize); Int result = count(G, p); (d) Clique Counting DataGraph G = loadDataGraph("input.graph"); Set&lt;Pattern&gt; patterns = generateAllVertexInduced(size); Map&lt;Pattern, Int&gt; result = count(G, patterns); (e) Motif Counting Void found(Match m) { mapPattern(m, True); stopExploration(); } DataGraph G = loadDataGraph("input.graph"); Pattern p = generateClique(desiredSize); Map&lt;Pattern, Bool&gt; result = match(G, p, found); (f) Clique Existence</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Graph mining use cases in PEREGRINE's pattern-aware programming model. §4.3), and hence, it directly matches only those subgraphs that satisfy absence of vertices across neighborhoods as defined by anti-vertex constraint.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>□Figure 5 .</head><label>5</label><figDesc>Figure 5. Computing exploration plan.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Example of a pattern graph and a data graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Pattern-Aware Processing Model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Patterns used in evaluation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Execution times (in seconds) for PEREGRINE with (PRG) and without (PRG-U) symmetry breaking. PRG-U could not finish matching any of the 4-motif patterns on Orkut within 5 hours.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. PEREGRINE 4-motif execution time breakdown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. (a) Scalability (PRG HT = hyper-threaded). (b) CPU utilization (solid) and memory bandwidth (dashed)for 24 cores (blue), 47 cores (green) and 94 cores (red).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Peak memory usage of different systems across various applications. Tall red bars represent RStream out of memory errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Step-by-step exploration in graph mining systems starting at vertex 1 and vertex 3. In total, 13 partial matches get explored and 13 canonicality checks are performed that prune out 5 partial matches. Isomorphism checks are performed on the remaining 8 matches for applications like FSM.</figDesc><table><row><cell cols="4">+ + (a) System + : Canonical : Redundant (Non-Canonical) _ RStream Arabesque Fractal (b) Profiling results for 4-Clique Counting on Patents [17] which contains Total Canonicality Isomorphism Matches Computations Computations 1.2B (342×) 33.0M 0 1.4B (400×) 1.4B 3.5M 659.0M (188×) 599.6M 0 ∼3.5M cliques of size 4. Isomorphism counts are 0 for RStream and Fractal because they have native support for clique computation. System Total Canonicality Isomorphism Matches Computations Computations RStream 40.1B (125×) 40.1B 343.3M Arabesque 685.8M (2.1×) 685.8M 320.7M</cell></row><row><cell>Fractal</cell><cell>665.6M (2.1×)</cell><cell>649.1M</cell><cell>320.7M</cell></row><row><cell cols="4">(c) Profiling results for 3-Motif Counting on Patents [17] which contains</cell></row><row><cell></cell><cell cols="2">∼320M 3-sized motifs.</cell><cell></cell></row></table><note>Figure 1. Left: Example illustrating step-by-step exploration; Right: Number of matches explored (partial and full), canonicality checks performed, and isomorphism checks performed by RStream</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Void matchFrom(Match m, Pattern p, Func f, MatchingOrder mo, PartialOrder po, Int i) { if (i &gt; |V (p C ) |) { // remaps m as in §4.1, before completing it // and invoking the user's callback f()</figDesc><table><row><cell>completeMatch(m, p, f, po, 1);</cell></row><row><cell>} else {</cell></row><row><cell>for (v in getExtensionCandidates(mo, po, i)) {</cell></row><row><cell>matchFrom(m+v, p, f, mo, po, i+1);</cell></row><row><cell>}</cell></row><row><cell>}</cell></row><row><cell>}</cell></row><row><cell>AggregationVal match(Graph G, Pattern p, Func f) {</cell></row><row><cell>Aggregator a;</cell></row><row><cell>(p C , partialOrder, matchingOrders) =</cell></row><row><cell>generatePlan(p);</cell></row><row><cell>parallel for (v in G) {</cell></row><row><cell>for (matchingOrder in matchingOrders) {</cell></row><row><cell>matchFrom({v}, p, f, matchingOrder,</cell></row><row><cell>partialOrders, 1);</cell></row><row><cell>}</cell></row><row><cell>}</cell></row><row><cell>return a.result();</cell></row><row><cell>}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The matching threads swap the global aggregation value with the local aggregation value and set a flag to indicate that new thread-local aggregation values are available for aggregation. The aggregator thread blocks until all threadlocal aggregation values become available, after which it performs the aggregation and resets the flag to indicate that the global aggregation value is available. With this design, our matching threads remain non-blocking to retain high matching throughput.</figDesc><table><row><cell>G</cell><cell cols="3">|V (G)| |E(G)| |L(G)|</cell><cell cols="2">Max. Avg. Deg. Deg.</cell></row><row><cell>(MI) Mico [13]</cell><cell>100K</cell><cell>1M</cell><cell>29</cell><cell cols="2">96637 21.6</cell></row><row><cell>(PA) Patents [17]</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>| -Unlabeled</cell><cell>3.7M</cell><cell>16M</cell><cell>-</cell><cell>793</cell><cell>10</cell></row><row><cell>| -Labeled</cell><cell>2.7M</cell><cell>13M</cell><cell>37</cell><cell>789</cell><cell>10</cell></row><row><cell>(OK) Orkut [60]</cell><cell cols="2">3M 117M</cell><cell>-</cell><cell>33133</cell><cell>76</cell></row><row><cell>(FR) Friendster [60]</cell><cell>65M</cell><cell>1.8B</cell><cell>-</cell><cell>5214</cell><cell>55</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 .</head><label>3</label><figDesc>Execution times (in seconds) for PEREGRINE, Arabesque</figDesc><table><row><cell>App</cell><cell cols="2">G PEREGRINE</cell><cell cols="4">Arabesque ABQ-8 ABQ-1 RS-96 RS-16 RStream</cell></row><row><cell cols="2">3-Motifs MI PA OK FR</cell><cell cols="5">0.12 158.05 39.05 3.10 870.70 525.49 2685.45 2186.93 51.83 252.74 17.90 --/ / 370.64 --/ /</cell></row><row><cell cols="2">4-Motifs MI PA OK</cell><cell>6.74 12.04 6156.10</cell><cell>---</cell><cell>---</cell><cell>/ / /</cell><cell>/ × /</cell></row><row><cell cols="2">2K-FSM MI 3K-FSM MI 4K-FSM MI</cell><cell cols="3">380.81 3418.25 821.60 279.74 3520.82 784.27 250.68 3514.97 779.75</cell><cell>× × ×</cell><cell>---</cell></row><row><cell cols="2">20K-FSM PA 21K-FSM PA 22K-FSM PA 23K-FSM PA</cell><cell cols="2">859.41 647.97 507.56 342.63 --402.57 299.12</cell><cell cols="2">-1757.69 -1711.87 -1626.53 -1936.92</cell><cell>----</cell></row><row><cell cols="2">3-Cliques MI PA OK FR</cell><cell cols="5">0.05 0.59 155.55 87.26 18.62 5.98 13.75 --986.20 1643.10 7.34 11.32 8.40 11.97 296.99 --/ /</cell></row><row><cell cols="2">4-Cliques MI PA OK FR</cell><cell cols="5">2.02 1598.09 353.37 266.61 0.90 249.38 107.02 105.00 181.30 -281.47 --/ / 1337.77 --/ /</cell></row><row><cell cols="2">5-Cliques MI PA OK FR</cell><cell cols="5">89.60 1.12 352.64 122.09 145.00 237.90 × ---3182.56 --/ / 4214.72 --/ /</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 .</head><label>4</label><figDesc>Execution times (in seconds) for PEREGRINE and Fractal<ref type="bibr" target="#b25">[12]</ref>. '-' indicates the system ran out of memory. '×' indicates the execution did not finish within 5 hours.</figDesc><table><row><cell>G</cell><cell>PEREGRINE</cell><cell cols="2">Fractal FCL-8 FCL-1</cell></row><row><cell>3-Motifs MI PA OK FR</cell><cell cols="3">0.12 3.10 231.95 214.34 22.13 17.11 17.90 --370.64 --</cell></row><row><cell>4-Motifs MI PA OK</cell><cell cols="3">6.74 12.04 362.19 742.35 78.66 420.67 6156.10 --</cell></row><row><cell>2K-FSM MI 3K-FSM MI 4K-FSM MI</cell><cell cols="3">380.81 154.47 675.98 279.74 154.74 680.33 250.68 144.34 663.26</cell></row><row><cell>20K-FSM PA 21K-FSM PA 22K-FSM PA 23K-FSM PA</cell><cell cols="2">851.41 647.97 507.56 402.57 451.18 × × ×</cell><cell>----</cell></row><row><cell>3-Cliques MI PA OK FR</cell><cell cols="3">0.05 0.59 232.60 216.76 18.71 17.21 13.75 --296.99 --</cell></row><row><cell>4-Cliques MI PA OK FR</cell><cell cols="3">2.02 0.90 237.64 224.50 25.77 34.79 281.47 --1337.77 --</cell></row><row><cell>5-Cliques MI PA OK FR</cell><cell cols="3">89.60 181.30 904.65 1.12 266.88 217.30 3182.56 --4214.72 --</cell></row><row><cell>Match p 1 MI PA OK FR</cell><cell cols="3">0.12 0.84 235.72 189.03 24.76 36.02 38.97 --824.62 --</cell></row><row><cell>Match p 2 MI PA OK FR</cell><cell cols="3">0.03 1.07 260.15 202.23 22.11 16.85 474.09 --18.09 --</cell></row><row><cell>Match p 3 MI PA OK</cell><cell cols="3">19.93 181.76 1288.94 13.41 30.18 69.33 13292.77 --</cell></row><row><cell>Match p 4 MI PA OK FR</cell><cell cols="3">12.29 120.99 789.81 2.23 25.58 21.63 1569.73 --7057.40 --</cell></row><row><cell>Match p 5 MI PA OK FR</cell><cell>14.94 1.89 1381.03 6726.51</cell><cell cols="2">56.51 345.35 25.30 17.39 ----</cell></row><row><cell>Match p 6 MI PA</cell><cell cols="3">65.26 27.94 210.04 205.39 × ×</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5 .</head><label>5</label><figDesc>Execution times (in seconds) for PEREGRINE and G-Miner<ref type="bibr" target="#b21">[8]</ref>. '/' indicates the system ran out of disk space.6.3 Comparison with Depth-First EnumerationTable 4 compares PEREGRINE's performance with Fractal on motif-counting, clique-counting, FSM, and pattern matching. As we can see, PEREGRINE is faster than Fractal by at least an order of magnitude across most of the applications. For instance, 4-cliques on Patents finished in less than a second on PEREGRINE whereas Fractal took over 200 seconds in both cluster and single-node configurations.Given equal resources (i.e., on a single node), FSM on Mico is up to 2.6× faster on PEREGRINE compared to that on Fractal. Furthermore, PEREGRINE scales to the larger dataset while Fractal does not. Even with 8 nodes, Fractal only outperforms PEREGRINE on the small Mico graph, and cannot handle the Patents workload except for very high support thresholds, where there is less work to be done; there too, PEREGRINE executes faster than Fractal.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 6 .</head><label>6</label><figDesc>PEREGRINE execution times (in seconds) for matching with an anti-vertex (p 7</figDesc><table><row><cell></cell><cell>14-Clique</cell><cell>p 7</cell><cell>p 8</cell></row><row><cell>MI PA OK FR</cell><cell>0.07 3.95 4.08 50.39</cell><cell>0.65 0.67 56.06 470.21</cell><cell>6.92 1.69 879.01 4017.15</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0">A connected vertex cover is a subset of connected vertices that covers all edges.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank our shepherd Aleksandar Prokopec and the anonymous reviewers for their valuable and thorough feedback. This work is supported by the Natural Sciences and Engineering Research Council of Canada.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">Set&lt;Pattern&gt; loadPatterns</title>
				<imprint/>
	</monogr>
	<note>String filename</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">Set&lt;Pattern&gt; generateAllEdgeInduced</title>
				<imprint/>
	</monogr>
	<note>Int size</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">Set&lt;Pattern&gt; generateAllVertexInduced</title>
				<imprint/>
	</monogr>
	<note>Int size</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Pattern generateClique</title>
		<imprint/>
	</monogr>
	<note>Int size</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Pattern generateStar</title>
		<imprint/>
	</monogr>
	<note>Int size</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Pattern generateChain</title>
		<imprint/>
	</monogr>
	<note>Int size</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m">Set&lt;Pattern&gt; extendByEdge</title>
				<imprint/>
	</monogr>
	<note>Set&lt;Pattern&gt; patterns</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">Set&lt;Pattern&gt; extendByVertex</title>
				<imprint/>
	</monogr>
	<note>Set&lt;Pattern&gt; patterns</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m">class Pattern { Set&lt;Vertex&gt; getNeighbors</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Label getLabel(Vertex u)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bool areConnected(Vertex src</title>
	</analytic>
	<monogr>
		<title level="j">Vertex dst</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Void addEdge(Vertex src</title>
	</analytic>
	<monogr>
		<title level="j">Vertex dst</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Void addAntiEdge(Vertex src</title>
	</analytic>
	<monogr>
		<title level="j">Vertex dst</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Void removeEdge(Vertex src</title>
	</analytic>
	<monogr>
		<title level="j">Vertex dst</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">ScaleMine: Scalable Parallel Frequent Subgraph Mining in a Single Large Graph</title>
		<author>
			<persName><forename type="first">Ehab</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ibrahim</forename><surname>Abdelaziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Panos</forename><surname>Kalnis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zuhair</forename><surname>Khayyat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fuad</forename><surname>Jamour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC &apos;16)</title>
				<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis (SC &apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficient Graphlet Counting for Large Networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nesreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><forename type="middle">A</forename><surname>Neville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><surname>Duffield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Data Mining (ICDM &apos;15)</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Chains of Affection: The Structure of Adolescent Romantic and Sexual Networks</title>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">S</forename><surname>Bearman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Moody</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katherine</forename><surname>Stovel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Journal of Sociology</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="44" to="91" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient Enumeration of Maximal k-Plexes</title>
		<author>
			<persName><forename type="first">Devora</forename><surname>Berlowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sara</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;15)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="431" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient Subgraph Matching by Postponing Cartesian Products</title>
		<author>
			<persName><forename type="first">Fei</forename><surname>Bi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenjie</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;16)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1199" to="1214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">What Is Frequent in a Single Graph?</title>
		<author>
			<persName><forename type="first">Bjorn</forename><surname>Bringmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siegfried</forename><surname>Nijssen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Knowledge Discovery and Data Mining: 12th Pacific-Asia Conference</title>
				<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5012</biblScope>
			<biblScope unit="page" from="858" to="863" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Better Bitmap Performance with Roaring Bitmaps</title>
		<author>
			<persName><forename type="first">Samy</forename><surname>Chambi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Lemire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Owen</forename><surname>Kaser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Godin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="709" to="719" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An Efficient Task-oriented Graph Mining System</title>
		<author>
			<persName><forename type="first">Hongzhi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunjian</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Da</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><surname>G-Miner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Systems (EuroSys &apos;18)</title>
				<meeting>the European Conference on Computer Systems (EuroSys &apos;18)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Visual pattern discovery for architecture image classification and product image search</title>
		<author>
			<persName><forename type="first">Wei-Ta</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming-Hung</forename><surname>Tsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Multimedia Retrieval (ICMR &apos;12)</title>
				<meeting>the ACM International Conference on Multimedia Retrieval (ICMR &apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Listing Kcliques in Sparse Real-World Graphs*</title>
		<author>
			<persName><forename type="first">Maximilien</forename><surname>Danisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oana</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauro</forename><surname>Sozio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the World Wide Web Conference (WWW &apos;18)</title>
				<meeting>the World Wide Web Conference (WWW &apos;18)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="589" to="598" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Low-Latency Graph Streaming Using Compressed Purely-Functional Trees</title>
		<author>
			<persName><forename type="first">Laxman</forename><surname>Dhulipala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;19)</title>
				<meeting>the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="918" to="934" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fractal: A General-Purpose Graph Pattern Mining System</title>
		<author>
			<persName><forename type="first">Vinicius</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><forename type="middle">H C</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dorgival</forename><surname>Guedes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meira</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivasan</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;19)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1357" to="1374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">GraMi: Frequent Subgraph and Pattern Mining in a Single Large Graph</title>
		<author>
			<persName><forename type="first">Mohammed</forename><surname>Elseidy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ehab</forename><surname>Abdelhamid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB &apos;14)</title>
				<meeting>the VLDB Endowment (PVLDB &apos;14)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="517" to="528" />
		</imprint>
	</monogr>
	<note>Spiros Skiadopoulos, and Panos Kalnis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">PowerGraph: Distributed Graph-parallel Computation on Natural Graphs</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haijie</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;12)</title>
				<meeting>the USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="17" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">GraphX: Graph Processing in a Distributed Dataflow Framework</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reynold</forename><forename type="middle">S</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankur</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Crankshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;14)</title>
				<meeting>the USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;14)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="599" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Network Motif Discovery Using Subgraph Enumeration and Symmetry-Breaking</title>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">A</forename><surname>Grochow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Kellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research in Computational Molecular Biology</title>
				<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="92" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The NBER Patent Citation Data File: Lessons, Insights and Methodological Tools</title>
		<author>
			<persName><forename type="first">Bronwyn</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Jaffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Trajtenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NBER Working Paper</title>
		<imprint>
			<biblScope unit="volume">8498</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient Subgraph Matching: Harmonizing Dynamic Programming, Adaptive Matching Order, and Failing Set Together</title>
		<author>
			<persName><forename type="first">Myoungji</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyunjoon</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geonmo</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kunsoo</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;19)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1429" to="1446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">TurboISO: Towards Ultrafast and Robust Subgraph Isomorphism Search in Large Graph Databases</title>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinsoo</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hoon</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;13)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;13)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">DistTC: High Performance Distributed Triangle Counting</title>
		<author>
			<persName><forename type="first">Loc</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vishwesh</forename><surname>Jatala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuhao</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Udit</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE High Performance Extreme Computing Conference (HPEC &apos;19)</title>
				<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">D: a fast distributed graph processing engine</title>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siegfried</forename><surname>Depner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Manhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Der</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Merijn</forename><surname>Lugt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Verstraaten</surname></persName>
		</author>
		<author>
			<persName><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><surname>Pgx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC &apos;15)</title>
				<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis (SC &apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Shivaram Venkataraman, Vladimir Braverman, and Ion Stoica</title>
		<author>
			<persName><forename type="first">Anand Padmanabha</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zaoxing</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Jin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;18)</title>
				<meeting>the USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;18)<address><addrLine>Carlsbad, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="745" to="761" />
		</imprint>
	</monogr>
	<note>ASAP: Fast, Approximate Graph Pattern Mining at Scale</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Graphflow: An Active Graph Database</title>
		<author>
			<persName><forename type="first">Chathura</forename><surname>Kankanamge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddhartha</forename><surname>Sahu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amine</forename><surname>Mhedbhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;17)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1695" to="1698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">DUALSIM: Parallel Subgraph Enumeration in a Massive Graph on a Single Machine</title>
		<author>
			<persName><forename type="first">Hyeonji</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juneyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sourav</forename><forename type="middle">S</forename><surname>Bhowmick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeonghoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seongyun</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Moath</surname></persName>
		</author>
		<author>
			<persName><surname>Jarrah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;16)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1231" to="1245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">OPT: A New Framework for Overlapped and Parallel Triangulation in Large-scale Graphs</title>
		<author>
			<persName><forename type="first">Jinha</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangyeon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyungyeol</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hwanjo</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;14)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;14)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="637" to="648" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">TurboFlux: A Fast Continuous Subgraph Matching System for Streaming Graph Data</title>
		<author>
			<persName><forename type="first">Kyoungmin</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">In</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyungyu</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geonhwa</forename><surname>Jeong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;18)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;18)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="411" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Social Network Analysis: Methods and Applications</title>
		<author>
			<persName><forename type="first">Anton</forename><surname>Korshunov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Beloborodov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nazar</forename><surname>Buzun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valeriy</forename><surname>Avanesov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Pastukhov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyrylo</forename><surname>Chykhradze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Kozlov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gomzin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Andrianov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Sysoev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stepan</forename><surname>Ipatov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Filonenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christina</forename><surname>Chuprina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Turdakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Institute for System Programming of RAS</title>
				<meeting>the Institute for System Programming of RAS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="439" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A combinatorial algorithm for calculating ligand binding</title>
		<author>
			<persName><forename type="first">Frederick</forename><forename type="middle">S</forename><surname>Kuhl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gordon</forename><forename type="middle">M</forename><surname>Crippen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">K</forename><surname>Friesen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Chemistry</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="34" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">GraphOne: A Data Store for Real-Time Analytics on Evolving Graphs</title>
		<author>
			<persName><forename type="first">Pradeep</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Conference on File and Storage Technologies (FAST &apos;19)</title>
				<meeting>the USENIX Conference on File and Storage Technologies (FAST &apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="249" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Finding Frequent Patterns in a Large Sparse Graph*</title>
		<author>
			<persName><forename type="first">Michihiro</forename><surname>Kuramochi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Karypis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="243" to="271" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Scalable Distributed Subgraph Enumeration</title>
		<author>
			<persName><forename type="first">Longbin</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ying</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shiyu</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB &apos;16)</title>
				<meeting>the VLDB Endowment (PVLDB &apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="217" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Pregel: A System for Large-Scale Graph Processing</title>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">H</forename><surname>Austern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Aart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilan</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naty</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Google</forename><surname>Czajkowski</surname></persName>
		</author>
		<author>
			<persName><surname>Inc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;10)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">GraphBolt: Dependency-Driven Synchronous Processing of Streaming Graphs</title>
		<author>
			<persName><forename type="first">Mugilan</forename><surname>Mariappan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Systems (EuroSys &apos;19)</title>
				<meeting>the European Conference on Computer Systems (EuroSys &apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">AutoMine: Harmonizing High-level Abstraction and High Performance for Graph Mining</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP &apos;19)</title>
				<meeting>the ACM Symposium on Operating Systems Principles (SOSP &apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="509" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">ApproxG: Fast Approximate Parallel Graphlet Counting Through Accuracy Control</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dinesh</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chao</forename><surname>Ai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing (CCGRID &apos;18)</title>
				<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="533" to="542" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">An Overview of Social Network Analysis</title>
		<author>
			<persName><forename type="first">Jean</forename><surname>Mcgloin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Kirk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Criminal Justice Education</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="169" to="181" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Scalability! But at what COST?</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Hot Topics in Operating Systems (HotOS XV)</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Flexible and Feasible Support Measures for Mining Frequent Patterns in Large Labeled Graphs</title>
		<author>
			<persName><forename type="first">Jinghan</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi-Cheng</forename><surname>Tu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;17)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="391" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Discovery of Significantly Enriched Subgraphs Associated with Selected Vertices in a Single Graph</title>
		<author>
			<persName><forename type="first">Pieter</forename><surname>Meysman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yvan</forename><surname>Saeys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ehsan</forename><surname>Sabaghian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wout</forename><surname>Bittremieux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Data Mining in Bioinformatics</title>
				<meeting>the International Workshop on Data Mining in Bioinformatics</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>Yves Van de Peer, Bart Goethals, and Kris Laukens</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Optimizing Subgraph Queries by Combining Binary and Worst-Case Optimal Joins</title>
		<author>
			<persName><forename type="first">Amine</forename><surname>Mhedhbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB &apos;19)</title>
				<meeting>the VLDB Endowment (PVLDB &apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1692" to="1704" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<author>
			<persName><forename type="first">Ron</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Shen-Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shalev</forename><surname>Itzkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dmitri</forename><surname>Kashtan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uri</forename><surname>Chklovskii</surname></persName>
		</author>
		<author>
			<persName><surname>Alon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network Motifs: Simple Building Blocks of Complex Networks</title>
				<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">298</biblScope>
			<biblScope unit="page" from="824" to="827" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A Lightweight Infrastructure for Graph Analytics</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP &apos;13)</title>
				<meeting>the ACM Symposium on Operating Systems Principles (SOSP &apos;13)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="456" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">PruneJuice: Pruning Trillion-edge Graphs to a Precise Pattern-matching Solution</title>
		<author>
			<persName><forename type="first">Tahsin</forename><surname>Reza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matei</forename><surname>Ripeanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Tripoul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roger</forename><surname>Pearce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage, and Analysis (SC &apos;18)</title>
				<meeting>the International Conference for High Performance Computing, Networking, Storage, and Analysis (SC &apos;18)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">A Scalable Distributed Graph Pattern Matching Engine</title>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">P</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Trigonakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Potter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><forename type="middle">Pgx</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><surname>Async</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Graph Data-Management Experiences &amp; Systems (GRADES &apos;17)</title>
				<meeting>the International Workshop on Graph Data-Management Experiences &amp; Systems (GRADES &apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Chaos: Scale-out Graph Processing from Secondary Storage</title>
		<author>
			<persName><forename type="first">Amitabha</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Bindschaedler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jasmina</forename><surname>Malicevic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP &apos;15)</title>
				<meeting>the ACM Symposium on Operating Systems Principles (SOSP &apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="410" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">GPS: A Graph Processing System</title>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Scientific and Statistical Database Management (SSDBM &apos;13)</title>
				<meeting>the International Conference on Scientific and Statistical Database Management (SSDBM &apos;13)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">QFrag: Distributed Graph Search via Subgraph Isomorphism</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gianmarco</forename><surname>De Francisci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgos</forename><surname>Morales</surname></persName>
		</author>
		<author>
			<persName><surname>Siganos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Cloud Computing (SoCC &apos;17)</title>
				<meeting>the Symposium on Cloud Computing (SoCC &apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="214" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Ligra: A Lightweight Graph Processing Framework for Shared Memory</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;13)</title>
				<meeting>the ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;13)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Multicore triangle computations without tuning</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kanat</forename><surname>Tangwongsan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Data Engineering (ICDE &apos;15)</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Answering Why-Questions for Subgraph Queries in Multi-attributed Graphs</title>
		<author>
			<persName><forename type="first">Qi</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Hossein Namaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yinghui</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Data Engineering (ICDE &apos;19)</title>
				<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A Distributed Approach for Graph Mining in Massive Networks</title>
		<author>
			<persName><forename type="first">Nilothpal</forename><surname>Talukder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammed</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1024" to="1052" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Arabesque: A System for Distributed Graph Mining</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Carlos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><forename type="middle">J</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgos</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammed</forename><forename type="middle">J</forename><surname>Siganos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP &apos;15)</title>
				<meeting>the ACM Symposium on Operating Systems Principles (SOSP &apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="425" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Bit-vector Algorithms for Binary Constraint Satisfaction and Subgraph Isomorphism</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Ullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Experimental Algorithmics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">KickStarter: Fast and Accurate Computations on Streaming Graphs via Trimmed Approximations</title>
		<author>
			<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guoqing</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)</title>
				<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="237" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">ASPIRE: Exploiting Asynchronous Parallelism in Iterative Algorithms Using a Relaxed Consistency Based DSM</title>
		<author>
			<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charan</forename><surname>Sai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajiv</forename><surname>Koduru</surname></persName>
		</author>
		<author>
			<persName><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGPLAN International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;14)</title>
				<meeting>SIGPLAN International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;14)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="861" to="878" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">CoRAL: Confined Recovery in Distributed Asynchronous Graph Processing</title>
		<author>
			<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ziang</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)</title>
				<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="223" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">RStream: Marrying Relational Algebra with Streaming for Efficient Graph Mining on a Single Machine</title>
		<author>
			<persName><forename type="first">Kai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiqiang</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Thorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tien</forename><forename type="middle">Quang</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guoqing</forename><forename type="middle">Harry</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;18)</title>
				<meeting>the USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;18)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="763" to="782" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">An Efficiently Computable Support Measure for Frequent Subgraph Pattern Mining</title>
		<author>
			<persName><forename type="first">Yuyi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Ramon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning and Knowledge Discovery in Databases (ECML PKDD &apos;12)</title>
				<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="362" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Tracing Fake-News Footprints: Characterizing Social Media Messages by How They Propagate</title>
		<author>
			<persName><forename type="first">Liang</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huan</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Web Search and Data Mining (WSDM &apos;18)</title>
				<meeting>the ACM International Conference on Web Search and Data Mining (WSDM &apos;18)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="637" to="645" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Defining and Evaluating Network Communities based on Ground-Truth</title>
		<author>
			<persName><forename type="first">Jaewon</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge and Information Systems</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="181" to="213" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Maverick: Discovering Exceptional Facts from Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Gensheng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damian</forename><surname>Jimenez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengkai</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Management of Data (SIGMOD &apos;18)</title>
				<meeting>the ACM International Conference on Management of Data (SIGMOD &apos;18)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1317" to="1332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Gemini: A Computation-Centric Distributed Graph Processing System</title>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weimin</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaosong</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;16)</title>
				<meeting>the USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="301" to="316" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
