<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Probabilistic Program Analysis with Martingales</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aleksandar</forename><surname>Chakarov</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Colorado</orgName>
								<address>
									<settlement>Boulder</settlement>
									<region>CO</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sriram</forename><surname>Sankaranarayanan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Colorado</orgName>
								<address>
									<settlement>Boulder</settlement>
									<region>CO</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Probabilistic Program Analysis with Martingales</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D9F2E15F1523DECE1930CA519CA278EA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present techniques for the analysis of infinite state probabilistic programs to synthesize probabilistic invariants and prove almost-sure termination. Our analysis is based on the notion of (super) martingales from probability theory. First, we define the concept of (super) martingales for loops in probabilistic programs. Next, we present the use of concentration of measure inequalities to bound the values of martingales with high probability. This directly allows us to infer probabilistic bounds on assertions involving the program variables. Next, we present the notion of a super martingale ranking function (SMRF) to prove almost sure termination of probabilistic programs. Finally, we extend constraint-based techniques to synthesize martingales and super-martingale ranking functions for probabilistic programs. We present some applications of our approach to reason about invariance and termination of small but complex probabilistic programs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Probabilistic programs are obtained by enriching standard imperative programming languages with random value generators that yield sequences of (pseudo) random samples from some probability distribution. These programs commonly occur in a variety of situations including randomized algorithms <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b11">12]</ref>, network protocols, probabilistic robotics, and monte-carlo simulations. The analysis of probabilistic programs is a rich area that has received a lot of attention in the past, yielding tools such as PRISM <ref type="bibr" target="#b18">[18]</ref> that implement a wide variety of approaches ranging from symbolic <ref type="bibr" target="#b1">[2]</ref> to statistical model checking <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>Our goal in this paper is to investigate a deductive approach to infinite state probabilistic programs, exploring techniques for synthesizing invariance and termination proofs in a probabilistic setting. Our approach is an extension of McIver and Morgan's quantitative invariants <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b20">20]</ref>. Whereas the earlier approach is limited to discrete probabilistic choices (eg., Bernoulli trials), our extension handles probabilistic programs with integer and real-valued random variables according to a range of distributions including uniform, Gaussian and Poisson. We make use of the concepts of martingales and super martingales from probability theory to enable the synthesis of probabilistic invariants and almost sure termination proofs. A martingale expression for a program is one whose expected value after the (n + 1) th loop iteration is equal to its sample value at the n th iteration. We use Azuma-Hoeffding theorem to derive probabilistic bounds on the value of a martingale expression. Next, we present the concept of a super martingale ranking function (SMRF) to prove almost sure termination of loops that manipulate real-valued variables. Finally, we extend constraint-based program analysis techniques originally proposed by <ref type="bibr">Colón et al.</ref> to yield techniques for inferring martingales and super-martingales using a template (super) martingale expression with unknown coefficients <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref>. Our approach uses Farkas lemma to encode the conditions for being a (super) martingale as a system of linear inequality constraints over the unknown coefficients. However, our approach does not require non-linear constraint solving unlike earlier constraint-based approaches <ref type="bibr" target="#b6">[7]</ref>. The constraint-based synthesis of linear (super) martingales yields linear inequality constraints. We present a preliminary evaluation of our approach over many small but complex benchmark examples using a prototype martingale generator.</p><p>The contributions of this paper are (a) we extend quantitative invariants approach of McIver and Morgan <ref type="bibr" target="#b20">[20]</ref> to a wider class of probabilistic programs through martingale and super-martingale program expressions using concentration of measure inequalities (Azuma-Hoeffding theorem) to generate probabilistic assertions. (b) We define super martingale ranking functions (SMRFs) to prove almost sure termination of probabilistic programs. (c) We present constraint-based techniques to generate (super) martingale expressions. Some of the main limitations of the current work are: (a) currently, our approach applies to purely stochastic programs. Extensions to programs with demonic non-determinism will be considered in the future. (b) The martingale synthesis approach focuses on linear expressions and systems. Extensions to non-linear programs and expressions will be considered in the future. (c) Finally, our approach for proving almost sure termination is sound but incomplete over the reals. We identify some of the sources of incompleteness that arise especially for probabilistic programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Supplementary Materials:</head><p>An extended version of this paper that includes many of the omitted technical details along with a prototype implementation of the techniques presented here will be made available on-line at our project page<ref type="foot" target="#foot_1">1</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivating Examples</head><p>We motivate our approach on two simple examples of probabilistic programs.</p><p>Example 1. Figure <ref type="figure" target="#fig_0">1</ref> shows a program that accumulates the sum of samples drawn from a uniform random distribution between [0, 1]. Static analysis techniques can infer the invariant 0 ≤ x ≤ 501 ∧ i = N at loop exit <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b22">22]</ref>. However, the value of x remains tightly clustered around 250, as seen in Fig. <ref type="figure" target="#fig_0">1</ref>. Using the approaches in this paper, we can statically conclude the probabilistic assertion Pr(x ∈ [200, 300]) ≥ 0.84. Unlike statistical model checkers, our symbolic technique provides guaranteed probability bounds as opposed to high confidence bounds <ref type="bibr" target="#b33">[33]</ref>. For the example above, the behavior of x can also be deduced using the properties of sums of uniform random variables. However, our approach using martingale theory is quite general: the martingale and the inferred bounds hold even if the call to unifRand is substituted by (say) a truncated Gaussian distribution with mean 1  2 .</p><p>1 real x = 0; 2 real N = 500; 3 for ( i=0; i &lt; N; ++i )  Example 2 (Almost Sure Termination). Consider the program shown in Figure <ref type="figure" target="#fig_0">1</ref>. It shows a program that manipulates two real-valued variables h and t. Initially, the value of t is set to 30 and h to 0. The loop iterates as long as h ≤ t. Does the program terminate? In the worst case, the answer is no. It is possible that the coin flips avoid incrementing h or when it gets incremented, the uniform random value drawn lies in the interval [0, 1]. However, the techniques of this paper establish almost-sure termination using a super martingale expression th. Such an expression behaves like a ranking function: It is initially positive and whenever its value is non-positive, the loop termination condition is achieved. Finally, for each iteration of the loop, the value of this expression decreases in expectation by at least 1.5. Therefore, the techniques presented in this paper infer the almost sure termination of this loop. Furthermore, we also conclude the martingale expression 2.5t-h. We use Azuma-Hoeffding theorem to conclude that the value of this expression is tightly clustered around its initial value 75.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Probabilistic Transition Systems</head><p>In this section, we present a simple transition system model for probabilistic programs. Our model is inspired by the probabilistic guarded command language (PGCL) proposed by McIver et al. <ref type="bibr" target="#b21">[21]</ref>. Unlike pGCL, our model allows non-discrete real-valued random variables with arbitrary distributions (Gaussian, Uniform, Exponential etc.). However, we do not allow (demonic) non-determinism. Let X = {x 1 , . . . , x n } be a set </p><formula xml:id="formula_0">m1 • • • • • • m k ϕ p 1 X = F 1 (X, R) p k X = F k (X, R) 3 9 h ≤ t 1 2 1 2 t = t + 1 t = t + 1 h = h + r 1 h &gt; t h , t = h,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>No Demonic Restriction:</head><p>We assume that all PTSs satisfy the no demonic restriction:</p><p>1. For each location , if τ 1 and τ 2 are any two different outgoing transitions at , then their guards ϕ 1 and ϕ 2 are mutually exclusive: ϕ 1 ∧ ϕ 2 ≡ false. 2. Let ϕ 1 , . . . , ϕ p be the guards of all the outgoing transitions at location . Their disjunction is mutually exhaustive:</p><formula xml:id="formula_1">ϕ 1 ∨ ϕ 2 ∨ • • • ∨ ϕ p ≡ true.</formula><p>Mutual exhaustiveness is not strictly necessary. However, it simplifies our operational semantics considerably. The definition of a PTS seems quite involved at a first sight. We illustrate how probabilistic programs can be translated into PTS by translating the program in Example 2, as shown in Figure <ref type="figure">2</ref>. The self loop on location 9 labeled id indicates a transition with guard true and a single fork with probability 1 that applies the identity function on the state variables. This transition is added to conform to the no demonic restriction. The semantics for a PTS Π are now described formally starting from the notion of a state and the semantics of each transition.</p><p>A state of the PTS is a tuple ( , x) with location ∈ L and valuation x for the system variables X. We consider the effect of executing a single transition τ : , ϕ, f 1 , . . . , f k on a state s : ( , x). We assume that τ is enabled on s, i.e., x |= ϕ. The result of executing τ on s is a probability distribution over the post states, obtained by carrying out the following steps:</p><p>1. Choose a fork f j for j ∈ <ref type="bibr">[1, k]</ref> with probability p j , and a vector of random variables r : (r 1 , . . . , r m ) drawn according to the joint distribution D. 2. Update the states by computing the function x = F j (x, r). The post-location is updated to m j ∈ L.</p><p>Let POST-DISTRIB(s, τ ) represent the distribution of the post states ( , x ) starting from a fixed state s : ( , x) for an enabled transition τ . A formal definition is provided in our extended version. Due to the no demonic restriction, exactly one transition τ is enabled for each state s. Therefore, the distribution POST-DISTRIB(s, τ ) can simply be written as POST-DISTRIB(s) since τ is uniquely defined given s. Operationally, a PTS is a Markov chain, where each sample execution is a countable sequence of states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Sample Executions). Let Π be a transition system. A sample execution</head><formula xml:id="formula_2">σ of Π is a countably infinite sequence of states σ : ( 0 , x 0 ) τ1 -→ ( 1 , x 1 ) τ2 -→ • • • τn -→ ( n , x n ) • • • , such that (a) ( 0 , x 0 ) is the unique initial state. (b)</formula><p>The state s j : ( j , x j ) for j ≥ 0 satisfies the guard for the transition τ j+1 . Note that by the no demonic restriction, τ j+1 is uniquely defined for each s j . (c) Each state s j+1 : ( j+1 , x j+1 ) is a sample from POST-DISTRIB(s j ). Almost-Sure Termination: Let Π be a PTS with a special final location F . We assume that the only outgoing transition at the final location is the identity transition id, as defined earlier. A sample execution σ of Π terminates if it eventually reaches a state ( F , x), and thus, continues to cycle in the same state. Let π :</p><formula xml:id="formula_3">0 τ1 -→ 1 τ2 -→ • • • F</formula><p>be a syntactic path through the PTS. It can be shown that (a) for each finite syntactic path there is a well-defined probability μ(π) ∈ [0, 1] that characterizes the probability that a sample path traverses the sequence of locations in π, and furthermore (b) the overall probability of termination can be obtained as the sum of the probabilities of all finite syntactic paths π j that lead from 0 to F .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. A PTS is said to terminate almost surely iff the sum of probabilities of the terminating syntactic paths is 1.</head><p>A measure theoretic definition of almost sure termination is provided in our extended technical report.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pre-expectation:</head><p>We now define the useful concept of pre-expectation of an expression e over program variables across a transition τ , extending the definition for discrete probabilities from McIver &amp; Morgan <ref type="bibr" target="#b20">[20]</ref>. Let s : ( , x) be a state and τ be the enabled transition on s. We define the pre-expectation (e |s) as the expected value of the expression e over the POST-DISTRIB(s), as an expression involving the current state variables of the program. Formally, let τ : ( , ϕ, f 1 , . . . , f k ) have k ≥ 1 forks each of the form f j : (p j , F j , m j ). We define τ (e |s) = k j=1 p j R (PRE(e , F j )), where PRE(e , F j ) represents the expression e [x → F j (x, r)] obtained by substituting the post-state variables x by F j (x, r), and R (g) represents the expectation of the expression g over the distribution D. We clarify this further using an example.</p><p>Example 3. Going back to Example 2, we wish to compute the pre-expectation of the expression</p><formula xml:id="formula_4">5 • t -2 • h across the transition τ 1 : ( 3 , (h ≤ t), f 1 , f 2 ) with forks f 1 : ( 1 2 , F 1 : λ (h, t). (h, t + 1), 3 ) and f 2 : ( 1 2 , F 2 : λ(h, t). (h + r 1 , t + 1), 3 ) (see Fig. 2). The precondition across F 1 yields PRE(5 • t -2 • h , F 1 ) = 5 • t -2 • h + 5. The precondition across F 2 yields PRE(5 • t -2 • h , F 2 ) = 5 • t -2 • h + 5 -2r 1 . The overall pre-expectation is given by τ (5 • t -2 • h |( 3 , h, t)) = 1 2 ( r1 (5 • t -2 • h + 5)) + ( * ← f 1 * ) 1 2 ( r1 (5 • t -2 • h + 5 -2r 1 )) ( * ← f 2 * )</formula><p>.</p><p>Simplifying, we obtain (5</p><formula xml:id="formula_5">• t -2 • h |( 3 , h, t)) = 5 • t -2 • h + 5 -r1 (r 1 ) = 5 • t -2 • h + 5 -5 = 5 • t -2 • h.</formula><p>In other words, the expected value of the expression 5 • t -2 • h in the post-state across transition τ is equal to its value in the current state. Such an expression is called a martingale <ref type="bibr" target="#b32">[32]</ref>.</p><p>The rest of this paper will expand on the significance of martingale expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Martingales and Supermartingale Expressions</head><p>A discrete-time stochastic process {M n } is a countable sequence of random variables M 0 , M 1 , M 2 , . . . where M n is distributed based on the samples drawn from M 0 , . . . , M n-1 . By convention, M n denotes the random variable and m n its sample.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Martingales and Super Martingales). A process</head><formula xml:id="formula_6">{M n } is a martingale iff for each n &gt; 0, (M n |m n-1 , . . . , m 0 ) = m n-1 .</formula><p>In other words, at each step the expected value at the next step is equal to the current value. Likewise {M n } is a supermartingale iff for each n &gt; 0, (</p><formula xml:id="formula_7">M n |m n-1 , . . . , m 0 ) ≤ m n-1 .</formula><p>If {M n } is a martingale then it is also a super-martingale. Furthermore, the process {-M n } obtained by negating M n is also a super-martingale. The study of martingales is fundamental in probability theory <ref type="bibr" target="#b32">[32]</ref> with numerous applications to the analysis of randomized algorithms <ref type="bibr" target="#b11">[12]</ref>.</p><p>Martingale Expressions: Let Π be a PTS with locations L, variables X and random variables R. We assume, for convenience, that all variables in X and random values are real-valued. We define martingale expressions for a given PTS Π. Next, we explore properties of martingales and super martingales, linking them to those of the PTS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Martingale Expressions). An expression e[X] over program variables</head><p>X is a martingale for the PTS Π iff for every transition τ : ( , ϕ, f 1 , . . . , f k ) in Π and for every state s : ( , x) for which τ is enabled, the pre-expectation of e equals its current state value:</p><formula xml:id="formula_8">∀ x. ϕ[x] ⇒ τ (e | , x) = e. Likewise, an expression is a super-martingale iff for each transition τ , ∀ x. ϕ[x] ⇒ τ (e | , x) ≤ e.</formula><p>In other words, the stochastic process {e n } obtained by evaluating the expression e on a sample execution of Π must be a (super) martingale. Note that in the terminology of McIver &amp; Morgan, martingale expressions correspond to exact invariants <ref type="bibr" target="#b21">[21]</ref>.</p><p>Example 4. We noted that for the expression e : 5• t -2 • h, and for any τ 1 enabled state ( 3 , h, t), we have that (5</p><formula xml:id="formula_9">• t -2 • h |h, t) = 5• t -2 • h.</formula><p>The remaining transitions in the PTS (Cf.Fig. <ref type="figure">2</ref>) also preserve the expression e. Therefore, e is a martingale. Likewise, we can show that the expression f : -h is a super-martingale. Often, it is not possible to obtain a single expression that is a martingale for the program as a whole. However, it is natural to obtain a more complex function of the state that maps to different program expressions at different locations.</p><p>Example 5. Consider a simple program and its corresponding PTS, as shown below. The program increments a variable x as long as a coin flip turns heads.</p><p>1 int x := 0; 2 while (flip (0.5))</p><formula xml:id="formula_10">3 x ++; 4 // end 0 1 τ 1 true 1 2 x := x + 1 1 2 , x := x τ 2 : id</formula><p>We can show that no linear expression over x can be a martingale. Any such expression must be of the form e : cx (we do not need a constant term in our analysis) for some coefficient c. We note that the pre-expectation w.r.</p><formula xml:id="formula_11">t τ 1 is τ1 (cx |x) = 1 2 (c(x + 1)) + 1 2 (cx) = cx + c 2 .</formula><p>This yields the constraint c = 0 if the expression is to be a martingale. However, consider a flow-sensitive map of the state ( , x) given by</p><formula xml:id="formula_12">f ( , x) = x if = 0 x -1 if = 1</formula><p>. We can conclude that f ( , x) is a martingale, since its pre-expectation for any transition equals its current value.</p><p>Often, labeling different locations in the program with different martingale expressions is quite advantageous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (Flow-Sensitive Expression Maps).</head><p>A flow-sensitive expression map η maps each location ∈ L to a (polynomial) expression η( ) over X.</p><p>An expression map η is a function that maps a state s : ( , x) to a real-value by computing η( )[x]. Let η be an expression map and τ : ( , ϕ, f 1 , . . . , f k ) be a transition with forks f 1 , . . . , f k , where f j : (p j , F j , m j ). The pre-expectation of η w.r.t. τ is given by</p><formula xml:id="formula_13">τ (η | , x) = k j=1 p j R (PRE(η(m j ), F j )). Example 6.</formula><p>For the program and map η in Ex. 5, we compute the pre-expectation of η w.r.t</p><formula xml:id="formula_14">τ 1 : ( 0 , true, f 1 , f 2 ) where f 1 : ( 1 2 , λx.x + 1, 0 ) and f 2 : ( 1 2 , id, 1 ). τ1 (η | 0 , x) = 1 2 ( x + 1 PRE(η( 0),λx.x+1) ) + 1 2 ( x -1 PRE(η( 1),λx.x) ) = x(= η( 0 )) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7 (Martingales and Super Martingale Expression Maps</head><p>). An expression map η is a martingale for a PTS Π iff for every transition τ : ( , ϕ, f 1 , . . . , f k ), we have</p><formula xml:id="formula_15">∀ x. ϕ[x] ⇒ τ (η | , x) = η( )[x].</formula><p>Likewise, the map is a super-martingale iff for every transition τ , ∀ x. ϕ[x] ⇒ Example 7. The map η in Example 6 is a martingale under the condition for transition τ 2 . The only other transition is trivial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">From Martingales to Probabilistic Assertions</head><p>We now present some of the key properties of martingales that can be used to make a link from (super) martingale expression maps to probabilistic assertions.</p><p>Theorem 1 (Azuma-Hoeffding Theorem). Let {M n } be a super martingale such that |m nm n-1 | &lt; c over all sample paths for constant c. Then for all n ∈ N and</p><formula xml:id="formula_16">t ∈ R such that t ≥ 0, it follows that Pr(M n -M 0 ≥ t) ≤ exp -t 2 2nc 2 . Moreover, if {M n } is a martingale the symmetric bound holds as well: Pr(M n -M 0 ≤ -t) ≤ exp -t 2 2nc 2 .</formula><p>Combining both bounds, we conclude that for a martingale</p><formula xml:id="formula_17">{M n } we obtain Pr(|M n -M 0 | ≥ t) ≤ 2 exp -t 2 2nc 2 .</formula><p>Azuma-Hoeffding bound is a concentration of measure inequality. For a martingale, it bounds the probability of a large deviation on either side of its starting value. For a super-martingale, the inequality bounds the probability of a large deviation above the starting value. Both bounds are useful in proving probabilistic assertions. We note the condition of bounded change on the martingale. This has to be established on the side for each transition in the program, and the bound c calculated (using optimization techniques) before the inequality can be applied.</p><p>Example 8. The Azuma-Hoeffding bound applies to the program in Ex. 1 (Section 1). We now observe that the expression 2x -i is a martingale of the loop. Its change at any step is bounded by ±1. Further, the initial value of the expression is 0. Therefore, choosing t = 50, we conclude that after N = 500 steps, Pr(|(2x -i) 500 -(2xi) 0 | ≥ 50) ≤ 2 exp -2500 2×500×1 ≤ 0.16. We note that (2x -i) 0 = 0 and i 500 = 500. Simplifying, with probability at least 0.84, we conclude that x ∈ [200, 300] after 500 steps.</p><p>Since the bounds depend on the number of steps n taken from the start, they are easiest to apply when n is fixed or bounded in an interval. Another common idea is to infer bounds |M n -M 0 | ≥ a √ n for constant a &gt; 0 and n ≥ 0.</p><p>Example 9. Continuing with Ex. 8, for n &gt; 0, we conclude the bounds</p><formula xml:id="formula_18">Pr(|(2x - i) n -(2x -i) 0 | ≥ a √ n) ≤ 2 exp(-a 2 n 2n ) ≤ 2 exp(-a 2 2</formula><p>). For a = 3, the upper bound is 0.0223.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Almost Sure Termination</head><p>In this section, we provide a technique for proving that a PTS Π with a final location F is almost surely terminating (see definition of almost sure termination in Section 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (Ranking Super Martingale). A super martingale (s.m.) {M n } is ranking iff it has the following properties:</head><p>1. There exists &gt; 0 such that for all sample paths, (M n+1 |m n ) ≤ m n -. 2. For all n ≥ 0, M n ≥ -K for some constant K &gt; 0.</p><p>Let {M n } be a ranking s.m. with positive initial condition m 0 &gt; 0. A sample path eventually becomes negative if m n ≤ 0 for some n ≥ 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. A ranking super martingale with a positive initial condition almost surely becomes negative.</head><p>Proof. The stopping time for a sample path is defined as t = inf n≥0 m n ≤ 0. We use T as a random variable for the stopping time. The stopped process is denoted M min(n,T ) <ref type="bibr">(</ref> </p><formula xml:id="formula_19">, m n ) = (M n+1 |y n , m n ) + min(n + 1, t) . We split two cases (a) n + 1 ≤ t or (b) n + 1 &gt; t.</formula><p>Case (a):</p><formula xml:id="formula_20">(Y n+1 |y n , m n ) = (M n+1 |m n ) + (n + 1) ≤ m n -+ (n + 1) ≤ y n . Case (b): y n = m t + t . We have (Y n+1 |m n , y n ) = m t + t = y n .</formula><p>In either case, we conclude (Y n+1 |m n , y n ) ≤ y n .</p><p>We note the well-known s.m. convergence theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 (Super Martingale Convergence Theorem). A lower-bounded super martingale converges (samplewise) almost surely.</head><p>Therefore, with probability 1, a sample path y 0 , . . . , y n , . . . converges to a value ỹ.</p><p>Lemma 2. For any convergent sample path y 0 , . . . , y n , . . ., the corresponding {M n } sample path m 0 , . . . , m n , . . . eventually becomes negative.</p><p>Proof. Convergence of y n to ỹ implies for any α &gt; 0, there exists N such that ∀n ≥ N, |y n -ỹ| ≤ α. For contradiction, assume the {M n } sample path has stopping time</p><formula xml:id="formula_21">t = ∞. Therefore, m n = y n -n for all n ≥ 0. Choosing α = , for any n &gt; N, m n ≤ ỹ + α -n ≤ ỹ -(n -1)</formula><p>. Therefore, for n &gt; 1 + ỹ , we conclude that m n ≤ 0. This contradicts our assumption that t = ∞.</p><p>To complete the proof, we observe that (a) a sample path y 0 , . . . , y n , . . . converges almost surely since {Y n } is a lower bounded s.m.; (b) for each convergent sample path the corresponding (unique) path m 0 , . . . , m n , . . . becomes negative; and therefore (c) any {M n } sample path becomes negative almost surely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 9 (Super Martingale Ranking Function). A super martingale ranking function (SMRF) η is a s.m. expression map that satisfies the following:</head><p>η( ) ≥ 0 for all = F , and η( F ) ∈ [-K, 0) for some lower bound K.</p><p>-There exists a constant &gt; 0 s.t. for each transition τ (other than the self-loop id around F ) with guard ϕ,</p><formula xml:id="formula_22">(∀ x) ϕ[x] ⇒ τ (η | , x) ≤ η( )[x] -.</formula><p>The SMRF definition above is a generalization of similar rules over discrete spaces, including the probabilistic variant rule <ref type="bibr" target="#b20">[20]</ref> and Foster's theorem <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b3">4]</ref>. Unlike standard ranking functions, we do not obtain completeness. Consider a purely symmetric random walk:</p><formula xml:id="formula_23">Theorem</formula><p>1 int x := 10; while (x &gt;= 0) { if (flip(0.5)) x++; else x --; }</p><p>We can show using recurrence properties of symmetric random walks, that the program above terminates almost surely. Yet, no SMRF can be found since the martingale x does not show adequate decrease. However, if the flip probability is changed to 0.5δ, then the variable x is a SMRF for the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discovering (Super) Martingales</head><p>Next, we turn our attention to the discovery of (super) martingale expression maps and super martingale ranking functions (SMRF). Our approach builds upon previous work by Colón et al. for constraint-based invariant and ranking function discovery for standard non-deterministic transition systems <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. We restrict our approach to affine PTS wherein each transition τ : ( , ϕ, f 1 , . . . , f k ), the guard ϕ is polyhedral (conjunctions of linear inequalities) and the update function</p><formula xml:id="formula_24">F i for each f i is affine, F i (X, R) : A i x + B i r + a i .</formula><p>A template expression is a bilinear form d + n i=1 c i x i with unknowns c 1 , . . . , c n , d. We may also consider a template expression map η that maps each location j to a template expression η( j ) : d j + n i=1 c ji x i . We collectively represent the unknown coefficients as a vector c. We encode the conditions for a template expression (map) corresponding to our objective: (super) martingales or super martingale ranking functions. Solving the resulting constraints directly yields (super) martingales.</p><p>Example 11. Consider the PTS in example 2 (see Fig. <ref type="figure">2</ref>). We wish to discover a s.m. using the template c 1 h + c 2 t at locations 3 , 9 .</p><p>Encoding Super Martingales: We discuss how the conditions on the pre-expectations of s.m. can be encoded using Farkas Lemma. Let τ : ( , ϕ, f 1 , . . . , f k ) be a transition with k forks. Let η be a template expression map. We wish to enforce that η is a s.m.</p><formula xml:id="formula_25">(∀ x) (ϕ[x]) ⇒ τ (η | , x) ≤ η( )[x]. Recall that τ (η | , x) = k j=1 p j R (PRE(η(m j ), F j )). Each PRE(η(m j ), F j ) can be expressed as PRE(η(m j ), F j ) = c T Ax + c T Br + c T a.</formula><p>Example 12. Returning back to Ex. 11, we wish to encode pre-expectation condition for the transition τ : ( 3 , (h ≤ t), f 1 , f 2 ), where f 1 : ( <ref type="formula" target="#formula_30">1</ref>2 , (λ(h, t). h, t + 1), 3 ) and f 2 : ( <ref type="formula" target="#formula_30">1</ref>2 , (λ(h, t). h + r 1 , t + 1), 3 ). We encode the pre-expectation condition for τ :</p><formula xml:id="formula_26">(∀h, t) (h ≤ t) ⇒ 1 2 r1 (c 1 h + c 2 (t + 1))+ 1 2 r1 (c 1 (h + r 1 ) + c 2 (t + 1)) ≤ c 1 h + c 2 t .</formula><p>We note that r1 (r 1 ) = 5 (See Figure <ref type="figure" target="#fig_0">1</ref>). By linearity of expectation, we obtain</p><formula xml:id="formula_27">(∀h, t) (h ≤ t) ⇒ c 1 h + c 2 t + c 2 + 1 2 c 1 r1 (r 1 ) ≤ c 1 h + c 2 t .</formula><p>Simplifying, we obtain (∀h, t)</p><formula xml:id="formula_28">(h ≤ t) ⇒ c 2 + 5 2 c 1 ≤ 0.</formula><p>Here, the RHS is independent of the variables h, t. Therefore, we obtain c 2 + 5 2 c 1 ≤ 0. Let μ represent the vector of mean values where μ j = R (r j ). Therefore,</p><formula xml:id="formula_29">R (PRE(η(m j ), F j )) = c T Ax + c T Bμ + a T c .</formula><p>To encode the s.m. property for τ , we use Farkas Lemma to encode the implication</p><formula xml:id="formula_30">(∀ x) (ϕ[x]) ⇒ τ (η | , x) template expression ≤ η( )[x] template expression<label>(1)</label></formula><p>Let ϕ be satisfiable and represented in the constraint form as Ax ≤ b.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5 (Farkas Lemma). The linear constraint</head><formula xml:id="formula_31">Ax ≤ b ⇒ c T x ≤ d is valid iff its alternative is satisfiable A T λ = c ∧ b T λ ≥ d ∧ λ ≥ 0.</formula><p>Encoding the entailment in Eq. ( <ref type="formula" target="#formula_30">1</ref>) using Farkas' Lemma ensures that the resulting constraints are linear inequalities.</p><p>Example 13. Continuing with Ex. 12, the transition id yields the constraint true. Therefore, the only constraint is c 2 + 5 2 c 1 ≤ 0. Solving, we obtain the line (c 1 : 1, c 2 : -5 2 ), yielding the martingale h - 5  2 t, while the ray (c 1 : -1, c 2 : 0) yields the s.m. -h. Other s.m. such as th are obtained as linear combinations.</p><p>Finding Super Martingale Ranking Functions: The process of discovering SMRFs is quite similar, but requires extra constraints. An abstract interpretation pass can be used to yield helpful invariants by treating the random variables and forks as nondeterministic choices. Let I( ) be a polyhedral invariant inferred at the location .</p><p>1 real x,y, estX, estY := 0,0,0,0 2 real dx, dy, dxc, dyc := 0,0,0,0 3 int i, N := 0,500 4 for i = 0 to N { 5   For location F , we encode I( F ) |= -K ≤ η( F ) &lt; 0. The latter condition requires the Motzkin's transposition theorem, a generalization of Farkas' lemma that deals with strict inequalities <ref type="bibr" target="#b17">[17]</ref>. Here K is treated as an unknown constant, whose value is also inferred as part of the process. 2. The adequate decrease condition is almost identical to that for s.m. However, we introduce an unknown &gt; 0 and require that τ (η | , x) ≤ η( ) -.</p><p>Example 14. Revisiting Ex. 12, we perform an abstract interpretation to obtain the facts </p><formula xml:id="formula_32">I( 3 ) : 0 ≤ h ≤ t + 9 ∧ h ≤ 9t -270 ∧ t ≥</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We have implemented the ideas presented thus far using a constraint generation framework that reads in the description of a PTS and generates constraints for supermartingale expression maps. Our tool uses the Parma Polyhedra Library <ref type="bibr" target="#b0">[1]</ref> to generate all possible solutions to these constraints in terms of martingale and super-martingale expressions. Currently, our implementation does not directly communicate with an abstract interpreter for deriving useful invariants. In some of the examples presented in this section, such invariants are computed using a numerical domain polyhedral abstract interpreter and added manually to the PTS description.</p><p>Robot Dead Reckoning: Dead reckoning is an approach for position estimation starting from a known fix at some time t = 0. Figure <ref type="figure">3</ref> (left) shows a model for robot navigation that involves estimating the actual position (x,y) of the robot as it is commanded to make various moves. Each step involves a choice of direction chosen from the set of compass directions {N, W, E, S, N E, N W, SW, SE} each with probability 0.1 or a "Stay" command with probability 0.2. The variables dxc,dyc capture the commanded direction, whereas the actual directions are slightly off by a random value. Our goal is to estimate how the position x,y deviates from the actual position estX,estY.</p><p>Our analysis shows that the expressions x -estX and y -estY are martingales at the loop head. The absolute change in these martingales are bounded by 0.05. Given the initial difference of 0 between the values, we infer using Azuma-Hoeffding theorem that Pr(|x -estX| ≥ 3) ≤ 1.5 × 10 -3 . In contrast, a worst-case analysis concludes that |x -estX| ≤ 0.05 * 500 ≤ 25. The analysis for y -estY yields identical results.</p><p>Roulette: For our next example, we analyze a betting strategy for a game of Roulette. The game involves betting money on a color (red or black) and a column (1,2 or 3). At each step, the player chooses an amount to bet randomly between 5 and 10 dollars. We skip a detailed description of the betting strategy and simply model the effect of the strategy as a probabilistic program, as shown in Figure <ref type="figure">3</ref> (right). The model captures the various outcome combinations ({Bank} {Red, Black} × {1, 2, 3}), including the one where the bank wins outright with probability 1 37 . Our analysis discovers the martingale expression 15 × i -74 × money which can be used to bound the probability of the money exceeding a certain quantity after n rounds. We generate the SMRF: -money. Thus, the program terminates almost surely in the gambler's ruin.</p><p>Table <ref type="table" target="#tab_4">1</ref> shows an evaluation of our approach over a set of linear PTS benchmarks. A description of the benchmarks and the inferred properties are provided in our extended technical report available on-line<ref type="foot" target="#foot_3">2</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Probabilistic programs can be quite hard to reason about. A large volume of related work has addressed techniques for formally specifying and verifying properties of probabilistic systems. Statistical approaches rely on simulations <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b19">19]</ref>, providing high confidence guarantees. On the other hand, symbolic techniques including BDD-based approaches <ref type="bibr" target="#b1">[2]</ref>, probabilistic CEGAR <ref type="bibr" target="#b16">[16]</ref>, deductive approaches <ref type="bibr" target="#b21">[21]</ref> and abstract interpretation techniques <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b2">3]</ref> attempt to establish guaranteed probability bounds on temporal properties of programs.</p><p>Martingale theory has been employed to establish guarantees for randomized algorithms <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b11">12]</ref>. In particular, the method of bounded differences is a popular approach that establishes a martingale and uses Azuma's inequality to place bounds on its values. The contribution of this paper lies in a partial mechanization of the process of discovering martingales and the termination analysis of programs using super-martingale ranking functions.</p><p>Our work is closely related to the quantitative invariants proposed by McIver and Morgan, and summarized in their monograph <ref type="bibr" target="#b20">[20]</ref>. Informally, quantitative invariants involve program expressions whose pre-expectations are at least their current value. These are used to establish pre-/post-annotations for programs, and in some cases they lead to an almost sure termination proof principle. In the framework of this paper, a quantitative invariant roughly corresponds to the negation of a super-martingale (also known as a sub-martingale). There are many differences between McIver &amp; Morgan's approach and that of this paper. Chiefly, our approach considers real-/integer-valued random variables with a large variety of probability distributions, whereas the probabilistic distributions studied by McIver &amp; Morgan are restricted to discrete distributions over a finite set of choices. The use of concentration of measure inequalities and the presentation of almost sure termination proofs using martingale theory are unique to this work. On the other hand, our work does not consider (demonic) non-determinism. Furthermore, we do not integrate martingales and super-martingales into a deductive proof system for proving properties of expectations. Part of the reason for this lies in the difficulty of establishing that expectations of program variables are well-defined for a given program. Many simple examples fail to yield well-defined expectations. We plan to study these issues further and achieve a more complete deductive verification framework as part of our future work.</p><p>The constraint-based analysis of (non-probabilistic) programs has been studied for invariance and termination proofs by many authors, including Colón et al. <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref>, Bradley et al. <ref type="bibr" target="#b4">[5]</ref>, Cousot <ref type="bibr" target="#b8">[9]</ref>, Podelski et al. <ref type="bibr" target="#b28">[28]</ref> and Gulwani et al. <ref type="bibr" target="#b15">[15]</ref>. Extensions to polynomial invariants were considered by Sankaranarayanan et al. <ref type="bibr" target="#b31">[31]</ref>, Carbonell et al. <ref type="bibr" target="#b30">[30]</ref>, Müller-Olm et al. <ref type="bibr" target="#b25">[25]</ref> and Platzer et al. <ref type="bibr" target="#b26">[26]</ref>. Recent work of Katoen et al. uses a constraint-based invariant synthesis method to derive quantitative invariants, generalizing earlier approaches <ref type="bibr" target="#b17">[17]</ref>. Our work in this paper was inspired, in part, by this generalization. Katoen et al. derive quantitative invariants that involve a combination of characteristic functions over linear assertions and program expressions. As a result, their approach yields nonlinear (bilinear) constraints of the same form as those obtained by earlier work by Colón et al. <ref type="bibr" target="#b6">[7]</ref>. Our approach focuses on linear (super) martingales and therefore, we obtain linear inequality constraints.</p><p>The almost sure termination of probabilistic programs was studied for finite state and "weakly" infinite programs by Esparza et al. using patterns <ref type="bibr" target="#b12">[13]</ref>. Their approach attempts to find the existence of a sequence of discrete probabilistic choices that will lead to termination from any reachable state. As such, finite length patterns do not exist for general infinite state systems studied here. Other approaches to almost sure termination including that of Morgan <ref type="bibr" target="#b20">[20]</ref> and Bournez et al. <ref type="bibr" target="#b3">[4]</ref> use the probabilistic variant rule, or equivalently Foster's theorem, a well-known result in (discrete) Markov chain theory <ref type="bibr" target="#b14">[14]</ref>. In fact, these principles turn out to be specializations of the SMRF principle presented in this paper.</p><p>(Super) martingale theory is widely used in stochastic calculus to reason about continuous time systems. Recently, Platzer considers an extension of differential logic to stochastic hybrid systems <ref type="bibr" target="#b27">[27]</ref>. Martingale theory is used as a basis for proving properties in this setting. However, Platzer's work does not deal directly with martingale expressions over state variables or the generation of such expressions. The techniques presented in this paper are dependent on discrete time martingale theory. We plan to extend our use of martingale theory to reason about stochastic hybrid systems. Another future direction will consider the use of (super) martingales to infer relational abstractions of probabilistic systems <ref type="bibr" target="#b29">[29]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. (Top, Left) Program that sums up random variables. (Top,Right) sample paths of the program with value of i in x-axis and y-axis showing x. Loop invariants assuming (demonic) non-deterministic semantics for unifRand are shown on the right. (Bottom,Left) A simple probabilistic program with a loop, (Bottom,Right) Sample executions of the program with x axis representing t and y axis representing h. The plot on the bottom also contrasts the worst-case invariants inferred on h, t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1</head><label>1</label><figDesc>Figure 1 plots the sample paths for two probabilistic transition systems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>9 15 elseFig. 3 .</head><label>153</label><figDesc>Fig. 3. (Left) Probabilistic program model for dead reckoning and (Right) Modeling a betting strategy for Roulette</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc><ref type="bibr" target="#b30">30</ref> and I( 9 ) : h &gt; t ∧ h ≤ t + 9. We use the template η( 3 ) : c 3,1 h + c 3,2 t + d 3 and η( 9 ) : c 9,1 h + c 9,2 t + d 9 . We obtain the result c 3,1 = c 9,1 = -1, c 3,2 = c 9,2 = 1 and d 3 = 10, d 9 = 0, with =3  2 and K = -9. This yields the SMRF η( 3 ) : th + 9, η( 9 ) : th.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>or M T n ) has sample paths m 0 , . . . , m t , m t , m t , . . .. Note that M min(n,T ) ≥ -K over all sample paths. Next, we define a process Y n = M min(n,T ) + min(n, T ). In other words, for each sample path y n = m n + n if n ≤ t, and y n = m t + t if n &gt; t. Note that given a sample path prefix m 0 , . . . , m n of M T n we can compute y n . Therefore, Y n is adapted to M min(n,T ) . Likewise, given y 0 , . . . , y n we can compute m min(n,t) . Therefore, sample paths of Y n are one-to-one correspondent with those of M T n . Lemma 1. {Y n } is a super martingale (relative to M T</figDesc><table /><note><p><p>n ) and Y n ≥ -K .</p>Proof. Y n ≥ -K for all n follows from the fact that M T n ≥ -K for all n. Next, we show that Y n is a s.m. For any sample path, (Y n+1 |y n</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>4. If a PTS Π has a super martingale ranking function η then every sample execution of Π terminates almost surely. For any sample execution of Π, we define the process {M n } where m n = η(s n ). It follows that {M n } is a ranking super martingale. The rest follows from Theorem 2 Example 10. For the PTS in Example 1, a.s. termination is established by the SMRF η( 0 ) : N -i, and η( 1 ) : -1. Consider the PTS in Example 2 and Figure 2, the SMRF η( 3 ) : th + 9 and η( 9 ) : th proves a.s. termination. The PTS in Ex. 5 has a SMRF η(</figDesc><table /><note><p><p><p>2 ) : 1 and η(</p>4</p>) : -1.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 .</head><label>1</label><figDesc>Results on a set of benchmark programs. #M: # of non-trivial martingales discovered and # S.M. # of non-trivial super martingales. All timings are under 0.1 seconds on Macbook air laptop with 8 GB RAM, running MAC OSX 10.8.3.</figDesc><table><row><cell>ID</cell><cell>Description</cell><cell>|X| |R| |L| |T | #M #S.M.</cell></row><row><cell>ROULETTE</cell><cell>betting strategy for roulette</cell><cell>3 1 1 1 1 1</cell></row><row><cell>TRACK</cell><cell>Target tracking with feedback</cell><cell>3 5 3 9 1 3</cell></row><row><cell>2DWALK</cell><cell>Random walk on R 2</cell><cell>4 1 1 4 3 1</cell></row><row><cell>COUPON5</cell><cell>coupon collectors with n = 5 coupons</cell><cell>2 0 5 4 4 8</cell></row><row><cell cols="2">FAIRBIASCOIN simulating a fair coin by biased coin</cell><cell>3 0 2 3 0 2</cell></row><row><cell>QUEUE</cell><cell>queue with random arrivals/service</cell><cell>3 0 1 2 1 2</cell></row><row><cell>CART</cell><cell>steering a cart on a rough surface</cell><cell>5 4 6 12 2 4</cell></row><row><cell>INVPEND</cell><cell cols="2">discrete inverted pendulum under stochastic disturbance 5 6 3 3 0 0</cell></row><row><cell>PACK</cell><cell>packing variable weight objects in cartons</cell><cell>6 2 3 5 3 4</cell></row><row><cell>CONVOY2</cell><cell>leader following over a convoy of cars</cell><cell>6 1 2 4 1 0</cell></row><row><cell>DRECKON</cell><cell>dead reckoning model</cell><cell>10 4 3 3 4 1</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>N. Sharygina and H. Veith (Eds.): CAV 2013, LNCS 8044, pp. 511-526, 2013. c Springer-Verlag Berlin Heidelberg 2013</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>http://systems.cs.colorado.edu/research/cyberphysical/ probabilistic-program-analysis</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>τ (η | , x) ≤ η( )[x].</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_3"><p>http://systems.cs.colorado.edu/research/cyberphysical/ probabilistic-program-analysis</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. Thanks to Prof. Manuel Lladser for useful pointers to martingale theory and the anonymous reviewers for detailed comments. This work was supported by the US National Science Foundation (NSF) under award numbers CNS-0953941 and CNS-1016994.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Parma Polyhedra Library: Toward a complete set of numerical abstractions for the analysis and verification of hardware and software systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bagnara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Zaffanella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="3" to="21" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Symbolic model checking for probabilistic processes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hartonas-Garmhausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 1997</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Marchetti-Spaccamela</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1256</biblScope>
			<biblScope unit="page" from="430" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A generalization of p-boxes to affine arithmetic</title>
		<author>
			<persName><forename type="first">O</forename><surname>Bouissou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Goubault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Goubault-Larrecq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Putot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Proving positive almost-sure termination</title>
		<author>
			<persName><forename type="first">O</forename><surname>Bournez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Garnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RTA 2005</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Giesl</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3467</biblScope>
			<biblScope unit="page" from="323" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Termination of polynomial programs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Bradley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Sipma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI 2005</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3385</biblScope>
			<biblScope unit="page" from="113" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Statistical model checking of mixed-analog circuits with an application to a third order Δ -Σ modulator</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Donzé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Legay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HVC 2008</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Chockler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Hu</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5394</biblScope>
			<biblScope unit="page" from="149" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Linear invariant generation using nonlinear constraint solving</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Colón</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Sipma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2003</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Hunt</surname><genName>Jr</genName></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2725</biblScope>
			<biblScope unit="page" from="420" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Synthesis of linear ranking functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Colón</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sipma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2001</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Margaria</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Yi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2031</biblScope>
			<biblScope unit="page" from="67" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Proving program invariance and termination by parametric abstraction, lagrangian relaxation and semidefinite programming</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI 2005</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3385</biblScope>
			<biblScope unit="page" from="1" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Automatic discovery of linear restraints among the variables of a program</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 19878</title>
		<imprint>
			<date type="published" when="1978-01">January 1978</date>
			<biblScope unit="page" from="84" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Probabilistic abstract interpretation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monerau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP 2012</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7211</biblScope>
			<biblScope unit="page" from="169" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Concentration of Measure for the Analysis of Randomized Algorithms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dubhashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Panconesi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Proving termination of probabilistic programs using patterns</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kiefer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2012</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7358</biblScope>
			<biblScope unit="page" from="123" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the stochastic matrices associated with certain queuing processes</title>
		<author>
			<persName><forename type="first">F</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals Mathematical Statistics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="355" to="360" />
			<date type="published" when="1953">1953</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Program analysis as constraint solving</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<biblScope unit="page" from="281" to="292" />
			<date type="published" when="2008">2008</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Probabilistic CEGAR</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wachter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2008</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5123</biblScope>
			<biblScope unit="page" from="162" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Linear-invariant generation for probabilistic programs</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Katoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mciver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Meinicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Morgan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS 2010</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Martel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6337</biblScope>
			<biblScope unit="page" from="390" to="406" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">PRISM: probabilistic model checking for performance and reliability analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMETRICS Perf. Eval. Review</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="40" to="45" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Probabilistic verification and approximation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lassaigne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Peyronnet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">152</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="122" to="131" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Abstraction, Refinement and Proof for Probabilistic Systems. Monographs in Computer Science</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mciver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Morgan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Developing and reasoning about probabilistic programs in pGCL</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mciver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Morgan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PSSE 2004</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Cavalcanti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sampaio</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Woodcock</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3167</biblScope>
			<biblScope unit="page" from="123" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A new numerical abstract domain based on difference-bound matrices</title>
		<author>
			<persName><forename type="first">A</forename><surname>Miné</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PADO 2001</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Danvy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Filinski</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2053</biblScope>
			<biblScope unit="page" from="155" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Abstract interpretation of programs as markov decision processes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Monniaux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="179" to="205" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<title level="m">Randomized Algorithms</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Precise interprocedural analysis through linear algebra</title>
		<author>
			<persName><forename type="first">M</forename><surname>Müller-Olm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="330" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Differential dynamic logic for hybrid systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reasoning</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="143" to="189" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Stochastic differential dynamic logic for stochastic hybrid programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CADE 2011</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Sofronie-Stokkermans</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6803</biblScope>
			<biblScope unit="page" from="446" to="460" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A complete method for the synthesis of linear ranking functions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI 2004</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2937</biblScope>
			<biblScope unit="page" from="239" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Transition invariants</title>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="32" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Automatic generation of polynomial loop invariants: Algebraic foundations</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rodriguez-Carbonell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kapur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISSAC</title>
		<meeting>ISSAC<address><addrLine>Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Non-linear loop invariant generation using Gröbner bases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sipma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<biblScope unit="page" from="318" to="330" />
			<date type="published" when="2004">2004</date>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Probability with Martingales (Cambridge Mathematical Textbooks)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-02">February 1991</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Statistical probabilitistic model checking with a focus on time-bounded properties</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L S</forename><surname>Younes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Simmons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information &amp; Computation</title>
		<imprint>
			<biblScope unit="volume">204</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1368" to="1409" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
