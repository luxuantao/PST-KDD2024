<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Chinese Remaindering with Errors</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering-Systems</orgName>
								<orgName type="institution">Tel-Aviv University</orgName>
								<address>
									<addrLine>Ramat-Aviv</addrLine>
									<postCode>69978</postCode>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Dana</forename><surname>Ron</surname></persName>
							<email>danar@eng.tau.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering-Systems</orgName>
								<orgName type="institution">Tel-Aviv University</orgName>
								<address>
									<addrLine>Ramat-Aviv</addrLine>
									<postCode>69978</postCode>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering-Systems</orgName>
								<orgName type="institution">Tel-Aviv University</orgName>
								<address>
									<addrLine>Ramat-Aviv</addrLine>
									<postCode>69978</postCode>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Chinese Remaindering with Errors</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6A37ED0438BD431304BCF5D4F2269E04</idno>
					<note type="submission">received July 7, 1999; revised February 10, 2000.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The Chinese Remainder Theorem states that a positive integer is uniquely specified by its remainder modulo relatively prime integers 1 , provided =1 . Thus the residues of modulo relatively prime integers 1 2 form a redundant representation of if =1 and . This gives a number-theoretic construction of an "error-correcting code" that has been considered often in the past (see [41]; also [35, pp. 325-336]), [19], [35]). In this code a "message" (integer) =1 is encoded by the list of its residues modulo 1 . By the Chinese Remainder Theorem, if a codeword is corrupted in ( ) 2 coordinates, then there exists a unique integer whose corresponding codesword differs from the corrupted word in at most places. Furthermore, Mandelbaum [25], [26] shows how can be recovered efficiently given the corrupted word provided that the 's are very close to one another. To deal with arbitrary 's, we present a variant of his algorithm that runs in almost linear time and recovers from Manuscript</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>= ( (log log 1 ))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For (and</head><p>(1) 1</p><p>), the fraction of error corrected by the algorithm is almost twice that corrected by the previous work. More significantly, the algorithm recovers the message even when the amount of agreement between the "received word" and the "codeword" is much smaller than the number of errors.</p><p>Index Terms-Lattice reduction, list decoding, redundant residue number system (RRNS) codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>T HE Chinese Remainder Theorem states that a positive in- teger is uniquely specified by its remainder modulo relatively prime integers , provided .</p><p>Thus if we pick relatively prime integers such that , then the remainders of modulo the 's form a redundant representation of . Specifically, can be recovered given any of the remainders.</p><p>This redundancy property of the Chinese remainder representation has been exploited often in theoretical computer science. The Karp-Rabin pattern-matching algorithm is based on this redundancy <ref type="bibr" target="#b15">[16]</ref>. This representation was used to show the strength of probabilistic communication over deterministic communication protocols (cf. <ref type="bibr" target="#b19">[20,</ref><ref type="bibr">Exercise 3.6]</ref>). The representation allows for easy arithmetic-addition, subtraction, and multiplication-on large integers and was even proposed by <ref type="bibr">Watson and Hastings [41]</ref> (also <ref type="bibr">[35, pp. 325-336]</ref>) as a potential representation for numbers in computers. <ref type="foot" target="#foot_0">1</ref> The ability to reduce computation over large integers to that over small integers is also employed in complexity-theoretic settings, with a notable example being its use in showing the hardness of computing the permanent of matrices <ref type="bibr" target="#b38">[39]</ref>. In the context of error correction, this representation of integers yields a natural error-correcting code that has been studied extensively in the literature (see <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b18">[19]</ref>, and the references therein). The central property that allows for the correction of error is that for any two integers , the sequences and (which we view as encodings of and , respectively), differ in at least coordinates. This difference (or distance) has the following implication. Consider a sequence of integers that are obtained by taking residues of an integer modulo , where of the residues are erroneous. In other words, differs from the codeword representing in coordinates. Then the Chinese Remainder Theorem indicates that for there exists a unique codesword that differs from in at most coordinates. Thus for such bounded error, is uniquely specified by the vector . The first algorithmic question that arises is whether, under the above conditions, it is possible to recover in polynomial time (i.e., in time polynomial in and</p><p>). This question was answered affirmatively by Mandelbaum <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>. Mandelbaum gives an efficient algorithm for the above Unique De-coding problem when provided that the 's are very close. Specifically, his algorithm runs in time 2   Note that the ratio may be exponential in even if (e.g., if for all 's and then the ratio is approximately</p><p>). We present and analyze a variant of Mandelbaum's algorithm. This variant can be implemented in almost-linear time, and solves the unique decoding problem when Note that for we have and for we have</p><p>The main focus of our work is the study of the decoding problem for larger error. In this case, there is no unique codeword that differs in at most coordinates from the received word . However, as long as , there exists a small list containing all integers whose Chinese remainder representations differ from the vector in at most coordinates <ref type="bibr" target="#b11">[12]</ref>. In this paper, we present an efficient algorithm for recovering this list in polynomial time. More precisely, the algorithm solves the following task:</p><p>List Decoding (for large error): Given relatively prime integers ; residues , with ; and an integer ; construct a list of all integers satisfying and for at least values of . (Theorem 11). (We comment that this list contains at most integers; cf., <ref type="bibr" target="#b11">[12]</ref>.)</p><p>Coding theory context.: The better known examples of asymptotically good error-correcting codes with efficient algorithms can be classified in one of two categories: 1) Algebraic codes: These are codes defined using the properties of low-degree polynomials over finite fields and include a wide variety of codes such as Reed-Solomon codes, Bose-Chaudhuri-Hocquenhgem (BCH) codes, Alternant codes, and algebraic-geometry codes. Such codes admit efficient error-correction algorithms; in fact, 2 Mandelbaum's paper does not provide an explicit analysis of the runningtime. The poly (1) factor is actually almost linear.</p><p>all the algorithms (for unique decoding) are similar in spirit and can be unified quite nicely <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b7">[8]</ref>.</p><p>2) Combinatorial codes: A second class of codes with efficient decoding algorithms evolved from combinatorial concepts such as expanders, super-concentrators, etc. Examples of this family include the codes of Sipser and Spielman <ref type="bibr" target="#b33">[34]</ref>, and Spielman <ref type="bibr" target="#b35">[36]</ref>. In both cases, the description of the code is captured by a graph; and the existence of a decoding algorithm is then related to combinatorial properties of the graph.</p><p>By extending the work of Mandelbaum <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref> (see also <ref type="bibr" target="#b2">[3]</ref>), our work contributes to broadening the study of efficiently decodable error-correcting codes, to include a number-theoretic code. To the best of our knowledge-this is the only example which does not fall into one of the two classes above.</p><p>For unique decoding, our algorithms are obtained by abstracting from known paradigms for correcting algebraic codes: The unique-decoding algorithm abstracts from a large collection of (unique) error-correcting algorithms for algebraic codes <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b4">[5]</ref>. In fact, an elegant unification of these results (see <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b7">[8]</ref>, or the technical report version of this paper <ref type="bibr" target="#b10">[11]</ref>) provides the inspiration for our algorithm. The list-decoding algorithm abstracts from the recent works on list-decoding algorithms for algebraic codes <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b12">[13]</ref>. We stress, however, that the translation of the above mentioned algorithms to our case is not immediate. In particular, the usual "interpolation" methods, that come in very handy in the algebraic case are not applicable here. In fact, the Chinese Remainder Code is not even linear in the usual sense and so linear algebra is not applicable in our case. Thus for solving analogies of "simple" problems in the algebraic case, we employ the continued-fraction method for the Unique Decoding task, and the approximate basis reduction algorithm <ref type="bibr" target="#b20">[21]</ref> for the List Decoding task. Our final algorithms achieve decoding capabilities comparable to those in algebraic cases. In particular, the list-decoding algorithm recovers from errors, provided and . Applications: As mentioned earlier, the Chinese Remainder Code is used naturally in many places. We suspect the decoding algorithm could be of use in some of these applications. At this point we are aware of some scenarios in which the decoding algorithm(s) for the Chinese Remainder Code are of use. In Section V, we describe the applicability of the Chinese Remainder Code and the decoding algorithm in "secret sharing" as an alternate to Shamir's scheme <ref type="bibr" target="#b31">[32]</ref>. (The latter used the properties of the Reed-Solomon code). In the technical report version of this paper <ref type="bibr" target="#b10">[11]</ref>, an application to the "average-case complexity of computing the permanent of random matrices" is also given. One more case where the list-decoding algorithm for the CRT code has been utilized is in a result of Håstad and Näslund <ref type="bibr" target="#b13">[14]</ref> who utilize the list-decoding algorithm for the CRT code (as part of a more involved algorithm) to show that all the individual bits of are "secure" given and for any "one-way function" .</p><p>Organization of this paper: In Section II we define the Chinese Remainder Code. In Section III we describe the unique decoding algorithm for the Chinese Remainder Code (in case of small error), and in Section IV we give the list-decoding algorithm (in case of large error). In Section V we describe the application of the Chinese Remainder Code to secret sharing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. THE CHINESE REMAINDER CODE</head><p>Notation: For positive integers , , Let denote the set , and let denote the remainder of when divided by . Note that .</p><p>Definition 1 (Chinese Remainder Code): Let be relatively prime integers, and an integer. The Chinese Remainder Code with basis and rate is defined for message space , where . The encoding of a message , denoted , is the -tuple .</p><p>Thus the Chinese Remainder Code does not have a "fixed alphabet" (the alphabet depends on the coordinate position) and it is not linear in the usual sense (as the natural arithmetic here is done modulo for the th coordinate). The distance of a code can, however, be defined as usual; i.e., the distance between two "words" of block length is the number of coordinates on which they differ; and the distance of a code is the minimum distance between any pair of distinct codewords. The distance properties of this code are very similar to those of Reed-Solomon and BCH codes; and follow immediately from the Chinese Remainder Theorem. Thus if are all -bit primes, then the information rate and the distance of the Chinese Remainder Code are comparable with those of the Reed-Solomon code or the BCH code. For our purposes, it is more useful to consider a variant of the notions of block length, rate, and distance as defined below.</p><p>Definition 4 (Amplitude): For a Chinese Remainder Code with basis and rate , the amplitude of the encoding is defined to be ; the amplitude of the message space is defined to be . For vectors and with , the amplitude of the distance between and is defined to be . The amplitude of agreement between and is defined to be . Notice that the product of the amplitudes of agreement and distance equals the amplitude of the encoding.</p><p>It is easy to see that if the distance between and is , and the amplitude of the distance between and is ; then . In case of traditional codes that are defined over fixed alphabets, i.e., , is directly proportional to and hence there is no need to consider the latter separately. In our case, the latter parameter provides a more refined look at the performance of the algorithms. From the Chinese Remainder Theorem it follows immediately that the amplitude of distance between any two codewords is larger than . Our goal is to solve the following error-correction problems (for as large an error parameter as possible).</p><p>The Error-Correction/List Decoding Problem: Given: 1) relatively prime integers and rate parameter specifying a Chinese Remainder Code; 2) integers , with and an error-parameter . Task: Find (all) message(s)</p><p>, where , s.t.</p><p>for at most values of .</p><p>It follows from the distance of the Chinese Remainder Code that the answer is unique if . In this case, the problem corresponds to the traditional error-correction problem for error-correcting codes. If is larger, then there may be more than one solution. We will expect the algorithm to return a list of all codewords with at most errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. THE DECODING ALGORITHM FOR SMALL ERROR</head><p>The first algorithm we present is a simple algorithm to recover from a small number of errors. The algorithm is very similar to Mandelbaum's algorithm <ref type="bibr" target="#b25">[26]</ref>, but is presented and analyzed slightly differently. In particular, we simplify the description of the algorithm by invoking a powerful algorithm for integer programming in small dimensions, due to Lenstra <ref type="bibr" target="#b21">[22]</ref>. The algorithm recovers from error of amplitude at most . Translating to classical measures this yields an error-correcting algorithm for (and in particular, if , then the algorithm can handle a constant fraction of errors).</p><p>The algorithm is described below formally. The inspiration for the algorithm comes from a general paradigm for decoding of many algebraic codes (see <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b7">[8]</ref>, or the technical report version of this paper <ref type="bibr" target="#b10">[11]</ref>). Given a received word that is close to the encoding of (a unique) message , the algorithm Unique-Decode tries to find two integers and such that</p><p>. To this end it first reconstructs the integer that corresponds to the received word (i.e., , for every ). It then searches for integers and such that (where ), and both and are of bounded sizes. In the analysis of the algorithm we show that the equality (modulo ) between and together with the restrictions on the sizes of and implies that is equal to (over the integers). Furthermore (as we show in the technical report version of this paper <ref type="bibr" target="#b10">[11]</ref>), has the following error-detection property: For every index such that , it holds that , and, moreover, the message can be reconstructed from the remaining 's. Though we do not use this property explicitly in the algorithm described below (as well as in its analysis), it can be used to obtain a variant of the algorithm (described in <ref type="bibr" target="#b10">[11]</ref>), which is more clearly related to the general decoding paradigm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Unique-Decode</head><p>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Set</head><p>, and let be an integer to be determined later. Let be s.t.</p><p>(as defined by CRT). 1. Find integers s.t.</p><p>(1)</p><p>2. Output if it is an integer.</p><p>The above algorithm can be implemented in polynomial time in the bit sizes of .</p><p>Step 2 is straightforward. The main realization is that Step 1 can be computed using an algorithm for integer programming in fixed number of variables, due to Lenstra <ref type="bibr" target="#b21">[22]</ref>. To see how to formulate our problem in this way, we let the final equality be expressed as . Our task thus reduces to computing and and In the technical report version of this paper <ref type="bibr" target="#b10">[11]</ref> we also show how the method of continued fractions leads to a nearly linear time algorithm for this task.</p><p>We now analyze the performance of this algorithm. We first describe it in terms of the amplitude of the distance between the message and the received word .</p><p>Lemma 5: If is such that for some the amplitude of the distance between and is at most , and then Unique-Decode returns .</p><p>We prove the lemma using the following two claims. ), and . Then notice that , and , and so the first item of (1) holds. Since , we have . Using (so that ), and since , the second item of (1) also holds. Finally, by CRT, the condition holds since the condition holds modulo every : For any fixed , either or . In either case, we have Proof of Claim 5.2: For every s.t.</p><p>, we have Thus by CRT, where is the amplitude of the agreement between and . But and . Thus .</p><p>As an immediate consequence of Lemma 5, and the observation relating amplitudes of distance to classical distance, we get the following theorem. . The theorem follows by taking logarithms of both sides.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DECODING FOR LARGE ERROR</head><p>In this section we will describe an algorithm that recovers from possibly many more errors than described in the previous section. In particular, if we fix and let , the fraction of errors that can be corrected goes to . As , this quantity approaches . This algorithm is inspired by the recent progress in list-decoding algorithms <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b12">[13]</ref>. Our algorithm and analysis follow the same paradigm, though each step is different.</p><p>The algorithm List-Decode can be viewed as a generalization of Unique-Decode. In both algorithms, given the received word , the algorithm first finds, using CRT, an integer corresponding to the received word (i.e., for every ). In Unique-Decode, the algorithm then attempts to find integers and (restricted in size), such that , and outputs . In other words, the algorithm searches for integers satisfying , and outputs the (unique)</p><p>Lemma 9: If is such that for some the amplitude of the agreement between and is greater than , and are integers satisfying (2), then (i.e., is a root of the polynomial ). Proof: We first observe that since the 's are small, is small in absolute value Now we observe that for such that it holds that Define By CRT Since the sum has absolute value at most , the hypothesis implies that the sum is identically zero as required.</p><p>As an immediate consequence of the last two lemmas, we get a of the correctness of List-Decode. The following proposition describes the performance in terms of amplitude (for any choice of ).</p><p>Proposition 10: For any choice of the parameter , List-Decode produces a list of up to integers which includes all messages such that the amplitude of agreement between and is at least . Proof: By Lemma 7, 's satisfying (2) exist and are found in Step 1. By Lemma 9, any as in the lemma is a root of the polynomial , and thus is included in the output.</p><p>The following theorem is obtained by optimizing the choice of the parameter in the above proposition. </p><p>We start with an analysis of the last inequality. For this we need Let . Then and , provided . Thus it suffices to show <ref type="bibr" target="#b5">(6)</ref> Fact: Equation ( <ref type="formula">6</ref>) holds if and . Proof: By the hypothesis, , and so and (6) follows.</p><p>Setting , shows that suffices to achieve <ref type="bibr" target="#b4">(5)</ref>. This setting of also implies that to satisfy (4), which is equivalent to , it suffices to set . Finally, to satisfy (3), which is equivalent to , it suffices to set which is smaller than . Thus we find that it suffices to have Setting yields the theorem. Comparison with <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b36">[37]</ref>: Our algorithm List-Decode is similar to those of <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b36">[37]</ref> in the basic steps. In their case also, they first find a polynomial "explaining" the corrupted word and then factor it to retrieve a list of messages. However, the specifics are quite different: They look for a bivariate polynomial explanation; their criterion is to find a nonzero polynomial of low degree; they find it by solving a linear system; and then employ a bivariate factorization step. We look for a univariate polynomial explanation; our criterion is the size of the coefficients; we find it by (essentially) solving Diophantine systems; and finally employ univariate factorization. Similarly, our analysis follows the same steps. The existence proof (Lemma 8) is similar to an analogous step in <ref type="bibr" target="#b36">[37]</ref>; though our proof here appears to be more general than his proof. In particular, the pigeonhole argument could also be applied to his case achieving analogous results. Finally, Lemma 9 is also analogous in spirit to similar lemmas in <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b36">[37]</ref>-again our proofs are different since our criteria are different.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. SECRET SHARING BASED ON CRT</head><p>The CRT code has been proposed as an alternate method for implementing secret-sharing <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b1">[2]</ref>. The scheme is based on the CRT-code, analogously to the way Shamir's secret-sharing scheme <ref type="bibr" target="#b31">[32]</ref> is based on Reed-Solomon codes. The existence of decoding algorithms for the CRT code enhances the power of such a secret-sharing scheme. In this section, we formally analyze the secrecy preserved by such a scheme. First we recall the notion of a secret-sharing scheme.</p><p>Loosely speaking, a secret-sharing scheme is a method for an (honest) dealer to distribute its secret among parties, giving each party a share of the secret, so that the following two conflicting goals are achieved 1) any large enough collection of parties can efficiently recover the secret; but 2) no small coalition of parties can obtain any information about the secret.</p><p>The collection of parties in item 1) is thought of as a collection of available honest parties, whereas the coalition in item 2) refers to a coalition of dishonest parties. Typically, a secret-sharing scheme is defined in terms of two thresholds, and (s.t., ), corresponding to the above two items. Below we relax item 2), introduce a parameter bounding the information leakage, and require that the information leaked about the secret to any subset of up to parties is bounded by this parameter. <ref type="foot" target="#foot_1">3</ref>We mention that secret sharing is one of the most widely used tools in Cryptography.</p><p>Recall that in Shamir's scheme, for parameters and , one is given a secret GF and shares it among parties by uniformly selecting a degree polynomial, , over GF with free term , and handing to the th party. Clearly, any parties can recover the secret (by interpolation), whereas no set of parties obtains any information about the secret. In abstract terms, Shamir's scheme consists of selecting a random codeword among those of a certain "label, "and giving each party a block of bits in the codeword. We can do the same in case of the CRT code, and our secret sharing scheme follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Construction 12</head><p>The CRT secret-sharing scheme): parameters:</p><p>and primes .</p><p>sharing: To share a secret GF one does the following 1. uniformly selects GF GF ; 2. finds so that , for ; 3. sets the th share to be , for .</p><p>reconstructing: Given any shares, , corresponding to parties , one reconstructs the secret as follows:</p><p>1. finds so that , for . 2. recover the secret to be . We first show that the reconstruction indeed works. Consider and as computed in Step 2 of the Sharing procedure and Step 1 of the Reconstruction procedure, respectively. Clearly, , for . Viewing and as nonnegative integers, we have and . Thus for every and follows. On the other hand, the first shares yield no information about the secret. As for other sets of up to shares, here some information about the secret is leaked, but we can upper-bound its amount. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>main contribution is an efficient decoding algorithm for the case in which the error may be larger than 2 . Specifically, given residues 1 and an agreement parameter , we find a list of all integers =1 such that ( mod ) = for at least values of 1, provided</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 2 (</head><label>2</label><figDesc>Chinese Remainder Theorem-CRT): If are relatively prime positive integers and are integers such that , then there exists a unique integer such that . Furthermore, where , , and is the multiplicative inverse modulo of . Corollary 3: For any relatively prime integers and any integer , the Chinese Remainder Code with basis and rate has distance . That is, for any two messages , the codewords and disagree on at least coordinates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Claim 5 . 1 :</head><label>51</label><figDesc>Under the premises of Lemma 5 there exist , satisfying (1). Claim 5.2: Under the premises of Lemma 5, for any pair satisfying (1) it holds that . We prove the two claim momentarily, and first show how Lemma 5 follows from the claims. Proof of Lemma 5: By Claim 5.1, Step 1 of the algorithm always returns a pair satisfying (1). By Claim 5.2, any pair that may be the outcome of Step 1 satisfies . Thus is an integer and the output of the algorithm is . We now prove Claims 5.1 and 5.2. Proof of Claim 5.1: Let (so that equals the amplitude of the distance between and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 6 :</head><label>6</label><figDesc>Unique-Decode solves the error-correction problem in polynomial time for any value of the error parameter with the setting . Proof: Using and , Lemma 5 can be applied if (as ). Namely, it suffices that which is equivalent to In turn, this condition holds if</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Proposition 13 :</head><label>13</label><figDesc>Let GF, let be chosen as in Step 1 of the Sharing procedure, and let</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Unfortunately, it does not allow for easy divisions or inequality comparisons-which is presumably why it was not employed.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The actual formulation will be slightly different: We will bound the statistical difference between t shares generated for any two possible secrets.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors would like to thank Venkatesan Guruswami for bringing the work <ref type="bibr" target="#b7">[8]</ref> to their attention. They would like to thank Valentine Kabanets for pointing out an error in the earlier version of this paper. They would like to thank Michael Quisquater for the pointer to <ref type="bibr" target="#b1">[2]</ref>, and Amin Shokrollahi for the pointers to <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, and <ref type="bibr" target="#b2">[3]</ref>. They would like to thank an anonymous reviewer for numerous pointers including <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b34">[35]</ref>, and <ref type="bibr" target="#b40">[41]</ref>.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The work of O. Goldreich was done in part while visiting MIT, and was supported in part by DARPA under Grant DABT63-96-C-0018. The work of D. Ron was done in part while visiting MIT, supported by an ONR Science Scholar Fellowship of the Bunting Institute. The work of M. Sudan was supported in part by a Sloan Foundation Fellowship, an MIT-NEC Research Initiation Grant, and NSF CA-REER Award CCR-9875511.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>root of the (degree-) polynomial . In List-Decode, the algorithm instead searches for a sequence of integers (of certain bounded sizes), such that and outputs all roots of the polynomial . As we show subsequently, the increase in the degree of the polynomial that the algorithm searches for (together with the particular restrictions on the sizes of its coefficients) allows us to decode for much larger error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>List-Decode</head><p>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Set</head><p>; and</p><p>with to be determined Let s.t. for every (as defined by CRT).</p><p>1. Find integers satisfying</p><p>2. Output all roots of the integer polynomial . The running time of Step 2 above is easily bounded by a polynomial in and . For example, one can use the algorithm for factoring polynomials over due to Lenstra, Lovasz (LLL) <ref type="bibr" target="#b20">[21]</ref>. Faster algorithms are also known for the simpler task of "root-finding." (In particular, one may use classical results on the bound of real roots to isolate an interval which includes all the real roots of the given polynomial. Then one may perform binary search to approximate the real roots, using the method of Sturm sequences to determine the number of real roots in any interval. For details on the bounds of roots and the method of Sturm sequences, c.f. Mishra <ref type="bibr" target="#b27">[28,</ref><ref type="bibr">Secs. 8.3 and 8.4]</ref> . Finally, since we are only interested in integer roots, an additive approximation of say suffices to determine them. Based on these ideas it is possible to obtain an algorithm with running time to list all integer roots of a degree polynomial with coefficients in the range . Faster implementations may be possible, but we are unaware of any published work.)</p><p>The more involved task is Step 1 and we will show how to implement it in polynomial time. Mainly, the idea is to set up a lattice whose short vectors correspond to small values of the coefficients 's. We show first that very small vectors of this form exist; and then use the basis reduction algorithm of LLL <ref type="bibr" target="#b20">[21]</ref> to find short (but not shortest) vectors in this lattice; and this will suffice for Step 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7 (Algorithm for Step 1.): 's as required in</head><p>Step 1 of List-Decode exist and can be found in polynomial time.</p><p>Proof: We set up an -dimensional integer lattice using basis vectors and described next. Let be a very large integer (to be determined later as a function of and ). For , the th coordinate of the vector , denoted , is given by if if otherwise.</p><p>The vector is zero everywhere except in the last coordinate where . A generic vector in this lattice is of the form for integers and . Explicitly the th coordinate of is given by if We are interested in showing that this lattice contains "short" vectors whose last coordinate equals , and every other coordinate has absolute value at most (thus satisfying ( <ref type="formula">2</ref>)). Furthermore, we would like to show that such vectors can be found efficiently. To his end, we first prove the following technical lemma. Using Lemma 8 with , we observe that the lattice defined above has a (short) nonzero vector (where the 's are as guaranteed by the lemma and ) with the last coordinate identically , and each other coordinate has absolute value at most Thus the -norm of this vector is at most By using the "approximate shortest vector" algorithm of <ref type="bibr" target="#b20">[21]</ref>, we find, in polynomial time, a vector of -norm at most For sufficiently large (any will do), all "short" vectors (i.e., with -norm at most ) have a last coordinate identical to , and thus yield a sequence of 's satisfying and . This sequence is as required in Step 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now we move on to</head><p>Step 2 of List-Decode. We argue next that any solution to the list-decoding problem is a root of the polynomial whose coefficients are given by any solution to Step 1. Instead of performing the analysis in terms of the amount of error in the received word, we do so in terms of the amount of agreement with some message.</p><p>(resp.,</p><p>) denote the value computed in Step 2. Then, for every set of indices, the statistical difference between and is at most Thus in general, security is provided only for (rather than for as in case of Shamir's scheme). An advised choice of parameters is to have 's be of the same magnitude and large enough so that is negligible in the security parameter.</p><p>Proof: Let us further generalize the claim and consider, for two integers , each relatively prime to , the randomized process which maps each to a uniformly selected member of . We are interested in the statistical difference between and , for the worst possible pair . (In our case, , and .) Clearly,</p><p>, where is uniformly chosen in (and same for ). So</p><p>The point is that is the only randomness in the right-hand side (r.h.s.), and that multiplying by is a permutation over (since is relatively prime to ). Thus if is uniformly distributed over then and are identically distributed. In general, the statistical difference between the latter is bounded by twice the statistical difference of (where is uniformly chosen in ) from the uniform distribution on . In case divides the statistical difference is zero, and otherwise it is which is bounded above by . The claim follows.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reconstructing algebraic functions from mixed data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="488" to="511" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A modular approach to key safeguarding</title>
		<author>
			<persName><forename type="first">C</forename><surname>Asmuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="208" to="210" />
			<date type="published" when="1983-03">Mar. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Error detection and correction by product codes in residue number systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Barsie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Maestrini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="640" to="643" />
			<date type="published" when="1978-09">Sept. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Algebraic Coding Theory</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Berlekamp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968">1968</date>
			<publisher>McGraw-Hill</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bounded distance +1 soft-decision reed-solomon decoding</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform.Theory</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="704" to="720" />
			<date type="published" when="1996-05">May 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Computational Complexity of Algebraic and Numeric Problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Munro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>American Elsevier</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Cryptography and Data Security</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E R</forename><surname>Denning</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Decoding codes from curves and cyclic codes</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Duursma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ph.D. dissertation, Eindhoven Inst. Technol</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<pubPlace>Eindhoven, The Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">List Decoding for Noisy Channels</title>
		<author>
			<persName><forename type="first">P</forename><surname>Elias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIT, Res. Lab. Electron., Tech. Rep</title>
		<imprint>
			<biblScope unit="volume">335</biblScope>
			<date type="published" when="1957">1957</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Error-correcting codes for list decoding</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="5" to="12" />
			<date type="published" when="1991-01">Jan. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Chinese Remaindering with Errors</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
		<idno>TR 98-082</idno>
		<ptr target="http://www.eccc.uni-trier.de/eccc/" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Learning polynomials with queries: The highly noisy case</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 36th Annu. Symp. Foundations of Computer Science</title>
		<meeting>36th Annu. Symp. Foundations of Computer Science<address><addrLine>Milwaukee, WI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">Oct. 23-25, 1998</date>
			<biblScope unit="page" from="294" to="303" />
		</imprint>
	</monogr>
	<note>Revised version available from ECCC</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Improved decoding for Reed-Solomon and algebraic-geometric codes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Guruswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="1757" to="1767" />
			<date type="published" when="1998-09">Sept. 1998</date>
		</imprint>
	</monogr>
	<note>Preliminary version in FOCS</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The security of all RSA and discrete log bits</title>
		<author>
			<persName><forename type="first">J</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Näslund</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-02">Feb. 1999</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><surname>Kaltofen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Polynomial factorization 1987-1991,&quot; in LATIN&apos;92</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Simon</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">583</biblScope>
			<biblScope unit="page" from="294" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Efficient Randomized Pattern-Matching Algorithms</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<idno>TR-31-81</idno>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Aiken Computation Lab., Harvard Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The analysis of algorithms</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Actes du Congres International des Mathematiciens</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="269" to="274" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A unified description of an error locating procedure for linear codes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kotter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Algebraic and Combinatorial Coding Theory Conf., Voneshta Voda</title>
		<meeting>Algebraic and Combinatorial Coding Theory Conf., Voneshta Voda<address><addrLine>Bulgaria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Krishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Sun</surname></persName>
		</author>
		<title level="m">Computational Number Theory and Digital Signal Processing: Fast Algorithms and Error Control Techniques</title>
		<meeting><address><addrLine>Boca Raton, FL</addrLine></address></meeting>
		<imprint>
			<publisher>CRC</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
			<affiliation>
				<orgName type="collaboration">Communication Complexity</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nisan</surname></persName>
			<affiliation>
				<orgName type="collaboration">Communication Complexity</orgName>
			</affiliation>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Cambridge Univ. Press</publisher>
			<pubPlace>Cambridge, U.K.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Factoring polynomials with rational coefficients</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lovasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematische Annalen</title>
		<imprint>
			<biblScope unit="volume">261</biblScope>
			<biblScope unit="page" from="515" to="534" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Integer programming with a fixed number of variables</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Operations Res</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="538" to="548" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">An Algorithmic Theory of Numbers, Graphs and Convexity</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lovász</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>SIAM</publisher>
			<pubPlace>Philadephia, PA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The Theory of Error-Correcting Codes</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Macwilliams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>North-Holland</publisher>
			<pubPlace>Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On a class of arithmetic codes and a decoding algorithm</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Mandelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="85" to="88" />
			<date type="published" when="1976-01">Jan. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Further results on decoding arithmetic residue codes</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="643" to="644" />
			<date type="published" when="1978-09">Sept. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Shift register synthesis and BCH decoding</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Massey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform, Theory</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="122" to="127" />
			<date type="published" when="1969-01">Jan. 1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Algorithmic Algebra</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mishra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">On Decoding Linear Codes by Error Correcting Pairs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pellikaan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven Univ. Technol</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">preprint</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Encoding and error-correction procedures for Bose-Chaudhuri codes</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="459" to="470" />
			<date type="published" when="1960-09">Sept. 1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Schnelle multiplikation grosser zahlen</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schonhage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Strassen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="281" to="292" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">How to share a secret</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="612" to="613" />
			<date type="published" when="1979-11">Nov. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Decoding algebraic-geometric codes beyond the error-correction bound</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Shokrollahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wasserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th Annu. ACM Symp. Theory of Computing</title>
		<meeting>30th Annu. ACM Symp. Theory of Computing<address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">May 23-26, 1998</date>
			<biblScope unit="page" from="241" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Expander codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Spielman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="1710" to="1722" />
			<date type="published" when="1996-11">Nov. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Residue Number System Arithmetic: Modern Applications in Digital Signal Processing</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Soderstrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Jenkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Jullien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Taylor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>IEEE Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Linear-time encodable and decodable error-correcting codes</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Spielman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="1723" to="1732" />
			<date type="published" when="1996-11">Nov. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Decoding of Reed-Solomon codes beyond the error-correction bound</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Complexity</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="180" to="193" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Van Lint</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>Introduction to Coding Theory</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The complexity of computing the permanent</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="189" to="201" />
			<date type="published" when="1979-04">Apr. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Algorithmic complexity in coding theory and the minimum distance problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vardy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th Annu. ACM Symp. Theory of Computing</title>
		<meeting>29th Annu. ACM Symp. Theory of Computing<address><addrLine>El Paso, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">May 4-6, 1997</date>
			<biblScope unit="page" from="92" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Self-checked computation using residue arithmetic</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Hastings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1966-12">Dec. 1966</date>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="1920" to="1931" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Error Correction of Algebraic Block Codes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Welch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Berlekamp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">U.S. Patent</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">470</biblScope>
			<date type="published" when="1986-12">Dec. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
