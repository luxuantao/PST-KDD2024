<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficiency Improvements in Constructing Pseudorandom Generators from One-way Functions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Iftach</forename><surname>Haitner</surname></persName>
							<email>iftach@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Omer</forename><surname>Reingold</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Salil</forename><surname>Vadhan</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Microsoft Research New England Campus</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Microsoft Research -Silicon Valley Campus &amp; Weizmann Institute of Science</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">School of Engineering &amp; Applied Sciences</orgName>
								<orgName type="institution">Harvard University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Efficiency Improvements in Constructing Pseudorandom Generators from One-way Functions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1AA7D219850E31E9C92506068A6621A2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>F.0 [Theory of Computation]: General One-way function</term>
					<term>Pseudorandom generator</term>
					<term>Pseudoentropy</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We give a new construction of pseudorandom generators from any one-way function. The construction achieves better parameters and is simpler than that given in the seminal work of Håstad, Impagliazzo, Levin, and Luby [SICOMP  '99]. The key to our construction is a new notion of nextblock pseudoentropy, which is inspired by the notion of "inaccessible entropy" recently introduced in [Haitner, Reingold, Vadhan, and Wee, STOC '09]. An additional advantage over previous constructions is that our pseudorandom generators are parallelizable and invoke the one-way function in a non-adaptive manner. Using [Applebaum, Ishai,  and Kushilevitz, SICOMP '06], this implies the existence of pseudorandom generators in NC 0 based on the existence of one-way functions in NC 1 .</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The result of Håstad, Impagliazzo, Levin, and Luby <ref type="bibr" target="#b12">[13]</ref> that one-way functions imply pseudorandom generators is one of the centerpieces of the foundations of cryptography and the theory of pseudorandomness.</p><p>From the perspective of cryptography, it shows that a very powerful and useful cryptographic primitive (namely, pseudorandom generators) can be constructed from the minimal assumption for complexity-based cryptography (namely, one-way functions). With this starting point, numerous other cryptographic primitives can also be constructed from one-way functions, such as private-key cryptography <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b19">20]</ref>, bit-commitment schemes <ref type="bibr" target="#b20">[21]</ref>, zero-knowledge proofs for NP <ref type="bibr" target="#b5">[6]</ref>, and identification schemes <ref type="bibr" target="#b2">[3]</ref>.</p><p>From the perspective of pseudorandomness, it provides strong evidence that pseudorandom bits can be generated very efficiently, with smaller computational resources than the "distinguishers" to whom the bits should look random. Such kinds of pseudorandom generators are needed, for example, for hardness results in learning <ref type="bibr" target="#b25">[26]</ref> and the natural proofs barrier for circuit lower bounds <ref type="bibr" target="#b21">[22]</ref>. Moreover, the paper of Håstad et al. introduced concepts and techniques that now permeate the theory of pseudorandomness, such as pseudoentropy and the Leftover Hash Lemma.</p><p>A drawback of the construction of Håstad et al., however, is that it is quite complicated. While it utilizes many elegant ideas and notions, the final construction combines these in a rather ad hoc and indirect fashion due to various technical issues. In addition to being less satisfactory from an aesthetic and pedagogical perspective, the complexity of the construction also has a significant impact on its efficiency. Indeed, it is too inefficient to be implemented even for very modest settings of parameters.</p><p>In the last few years, progress has been made on simplifying the construction of Håstad et al. <ref type="bibr" target="#b14">[15]</ref> and improving its efficiency <ref type="bibr" target="#b8">[9]</ref>. These constructions, however, still retain the overall structure of the Håstad et al. construction, and thus retain some of the complex and ad hoc elements.</p><p>In this paper, we present a significantly more direct and efficient construction of pseudorandom generators from oneway functions. The key to our construction is a new notion of next-block pseudoentropy, which is inspired by the recently introduced notion of "inaccessible entropy" <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The HILL Construction</head><p>Informally, a function f : {0, 1} n → {0, 1} n is a one-way function (OWF) if it is easy to compute (in polynomial time) and hard to invert even on random inputs. A polynomialtime computable function G : {0, 1} n → {0, 1} m(n) is a pseudorandom generator (PRG) if it is stretching (i.e., m(n) &gt; n) and its output distribution is pseudorandom (i.e., G(Un) is computationally indistinguishable from U m(n) ). The theorem of Håstad et al. relates these notions: Theorem 1.1. If there exists a one-way function, then there exists a pseudorandom generator.</p><p>The key notion underlying their construction is the following generalization of pseudorandomness. Definition 1.2 (pseudoentropy, informal). A random variable X has pseudoentropy k if there exists a random variable Y such that:</p><p>1. X is computationally indistinguishable from Y .</p><p>2. H(Y ) ≥ k, where H(•) denotes Shannon entropy. 1   A pseudoentropy generator (PEG) 2 is a polynomial-time computable function G : {0, 1} n → {0, 1} m(n) such that X = G(Un) has pseudoentropy H(G(Un)) + ∆(n) for some ∆(n) ≥ 1/ poly(n). We refer to ∆(n) as the entropy gap of G.</p><p>That every pseudorandom generator G : {0, 1} n → {0, 1} m(n) is a pseudoentropy generator can be seen by taking Y = U m(n) and noting that H(Y ) = m(n), but H(G(Un)) ≤ H(Un) = n. Pseudoentropy generators are weaker in that Y may be very far from uniform, and may even have H(Y ) &lt; n (as long as H(G(Un)) is even smaller).</p><p>The construction of pseudorandom generators from oneway functions proceeds roughly in the following steps:</p><p>OWF to PEG: Given a one-way function f : {0, 1} n → {0, 1} n , Håstad et al. define PEG(x, h, i) = (f (x), h, h(x)1...i), where h is an appropriate hash function and h(x)1...i denotes the first i bits of h(x).</p><p>PEG can be shown to be a pseudoentropy generator with an entropy gap of roughly ∆ = log n/n -Whenever i = log |f -1 (x)| + Θ(log n) (which happens with probability Θ(log n/n)) the first ≈ log |f -1 (x)| bits of h(x) extract all the entropy of x, and then we get Θ(log n) bits of pseudoentropy by the Goldreich-Levin Hardcore-Bit Theorem <ref type="bibr" target="#b3">[4]</ref>.</p><p>Converting Shannon Entropy to Min-Entropy and Amplifying the Gap: Next, Håstad et al. use a direct product construction PEG (x1, . . . , xt) = (PEG(x1), . . . , PEG(xt)) to convert pseudoentropy into pseudo-min-entropy, and increase the entropy gap to be ω(log n). This turns out to require taking roughly t = (n/∆) 2 copies.</p><p>Randomness Extraction: By hashing, Håstad et al. extract pseudorandom bits from the pseudo-min-entropy achieved so far. By also hashing the seed x to extract any remaining entropy, they obtain a pseudorandom generator. Specifically, they show that G(x, h1, h2) = (h1, h2, h1(PEG (x)), h2(x)) is a pseudorandom generator, if the output lengths of h1 and h2 are chosen appropriately. The choice of output lengths depends on the amount of min-entropy in the output of PEG , 1 The Shannon entropy of a random variable X is defined to be E</p><p>x R</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>←X</head><p>[log(1/ Pr[X = x])]. 2 Håstad et al. <ref type="bibr" target="#b12">[13]</ref> refer to such a generator as a false entropy generator, and require that a pseudoentropy generator to have output pseudoentropy n + ∆(n), rather than just H(G(Un)) + ∆(n). However, for the informal discussion here, we prefer not to introduce the additional term "false entropy". which in turn depends on the amount of entropy in the output of PEG. Unfortunately, these quantities may be infeasible to compute; this is handled by the next step. The total seed length in this informal description is roughly</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Enumeration</head><formula xml:id="formula_0">n • t • u = O(n 4 /∆ 3 ) = O(n 7</formula><p>). In fact, we have been cheating a bit in order to present the construction in a more modular way than in <ref type="bibr" target="#b12">[13]</ref>. (The issues we ignored have to do with the samplability of source Y in Definition 1.2.) The actual seed length in the main construction presented in <ref type="bibr" target="#b12">[13]</ref> is of O(n 10 ) (and the construction involves additional complications). A construction of seed length O(n 8 ) is outlined in <ref type="bibr" target="#b12">[13]</ref>, and has been formalized and proven in <ref type="bibr" target="#b14">[15]</ref>. Above we see three main sources of inefficiency in the construction: (1) the entropy gap ∆ being fairly small, (2) the conversion of Shannon entropy to min-entropy, and (3) enumerating guesses for the output entropy of the initial pseudoentropy generator. Haitner, Harnik, and Reingold <ref type="bibr" target="#b8">[9]</ref> show how to save a factor of n in the enumeration step (by constructing a pseudoentropy generator in which more is known about how the entropy is distributed) to obtain a seed length of O(n 7 ), but still all of the steps remain.</p><p>A further complication in the construction of Håstad et al. is that the reductions demonstrating the correctness of the construction are much more complex for uniform adversaries. This aspect of the proof has recently been simplified and made much more modular via Holenstein's uniform hardcore lemma <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>In case the one-way function is secure against exponential running time (2 Ω(n) ) adversaries, Holenstein <ref type="bibr" target="#b14">[15]</ref> showed how to reduce the seed length to O(n 4 • ω(log n)) (or O(n 5 ) to obtain a PRG with exponential security), which was then improved by Haitner et al. <ref type="bibr" target="#b9">[10]</ref> to O(n • ω(log n)) (or O(n 2 ) to obtain a PRG with exponential security). <ref type="foot" target="#foot_0">3</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Approach</head><p>Our construction is based on a generalization of the notion of a pseudoentropy generator. It is motivated by the well-known fact that the pseudorandomness of a random variable X is equivalent to each bit of X being indistinguishable from uniform given the previous ones <ref type="bibr" target="#b26">[27]</ref>. That is, X = (X1, . . . , Xn) is computationally indistinguishable from Un = (Y1, . . . , Yn) if and only if for every i, (X1, X2, . . . , Xi-1, Xi) is computationally indistinguishable from (X1, X2, . . . , Xi-1, Yi). It is thus natural to consider what happens if we require not that Xi be pseudorandom given the previous bits, but only that Xi has pseudoentropy given the previous bits. More generally, we can allow the Xi's to be blocks instead of bits.</p><p>Definition 1.3 (NBP, informal). A random variable X = (X1, . . . , Xm) has next-block pseudoentropy k if there exists a set of random variables Y = {Y1, . . . , Ym}, each jointly distributed with X, such that:</p><p>1. For every i, (X1, X2, . . . , Xi-1, Xi) is computationally indistinguishable from (X1, X2, . . . , Xi-1, Yi).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>i H(Yi|X1, . . . Xi-1) ≥ k. A next-block pseudoentropy generator (NBPEG) is a polynomial-time computable function G : {0, 1} n → ({0, 1} ) m such that (X1, . . . , Xm) = G(Un) has next-block pseudoentropy H(G(Un)) + ∆(n), where again ∆(n) is called the entropy gap.</p><p>That is, in total, the bits of X "look like" they have k bits of entropy given the previous ones. Note that the case of 1 block (m = 1) amounts to the definition of a pseudoentropy generator. Also note that, when m &gt; 1, allowing Y to be correlated with X in this definition is essential: for example if all the blocks of X are always equal to each other (and have noticeable entropy), then there is no way to define Y that is independent of X and satisfies the first condition.</p><p>With this notion, our construction proceeds as follows.</p><p>OWF to NBPEG: Given a one-way function f , we define G(x, h) = (f (x), h, h(x)1, h(x)2, . . . , h(x)n), where h : {0, 1} n → {0, 1} n is an appropriate hash function, and h(x)i is the i'th bit of h(x). Notice that this is the same as the construction of Håstad et al., except that we do not randomly truncate the output. At first, this seems problematic; by revealing all of h(x), it becomes easy for an adversary to compute x, and thus the pseudoentropy of output equals its real entropy (i.e., we have zero entropy gap). We show, however, that it does indeed have next-block pseudoentropy n + log n, which is even larger than the seed length of G. We have gained in two ways here. First, the entropy gap is now ∆ = log n instead of ∆ = log n/n. Second, we know the total amount of entropy in the output (though not the amount contributed by the individual blocks). These two advantages improve the the complexity and security of the rest of the construction. Furthermore, the fact that the next-block pseudoentropy is larger than the seed length simplifies the construction, as we do not need to extract any additional entropy from the seed.</p><p>Entropy Equalization: Here we use a technique from <ref type="bibr" target="#b11">[12]</ref> to convert our knowledge about the total entropy (summed over all blocks) into knowledge about the entropy in the individual blocks. We evaluate G on u = O(n/∆) independent seeds and concatenate the outputs, but randomly shifted by i R ← [n] coordinates. This increases our seed length and our entropy by a multiplicatives factor of approximately u, but now almost all the blocks have pseudoentropy at least the average pseudoentropy of the blocks of G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Converting Shannon Entropy to Min-Entropy and</head><p>Amplifying the Gap: This works the same as in <ref type="bibr" target="#b12">[13]</ref>.</p><p>Again we take roughly t = O(n/∆) 2 copies, but concatenate them within each block to obtain an m-block generator G . Now each of the m blocks is indistinguishable from having high min-entropy conditioned on the previous ones. Thus what we have is computational analogue of a block source <ref type="bibr" target="#b1">[2]</ref>, which are random sources in which each block has high min-entropy conditioned on the previous ones.</p><p>Randomness Extraction: For this step, we use a known method for block-source extraction <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">28]</ref> and define G(x, h) = (h, h(G (x)1), . . . , h(G (x)m)), where h is a universal hash function. Since we know how much pseudo-min-entropy is in each block, there is no difficulty in choosing the output length of h.</p><p>In total, our seed length is roughly</p><formula xml:id="formula_1">O(n • u • t) = O(n 4</formula><p>). For the case of exponentially hard one-way functions, we can obtain ∆ = Ω(n), and thus achieve seed O(n • ω(log n)) matching <ref type="bibr" target="#b9">[10]</ref> (but, unlike <ref type="bibr" target="#b9">[10]</ref>, our construction uses nonadaptive calls to the one-way function).</p><p>Note that our construction involves no "guessing" of entropies, neither in the construction of the initial NBPEG G, nor in an enumeration step at the end. While the entropy equalization "costs" the same (namely u = O(n/∆)) as enumeration did, it is actually doing more for us. Enumeration handled our lack of knowledge of a single entropy value (for which there were only O(n/∆) choices), but here equalization is handling lack of knowledge for approximately n entropy values (one for each block), for which there are exponentially many choices. Moreover, enumeration required composing the pseudorandom generators to increase their stretch, resulting in a construction that is highly sequential and makes adaptive use of the one-way function. Our pseudorandom generators make nonadaptive use of the one-way function and are parallelizable (e.g., in NC 1 ), for getting pseudorandom generators with small stretch. Using Applebaum et al. <ref type="bibr" target="#b0">[1]</ref>, this implies the existence of pseudorandom generators in NC 0 based on the existence of one-way functions in NC 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Relation to Inaccessible Entropy</head><p>The notion of next-block pseudoentropy generators was inspired by the notion of inaccessible entropy generators in <ref type="bibr" target="#b11">[12]</ref>. These are generators G that also produce m blocks (x1, . . . , xm) with the property that it is infeasible for an adversary to generate a sequence of blocks (x1, . . . , xm) that are consistent with the output of G in such a way that entropy of the individual blocks xi is high (conditioned on the state of the adversary after generating the previous blocks). Thus, in a computational sense, the output of G has low entropy. For this reason, the notions of next-block pseudoentropy generators and inaccessible entropy generators seem to be dual to each other.</p><p>The initial construction of an inaccessible entropy generator in <ref type="bibr" target="#b11">[12]</ref> is G(x) = (f (x)1, . . . , f (x)n, x), which is very similar to our construction of a next-block pseudoentropy generator except that there is no hashing and the bits of f (x) instead of h(x) are treated as separate blocks. This initial step is followed by entropy equalization and gap amplification steps that are exactly the same as the one we use (but analyzed with respect to dual notions). The final hashing step there (to construct statistically hiding commitment schemes) is more complex than ours and is necessarily interactive.</p><p>Interestingly, the notion of inaccessible entropy generator was introduced in an attempt to make the construction of statistically hiding commitment schemes from one-way func-tions "as simple" as the construction of pseudorandom generators from one-way functions, via manipulating notions of computational entropy. (The previous construction, from <ref type="bibr" target="#b10">[11]</ref>, was extremely complex.) In return, that effort has now inspired our simplifications and improvements to the construction of pseudorandom generators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Paper Organization</head><p>Notations and definitions used through this paper are given in Section 2, where the new notion of a next-block pseudoentropy generator is formally defined in Section 3. In Section 4 we present our construction of next-block pseudoentropy generator from one-way functions, where in Section 5 we show how to use next-block pseudoentropy generators to get a pseudorandom generator. Finally, in Section 6 we use the above reductions to prove the main result of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES 2.1 Random Variables</head><p>Let X and Y be random variables taking values in a discrete universe U. We adopt the convention that when the same random variable appears multiple times in an expression, all occurrences refer to the same instantiation. For example, Pr[X = X] is 1. The support of a random variable X is Supp(X) := {x : Pr[X = x] &gt; 0}. We write ∆(X, Y ) to denote the statistical difference (a.k.a. variation distance) between X and Y , i.e.</p><formula xml:id="formula_2">∆(X, Y ) = max T ⊆U |Pr[X ∈ T ] -Pr[Y ∈ T ]| .</formula><p>If ∆(X, Y ) ≤ ε (respectively, ∆(X, Y ) &gt; ε), we say that X and Y are ε-close (resp., ε-far).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Entropy Measures</head><p>We will refer to several measures of entropy in this work. The relation and motivation of these measures is best understood by considering a notion that we will refer to as the sample-entropy: For a random variable X and x ∈ Supp(X), we define the sample-entropy of x with respect to X to be the quantity</p><formula xml:id="formula_3">HX (x) := log(1/ Pr[X = x]).</formula><p>The sample-entropy measures the amount of "randomness" or "surprise" in the specific sample x, assuming that x has been generated according to X. Using this notion, we can define the Shannon entropy H(X) and min-entropy H∞(X) as follows:</p><formula xml:id="formula_4">H(X) := E x R ←X [HX (x)] H∞(X) := min x∈Supp(X)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HX (x)</head><p>Flattening Shannon Entropy..</p><p>It is well-known that the Shannon entropy of a random variable can be converted to min-entropy (up to small statistical distance) by taking independent copies of this variable. Lemma 2.1.</p><p>1. Let X be a random variable taking values in a universe U, let t ∈ N, and let ε &gt; 0. Then with probability at least</p><formula xml:id="formula_5">1 -ε -2 -Ω(t) over x R ← X t , |H X t (x) -t • H(X)| ≤ O( t • log(1/ε) • log(|U | • t)).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Let X, Y be jointly distributed random variables where</head><p>X takes values in a universe U, let t ∈ N, and let ε &gt; 0. Then with probability at least</p><formula xml:id="formula_6">1 -ε -2 -Ω(t) over (x, y) R ← (X t , Y t ) := (X, Y ) t , we have that H X t |Y t (x|y) -t • H(X|Y ) ≤ O( t • log(1/ε)•log(|U |• t)).</formula><p>We omit the proof from this version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">One-way Functions</head><p>Definition 2.2. Let f : {0, 1} n → {0, 1} m be a polynomial-time computable function, where n is a security parameter and m = m(n). For T = T (n) and ε = ε(n), we say that f is a (T, ε)-one-way function if for every probabilistic algorithm A running in time T and all sufficiently large n, we have:</p><formula xml:id="formula_7">Pr[A(Y ) ∈ f -1 (Y )] ≤ ε,</formula><p>where the probability is taken over Y = f (Un) and the coin tosses of A. We say that f is a one-way function if it is a (p(n), 1/p(n))-one-way function for every polynomial p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Pseudorandom Generators</head><p>Definition 2.3. Let X be a random variable, depending on a security parameter n, and taking values in {0, 1} m , for m = m(n). For T = T (n) and ε = ε(n), we say that X is (T, ε)-pseudorandom if for every probabilistic distinguisher D running in time T and all sufficiently large n, we have:</p><formula xml:id="formula_8">|Pr[D(X) = 1] -Pr[D(Um) = 1]| ≤ ε. A polynomial-time computable function G : {0, 1} n → {0, 1} m with m = m(n) &gt; n is a (T, ε)-pseudorandom gen- erator if G(Un) is (T, ε)-pseudorandom.</formula><p>We say that X is pseudorandom if it is (p(n), 1/p(n))pseudorandom for every polynomial p. Similarly, G is a pseudorandom generator G if G(Un) is pseudorandom.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">NEXT-BLOCK PSEUDOENTROPY</head><p>In this section we formally define the new notion of nextblock pseudoentropy, for the cases of both Shannon entropy and min-entropy. The definitions will differ from the informal definition given in the introduction (Definition 1.3) in the following two ways, both of which are important for the treatment of uniform adversaries:</p><p>• We will require indistinguishability even against algorithms that have an oracle for sampling from the joint distribution (X, Yi). (This enables us to show, using a hybrid argument, that pseudoentropy increases when we taking many independent copies of X. In the case of nonuniform adversaries, no oracle for sampling from (X, Yi) is needed, as the samples can be nonuniformly hardwired into the adversary.)</p><p>• In order to achieve the first item, we will allow the random variables Yi to depend on the distinguisher.</p><p>Similar issues arise for treating uniform adversaries with standard pseudoentropy.</p><p>Definition 3.1. (next-block (Shannon) pseudoentropy) Let X be a random variable taking values in U m , where X, U, and m may all depend on a security parameter n. For T = T (n), k = k(n) and ε = ε(n), we say that X has (T, ε) next-block pseudoentropy k if for every oracle-aided distinguisher D (•) of running time at most T , there exists a set of random variables {Y1, . . . , Ym} over U such that:</p><p>1. </p><formula xml:id="formula_9">E i R ←[m] [Pr[D O X,Y (X1, . . . , Xi) = 1] -Pr[D O X,Y (X1, . . . , Xi-1, Yi) = 1]] ≤ L • ε,</formula><p>where OX,Y (i), for i ∈ [m], samples according to the joint distribution (X, Yi), and L = L(n) is a bound on number of calls made by D to OX,Y (including the challenge itself ).</p><p>We say that X has next-block pseudoentropy k, if it has (p(n), 1/p(n))-next-block pseudoentropy k for every polynomial p. We say that every block of X has (T, ε)-next-block</p><formula xml:id="formula_10">pseudoentropy α = α(n), if condition (1) above is replaced with H(Yi | X1,...,i-1) ≥ α for every i ∈ [m].</formula><p>Note that we have omitted absolute values in the indistinguishability condition above (and below). This is purely for technical convenience, as D can use O((m/ε) 2 ) random samples from its oracle to test whether the (signed) advantages inside the expectation are positive or negative to within an accuracy of ±ε/2m and negate itself for some values of i in order to ensure a positive advantage of at least Lε/2. Definition 3.2. (next-block pseudo-min-entropy) Let X be a random variable taking values in U m , where X, U, and m may all depend on a security parameter n. For T = T (n), α = α(n), and ε = ε(n), we say that every block of X has (T, ε)-next-block pseudo-min-entropy α, if for every oracleaided distinguisher D (•) running in time at most T (n), there exists a set of random variables {Y1, . . . , Ym} over U such that:</p><p>1. H∞(Yi | X1,...,i-1) ≥ α, and 2.</p><formula xml:id="formula_11">E i R ←[m] [Pr[D O X,Y (X1, . . . , Xi) = 1] -Pr[D O X,Y (X1, . . . , Xi-1, Yi) = 1] ≤ L • ε,</formula><p>where OX,Y and L is as in Definition 3.1.</p><p>We say that every block of X has next-block pseudo-minentropy α, if every block of X has (p(n), 1/p(n))-next-block pseudo-min-entropy α, for every polynomial p.</p><p>Unless explicitly stated otherwise, in the following sections we view a distribution over {0, 1} t as a t-block distribution. When we refer to the next-block pseudoentropy properties of a function G : {0, 1} n → {0, 1} m , these refer to the random variable G(Un).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ONE-WAY FUNCTIONS TO NEXT-BLOCK PSEUDOENTROPY GENERA-TOR</head><p>This section will show how to construct a next-block pseudoentropy generator G nb f out of a one-way function f : {0, 1} n → {0, 1} n . Theorem 4.1. (Next-block pseudoentropy generator from one-way functions) Let n be a security parameter and f : {0, 1} n → {0, 1} n be a polynomial-time computable function. Then there exists a polynomial-time computable generator</p><formula xml:id="formula_12">G nb : {0, 1} d → {0, 1} m , with d = d(n) ∈ O(n) and m = m(n) ∈ O(n)</formula><p>, such that the following holds:</p><p>Security: Assume that f is a (T, ε) one-way function for some T = T (n) and ε = ε(n). Then for any poly(n)-</p><formula xml:id="formula_13">time computable value of ε = ε (n) &gt; 2 -n/4 , G nb has (T • (ε /n) O(1) , ε )-next-block-pseudoentropy k = d + log(1/ε) -c log n, where c is a universal constant.</formula><p>Complexity: G nb is computable in NC 1 with one oracle call to f .</p><p>When f is a standard one-way function, we can take T = 1/ε = n c for an arbitrarily large constant c and set ε = 1/n γc for a small universal constant γ, to deduce that G nb has (n</p><formula xml:id="formula_14">Ω(c ) , 1/n Ω(c ) )-next-block pseudoentropy k = d+(c - c) log n. In particular, G nb has next-block pseudoentropy k = d + log n.</formula><p>Our construction employs a family of hash functions Q = {Qn = {q : {0, 1} n → {0, 1} n }}. We will shortly discuss the properties needed from Q. Given an appropriate family Q, we can define G nb f quite easily: Construction 4.2. On security parameter n, define the algorithm G nb on domain {0, 1} n × Qn, for Qn = {q : {0, 1} n → {0, 1} n }, and oracle f : {0, 1} n → {0, 1} n as follows:</p><p>G nb f (s, q) := (f (s), q, q(s)1, . . . , q(s)n),</p><p>where s is n bits long and q(s)i denotes the ith bit of q(s).</p><p>(Note that we abuse notation and write q for both the function and its description.)</p><p>The following properties regarding the efficiency of G nb f are immediate: •) is linear in its first argument (as |q| = O(|s|). Finally, G nb f invokes f exactly once (and thus is non-adaptive with respect to f ). Indeed, we will define Q that is both efficient and has a short description. The main requirement from Q, however, has to do with ensuring that G nb f is a next-block pseudoentropy generator. Let us start by presenting the following strategy showing that the entropy gap (i.e., k -d) for ε = 1/n Ω(log n) is at least log n. Let D f (y) := log |{x ∈ {0, 1} n : f (x) = y}| and let S be uniformly distributed over {0, 1} n . Then the distribution of S conditioned on y = f (S) still has D f (y) bits of entropy. We would like Q to extract these bits and in addition to extract log n bits of pseudoentropy. More concretely, we ask that the first D f (y) + log n bits of q(S) are pseudorandom even given y = f (S) and q (to simplify notation, we will ignore round-off errors and treat D f (y) as an integer). Given such a Q, we are essentially done (at least when considering non-uniform security<ref type="foot" target="#foot_1">4</ref> ). Consider the distributions X = G nb f (S, Q) and the distribution (Y1, . . . , Yn) := (f (S), Q, R1, . . . R k , Q(S)K+1, . . . , Q(S)n), where S and Q are uniformly distributed, K := D f (f (S)) + log n and the Ri's are uniformly random bits. By the above discussion, X and Y (more formally, X and {Yi}) are next-block indistinguishable. In addition, we have:</p><formula xml:id="formula_15">Lemma 4.3. If Q is in NC 1 then G nb f is in NC 1 with one oracle call to f . If the description length of Qn is O(n) then the input length of G nb<label>(</label></formula><formula xml:id="formula_16">m i=1 H(Yi | X1,...,i-1) ≥ H(f (S)) + H(Q) + H(R1, . . . , RK |f (S)) = H(f (S)) + H(Q) + E[D f (f (S)) + log n] = n + log |Qn| + log n.</formula><p>and therefore G nb f is indeed a next-block pseudoentropy generator.</p><p>The first remaining challenge is to construct such a family Q. As we will discuss shortly, it is easy to obtain all the above properties with hash functions that have description length n 2 . For better efficiency, we will settle on Q with slightly weaker properties (where the pseudorandom bits extracted by q ∈ Q will be pseudorandom up to advantage 1/n rather than an arbitrary inverse polynomial advantage). An additional challenge is achieving next-block pseudoentropy in the (more standard) uniform setting. The difficulty is that we need X and Y to be next-block indistinguishable even given oracles that sample these distributions. While X is efficiently samplable (and thus an oracle that samples X is easy to implement), Y may not be (as D f (y) may be hard to compute). To overcome this difficulty we employ Holenstein's Uniform Hardcore Lemma <ref type="bibr" target="#b13">[14]</ref>. Employing the Hardcore Lemma also closes the gap between the properties of Q we obtain and the stronger properties in the discussion above (actually, we even achieve a stronger guarantee, where the entropy gap is roughly log(1/ε)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The family Q and unpredictability</head><p>A family Q with the above properties, but with description length n 2 , is easy to come by. Simply define q(s) to be As, where A is a uniformly chosen n × n matrix over GF <ref type="bibr" target="#b1">(2)</ref>. For a random y = f (S), the Leftover Hash Lemma <ref type="bibr" target="#b18">[19]</ref> yields that the first D f (y) -c log n bits of Q(S) are statistically close to uniform up to statistical distance 1/n Ω(c) . An additional (c + 1) • log n bits are pseudorandom by reduction to the Goldreich-Levin hardcore predicate <ref type="bibr" target="#b3">[4]</ref>. An interesting open problem is to come up with a family Q that has similar properties and in addition has description length n. Instead, in this paper we relax the requirements from Q.</p><p>Defining q(s) = As is equivalent to selecting each one of the output bits of q(s) to be a uniformly selected location of the Hadamard encoding of s. If instead we let each bit be a location in a polynomially-long encoding of s, we get description length n log n. As long as this encoding possesses good list-decoding properties, such a construction still suffices for our purposes. To save the final log n factor, we will look at an encoding of x into logarithmically long symbols (and thus will only need n/ log n symbols as the output of q(s)). The following lemma formalizes the properties of the encoding we will use. As with the Hadamard Code, the code we will use will satisfy both the role of extracting D f (y) -O(log n) truly random bits via the Leftover Hash Lemma and the role of extracting O(log n) pseudorandom bits similarly to a hardcore function.</p><p>Lemma 4.4. There exists an NC 1 algorithm Enc such that on input s ∈ {0, 1} n , the algorithm Enc produces t = poly(n) symbols Enc(s)1, Enc(s)2, . . . , Enc(s)t with each Enc(s)i ∈ {0, 1} for = log n and such that the following properties hold: Almost 2-Universal: For every two distinct n-bit strings s = s it holds that</p><formula xml:id="formula_17">Pr i∈[t] [Enc(s)i = Enc(s )i] ≤ 2 -• (1 + 1/(2n 5 )).</formula><p>List Decoding: There exists a polynomial-time algorithm Dec that on input 1 n and given oracle access to a function Ã : [t] × {0, 1} → {0, 1}, outputs a list of poly(n) strings that includes every s ∈ {0, 1} n satisfying the following:</p><formula xml:id="formula_18">Pr i R ←[t] [ Ã(i, Enc(s)i) = 1] - Pr i R ←[t],z R ←{0,1} [ Ã(i, z) = 1]] &gt; 1/5n 2 .</formula><p>Note that the oracle Ã has a domain of size t • 2 = poly(n), so Dec has enough time to query it on all inputs (i.e. "local decoding" is not needed).</p><p>Proof. Enc can be taken to be the concatenation of a Reed-Solomon Code (over a field of size a sufficiently large polynomial in n) and the Hadamard Code over GF <ref type="bibr" target="#b1">(2 )</ref>. The almost-universality property follows from a standard argument: the probability that Enc(s) = Enc(s ) is bounded by the probability that a random symbol of two distinct Reed-Solomon codewords agree plus the probability that a random symbol in two distinct Hadamard codewords agree. By making the field of the Reed-Solomon encoding sufficiently larger than 2 (but still poly(n)) we get the desired property. The list-decoding property follows from the list-decoding algorithm of Sudan <ref type="bibr" target="#b22">[23]</ref> for the Reed-Solomon code, combined with brute-force decoding of the Hadamard code. 2</p><p>Construction 4.5. Let n, Enc, t and be as in Lemma 4.4. The description of a random hash function q ∈ Qn is composed of n/ random indices i1, . . . , i n/ ∈ [t]. On input s define q(s) to be the first n bits of Enc(s)i 1 . . . Enc(s)i n/ . Lemma 4.6. Let n be a security parameter, Q be as in Construction 4.5, let G nb be the oracle-aided algorithm for Construction 4.2 (with respect to Q), and let f : {0, 1} n → {0, 1} n be a (T, ε) one-way function, for</p><formula xml:id="formula_19">T = T (n) ≥ n, ε = ε(n). Then there exists a constant c &gt; 0 such that n-1 i=0 Pr[P (f (S), Q, Q(S)1, . . . , Q(S)i) = Q(S)i+1] ≥ n -H(f (S)) + log(1/ε) -c log n 2 ,</formula><p>even when P is allowed to run in time T /n c , where S and Q are uniformly distributed over {0, 1} n and Qn respectively.</p><p>Note that above (and below) Q(S)1, . . . , Q(S)i+1 refer to individual bits of Q(S), not -bit blocks. We omit the proof from this version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Proving Next-block Pseudoentropy via Hardcore Lemma</head><p>Lemma 4.6 shows that the output of G nb (after f (S) and Q) satisfies a weak next-bit unpredictability. In this section we use Holenstein's "Uniform Hardcore Lemma" of Holenstein <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16]</ref> (the uniform variant of the Impagliazzo <ref type="bibr" target="#b16">[17]</ref> Hardcore Lemma), to translate this weak next-bit unpredictability into next-bit pseudoentropy, thereby proving Theorem 4.1. We begin with a statement of the the Hardcore Lemma. This translates weak unpredictability (of a single bit) into strong unpredictability on a noticeable fraction of inputs.</p><p>Proposition 4.7. Let n be a security parameter, and let</p><formula xml:id="formula_20">= (n), h : {0, 1} n → {0, 1} , V : {0, 1} n → {0, 1}, δ = δ(n) ∈ (0, 1) &gt; 1/ poly(n), and γ = γ(n) ∈ (0, 1) &gt; 2 -n/3</formula><p>all be poly(n)-time computable functions. Assume that</p><formula xml:id="formula_21">Pr[M (h(Un)) = V (Un)] ≤ 1 -δ/2</formula><p>for every probabilistic algorithm M running in time T = T (n) and large enough n. Then there is a polynomial p such that for every oracle-aided predictor P running in time T = T /p(n, 1/γ) and all sufficiently large n, there exists a set L ⊆ {0, 1} n of density at least δ such that</p><formula xml:id="formula_22">Pr W R ←L [P χ L (h(W )) = V (W )] &lt; (1 + γ)/2,</formula><p>where χL is the characteristic function of L, provided that all the queries of P to χL are computed independently of the input h(W ).</p><p>We now reinterpret Holenstein's Hardcore Lemma in terms of conditional pseudoentropy, similarly to the reinterpretation of Impagliazzo's Hardcore Lemma in <ref type="bibr" target="#b23">[24]</ref>. Proposition 4.8. Let n be a security parameter, and let = (n), δ = δ(n) ∈ (0, 1) &gt; 1/ poly(n), and γ = γ(n) ∈ (0, 1) &gt; 2 -n/3 all be poly(n)-time functions, and let (A, B) be a poly-time samplable distribution on {0, 1} × {0, 1} such that</p><formula xml:id="formula_23">Pr[M (A) = B] ≤ 1 -δ/2</formula><p>for every probabilistic algorithm M running in time T = T (n) and large enough n. Then there is a polynomial p such that for every oracle-aided distinguisher D running in time T = T /p(n, 1/γ) and all sufficiently large n, there is a random variable C, jointly distributed with A, such that:</p><formula xml:id="formula_24">1. H(C|A) ≥ δ. 2. Pr[D O A,B,C (A, B) = 1] -Pr[D O A,B,C (A, C) = 1] ≤ γ.</formula><p>Proof. Let (h, V ) : {0, 1} n → {0, 1} ×{0, 1} be the polytime sampling algorithms for (A, B), i.e. (h(Un), V (Un)) = (A, B). (By renaming the security parameter n, we may assume that the sampling algorithms use n coin tosses.) Thus we may apply Proposition 4.7 to the pair (h, V ). For any given subset L ⊆ {0, 1} n of density δ, we define a probabilistic function VL : {0, 1} n → {0, 1}, where</p><formula xml:id="formula_25">VL(r) = V (r) if r / ∈ L a random bit if r ∈ L.</formula><p>From this we get a random variable CL jointly distributed with A, defined by (A, CL) = (h(Un), VL(Un)). Notice that H(CL|A) is at least the density of L, namely δ. We will show that taking C = CL for some L suffices. Suppose for contradiction that we have an oracle-aided distinguisher D running in time T such that for every L of density δ,</p><formula xml:id="formula_26">Pr[D O A,B,C L (A, B) = 1] -Pr[D O A,B,C L (A, CL) = 1] &gt; γ. Since B and CL are identical when Un / ∈ L, we have Pr[D O A,B,C L (A, B) = 1|Un ∈ L] -Pr[D O A,B,C L (A, CL) = 1|Un ∈ L] &gt; γ.</formula><p>Since CL is a uniformly random bit when Un ∈ L, we can apply the standard reduction from distinguishing to predicting to obtain an oracle-aided predictor P , running in time T + O(1) such that</p><formula xml:id="formula_27">Pr[P χ L (A) = B|Un ∈ L] &gt; (1 + γ)/2.<label>(1)</label></formula><p>Specifically, on input x, P generates a random bit b R ←{0, 1}, runs D O A,B,C L (x, b), outputs b if D outputs 1, and outputs ¬b if D outputs 0. P can simulate random samples from the oracle OA,B,C L by choosing r R ← {0, 1} n and outputting (h(r), V (r), VL(r)), which can be efficiently computed using P 's oracle access to χL. Equation ( <ref type="formula" target="#formula_27">1</ref>) can be rewritten as:</p><formula xml:id="formula_28">Pr W R ←L [P χ L (h(W )) = V (W )] &gt; (1 + γ)/2.</formula><p>This contradicts Proposition 4.7.</p><p>2</p><p>We can now use this form of the Hardcore Lemma to deduce Theorem 4.1 from Lemma 4.6. The proof is omitted from this version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">FROM NEXT-BLOCK PSEUDOEN-TROPY TO PSEUDORANDOM GENER-ATORS</head><p>In this section we show how to transform a next-block pseudoentropy generator into a pseudorandom generator.</p><p>Theorem 5.1. (Next-block pseudoentropy generator to pseudorandom generator) Let n be a security parameter, and let m = m(n), ∆ = ∆(n) ∈ [1/ poly(n), n], and κ = κ(n) ∈ {1, . . . , n} be poly(n)-time computable. For every polynomial-time computable, m-block generator G nb : {0, 1} n → {0, 1} m , there exists a polynomial-time computable generator G : {0,</p><formula xml:id="formula_29">1} d → {0, 1} d•(1+Ω(∆)) with d = d(n) = O(m 2 • (n/∆) 3 • κ • log 2 n</formula><p>) such that the following holds:</p><formula xml:id="formula_30">Security: Assume that G nb has (T, ε)-next-block pseudoen- tropy at least n + ∆, for T = T (n), ε = ε(n), then G is a (T / poly(n), poly(n) • (ε + 2 -κ ))-pseudorandom generator. Complexity: G is computable in NC 1 with O(d/n) oracle calls to G nb .</formula><p>In Theorem 5.1, it may be convenient to view κ(n) as the security parameter of the construction. In particular, when</p><formula xml:id="formula_31">κ(n) logarithmic in 1/ε(n) we get that (T (n), ε(n))-next- block pseudoentropy turns into an (T (n)/ poly(n), poly(n) • ε(n))-pseudorandom generator.</formula><p>We prove Theorem 5.1 via the following sequence of reductions:</p><p>1. In Section 5.1 we show how to get a better handle on the output distribution of the G nb -specifically, we apply a generic transformation on G nb , to get a generator for which the (conditional) pseudoentropy of each of its output blocks is the same (i.e., (n + ∆)/m).</p><p>2. In Section 5.2 we consider a direct product of the latter next-block pseudoentropy generator, and show that this action both increases the absolute gap between the next-block pseudoentropy of the generator and its real entropy (i.e., its input length), and transforms its next-block pseudoentropy into next-block pseudo-minentropy.</p><p>3. In Section 5.3 we show to extract pseudorandomness from the output of the latter type of generators.</p><p>4. In Section 5.4 we put the above parts together to prove Theorem 5.1.</p><p>To simplify notations, we prove the first three steps with respect to arbitrary next-block pseudoentropy distributions. Given a distribution X over U m , a set of distributions Y = {Yi} i∈[m] over U, and an oracle-aided algorithm</p><formula xml:id="formula_32">D (•) , we let δ D X,Y := E i R ←[m(n)] δ D X,Y,i := Pr[D O X,Y (X1, . . . , Xi) = 1]-Pr[D O X,Y (X1, . . . , Xi-1, Yi) = 1]</formula><p>, where OX,Y (i) samples according to the joint distribution (X, Yi) (see Definition 3.1). Finally, in all of the following claims we assume the description of the "universe" U is polynomial in n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Entropy Equalization</head><p>In this section we show to manipulate a given distribution to gain a better characterization of its next-block pseudoentropy, without losing "too much" pseudoentropy. The following transformation is closely related to a similar reduction from <ref type="bibr" target="#b7">[8]</ref>. The idea is the following: consider an m-block random variable X over U m with next-block pseudoentropy k. Now generate m • blocks by concatenating independent copies one after the other. Finally, for a random j ∈ [m], erase the first j blocks and the last m -j blocks. We now have a new variable X with m • ( -1) blocks and for every location i the block in the ith location of X is a block of X in a random location. It is not hard to prove (as we do below) that the next-block pseudoentropy of each block is at least k/m. On the other hand, the real entropy of X is at most times that of X. Taking large enough we get that the (relative) difference between next-block pseudoentropy and real entropy has not significantly decreased.</p><p>For j ∈ [m] and z (1) , . . . , z ( ) ∈ U m , we let Eq(j, z (1) , . . . , z ( ) ) := (z Claim 5.2. Let n be a security parameter, and let m = m(n) = poly(n) and = (n) = poly(n) be poly(n)time computable integer functions, where (n) &gt; 1. Let X be random variable over U m with (T, ε)-next-block pseudoentropy at least k, for T = T (n), ε = ε(n) and k = k(n). Let J be uniformly distributed over [m] and let X = Eq(J, X (1) , . . . , X ( ) ), where the X (i) 's are iid copies of X.</p><formula xml:id="formula_33">Then X has (T -O( • m • log |U |), 2 ε) next-block pseudoen- tropy at least k/m.</formula><p>Proof. Let m = ( -1) • m and let Y = {Y1, . . . , Ym} be a set of random variable jointly distributed with X. In the following we think of Y as a single random variable Y = (Y1, . . . , Ym) jointly distributed with X, though we only sample a single entry Yi per instance of Y . Let Y (1) , . . . , Y ( ) be iid copies of Y and let Y = Eq(J, Y (1) , . . . , Y ( ) ) be jointly distributed with X in the natural way --J takes the same value as in X, and for every j ∈ [ ], Y (j) is jointly distributed with X (j) according to the joint distribution (X, Y ). Notice that Yi = Y J+i-1 mod m (where we define m mod m to equal m rather than 0), and that</p><formula xml:id="formula_34">J + i -1 is uniformly distributed in [m].</formula><p>Thus, for every i ∈ [m ] we have that</p><formula xml:id="formula_35">H( Yi | X1,...,i-1) (2) ≥ H(Y J+i-1 mod m |X1, . . . , X (J+i-1 mod m)-1 ) = E i R ←[m] [H(Y i | X1, . . . , X i -1 )].</formula><p>Let D be an adversary the violates the next-block pseudoentropy of X. We define D for breaking the next-block pseudoentropy of X as follows: on input (x1, . . . , xi-1, z), D generates a random sample x = (x 1 , . . . , x m ) from X (using OX,Y ). It then selects i ∈ [m ] uniformly at random such that i = j + i -1 mod m, where j is the value of J in the generation of </p><formula xml:id="formula_36">δ D X, Y = δ D X,Y ≤ L • ε = L • (2 ε),</formula><p>where L and L are the number of oracle calls made by D and D, respectively. This is contradiction to the assumption about the next-block pseudoentropy of X. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Next-block Pseudoentropy Converts to Pseudo-Min-Entropy</head><p>In this section we show how to transform nextblock (Shannon) pseudoentropy to next-block pseudo-minentropy, while increasing the overall entropy gap. The transformation of X is simply a t-fold parallel repetition of X (i.e., every block of the new random variable X t is composed of t corresponding blocks of t independent copies of X). This generalizes an analogous transformation that was used by Håstad et al. <ref type="bibr" target="#b12">[13]</ref> in the context of standard (i.e. single-block) pseudoentropy.</p><p>Given an m-block random variable V taking values in U m and an integer t &gt; 0, we let</p><formula xml:id="formula_37">V t = ((V (1) 1 , . . . , V (t) 1 ), . . . , (V (1) m , . . . , V (t) m )) ∈ (U t ) m , where V (i)</formula><p>for every i ∈ [t] is an independent copy of V . Claim 5.3. Let n be a security parameter, and m = m(n) = poly(n), t = t(n) = poly(n), be poly(n)-time computable functions, and let X be a random variable over U m where every block of X has (T, ε) next-block pseudoentropy α, for T = T (n), ε = ε(n), α = α(n). Then for every κ = κ(n) &gt; 0 it holds that every block of X t has (T , ε ) next-block pseudo-min-entropy α , where</p><formula xml:id="formula_38">• T = T (n) = T -O(m • t • log |U|). • ε = ε (n) = 2 • t 2 • (ε + 2 -κ + 2 -c•t</formula><p>) for a universal constant c &gt; 0, and</p><formula xml:id="formula_39">• α = α (n) = t • α -Γ(t, κ, |U |), for Γ(t, κ, |U|) ∈ O( √ t • κ • log(|U | • t)).</formula><p>Notice that the t • α term is the largest we could hope for the pseudoentropy -getting α bits of pseudoentropy per copy. However, since we wish to move from a pseudo-form of Shannon entropy (measuring randomness on average) to a pseudo-form of min-entropy (measuring randomness with high probability), we may have a deviation that grows like √ t. By taking t large enough, this deviation becomes insignificant.</p><p>In more detail, consider the case that X has next-block pseudoentropy α with polynomial security, i.e. T and 1/ε can be taken to be arbitrarily large polynomials in n, and we would like to deduce that X t has next-block min-pseudoentropy α with polynomial security. Moreover, assume U = {0, 1}. Then we should take κ and t to be an arbitrarily large multiples of log n, and we have α = t • (α -O( (log n)/t) • log t). So if we would like to have pseudo-min-entropy at least t • (α -δ), we should take t to be polylog(n)/δ 2 . In our application, we have δ = Θ(∆/n) = Θ(log n/n), so we take t = Õ(n 2 ) copies.</p><p>We omit the proof from this version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Next-block Pseudo-Min-Entropy to Pseudorandomness</head><p>For our final step, we assume that X is such that each of the m blocks of X has large next-block pseudo-min-entropy α. Using a two-universal independent hash function S, we extract almost all its pseudo-min-entropy of each block individually. The result is a sufficiently long pseudorandom bit sequence. This is a computational analogue of block-source extraction in the literature on randomness extractors <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">28]</ref>. </p><formula xml:id="formula_40">(n) = poly(n), t = t(n) = poly(n), α = α(n) ∈ [t(n)] and κ = κ(n) ∈ [α(n)]</formula><p>be poly(n)-time computable integer functions. There exists an efficient procedure Ext ∈ NC 1 that on input x ∈ ({0, 1} t ) m and s ∈ {0, 1} t , outputs a string y ∈ ({0, 1} α-κ ) m such that the following holds.</p><p>Let X be a random variable over ({0, 1} t ) m such that every block of X has (T, ε) next-block pseudo-min-entropy α, for T = T (n) and ε = ε(n), then Ext(X, Ut) is (T -m • poly(t), m • ε + 2 -κ/2 ) pseudorandom.</p><p>Proof. Let Ext(x, s) := (s(x1), . . . , s(xm)), where s is interpreted as a member of a family of two-universal hash functions from t bits to α -κ bits in NC 1 (such as s(x) := s • x over GF (2 t ) truncated to α -κ bits). Let DPRG be an adversary that violates the pseudorandomness of Ext(X, Ut), and let δPRG be its distinguishing advantage. We define D for breaking the next-block pseudoentropy of X as follows: on input (x1, . . . , xi-1, z), D returns DPRG(s(x1), . . . , s(xi-1), s(z), U (α-κ)•(m-i) ), where s is uniformly chosen from {0, 1} t .</p><p>We note that D makes no oracle calls (and thus we count its query complexity as one), and that its running-time is at most that of DPRG plus m • poly(t).</p><p>Let Z [i] (W ) := (S(X1), . . . , S(Xi-1), S(W ), U (α-κ)•(m-i) ), for a uniformly distributed hash function S and let Y = {Y1, . . . , Ym} be a set of random variable over U jointly distributed with X, with H∞(Yi | x1,...,i-1) ≥ α for every x ∈ Supp(X) and i ∈ [m]. The Leftover Hash Lemma <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b17">18]</ref> can be shown to yield that δ D X,Y ≥ ε (further details are omitted from this version). This contradicts the assumption about the next-block pseudoentropy of X. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Putting It Together</head><p>The proof of Theorem 5.1 follows the three steps given by the three previous subsection (entropy equalization, obtaining pseudo-min-entropy and finally obtaining pseudorandomness). We omit the proof from this version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">PUTTING IT TOGETHER</head><p>We are now ready to prove the main result of the paper. Complexity: G is computable in NC 1 with O(d/n) oracle calls to f .</p><p>We omit the proof from this version. The above theorem yields the following important corollaries. G is computable in NC 1 with O(d/n) oracle calls to f .</p><p>Proof. Applying Theorem 6.1 on f , ε = 1/n c and κ = log 2 n, we get an efficient generator G of the stated input and output lengths. Assume now that G is not a pseudorandom generater. Namely, there exists p ∈ poly such that G is not (p(n), 1/p(n)) pseudorandom. Therefore, G is not (T • (ε /n) O (1) , ε • poly(n))-pseudorandom, for ε := 1/p(n) • poly(n) &gt; 2 -κ and T = poly(n) • p(n). It follows that f is not (T, ε)-one-way, in contradiction. 2 Corollary 6.3. (Pseudorandom generator from one-way functions -exponential hardness case) Let f : {0, 1} n → {0, 1} n be a (2 Ω(n) , 2 -Ω(n) )-one-way function, then 1. There exists a (2 Ω(n) , 2 -Ω(log Proof. Immediate from Theorem 6.1, taking κ = log 2 (n) and κ ∈ Ω(n) in the first and second cases respectively, and ε = 2 -κ .</p><p>2</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>:</head><label></label><figDesc>Håstad et al. enumerate over all u = O(n/∆) possible values k for the output entropy of PEG (up to an accuracy of ∆/2), construct a pseudorandom generator G k for each, use composition to make each G k stretch its seed by a factor of greater than u, and then take G(x1, . . . , xu) = G1(x1) ⊕ • • • ⊕ Gu(xu) as their final pseudorandom generator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>m i=1 H(Yi | X1, . . . , Xi-1) ≥ k, and 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Claim 5 . 4 .</head><label>54</label><figDesc>(from next-block pseudo-min-entropy to pseudorandomness) Let n be a security parameter, m = m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 6 . 1 .</head><label>61</label><figDesc>(Pseudorandom generator from one-way functions) Let n be a security parameter and f : {0, 1} n → {0, 1} n a polynomial-time computable function. For allpoly(n)-time computable functions ε = ε(n) ≤ 1/n c (where c is a universal constant) and κ = κ(n) ∈ [n/4], there exists an efficient generator G from strings of length d = d(n) = O(n 4 • κ • log 2 n/ log 3 (1/ε) to strings of length d • (1 + Ω(log(1/ε)/n),such that the following holds:Security: Assume that f is a (T, ε) one-way function for T = T (n), ε = ε(n), and let ε = ε (n) ≥ 2 -κ be an poly(n)-time computable function, then G is a (T • (ε /n) O(1) , ε • poly(n))-pseudorandom generator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Corollary 6 . 2 .</head><label>62</label><figDesc>(Pseudorandom generator from oneway functions -polynomial security case) Let n be a security parameter f : {0, 1} n → {0, 1} n be a one-way function, then there exists a pseudorandom generator G from strings of length d = d(n) ∈ Õ(n 4 ) to strings of length d • (1 + Ω((log n)/n)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>2 n) )-pseudorandom generator G from strings of length d = d(n) ∈ Õ(n) to strings of length d • (1 + Ω(1)), and 2. There exists a (2 Ω(n) , 2 -Ω(n) )-pseudorandom generator G from strings of length d(n) ∈ Õ(n 2 ) to strings of length d • (1 + Ω(1)), G is computable in NC 1 with O(d(n)/n) oracle calls to f .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>x , and returns D O X, Y (x 1 , . . . , x i -i , x1, . . . , xi-1, z), while answering D's queries to O X, Y using OX,Y . We note that D makes at most 2 times more oracle queries than D, and that D can be implemented in the running time of D plus O( • m • log |U|).</figDesc><table /><note><p>For every Y as above with i∈[m] H(Yi | X1,...,i-1) ≥ k, Equation (2) yields that Y is a random variable that D should be able to next-block distinguish from X. Since the query to D done by D is distributed identically to a random challenge to D with respect to the joint distribution ( X, Y ), it follows that</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>In more detail, Holenstein's construction generalizes<ref type="bibr" target="#b12">[13]</ref> for OWFs of "any hardness", while Haitner et al.<ref type="bibr" target="#b9">[10]</ref> take a totally different route (based on the"randomized iterate" of a function introduced by Goldreich et al.<ref type="bibr" target="#b6">[7]</ref>) and obtain constructions based on exponentially hard OWFs, as well as on (unknown-)regular OWFs.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>I.e., the distinguisher is non-uniform and does not get oracle access to OX,Y .</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Benny Applebaum, Oded Goldreich, Thomas Holenstein, and Emanuele Viola for very helpful conversations.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Supported by US-Israel BSF grant 2006060. † Supported by NSF grant CNS-0831289 and US-Israel BSF grant 2006060.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Cryptography in NC 0</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Unbiased bits from sources of weak randomness and probabilistic communication complexity</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="230" to="261" />
			<date type="published" when="1988-04">Apr. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Zero-knowledge proofs of identity</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="77" to="94" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A hard-core predicate for all one-way functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>the 21st Annual ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="792" to="807" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="691" to="729" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note>Preliminary version in FOCS&apos;86</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the existence of pseudorandom generators</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1163" to="1175" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Inaccessible entropy</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>the 41st Annual ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the power of the randomized iterate</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2006</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient pseudorandom generators from exponentially hard one-way functions</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Automata, Languages and Programming, 24th International Colloquium</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>ICALP</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Statistically hiding commitments and statistical zero-knowledge arguments from any one-way function</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1153" to="1218" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Inaccessible entropy</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual ACM Symposium on Theory of Computing (STOC &apos;09)</title>
		<meeting>the 41st Annual ACM Symposium on Theory of Computing (STOC &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009-06">May-2 June 2009</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="611" to="620" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A pseudorandom generator from any one-way function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary versions in STOC&apos;89 and STOC&apos;90</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1364" to="1396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Key agreement from weak bit agreement</title>
		<author>
			<persName><forename type="first">T</forename><surname>Holenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>the 37th Annual ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="664" to="673" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Pseudorandom generators from one-way functions: A simple construction for any hardness</title>
		<author>
			<persName><forename type="first">T</forename><surname>Holenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography, Third Theory of Cryptography Conference</title>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Strengthening key agreement using hardcore sets -PhD thesis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Holenstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A personal view of average-case complexity</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Annual Structure in Complexity Theory Conference</title>
		<meeting>the Tenth Annual Structure in Complexity Theory Conference</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="134" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">How to recycle random bits</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zuckerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th Annual Symposium on Foundations of Computer Science (FOCS)</title>
		<meeting>the 30th Annual Symposium on Foundations of Computer Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="248" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Pseudorandom generation from one-way functions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>the 21st Annual ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="12" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">How to construct pseudorandom permutations from pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Bit commitment using pseudorandomness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="151" to="158" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note>Preliminary version in CRYPTO&apos;89</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Natural proofs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Razborov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="35" />
			<date type="published" when="1997-08">Aug. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Decoding of Reed-Solomon codes beyond the error correction bound</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Complexity</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="180" to="193" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Pseudorandom generators without the XOR lemma</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Trevisan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="236" to="266" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Constructing locally computable extractors and cryptosystems in the bounded-storage model</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="43" to="77" />
			<date type="published" when="2004-01">January 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A theory of the learnable</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1134" to="1142" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Protocols for secure computations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="160" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Simulating BPP using a general weak random source</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zuckerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4/5</biblScope>
			<biblScope unit="page" from="367" to="391" />
			<date type="published" when="1996-11">Oct./Nov. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
