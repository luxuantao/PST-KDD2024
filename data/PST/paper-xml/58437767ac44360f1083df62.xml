<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalable Graph-based Bug Search for Firmware Images</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Qian</forename><surname>Feng</surname></persName>
							<email>qifeng@syr.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">Syracuse University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rundong</forename><surname>Zhou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">Syracuse University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chengcheng</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">Syracuse University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yao</forename><surname>Cheng</surname></persName>
							<email>ycheng@syr.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">Syracuse University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Brian</forename><surname>Testa</surname></persName>
							<email>brian.testa.1@us.af.mil</email>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">Syracuse University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Air Force Research Lab</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Heng</forename><surname>Yin</surname></persName>
							<email>heyin@syr.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">Syracuse University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Riverside</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scalable Graph-based Bug Search for Firmware Images</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">76E76EBA271E0A114E2617687F7E34E0</idno>
					<idno type="DOI">10.1145/2976749.2978370</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Firmware Security</term>
					<term>Machine Learning</term>
					<term>Graph Encoding</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Because of rampant security breaches in IoT devices, searching vulnerabilities in massive IoT ecosystems is more crucial than ever. Recent studies have demonstrated that control-flow graph (CFG) based bug search techniques can be effective and accurate in IoT devices across different architectures. However, these CFG-based bug search approaches are far from being scalable to handle an enormous amount of IoT devices in the wild, due to their expensive graph matching overhead. Inspired by rich experience in image and video search, we propose a new bug search scheme which addresses the scalability challenge in existing cross-platform bug search techniques and further improves search accuracy. Unlike existing techniques that directly conduct searches based upon raw features (CFGs) from the binary code, we convert the CFGs into high-level numeric feature vectors. Compared with the CFG feature, high-level numeric feature vectors are more robust to code variation across different architectures, and can easily achieve realtime search by using state-of-the-art hashing techniques.</p><p>We have implemented a bug search engine, Genius, and compared it with state-of-art bug search approaches. Experimental results show that Genius outperforms baseline approaches for various query loads in terms of speed and accuracy. We also evaluated Genius on a real-world dataset of 33,045 devices which was collected from public sources and our system. The experiment showed that Genius can finish a search within 1 second on average when performed over 8,126 firmware images of 420,558,702 functions. By only looking at the top 50 candidates in the search result, we found 38 potentially vulnerable firmware images across 5 vendors, and confirmed 23 of them by our manual analysis. We also found that it took only 0.1 seconds on average to finish searching for all 154 vulnerabilities in two latest commercial firmware images from D-LINK. 103 of them are potentially vulnerable in these images, and 16 of them were confirmed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Finding vulnerabilities in devices from the Internet of Things (IoT) ecosystem is more crucial than ever. Unlike in PCs or mobile phones, a security breach in one IoT device could cause unprecedented damage to our daily life, involving massive breakdowns of public systems <ref type="bibr" target="#b4">[4]</ref> or quality of life issues. Even worse, we cannot rely on traditional protection mechanisms like commercial AntiVirus software on PCs and mobile devices to prevent attacks, since these traditional defenses are not feasible on IoT devices due to their relatively low CPU and memory profiles <ref type="bibr" target="#b3">[3]</ref>. Gartner, Inc. forecasts that 6.4 billion connected things will be in use worldwide in 2016, up 30 percent from 2015, and will reach 20.8 billion by 2020. The vast diffusion of devices will increase the potential for the introduction of vulnerabilities to the IoT ecosystem. As a result, the need for third-party evaluators (e.g. consumer product evaluators, penetration testers) to quickly and accurately identify vulnerabilities in IoT ecosystem devices on behalf of customers and the need to support periodic security evaluations on existing devices is increasing dramatically <ref type="bibr" target="#b1">[1]</ref>.</p><p>However, discovering vulnerabilities in an IoT ecosystem is like finding a needle in a haystack, even when we are dealing with known vulnerabilities. For many IoT products, security is an afterthought. Between copy-paste coding practices and outsourcing of functionality to untrusted third-party libraries, the development process of IoT devices is a fertile environment for bug generation and persistence. As several integration vendors may rely upon the same subcontractors, tools, or SDKs provided by third-party vendors <ref type="bibr" target="#b18">[19]</ref>, bugs generated during the development process can be spread across hundreds or even thousands of IoT devices with similar firmware. Without detailed knowledge of the internal relationships between these vendors, it is impossible to track the same vulnerability across the IoT ecosystem <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b26">27]</ref>. It is even worse when these devices are built on different architectures <ref type="bibr" target="#b44">[45]</ref>.</p><p>To address this critical problem, security researchers have been actively developing techniques to automatically analyze and detect vulnerabilities in IoT products <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b51">52,</ref><ref type="bibr" target="#b60">61]</ref>. Advancing our ability to perform bug searches in a general, lightweight manner is becoming increasingly important. Such a bug search technique would allow security professionals to reduce the time and resources required to locate a problem. Having done so, security professionals could scan all IoT devices in the ecosystem for a new vulnerability, and quickly generate a security evaluation. They would also be able to scan a new device for all known vulnerabilities, thus allowing us to learn from past mistakes before the possibly bug-infested IoT devices are widely deployed.</p><p>Bug search at scale. Researchers have already made primitive attempts at bug searching in the firmware images of IoT devices <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b44">45]</ref>. One common approach is to scan the firmware images using superficial patterns such as constant numbers or specific strings <ref type="bibr" target="#b18">[19]</ref>. When a vulnerability is tied to a unique constant or string, this approach can be very effective and can easily scale to a large number of firmware images. However, this approach lacks the generality to deal with more complex vulnerabilities that lack these distinct constant or string patterns.</p><p>To address cross-platform bug search in general, two recent efforts <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b44">45]</ref> proposed extraction of various robust features from binary code and then performed searches against the extracted control flow graphs (CFGs). However, these approaches are far from being scalable. The approach by Pewny et al. <ref type="bibr" target="#b44">[45]</ref> can take up to one CPU month to prepare and conduct a search in a stock Android image with 1.4 million basic blocks <ref type="bibr" target="#b22">[23]</ref>. Eschweiler et al. <ref type="bibr" target="#b22">[23]</ref> attempted to address this issue by leveraging a more lightweight feature extraction and using a pre-filtering technique. However, the efficacy of pre-filtering was only evaluated on a small number of firmware images, for a small set of vulnerabilities. According to our large-scale evaluation in Section 5.3, pre-filtering seems unreliable and can cause significant degradation in search accuracy.</p><p>Bug search as a search problem. Fundamentally, the bottleneck for the CFG-based bug search techniques is not about the graph matching algorithm, but rather the search scheme. These techniques conduct pairwise graph matching for search, the complexity of which makes them unusable in large-scale datasets.</p><p>A similar problem has been extensively studied in the computer vision community where they are interested in efficiently searching for similar images from large volume of image <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b59">60]</ref>. Instead of conducting pair-wise matching on raw images directly, they learn higher-level numeric feature representations from raw images. In this paper, we leverage the successful techniques from the computer vision community and propose a novel search method called Genius 1 for bug search in IoT devices. Although images appear to be quite different from binary functions, we found in this paper that scalable image search methodologies can be applied for graph-based bug search. As opposed to directly matching two control-flow graphs, the proposed method learns higher-level numeric feature representations from control-flow graphs, and then conducts search based on the learned higher-level features.</p><p>Compared with existing bug search methods, Genius has the following two benefits: First, the learned features tend to be more invariant to cross-architecture changes than the raw CFG features. This is because Genius learns a feature representation using representative CFGs, which tends to be more invariant than the pairwise match. This invariance property has been verified in a number of image retrieval system <ref type="bibr" target="#b52">[53,</ref><ref type="bibr" target="#b58">59]</ref> such as the Google image search. The experimental results in Section 5 substantiate this hypothesis in the bug search problem. Second, Genius significantly improves the state-of-the-art bug search efficiency. The graph is a complex structure, and thus directly indexing or hashing graphs at scale is still a challenging problem <ref type="bibr" target="#b35">[36]</ref>. However, the proposed method circumvents the difficulty by transforming a graph as a higher-level feature representation, which can be indexed by Locality Sensitive Hashing <ref type="bibr" target="#b53">[54]</ref>. This transformation enables a bug search method that could be orders of magnitude faster than existing methods.</p><p>Our interdisciplinary study focuses on leveraging existing image retrieval techniques to address the scalability issue in the existing graph-based bug search methods. Furthermore, our empirical studies provide compelling insights how to find appropriate settings for the bug search problem. Our empirical observations 1 Genius stands for Graph Encoding for Bug Search. may benefit not only the bug search methods but also other related approaches <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b61">62,</ref><ref type="bibr" target="#b62">63]</ref>.</p><p>We have implemented a proof-of-concept Genius, and compared it with existing state-of-the-art bug search approaches; our experiments demonstrate that Genius outperforms existing methods over various query loads in terms of accuracy and efficiency and scalability. We further demonstrate the efficacy of IoT bug search on 8,126 firmware images of 420,558,702 functions. The performance testing on 10,000 queries showed that Genius can finish a query in less than 1 second on average. Contributions. In summary, our contributions are as follows:</p><p>• New insights. We leverage techniques widely used in the computer vision community and develop a control flow graph based method to address the scalability issue in existing bug search techniques. We systematically study different schemes in the existing image search techniques, and discover an appropriate scheme for the bug search in IoT ecosystem.</p><p>• Significant scalability improvement. We demonstrate the efficacy of Genius on firmware images from 8,126 devices across three architectures and 26 vendors. The performance testing on 10,000 queries shows that Genius can process a query in less than 1 seconds on average. We also demonstrate that Genius can achieve comparable or even better accuracy and efficiency than the baseline techniques.</p><p>• New Discoveries. We demonstrate two use scenarios for Genius. The results show that Genius takes less than 3 seconds on average to finish a vulnerability search across 8,126 devices. As a result of the efficient method, by only looking at top 50 candidates in the search result, we found 38 potentially vulnerable firmware images across 5 vendors, and confirmed 23 of them via manual analysis. We also found that Genius takes only 0.1 second on average for all 154 vulnerabilities in two latest commercial firmware images from D-LINK. 103 potential vulnerabilities were found in these images, and 16 of them were confirmed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">APPROACH OVERVIEW</head><p>Inspired by image retrieval techniques, the proposed method includes the following main steps, as shown in Figure <ref type="figure">1</ref>: 1) raw feature extraction, 2) codebook generation, 3) feature encoding, and 4) online search. The first step aims at extracting the attributed control flow graph, which is referred to as the raw feature, from a binary function (Section 3). Codebook generation utilizes unsupervised learning methods to learn higher-level categorizations from raw attributed control flow graphs (Section 4.1). Feature encoding encodes the attributed control flow graph by learned categorizations into higher-level feature vector residing in the high-dimensional space (Section 4.2). Finally, given a function, online search aims at efficiently finding its most similar functions by Locality Sensitive Hashing (LSH) <ref type="bibr">[9]</ref>. Since each function is transformed into a higher-level numeric feature in the feature encoding step, we can directly apply LSH to conduct efficient searches in terms of the approximated cosine and Euclidean distance between the higher-level features (Section 4.3). The details of each step will be discussed in the following sections.</p><p>Generally, there are two stages in the proposed method: offline indexing and online search. Offline indexing, which includes raw feature extraction, codebook generation and feature encoding, is applied to existing functions before we can perform searches. Similar to text and image search methods, this step is a one-time effort and can be trivially paralleled across multiple CPU cores. The online search phase, which includes feature encoding and search, is When a new vulnerability is released, a security professional can use Genius to search for this vulnerability in their device repositories . Genius will generate the query for the vulnerability and query in the indexed repository. The outputs will be a set of metadata about all potentially infected devices with their brand names, library names and the potentially vulnerable functions. All outputs will be ranked by their similarity scores for quick screening of the results. 2) Scenario II: Security professionals may upload unseen firmware images that do not exist in the repository for a comprehensive vulnerability scan. In this case, Genius will index these firmware images for the security professionals. As a result, they can simply query any vulnerabilities in our vulnerability database. Genius will retrieve the most similar vulnerabilities in the existing indexed firmware images and output metadata of all potentially vulnerable functions including their names, library names holding these functions and firmware device types where these functions are used. Again, all outputs will be ranked by their similarity scores to facilitate quick screening of the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RAW FEATURE EXTRACTION</head><p>The CFG (Control Flow Graph) is the common feature used in bug search. More recently, different attributes on the basic blocks, such as I/O pairs and statistic features <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b44">45]</ref>, are explored to increase the matching accuracy. Following the idea, this paper utilizes the control flow graph with different basic-block level attributes called ACFG (Attributed Control Flow Graph) as the raw features to model the function in our problem. Definition 1. (Attributed Control Flow Graph) The attributed control flow graph, or ACFG in short, is a directed graph G = V, E, φ , where V is a set of basic blocks; E ⊆ V ×V is a set of edges representing the connections between these basic blocks, and φ : V → Σ is the labeling function which maps a basic block in V to a set of attributes in Σ.</p><p>The attribute set Σ in Definition 1 can be tailored depending upon the level of detail required to accurately characterize a basic block. For efficiency, instead of using expensive semantic features like I/O pairs <ref type="bibr" target="#b44">[45]</ref>, we focus on two types of features in this paper: statistical and structural. The statistical features describe local statistics within a basic block, whereas the structural features capture the position characteristics of a basic block within a CFG. Inspired by <ref type="bibr" target="#b22">[23]</ref>, in Σ we extract six types of statistical features and two types of structural features, listed in Table <ref type="table" target="#tab_0">1</ref>.</p><p>Inspired by the work on complex network analysis, we propose two types of structural features: no. of offspring and betweenness centrality. The no. of offspring is the number of children nodes in the control flow graph. This information helps locate the layer of a node in the graph. The betweenness centrality measures a node's centrality in a graph <ref type="bibr" target="#b41">[42]</ref>. Nodes in the same layer in the CFG could have different betweenness centrality. The results in Section 5.4 demonstrate the efficacy of the proposed structural features. In summary, the proposed features consider not only the statistical similarity but also the structural similarity between two ACFGs.</p><p>To generate the attributed graph for a binary function, we first extract its control flow graph, along with attributes in Σ for each basic block in the graph, and store them as the features associated with the basic block. We utilize IDA Pro <ref type="bibr" target="#b27">[28]</ref>, a commercial disassembler tool, for attributed graph construction. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">METHODOLOGY</head><p>Section 3 introduced the notion of Attributed Control Flow Graph (ACFG), which will be used as the raw feature set for Genius. This section discusses how we utilize these ACFGs and transform them into high-level feature vectors that are suitable for scalable, accurate bug search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Codebook Generation</head><p>The first step in the proposed method is codebook generation, which aims at learning a set of categorizations, that is codewords, from raw features. Formally, a codebook C is a finite and discrete set: C = {c1, c2, . . . , c k }, where ci is the i-th codeword, or "centroid", and i is the integer index associated with that centroid. The codebook is generated from a training set of raw features by an unsupervised learning algorithm. In our case, the raw features are the control flow graphs. The codebook generation consists of two phases: similarity metric computation and clustering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Raw Feature Similarity</head><p>We consider the raw feature similarity computation as a labeled graph matching problem. By definition, ACFGs are matched not only by their structures but also by their labels (attributes) on the structures. Theoretically, graph matching is an NP-complete problem, but many techniques have been proposed to optimize the process for an approximate matching result <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b48">49]</ref>. For efficiency, we utilize bipartite graph matching to quantify ACFG similarity. Although other approaches such as MCS (Maximum Common Subgraph) matching <ref type="bibr" target="#b13">[14]</ref> may also be applied to this problem, efficiency is still a major concern. The primary limitation of bipartite graph matching is that it is agnostic to the graph structure, and the accumulation of errors could result in less accurate results. To address the issue, we have appended structural features, described in Section 3, to allow bipartite graph matching to incorporate some graph structural information. Experiments in Section 5. <ref type="bibr" target="#b4">4</ref> show that these structural features boost the accuracy of bipartite graph matching in our problem.</p><p>Essentially, bipartite graph matching utilizes the match cost of two graphs to compute the similarity. It quantifies the match cost of two graphs by modeling it as an optimization process. Given two ACFGs, G1 and G2, the bipartite graph matching will combine two ACFGs as a bipartite graph</p><formula xml:id="formula_0">G bp = ( V , Ê), where V = V (G1) ∪ V (G2), Ê = { êk = (vi, vj)|vi ∈ V (G1) ∧ vj ∈ V (G2)}</formula><p>, and edge êk = (vi, vj) indicates a match from v1 to v2. Each match is associated with a cost. The minimum cost of two graphs is the sum of all edges cost on the mapping. Bipartite graph matching can go over all mappings efficiently, and select the one-to-one mapping on nodes from G1 to G2 of the minimum cost.</p><p>In our problem, a node in the bipartite graph is a basic block on the ACFG. The edge cost is calculated by the distance between the two basic blocks on that edge. Each basic block on the ACFG has a feature vector discussed in Section 3. Therefore, we calculate the distance between two basic blocks by cost(v, v) =</p><formula xml:id="formula_1">i α i |a i -â i | i α i max(a i ,â i ) .</formula><p>It is the same distance metric used in the paper <ref type="bibr" target="#b22">[23]</ref> to quantify the distance of two basic blocks. ai and âi are the i-th feature in feature vectors of two basic block v and v respectively. If the feature is a constant, |ai -âi| is their difference. If the feature is a set, we use Jaccard to calculate the set difference. αi is the corresponding weight of the feature which will be discussed below.</p><p>The output of bipartite graph matching is the minimum cost of two graphs. Normally the match cost of two graphs is greater than one, and positively correlated to the size of compared ACFGs. Therefore, we normalize the cost to compute the similarity score. For cost normalization, we create an empty ACFG Φ for each compared ACFG. Each node in the empty graph has an empty feature vector, and the size of the empty graph is set to that of the corresponding compared graph. By comparing with this empty ACFG, we can obtain the maximum matching cost the compared graph can produce. We compute the matching cost with the empty graph for the two graphs, and select the maximum matching cost as the denominator, and use it to normalize the matching cost of two graphs. Suppose cost(gi, gj) represents the cost of the best bipartite matching between two graphs g1, g2, the ACFG similarity between two graphs can be formally represented as following:</p><formula xml:id="formula_2">κ(g1, g2) = 1 - cost(g1, g2) max(cost(g1, Φ), cost(Φ, g2)) ,<label>(1)</label></formula><p>We found that the features in Table <ref type="table" target="#tab_0">1</ref> have different importance in computing graph similarity. We learn weights of the raw features to capture the latent similarity between two ACFGs. Basically, the learning objective is to find weight parameters that can maximize the distance of different ACFGs while simultaneously minimizing the distance of equivalent ACFGs. To approach this optimization problem, we adopt the approach used in Eschweile et al <ref type="bibr" target="#b22">[23]</ref>. More specifically, we use a genetic algorithm using GALib <ref type="bibr" target="#b55">[56]</ref>. We also execute an arithmetic crossover using a Gaussian mutator 100 times. The learned weights for each feature are listed in Table <ref type="table" target="#tab_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Clustering</head><p>After defining the similarity metric for the ACFG, the next step is to generate a codebook using the unsupervised learning method. This process can be regarded as a clustering process over a collection of raw features: ACFGs, where each cluster comprises a number of similar ACFGs.</p><p>In this paper, we use spectral clustering <ref type="bibr" target="#b42">[43]</ref> as the unsupervised learning algorithm to generate the codebook. Formally, the spectral clustering algorithm partitions the training set of ACFGs into n sets S = {S1, S2, . . . , Sn} so as to minimize the sum of the distance of every ACFG to its cluster center. ci ∈ C is the centroid for the subset Si. We define the centroid node as the ACFG that has the minimum distance to all the other ACFGs in Si, and the collection of all centroid nodes constitutes a code book.</p><p>Unlike traditional clustering algorithms, in which the inputs are numerical vectors, in this paper we propose to use a kernelized spectral clustering where the input is a kernel matrix. The similarity computed in Section 3 can be used to generate the kernel matrix for the spectral clustering. Suppose the kernel matrix is M, and each entry in M is a similarity score of two corresponding ACFGs. The kernelized clustering works on M and outputs the optimal partitions (clusters) of ACFGs in the training data.</p><p>The codebook size n would affect the bug search accuracy. To this end, we systematically study a suitable n in the bug search in Section 5 and demonstrate that n = 16 seems to be a reasonable codebook size trading off efficiency and accuracy.</p><p>In order to reduce computational cost in constructing the codebook, a common strategy is to randomly sample a training set from the entire dataset. We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architectures. See Section 5.2. Then split ACFGs into separate "strata" with different size ranges. Each stratum is then sampled as an independent sub-population, out of which individual ACFGs are randomly selected. This is a commonly used approach known as stratified sampling <ref type="bibr" target="#b49">[50]</ref>.</p><p>The codebook generation is expensive. However, since the codebook generation is an offline and one-time effort, it will not detrimentally impact the runtime for the online searches. Besides, some approaches can be used to expedite this process, such as the par-allelled clustering approximate clustering <ref type="bibr" target="#b11">[12]</ref> or the hierarchical clustering algorithm <ref type="bibr" target="#b39">[40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Feature Encoding</head><p>Given a learned codebook, feature encoding is to map raw features of a function into a higher-level numeric vector, each dimension of which is the similarity distance to a categorization in the codebook. This step is known as feature encoding <ref type="bibr" target="#b15">[16]</ref>.</p><p>There are two notable benefits for feature encoding. First, the higher-level feature can better tolerate the variation of a function across different architectures, as each of its dimensions is the similarity relationship to a categorization which is less sensitive to the variation of a binary function than the ACFG itself. This property has been demonstrated by many practices in the image search to reduce the noises from the scale, viewpoint and lighting. We further demonstrate it in the bug search scenario in Section 5.3. Second, the ACFG raw features after encoding becomes a point in the high dimensional space which can be conveniently indexed and searched by existing hashing methods. Therefore, the encoding enables a faster real-time bug-search system. See Section 5.5.</p><p>Formally, the feature encoding is to learn a quantizer q : G → R n over the codebook C = {c1, ..., cn}, where G is the set of all ACFG graphs following Definition 1, and R n represents the ndimensional real space. In this paper, we discuss two approaches to derive q. For a given graph gi, let N N (gi) represent the nearest centroid neighbors in the codebook:</p><formula xml:id="formula_3">N N (gi) = arg max c j ∈C κ(gi, cj)<label>(2)</label></formula><p>where κ is defined in Eq. ( <ref type="formula" target="#formula_4">3</ref>). A common practice in image retrieval is to consider not only the nearest neighbor but a few nearest neighbors, e.g. 10 nearest neighbors <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b58">59]</ref>. Bag-of-feature encoding. The bag-of-feature encoding, which maps a graph to some centroids in the codebook, represents each function as a bag of features. The bag-of-feature quantizer can be defined as:</p><formula xml:id="formula_4">q(gi) = g i :N N (g i )=c j [1(1 = j), . . . , 1(n = j)] T ,<label>(3)</label></formula><p>where 1(•) is an indicator function which equals 1 when • is true and 0 otherwise. Eq. ( <ref type="formula" target="#formula_4">3</ref>) indicates that the output encoded feature will add 1 to the corresponding dimension of the nearest centroid. This representation is inspired by the bag-of-words model used in text retrieval <ref type="bibr" target="#b37">[38]</ref>, where each document is represented by a collection of terms in the English vocabulary. In analogy, in our problem, each function is represented by a collection of representative graphs in the learned codebook. After encoding each function becomes a point in the high dimensional vector space. VLAD encoding. The drawback of the bag-of-word model is that the distance between a given graph and a centroid is completely ignored as long as the centroid is the graph's nearest neighbors. The VALD <ref type="bibr" target="#b9">[10]</ref> encoding was proposed to incorporate the first-order differences and assigns a graph to a single mixture component.</p><formula xml:id="formula_5">q(gi) = g i :N N (g i )=c j [1(1 = j)κ(gi, c1), ..., 1(n = j)κ(gi, cn)] T ,<label>(4)</label></formula><p>Compared to Eq. (3), Eq. ( <ref type="formula" target="#formula_5">4</ref>) adds the similarity information to the centroids in the encoded features. Note as our raw features are graphs, in Eq. ( <ref type="formula" target="#formula_5">4</ref>) we use the kernelized similarity function in the VALD encoding which is different from the traditional VALD defined for image retrieval. In VALD encoding, a dimension represents the similarity to a corresponding ACFG centroid in the code-book. As a result, the vector is of latent semantic meaning that reflects a similarity distribution across all centroids in the learned codebook. Empirically we found that VLAD encoding performs better than the bag-of-feature encoding for bug search. We will walk the encoding algorithm in a toy example in Fig. <ref type="figure" target="#fig_1">3</ref>. Given ACFGs for three functions F1_x86, F1_mips and F2_mips, where the first two are the same function compiled from different architectures, and the last one is a completely different function. The compiler used for F1_mips merges the basic block 4 and 5 into the single node 8, so the ACFG of function F1 in MIPS is different from that in x86, due to the instruction reordering. F2_mips shares partial code with function F1_mips. For example, they both check some environment conditions and directly return if it fails.</p><p>For clarity, the similarity metric between ACFGs used in Fig. <ref type="figure" target="#fig_1">3</ref> adopts maximum common subgraph matching. For example, the similarity score between F1_x86 and F1_mips is 5/7 where 5 means the maximum common subgraph, and 7 means the maximum size between two graphs.</p><p>The pair-wise match will match two functions directly by their ACFGs, whereas Genius will match them by their encoded vectors. VLAD encoding generates the encoded vector by comparing a ACFG to its top 3 closest centroid nodes in the codebook in Fig. <ref type="figure" target="#fig_1">3b</ref>). Different from BOF model, it will store the similarity score to each centroid node into the corresponding dimension in the vector. The resulting feature vector is shown in Fig. <ref type="figure" target="#fig_1">3d</ref>) (bottomright corner). Fig. <ref type="figure" target="#fig_1">3d</ref>) also lists match results for both pair-wise match and Genius. The distance metrics used by Genius will be discussed in Section 4.3. We can see that the pair-wise graph match fails to match F1_x86 to F1_mips, since it matches two functions locally. On the contrary, Genius can still match these two functions with high similarity score, as the encoded feature vector is more invariant to local changes on an ACFG. Note, this toy example is only for illustration and we will substantiate our hypothesis by extensive experiments on real-world datasets in Section 5.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Online Search</head><p>The encoded features generated in Section 4.2 may be directly used in search. However, this straightforward solution may not be scalable for millions of functions in real-world applications. This section introduces a scalable solution by LSH (Locality-sensitive hashing) to scale the search. In this paper, we utilize LSH as opposed to other indexing methods such as k-d tree, as the k-d tree may not be suitable for our problem due to its inefficiency in highdimensional spaces especially when the codebook is large <ref type="bibr" target="#b56">[57]</ref>.</p><p>Given a query function, we first derive its encoded feature by Eq. ( <ref type="formula" target="#formula_4">3</ref>) and ( <ref type="formula" target="#formula_5">4</ref>), then we are interested in finding the function in a large dataset that are closest to the query with a high probability. LSH achieves this goal by learning a projection so that if two points are closer together in the feature encoding space, they should remain close after the projection in the hashing space. Following <ref type="bibr" target="#b53">[54]</ref>, given the encoded feature q(g), we employ the projection functions hi defined as:</p><formula xml:id="formula_6">hi(q(g)) = (v • q(g) + b)/w ,</formula><p>(5) where w is the number of quantized bin, v is a randomly selected vector from a Gaussian distribution, and b is a random variable sampled from a uniform distribution between 0 and w. In addition, • is he floor operator. Essentially, a hashing function defines a hyper-plane to project the input encoded features. For any functions q(gi), q(gj) ∈ R n that are close to each other in the encoding space, there is a high probability P [h(q(gi)) = h(q(gj))] = p1 that they fall into the same bucket. Likewise, for any functions that are far apart, there is a low probability p2(p2 &lt; p1) that they fall into the same bucket.</p><p>The locality sensitive hash of an encoded feature q(g) as lsh(g) = [h1(q(g)), .., hw(q(g))] where w is the number of hash functions. After LSH, a function is projected as a point in the hashing space. We experiment on two classical distance metrics defined in the hashing space: Euclidean distance and the cosine distance <ref type="bibr" target="#b46">[47]</ref> in our bug search problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL EVALUATION</head><p>In this section, we empirically evaluate Genius with respect to accuracy, efficiency, and scalability. First, we briefly describe the experiment setup and the data sets used in our evaluation (Sections 5.1 and 5.2). Second, we conduct a systematic baseline comparison against the existing bug search methods in terms of the accuracy and efficiency in the cross-platform setting (Section 5.3). Third, we evaluate Genius on 33,045 firmware images and demonstrate its scalability (Section 5.5). Finally, we present two case studies that demonstrate how we would expect a user to employ Genius under realistic conditions (Section 5.6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experiment Setup</head><p>We wrote the plugin to the disassembler tool IDA Pro <ref type="bibr" target="#b27">[28]</ref> for ACFG extraction. We implemented codebook generation, feature encoding in python, and adopted Nearpy <ref type="bibr" target="#b5">[6]</ref> for LSH hashing and search. We utilized MongoDB [5] to store the firmware images and encoded features. Our experiments were conducted on a server with 65 GB memory, 24 cores at 2.8 GHz and 2 TB hard drives. All the evaluations were conducted based on four types of datasets: 1) baseline evaluation dataset; 2) two public firmware images; 3) 33,045 firmware images and 4) the vulnerability dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Data preparation</head><p>Dataset I -Baseline evaluation. This dataset was used for baseline comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1.21 and v1.20), OpenSSL (v1.0.1f and v1.0.1a) and coreutils (v6.5 and v6.7). All programs were compiled for three different architectures (x86, ARM, MIPS; all 32 bit) using three compiler versions (gcc v4.6.2/v4.8.1 and clang v3.0). We also enabled four optimization levels (O0-O3) for each version of a compiler. These settings have been used in existing studies as well <ref type="bibr" target="#b44">[45]</ref>. We kept the symbol names during compilation which allowed us to maintain ground truth for evaluations.</p><p>These different compilation combinations resulted in a dataset of over 568,134 functions. As several of the existing techniques could not scale to a dataset of this size, we randomly sampled 10,000 functions from this dataset as the baseline dataset, and used that for baseline evaluation. Each function in the baseline dataset has at least two instances: one for query and another for search. The remaining functions in Dataset I were used for codebook generation. Dataset II -Public dataset. Recent work such as Pewny et al <ref type="bibr" target="#b44">[45]</ref> and Eschweiler et al <ref type="bibr" target="#b22">[23]</ref> used the same public dataset based upon two publicly-available firmware images for baseline comparison <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. We also evaluated Genius using this dataset to provide for fair comparison with the state-of-the-art systems. Dataset III -Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild. We used it to evaluate the scalability of Genius. The images in this dataset were collected from three sources: 9,000 firmware images from <ref type="bibr" target="#b16">[17]</ref>, the entire dataset from <ref type="bibr" target="#b18">[19]</ref> and 500 randomly selected images from our own crawl of the DDWRT ftp site <ref type="bibr" target="#b2">[2]</ref>. Of the total 33,045 firmware images collected, we successfully unpacked 8,126 images from 26 different vendors. The vendors include such as ATT, Verizon, Linksys, D-Link, Seiki, Polycom, TRENDnet. The product types from each vendor include IP cameras, routers, access points and third-party or open-source firmware. Dataset IV-The vulnerability dataset. This dataset is a mapping between CVE numbers and the corresponding functions that actually introduced the vulnerabilities. To construct a query which can be used by Genius for bug search, we need to find binary code for these vulnerable functions. While other works have already investigated construction of vulnerability databases <ref type="bibr" target="#b43">[44]</ref>, none of them fit our purposes; they cannot extract the binary code for vulnerable functions required by Genius. As a result, we created a freely available vulnerability database for this effort and for the broader research community.</p><p>To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE numbers. We were also able to retrieve information about the software commits to fix the vulnerabilities, which provided us the vulnerable function names and symbols. We then downloaded the source code for the vulnerable versions of the software, compiled the source and extracted the vulnerable functions from the binary code using the symbol names. We then used Genius to generate higher-level features for each vulnerable function. In the end, we utilized Mon-goDB [5] to build the database which stored the vulnerable functions and their corresponding feature vectors for later use. In our evaluation, we were only interested in vulnerabilities related to libraries widely used in firmware devices. We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Cross-Platform Baseline Comparison</head><p>We first evaluated Genius with baseline methods under the cross-platform setting. All evaluations in this subsection were conducted under the baseline dataset in Dataset I and Dataset II. Since each function name has multiple instances in Dataset I, we collected the query set Q by randomly selecting one instance for each function name, and considered the rest of the baseline dataset as a codebase. The codebook of Genius in this part is also trained on Dataset I, and its size is 16 for all baseline evaluations. Evaluation Metrics. We used two metrics to evaluate the accuracy of the proposed and baseline methods: the recall rate (A.K.A true positive rate) and false positive rate. In the code search scenario, the search results are a ranked list. For each query q, there are m matching functions out of a total of L functions. If we consider the top-K retrieved instances as positives, the total number of correctly matched functions, µ, are true positives, and the remaining number of functions in the top K, that is K -µ, are false positives. Based on the definitions of recall and false positive rate, the recall rate is calculated as recall(q) = µ m and the false positive rate is</p><formula xml:id="formula_7">F P R(q) = (K-µ)</formula><p>L-m . Preparation of Baseline Systems. We prepared three representative, state-of-the-art, cross-architecture bug search techniques to establish our evaluation baseline: discovRe <ref type="bibr" target="#b22">[23]</ref>, Multi-MH and Multi-k-MH <ref type="bibr" target="#b44">[45]</ref> and a centroid based search <ref type="bibr" target="#b17">[18]</ref>. Our first task was to prepare versions of these solutions for this evaluation.</p><p>• discovRe <ref type="bibr" target="#b22">[23]</ref>: Due to unavailability of the source code, we reimplemented discovRe<ref type="foot" target="#foot_0">2</ref> and set the iteration limitation to be the same (i.e., 16*max(|G1|, |G2|)) as the one used in their work work. We evaluated Genius against two versions of discovRe: the original version with pre-filtering and the version without pre-filtering. For the pre-filtering version, we set the threshold to 128 as specified in <ref type="bibr" target="#b22">[23]</ref>. The version without pre-filtering uses only their graph matching metric for search. • Multi-MH and Multi-k-MH <ref type="bibr" target="#b44">[45]</ref>: Their source code is not available. Due to the complexity, it was less possible for us to reimplement their approach within a reasonable amount of time. Fortunately, discovRe has already conducted a thorough baseline comparison against these two approaches and published the results. The binaries used for the evaluation are also available online. Hence, we evaluated Genius on the same setting for this baseline comparison, and compared the published numbers on the benchmark. • Centroid <ref type="bibr" target="#b17">[18]</ref>: The centroid-based approach is known for its efficiency with respect to the Android malware clone and repackage problem <ref type="bibr" target="#b17">[18]</ref>. We implemented a centroid-based bug search system for IOT devices. Note that while the centroid method is not directly designed for cross-platform code matching, it is still meaningful to compare it with Genius in terms of efficiency and accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Accuracy comparison.</head><p>To evaluate the efficacy of Genius, we first conducted thorough comparisons with DiscovRe and Centroid on Dataset I, since we have reimplemented these two approaches. We compared with the published results of Multi-MH and Multi-k-MH on Dataset II.</p><p>The first round of evaluations worked on the baseline dataset in Dataset I. We randomly selected 1000 functions as queries to feed into the target approach, and evaluated search results in terms of two metrics. Fig. <ref type="figure" target="#fig_2">4a</ref>) lists the average recall rates for 1,000 queries across different thresholds of K, where the the y-axis indicates the recall for the corresponding K values. We can see that Genius significantly outperforms the baseline methods for every value of K. For example, Genius ranks 27% functions at top 1, whereas discovRe only ranks 0.5%. We also found that the performance of discovRe is worse than the version without pre-filtering. Fig. <ref type="figure" target="#fig_2">4b</ref>) shows the ROC curves for each approach. This was the macroaverage result across 1,000 queries. We can see that the ROC curve of Genius is better than those of the baseline approaches, especially when the false positive rate is small. The results in Fig. <ref type="figure" target="#fig_2">4 (a)</ref> and (b) substantiate that Genius can achieve even better accuracy than the state-of-the-art methods.</p><p>We inspected the search results and found that the superior performance of Genius is mainly because of the salient and robust feature representation learned on top of the ACFGs. As an example, ssl3_get_message was ranked at top 1 by Genius but ranked below 40th by baseline methods because its CFG extracted from the function of X86 and MIPS was changed. Our method managed to capture the change and thus showed better results. We also analyzed the cases where Genius yield worse results than baseline methods. We hypothesize the reason is about the quality of the learned codebook. We will discuss it in Section 5.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Efficiency comparison.</head><p>We conducted efficiency comparison in terms of online search and offline preparation. For online search, we evaluated on both Dataset I and II. For offline preparation efficiency, we evaluated Dataset II as a demonstration.</p><p>Offline Preparation Efficiency. The preparation includes ACFG extraction and feature encoding. Table <ref type="table" target="#tab_2">3</ref> shows the aggregation of preparation time for the phases of Genius on Dataset II. We can see that Genius outperforms Multi-MH and Multi-k-MH. Dis-covRe only considers the control flow graph extraction time, whereas Genius needs extra time to encode these graphs. Even if Genius is slower than DiscovRe at the preparation stage, as the preparation  is an offline stage and only an one-time effort, it is reasonable to sacrifice some preparation time for the online search efficiency.</p><p>Online Search Efficiency. Similar to the accuracy comparison discussed above, we evaluated the online search efficiency on Dataset I and II, respectively. We first conducted the search on Dataset I, searched all of the functions in the dataset and recorded their search times for each target approach. Fig. <ref type="figure" target="#fig_3">5</ref> lists the Cumulative distribution function (CDFs) of search time for the four approaches on Dataset I, where the x-axis plots the search time in seconds. We can see that Genius and the centroid-based approach have least search time. DiscovRe, on the other hand, has the longest search time because it requires expensive online graph matching. In the best case, discovRe takes 10 ms for a query, whereas Genius only requires 0.1 ms to return more accurate results. Unsurprisingly, we also found that the version of discovRe without pre-filtering has even worse performance. It required nearly 2 hours for a single query in the worst case, and was still less accurate than Genius.</p><p>Although the centroid approach had comparable efficiency with Genius, as previously mentioned, centroid significantly underperforms Genius in terms of the accuracy. We also conducted a second round evaluation on Dataset II for all baseline approaches. We utilized the search time for the Heartbleed vulnerability as the metric. Table <ref type="table" target="#tab_1">2</ref> lists the search results. It shows that Genius is orders of magnitude faster than Multi-MH, Multik-MH and discovRE. This demonstrates that Genius outperforms most of the existing methods in terms of efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Parameter Studies</head><p>We systematically studied the parameter's impact on the accuracy of Genius under different settings. The parameters for evaluation included the structural features used in bipartite graph match-ing, the codebook size, the size of training data for codebook generation, and the feature encoding methods. All evaluation settings were conducted on Dataset I. A. Distance metrics and structural features. To verify the contribution of the proposed structural features, we conducted bipartite graph matching experiments with and without structural features. As shown in Fig. <ref type="figure" target="#fig_4">6a</ref>), the matching with structural features outperforms the matching without it. Besides, we also evaluated two distance metrics used in the LSH. Results show that the cosine distance performs better than the Euclidean distance. B. Codebook sizes. We created codebooks of different sizes and studies their search accuracy. We evaluated the accuracy in terms of the recall rate at two representative false positive rates. Fig. <ref type="figure" target="#fig_4">6b</ref>) illustrates the results for the codebooks of 16, 32, 64, and 128 centroids. We can see that the codebook size seems not having a significant influence on the accuracy of Genius. This result provides an insight that allow us to reduce codebook preparation time by using a smaller codebook n = 16. C. Training data sizes. Another important parameter is the size of training set used to generate codebook. We selected training data samples of different sizes to generate the codebook for search. Fig. <ref type="figure" target="#fig_4">6c</ref>) shows their search results. We can see that the more samples used for training, the better Genius performed, but the increase in accuracy becomes saturated when the training data is sufficiently large, in our case up to 100 thousand functions. This is consistent with observations from image retrieval methods. D. Feature encoding methods. We discussed two feature encoding methods in Section 4.2: bag-of-feature and VLAD encoding. We compared their impacts on the search accuracy while fixing other parameters. Fig. <ref type="figure" target="#fig_4">6d</ref>) illustrates the ROC curves using two encoding methods. As we can see, VALD performs better than Bag-of-Feature encoding. This observation suggests considering the first-order statistics is beneficial for bug search problem. As the computational cost is similar between VALD and bag-of-features, we recommend using VALD feature encoding in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Bug Search at Scale</head><p>We evaluated the scalability of Genius on Dataset III, which consists of 8,126 firmware images containing 420,336,846 functions, in terms of the preparation phase and search phase. We investigated the time consumption for each stage to demonstrate that Genius is capable of handling firmware images at a large scale.</p><p>We encoded 1 million functions randomly selected from Dataset III and collected the preparation time for each of them   <ref type="figure">10a</ref>) demonstrates the Cumulative Distribution Function (CDF) of time consumption for randomly selected 1 million query functions. We can see that nearly 90% of the functions were encoded in less than 0.1 seconds. Additionally, less than 10% of the functions needed more than 4 seconds to encode. This is because these functions have more than 1000 basic blocks, and thus take longer to encode. The prepartion time across different sizes of ACGFs is illustrated in Fig. <ref type="figure">10b</ref>).</p><p>We further evaluated the search time for Genius in the large scale codebase. We partitioned Dataset III into six codebases of different scales from s = 10 3 to s = 10 8 , where s is the total number of functions in the codebase. Genius was tested against 1 to 10,000 sequentially submitted queries. Fig. <ref type="figure">10c</ref>) shows the loglog plot of the time consumption for Genius at the online search phase. As we can see, the search time grows sublinearly according to the increase of the codebase size, and the average search time over observed was less than 1 second for a firmware codebase of about 100 million functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Case Studies</head><p>We also evaluated the efficacy of Genius in real bug search scenarios. Case studies were conducted on Genius for the two use scenarios discussed in Section 2. With the aid of case studies, we demonstrated how Genius would work in the real world to facilitate the vulnerability identification process.</p><p>Scenario I. In this scenario, we conducted a vulnerability search on Dataset III of 8,126 images using vulnerability queries extracted from Dataset IV. We performed a comprehensive search for two vulnerabilities (CVE-2015-1791 and CVE-2014-3508), which took less than 3 seconds. We then manually verified the vulnerability authenticity for the returned candidate functions. We disassembled the binary code for each candidate, and looked into their seman-tics to check whether they were patched or not. Due to the workload of manual analysis, we only verified the top 50 candidates for the two selected vulnerabilities. We found 38 potentially vulnerable firmware devices across 5 vendors, and confirmed that 23 were actually vulnerable. We also contacted these product vendors for further confirmation. The following gives the detailed discussion about search results. CVE-2015-1791. This vulnerability allows remote attackers to cause a denial of service (double free and application crash) on the device. In the top 50 candidates, we found that there were 14 firmware images potentially affected by this vulnerability. We were able to confirm that 10 of these images were actually vulnerable. These images were from two vendors: D-LINK and Belkin. CVE-2014-3508. This vulnerability allows context-dependent attackers to obtain sensitive information from process stack memory by reading the output of sensitive functions. We found that there were 24 firmware images which could have this vulnerability, and we were able to confirm that the vulnerabilities existed in 13 images from three vendors. These vendors included CenturyLink, D-Link and Actiontec.</p><p>This clearly demonstrated that a security evaluator, after only 3 seconds, could get a list of candidate functions to prioritize their search for vulnerable device firmware.</p><p>Scenario II. We chose the two latest commercial firmware images from D-Link DIR-810 model as our evaluation targets. We built the LSH indexes for these two firmware images and then searched those two images for all 185 vulnerabilities from Dataset IV (discussed in Section 5.2). It took less than 0.1 second on average to finish searching for all 154 vulnerabilities. We conducted manual verification at the top 100 candidates for each vulnerability and found 103 potential vulnerabilities in total for two images, 16 of     <ref type="table" target="#tab_4">4</ref>). We contacted the product vendor for further confirmation. Overall, these two case studies substantiate that Genius is an effective tool to facilitate IoT firmware bug searching process for security evaluators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION</head><p>While we have demonstrated the efficacy of Genius for accurate, scalable bug search in IoT devices, there are several relevant technical limitations. Our method utilizes static analysis to extract syntactical features, and thus cannot handle obfuscated code which is used to avoid similarity detection (e.g., malware).</p><p>Additionally, the accuracy of Genius heavily relies on the quality of CFG extraction. Although IDA pro <ref type="bibr" target="#b27">[28]</ref> provides us reasonable accuracy in our evaluation, we can rely on more advanced techniques to further improve its accuracy such as <ref type="bibr" target="#b50">[51]</ref>.</p><p>Furthermore, the accuracy of Genius could be impacted by function inlining, since it may change the CFG structures. Since our main focus in this paper is to improve the scalability of existing in-depth bug search, we will leave the evaluation of Genius for this case as future work.</p><p>Like other CFG-based code search approaches, the accuracy of Genius is also affected by the size of the CFG. The smaller the size of CFG is, the more likely it is to have collisions. To be aligned with other work <ref type="bibr" target="#b22">[23]</ref>, we also considered functions with at least five basic blocks. We believe that this is a reasonable assumption since small functions have significantly lower chance to contain vulnerabilities in a real-world scenario <ref type="bibr" target="#b36">[37]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>We have discussed closely related work throughout the paper. In this section, we briefly survey additional related work. We focus on approaches using code similarity to search for known bugs. There are many other approaches that aim at finding unknown bugs, such as fuzzing or symbolic execution <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b51">52,</ref><ref type="bibr" target="#b54">55]</ref> etc. Since they are orthogonal to our approach, we will not discuss these approaches in this section.</p><p>Source-Level Bug Search. Many works focused on finding code clones at the source code level. For example, <ref type="bibr" target="#b57">[58]</ref> generates a code property graph from the source code and conducts a graph query to search for code clones with the same pattern. Similarly, tokenbased approaches such as CCFinder <ref type="bibr" target="#b32">[33]</ref> and CP-Miner <ref type="bibr" target="#b34">[35]</ref> utilize token sequence and scan for duplicate token sequences in other source code. DECKARD <ref type="bibr" target="#b17">[18]</ref> generates numerical vectors based upon abstract syntax trees and conducts code similarity matching for code clone detection. ReDeBug <ref type="bibr" target="#b28">[29]</ref> provides an efficient and scalable search to find unpatched code clones in OS-distribution bases. All of these approaches require source code, and cannot find bugs in firmware images unless the source code is available.</p><p>Binary-Level Bug Search. Since we do not always have access to firmware source code, bug search techniques that work on binary code are very important. One common issue with the current approaches is that they only support a single architecture. It is common that bugs from firmware images in x86 can appear in images of another architecture such as MIPS or ARM, so finding bugs in firmware images demands the capability to handle binary code in a cross-architecture setting.</p><p>For example, the tracelet-based approach <ref type="bibr" target="#b19">[20]</ref> captures execution sequences as features for code similarity checking, which can defeat the CFG changes. However, the opcode and register names are different across architectures, so it is not suitable for finding bugs in firmware images cross architectures. Myles et al. <ref type="bibr" target="#b40">[41]</ref> uses kgrams on opcodes as a software birthmark technique. TEDEM <ref type="bibr" target="#b45">[46]</ref> captures semantics using the expression tree of a basic block. The opcode difference on different architectures will easily defeat these two approaches. Rendezvous <ref type="bibr" target="#b33">[34]</ref> first explored the code search in binary code. However, it has two limitations. It relies on ngram features to improve the search accuracy. Secondly, it decomposes the whole CFG of a function into subgraphs. Our evaluation demonstrates that two CFGs as a whole by graph matching is much more accurate than comparing their subgraphs since one edge addition will introduce great difference on the number of subgraphs for two equal CFGs. Therefore, subgraph decomposition will reduce the search accuracy. Finally, as with the other approaches described thus far, it is designed for a single architecture. Control flow graph (CFG)-based bug searching is a prevalent approach for finding bugs in firmware images. However, most existing works focus on how to improve the matching accuracy by selecting different features or matching algorithms. Flake et al. <ref type="bibr" target="#b24">[25]</ref> proposed to match CFGs of a function to defeat some compiler optimizations such as instruction reordering and changes in register allocation. However, the approach relies upon exact graph matching which is too expensive to be applied for large scale bug search. Pewny et al. <ref type="bibr" target="#b44">[45]</ref> use I/O pairs to capture semantics at the basicblock level for code similarity computation. It is still expensive for feature extraction and graph matching. DiscovRe <ref type="bibr" target="#b22">[23]</ref> utilizes the pre-filtering to facilitate CFG based matching, but our evaluation demonstrates that the pre-filtering is unreliable and outputs tremendous false negatives. Zynamics BinDiff <ref type="bibr" target="#b20">[21]</ref> and BinSlayer <ref type="bibr" target="#b12">[13]</ref> use a similarity metric based on the isomorphism between control flow graphs to check similarity of two binaries. They are not designed for bug search, especially for finding bug doublets across different binaries where the CFGs of two binaries are totally different. Besides, BinHunt <ref type="bibr" target="#b25">[26]</ref> and iBinHunt <ref type="bibr" target="#b38">[39]</ref> utilize symbolic execution and a theorem prover to check semantic equivalence between basic blocks. These two approaches are expensive and cannot be applied for large scale firmware bug search since they need to conduct binary analysis to extract the equations and conduct the equivalence checking.</p><p>The field of automatic large-scale firmware analysis has also made a breakthrough. Costin et al. <ref type="bibr" target="#b18">[19]</ref> carried out an analysis of over 30,000 firmware samples, but it does not perform in-depth analysis. Instead, it extracts each firmware sample and investigates it for artifacts such as private encryption keys. Therefore, this approach is not suitable for finding more general vulnerabilities without these obvious artifacts.</p><p>Dynamic analysis based bug search in firmware images. Blanketexecution <ref type="bibr" target="#b21">[22]</ref> uses the dynamic run-time environment of the program as features to conduct the code search. This approach can defeat the CFG changes, but it is only evaluated in a single architecture. Besides, dynamic analysis to support firmware images is at the initial stage <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b60">61]</ref>, and still has not been demonstrated its effectiveness with respect to the run-time environments of programs for large scale firmware images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>In this paper, inspired by the image retrieval approaches, we proposed a numeric-feature based search technique to address the scalability issues in existing in-depth IoT bug search approaches. We proposed methods to learn higher-level features from the raw features (control flow graphs), and performed search based upon the learned feature vector rather than directly performing pair-wise matching. We have implemented a bug search system (Genius), and compared Genius with the state-of-the-art bug search approaches. The extensive experimental results show that Genius can achieve even better accuracy than the state-of-the-art methods, and is orders of magnitude faster than most of the existing methods. To further demonstrate the scalability, Genius was evaluated on 8,126 devices of 420 million functions across three architectures and 26 vendors. The experiments show that Genius can finish a query less than 1 second on average.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: The approach overview</figDesc><graphic coords="3,87.59,52.44,435.52,112.27" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A toy example on VALD feature encoding. Features on each basic block of ACFG are simplified into a single constant value. The match cost of two basic blocks with the same value is zero, otherwise 1.We will walk the encoding algorithm in a toy example in Fig.3. Given ACFGs for three functions F1_x86, F1_mips and F2_mips, where the first two are the same function compiled from different architectures, and the last one is a completely different function. The compiler used for F1_mips merges the basic block 4 and 5 into the single node 8, so the ACFG of function F1 in MIPS is different from that in x86, due to the instruction reordering. F2_mips shares partial code with function F1_mips. For example, they both check some environment conditions and directly return if it fails.For clarity, the similarity metric between ACFGs used in Fig.3adopts maximum common subgraph matching. For example, the similarity score between F1_x86 and F1_mips is 5/7 where 5 means the maximum common subgraph, and 7 means the maximum size between two graphs.The pair-wise match will match two functions directly by their ACFGs, whereas Genius will match them by their encoded vectors. VLAD encoding generates the encoded vector by comparing a ACFG to its top 3 closest centroid nodes in the codebook in Fig.3b). Different from BOF model, it will store the similarity score to each centroid node into the corresponding dimension in the vector. The resulting feature vector is shown in Fig.3d) (bottomright corner). Fig.3d) also lists match results for both pair-wise match and Genius. The distance metrics used by Genius will be discussed in Section 4.3. We can see that the pair-wise graph match fails to match F1_x86 to F1_mips, since it matches two functions locally. On the contrary, Genius can still match these two functions with high similarity score, as the encoded feature vector is more invariant to local changes on an ACFG. Note, this toy example is only for illustration and we will substantiate our hypothesis by extensive experiments on real-world datasets in Section 5.3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Baseline comparison for accuracy on Dataset I. K means that we consider retrieved candidates on top K as positives Two figures share the same legends.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The CDFs of search time on Dataset I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Accuracy comparison with different parameter settings. a), c) and d) are ROC curves encoding time. Fig.10a) demonstrates the Cumulative Distribution Function (CDF) of time consumption for randomly selected 1 million query functions. We can see that nearly 90% of the functions were encoded in less than 0.1 seconds. Additionally, less than 10% of the functions needed more than 4 seconds to encode. This is because these functions have more than 1000 basic blocks, and thus take longer to encode. The prepartion time across different sizes of ACGFs is illustrated in Fig.10b).We further evaluated the search time for Genius in the large scale codebase. We partitioned Dataset III into six codebases of different scales from s = 10 3 to s = 10 8 , where s is the total number of functions in the codebase. Genius was tested against 1 to 10,000 sequentially submitted queries. Fig.10c) shows the loglog plot of the time consumption for Genius at the online search phase. As we can see, the search time grows sublinearly according to the increase of the codebase size, and the average search time over observed was less than 1 second for a firmware codebase of about 100 million functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>Figure 7: The CDF of preparation time over#1 million functions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>Figure 9: The search time crossscales of fimware codebases(# of funcitons</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Basic-block level features used in Genius.</figDesc><table><row><cell>Type</cell><cell>Feature Name</cell><cell>Weight (α)</cell></row><row><cell></cell><cell>String Constants</cell><cell>10.82</cell></row><row><cell></cell><cell>Numeric Constants</cell><cell>14.47</cell></row><row><cell>Statistical Features</cell><cell>No. of Transfer Instructions No. of Calls</cell><cell>6.54 66.22</cell></row><row><cell></cell><cell>No. of Instructions</cell><cell>41.37</cell></row><row><cell></cell><cell cols="2">No. of Arithmetic Instructions 55.65</cell></row><row><cell>Structural Features</cell><cell>No. of offspring Betweeness</cell><cell>198.67 30.66</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Comparison with Multi-MH and Multi-k-MH, discovRE, Centroid with the propose method for OpenSSL. Each cell contains the rank, separated by the colon, for both vulnerable functions: heartbeat for TLS and DTLS.</figDesc><table><row><cell></cell><cell cols="6">Multi-MHTLS [45] Multi-k-MH [45] discovRE [23]</cell><cell cols="2">Genius</cell><cell cols="2">Centroid [18]</cell></row><row><cell>From -&gt;To</cell><cell>TLS</cell><cell>DTLS</cell><cell cols="2">TLS DTLS</cell><cell cols="5">TLS DTLS TLS DTLS TLS</cell><cell>DTLS</cell></row><row><cell>MIPS → DD-WRT</cell><cell>1:2</cell><cell>2:4</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>46:100</cell><cell>87:99</cell></row><row><cell>MIPS → ReadyNAS</cell><cell>1:2</cell><cell>6:16</cell><cell>1:2</cell><cell>1:4</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>88:190</cell><cell>678:988</cell></row><row><cell>x86 → DD-WRT</cell><cell cols="2">70:78 1:2</cell><cell cols="2">5:33 1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>97:255</cell><cell>102:89</cell></row><row><cell>x86 → ReadyNAS</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell>1:2</cell><cell cols="2">145:238 333:127</cell></row><row><cell>Query Normalized Avg. Time</cell><cell></cell><cell>0.3s</cell><cell></cell><cell>1 s</cell><cell cols="2">4.1 × 10 -4 s</cell><cell cols="2">1.8 × 10 -6 s</cell><cell cols="2">1.4 × 10 -6 s</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Baseline comparison on preparation time.</figDesc><table><row><cell>Preparation Time in Minutes</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>. The preparation time included the control flow graph extraction and graph</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.9</cell><cell></cell><cell></cell><cell></cell></row><row><cell>True positive rate</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>C</cell><cell></cell><cell>n</cell><cell>Recall</cell><cell>0.75 0.85 0.8</cell><cell></cell><cell cols="3">Recall@FPR(0.075) Recall@FPR(0.110)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.7</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.65</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>16</cell><cell>32</cell><cell>64</cell><cell></cell><cell>128</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">False postive rate</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Codebook Size</cell><cell></cell></row><row><cell></cell><cell cols="9">(a) Distance metrics and structural features</cell><cell></cell><cell></cell><cell cols="2">(b) Codebook sizes</cell><cell></cell></row><row><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.8</cell><cell></cell><cell></cell><cell></cell></row><row><cell>True Positive Rate</cell><cell cols="2">0.4 0.6</cell><cell></cell><cell></cell><cell></cell><cell cols="4">Training Set 4K</cell><cell>True Positive Rate</cell><cell>0.4 0.6</cell><cell></cell><cell cols="2">VALD Encoding</cell></row><row><cell></cell><cell cols="2">0.2</cell><cell></cell><cell></cell><cell></cell><cell cols="4">Training Set 20K</cell><cell></cell><cell>0.2</cell><cell></cell><cell cols="3">Bag-of-Feature Encoding</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">Training Set 100K</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>0</cell><cell>0.1</cell><cell>0.2</cell><cell>0.3</cell><cell>0.4 Flase Positive Rate 0.5 0.6</cell><cell>0.7</cell><cell>0.8</cell><cell>0.9</cell><cell>1</cell><cell>0 0</cell><cell>0.2</cell><cell>0.4 False Positive Rate 0.6</cell><cell>0.8</cell><cell>1</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">(c) Training set size</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">(d) Feature encoding</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 :</head><label>4</label><figDesc>Case study results for Scenario II</figDesc><table><row><cell></cell><cell cols="2">DIR-810L_REVB_FIRMWARE_2.03B02</cell><cell></cell><cell cols="2">DIR-810L_REVB_FIRMWARE_2.02.B01</cell></row><row><cell>CVE</cell><cell cols="2">Patched Vulnerability Type</cell><cell>CVE</cell><cell cols="2">Patched Vulnerability Type</cell></row><row><cell cols="2">CVE-2016-0703 No</cell><cell cols="3">Allows man-in-the-middle attack CVE-2015-0206 No</cell><cell>Memory consumption</cell></row><row><cell cols="2">CVE-2015-1790 No</cell><cell>NULL pointer dereference</cell><cell cols="2">CVE-2014-0160 Yes</cell><cell>Heartbleed</cell></row><row><cell cols="2">CVE-2015-1791 Yes</cell><cell>Double free</cell><cell cols="2">CVE-2015-0289 No</cell><cell>NULL pointer dereference</cell></row><row><cell cols="2">CVE-2015-0289 No</cell><cell>NULL pointer dereference</cell><cell cols="2">CVE-2016-0797 No</cell><cell>Heap memory corruption</cell></row><row><cell cols="2">CVE-2014-8275 No</cell><cell>Missing sanitation check</cell><cell cols="2">CVE-2016-0798 No</cell><cell>Memory consumption</cell></row><row><cell cols="2">CVE-2015-0209 No</cell><cell>Use-after-free</cell><cell cols="2">CVE-2014-3513 No</cell><cell>Memory consumption</cell></row><row><cell cols="2">CVE-2015-3195 No</cell><cell>Mishandles errors</cell><cell cols="2">CVE-2014-3508 No</cell><cell>Information leakage</cell></row><row><cell>#</cell><cell>#</cell><cell>#</cell><cell cols="2">CVE-2015-0206 No</cell><cell>Memory consumption</cell></row><row><cell>#</cell><cell>#</cell><cell>#</cell><cell cols="2">CVE-2014-8275 No</cell><cell>Missing sanitation check</cell></row><row><cell cols="2">which were confirmed (see Table</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>We contacted the author of discovRe for comparison by providing their search results, but they have not provided us results yet.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>We would like to thank anonymous reviewers for their feedback. This research was supported in part by National Science Foundation Grant #1054605, Air Force Research Lab Grant #FA8750-15-2-0106, and DARPA CGC Grant #FA8750-14-C-0118. Any opinions, findings, and conclusions in this paper are those of the authors and do not necessarily reflect the views of the funding agencies.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.ey.com/Publication/vwLUAssets/EY-cybersecurity-and-the-internet-of-things.pdf" />
		<title level="m">Cybersecurity and the Internet of Things</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ddwrt Ftp</surname></persName>
		</author>
		<ptr target="http://download1.dd-wrt.com/dd-wrtv2/downloads/others/eko/BrainSlayer-V24" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://www.cyactive.com/industrial-utilities-devices-cyber-threat-lurks/" />
		<title level="m">Industrial Utilities and Devices Where the Cyber Threat Lurks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://www.federaltimes.com/story/government/solutions-ideas/2016/04/08/internet-things-when-cyberattacks-have\discretionary{-}{}{}physical-effects/82787430/" />
		<title level="m">Iot when cyberattacks have physical effects</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><surname>Nearpy</surname></persName>
		</author>
		<ptr target="https://pypi.python.org/pypi/NearPy" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><surname>Dd-Wrt</surname></persName>
		</author>
		<ptr target="ftp://ftp.dd-wrt.com/others/eko/BrainSlayer-V24-preSP2/2013/05-27-2013-r21676/senao-eoc5610/linux.bin" />
		<title level="m">Firmware Image r21676</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
		<ptr target="http://www.downloads.netgear.com/files/GDC/READYNAS-100/ReadyNASOS-6.1.6-arm.zip" />
	</analytic>
	<monogr>
		<title level="j">ReadyNAS Firmware Image v</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Near-optimal hashing algorithms for approximate nearest neighbor in high dimensions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Andoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM Commun</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">All about vlad</title>
		<author>
			<persName><forename type="first">R</forename><surname>Arandjelovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1578" to="1585" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic exploit generation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="74" to="84" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Approximate clustering without the approximation</title>
		<author>
			<persName><forename type="first">M.-F</forename><surname>Balcan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twentieth Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>the twentieth Annual ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1068" to="1077" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Binslayer: accurate comparison of binary executables</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bourquin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Robbins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop</title>
		<meeting>the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A graph distance metric based on the maximal common subgraph</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bunke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shearer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern recognition letters</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="255" to="259" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Program-adaptive mutational fuzzing</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<pubPlace>Oakland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The devil is in the details: an evaluation of recent feature encoding methods</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chatfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Lempitsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vedaldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BMVC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Towards automated dynamic analysis for linux-based embedded firmware</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Finding unknown malice in 10 seconds: Mass vetting for new threats at the google-play scale</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A large-scale analysis of the security of embedded firmwares</title>
		<author>
			<persName><forename type="first">A</forename><surname>Costin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zaddach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Francillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Balzarotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Tracelet-based code search in executables</title>
		<author>
			<persName><forename type="first">Y</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Graph-based comparison of executable objects (english version)</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dullien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rolles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SSTIC</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Blanket execution: Dynamic similarity testing for program binaries and components</title>
		<author>
			<persName><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">discovre: Efficient cross-architecture identification of bugs in binary code</title>
		<author>
			<persName><forename type="first">S</forename><surname>Eschweiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yakdan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gerhards-Padilla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Origen: Automatic extraction of offset-revealing instructions for cross-version memory analysis</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Carmony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>ASIACCS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Structural comparison of executable objects</title>
		<author>
			<persName><forename type="first">H</forename><surname>Flake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DIMVA</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Binhunt: Automatically finding semantic differences in binary programs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information and Communications Security</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Holcombe</surname></persName>
		</author>
		<ptr target="https://securityevaluators.com/knowledge/case_studies/routers/soho_techreport.pdf" />
		<title level="m">Soho network equipment (technical report</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<ptr target="http://www.datarescue.com/idabase/" />
		<title level="m">The IDA Pro Disassembler and Debugger</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Redebug: finding unpatched code clones in entire os distributions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<pubPlace>Oakland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Zero-example event search using multimodal pseudo relevance feedback</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-I</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Hauptmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICMR</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Towards efficient learning of optimal spatial bag-of-words representations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><surname>Deyu Andhauptmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICMR</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Bridging the ultimate semantic gap: A semantic search engine for internet videos</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-I</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Hauptmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICMR</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Ccfinder: a multilinguistic token-based code clone detection system for large scale source code</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kamiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kusumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="654" to="670" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Rendezvous: A search engine for binary code</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Khoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mycroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Working Conference on Mining Software Repositories</title>
		<meeting>the 10th Working Conference on Mining Software Repositories</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Cp-miner: A tool for finding copy-paste and related bugs in operating system code</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Myagmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="289" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Hashing with graphs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">More Complex = Less Secure. Miss a Test Path and You Could Get Hacked</title>
		<author>
			<persName><surname>Mccabe</surname></persName>
		</author>
		<ptr target="http://www.mccabe.com/sqe/books.htm" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">A comparison of event models for naive bayes text classification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nigam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">ibinhunt: binary hunting with inter-procedural control flow</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ming</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security and Cryptology</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="92" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A survey of recent advances in hierarchical clustering algorithms</title>
		<author>
			<persName><forename type="first">F</forename><surname>Murtagh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="354" to="359" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">K-gram based software birthmarks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Myles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Collberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM symposium on Applied computing</title>
		<meeting>the 2005 ACM symposium on Applied computing</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Newman</surname></persName>
		</author>
		<title level="m">Networks: an introduction</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">On spectral clustering: Analysis and an algorithm</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in neural information processing systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="849" to="856" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Vccfinder: Finding potential vulnerabilities in open-source projects to assist code audits</title>
		<author>
			<persName><forename type="first">H</forename><surname>Perl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dechand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Arp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rieck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Acar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Cross-architecture bug search in binary executables</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pewny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Garmany</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rossow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<pubPlace>Oakland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Leveraging semantic signatures for bug search in binary programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pewny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bernhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rossow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Similarity between euclidean and cosine angle distance for nearest neighbor queries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sural</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pramanik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the symposium on Applied computing</title>
		<meeting>the symposium on Applied computing</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1232" to="1237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Optimizing seed selection for fuzzing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Warren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Grieco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Approximate graph edit distance computation by means of bipartite graph matching</title>
		<author>
			<persName><forename type="first">K</forename><surname>Riesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bunke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Image and vision computing</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="950" to="959" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Effect of separate sampling on classification accuracy</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Shahrokh</forename><surname>Esfahani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="242" to="250" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Recognizing functions in binaries with neural networks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">C R</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Moazzezi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Firmalice-automatic detection of authentication bypass vulnerabilities in binary firmware</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Video google: A text retrieval approach to object matching in videos</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sivic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Computer Vision</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Locality-sensitive hashing for finding nearest neighbors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Slaney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Signal Processing Magazine</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="128" to="131" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>IEEE</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Driller: Augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName><forename type="first">N</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Galib: A c++ library of genetic algorithm components</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mechanical Engineering Department</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page">54</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A quantitative analysis and performance study for similarity-search methods in high-dimensional spaces</title>
		<author>
			<persName><forename type="first">R</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Schek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Blott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="194" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Automatic inference of search patterns for taint-style vulnerabilities</title>
		<author>
			<persName><forename type="first">F</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gascon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rieck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<pubPlace>Oakland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Evaluating bag-of-visual-words representations in scene classification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-G</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Hauptmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Ngo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International workshop on Workshop on multimedia information retrieval</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Content-based video search over 1 million videos with 1 core in 1 second</title>
		<author>
			<persName><forename type="first">S.-I</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Hauptmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ICMR</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Avatar: A framework to support dynamic security analysis of embedded systems&apos; firmwares</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zaddach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Francillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Balzarotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Towards automatic generation of security-centric descriptions for android apps</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Semantics-Aware Android Malware Classification Using Weighted Contextual API Dependency Graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
