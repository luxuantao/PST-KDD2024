<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FINN: A Framework for Fast, Scalable Binarized Neural Network Inference</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Yaman</forename><surname>Umuroglu</surname></persName>
							<email>yamanu@idi.ntnu.no</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Xilinx Research Labs</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Norwegian University of Science and Technology</orgName>
								<orgName type="institution" key="instit2">University of Sydney</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicholas</forename><forename type="middle">J</forename><surname>Fraser</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Xilinx Research Labs</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Giulio</forename><surname>Gambardella</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Xilinx Research Labs</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaela</forename><surname>Blott</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Xilinx Research Labs</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Philip</forename><surname>Leong</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Magnus</forename><surname>Jahre</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Norwegian University of Science and Technology</orgName>
								<orgName type="institution" key="instit2">University of Sydney</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kees</forename><surname>Vissers</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Xilinx Research Labs</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">FINN: A Framework for Fast, Scalable Binarized Neural Network Inference</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">10EC67144622747CAC04C4E4F4866D05</idno>
					<idno type="DOI">10.1145/3020078.3021744</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Research has shown that convolutional neural networks contain significant redundancy, and high classification accuracy can be obtained even when weights and activations are reduced from floating point to binary values. In this paper, we present Finn, a framework for building fast and flexible FPGA accelerators using a flexible heterogeneous streaming architecture. By utilizing a novel set of optimizations that enable efficient mapping of binarized neural networks to hardware, we implement fully connected, convolutional and pooling layers, with per-layer compute resources being tailored to user-provided throughput requirements. On a ZC706 embedded FPGA platform drawing less than 25 W total system power, we demonstrate up to 12.3 million image classifications per second with 0.31 µs latency on the MNIST dataset with 95.8% accuracy, and 21906 image classifications per second with 283 µs latency on the CIFAR-10 and SVHN datasets with respectively 80.1% and 94.9% accuracy. To the best of our knowledge, ours are the fastest classification rates reported to date on these benchmarks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Convolutional Neural Networks (CNNs) have dramatically improved in recent years, their performance now exceeding that of other visual recognition algorithms <ref type="bibr" target="#b14">[14]</ref>, and even surpassing human accuracy on certain problems <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b29">29]</ref>. They are likely to play an important role in enabling ubiquitous machine vision and intelligence on all kinds of devices, but a significant computational challenge remains. Modern CNNs may contain millions of floating-point parameters and require billions of floating-point operations to recognize a single image. Furthermore, these requirements tend to increase as researchers explore deeper networks. For instance, AlexNet <ref type="bibr" target="#b14">[14]</ref> (the winning entry for ImageNet Large Scale Visual Recognition Competition (ILSVRC) <ref type="bibr" target="#b23">[23]</ref> in 2012) required 244 MB of parameters and 1.4 billion floating point operations (GFLOP) per image, while VGG-16 <ref type="bibr" target="#b25">[25]</ref> from ILSVRC 2014 required 552 MB of parameters and 30.8 GFLOP per image.</p><p>While the vast majority of CNNs implementations use floating point parameters, a growing body of research demonstrates this approach incorporates significant redundancy. Recently, it has been shown <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b32">32]</ref> that neural networks can classify accurately using one-or two-bit quantization for weights and activations. Such a combination of low-precision arithmetic and small memory footprint presents a unique opportunity for fast and energy-efficient image classification using Field Programmable Gate Arrays (FPGAs). FPGAs have much higher theoretical peak performance for binary operations compared to floating point, while the small memory footprint removes the off-chip memory bottleneck by keeping parameters on-chip, even for large networks. Binarized Neural Networks (BNNs), proposed by Courbariaux et al. <ref type="bibr" target="#b5">[5]</ref>, are particularly appealing since they can be implemented almost entirely with binary operations, with the potential to attain performance in the teraoperations per second (TOPS) range on FPGAs.</p><p>In this work, we propose Finn, a framework for building scalable and fast BNN inference accelerators on FPGAs. Finn-generated accelerators can perform millions of classifications per second with sub-microsecond latency, thereby making them ideal for supporting real-time embedded applications such as augmented reality, autonomous driving and robotics. Compute resources can be scaled to meet a given classification rate requirement. We demonstrate Finn's capabilities with a series of prototypes for classifying the MNIST, SVHN and CIFAR-10 benchmark datasets. Our classification rate results surpass the best previously published results by over 48× for MNIST, 2.2× for CIFAR-10 and 8× for SVHN. To the best of our knowledge, this is the fastest reported neural network inference implementation on these datasets. The novel contributions are:</p><p>• Quantification of peak performance for BNNs on FPGAs using a roofline model.</p><p>• A set of novel optimizations for mapping BNNs onto FPGA more efficiently.</p><p>• A BNN architecture and accelerator construction tool, permitting customization of throughput.</p><p>• A range of prototypes that demonstrate the potential of BNNs on off-the-shelf FPGA platforms.</p><p>The rest of this paper is organized as follows: Section 2 provides background on CNNs, BNNs, and their hardware implementations. Section 3 discusses BNNs accuracy and peak performance on FPGAs. Section 4 describes Finn's architecture and optimizations. Section 5 presents the experimental evaluation, and Section 6 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>This work is focused on supervised learning, in which the goal is to find a function, g(xi), which approximates a mapping xi → yi ∀ i, where {xi, yi} is an input/output pair known as a training example. Furthermore, only the inference problem is studied, the parameters, w, being assumed to have been learned offline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Convolutional Neural Networks</head><p>A multilayer perceptron is a type of Artificial Neural Network (ANN) which has its neurons arranged in multiple layers, with neurons taking the output of all neurons of the previous layer as inputs. Mathematically, the output, a l,n , for the n th neuron in the l th layer of a fully connected network is calculated as follows:</p><formula xml:id="formula_0">a l,n = fact( S l s=0 w l,n,s a l-1,s + b l,n ) ,<label>(1)</label></formula><p>where w l,n,s is weight of the s th synapse connected to the input of the n th neuron in the l th layer, b l,n is a bias term, fact is the activation function, and S l is the number of synapses connected to each neuron in the l th layer. Popular activation functions include: the hyperbolic tangent function, fact(a) = tanh(a); and the rectified linear unit (ReLU), fact(a) = max(0, a).</p><p>CNNs <ref type="bibr" target="#b15">[15]</ref> are a variant of multilayer perceptrons, in which a layer only receives inputs from a small receptive field of the previous layer. This approach greatly reduces the number of parameters involved and allows local features (e.g., edges, corners) to be found <ref type="bibr" target="#b15">[15]</ref>. A basic 2D convolutional layer in a neural network is similar to a fully connected layer except that: a) each neuron receives an image as inputs and produces an image as its output (instead of a scalar); b) each synapse learns a small array of weights which is the size of the convolutional window; and c) each pixel in the output image is created by the sum of the convolutions between all synapse weights and the corresponding images. The output of the l th convolutional layer, which takes as input S l images of dimension R l × C l , the pixel, p l,n,r,c , at location (r, c) of the n th output image is calculated as follows:</p><formula xml:id="formula_1">p l,n,r,c = fact( S l s=0 J l j=0 K l k=0 w l,n,s,j,k p l-1,n,r+j,c+k ) , (2)</formula><p>where J l × K l are the dimensions of the convolution window. As discussed in Section 4, a 2D convolutional layer can be reduced to a matrix multiply followed by an elementwise activation function. CNN topologies are composed from a few common primitives: convolutional layers, pooling layers and fully connected layers.</p><p>Pooling layers can be considered as simple downsamplers of 2D images. A basic max pooling layer divides an image into small sub-tiles of a given window size and then replaces each sub-tile with its largest element. An average pooling layer is similar but uses the average function instead of max.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Binary Neural Networks</head><p>Although floating point numbers are a natural choice for handling the small updates that occur during neural network training, the resulting parameters can contain a lot of redundant information <ref type="bibr" target="#b8">[8]</ref>. One of several possible dimensions possessing redundancy is precision <ref type="bibr" target="#b27">[27]</ref>. An extreme case are BNNs in which some or all the arithmetic involved in computing the outputs are constrained to single-bit values. We consider three aspects of binarization for neural network layers: binary input activations, binary synapse weights and binary output activations. If all three components are binary, we refer to this as full binarization, and the cases with one or two components as partial binarization.</p><p>Kim and Smaragdis <ref type="bibr" target="#b12">[12]</ref> consider full binarization with a predetermined portion of the synapses having zero weight, and all other synapses with a weight of one. They report 98.7% accuracy with fully-connected networks on the MNIST dataset, and observe that only XNOR and bitcount operations are necessary for computing with such neural networks. XNOR-Net by Rastegari et al. <ref type="bibr" target="#b22">[22]</ref> applies convolutional BNNs on the ImageNet dataset with topologies inspired by AlexNet, ResNet and GoogLeNet, reporting top-1 accuracies of up to 51.2% for full binarization and 65.5% for partial binarization. DoReFa-Net by Zhou et al. <ref type="bibr" target="#b32">[32]</ref> explores reduced precision during the forward pass as well as the backward pass, and note that this opens interesting possibilities for training neural networks on FPGAs. Their results includes configurations with partial and full binarization on the SVHN and ImageNet datasets, including best-case ImageNet top-1 accuracies of 43% for full and 53% for partial binarization.</p><p>Finally, the work by Courbariaux et al. <ref type="bibr" target="#b5">[5]</ref> describes how to train fully-connected and convolutional networks with full binarization and batch normalization layers, reporting competitive accuracy on the MNIST, SVHN and CIFAR-10 datasets. Training for this work was performed using their open source implementation. We use the acronym CNN to refer to conventional or non-binarized neural networks for brevity throughout the rest of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Neural Networks in Hardware</head><p>A great deal of prior work on mapping neural networks to hardware exist both for FPGAs and as ASICs. We refer the reader to the work by Misra and Saha <ref type="bibr" target="#b16">[16]</ref> for a comprehensive survey. We cover a recent and representative set of works here, roughly dividing them into four categories based on their basic architecture: 1) a single processing engine <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b2">2]</ref>, usually in the form of a systolic array, which processes each layer sequentially; 2) a streaming architecture <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b1">1]</ref>, consisting of one processing engine per network layer; 3) a vector processor <ref type="bibr">[7]</ref> with instructions specific to accelerating the primitives operations of convolutions; and 4) a neurosynaptic processor <ref type="bibr" target="#b6">[6]</ref>, which implements many digital neurons and their interconnecting weights.</p><p>Systolic arrays: Zhang et al. <ref type="bibr" target="#b31">[31]</ref> describes a single processing engine style architecture, using theoretical roofline models tool to design accelerators optimized for the execution of each layer. Ovtcharov et al. <ref type="bibr" target="#b20">[20]</ref> implement a similar style architecture, but achieved a 3× speedup over Zhang et al. <ref type="bibr" target="#b31">[31]</ref>. Eyeriss by Chen et al. <ref type="bibr" target="#b4">[4]</ref> use 16-bit fixed point rather than floating point, and combine several different data reuse strategies. Each 2D convolution is mapped to 1D convolutions across multiple processing engines, allowing for completely regular access patterns for each processing element. The authors report that their data reuse provides 2.5× better energy efficiency over other methods. YodaNN by Andri et al. <ref type="bibr" target="#b2">[2]</ref> have a similar design as Zhang et al. <ref type="bibr" target="#b31">[31]</ref> but explore binary weights for fixed sized windows.</p><p>Streaming architectures: Venieris and Bouganis <ref type="bibr" target="#b28">[28]</ref>   CNNs to FPGAs, which is a similar approach to ours. The main difference is that our design is optimized for BNNs while their design targets conventional CNNs. Their designs achieve up to 1.62× the performance density of hand tuned designs. Alemdar et al. <ref type="bibr" target="#b1">[1]</ref> implement fully-connected ternary-weight neural networks with streaming and report up to 255K frames per second on the MNIST dataset, but concentrate on the training aspect for those networks.</p><p>Vector processors: Farabet et al. <ref type="bibr">[7]</ref> describe a programmable ConvNet Processor (CNP), which is a RISC vector processor with specific macro-instructions for CNNs including 2D convolutions, 2D spatial pooling, dot product and an elementwise non-linear mapping function. The authors also created a tool to compile a high level network description into host code which is used to call the CNP.</p><p>Neurosynaptic processors: TrueNorth <ref type="bibr" target="#b6">[6]</ref> is a low power, parallel ASIC with 4096 neurosynaptic cores, each implementing 256 binary inputs, 256 neurons and a 256 × 256 array of synapses. An internal spiking router can connect any input on any core to any neuron on any core, allowing many network topologies to be implemented on fixed hardware.</p><p>The authors are not aware of any publication that demonstrates end-to-end mapping of BNNs onto FPGAs. In comparison to prior art, the binary network inference engine can significantly increase classification rates, while reducing power consumption and minimizing latency. This currently comes at the cost of a small drop in accuracy for larger networks, however we believe a) there are use cases that do not require the highest level of accuracy, or can be solved with smaller networks (such as classification of playing cards or handwritten digits <ref type="bibr" target="#b15">[15]</ref>) and b) that accuracy can be improved by increasing network sizes <ref type="bibr" target="#b27">[27]</ref>, an ongoing topic in machine learning research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">BNN PERFORMANCE AND ACCURACY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Estimating Performance Using Rooflines</head><p>To estimate and compare BNN performance with fixedpoint CNN, we use a roofline model <ref type="bibr" target="#b30">[30]</ref> which considers memory bandwidth, peak computational performance and arithmetic intensity (the number of mathematical operations performed for each byte of off-chip memory read or written). The intersection of the roofline curve with a vertical line for a particular arithmetic intensity, gives the theoretical peak performance point, which is either compute-bound or memory-bound. In particular, we consider the binarized <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b22">22]</ref> and 8-bit fixed-point <ref type="bibr" target="#b26">[26]</ref> implementations of the popular AlexNet <ref type="bibr" target="#b14">[14]</ref>, both of which require 1.4 billion operations (GOPS) to classify one image.</p><p>Using the methodology described in <ref type="bibr" target="#b17">[17]</ref>, we develop a roofline model for a Xilinx Zynq UltraScale+ ZU19EG FPGA <ref type="foot" target="#foot_0">1</ref> . The resulting roofline model is depicted in Figure <ref type="figure" target="#fig_0">1</ref>. We first observe that the FPGA's compute-bound performance is 66 TOPS for binary operations, which is about 16× higher compared to 8-bit and 53× higher compared to 16-bit fixed point operations. However, reaching the compute-bound peak is only possible if the application is not memory-bound.</p><p>The compact model size of BNNs provides another key benefit. Since the binarized AlexNet requires only 7.4 MB of parameters (compared with 50 MB for 8-bits), the entire neural network model can be kept in on-chip memory. The arithmetic intensities for the binarized and 8-bit fixed point AlexNet variants are shown with vertical lines. Thus, the BNN is almost able to reach the computational peak, while the peak performance of the fixed-point CNN is bound by the memory bandwidth. Based on these observations, with a design that reaches 75% of the peak, we estimate a throughput of 0.75 • 66 TOPS 1.4 GOPS ≈ 35000 images per second. Using the same model, it should be possible to extend the comparison to CPUs and GPUs, but little data is available on peak binary synaptic operation performance since BNNs are relatively new. For instance, <ref type="bibr" target="#b5">[5]</ref> mentions 6 cycles per 32 synapses (64 binary operations) on recent NVIDIA GPUs, which would yield a computational peak of about 26 TOPS on a Tesla K40 with 2880 cores running at 875 MHz, and 16666 images per second for binarized AlexNet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Accuracy-Computation Tradeoffs</head><p>A tradeoff between network size, precision and accuracy exists <ref type="bibr" target="#b27">[27]</ref> so if one would like to achieve a certain classification accuracy for a particular problem, which approach leads to the most efficient solution? 1) A regular ANN with floating point precision? 2) A larger network, but a BNN? To gain more insight into this issue, we conducted a set of experiments on the MNIST dataset that compare accuracy of floating point and binary precision for the same topology. The binary networks are obtained via replacing regular layers by their binary equivalents, as described by Courbariaux et al. <ref type="bibr" target="#b5">[5]</ref>. We also binarize the input images for the BNN as our experiments show that input binarization works well for MNIST. Since the space of possible network topologies that can be trained is infinite, we adopted the approach in <ref type="bibr" target="#b27">[27]</ref> to simplify the problem. We fix the network topology to a 3 hidden layer, fully connected network while scaling the number of neurons in each layer, and plot the resulting accuracy in Table <ref type="table" target="#tab_1">1</ref> along with the number of parameters and operations per frame. A few trends are apparent for this problem and network configuration space: 1) similar to what was found in by Sung et al. <ref type="bibr" target="#b27">[27]</ref>, as the network size increases, the difference in accuracy between low precision networks and floating point networks decreases; and 2) in order to achieve the same level of accuracy as floating point networks, BNNs require 2-11× more parameters and operations. Note that we show the accuracy for networks trained using 32-bit floating point numbers, but it is likely that this could be reduced to 8-bit fixed point without a significant change in accuracy <ref type="bibr" target="#b10">[10]</ref>. Our BNN performance estimates from Section 3.1 suggest a 16× speedup for BNN over 8-bit fixed point, which is greater than the 2-11× increase in parameter and operation size. Thus, we expect that BNNs with compara-  ble accuracy will be faster than fixed-point networks, even though they may require more parameters and operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">BNNs ON RECONFIGURABLE LOGIC</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Architecture</head><p>We adopted a heterogeneous streaming architecture as shown in Figure <ref type="figure" target="#fig_1">2</ref> for this work. We build a custom architecture for a given topology rather than scheduling a operations on top of a fixed architecture. Separate compute engines are dedicated to each layer, which communicate via on-chip data streams. Each engine starts to compute as soon as the previous engine starts to produce output. Additionally, owing to the compact model size of BNNs, all neural network parameters are kept in on-chip memory. This avoids most accesses to off-chip memory, minimizes the latency (the time to finish classifying one image) by overlapping computation and communication, and minimizes the initiation interval : a new image can enter the accelerator as soon as the first compute array is finished with the previous image. The separate mapping of layers to compute arrays also enables heterogeneity. By tailoring compute arrays separately for each layer's requirements, we can avoid the "one-size-fits-all" inefficiencies and reap more of the benefits of reconfigurable computing. This requires a different bitfile when the neural network topology is changed but we consider this an acceptable cost for the performance gains obtained.</p><p>A BNN accelerator may have various constraints imposed upon it depending on the use case. User-imposed constraints include the choice of FPGA and platform, desired classification throughput in frames per second (FPS) and clock frequency. Simultaneously, the BNN topology constrains how the compute resources must be allocated to obtain an efficient heterogeneous streaming architecture. Finn offers parameterizable building blocks and a way of controlling the classification throughput, as described in Sections 4.3 and 4.4. To achieve portability, we chose a commercial high level synthesis tool, Vivado High-Level Synthesis (HLS), for the implementation. The tool enables faster development cycles via high-level abstractions, and provides automated pipelining to meet the clock frequency target.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">BNN-specific Operator Optimizations</head><p>BNNs have several properties that enable a more efficient mapping to FPGAs without affecting the network accuracy, which we describe in the following subsections. We assume that the methodology described in <ref type="bibr" target="#b5">[5]</ref> is used for training all BNNs in this paper, where all BNN layers have the following properties (unless otherwise stated):</p><p>• Using 1-bit values for all input activations, weights and output activations (full binarization), where an unset bit represents -1 and a set bit represents +1.</p><p>• Batch normalization prior to the activation function.</p><p>• Using the following activation function:</p><formula xml:id="formula_2">Sign(x) = {+1 if x ≥ 0, -1 if x &lt; 0}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Popcount for Accumulation</head><p>The regular and value-constrained nature of BNN computations enable computing binary dot products with fewer hardware resources. Let Y be the number of input synapses (or fan-in) for a given neuron, with the number of +1-valued synapse inputs denoted as Y1 and -1-valued synapses as Y0. As there are only two possible values (-1 and +1) for any synapse input, Y = Y0 + Y1. Therefore, by counting the number of synapses for only one value, it is possible to infer the summed response for the entire neuron.</p><p>The practical consequence for hardware is that the summation of a binary dot product can be implemented by a popcount operation that counts the number of set bits instead of accumulation with signed arithmetic. Our experiments with Vivado HLS indicate that popcount-accumulate requires approximately half the number of LUT and FF resources to implement compared to signed-accumulate. For instance, with a target F clk = 200 MHz, a 128-bit popcountaccumulate requires 376 LUTs and 29 FFs, while a 128-bit bipolar-accumulate requires 759 LUTs and 84 FFs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Batchnorm-activation as Threshold</head><p>All BNN layers use batch normalization <ref type="bibr" target="#b11">[11]</ref> on convolutional or fully connected layer outputs, then apply the sign function to determine the output activation. We show how the same output can be computed via thresholding.</p><p>Let a k be the dot product (pre-activation) output of neuron k, and Θ k = (γ k , µ k , i k , B k ) be the batch normalization parameters learned during training for this neuron. The output a b k is computed as <ref type="figure">3</ref> shows the dot product input vs output activation for three example neurons. Depending on parameter values, the plot may be shifted towards the left or right, or be flipped horizontally, but a threshold τ k for a change in the output activation is always present. Solving BatchNorm(τ k , Θ k ) = 0 we can deduce that</p><formula xml:id="formula_3">a b k = Sign(BatchNorm(a k , Θ k )), with BatchNorm(a k , Θ k ) = γ k • (a k -µ k ) • i k + B k . Figure</formula><formula xml:id="formula_4">τ k = µ k -(B k /(γ k • i k )).</formula><p>To make the thresholds compatible with the positive-only operations in Section 4.2.1), the computed threshold is averaged with the neuron fan-in S to obtain τ + k = (τ k + S)/2. Observing how neuron C activates with an opposite sign threshold to neurons A and B in Figure <ref type="figure">3</ref>, all neurons can be made to activate using a greater-than threshold by flipping the signs of a neuron's weights if</p><formula xml:id="formula_5">γ k • i k &lt; 0.</formula><p>Using these techniques, we can compute the output activation using an unsigned comparison and avoid computing the batch normalized value altogether during inference. τ + k itself is fixed for a trained network and can be computed from the batchnorm parameters at compile time. Synthesis reports from Vivado HLS for 16-bit dot product output values indicate that regular batchnorm-and-sign activation requires 2 DSPs, 55 FFs and 40 LUTs, whereas the threshold activation we describe here only requires 6 LUTs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Boolean OR for Max-pooling</head><p>The networks described in <ref type="bibr" target="#b5">[5]</ref> perform pooling prior to activations, i.e. pooling is performed on non-binarized numbers, which are then batch normalized and fed into the activation function. We show that the same layer outputs can be derived by max pooling after the activations without having to re-train the network. Let a1, a2, . . . aY be the positive dot product outputs that will be processed by max-pooling. In accordance with Section 4.2.2, the output would be computed as a b = (Max(a1, a2, . . . aY ) &gt; τ + ). Due to the distributivity of Max, the output will be true if any of a1, a2, . . . aS are greater than τ + . Therefore, the same result can be computed as a b = (a1 &gt; τ + ) ∨ (a2 &gt; τ + ) . . . ∨ (aY &gt; τ + ). As the threshold comparisons are already computed for the activations, max-pooling can be effectively implemented with the Boolean OR-operator. We note that similar principles apply for min-pooling (as Boolean AND) and average-pooling (as Boolean majority function) as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">FINN Design Flow and Hardware Library</head><p>Figure <ref type="figure">4</ref> illustrates the design flow for converting a trained BNN into an FPGA accelerator. The user supplies a FPS target alongside a Theano-trained BNN to the Finn synthesizer. The synthesizer first determines the folding parameters (Section 4.4) to meet the FPS target and applies the optimizations from Section 4.2, then produces a synthesizable C++ description of a heterogeneous streaming architecture. The architecture is composed of building blocks from the Finn hardware library described in the following subsections. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">The Matrix-Vector-Threshold Unit</head><p>The Matrix-Vector-Threshold Unit (MVTU) forms the computational core for our accelerator designs. The vast majority of compute operations in a BNN can be expressed as matrix-vector operations followed by thresholding. For instance, the pre-activation output a N of the fully connected neural network layer at index N is given by matrix-vector product a N = A•a b N-1 where A is the synaptic weight matrix and a b N-1 are the activations from the previous layer. The post-activation output can then be computed by a b N = a N &gt; τ + N , where the thresholds τ + N are determined as described in Section 4.2.2. Convolutions can also be implemented as matrix-vector products, as will be described in Section 4.3.2. As such, the MVTU implements fully-connected layers as a standalone component, and is also used as part of the convolutional layers.</p><p>The overall organization of the MVTU is shown in Figure <ref type="figure">5</ref>. Internally, the MVTU consists of an input and output buffer, and an array of Processing Elements (PEs) each with a number of SIMD lanes. The number of PEs (P ) and SIMD lanes (S) are configurable to control the throughput as discussed in Section 4.4.1. The synapse weight matrix to be used is kept in On-Chip Memory (OCM) distributed between PEs, and the input images stream through the MVTU as each one is multiplied with the matrix. Each PE receives exactly the same control signals and input vector data, but multiply-accumulates the input with a different part of the matrix. In terms of the taxonomy described in <ref type="bibr" target="#b4">[4]</ref>, this architecture is both weight stationary (since each weight remains local to the PE) and output stationary (since each popcount computation remains local to the PE).</p><p>Figure <ref type="figure">6</ref> shows the datapath of an MVTU PE. It computes the dot product between the input vector and a row of the synaptic weight matrix and compares the result to a threshold, producing a single-bit output. The dot product computation itself consists of an XNOR of the vectors, after which the number of set bits in the result is counted (see Section 4.2.1) and added to the accumulator register. Once the entire dot product is accumulated, it is thresholded. The accumulator, adder and threshold memory bitwidth can be scaled down to T = 1 + log 2 (Y ) for additional resource savings.  Finally, it is worth pointing out that the MVTU architectural template can also support partial binarization for non-binarized outputs and inputs. Removing the thresolding stage provides non-binarized outputs, while using regular multiply-add instead of XNOR-popcount can handle nonbinarized inputs These features are used in the first and last layers of networks that process non-binary input images or do not output a one-hot classification vector.</p><formula xml:id="formula_6">A B C E F G D H A B C D E F G H P Q R S T U V W filters P Q R T U V S W</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Convolution: The Sliding Window Unit</head><p>Convolutions can be lowered to matrix-matrix multiplications <ref type="bibr" target="#b3">[3]</ref>, which is the approach followed in this work. The weights from the convolution filters are packed into a filter matrix, while a sliding window is moved across input images to form an image matrix. These matrices are then multiplied to generate the output images.</p><p>The convolutional layer consists of a Sliding Window Unit (SWU), which generates the image matrix from incoming feature maps, and a MVTU that actually computes the matrix-matrix product using a different column vector from the image matrix each time. In order to better cater for the SIMD parallelism of the MVTU and minimize buffering requirements, we interleave the feature maps such that each pixel contains all the Input Feature Map (IFM) channel data for that position, as illustrated in Figure <ref type="figure" target="#fig_5">7a</ref>. Since the dot product to compute a Output Feature Map (OFM) pixel includes all IFMs pixels at a certain sliding window location, those IFM pixels can be processed in any order owing to the commutative property of addition. Note that interleaving the filter matrix has no additional cost since it is done offline, and interleaving the input image can be done on-the-fly in the FPGA. Storing the pixels in this fashion allows us to implement the SWU with a single wide OCM instead of multiple narrow OCMs, and also enables the output of the MVTU to be directly fed to the next layer without any transposition. As illustrated in Figure <ref type="figure" target="#fig_5">7b</ref>, the incoming IFM data is simply stored at sequential addresses in a buffer, then the memory locations corresponding to each sliding window are read out to produce the image matrix.</p><p>Although not required by any of the networks described in this work, the SWU also pads the images if necessary. One interesting observation is that with the bipolar number representation used in this work, there is no number corresponding to zero. Therefore, in order to maintain a true binary datapath for activations, images must be padded with our representation or either a 1 or a -1. Future work will look into what impact this has on the accuracy of trained networks, but early experiments suggest that there is very little difference in accuracy, with respect to <ref type="bibr" target="#b5">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">The Pooling Unit</head><p>The Pooling Unit (PU) implements max-pooling as described in Section 4.2.3. To implement k × k max-pooling on a DH × DW binary image of C channels, the PU contains C • k line buffers of DW bits each. As with the rest of our component library, the PU operates in a streaming fashion. The input image is gradually streamed into the line buffers. When at least k rows of the image have arrived, each k consecutive bits of the line buffer are OR'ed together to produce horizontal subsampling for each channel. These are then OR'ed together with the other line buffers to produce vertical subsampling, the results are streamed out, and the oldest line buffers are refilled with the next row of pixels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Folding</head><p>In terms of the MVTU description given in Section 4.3.1, each PE corresponds to a hardware neuron, while each SIMD lane acts as a hardware synapse. If we were to dimension each MVTU in a network with a number of hardware neurons and synapses equal to the number of neurons and synapses in a BNN layer, this would result in a fully parallel neural network that could classify images at the clock rate. However, the amount of hardware resources on an FPGA is limited, and it is necessary to time-multiplex (or fold ) the BNN onto fewer hardware synapses and neurons. We now describe how the folding is performed subject to user constraints.</p><p>The work by Venieris et al. <ref type="bibr" target="#b28">[28]</ref> describes a method for folding neural networks expressed as streaming dataflow graphs, with focus on formalizing the folding and design space exploration. In this work, we consider a simpler variant that only controls the folding of matrix-vector products to achieve a given FPS requirement set by the user, and focus on how the folding is implemented in terms of the workload mapping. As almost all computations in BNNs are expressed as matrix-vector multiplications, implementing folding for matrix-vector multiplication already enables a great degree of control over the system throughput. Folding directly affects the resource and power consumption of the final system as well, which we explore in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Folding Matrix-Vector Products</head><p>Folding matrix-vector products is achieved by controlling two parameters of the MVTU: P the number of PEs, and S the number of SIMD lanes per PE. These determine how the matrix is partitioned between the PEs. A P -high, S-wide tile of the matrix is processed at a time, with each row in the tile mapped to a different PE, and each column to a different SIMD lane. For a X × Y matrix, we refer to as the neuron fold and F s = Y /S as the synapse fold. The total fold F is then obtained as F = F n • F s , which is also the number of cycles required to complete one matrix-vector multiply. Note that F n and F s should be integers to avoid padding the weight matrix. As an example, Figure <ref type="figure" target="#fig_6">8</ref> shows how a 6 × 4 weight matrix is partitioned between three PEs with two SIMD lanes each. Here, each matrix-vector multiply will take</p><formula xml:id="formula_7">F n = X/P A B C E F G D H J K L N O P M Q R S T V W X U Y N O P Q A B C D F H S E G R T U J K L M V W X Y<label>T0</label></formula><formula xml:id="formula_8">F n • F s = (6/3) • (4/2) = 4 cycles.</formula><p>The same principle applies for convolutional layers, but these always have an inherent amount of folding due to our current matrix-matrix product as multiple matrix-vector products implementation. For convolutional layers, the total fold is</p><formula xml:id="formula_9">F = F m • F n • F s ,</formula><p>where F m is a network-dependent constant due to multiple matrix-vector products, and is equal to the number of output pixels from the convolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Determining F n and F s</head><p>Avoiding the "one-size-fits-all" inefficiencies requires tailoring each MVTU's compute resources to layer requirements. The guiding principle here is rate-balancing the heterogeneous streaming architecture: the slowest layer (with IImax) will determine the overall throughput, so each layer should use a roughly equal number of cycles to process one image. As this is a streaming system, the classification throughput FPS will be approximately F clk IImax , where F clk is the clock frequency. For a fully-connected layer, the total fold F is equal to the initiation interval (II). Therefore, balancing a fully-connected BNN can be achieved by using F n and F s such that F n • F s = F clk FPS for each layer. Depending on the the FPS requirements, the number of memory channels or sliding window generation may constitute bottlenecks. For such cases, we match the throughput of all other layers to the bottleneck in order not to waste resources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>To evaluate Finn, we created a number of prototypes that accelerate BNNs inference on the MNIST <ref type="bibr" target="#b15">[15]</ref> (28 × 28 handwritten digits), CIFAR-10 [13] (32 × 32 color images in 10 categories) and cropped SVHN <ref type="bibr" target="#b18">[18]</ref> (32 × 32 images of Street View House Numbers) datasets. Each prototype combines a BNN topology with a different use case scenario. We consider three different BNN topologies for classifying the datasets as follows:</p><p>• SFC and LFC are three-layer fully connected network topologies for classifying the MNIST dataset, with different numbers of neurons to demonstrate accuracycomputation tradeoffs (Section 3.2). SFC contains 256 neurons per layer and achieves 95.83% accuracy, while LFC has 1024 neurons per layer and achieves 98.4%</p><p>accuracy. These networks accept 28x28 binary images and output a 10-bit one-hot vector indicating the digit.</p><p>• CNV is a convolutional network topology inspired by BinaryNet <ref type="bibr" target="#b5">[5]</ref> and VGG-16 <ref type="bibr" target="#b25">[25]</ref>. It contains a of (3x3 convolution, 3x3 convolution, 2x2 maxpool) layers repeated three times with 64-128-256 channels, followed by two fully connected layers of 512 neurons each. We use this topology for classifying both the CIFAR-10 (with 80.1% accuracy) and SVHN (with 94.9% accuracy) datasets, with different weights and thresholds. Note that the inputs to the first layer and the outputs from the last layer are not binarized; CNV accepts 32x32 images with 24 bits/pixel, and returns a 10-element vector of 16-bit values as the result.</p><p>To further demonstrate the flexibility of the framework, we consider two usage scenarios for each BNN topology to guide the choice of parametrization:</p><p>• max is the maximum performance scenario where it is desirable to reach the peak FPS permitted by the platform, topology and Finn's architecture.</p><p>• fix represents a scenario with a fixed FPS requirement, which is often determined by an I/O device for real life applications. For instance, consider a 640 × 480 video stream at 30 FPS, which is to be chopped up into 32 × 32 tiles for neural network inference. Handling this task with real-time performance would require a BNN inference rate of 9000 FPS, which we set as the requirement for this usage scenario.</p><p>We use shortened names to refer to the prototypes, e.g. CNV-fix refers to the prototype that implements the CNV topology for the fix usage scenario. For each prototype, the folding factors (Section 4.4) were determined to meet the requirements of its usage scenario, and the Finn design flow (Section 4.3) was followed to generate the hardware accelerator. Vivado HLS and Vivado version 2016.3 were used for the bitfile synthesis. A target clock frequency of 200 MHz was used for both Vivado HLS and Vivado, and to run the resulting accelerator unless otherwise stated. The salient properties of the topologies and folding factors for the prototypes are summarized in Table <ref type="table" target="#tab_2">2</ref>.</p><p>All prototypes have been implemented on the Xilinx Zynq-7000 All Programmable SoC ZC706 Evaluation Kit running Ubuntu 15.04. The board contains a Zynq Z7045 SoC with dual ARM Cortex-A9 cores and FPGA fabric with 218600 LUTs and 545 BRAMs. The host code runs on the Cortex-A9 cores of the Zynq. It initializes 10000 images with test data in the Zynq's shared DRAM, launches and times the accelerator execution to measure classification throughput, then measures accuracy by comparing against the correct classifications. Two power measurements P chip and P wall are provided for each experiment; P chip using the PMBus interface to monitor the FPGA power supply rails, and P wall using a wall power meter for the total board power consumption. The measurements are averaged over a period of 10 seconds while the accelerator is running.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Results</head><p>Table <ref type="table" target="#tab_3">3</ref> provides an overview of the experimental results, in terms of classification throughput, latency to classify one image, FPGA resource usage and power. The max scenario  results are perhaps the best summary of the potential of BNNs on FPGAs, with SFC-max achieving 12.3 million classifications per second at 0.31 µs latency while drawing less than 22 W total power. All fix results meet and exceed the 9000 FPS requirement by 30% due to folding factors being integers, though lower throughput and power could have been achieved by using a slower clock. We focus on particular aspects of the results in the following subsections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Maximum Throughput and Bottlenecks</head><p>To assess the quality of results for the max scenarios, we compare the achieved performance (XNOR-popcount operations per second) with the peak throughput in TOPS indicated by the roofline model. Figure <ref type="figure" target="#fig_7">9</ref> presents a roofline model (Section 3.1) for the ZC706, assuming 90% LUT utilization, 200 MHz clock frequency and 1.6 GB/s of DRAM bandwidth. The vertical lines show the arithmetic intensities for the topologies, and the actual operations per second values from corresponding prototypes with max usage scenarios are indicated as points on those lines. All max prototypes achieve performance in the TOPS range, but are bottlenecked due to different factors. CNV-max achieves 2.5 TOPS and is architecture-bound. The current SWU design does not scale as well as the MVTU and constitutes a bottleneck, which will be addressed in future work. Despite its higher observe that CNV-max actually requires ∼2×    than SFC-max since the folding parameters for CNV-max are chosen in accordance with the maximum performance dictated by the bottleneck. SFC-max achieves 8.2 TOPS and is memory-bound. Observe that the SFC arithmetic intensity line intersects the memory-bound (sloped) part of the roofline, thus the performance cannot be scaled up without adding more DRAM memory bandwidth. LFC-max achieves 9.1 TOPS, which is 46% of the roofline, and is resourcebound. As folding factors are integers, the smallest increment is 2× which roughly doubles the resource cost. The FPGA has enough LUTs but not enough BRAMs to accommodate doubled resource cost, thus leaving ∼30% of BRAMs unused. A 3x512-neuron fully connected topology, labeled MFC in Figure <ref type="figure" target="#fig_7">9</ref>, was able to achieve 11.6 TOPS and 6238 kFPS with 95% of the device BRAMs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Energy Efficiency</head><p>It is desirable to minimize the energy spent per image classification, which corresponds to maximizing FPS per Watt when many images are to be classified. To help evaluate the energy efficiency, Figure <ref type="figure" target="#fig_8">10</ref> plots the achieved FPS per Watt for the prototypes for both the wall power and FPGA power readings. In general, we see that the higher FPS prototypes have better energy efficiency, with SFC-max offering 583066 FPS per W of total power and outperforming all other prototypes by at least an order of magnitude. It is also worth noting that the board's idle power consumption is about 7 W, which forms a lower bound on all wall power measurements, and could be improved by e.g. using LPDDR memory.</p><p>To maximize energy efficiency with a fixed target FPS, is it better to use a highly parallel design at low clock frequency, or a less parallel design at high clock frequency? We ran an additional experiment to investigate this question by slowing down the SFC-max prototype to meet the fix FPS requirement of 9000 FPS. By clocking it at 250 kHz, we obtained a classification throughput of 15731 FPS with 0.2 W of FPGA power. The result is labeled SFC-smax in Figure <ref type="figure" target="#fig_8">10</ref>, and is over 2× more energy efficient than SFC-fix. This suggests that a high degree of parallelism benefits energy efficiency as long as the FPGA resources are available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Resource Efficiency</head><p>We consider two aspects of resource efficiency for Finn: how efficiently the compute units are used during runtime (runtime efficiency), and how efficiently FPGA resources are turned into compute units (mapping efficiency).</p><p>To assess runtime efficiency, we divide the FPS-based (actual) operations per cycle (  types loses some insight, since CNV uses LUTs on SWU and PU, while fully-connected topologies do not. Instead, for a single 256 × 256 fully-connected layer, we fix S = 64 and vary P , and plot the LUTs per synaptic operation in Figure <ref type="figure" target="#fig_9">11</ref>, which should be minimized to maximize efficiency. The LUTs per operation decreases with higher P since the fixed-size control logic is amortized between more PEs and reaches a minimum of 1.83 for P = 64, but increases again for P &gt; 64. To understand why, we also plot the number of BRAMs used in the same figure. Although all designs have the same number of BNN parameters, the number of BRAMs increases with P since each PE needs its own weight and threshold memories. This also means a significant part of the BRAM storage capacity is unused for 1 &lt; P ≤ 64, since the same amount of network parameters is divided between a greater number of memories. This is also visible for SFC-fix and SFC-max, which use the same network parameters, but have almost 10× difference in the number of BRAMs used (15.5 vs 130.5) since SFC-max has more compute elements working in parallel. Here, with P &gt; 64, so little of each BRAM is used that Vivado HLS implements the weight and threshold memories using LUTs, which causes the LUTs per operation to increase. Thus, the depth and number of BRAMs, and the LUT-to-BRAM ratio of the FPGA plays a key role in determining how well the resources will be utilized by a BNN. For instance, on another FPGA with the same amount of LUTs but twice the number of half-depth BRAMs, LFC-max could achieve 2× throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Comparison to prior work</head><p>From an application perspective, we suggest that the current best way to compare different platforms is to simply compare their accuracy, FPS and power consumption when working on the same benchmark datasets (MNIST, CIFAR-10 and SVHN). This comparison is provided in Table <ref type="table" target="#tab_6">4</ref>, and is divided into three sections: our results, prior work on low-precision (&lt; 4 bits) networks, and prior work with higher-precision (&gt; 4 bits) networks.</p><p>When it comes to pure image throughput, our designs outperform all others. For the MNIST dataset, we achieve an FPS which is over 48/6× over the nearest highest throughput design <ref type="bibr" target="#b1">[1]</ref> for our SFC-max/LFC-max designs respectively. While our SFC-max design has lower accuracy than the networks implemented by Alemdar et al. <ref type="bibr" target="#b1">[1]</ref> our LFC-max design outperforms their nearest accuracy design by over 6/1.9× for throughput and FPS/W respectively. For other datasets, our CNV-max design outperforms TrueNorth <ref type="bibr" target="#b6">[6]</ref> for FPS by over 17/8× for CIFAR-10 / SVHN datasets respectively, while achieving 9.44× higher throughput than the design by Ovtcharov et al. <ref type="bibr" target="#b20">[20]</ref>, and 2.2× over the fastest results reported by Hegde et al. <ref type="bibr" target="#b9">[9]</ref>. Our prototypes have classification accuracy within 3% of the other low-precision works, and could have been improved by using larger BNNs.</p><p>A recent work by Nurvitadhi et al. <ref type="bibr" target="#b19">[19]</ref> compares binary matrix-vector operation performance and efficiency on FPGA, ASIC, GPU and CPU. Their results indicate that CPU and GPUs are severely underutilized for binary synaptic operations, and that FPGAs are only ∼8× less energy efficient than ASICs in this case. As they do not provide results on end-to-end network implementations, we do not include them in Table <ref type="table" target="#tab_6">4</ref>. Our 11.6 TOPS MFC prototype (Section 5.2.1) is 20% faster than the 9.6 TOPS reported in their work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>This work demonstrates the performance and energy efficiency potential of recently proposed BNNs for image classification. They are particularly well-suited for FPGA implementations as parameters can be fit entirely in OCM and arithmetic is simplified, enabling high computational performance. The novel parameterizable dataflow architecture and optimizations presented enable unprecedented classification rates, minimal power consumption and latency, while offering the flexibility of C++ design entry and the scalability required for accelerating larger and more complex networks. We hence believe that this technology is eminently suitable for embedded applications requiring real-time response, including surveillance, robotics and augmented reality. Future work will focus on providing support for non-binary low precision, implementing larger networks like AlexNet, higher performance convolutions, and a more thorough design space exploration. Finally, Finn assumes that all BNN parameters can fit into the available OCM of a single FPGA. Supporting external memory, multi-FPGAs implementations and reconfiguration <ref type="bibr" target="#b28">[28]</ref> could improve the utility of our approach. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Roofline model for a ZU19EG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Heterogeneous streaming architecture and schedule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: Three examples of binary neuron activations with batch normalization. A slight vertical offset is added for clarity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: Overview of the MVTU.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Convolution using interleaved channels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Neuron and synapse folding for MVTU.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: ZC706 roofline with topologies and max-datapoints.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Prototype energy efficiency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Mapping resource efficiency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Accuracy results -BNN vs floating point NN.</figDesc><table><row><cell></cell><cell></cell><cell>Binary</cell><cell></cell><cell>Float</cell></row><row><cell cols="2">Neurons/layer</cell><cell>Err. (%)</cell><cell></cell><cell>Err. (%)</cell><cell># Params</cell><cell>Ops/frame</cell></row><row><cell>128</cell><cell></cell><cell>6.58</cell><cell></cell><cell>2.70</cell><cell>134,794</cell><cell>268,800</cell></row><row><cell>256</cell><cell></cell><cell>4.17</cell><cell></cell><cell>1.78</cell><cell>335,114</cell><cell>668,672</cell></row><row><cell>512</cell><cell></cell><cell>2.31</cell><cell></cell><cell>1.25</cell><cell>932,362</cell><cell>1,861,632</cell></row><row><cell>1024</cell><cell></cell><cell>1.60</cell><cell></cell><cell>1.13</cell><cell>2,913,290</cell><cell>5,820,416</cell></row><row><cell>2048</cell><cell></cell><cell>1.32</cell><cell></cell><cell>0.97</cell><cell>10,020,874</cell><cell>20,029,440</cell></row><row><cell>4096</cell><cell></cell><cell>1.17</cell><cell></cell><cell>0.91</cell><cell>36,818,954</cell><cell>73,613,312</cell></row><row><cell></cell><cell cols="5">heterogeneously sized; tailored to compute requirements</cell></row><row><cell>on-chip</cell><cell cols="2">layer 1 compute array parameters</cell><cell></cell><cell>layer 2 compute array</cell><cell>layer 3 compute array parameters</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>parameters</cell></row><row><cell>off-chip</cell><cell>images</cell><cell></cell><cell cols="2">main memory</cell><cell>classifications</cell></row><row><cell></cell><cell></cell><cell cols="2">latency</cell><cell></cell></row><row><cell></cell><cell>read</cell><cell>read</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">compute 1</cell><cell cols="2">compute 1</cell></row><row><cell></cell><cell></cell><cell cols="2">compute 2</cell><cell cols="2">compute 2</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">compute 3</cell><cell>compute 3</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>write</cell><cell>write</cell></row><row><cell cols="3">initiation interval</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Summary of workloads.</figDesc><table><row><cell>Topology</cell><cell>Params</cell><cell>Ops</cell><cell>Off-chip I/O</cell><cell>Op.Int.</cell></row><row><cell></cell><cell>(Mbits)</cell><cell>(M)</cell><cell>(B)</cell><cell>(Ops/B)</cell></row><row><cell>SFC</cell><cell>0.3</cell><cell>0.6</cell><cell>112</cell><cell>5970</cell></row><row><cell>LFC</cell><cell>2.9</cell><cell>5.8</cell><cell>112</cell><cell>51968</cell></row><row><cell>CNV</cell><cell>1.5</cell><cell>112.5</cell><cell>3092</cell><cell>36400</cell></row><row><cell>Prototype</cell><cell></cell><cell cols="2">Per-Layer Total Fold (F )</cell><cell></cell></row><row><cell>SFC-max</cell><cell></cell><cell></cell><cell>13, 16, 16, 16</cell><cell></cell></row><row><cell>SFC-fix</cell><cell></cell><cell cols="2">12544, 16384, 16384, 2560</cell><cell></cell></row><row><cell>LFC-max</cell><cell></cell><cell></cell><cell>104, 128, 128, 128</cell><cell></cell></row><row><cell>LFC-fix</cell><cell></cell><cell cols="3">13312, 16384, 16384, 10240</cell></row><row><cell>CNV-max</cell><cell cols="4">8100, 7056, 5184, 7200, 5184, 4608, 8192, 8192, 1280</cell></row><row><cell>CNV-fix</cell><cell cols="4">16200, 14112, 10368, 14400, 10368, 9216, 16384, 16384, 1280</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Summary of results from Finn 200 MHz prototypes.</figDesc><table><row><cell>Name</cell><cell cols="3">Thr.put Latency LUT</cell><cell cols="2">BRAM P chip</cell><cell>P wall</cell></row><row><cell></cell><cell>(FPS)</cell><cell>(µs)</cell><cell></cell><cell></cell><cell>(W)</cell><cell>(W)</cell></row><row><cell>SFC-max</cell><cell cols="2">12361 k 0.31</cell><cell>91131</cell><cell>4.5</cell><cell>7.3</cell><cell>21.2</cell></row><row><cell>LFC-max</cell><cell cols="2">1561 k 2.44</cell><cell>82988</cell><cell>396</cell><cell>8.8</cell><cell>22.6</cell></row><row><cell>CNV-max</cell><cell>21.9 k</cell><cell>283</cell><cell>46253</cell><cell>186</cell><cell>3.6</cell><cell>11.7</cell></row><row><cell>SFC-fix</cell><cell>12.2 k</cell><cell>240</cell><cell>5155</cell><cell>16</cell><cell>0.4</cell><cell>8.1</cell></row><row><cell>LFC-fix</cell><cell>12.2 k</cell><cell>282</cell><cell>5636</cell><cell>114.5</cell><cell>0.8</cell><cell>7.9</cell></row><row><cell>CNV-fix</cell><cell>11.6 k</cell><cell>550</cell><cell>29274</cell><cell>152.5</cell><cell>2.3</cell><cell>10</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>The prototypes exhibit good runtime efficiency, with ∼70% for CNV, ∼80% for SFC and ∼90% for LFC. The efficiency can be increased further by fine-tuning the folding factors between different layers.</figDesc><table><row><cell>LUT/Ops/cycle</cell><cell>2 4 6 8</cell><cell>0</cell><cell>50</cell><cell>100</cell><cell>150</cell><cell>200 LUT efficiency 250 LUT efficiency BRAM usage</cell><cell>0 20 40 60</cell><cell>BRAMs</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">PE count</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>FPS•Ops F clk</cell><cell>) by the (peak) number</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">of synaptic operations per cycle from the design ( 2 • P • S).</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Evaluating the mapping efficiency directly on the proto-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>Comparison to prior work. Metrics not reported by prior work are indicated by dashes (-), and our estimates by ∼ .</figDesc><table><row><cell>Name</cell><cell>Dataset</cell><cell>Platform</cell><cell>Precision</cell><cell>Err. (%)</cell><cell>kFPS</cell><cell>P chip (W)</cell><cell>P wall (W)</cell><cell>kFPS/P chip</cell><cell>kFPS/P wall</cell><cell>GOPS</cell></row><row><cell>SFC-max</cell><cell>MNIST</cell><cell>ZC706</cell><cell>1</cell><cell>4.17</cell><cell>12,361</cell><cell>7.3</cell><cell>21.2</cell><cell>1693.29</cell><cell>583.07</cell><cell>8,265.45</cell></row><row><cell>LFC-max</cell><cell>MNIST</cell><cell>ZC706</cell><cell>1</cell><cell>1.60</cell><cell>1,561</cell><cell>8.8</cell><cell>22.6</cell><cell>177.39</cell><cell>69.07</cell><cell>9,085.67</cell></row><row><cell>MFC-max</cell><cell>MNIST</cell><cell>ZC706</cell><cell>1</cell><cell>2.31</cell><cell>6,238</cell><cell>11.3</cell><cell>28.5</cell><cell>552</cell><cell>218.8</cell><cell>11,612.86</cell></row><row><cell>CNV-max</cell><cell>CIFAR-10</cell><cell>ZC706</cell><cell>1</cell><cell>19.90</cell><cell>21.9</cell><cell>3.6</cell><cell>11.7</cell><cell>6.08</cell><cell>1.87</cell><cell>2,465.5</cell></row><row><cell>CNV-max</cell><cell>SVHN</cell><cell>ZC706</cell><cell>1</cell><cell>5.10</cell><cell>21.9</cell><cell>3.6</cell><cell>11.7</cell><cell>6.08</cell><cell>1.87</cell><cell>2,465.5</cell></row><row><cell>Alemdar et al. [1]</cell><cell>MNIST</cell><cell>Kintex-7 160T</cell><cell>2</cell><cell>2.24</cell><cell>255.10</cell><cell>0.32</cell><cell>-</cell><cell>806.45</cell><cell>-</cell><cell>∼96.68</cell></row><row><cell>Alemdar et al. [1]</cell><cell>MNIST</cell><cell>Kintex-7 160T</cell><cell>2</cell><cell>1.71</cell><cell>255.10</cell><cell>1.84</cell><cell>-</cell><cell>138.50</cell><cell>-</cell><cell>∼448.47</cell></row><row><cell>Alemdar et al. [1]</cell><cell>MNIST</cell><cell>Kintex-7 160T</cell><cell>2</cell><cell>1.67</cell><cell>255.10</cell><cell>2.76</cell><cell>-</cell><cell>92.59</cell><cell>-</cell><cell>∼864.03</cell></row><row><cell>Park and Sung [21]</cell><cell>MNIST</cell><cell>ZC706</cell><cell>3</cell><cell>-</cell><cell>70</cell><cell>4.98</cell><cell>-</cell><cell>14.06</cell><cell>-</cell><cell>∼210</cell></row><row><cell>TrueNorth [6]</cell><cell>CIFAR-10</cell><cell>TrueNorth</cell><cell>1</cell><cell>16.59</cell><cell>1.249</cell><cell>0.2044</cell><cell>-</cell><cell>6.11</cell><cell>-</cell><cell>-</cell></row><row><cell>TrueNorth [6]</cell><cell>SVHN</cell><cell>TrueNorth</cell><cell>1</cell><cell>3.34</cell><cell>2.526</cell><cell>0.2565</cell><cell>-</cell><cell>9.85</cell><cell>-</cell><cell>-</cell></row><row><cell>CaffePresso [9]</cell><cell>MNIST</cell><cell>Keystone-II</cell><cell>16</cell><cell>-</cell><cell>5</cell><cell>-</cell><cell>14</cell><cell>-</cell><cell>0.357</cell><cell>44.82</cell></row><row><cell>CaffePresso [9]</cell><cell>CIFAR-10</cell><cell>Keystone-II</cell><cell>16</cell><cell>-</cell><cell>10</cell><cell>-</cell><cell>14</cell><cell>-</cell><cell>0.714</cell><cell>146.14</cell></row><row><cell>CaffePresso [9]</cell><cell>MNIST</cell><cell>Parallella</cell><cell>32</cell><cell>-</cell><cell>0.64</cell><cell>-</cell><cell>5</cell><cell>-</cell><cell>0.129</cell><cell>5.78</cell></row><row><cell>CaffePresso [9]</cell><cell>CIFAR-10</cell><cell>Parallella</cell><cell>32</cell><cell>-</cell><cell>0.1</cell><cell>-</cell><cell>5</cell><cell>-</cell><cell>0.019</cell><cell>1.40</cell></row><row><cell>Ovtcharov et al. [20]</cell><cell>CIFAR-10</cell><cell>Stratix V D5</cell><cell>32</cell><cell>∼11-26</cell><cell>2.32</cell><cell>-</cell><cell>25</cell><cell>-</cell><cell>0.093</cell><cell>-</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We assume 4.8 GB/s off-chip memory bandwidth, 350 MHz clock and the following operation cost function:</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>2.5 LUTs for 1-bit, 40 LUTs for 8-bit, 8 LUTs and 0.5 DSPs for 16-bit.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors would like to thank the NTNU HPC lab and colleagues at Xilinx Research Labs for their support. This work was supported under the Australian Research Councils Linkage Projects funding scheme (project number LP130101034).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Ternary Neural Networks for Resource-Efficient AI Applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Alemdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Caldwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Leroy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Prost-Boucle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pétrot</surname></persName>
		</author>
		<idno>CoRR, abs/1609.00222</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">YodaNN: An ultra-low power convolutional neural network accelerator based on binary weights</title>
		<author>
			<persName><forename type="first">R</forename><surname>Andri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cavigelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
		<idno>CoRR, abs/1606.05487</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">High performance convolutional neural networks for document processing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chellapilla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Puri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Simard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFHR</title>
		<meeting>ICFHR</meeting>
		<imprint>
			<publisher>Suvisoft</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Eyeriss: A spatial architecture for energy-efficient dataflow for convolutional neural networks</title>
		<author>
			<persName><forename type="first">Y.-H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE ISCA</title>
		<meeting>ACM/IEEE ISCA</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Binarized Neural Networks: Training Deep Neural Networks with Weights and Activations Constrained to +1 or -1</title>
		<author>
			<persName><forename type="first">M</forename><surname>Courbariaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hubara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Soudry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>El-Yaniv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<idno>CoRR, abs/1602.02830</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Convolutional Networks for Fast, Energy-Efficient Neuromorphic Computing</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Esser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Merolla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Arthur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Cassidy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Appuswamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Andreopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Mckinstry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Melano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Barch</surname></persName>
		</author>
		<idno>CoRR, abs/1603.08270</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">CNP: An FPGA-based processor for convolutional networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Farabet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Poulet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE FPL</title>
		<meeting>IEEE FPL</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="32" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Deep Compression: Compressing Deep Neural Network with Pruning, Trained Quantization and Huffman coding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<idno>CoRR, abs/1510.00149</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">CaffePresso: An Optimized Library for Deep Learning on Embedded Accelerator-based platforms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hegde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Siddhartha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ramasamy</surname></persName>
		</author>
		<author>
			<persName><surname>Kapre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CASES</title>
		<meeting>CASES</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and&lt; 1MB model size</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Iandola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ashraf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
		<idno>CoRR, abs/1602.07630</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Batch normalization: Accelerating deep network training by reducing internal covariate shift</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ioffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICML</title>
		<meeting>ICML</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="448" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Bitwise neural networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Smaragdis</surname></persName>
		</author>
		<idno>CoRR, abs/1601.06071</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NIPS</title>
		<meeting>NIPS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1097" to="1105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Gradient-based learning applied to document recognition</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. of the IEEE</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2278" to="2324" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Artificial neural networks in hardware: A survey of two decades of progress</title>
		<author>
			<persName><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Saha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neurocomputing</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="239" to="255" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Semi-Automated Tool Flow for Roofline Anaylsis of OpenCL Kernels on Accelerators</title>
		<author>
			<persName><forename type="first">S</forename><surname>Muralidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>O'brien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lalanne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on H2RC</title>
		<meeting>Workshop on H2RC</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Reading digits in natural images with unsupervised feature learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Netzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Coates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bissacco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS Workshop on Deep Learning and Unsupervised Feature Learning</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Accelerating Binarized Neural Networks: Comparison of FPGA, CPU, GPU, and ASIC</title>
		<author>
			<persName><forename type="first">E</forename><surname>Nurvitadhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sheffield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Venkatesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFPT</title>
		<meeting>ICFPT</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Accelerating deep convolutional neural networks using specialized hardware</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ovtcharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ruwase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fowers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015-02">February 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">FPGA based implementation of deep neural networks using on-chip memory only</title>
		<author>
			<persName><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ICASSP</title>
		<meeting>IEEE ICASSP</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1011" to="1015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">XNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rastegari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ordonez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Redmon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Farhadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">O</forename><surname>Russakovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Satheesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karpathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khosla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fei-Fei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ImageNet Large Scale Visual Recognition Challenge. IJCV</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="211" to="252" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Deep learning in neural networks: An overview</title>
		<author>
			<persName><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Networks</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="85" to="117" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<idno>CoRR, abs/1409.1556</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Throughput-Optimized OpenCL-based FPGA Accelerator for Large-Scale Convolutional Neural Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Suda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dasika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mohanty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B K</forename><surname>Vrudhula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIGDA ISFPGA</title>
		<meeting>ACM/SIGDA ISFPGA</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="16" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Resiliency of deep neural networks under quantization</title>
		<author>
			<persName><forename type="first">W</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hwang</surname></persName>
		</author>
		<idno>CoRR, abs/1511.06488</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">fpgaConvNet: A Framework for Mapping Convolutional Neural Networks on FPGAs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename><surname>Venieris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Bouganis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE FCCM</title>
		<meeting>IEEE FCCM</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="40" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Planet -photo geolocation with convolutional neural networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Weyand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kostrikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Philbin</surname></persName>
		</author>
		<idno>CoRR, abs/1602.05314</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Roofline: an insightful visual performance model for multicore architectures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="65" to="76" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Optimizing FPGA-based accelerator design for deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIGDA ISFPGA</title>
		<meeting>ACM/SIGDA ISFPGA</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="161" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">DoReFa-Net: Training low bitwidth convolutional neural networks with low bitwidth gradients</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zou</surname></persName>
		</author>
		<idno>CoRR, abs/1606.06160</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
