<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Syntax and consistent equation semantics of hybrid Chi ୋ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Mechanical Engineering</orgName>
								<orgName type="department" key="dep2">TU/e)</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Man</surname></persName>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Department of Mathematics and Computer Science</orgName>
								<orgName type="department" key="dep2">TU/e)</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Department of Mathematics and Computer Science</orgName>
								<orgName type="department" key="dep2">TU/e)</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Mechanical Engineering</orgName>
								<orgName type="department" key="dep2">TU/e)</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">R</forename><forename type="middle">R H</forename><surname>Schiffelers</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Mechanical Engineering</orgName>
								<orgName type="department" key="dep2">TU/e)</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Syntax and consistent equation semantics of hybrid Chi ୋ</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">929F5097FD3A8531173D4912BBD957B3</idno>
					<idno type="DOI">10.1016/j.jlap.2005.10.005</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The hybrid χ (Chi) formalism integrates concepts from dynamics and control theory with concepts from computer science, in particular from process algebra and hybrid automata. It integrates ease of modeling with a straightforward, structured operational semantics. Its 'consistent equation semantics' enforces state changes to be consistent with delay predicates, that combine the invariant and flow clauses of hybrid automata. Ease of modeling is ensured by means of the following concepts: (1) different classes of variables: discrete and continuous, of subclass jumping or non-jumping, and algebraic; (2) strong time determinism of alternative composition in combination with delayable guards;</p><p>(3) integration of urgent and non-urgent actions; (4) differential algebraic equations as a process term as in mathematics; (5) steady-state initialization; and 6) several user-friendly syntactic extensions. Furthermore, the χ formalism incorporates several concepts for complex system specification: (1) process terms for scoping that integrate abstraction, local variables, local channels and local recursion definitions; (2) process definition and instantiation that enable process re-use, encapsulation, hierarchical and/or modular composition of processes; and (3) different interaction mechanisms: handshake synchronization and synchronous communication that allow interaction between processes without sharing variables, and shared variables that enable modular composition of continuous-time or hybrid processes. The syntax and semantics are illustrated using several examples.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Hybrid systems related research is based on two, originally different, world views: on the one hand the dynamics and control (DC) world view, and on the other hand the computer science (CS) world view.</p><p>The DC world view is that of a predominantly continuous-time system, which is modeled by means of differential (algebraic) equations, or by means of a set of trajectories. Hybrid phenomena are modeled by means of discontinuous functions and/or switched equation systems. The evolution of a hybrid system in the continuous-time domain is considered as a set of piecewise continuous functions of time (one for each variable).</p><p>Analysis and synthesis of hybrid systems in the DC domain are done, among others, by means of piecewise affine (PWA) systems, mixed logic dynamical (MLD) systems or linear complementarity (LC) systems, see <ref type="bibr" target="#b0">[1]</ref> for an overview relating these different classes, and see <ref type="bibr" target="#b1">[2]</ref> for a translation of PWA systems to hybrid χ (Chi). A different framework to consider hybrid systems are differential (algebraic) equations with discontinuous right-hand sides, the semantics of which can be defined using differential inclusions. Such differential inclusions allow modeling of relays, valves or any kind of on/off switching elements at a high level of abstraction in control systems with so-called sliding modes <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>.</p><p>The CS world view is that of a predominantly discrete-event system. A well-known model is a (hybrid) automaton, but modeling of discrete-event systems is also based on, among others, process algebra, Petri nets, and data flow languages. For modeling and analysis of hybrid phenomena, discrete-event formalisms are extended in different ways with some form of differential (algebraic) equations. The most influential hybrid system model is that of a hybrid automaton such as defined in <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref>. An essential difference between such a hybrid automaton and a DC hybrid system model is that where in the DC hybrid model there are no actions, in the hybrid automaton, discontinuities take place mainly by means of (labeled) actions. By means of actions, the hybrid automaton switches from one mode/location to another mode/location.</p><p>Clearly, hybrid systems represent a domain where the DC and CS world views meet, and we believe that a formalism that integrates the DC and CS world views is a valuable contribution towards integration of the DC and CS methods, techniques, and tools. The hybrid χ formalism is such a formalism. On the one hand, it can deal with continuous-time systems, PWA/MLD/LC systems, and hybrid systems based on sets of ordinary differential equations using discontinuous functions in combination with algebraic constraints (the DC approach). On the other hand, it can deal with discrete-event systems, without continuous variables or differential equations, and with hybrid systems in which discontinuities take place (mainly) by means of actions (the CS approach).</p><p>The intended use of hybrid χ is for modeling, simulation, verification, and real-time control. Its application domain ranges from physical phenomena, such as dry friction, to large and complex manufacturing systems. Although the semantics is formally defined, including a solution concept, the straightforward and elegant syntax and semantics is also highly suited to non-computer scientists. In the remainder of this paper, we usually refer to hybrid χ as χ .</p><p>The most important concepts in χ are summarized below:</p><p>(1) Integration between the DC and CS world views: • The DC world view in χ allows modeling of hybrid phenomena by means of discontinuous functions and/or switched equation systems. For this purpose, χ has introduced the category of algebraic variables, the trajectory of which can be discontinuous.</p><p>Furthermore, the convex equality operator, defined in <ref type="bibr" target="#b11">[12]</ref>, but not explained in detail in this paper, allows modeling of differential inclusions according to the Filippov solution concept <ref type="bibr" target="#b2">[3]</ref>. The solution concept has been formalized in χ . • The CS world view in χ allows modeling of hybrid phenomena in a way that is strongly influenced by hybrid automata. In this respect, the new hybrid χ formalism differs considerably from its predecessor defined in <ref type="bibr" target="#b12">[13]</ref> which was quite different from hybrid automata. In the χ formalism described in this paper, the 'consistent equation semantics' enforces changes in the values of variables to be consistent with delay predicates, that combine the invariant and flow clauses of hybrid automata. This is expressed by the property p || x = e ↔ p[e/x] || x = e, that, although not yet proven, we expect to hold. Here, || denotes parallel composition, x = e is a mathematical equation, p[e/x] denotes the process term obtained from p by substituting every free occurrence of variable x by its defining expression e, and p ↔ q means that the two process terms p and q are bisimilar, that is they have the same behavior. For example:</p><p>x := y || y = 1 is bisimilar to x := 1 || y = 1, where x := y denotes an assignment of the value of y to variable x. A difference between the consistent equation semantics and the semantics of hybrid automata is that where the χ semantics considers ẋ = 1 ∧ ẋ = 2 to be an inconsistent process term, the hybrid automaton can enter the location with flow clause ẋ = 1 ∧ ẋ = 2, but cannot delay in this location. The inconsistent process in a hybrid automaton is a location with invariant false. A translation from the hybrid automaton model defined in <ref type="bibr" target="#b7">[8]</ref> to χ can be found in <ref type="bibr" target="#b1">[2]</ref>. This translation assumes that the flow clauses of the hybrid automaton cannot evaluate to false.</p><p>(2) Integration of a straightforward semantics and ease of modeling. An important aspect is the conceptual similarity with hybrid automata as mentioned in the previous item. The concepts from hybrid automata have been extended in several ways to facilitate modeling. Where hybrid automata in general either have locations (e.g. <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref>) or discrete variables (e.g. <ref type="bibr" target="#b10">[11]</ref>), and in addition either jumping or non-jumping continuous variables, χ has, among others, the following categories of variables: • Discrete variables, which facilitate compact readable specifications. In hybrid automata such variables are sometimes mimicked by real valued variables with a derivative of zero. However, for non-real valued variables, such as variables of type string, the concept of a zero derivative cannot be used. • Jumping continuous variables, that correspond to the continuous variables of hybrid automata as defined in, for example, <ref type="bibr" target="#b7">[8]</ref>. The values of these variables are in principle allowed to jump (change) arbitrarily in an action transition, as long as the resulting values satisfy the action (jump) predicate, and the resulting process is consistent. Consider for example a system with three variables: x, y, z. If the value of x should change to 1, and the other variables should remain unchanged, the action (jump) predicate should be x = 1 ∧ y = y ∧ z = z, or x + = 1 ∧ y + = y -∧ z + = z -, depending on the syntax, where v and v + denote the value of variable v after execution of the action, and v and v -denote the value of variable v before execution of the action. Restrictions of the type v + = v -clutter the models, and are therefore often omitted in informal hybrid automata specifications. In order to allow fully formal models, without the clutter associated with the restrictions on non-jumping variables, χ has an additional class of variables: the non-jumping continuous variables.</p><p>• Non-jumping continuous variables, that correspond to the continuous variables of hybrid automata as defined by, for example, the input language of the tool HyTech <ref type="bibr" target="#b13">[14]</ref>. The values of these variables are not allowed to change in action transitions, unless their changes are explicitly specified, for example by means of assigning a new value to such a variable. • Algebraic variables, that can have discontinuous trajectories, as already discussed in the item on integration between the DC and CS world views.</p><p>Other concepts that enable integration of a straightforward semantics and ease of modeling are: • Strong time-deterministic alternative composition operator. Where in many process algebras the passage of time can result in making a choice between the two operands of the choice or alternative composition operator, in χ , the passage of time can never result in such a choice. In the case of weak time-determinism, the alternative composition ẋ = 1 [] x := 1 (other languages may use the + or ⊕ operators instead of []) can non-deterministically choose between doing a delay according to and resulting in ẋ = 1, or doing the (undelayable) action x := 1. Strong time deterministic alternative composition means that alternative composition can delay only if both process terms can delay together, so that ẋ = 1 [] x := 1 can only do the (non-delayable) action x := 1, and then terminate. Hybrid automata have a comparable choice mechanism, apart from initialization. In a hybrid automaton, action transitions cannot disappear as a result of time passing. They can only be disabled for the period of time that the associated guard evaluates to false in the valuation prescribed by the trajectory of the variables. Also, time passing cannot result in the choice of a different location. The only changes in a hybrid automaton as a result of time passing are changes in the values of the variables. Only initially, depending on the initial edges and invariants, different initial locations may be selected as a result of time passing. Note that this does not imply that the χ formalism (or a hybrid automaton) is time deterministic. In the case of equations with multiple solutions, such as in x 2 = 1, delaying can take place according to any of the allowed solutions. • Delayable guards. Where many process algebras have non-delayable guards, χ has delayable guards. A non-delayable guard cannot perform a delay when it is false. A delayable guard can delay when it is false until it becomes true, and thus facilitates modeling. Consider for example a valve α that must be switched on when the temperature T becomes bigger then T max . Using a delayable guard, this can be modeled simply by T ≥ T max → α := true. Delayable guards ensure that in b → h ! b, the value of expression b that is sent via channel h is always true. Note that h ! b can either do the send action, or delay for an arbitrary period of time. Non-delayable guards may lead to un-intuitive behavior, because the value of b that is sent may be false. Consider the process term:</p><formula xml:id="formula_0">x := 0; ( ẋ = 1 || (x ≤ 3 → h ! x [] 10) || 5; h ? y),</formula><p>where s can delay for t time-units (t ≤ s) to st, and 0 can terminate by means of an internal action.</p><p>Using non-delayable guards, the process term can perform the assignment, followed by a delay of at most 5, and after an internal action transforms into</p><formula xml:id="formula_1">ẋ = 1 || (h ! x [] 5) || h ? y.</formula><p>The guard that was true has disappeared at the start of the delay. If the communication via channel h takes place now, a value of 5 is sent, which does not conform to x ≤ 3.</p><p>Using delayable guards on the other hand, the process term can do the assignment followed by a delay of at most 3, and transforms into:</p><formula xml:id="formula_2">ẋ = 1 || (x ≤ 3 → h ! x [] 7) || 2; h ? y,</formula><p>where the value of x is 3. Communication is still not possible. After a delay of 2, followed by an internal action, the process term transforms into:</p><formula xml:id="formula_3">ẋ = 1 || (x ≤ 3 → h ! x [] 5) || h ? y,</formula><p>where the value of x is 5, and after another delay of 5 it transforms into:</p><formula xml:id="formula_4">ẋ = 1 || (x ≤ 3 → h ! x [] 0) || h ? y.</formula><p>The time-out takes place, leading to: ẋ = 1 || h ? y. Due to the delayable guard, that does not disappear while delaying, the communication does not take place, because the guard cannot be satisfied.</p><p>• Integrated urgent and non-urgent actions. Where most hybrid automata have non-urgent actions only, the χ formalism has both non-urgent actions and urgent actions. The concept of urgency is defined in a very flexible way: non-delayable actions are by definition urgent and delayable actions are non-urgent. This is achieved without any additional operators.</p><p>The concept of urgency is built into the individual parallel composition operator, alternative composition operator, and guard operator. Consider the non-delayable action x := 1. The following three process terms -ẋ = 1 || x := 1 -ẋ = 1 [] x := 1 -ẋ = 1 || x ≤ 0 → x := 1 can each execute only the action x := 1, assuming that the value of x is initially non-positive. Consider now the delayable action [x : <ref type="bibr">= 1]</ref>. The following three process terms</p><formula xml:id="formula_5">-ẋ = 1 || [x := 1] -ẋ = 1 [] [x := 1] -ẋ = 1 || x ≤ 0 → [x := 1]</formula><p>can each execute either the action x := 1 or perform a delay, assuming again that the value of x is initially non-positive.</p><p>Communication on channels can also be urgent and non-urgent as in Uppaal. This is achieved by means of an operator that partitions the set of channels into a set of urgent and a set of non-urgent channels. For the urgent channels, communication must take place as soon as it becomes possible, whereas for the non-urgent channels, no such preference for communication is assumed (see Section 2.4.8).</p><p>• Non-causal equations as in mathematics. Differential algebraic equations are process terms in hybrid χ . Therefore, they are modeled in χ in the same way as in mathematics. • Steady state initialization. Dynamical analysis of physical systems often starts in initial steady-state conditions. This means that the initial state is such that all derivatives are zero. In χ , steady state initialization can be easily expressed by means of the signal emission operator. For example, ẋ = 0 ẋ = -x + 1 represents the steady state initialization ( ẋ = 0 ) of model ẋ = -x + 1. This means that this model only allows behavior for the case that initially ẋ = 0 holds, which implies that the initial value of x must be 1. In general, steady state initialization is not possible in this way for hybrid automata, because initial edges and invariants are usually predicates over variables, not derivatives. However, when the equations are straightforward enough, the modeler can explicitly calculate steady state conditions. In the example, variable x could be initialized to 1.</p><p>• Syntactic extensions. Ease of modeling is further supported in χ by extension of the set of orthogonal core process terms with additional process terms for ease of modeling. These additional process terms are defined by means of a straightforward translation into the core process terms.</p><p>(3) Concepts for complex system specification: • Process terms for scoping that integrate abstraction, local variables, local channels and local recursion definitions. • Parameterized process definition and process instantiation that enable:</p><p>process re-use, and encapsulation, hierarchical and/or modular composition of processes. • CSP communication and synchronization concepts that allow synchronization and communication without sharing of variables. • Shared variables, that enable modular composition of continuous or hybrid processes.</p><p>The history of the χ formalism dates back quite some time. It was originally designed as a modeling and simulation language for specification of discrete-event, continuous-time or combined discrete-event/continuous-time models. The first simulator <ref type="bibr" target="#b14">[15]</ref>, however, was suited to discrete-event models only. The simulator was successfully applied to a large number of industrial cases, such as an integrated circuit manufacturing plant, a brewery, and process industry plants <ref type="bibr" target="#b15">[16]</ref>. Later, the hybrid language and simulator were developed <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18]</ref>. For the purpose of verification, the discrete-event part of the language was mapped onto the process algebra χ σ by means of a syntactical translation. The semantics of χ σ was defined using a structured operational semantics style (SOS), bisimulation relations were derived, and a model checker was built <ref type="bibr" target="#b18">[19]</ref>. In this way, verification of discrete-event χ models was made possible <ref type="bibr" target="#b19">[20]</ref>. The χ formalism defined in this paper integrates the modeling language and the verification formalism. It integrates, extends and improves the syntax and semantics defined in <ref type="bibr" target="#b20">[21]</ref> and <ref type="bibr" target="#b12">[13]</ref>.</p><p>The remainder of this paper is organized as follows. Section 2 describes the syntax and informal semantics of the χ formalism. In Section 3, the semantics of χ is formally specified. Several examples in Section 4 illustrate the use of the formalism. In Section 5, a notion of equivalence is defined, which is shown to be a congruence for all χ operators. Furthermore, some useful properties of closed χ process terms are given. Full proofs are presented in the appendices. Section 6 discusses related work, and Section 7 terminates with conclusions and points out directions of future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Syntax and informal semantics of the Chi formalism</head><p>This section presents a concise definition of the syntax and informal semantics of χ . The syntax definition is incomplete in the sense that the syntax of predicates, expressions, etc. is defined on a high level of abstraction. This is done because different implementations of χ , such as tools for simulation, verification, or real-time control, may impose different syntactical restrictions. The intention of this paper is to define the χ formalism that encompasses all different future tools without posing unnecessary syntactical restrictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Syntax of processes</head><p>A χ process is a triple p, σ, E , where p denotes a process term, σ denotes a valuation, and E denotes an environment. The syntax of process terms is introduced in Section 2.3. A valuation is a partial function from variables to values. Syntactically, a valuation is denoted by a set of pairs {x 0 → c 0 , . . . , x n → c n }, where x i denotes a variable and c i its value.</p><p>An environment E is a tuple (C, J, L, H, R), where C denotes the set of continuous variables, J denotes the set of jumping variables, L denotes the set of algebraic variables, H denotes the set of channels, and R denotes a recursion definition. A recursion definition is a partial function from recursion variables to process terms. Syntactically, a recursive process definition is denoted by a set of pairs {X 0 → p 0 , . . . , X m → p m }, where X i denotes a recursion variable and p i the process term defining it.</p><p>To ensure that the variables, channels and recursion variables occurring in χ processes are defined, each χ process p, σ, (C, J, L, H, R) must satisfy the following requirements:</p><p>• All variables occurring free in p or in the range of R must be either in the domain of σ , in set L, or in case of dotted variables ẋ, their undotted counterparts x must be in C. • All channels occurring free in p or in the range of R must be in H .</p><p>• All recursion variables occurring free in p or in the range of R must be in the domain of R. • The predefined variable time must be in the domain of σ , and not in any of the sets C, J , and L. • Finally, continuous variables must have a value: C ⊆ dom(σ ) \ {time}, jumping variables must be defined: J ⊆ (dom(σ ) \ {time}) ∪ L, and algebraic variables, recursion variables and the other variables must be disjoint: dom(σ</p><formula xml:id="formula_6">) ∩ L = ∅ and (dom(σ ) ∪ L) ∩ dom(R) = ∅.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Informal semantics of processes</head><p>The behavior of χ processes is defined in terms of actions and delays. Actions define instantaneous changes, where time does not change, to the values of variables. Delays involve the passing of time, where for all variables their trajectory as a function of time is defined. The valuation σ and the environment E, together define the variables that exist in the χ process and the variable classes to which they belong.</p><p>The variables are grouped into different classes with respect to the delay behavior and action behavior. With respect to the delay behavior, the variables are divided into the following classes:</p><p>• The discrete variables, the values of which remain constant while delaying.</p><p>• The continuous variables, the values of which change according to an absolutely continuous function of time while delaying. The values of continuous variables are further restricted by delay predicates, that are usually in the form of differential algebraic equations. • The dotted continuous variables, the values of which change according to an integrable, possibly discontinuous function of time while delaying. The relation between the dotted continuous variables and the continuous variables is explained in Section 3.3.2. • The algebraic variables, that behave in a similar way as continuous variables. The differences are that algebraic variables may change according to a discontinuous function of time, and algebraic variables are not allowed to occur as dotted variables.</p><p>• The predefined variable 'time', that denotes the current time.</p><p>With respect to the action behavior, the variables are divided into two classes: • The non-jumping variables, the values of which by default do not change in actions.</p><p>Such changes need to be explicitly specified. • The jumping variables, the values of which by default can jump to arbitrary values in actions. The values after jumping can be restricted by means of action predicates, send and receive process terms, or delay predicates (equations).</p><p>The discrete and continuous variable classes can be divided into jumping and nonjumping versions. For the other classes, such a division is not possible: the dotted continuous and algebraic variables are by definition jumping with respect to the action behavior, and the predefined variable time is by definition non-jumping.</p><p>Further explanation on the semantics of the behavior of the different classes of variables is found in Section 3.3.1 on the action predicate, in Section 3.3.2 on the delay predicate, in Section 3.3.3 on the send and receive process terms, and in Section 3.4.6 on parallel composition.</p><p>The valuation σ captures the values of those variables that are relevant for determining the future behaviors of a process. The domain of the valuation σ in a χ process p, σ, E consists of the discrete variables, the continuous variables, and the predefined non-jumping variable time. The dotted continuous variables and the algebraic variables are not included in the domain of σ , because their values depend only on the process term p, possibly together with the values of the other variables. The values of the dotted continuous and algebraic variables are included in the so called 'extended valuation'. This extended valuation is required, among others, to ensure consistency of χ processes.</p><p>The consistency requirement enforces constraints on χ processes comparable to invariants in hybrid automata. Informally, in χ , the delay predicates (equations) must always hold. Consistency ensures that in x := 1 || y = x, assuming that y is a jumping variable, the values of x and y are 1 after assigning 1 to x, independently of the initial value of y. Consistency also ensures that inconsistent processes cannot be reached, e.g. in x := 1 || x = 2, the assignment to x cannot be executed. In fact, in χ , only consistent processes can perform action or delay transitions, and the result of an action or delay transition is always a consistent process.</p><p>Consistency is related to extended valuations in the following way: a χ process p, σ, E is consistent with extended valuation ξ , where ξ is the valuation σ extended with the (valuation for the) algebraic and dotted variables as defined by environment E, if the delay predicates u in p and the predicates u of signal emission operators in p hold when evaluated in extended valuation ξ .</p><p>For a χ process p, σ, (C, J, L, H, R) , the combination of the variable classes for the delay and action behavior leads to the following classes of variables:</p><formula xml:id="formula_7">• The set of discrete variables D is dom(σ ) \ (C ∪ {time}), -the set of non-jumping discrete variables is D \ J , -the set of jumping discrete variables is D ∩ J . • The set of continuous variables is C,</formula><p>the set of non-jumping continuous variables is C \ J , the set of jumping continuous variables is C ∩ J . • The set of (jumping) dotted continuous variables is Ċ.</p><p>• The set of (jumping) algebraic variables is L.</p><p>• The predefined (non-jumping) variable denoting the current time is time.</p><p>Note that it is possible to have D ∩ J = ∅ and L ∩ J = ∅. Such jumping discrete or jumping algebraic variables can occur as an artefact of the parallel composition of a send and a receive process term, where the receive process term assigns the received value to a discrete or algebraic variable, see Sections 3.3.3 and 3.4.6. From a modeling perspective, discrete and algebraic variables are in principle never explicitly declared as jumping. Discrete variables are not declared as jumping, because their value is not determined by equations, and therefore their values need not change when the value of a variable occurring in an equation changes due to an action. Algebraic variables are not declared as jumping, because they are by definition jumping. In fact, there is no difference between the behavior of an algebraic variable that is in set J and one that is not in the set.</p><p>Consider, for example, the process n := 1 || y = n, {n → 0, time → 0}, (∅, ∅, {y}, ∅, ∅) consisting of the discrete variable n, the predefined variable time, the algebraic variable y, and no continuous variables. Initially, the value of n equals 0, and thus the value of y equals 0. After the assignment of 1 to n, the equation y = n should still hold, and thus the value of y jumps to 1. The process terms and operators used in this model, and their informal semantics are discussed in the Sections 2.3 and 2.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Syntax of process terms</head><p>Process terms p ∈ P (without p ext ∈ P ext , see the table below) are the 'core' elements of the χ formalism. In Section 2.5, the syntax of χ process terms is extended with process terms P ext to ensure better readability of χ models. The semantics of those process terms is defined in terms of the core process terms given in this section.</p><p>The set of process terms P is defined by the following grammar for the process terms p ∈ P :</p><formula xml:id="formula_8">p::= W : r l a | u | δ | ⊥ | [p] | u p | p; p | b → p | p [] p | p || p | h !! e n | h ?? x n | ∂ A (p) | υ H (p) | X | ι J + (p) | |[ V σ ⊥ , C, L '|'p ]| | |[ H H '|'p ]| | |[ R R '|'p ]| | p ext</formula><p>Here, r is a predicate over variables (including the variable time), dotted continuous variables, and ' -' superscripted variables (including the dotted variables, e.g. ẋ). The action label l a is taken from a given set A label which at least contains the special action label τ representing the internal or silent step. Furthermore, u and b are both predicates over variables (including the variable time) and dotted continuous variables; e n denotes the expressions e 1 , . . . , e n , and x n denotes the (non-dotted) variables x 1 , . . . , x n such that time ∈ {x n }. For n = 0, h !! e n and h ?? x n denote h !! and h ??, respectively, where h is a channel. Finally, A is a set of actions, H is a set of channels, X is a recursion variable, R is a recursion definition as defined in Section 2.1, W , J + , C, L are sets of (non-dotted) variables such that time ∈ W and time ∈ J + , and σ ⊥ is a valuation that also allows the undefined 'value' ⊥. It is specified as {x 0 → c 0 , . . . , x n → c n }, where x i denotes a variable and c i a value or ⊥.</p><p>As is common practice in mathematics, the comma in predicates denotes conjunction. E.g. u 1 , u 2 denotes the predicate u 1 ∧ u 2 . Also, both e 1 ≤ ẋ ≤ e 2 and ẋ ∈ [e 1 , e 2 ] can be used instead of ẋ ≥ e 1 , ẋ ≤ e 2 , and likewise for strict inequalities and open intervals.</p><p>The operators are listed in descending order of their binding strength as follows { , → }, ; , {|| , []}. The operators inside the braces have equal binding strength. In addition, operators of equal binding strength associate to the right, and parentheses may be used to group expressions. For example, p; q ; r means p; (q ; r). An informal, concise explanation of this syntax is given below. Section 3 gives a more detailed account of their meaning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Informal semantics of process terms</head><p>Strictly speaking, a χ process term p cannot perform actions nor delays. Only the χ process p, σ, E , that is obtained by adding a valuation and an environment to p, can, in principle, perform actions and delays. Therefore, when we informally refer to a process term that performs actions or delays, we refer to the process term together with a valuation and environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1.">Manipulating the values of variables</head><p>In χ , there are several classes of variables, and there are several means to change the value of a variable, depending on the class of variable. The main means for changing the value of a variable are the action predicate, for instantaneous changes, and the delay predicate, for the changes of variables over time.</p><p>Action predicates. An instantaneous change of the value of a discrete or continuous variable in χ is always connected to the execution of an action. In action predicates, the action is represented by a label. Other types of action are related to communication, which is treated below in the paragraph on parallelism. Action predicate W : r l a denotes instantaneous changes to the variables from set W , by means of an action labeled l a , such that predicate r is satisfied. The predefined global variable time cannot be assigned. The non-jumping variables that are not mentioned in W remain unchanged, and the jumping variables, dotted continuous variables, and algebraic variables may obtain 'arbitrary' values, provided that the predicate r is satisfied and the process remains consistent.</p><p>A ' -' superscripted occurrence of a variable refers to the value of the variable in the extended valuation prior to execution of the action predicate, and a normal (un-superscripted) occurrence of a variable refers to the value of that variable in the extended valuation that results from the execution of the action predicate. A predicate r is satisfied if evaluating the ' -' superscripted variables in the original extended valuation and evaluating the normal occurrences of the variables in the obtained extended valuation means that the predicate is true. The reason to use an extended valuation for evaluating action predicate r is that in such predicates also algebraic and dotted continuous variables may be used. Note that it can be the case that different instantaneous changes satisfy the predicate, this may result in non-determinism.</p><p>Note that the (multi-)assignment is not a primitive in χ, as for example in <ref type="bibr" target="#b18">[19]</ref>. This is because action predicates are more expressive than assignments. An assignment can be expressed as an action predicate (see Section 2.5.2), but not the other way around. Consider for example the action predicate {x} : x ∈ [0, 1] τ , that changes the value of x to a value in the interval [0, 1]. Also, the predicate of an action predicate may consist of a conjunction of implicit equations, e.g. {x} :</p><formula xml:id="formula_9">f 1 (x -, x) = 0 ∧ • • • ∧ f n (x -, x) = 0</formula><p>τ . The solution of such a system of equations, if present, need not always be expressible in an explicit form. The system may also have multiple solutions.</p><p>Delay predicates. In principle, continuous and algebraic variables change arbitrarily over time when delaying, although, depending on the class of the variable, they may have to respect some continuity requirements, see Section 3.3.2 for more details. A delay predicate u, usually in the form of a differential algebraic equation, restricts the allowed behavior of the continuous and algebraic variables in such a way that the value of the predicate remains true over time. Delay predicates in the form of x ≥ e, where x is a variable, e an expression, and instead of ≥, also ≤, &gt;, &lt; can be used, are comparable to invariants in hybrid automata.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2.">Deadlock and inconsistency</head><p>In χ , only consistent processes can do action or delay transitions, and the result of an action or delay transition is always a consistent process. Some process terms are consistent for certain valuations and inconsistent for other valuations. E.g. the delay predicate process term x ≥ 0 is consistent for all values of x greater or equal to zero, and inconsistent otherwise. There are also process terms that are consistent or inconsistent for all valuations. The inconsistent process term ⊥ is inconsistent for all valuations. It cannot perform any transition.</p><p>The deadlock process term δ cannot perform actions or delays. It is however consistent. Both process terms are needed for the specification of properties only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.3.">Any delay operator</head><p>Besides the specification of delay by means of delay predicates, arbitrary delay can be described by means of the any delay operator <ref type="bibr">[p]</ref>. The resulting behavior is such that arbitrary delays are allowed. When [p] delays, p remains unchanged and its delay behavior is ignored. The action behavior of p remains unchanged in [p].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.4.">Signal emission</head><p>Signal emission operator process term u p behaves as p for those extended valuations where u holds. The process term is inconsistent with extended valuations for which u does not hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.5.">Sequential composition</head><p>The sequential composition of process terms p and q behaves as process term p until p terminates, and then continues to behave as process term q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.6.">Conditional</head><p>The guarded process term b → p can do whatever actions p can do under the condition that the guard b evaluates to true using the current extended valuation. The guarded process term can delay according to p under the condition that for the intermediate extended valuations during the delay, the guard b holds. The guarded process term can perform arbitrary delays under the condition that for the intermediate valuations during the delay, possibly excluding the first and last valuation, the guard b does not hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.7.">Choice</head><p>The alternative composition operator [] allows a non-deterministic choice between different actions of a process. With respect to time behavior, the participants in the alternative composition have to synchronize. This means that the trajectories of the variables have to be agreed upon by both participants. This means that [] is a strong time-deterministic choice operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.8.">Parallelism</head><p>Parallelism can be specified by means of the parallel composition operator || . Parallel processes interact by means of shared variables or by means of synchronous point-to-point communication/synchronization via a channel. Channels are denoted as labels (identifiers). The parallel composition p || q synchronizes the time behavior of p and q, interleaves the action behavior (including the instantaneous changes of variables) of p and q, and synchronizes matching send and receive actions. The synchronization of time behavior means that only the time behaviors that are allowed by both p and q are allowed by their parallel composition. The consistent equation semantics of χ enforces that actions by p (or q) are allowed only if the values of the variables before and after the actions are consistent with the other process term q (or p). This means, among others, that the delay predicates of q must hold before and after execution of an action by p.</p><p>By means of the send process term h !! e 1 , . . . , e n , for n ≥ 1, the values of expressions e 1 , . . . , e n (evaluated w.r.t. the extended valuation) are sent via channel h. For n = 0, this reduces to h !! and nothing is sent via the channel. By means of the receive process term h ?? x 1 , . . . , x n , for n ≥ 1, values for x 1 , . . . , x n are received from channel h. We assume that all variables in x n are different: x i = x j ⇒ i = j . For n = 0, this reduces to h ??, and nothing is received via the channel. Communication in χ is the sending of values by one parallel process via a channel to another parallel process, where the received values (if any) are stored in variables. For communication, the acts of sending and receiving (values) have to take place in different parallel processes at the same moment in time. In case no values are sent and received, we refer to synchronization instead of communication.</p><p>In order to be able to model open systems (i.e. systems that interface with the environment), it is necessary not to enforce communication via the external channels of the model (e.g. the channels that send or receive from the environment). For communication via internal channels, however, the communication of matching send and receive actions, often is not only an option, but an obligation. In such models, the separate occurrence of the send action and the receive action via an internal channel is undesired. The encapsulation operator ∂ A , where A ⊆ A \ {τ } is a set of actions (A is the set of all possible actions and τ is the predefined internal action), is introduced to block the actions from the set A. In order to assure that, for internal channels, only the synchronous execution of matching send and receive actions takes place, one can simply put all send and receive actions via internal channels in the set A.</p><p>In principle the channels in χ are non-urgent. This means that communication does not necessarily take place as soon as possible. In order to describe also urgent channels, the urgent communication operator υ H (p), where H ⊆ H is a set of channel labels, ensures that p can only delay in case no communication or synchronization of send and receive actions via a channel from H is possible.</p><p>Note that a different kind of urgency can be achieved by means of undelayable process terms. The χ semantics ensures that actions of undelayable process terms have priority over delays. For example in ẋ = 1 || x := 1 and ẋ = 1 [] x := 1, the assignment cannot delay. Therefore, it must be executed before a delay is possible. Also in h !! || ẋ = 1, or h !! || h ??, or h !! || [h ??], the parallel composition cannot delay because h !! cannot delay. Therefore, a send action must be executed before a delay may be possible. Process term</p><formula xml:id="formula_10">[h !!] || [h ??],</formula><p>however, can do a communication action (or send or receive action), but it can also delay. To enforce the communication action to take place in such case, the urgent communication operator can be used:</p><formula xml:id="formula_11">υ {h} ([h !!] || [h ??]).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.9.">Recursive definitions</head><p>Process term X denotes a recursion variable (identifier) that is defined either in the environment of the process, or in a recursion scope operator process term |[ R . . . | p ]|, see below. Among others, it is used to model repetition. Recursion variable X can do whatever the process term of its definition can do.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.10.">Jump enabling operator</head><p>Jump enabling operator ι J + (p), where J + denotes a set of variables, is used to (re)define the variables in set J + as jumping variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.11.">Hierarchical modeling</head><p>Thus far, it has been assumed that all variables that are allowed to occur in a χ process term are either declared in the valuation or in the environment (in the set L). To support the hierarchical modeling of systems, it is convenient to allow local declarations of variables. For this purpose, the variable scope operator process term </p><formula xml:id="formula_12">|[ V σ ⊥ , C, L | p ]| is introduced,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Syntactic extensions</head><p>For many of the χ processes, process terms and operators introduced before, there is additional, more user-friendly syntax available, the so-called syntactic extensions. In this section, all of these syntactic extensions are expressed in terms of the syntax introduced in the previous sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1.">Processes</head><p>Notation</p><formula xml:id="formula_13">disc s 1 , . . . , s k , cont x 1 , . . . , x n , alg z 1 , . . . , z m , chan h 1 , . . . , h l , i , X 1 → p 1 , . . . , X r → p r | p ,</formula><p>where s 1 ,. . .,s k denote the discrete variables, x 1 ,. . .,x n denote the non-jumping continuous variables, z 1 , . . . , z m denote the algebraic variables, h 1 , . . . , h l denote the urgent channels, i denotes an initialization predicate that restricts the allowed values of the variables initially, X 1 → p 1 , . . . , X r → p r denote the recursion definitions, and p is a process term, is an abbreviation for the set of χ processes defined by:</p><formula xml:id="formula_14">∂ A ia (υ {h 1 ,...,h l } ((i ∧ time = 0) p)) , σ sxt , ( {x 1 , . . . , x n } , ∅ , {z 1 , . . . , z m } , {h 1 , . . . , h l } , {X 1 → p 1 , . . . , X r → p r } ) ,</formula><p>namely for each valuation σ sxt , with dom(σ sxt ) = {s 1 , . . . , s k , x 1 , . . . , x n , time}, a separate χ process. In the χ process, A ia represents the internal send and receive actions via channels h 1 , . . . , h l .</p><p>In the notation defined above, it is required that the discrete, continuous, and algebraic variables are all different. Besides the declared variables, the existence of the predefined reserved global variable time which denotes the current time, the value of which is initially zero, is assumed. This variable cannot be declared. It can only be used in expressions in process term p, or in p 1 , . . . , p r .</p><p>As a shorthand, the keyword preceding variables of a certain type is omitted when there are no variables of that type, and the keyword chan is omitted when there are no channel declarations. Also the initialization predicate i and the recursive definitions X 1 → p 1 , . . . , X r → p r may be omitted, indicating a predicate that always holds and an empty list of recursive definitions, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.2.">Process terms</head><p>For many of the core process terms introduced before, there is additional, more userfriendly syntax available. The set of process terms P ext is defined by the following grammar for the process terms p ext ∈ P ext and p ∈ P :</p><formula xml:id="formula_15">p ext ::= skip | x n := e n | h ! e n | h ? x n | d (p) | d | * p | b * → p | (jump y m '|'p) | |[ disc s k , cont x n , alg z l , chan h m , i, L R '|'p ]| | l p (x k , h m , e n )</formula><p>The operators of p and p ext are listed in descending order of their binding strength as follows: { * , * → , , → }, ; , {|| , []}. Skip. Process term skip is an abbreviation for an action predicate that can perform an internal action (τ ), such that only the jumping variables can change.</p><p>skip ∅ : true τ Multi-assignment. Multi-assignment x n := e n for n ≥ 1 is an abbreviation for an internal action that changes variables x 1 , . . . , x n to the values of expressions e 1 , . . . , e n , respectively. For n = 1, this gives an assignment x := e.</p><p>x n := e n {x n } :</p><formula xml:id="formula_16">x 1 = e - 1 ∧ • • • ∧ x n = e - n τ</formula><p>Here e -denotes the result of replacing all variables x i in e by their ' -' superscripted version x - i . For example, process term x := 2x + yz is defined as {x} : x = 2x -+ y -z - τ , and process term x, y := x + y, xy is defined as {x, y} :</p><formula xml:id="formula_17">(x = x -+ y -) ∧ (y = x --y -) τ .</formula><p>Delayable send and receive. Process terms h ! e n , and h ? x n are the respective delayable counterparts of h !! e n and h ?? x n . They are defined by means of the any delay operator [p], which adds arbitrary delay behavior to p.</p><formula xml:id="formula_18">h ! e n [h !! e n ] h ? x n [h ?? x n ]</formula><p>Delay operators. By means of the delay operator d (p), a process term is forced to delay for the amount of time units specified by the value of numerical expression d, and then proceeds as p. The abbreviation d denotes a process term that first delays for d time units, and then terminates by means of an internal action τ . The fact that process term d terminates by means of an action ensures that time-outs enforce a choice in alternative composition. The value of expression d is evaluated at the first delay or action by d.</p><formula xml:id="formula_19">d (p) |[ V {t → ⊥}, ∅, ∅ | t = time + d time ≥ t → p ]| d d (skip)</formula><p>In the definition of d (p), t denotes a fresh variable, not occurring free in p. Delays are only defined for non-negative values of d. Therefore, we assume that the value of d in the extended valuation is non-negative.</p><p>Repetition operators. Process term * p represents the infinite repetition of process term p. Guarded repetition b * → p can be interpreted as 'while b do p'.</p><formula xml:id="formula_20">* p |[ R {X → p; X} | X ]| b * → p |[ R {X → b → skip; p; X [] ¬b → skip} | X ]|</formula><p>In </p><formula xml:id="formula_21">|[ disc s k , cont x n , alg z l , chan h m , i , L R | p ]| |[ V σ sx , {x 1 , . . . , x n } , {z 1 , . . . , z l } | |[ H {h 1 , . . . , h m } | υ {h 1 ,...,h m } (|[ R {L R } | i p ]|) ]| ]|</formula><p>Here L R denotes the recursion definitions X 1 → p 1 , . . . , X r → p r , σ sx denotes a valuation with dom(σ sx ) = {s 1 , . . . , s k , x 1 , . . . , x n }, and σ sx is undefined for all elements from its domain:</p><formula xml:id="formula_22">∀ v∈dom(σ sx ) σ sx (v) = ⊥.</formula><p>In a similar way as defined for χ processes, the keyword preceding variables of a certain type is omitted when there are no variables of that type, and the keyword chan is omitted when there are no local channel declarations. Also the initialization predicate i and the recursion definitions may be omitted, indicating a predicate that always holds and an empty list of recursion definitions, respectively.</p><p>Process instantiation. Process instantiation process term l p (x k , h m , e n ), where l p denotes a process label, enables (re)-use of a process definition. A process definition is specified once, but it can be instantiated many times, possibly with different parameters: external variables x k , external channels h m , and expressions e n .</p><p>Chi specifications in which process instantiations l p (x k , h m , e n ) are used have the following structure:</p><formula xml:id="formula_23">pd 1 . . . pd j disc . . . , cont . . . , alg . . . , chan . . . , i, L R | q ,</formula><p>where for each process instantiation l p (x k , h m , e n ) occurring in process term q, a matching process definition pd j of the form</p><formula xml:id="formula_24">l p (ext x k , chan h m , val v n ) = p</formula><p>must be present among the j process definitions pd 1 . . . pd j . Here l p denotes a process label, x k denotes the 'actual external' variables x 1 , . . . , x k , h m denotes the 'actual external' channels h 1 , . . . , h m , e n denotes the expressions e 1 , . . . , e n , x k denotes the 'formal external' variables x 1 , . . . , x k , h m denotes the 'formal external' channels h 1 , . . . , h m , and v n denotes the 'value parameters' v 1 , . . . , v n .</p><p>The only free variables and free channels that are allowed in process term p are the formal external variables x k , the formal external channels h m , and the value parameters v n . We assume that the formal external variables x k and the value parameters v n are different.</p><p>Formally, the syntactic translation of process instantiation</p><formula xml:id="formula_25">l p (x k , h m , e n )</formula><p>with corresponding process definition</p><formula xml:id="formula_26">l p (ext x k , chan h m , val v n ) = p is given by |[ V {v 1 → ⊥, . . . , v n → ⊥}, ∅, ∅ | v n = w n p ]| [x k , h m , e n /x k , h m , w n ].</formula><p>Notation p[x k , h m , e n /x k , h m , w n ] denotes the process term obtained from p by substitution of the (free) variables x k by x k , of the (free) channels h m by h m , and of the (free) variables w n by expressions e n .</p><p>The variables w n are assumed to be fresh with respect to x k and v n . The substitution is defined in such a way that no variables from x k or e n , and no channels from h m become bound. If substitution would cause new bindings, the local variable or local channel that a variable or channel from x k , e n , or h m would become bound to, is renamed into a fresh variable or fresh channel before the substitution takes place.</p><p>The translation declares the value parameters v n as local discrete variables with initial values e n . By convention, however, process term p normally does not change the values of these variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.">Data types</head><p>The χ formalism is statically strongly typed. Besides the classification of variables as defined before, all variables have a type. The type of a variable defines the allowed values of the variable and the allowed operations on the variable. The atomic types are nat (natural numbers, including zero), int (integers), real (real-valued numbers), bool (booleans), string (strings), and enum (enumerations). Type constructors operate on existing types to create structured types. The χ formalism defines type constructors to create sets, lists, array tuples, record tuples, dictionaries, functions, and distributions (for stochastic models). Channels also have a type that indicates the type of data that is communicated via the channel. Pure synchronization channels, that do not communicate data, are of the predefined type void. The χ type system is strictly enforced in the χ tools. However, since the type system is not formalized, it is omitted from the specifications in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Semantics of the Chi formalism</head><p>This section presents the structured operational semantics (SOS <ref type="bibr" target="#b21">[22]</ref>) of χ . It associates a hybrid transition system <ref type="bibr" target="#b22">[23]</ref> with a χ process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">General description of the SOS</head><p>The main purpose of such an SOS is to define the behavior of χ processes at a certain chosen level of abstraction. The meaning of a χ process depends on the values of the variables and on the environment. A set V of variables, and a set H of channel labels are assumed. The values of the variables at a specific moment in time are captured by means of a valuation, i.e., a partial function from the variables to the set of values (containing at least the booleans B and the reals R). The set of all valuations is denoted : = V → , and we assume σ ∈ for all χ processes p, σ, E . Extended valuations also include the values of dotted continuous variables and the algebraic variables. The set of all extended valuations is denoted ˙ : ˙ = (V ∪ V) → , where V denotes the set of all dotted variables. The set T is used to represent points in time; usually T = R ≥0 . The set of environments E is defined as E = P(V) × P(V) × P(V) × P(H) × R, where R = X → P denotes the set of all partial functions of recursion variables X to process terms P .</p><p>The SOS is chosen to represent the following:</p><p>(1) Discrete behavior by means of action transitions:</p><formula xml:id="formula_27">(a) _ _ -→ _ ⊆ (P × × E) × ( ˙ × A × ˙ ) × (P × × E)</formula><p>, where A denotes the set of actions, and is defined as A = A label ∪ A com . The set of action labels A label includes at least the pre-defined internal action τ . The set of communication actions A com is defined as</p><formula xml:id="formula_28">A com = {isa(h, cs), ira(h, cs, W ), ca(h, cs) | h ∈ H, cs ∈ * , W ⊆ V},</formula><p>where isa, ira, and ca denote action labels for the internal send action, the internal receive action, and the communication action respectively, h ∈ H denotes a channel, cs ∈ * denotes a list [c 1 , . . . , c n ] of values, and W denotes a set of variables. The intuition of an action transition p, σ, E ξ,a,ξ -→ p , σ , E is that the process p, σ, E executes the discrete action a ∈ A with extended valuations ξ and ξ and thereby transforms into the process p , σ , E , where σ and E denote the accompanying valuation and environment of the process term p , respectively, after the discrete action a is executed. -→ p , σ , E : dom(σ ) ⊆ dom(ξ ), dom(ξ ) = dom(ξ ), extended valuation ξ restricted to dom(σ ) equals valuation σ , and extended ξ restricted to dom(σ ) equals valuation σ .</p><formula xml:id="formula_29">(b) _ _ -→ , _, _ ⊆ (P × × E) × ( ˙ × A × ˙ ) × ( × E).</formula><p>• For all time transitions p, σ, E t,ρ -→ p, σ , E : dom(ρ) = [0, t], and for all variables x ∈ dom(σ ), the value in the resulting valuation σ (x) equals the value of the variable in the end-point of the trajectory ρ(t)(x).</p><p>• For all consistency predicates p, σ, E ξ : extended valuation ξ restricted to dom(σ ) equals valuation σ . The relations and predicates mentioned above are defined through so-called deduction rules. A deduction rule is of the form H r , where H is a number of hypotheses separated by commas and r is the result of the rule. The result of a deduction rule can be derived if all of its hypotheses are derived. In case the set of hypotheses is empty, the deduction rule is called an axiom.</p><p>In order to increase the readability of the χ deduction rules, some additional abbre- </p><formula xml:id="formula_30">viations are used. Notation E p, σ ξ,a,ξ -→ q, σ , where q ∈ P ∪ { } is an abbrevia- tion for p, σ, E ξ,a,ξ -→ q, σ , E , notation E p, σ t,ρ -→ q, σ is an abbreviation for p, σ, E t,ρ -→ q, σ</formula><formula xml:id="formula_31">-→ q, σ or p, σ t,ρ -→ q, σ or p, σ ξ ) is an abbreviation for E f 1 , . . . , E f n . Notation E p 1 , σ 1 ξ 1 ,a 1 ,ξ 1 -→ q 11 . . . q 1n , σ 1 , . . . , p m , σ m ξ m ,a m ,ξ m -→ q m1 . . . q mn , σ m , C E r, σ ξ,b,ξ -→ s 1 . . . s n , σ</formula><p>where q j i , s i ∈ P ∪ { }, p i , r ∈ P , and C denotes an optional hypothesis that must be satisfied in the deduction rule, is an abbreviation for the following rules (one for each i):</p><formula xml:id="formula_32">E p 1 , σ 1 ξ 1 ,a 1 ,ξ 1 -→ q 1i , σ 1 , . . . , p m , σ m ξ m ,a m ,ξ m -→ q mi , σ m , C E r, σ ξ,b,ξ -→ s i , σ</formula><p>The notation H R , where R is a number of results separated by commas, is an abbreviation for a set of deduction rules of the form H r ; one for each r ∈ R, and notation</p><formula xml:id="formula_33">E H r is an abbreviation for E H E r . Furthermore, notation p, σ, E ca(h, * ) denotes ( ξ,cs,ξ ,p ,σ ,E p, σ, E ξ,ca(h,cs),ξ -→ p , σ , E ) ∧ ( ξ,cs,ξ ,σ ,E p, σ, E ξ,ca(h,cs),ξ -→ , σ , E ), and notation p, σ, E α -→ p , σ , E is an abbreviation for p, σ, E ξ,a,ξ</formula><p>-→ p , σ , E for some ξ , a, and ξ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Notations and mathematical definitions</head><p>Notations f ∈ M → G and g ∈ M → G define complete function f , dom(f ) = M, and partial function g, dom(g) ⊆ M, both with range G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1.">Operators on functions</head><p>Based on <ref type="bibr" target="#b9">[10]</ref>, the following definitions of operators , ∪, and ↓ applied on functions are used. If f is a function, dom(f ) and range(f ) denote the domain and range of f , respectively. If S is a set, f S denotes the restriction of f to S, that is, the function g with dom(g) = dom(f ) ∩ S, such that g(c) = f (c) for each c ∈ dom(g).</p><p>If f and g are functions with dom(f</p><formula xml:id="formula_34">) ∩ dom(g) = ∅, then f ∪ g denotes the unique function h with dom(h) = dom(f ) ∪ dom(g) satisfying the condition: for each c ∈ dom(h), if c ∈ dom(f ) then h(c) = f (c), and h(c) = g(c) otherwise.</formula><p>If f is a function whose range is a set of functions and S is a set, then f ↓ S denotes the function g with dom(g) = dom(f ) such that g(c) = f (c) S for each c ∈ dom(g). If f is a function whose range is a set of functions, all of which have a particular element d in their domain, then f ↓ d denotes the function g with dom(g</p><formula xml:id="formula_35">) = dom(f ) such that g(c) = f (c)(d) for each c ∈ dom(g).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2.">Notations</head><p>Let x ∈ V be a variable, S, C, L ⊆ V be sets of variables, σ ∈ be a valuation, e be an expression over variables and constants, and t ∈ T be a time-point, then the following notations are defined:</p><p>• σ (x) denotes the value of variable x in valuation σ . We use the similar notation σ (e).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Ṡ denotes the set of dotted variables</head><formula xml:id="formula_36">{ ẋ | x ∈ S}. • ξ ĊL ∈ ( Ċ ∪ L) → denotes an arbitrary valuation with domain Ċ ∪ L. • ξ σ is an abbreviation for ξ dom(σ ). • Function ∈ ( × P(V) × P(V) × P(V)) → P( ˙ ) returns a set of extended valuations,</formula><p>given a valuation, the set of continuous variables, the set of jumping variables, and the set of algebraic variables. Formally, function is defined as:</p><formula xml:id="formula_37">(σ, C, J, L) = {ξ | dom(ξ ) = dom(σ ) ∪ Ċ ∪ L, ∀ x∈dom(σ )\J ξ(x) = σ (x)}.</formula><p>The values of the variables in ξ are defined as follows: the values of the variables in dom(σ ) \ J are given by σ . The jumping variables J , the dotted variables Ċ and the algebraic variables L have arbitrary values. • σEt , where environment E denotes the tuple (C, J, L, H, R), is an abbreviation for FG (σ, C, L, true, t). Here, FG is the solution function as defined in Section 3.3.2.</p><p>• ρ σ is an abbreviation for ρ ↓ dom(σ ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Deduction rules for atomic process terms</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1.">Action predicate</head><p>Action predicate process term W : r l a denotes instantaneous changes to the variables from set W , by means of an action labeled l a ∈ A label , such that predicate r over variables from the domains of the extended valuations ξ -and ξ is satisfied, see Rule 1, where ξ, ξ ∈ (dom(σ ) ∪ Ċ ∪ L) → , and ξ -is defined below.</p><p>The values of the variables from dom(σ ) in ξ are given by σ . The dotted variables Ċ and the algebraic variables L in ξ can in principle take any value (ξ = σ ∪ ξ ĊL ) as long as the action predicate r is satisfied (ξ -∪ ξ |= r). Variables occurring with a ' -' superscript in r are evaluated in ξ -, which denotes an extended valuation with dom(ξ -) = {x -| x ∈ dom(ξ )}, and ξ -(x -) = ξ(x). For extended valuation ξ , the values of the discrete and the nonjumping variables (dom(σ ) \ (J ∪ W )) are given by σ . The jumping variables J , the variables from set W , the dotted variables Ċ and the algebraic variables L are allowed to change such that the action predicate is satisfied.</p><p>Rule 2 states that action predicates are consistent with any extended valuation σ ∪ ξ ĊL in any environment E.</p><formula xml:id="formula_38">ξ = σ ∪ ξ ĊL , ξ ∈ (σ, C, J ∪ W, L), ξ -∪ ξ |= r (C, J, L, H, R) W : r l a , σ ξ , l a , ξ -→ , ξ σ 1 (C, J, L, H, R) W : r l a , σ σ ∪ξ ĊL<label>2</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2.">Delay predicate</head><p>Delay predicate u is a predicate over variables and dotted continuous variables.</p><formula xml:id="formula_39">ρ ∈ FG (σ, C, L, u, t) (C, J, L, H, R) u, σ t,ρ -→ u, ρ σ (t) 3 σ ∪ ξ ĊL |= u (C, J, L, H, R) u, σ σ ∪ξ ĊL 4 Function FG ∈ × P(V) × P(V) × U × T → P(T → ˙ )</formula><p>, where U denotes the set of all predicates over V and V, returns a set of trajectories from time to an extended valuation for the variables and dotted variables, given a valuation representing the current values of the discrete and continuous variables, the set of continuous variables, the set of algebraic variables, a delay predicate and a time point that denotes the duration of the trajectory. Formally, function FG is defined as:</p><formula xml:id="formula_40">FG (σ, C, L, u, t) = { ρ | ρ ∈ [0, t] → ((dom(σ ) ∪ Ċ ∪ L) → ) , t ≥ 0 , ∀s ∈ [0, t] : ρ(s) |= u , ∀x ∈ dom(σ ) \ ({time} ∪ C) : ρ ↓ x is a constant function. , ∀x ∈ dom(σ ) : (ρ ↓ x)(0) = σ (x) , ∀x ∈ L : ρ ↓ x ∈ F , ∀x ∈ C : ρ ↓ ẋ is an integrable function in the Lesbesgue sense. , ∀s ∈ [0, t], x ∈ C : (ρ ↓ x)(s) = (ρ ↓ x)(0) + s 0 (ρ ↓ ẋ)(s )ds , ∀x ∈ C : (ρ ↓ x, ρ ↓ ẋ) ∈ G , ∀s ∈ [0, t] : ρ(s)(time) = σ (time) + s }</formula><p>The trajectory ρ is a function from the time interval [0, t], where t ≥ 0, to a valuation, where the domain of each valuation consists of all variables and dotted continuous variables. Trajectory ρ satisfies the predicate u for all time points of its domain (∀ s∈[0,t] ρ(s) |= u). The trajectory of each discrete variable x ∈ dom(σ ) \ ({time} ∪ C) is restricted to a constant function. The initial value (starting-point) of the trajectory of each discrete and continuous variable equals the value of that variable in σ</p><formula xml:id="formula_41">(∀ x∈dom(σ ) (ρ ↓ x)(0) = σ (x)).</formula><p>The trajectories of the algebraic variables (ρ ↓ x for x ∈ L) are required to be functions of type F . This set of functions is a parameter of the solution concept of χ . The definition of the</p><formula xml:id="formula_42">trajectory as ρ ∈ [0, t] → ((dom(σ ) ∪ Ċ ∪ L) → ) ensures that ∀ x∈L (ρ ↓ x) ∈ [0, t] → .</formula><p>Having the set F as a parameter of the solution concept allows us to restrict F to, for instance, the set of piecewise constant functions, if this would be required for certain properties to hold.</p><p>The trajectories of the dotted variables are required to be integrable. This ensures that the integral s 0 (ρ ↓ ẋ)(s )ds is defined. The relation between the trajectory of a continuous variable x and the trajectory of its 'derivative' ẋ is given by the Caratheodory solution concept <ref type="bibr" target="#b2">[3]</ref></p><formula xml:id="formula_43">: (ρ ↓ x)(s) = (ρ ↓ x)(0) + s 0 (ρ ↓ ẋ)(s )ds .</formula><p>Note that this integral relation can hold only for those continuous variables for which ρ ↓ x is an absolutely continuous function. Thus the solution function FG restricts the trajectory ρ ↓ x of every continuous variable x to an absolutely continuous function, but it does allow a non-smooth trajectory for a continuous variable in the case that the trajectory of its 'derivative' ρ ↓ ẋ is non-smooth or even discontinuous, as in, for example, cont y , y = 0 | ẏ = step(time -1) , where step(x) equals 0 for x ≤ 0 and 1 for x &gt; 0.</p><p>The disadvantage of the Caratheodory solution concept is that it introduces spurious solutions in a higher index system such as cont y , alg z | y = time, z = ẏ . Here, one could argue that the trajectory for z should be the constant function 1. The Caratheodory solution concept, however, allows trajectories for z that are 1, except for discontinuity points, where any other value is allowed. Such spurious discontinuities in ρ ↓ ẋ, in the case that the trajectory of a differential variable x is smooth, and thus ρ ↓ x is differentiable, on some interval I , can be prevented in two ways.</p><p>First, by changing the model to cont y, z | y = time, z = ẏ . Defining z as a continuous variable requires its trajectory to be (absolutely) continuous.</p><p>Second, by restricting the solution concept. This can be done by restricting set G in the requirement</p><formula xml:id="formula_44">∀ x∈C (ρ ↓ x, ρ ↓ ẋ) ∈ G, where G is a parameter of the χ solution concept. Defining G = {(f, f ) | ∀ I ⊆dom(f ) f is differentiable on I ⇒ f I is the derivative function of f I },</formula><p>where I denotes some interval, requires the solution function ρ ↓ ẋ for the dotted variable ẋ to be indeed the derivative function of the solution function ρ ↓ x for the differential variable x, for all intervals where ρ ↓ x is differentiable. This prevents spurious discontinuities from occurring in higher index systems as discussed above. The disadvantage of this set G is that for instance the delay predicate (time = 1 ⇒ ẋ = 1) ∧ (time = 1 ⇒ ẋ = 0) has no solution for x (ρ ↓ x) on the interval [0, t], for t &gt; 1, starting from a valuation in which time = 0. A constant function of time for x with domain [0, t] for t &gt; 0, which is a solution for G = {(f, f ) | true}, is not a solution for the restricted version of G defined above, because the derivative function (here ρ ↓ ẋ) of a constant function (here ρ ↓ x) is always zero, and therefore the valuation at time point 1 (ρ(1)) does not satisfy the delay predicate.</p><p>The properties derived in Section 5.2 are valid for all parameters F and G. For the translation of a hybrid automaton to χ as defined in <ref type="bibr" target="#b1">[2]</ref>, differentiable functions are assumed for the trajectories of the continuous variables: G = {(f, f ) | f is differentiable, and f is the derivative function of f }. In this way, the semantics of the χ translation corresponds to the semantics of the hybrid automaton. For the examples in Section 4, differentiability would be too strong a restriction. Therefore, piecewise continuous functions for the trajectories of the algebraic and dotted variables are assumed:</p><formula xml:id="formula_45">F = {f | f is a piecewise continuous function }, G = {(f, f ) | f is a piecewise continuous function }.</formula><p>There is no fundamental reason for this choice. Another possibility would have been not to define additional restrictions:</p><formula xml:id="formula_46">F = {f | true}, G = {(f, f ) | true}.</formula><p>For a model with just one solution such as: cont x , alg y | ẋ = y , y = step(time -1) , the solution is the same for both cases of F and G. For a model that allows infinitely many solutions, such as cont x , alg y | true , there would obviously be a difference.</p><p>In some deduction rules describing delay behavior, abbreviation σEt , which denotes FG (σ, C, L, true, t), is used as a hypothesis. The true predicate does not restrict t and the trajectory ρ other than by means of the default restrictions. Among others, the discrete variables remain constant, and the trajectory of each continuous variable is an absolutely continuous function that starts with the value of the continuous variable in σ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3.">Send and receive</head><p>Send and receive process terms h !! e n and h ?? x n denote undelayable sending of expression e n via channel h, and undelayable receiving of information via channel h into variable(s) x n , respectively.</p><p>The values of expressions e 1 , . . . , e n which are sent via channel h are evaluated in extended valuation ξ , see Rule 5, where e n denotes e 1 , . . . , e n , [ξ(e n )] denotes the list of values [ξ(e 1 ), . . . , ξ(e n )] for n ≥ 1, and ξ(e) denotes the value of expression e for extended valuation ξ . The case that n equals 0, represents the case where nothing is sent via the channel, and e 0 and [ξ(e 0 )] denote an empty expression and an empty list, respectively. For n ≥ 1, the receive process term h ?? x 1 , . . . , x n can receive the list of values [c 1 , . . . , c n ], see Rule 6, where</p><formula xml:id="formula_47">x n denotes x 1 , . . . , x n , {x n } denotes the set {x 1 , . . . , x n } , [c n ] denotes the list of values [c 1 , . . . , c n ], and ξ (x n ) = c n is an abbreviation for ξ (x 1 ) = c 1 , . . . , ξ (x n ) = c n .</formula><p>For n = 0, nothing is received, so that x 0 and c 0 are empty, and ξ (x 0 ) = c 0 always holds.</p><formula xml:id="formula_48">ξ = σ ∪ ξ ĊL , ξ ∈ (σ, C, J, L) (C, J, L, H, R) h !! e n , σ ξ , isa(h,[ξ(e n )]), ξ -→ , ξ σ 5 ξ = σ ∪ ξ ĊL , ξ ∈ (σ, C, J ∪ {x n }, L), ξ (x n ) = c n (C, J, L, H, R) h ?? x n , σ ξ , ira(h,[c n ],{x n }), ξ -→ , ξ σ 6 (C, J, L, H, R) h !! e n , σ σ ∪ξ ĊL 7 (C, J, L, H, R) h ?? x n , σ σ ∪ξ ĊL<label>8</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4.">Deadlock and inconsistent process term</head><p>Process term δ cannot perform any action transitions, nor time transitions. It is, however, consistent for arbitrary extended valuations σ ∪ ξ ĊL .</p><formula xml:id="formula_49">(C, J, L, H, R) δ, σ σ ∪ξ ĊL<label>9</label></formula><p>There are no rules for the inconsistent process term ⊥. Therefore, it cannot do actions transition, nor time transitions, and it is inconsistent for all valuations and environments. Process term ⊥ originates from the process algebra with propositional signals ACP ps <ref type="bibr" target="#b23">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Deduction rules for operators</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1.">Any delay operator</head><p>The any delay operator [p] allows arbitrary time transitions, that need to satisfy only the general solution function requirements (e.g. trajectories of discrete variables are constant), regardless of the time transitions allowed by p (see <ref type="bibr">Rule 11)</ref>. The any delay operator does not affect the action behavior of p (see <ref type="bibr">Rule 10)</ref>. Process term [p] is consistent with any extended valuation σ ∪ ξ ĊL , in any environment E (see <ref type="bibr">Rule 12)</ref>.</p><formula xml:id="formula_50">E p, σ α -→ p , σ [p], σ α -→ p , σ 10 E ρ ∈ σEt [p], σ t,ρ -→ [p], ρ σ (t) 11 (C, J, L, H, R) [p], σ σ ∪ξ ĊL<label>12</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2.">Signal emission operator</head><p>The signal emission operator u p ensures that p starts its behavior from an extended valuation ξ in which initialization predicate u is satisfied. This operator was inspired by the signal emission operator from the process algebra with propositional signals ACP ps <ref type="bibr" target="#b23">[24]</ref>, which was also used in <ref type="bibr" target="#b24">[25]</ref>.</p><formula xml:id="formula_51">E p, σ ξ,a,ξ -→ p , σ , ξ |= u u p, σ ξ,a,ξ -→ p , σ 13 E p, σ t,ρ -→ p , σ , ρ(0) |= u u p, σ t,ρ -→ p , σ 14 E p, σ ξ , ξ |= u u p, σ ξ 15</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3.">Sequential composition operator</head><p>The sequential composition of process terms p and q behaves as process term p until p terminates, and then continues to behave as process term q. When p terminates, its right-hand extended valuation ξ must be consistent with q (see Rule 16).</p><formula xml:id="formula_52">E p, σ ξ,a,ξ -→ , σ , q, σ ξ p; q, σ ξ,a,ξ -→ q, σ 16 E p, σ α -→ p , σ p; q, σ α -→ p ; q, σ 17 E p, σ t,ρ -→ p , σ p; q, σ t,ρ -→ p ; q, σ 18 E p, σ ξ p; q, σ ξ 19</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.4.">Guard operator</head><p>The guarded process term b → p can do whatever actions p can do under the condition that the guard evaluates to true using extended valuation ξ . Evaluating the guard in ξ ensures that when guard operators are nested with signal emission operators, actions can be executed only if all predicates of the signal emission operators and all guards hold, independently of the order. Furthermore, the values of the dotted variables and algebraic variables are defined in ξ , whereas they are not defined in σ .</p><p>The guarded process term can delay according to p under the condition that for all intermediate valuations the guard evaluates to true (∀ s∈[0,t] ρ(s) |= b, see Rule 21).</p><p>The guarded process term can perform arbitrary delays under the condition that for the intermediate valuations, possibly excluding the first and last valuation, the guard does not hold ( ∀ s∈(0,t) ρ(s) |= ¬b). This ensures that, for example, the process disc x , x = 1 | time ≥ x → skip behaves as expected: it can first do a time transition of 1, such that the value of the current time time becomes 1, and thereafter it can do a τ action to the terminated process. If the condition in Rule 22 would be ∀ s∈[0,t] ρ(s) |= ¬b, then a time transition of 1 would be impossible. This is because the value of the guard should then also be false for the last time point of the time transition, so that the point where the value of time equals 1 could not be reached. The condition ρ(0) |= b ⇒ p, σ 0,ρ {0} -→ p , σ in Rule 22, which states that p must be able to delay for a duration of 0 if the guard is initially true, ensures that undelayable actions in p have priority over delay behavior of a guard that is initially true and continues as false. The condition</p><formula xml:id="formula_53">ρ(t) |= b ⇒ p, ρ σ (t) ρ(t)</formula><p>in Rule 22 requires consistency if the guard holds in the end-point of the trajectory. This ensures that it is impossible to delay to an inconsistent state.</p><p>Finally, b → p is consistent with extended valuations for which b holds and with which p is consistent (Rule 23), and with extended valuations for which b does not hold (Rule 24).</p><formula xml:id="formula_54">E p, σ ξ,a,ξ -→ p , σ , ξ |= b b → p, σ ξ,a,ξ -→ p , σ 20 E p, σ t,ρ -→ p , σ , ∀ s∈[0,t] ρ(s) |= b b → p, σ t,ρ -→ b → p , σ 21 E ρ ∈ σEt , ∀ s∈(0,t) ρ(s) |= ¬b, ρ(0) |= b ⇒ p, σ 0,ρ {0} -→ p , σ , ρ(t) |= b ⇒ p, ρ σ (t) ρ(t) b → p, σ t,ρ -→ b → p, ρ σ (t) 22 E p, σ ξ , ξ |= b b → p, σ ξ 23 σ ∪ ξ ĊL |= ¬b (C, J, L, H, R) b → p, σ σ ∪ξ ĊL<label>24</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.5.">Alternative composition operator</head><p>Applying the alternative composition operator to process terms p and q models a nondeterministic choice between p and q for action transitions. Process term p can perform action transitions only if the initial extended valuation is consistent with q, as specified in Rule 25. Consider for example the following process term: y = 1 [] x := y. This corresponds to a hybrid automaton with one location with flow predicate true, invariant y = 1, and an urgent outgoing edge with jump condition x := y. The invariant y = 1 ensures that the value of y equals 1 when the outgoing edge is taken.</p><p>The passage of time cannot result in making a choice between p and q, since the time transitions of the process terms p and q have to synchronize to obtain the time transition (with the same time step t and trajectory ρ) of their alternative composition as defined by Rule 26.</p><formula xml:id="formula_55">E p, σ ξ,a,ξ -→ p , σ , q, σ ξ p [] q, σ ξ,a,ξ -→ p , σ , q [] p, σ ξ,a,ξ -→ p , σ 25 E p, σ t,ρ -→ p , σ , q, σ t,ρ -→ q , σ p [] q, σ t,ρ -→ p [] q , σ 26 E p, σ ξ , q, σ ξ p [] q, σ ξ 27</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.6.">Parallel composition operator</head><p>The parallel composition of process terms p and q has as its behavior with respect to action transitions the interleaving of the behaviors of p and q (see Rule 29). Process term p can only perform action transitions from an extended valuation ξ which is consistent with q. Furthermore, the resulting extended valuation ξ must be consistent with q (see Rule 29).</p><p>The parallel composition allows the synchronization of matching send and receive actions. A send action isa(h, cs) and a receive action ira(h , cs , W ) match iff h = h and cs = cs ; i.e. the channels used for sending and receiving are the same, and also the values sent and the values received are identical. Furthermore, the resulting extended valuations ξ of both the send action and the receive action have to be the same. In order to be able to receive values in variables of the same scope as the send process term, the variables of which the value changes due to the receive action are passed on to the send process term. This is achieved by means of set W on the receive action, and the addition of this set W to the set of jumping variables in the environment where the send action takes place (see <ref type="bibr">Rule 28)</ref>. The result of the synchronization is a communication action that is represented by ca(h, cs) as defined by Rule 28.</p><p>The time transitions of the process terms that are put in parallel have to synchronize in the same way as for alternative composition, see Rules 26 and 30.</p><formula xml:id="formula_56">(C, J ∪ W, L, H, R) p, σ ξ,isa(h,cs),ξ -→ p p , σ , (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ -→ q q , σ (C, J, L, H, R) p || q, σ ξ,ca(h,cs),ξ -→ p q p || q , σ , q || p, σ ξ,ca(h,cs),ξ -→ p q q || p , σ E q, σ ξ , p, σ ξ,a,ξ -→ p , σ , q, σ ξ p || q, σ ξ,a,ξ -→ q p || q , σ , q || p, σ ξ,a,ξ -→ q q || p , σ 29 E p, σ t,ρ -→ p , σ , q, σ t,ρ -→ q , σ p || q, σ t,ρ -→ p || q , σ 30 E p, σ ξ , q, σ ξ p || q, σ ξ 31</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.7.">Action encapsulation operator</head><p>The behavior of the action encapsulation applied to a process term ∂ A (p) is the same as the behavior of its argument with the restriction that actions from the set A (A ⊆ A \ {τ }) cannot be executed (see <ref type="bibr">Rule 32)</ref>. Action encapsulation has no effect on time transitions and consistency, as defined by Rules 33 and 34. </p><formula xml:id="formula_57">E p, σ ξ,a,ξ -→ p , σ , a ∈ A ∂ A (p), σ ξ,a,ξ -→ ∂ A (p ) , σ 32 E p, σ t,ρ -→ p , σ ∂ A (p), σ t,ρ -→ ∂ A (p ),</formula><formula xml:id="formula_58">-→ p , σ υ H (p), σ α -→ υ H (p ) , σ 35 E p, σ ξ υ H (p), σ ξ 36 E p, σ t,ρ -→ p , σ , ∀ s∈[0,t) ( p, σ s,ρ [0,s] -→ p s , σ s , p s , σ s t-s,ρ -s -→ p , σ , ∀ h∈H p s , σ s , E ca(h, * ) ) υ H (p), σ t,ρ -→ υ H (p ), σ</formula><p>37 where ρ -s denotes the trajectory ρ shifted left by s time-units and starting at 0: dom(ρ -s ) = [0, ts], assuming dom(ρ) = [0, t], and ∀ t ∈dom(ρ -s ) ρ -s (t ) = ρ(t + s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.9.">Recursion variable</head><p>A recursion variable process term X behaves as the process term given by R(X). Here R(X) is the process term that is defined for recursion variable X in function R. This is equivalent to syntactically replacing recursion variable X by its defining process term R(X). Function R can be defined in the environment of the χ process directly, or by means of the recursion scope operator, see Section 3.4.13.</p><formula xml:id="formula_59">(C, J, L, H, R) R(X), σ α -→ p , σ X, σ α -→ p , σ<label>38</label></formula><formula xml:id="formula_60">(C, J, L, H, R) R(X), σ t,ρ -→ p , σ X, σ t,ρ -→ p , σ 39 (C, J, L, H, R) R(X), σ ξ X, σ ξ 40</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.10.">Jump enabling operator</head><p>The jump enabling operator applied to a process term p with set J + (ι J + (p)) behaves the same as its argument in an environment where the variables from set J + are jumping variables.</p><formula xml:id="formula_61">(C, J ∪ J + , L, H, R) p, σ α -→ p , σ (C, J, L, H, R) ι J + (p), σ α -→ ι J + (p ) , σ 41 (C, J ∪ J + , L, H, R) p, σ t,ρ -→ p , σ (C, J, L, H, R) ι J + (p), σ t,ρ -→ ι J + (p ), σ 42 (C, J ∪ J + , L, H, R) p, σ ξ (C, J, L, H, R) ι J + (p), σ ξ 43</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.11.">Variable scope operator</head><p>By means of the variable scope operator, local variables are introduced in a χ process. A variable scope operator process term  <ref type="figure">d ,</ref><ref type="figure">x ,</ref><ref type="figure">g /d,</ref><ref type="figure">x,</ref><ref type="figure">g</ref>] denotes the process term that is obtained by substitution of the (free) variables d, x, g in p by the fresh variables d , x , g , respectively, choosing the fresh variables d , x , g in such a way that they remain free in p. After execution of an action or a delay transition, the local variables of the variable scope operator are renamed back to their original names. Note that the variables used in the recursion definitions R are not renamed to ensure that the bindings of these variables remain unchanged. In this way, the variables occurring in recursion definitions are bound statically, as is illustrated by the following example χ process:</p><formula xml:id="formula_62">|[ V σ dx ⊥ , {x}, {g} | p ]|,</formula><formula xml:id="formula_63">|[ V {n → 2}, ∅, ∅ | X; z := n ]| , {n → 0, y → 0, z → 0} , (∅, ∅, ∅, ∅, {X → n := 1; y := n})</formula><p>.</p><p>The process defines the variables n, y, z that are initialized to 0, a recursion definition X → n := 1; y := n, and a variable scope operator that redefines n as a local variable that is initialized to 2. When the process term X; z := n terminates, the value of y equals 1, and the value of z equals 2. The recursion variable X is executed in the scope of its definition.</p><p>The variable scope operator is the only operator that affects the set of continuous variables C and the set of algebraic variables L from the environment. In this way, it is ensured that the discrete, continuous, or algebraic variables in any χ process p, σ, E remain discrete, continuous, or algebraic, respectively. Continuous variables, on the other hand, can change from non-jumping continuous variables to jumping continuous variables, using the jump enabling operator (see Section 3.4.10).</p><p>The local variables are invisible outside of the scope operator. This is done by means of data abstraction. For action transitions, data abstraction takes place by restricting the extended valuations, and the valuation of the resulting process, to the global variables, and by keeping only the global variables in the set W of the internal receive actions. For time transitions, data abstraction takes place by restricting the trajectory to the global variables. In this way, all changes to local variables are removed.</p><p>Action transition abstraction function κ ∈ × P( V) × P(V) × ˙ × A × ˙ → ˙ × A × ˙ is defined as follows. For arbitrary receive actions ira(h, cs, W ):</p><formula xml:id="formula_64">κ σ ĊL (ξ, ira(h, cs, W ), ξ ) = ξ σ ĊL , ira(h, cs, W ∩ (dom(σ ) ∪ L)), ξ σ ĊL ,</formula><p>and for all other actions:</p><formula xml:id="formula_65">κ σ ĊL (ξ, a, ξ ) = ξ σ ĊL , a, ξ σ ĊL ,</formula><p>where extended valuations ξ σ ĊL and ξ σ ĊL denote ξ (dom(σ ) ∪ Ċ ∪ L) and ξ (dom(σ ) ∪ Ċ ∪ L), respectively. Furthermore, in the rules below, the following abbreviations are used: valuation σ σ denotes σ dom(σ ), and trajectory ρ σ ĊL denotes ρ ↓ (dom(σ ) ∪ Ċ ∪ L).</p><p>Valuation σ dx ⊥ ∈ {d, x} → ( ∪ {⊥}) and valuation σ d x ∈ {d , x } → define the same values for all (renamed) variables for which σ dx ⊥ is defined. For the undefined variables in σ dx ⊥ , σ d x has an arbitrary value:</p><formula xml:id="formula_66">∀ v∈dom(σ dx ⊥ ) σ dx ⊥ (v) = ⊥ ⇒ σ d x (v[d , x /d, x]) = σ dx ⊥ (v), where v[d , x /d, x] denotes the renamed version of variable v. (C ∪ {x }, J, L ∪ {g }, H, R) p[d , x , g /d, x, g], σ ∪ σ d x ξ,a,ξ -→ p , σ (C, J, L, H, R) |[ V σ dx ⊥ , {x}, {g} | p ]|, σ κ σ ĊL (ξ,a,ξ ) -→ |[ V (σ {d , x })[d, x/d , x ], {x}, {g} | p [d, x, g/d , x , g ] ]| , σ σ 44 (C ∪ {x }, J, L ∪ {g }, H, R) p[d , x , g /d, x, g], σ ∪ σ d x t,ρ -→ p , σ (C, J, L, H, R) |[ V σ dx ⊥ , {x}, {g} | p ]|, σ t,ρ σ ĊL -→ |[ V (σ {d , x })[d, x/d , x ], {x}, {g} | p [d, x, g/d , x , g ] ]|, σ σ 45 (C ∪ {x }, J, L ∪ {g }, H, R) p[d , x , g /d, x, g], σ ∪ σ d x ξ (C, J, L, H, R) |[ V σ dx ⊥ , {x}, {g} | p ]|, σ ξ σ ĊL<label>46</label></formula><p>3.4.12. Channel scope operator By means of the channel scope operator, local channels can be introduced in a χ process. By means of action abstraction, communication actions on local channels are made invisible outside of the scope operator.</p><p>Action abstraction takes place by substituting communication actions ca(h, cs) using a local channel by internal τ actions (see <ref type="bibr">Rule 47)</ref>. The internal send and receive actions (isa(h, cs) and ira(h, cs, W )) on a local channel h are blocked, because Rule 47 only specifies behavior for communication actions ca(h, cs). Therefore, these internal send and receive actions are not visible outside of the scope operator. Function ch ∈ A → H ∪ {⊥} extracts the channel label from an action. It is defined as ch(ca(h, cs)) = h, ch(isa(h, cs)) = h, ch(ira(h, cs, W )) = h, and ch(l a ) = ⊥, where l a ∈ A label . Note that no renaming is applied to action a in Rule 48, because this action cannot refer to local channels.</p><p>The local channels h occurring in p are renamed to fresh channels h in a similar way as for the local variables in the variable scope operator. Also here, in the channel scope operator, renaming does not take place in the recursion definitions R to ensure that the bindings of channels in R remain unchanged.</p><formula xml:id="formula_67">(C, J, L, H ∪ {h }, R) p[h /h], σ ξ,ca(h,cs),ξ -→ p , σ , h ∈ {h } (C, J, L, H, R) |[ H {h} | p ]|, σ ξ,τ,ξ -→ |[ H {h} | p [h/h ] ]| , σ 47 (C, J, L, H ∪ {h }, R) p[h /h], σ ξ,a,ξ -→ p , σ , ch(a) ∈ {h } (C, J, L, H, R) |[ H {h} | p ]|, σ ξ,a,ξ -→ |[ H {h} | p [h/h ] ]| , σ 48 (C, J, L, H ∪ {h }, R) p[h /h], σ t,ρ -→ p , σ (C, J, L, H, R) |[ H {h} | p ]|, σ t,ρ -→ |[ H {h} | p [h/h ] ]|, σ (C, J, L, H ∪ {h }, R) p[h /h], σ ξ (C, J, L, H, R) |[ H {h} | p ]|, σ ξ 50</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.13.">Recursion scope operator</head><p>By means of the recursion scope operator, local recursion definitions are introduced in a χ process. The application of the recursion scope operator to a process term p with a 'global' valuation σ and a 'global' environment (C, J, L, H, R) behaves as p after the addition of local recursion definitions to the global recursion definitions. In the rules below, X → q denotes the recursion definitions X 1 → q 1 , . . . , X r → q r . To prevent redefinition of recursion definitions already existing in the environment, the local recursion variables X are renamed to fresh variables X with respect to the variables from the domain of R.</p><formula xml:id="formula_68">(C, J, L, H, R ∪ {X → q[X /X]}) p[X /X], σ α -→ p , σ (C, J, L, H, R) |[ R {X → q} | p ]|, σ α -→ |[ R {X → q} | p [X/X ] ]| , σ 51 (C, J, L, H, R ∪ {X → q[X /X]}) p[X /X], σ t,ρ -→ p , σ (C, J, L, H, R) |[ R {X → q} | p ]|, σ t,ρ -→ |[ R {X → q} | p [X/X ] ]|, σ 52 (C, J, L, H, R ∪ {X → q[X /X]}) p[X /X], σ ξ (C, J, L, H, R) |[ R {X → q} | p ]|, σ ξ 53</formula><p>Consider, for example, the process term</p><formula xml:id="formula_69">|[ R X → Y, Y → x := 0 | |[ R Y → x := 1 | X ]|]|.</formula><p>Local recursion variable Y with definition Y → x := 1 conflicts with the recursion variable definition Y → x := 0 from the outer scope. The renaming of the local variable in the rules of the recursion scope operator ensures that the process term behaves as</p><formula xml:id="formula_70">|[ R X → Y, Y → x := 0 | |[ R Z → x := 1 | X ]|]|.</formula><p>Thus, the value of variable x becomes 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Examples</head><p>This section presents three examples. Many additional examples can be found in <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Constrained pendulum</head><p>Fig. <ref type="figure" target="#fig_2">1</ref> shows a constrained pendulum that is also defined in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b25">26]</ref>. The equations of motion of this pendulum are given by Eq. ( <ref type="formula">1</ref>). The angle between the pendulum and the vertical is denoted by θ , ω denotes the angular velocity of the pendulum, and l denotes the distance between the rotation point and the mass.</p><formula xml:id="formula_71">θ = ω ml ω = -mg sin(θ ) -dlω (1)</formula><p>The mass and maximum length of the pendulum are represented by m and L, respectively. The damping coefficient and the acceleration due to gravity are denoted by d and g. The angle of the constraint is denoted by θ p . In order to keep the example as small and clear as possible, it is assumed that θ p ≥ 0 and |θ | ≤ π/2. Also, it is assumed that the pendulum always remains in a straight line from the rotation point to the end point. The χ model is:</p><formula xml:id="formula_72">cont θ, ω, alg l , θ = θ 0 , ω = ω 0 , long → l = L, θ ≤ θ p [] [ω := L L s ω]; short , short → l = L s , θ ≥ θ p [] [ω := L s L ω]; long | (skip; long [] skip; short) || θ = ω , ml ω = -mg sin(θ ) -dlω ,</formula><p>where θ 0 and ω 0 denote constants representing the initial values of θ and ω, respectively. When θ ≤ θ p or θ ≥ θ p , the pendulum can delay in mode long or short, respectively. In mode long, the assignment ω := L L s ω can be executed only if the new state after the assignment to ω is consistent with the constraints l = L s , θ ≥ θ p of mode short, because a process cannot enter an inconsistent state. Therefore, mode switches are possible only for θ = θ p . The any delay operator applied on the assignment in [ω := L L s ω] is needed, because otherwise the assignment and the alternative composition would not be able to delay. Note that the model allows infinite switching between modes long and short, without progress of time, when θ = θ p . This switching behavior can, in principle, be avoided by guarding the delayable assignments [ω := L L s ω] and [ω := L s L ω] with (non-trivial) conditions that prevent mode switching when no delay behavior is possible in the new mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Glider take-off</head><p>Fig. <ref type="figure" target="#fig_3">2</ref> shows a glider that is towed off the ground by a tow plane. The position, velocity and acceleration of the tow plane are given by x 1 , v 1 , a, respectively. The position and velocity of the glider are given by x 2 and v 2 .</p><p>Initially, the tow plane and glider are standing still at a distance of l min . After one unit of time, the tow plane very slowly accelerates (a := 0.02) until the tow cable is at its maximum length of l max . At that moment, the velocity of the glider jumps discontinuously to the velocity of the tow plane. We assume the mass of the glider to be considerably smaller than the mass of the tow plane. The tow plane then accelerates (a := 0.5) until its velocity is at v max . After another t units of time, the glider releases the tow cable, and continues on its own. Its velocity is then assumed to be determined by the air resistance, which is proportional to the squared velocity (kv 2  2 ), and the propelling forces F , which we assume constant in the model below:</p><formula xml:id="formula_73">disc s, a, cont x 1 , x 2 , v 1 , v 2 , s = stop, a = 0, x 1 = l min , x 2 = 0, v 1 = 0 | ẋ1 = v 1 , ẋ2 = v 2 , v1 = m 1 a || s = stop → v 2 = 0 || s = tow → v 2 = v 1 || s = fly → v2 = F -kv 2 2 || 1; a := 0.02 ; x 1 -x 2 ≥ l max → (jump v 2 | s := tow) ; a := 0.5; v 1 ≥ v max → a := 0 ; t ; s := fly</formula><p>In the model, m 1 is a constant denoting the mass of the towing plane, k is some constant, and enumeration variable s denotes the state of the glider. When the distance between the tow plane and the glider becomes equal to the maximum length of the cable, the glider abruptly starts moving. This is modeled by (jump v 2 | s := tow). The jump enabling operator (jump v 2 | . . .) enables jumps for continuous variable v 2 when assignment s := tow) is executed. This is necessary, because v 2 is declared as a (non-jumping) continuous variable. The only assignment where v 2 must be able to jump is the assignment s := tow, because then v 2 must discontinuously change to the value of v 1 in order to satisfy equation v 2 = v 1 that must hold for s = tow. In this example, the relation v 2 = v 1 in mode tow is so straightforward, that the jumping behavior of variable v 2 when mode tow becomes active can also be modeled explicitly by means of a multi-assignment (s, v 2 := tow, v 1 ) instead of (jump v 2 | s := tow). The model with the jump enabling operator is more general, because it can also be used in cases where the algebraic constraints are so complex that it becomes difficult, or impossible, to explicitly calculate the new value of the jumping variable after the discontinuity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Bottle filling system</head><p>The bottle filling system from Fig. <ref type="figure" target="#fig_4">3</ref> consists of a liquid storage tank, and two identical bottle filling lines.  The bottles are filled with liquid from the storage tank. A control system keeps the volume V T in the storage tank between 2 and 10, and the pH level (acidity) of the liquid in the storage tank between 7 and 7.1. The liquid in the storage tank slowly becomes less acidic (pH level increases). To correct this, a strong acid is dribbled into the storage tank when the acidity of the liquid becomes too low (pH ≥ 7.1).</p><p>Fig. <ref type="figure" target="#fig_5">4</ref> shows the iconic model of the bottle filling system. The lines ending in a small circle represent shared variables (V T , Q F 1 , Q F 1 ).</p><p>The acid and liquid supply processes are not modeled, since we consider the acid and liquid always to be available, and we are not interested in the amount of acid or liquid that is used. The χ specification of the bottle filling system is as follows:</p><formula xml:id="formula_74">cont V T , alg Q F1 , Q F2 , V T = 2 | T (V T , Q F1 , Q F2 ) || F(V T , Q F1 ) || F(V T , Q F2 )</formula><p>The storage tank and the two bottle filling lines are connected by means of the variables Q F1 , and Q F2 , respectively. Since a bottle may start filling only if the storage tank contains at least a volume of 0.7, the volume V T of the storage tank is available in both bottle filling processes.</p><p>The molar quantity and molar concentration of the acid in the storage tank are denoted by n and c, respectively, where n = cV . The incoming flows of liquid and acid of the liquid storage tank T are denoted by Q u and Q a , respectively. The outgoing flows to the two bottle filling processes are denoted by Q F1 and Q F2 , respectively.</p><p>It is assumed that the liquids are incompressible, and that the volumes of the fluids remain the same when they are mixed. In such a case, the volume V of the mixed liquid equals the sum of its components which leads to the following equation:</p><formula xml:id="formula_75">V = Q u + Q a -Q F1 -Q F2 .</formula><p>Next, the mass balance (actually mol balance) for the dissolved substance is derived. Acid comes into the tank by means of the flows Q u and Q a . Acid leaves the tank in outgoing flows Q F1 and Q F2 . Because the concentrations are in [mol/m 3 ], they can be directly multiplied with the flows (in [m 3 /s]), which leads to</p><formula xml:id="formula_76">ṅ = c u Q u + c a Q a -cQ F1 -cQ F2 ,</formula><p>where c u and c a denote the concentrations of acid in the flows Q u and Q a . The gradual reduction of the acidity of the liquid is modeled by means of a constant K loss , which leads to</p><formula xml:id="formula_77">ṅ = c u Q u + c a Q a -cQ F1 -cQ F2 -K loss V .</formula><p>It is assumed that the acid is completely decomposed. Taking into account that the units of c are in [mol/m 3 ] instead of [mol/l], the pH is given by pH =log c/1000.</p><p>The χ specification of the liquid storage tank follows below, where symbols Q seta , Q setu , c a , c u , and K loss denote constants:</p><formula xml:id="formula_78">T (ext V , Q F1 , Q F2 ) |[ disc α, β , cont n, alg pH, c, Q a , Q u , α = 0, β = 0, pH = 7 | V = Q u + Q a -Q F1 -Q F2 , ṅ = c u Q u + c a Q a -cQ F1 -cQ F2 -K loss V , n = cV , pH = -log c/1000 , Q a = αQ seta , Q u = βQ setu || * ( pH ≥ 7.1 → α := 1; pH ≤ 7 → α := 0 ) || * ( V ≤ 2 → β := 1; V ≥ 10 → β := 0 ) ]|</formula><p>The model of the liquid storage tank T illustrates that a differential variable, such as variable n, is not necessarily initialized. In this case, instead, the algebraic variable pH is initialized (pH = 7). The continuous variables of the bottle filling system with tank T , can be declared in different ways.</p><p>In most cases, the differential variables, in this case V and n, are declared as (nonjumping) continuous variables. The other variables, not occurring with a dot (derivative) are then declared as algebraic variables. This ensures that the differential variables can be assigned new values, causing discontinuities. The algebraic variables will then simultaneously jump to their new values satisfying the equations. This declaration scheme is used in process T . Note that variable V is an external variable that is declared as a (nonjumping) continuous variable in the preceding χ process that defines the complete bottle filling system. Note that even though pH is an algebraic variable, which is not normally assigned new values, pH can be initialized, in this case to a value of 7, in the initialization predicate.</p><p>In process T , the only discontinuities in continuous variables occur in the flows Q F1 , Q F2 , Q a , and Q u , that are switched on and off discontinuously in process T , and in process F that follows below. Therefore, the algebraic variables apart from these flows could just as well have been declared as (non-jumping) continuous variables as in cont n, pH, c.</p><p>The behavior of the model is explained as follows. Initially, the pH of the liquid in the storage tank equals 7. It is assumed that the pH level of the incoming liquid is 7 or more, since the acidity controller can only make the acidity of the storage tank increase, causing the pH to decrease. If the pH value exceeds the maximum value (pH ≥ 7.1), the acid valve is opened (α := 1) so that acid is dribbled into the tank. Dribbling of the acid continues until the pH value comes back at 7, and the valve is closed (α := 0). In a similar way, the controller tries to keep the level of the storage tank between 2 and 10.</p><p>The model of a bottle filling line follows below, where symbols Q setF , and t tr denote constants.</p><formula xml:id="formula_79">F(ext V T , Q F ) = |[ disc α, cont V , α = 0, V = 0 | V = Q F , Q F = αQ setF || * ( V T ≥ 0.7 → α := 1 ; α = 1 * → ( V ≥ 1 → α := 0 [] V T ≤ 0.5 → α := 0; V T ≥ 0.7 → α := 1 ) ; t tr ; V := 0 ) ]|</formula><p>The valve switching the flow Q F is modeled by means of the discrete variable α. When the volume in the storage tank is at least 0.7, the bottle filling process can be started (α := 1). Filling stops when the volume in the storage tank drops below 0.5 (V T ≤ 0.5 → α := 0). Filling resumes when the volume in the storage tank is at least 0.7. Filling also stops when the bottle is full (V ≥ 1 → α := 0). The time needed to place a new bottle under the filling nozzle is given by t tr . After that, the bottle volume is reset to 0, which models the arrival of a new bottle, and the filling process is repeated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Validation of the semantics</head><p>First we consider the well-definedness of the semantics in Section 5.1. Then, in Section 5.2, some properties of the χ semantics are given. In Section 5.3, a notion of equivalence is defined, called stateless bisimilarity <ref type="bibr" target="#b26">[27]</ref>, which is similar to the well-known notion of bisimilarity <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref>. It is also shown that this relation is an equivalence and a congruence for all χ operators. Some useful properties of closed χ process terms are given in Section 5.4. Many of these properties express intuitions about the meaning of the χ operators such as the commutativity and associativity of the alternative composition and the parallel composition operator. Other properties are introduced for the purpose of simplifying χ models. Both the examples treated in the previous section and the properties treated in this section add to the level of confidence one has with respect to the 'correctness' of the semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Well-definedness of the semantics</head><p>In the term deduction system, negative premises are used in Rule 37 of the urgent communication operator. As a consequence it is not obvious at first sight whether the term deduction system defines a unique transition system for each closed process term. Welldefinedness of the term deduction system can be obtained by providing a stratification <ref type="bibr" target="#b29">[30]</ref>. The mapping that associates with every positive action transition and positive consistency predicate the value 0 and with every positive time transition the value 1, turns out to be a stratification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Properties of the semantics</head><p>In this section, some useful properties about the semantics of χ are introduced. The proofs of these properties are given in Appendix A. The properties are applied in the remainder of the paper, especially in the proofs of the properties defined in Section 5.4.</p><p>With the current set of deduction rules for the semantics of χ, the left-hand (ξ ) and right-hand (ξ ) extended valuation restricted to the domain of σ are always the same as the initial (σ ) and resulting (σ ) valuation of an action transition, respectively. A similar reasoning applies to the first and last valuation of a trajectory on a time transition and the initial and resulting valuation, respectively. Also note that the environment is never changed in a transition, and that the extended valuation in the consistency predicate restricted to the model variables is the same as the initial valuation.</p><p>The following lemma captures these facts.</p><p>Lemma 1. Let p and p be closed process terms, σ, σ be valuations, ξ, ξ be extended valuations, E and E be environments, a be an action, ρ be a trajectory, and t ∈ T . Then</p><formula xml:id="formula_80">p, σ, E ξ,a,ξ -→ _, σ , E ⇒ dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ ∧ E = E , p, σ, E t,ρ -→ p , σ , E ⇒ dom(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ ∧ E = E , p, σ, E ξ ⇒ ξ σ = σ, where p, σ, E ξ,a,ξ -→ _, σ , E is an abbreviation for p, σ, E ξ,a,ξ -→ p , σ , E for some p .</formula><p>The χ processes that can perform action or time transitions are consistent (the consistency predicate holds). Lemma 2. Let p and p be closed process terms, σ and σ be valuations, E and E be environments, ξ and ξ be extended valuations and a be an action. Then The following lemma shows that any variation in the set of jumping variables in the environment of a consistent χ process has no effect on the consistency predicate. Lemma 4. Let p be a closed process term, σ be a valuation, C, J, W, L be sets of various classes of χ variables such that J and W ⊆ dom(σ ) \ {time}, H be a set of channels, R be a recursion definition, and ξ be an extended valuation. Then</p><formula xml:id="formula_81">p, σ, E ξ,a,ξ -→ ⇒ p,</formula><formula xml:id="formula_82">p, σ, (C, J, L, H, R) ξ ⇔ p, σ, (C, J ∪ W, L, H, R) ξ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Stateless bisimilarity</head><p>Two closed χ process terms are considered equivalent if they have the same behavior (in the bisimulation sense) in case both are considered from the same initial valuation of model variables and the same environment. We also assume that the initial valuation contains at least the free occurrences of variables in the two closed χ process terms being equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Stateless bisimilarity).</head><p>A stateless bisimulation relation on closed process terms is a relation R ⊆ P × P such that for all (p, q) ∈ R, the following holds: <ref type="figure">E,</ref><ref type="figure">ξ,</ref><ref type="figure">a,</ref><ref type="figure">ξ ,</ref><ref type="figure">p ,</ref><ref type="figure">σ ,</ref><ref type="figure">E p,</ref><ref type="figure">σ,</ref><ref type="figure">E</ref> ξ,a,ξ <ref type="figure">E,</ref><ref type="figure">ξ,</ref><ref type="figure">a,</ref><ref type="figure">ξ ,</ref><ref type="figure">q ,</ref><ref type="figure">σ ,</ref><ref type="figure">E q,</ref><ref type="figure">σ,</ref><ref type="figure">E</ref> ξ,a,ξ</p><formula xml:id="formula_83">(1) ∀ σ,E,ξ,a,ξ ,σ ,E p, σ, E ξ,a,ξ -→ , σ , E ⇔ q, σ, E ξ,a,ξ -→ , σ , E , (2) ∀ σ,</formula><formula xml:id="formula_84">-→ p , σ , E ⇒ ∃ q q, σ, E ξ,a,ξ -→ q , σ , E ∧ (p , q ) ∈ R, (3) ∀ σ,</formula><formula xml:id="formula_85">-→ q , σ , E ⇒ ∃ p p, σ, E ξ,a,ξ -→ p , σ , E ∧ (p , q ) ∈ R, (4) ∀ σ,E,t,ρ,p ,σ ,E p, σ, E t,ρ -→ p , σ , E ⇒ ∃ q q, σ, E t,ρ -→ q , σ , E ∧ (p , q ) ∈ R, (5) ∀ σ,E,t,ρ,q ,σ ,E q, σ, E t,ρ -→ q , σ , E ⇒ ∃ p p, σ, E t,ρ -→ p , σ , E ∧ (p , q ) ∈ R, (6) ∀ σ,E,ξ p, σ, E ξ ⇔ q, σ, E ξ .</formula><p>Two closed process terms p and q are stateless bisimilar, denoted by p ↔ q, if there exists a stateless bisimulation relation R such that (p, q) ∈ R.</p><p>As a consequence of Lemma 1, the definition of stateless bisimilarity can be simplified considerably. Yet, with in mind future extensions of the χ formalism, it might well be the case that these properties of the semantics are lost. Since we would prefer not to redo all the coming proofs (in such a future), this presentation was chosen.</p><p>Stateless bisimilarity is proved to be a congruence with respect to all χ operators. As a consequence, algebraic reasoning is facilitated, since it is allowed to replace equals by equals in any context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 6 (Congruence). Stateless bisimilarity is a congruence with respect to all χ operators.</head><p>Proof. The deduction rules of the χ formalism, satisfy the process-tyft format of <ref type="bibr" target="#b26">[27]</ref>. Therefore, stateless bisimilarity is a congruence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Properties of the Chi operators</head><p>In this section, some properties of the operators of χ that hold with respect to stateless bisimilarity are discussed. Most of these correspond well with our intuitions, and hence this can be considered as an additional validation of the semantics. It is not our intention to provide a complete list of such properties (complete in the sense that every equivalence between closed process terms is derivable from those properties). The proofs of the properties from this section are given in Appendix B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 7 (Signal emission operator).</head><p>The following properties hold for all closed process terms p ∈ P and predicates u, u :</p><formula xml:id="formula_86">true p ↔ p u u ↔ u false p ↔ ⊥ u (u p) ↔ (u ∧ u ) p</formula><p>If a true predicate is emitted, the process term is simply executed. If falsity holds initially, the process term is inconsistent. There is no effect if a predicate u is emitted to itself. A concatenation of signal emissions leads to a signal emission with conjunction of predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 8 (Alternative composition).</head><p>The following properties hold for all closed process terms p, q, r ∈ P :</p><formula xml:id="formula_87">p [] p ↔ p ( p[] q) [] r ↔ p [] (q [] r) p [] q ↔ q [] p</formula><p>The alternative composition is idempotent, commutative and associative. </p><formula xml:id="formula_88">true → p ↔ p b→ ⊥ ↔ ¬b false → p ↔ true b → (p [] q) ↔ b → p [] b → q</formula><p>If a process term is guarded by a true predicate, the process term is simply executed. In case a process term is guarded by a false predicate, process term false → p can perform any time transition, hence equals a true predicate. An inconsistent process term that is guarded by any guard is equivalent to the negation of the guard. By rewriting this property as u ↔ ¬u → ⊥, where the delay predicate u and guard b share the same syntax, it becomes clear that the delay predicate is not a primitive. Finally, the guard distributes over the alternative composition operator.</p><p>Proposition 10 (Sequential composition). The following properties hold for all closed process terms p, q, r ∈ P and guards b:</p><formula xml:id="formula_89">δ; p ↔ δ ( p [] q); r ↔ p; r [] q ; r (p; q); r ↔ p; (q ; r) b → (p; q) ↔ (b → p); q</formula><p>A deadlock process term followed by some other process terms is equivalent to the deadlock process term itself since the deadlock process term does not terminate successfully, i.e., deadlock is a left-zero element for sequential composition.</p><p>Sequential composition is associative and alternative composition distributes over sequential composition from the left. A guard distributes to the left argument of a sequential composition.</p><p>Proposition 11 (Parallel composition). The following properties hold for all closed process terms p, q, r ∈ P :</p><formula xml:id="formula_90">p || q ↔ q || p (p|| q) || r ↔ p || (q || r)</formula><p>Parallel composition is commutative and associative.</p><p>Proposition 12 (Action encapsulation operator). The following properties hold for all closed process terms p ∈ P , and sets of actions A, A :</p><formula xml:id="formula_91">∂ ∅ (p) ↔ p ∂ A (∂ A (p)) ↔ ∂ A∪A (p)</formula><p>If there are no actions to be encapsulated, the application of the action encapsulation operator to a process term p has no effect. Multiple applications of the action encapsulation operator are equivalent to a single application where all the actions to be encapsulated are combined using union of sets of actions.</p><p>Proposition 13 (Inconsistent process). The following properties hold for all closed process terms p ∈ P and predicates u:</p><formula xml:id="formula_92">u ⊥ ↔ ⊥ ⊥; p ↔ ⊥ p [] ⊥ ↔ ⊥ skip; ⊥ ↔ δ p || ⊥ ↔ ⊥ ⊥ ↔ false ∂ A (⊥) ↔ ⊥</formula><p>The inconsistent process term is a zero element for the signal emission operator, alternative composition, parallel composition and the action encapsulation operator. It is also a left-zero element for sequential composition. Going on as ⊥ after performing an action transition, for example skip, is impossible. Since ⊥ and false predicate cannot perform any transition, both process terms are equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related work</head><p>The χ formalism is a hybrid process algebra, and is thus related to the other hybrid process algebras: HyPA <ref type="bibr" target="#b30">[31]</ref>, process algebra for hybrid systems ACP srt hs <ref type="bibr" target="#b24">[25]</ref>, the φ-calculus <ref type="bibr" target="#b31">[32]</ref>, the hybrid formalisms based on CSP <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>, and the process algebra <ref type="bibr" target="#b34">[35]</ref>.</p><p>The latter three process algebras <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b34">35]</ref> differ from χ in that they do not have shared variables. Shared variables are essential for modular specification of continuous and hybrid systems. The two CSP based formalisms also differ from the other process algebras in that they use a denotational semantics instead of an operational semantics. An operational semantics is generally believed to be more intuitive and easier to understand than a denotational semantics <ref type="bibr" target="#b35">[36]</ref>.</p><p>The φ-calculus differs from the other process algebras in that continuous behavior is not defined by means of predicates in process terms. Instead, continuous behavior is defined by means of an environment. Process terms operate on the environment to update initial values, vector-fields, and algebraic constraints. In this way, the φ-calculus can deal with dynamically reconfigurable processes. The resulting differential equations are required to be autonomous. This limits the specification of continuous systems, using the φ-calculus, to that of ordinary differential equations (ODEs).</p><p>The relation between χ , hybrid automata, HyPA and ACP srt hs is discussed below. When comparing χ to hybrid automata, it should be kept in mind that many different hybrid automaton definitions exist. Some definitions require solutions for the continuous variables to be differentiable functions, e.g. in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref>. Other definitions allow the more general case of piecewise differentiable or piecewise continuous functions, e.g. in <ref type="bibr" target="#b8">[9]</ref>. In <ref type="bibr" target="#b9">[10]</ref>, for each variable a dynamic type can be defined, which allows among others solutions in the form of discontinuous functions. Most definitions of hybrid automata do not define urgent transitions, or they define urgent transitions in a restrictive way (non-guarded), as in <ref type="bibr" target="#b13">[14]</ref>. In <ref type="bibr" target="#b4">[5]</ref>, urgent transitions are defined in a general way, using a predicate that defines the maximum sojourn time in a location. However, instead of invariants and flow clauses, evolution functions are used in locations. With respect to the meaning of jump clauses, that define the behavior of the variables in action transitions, differences also occur: where in <ref type="bibr" target="#b7">[8]</ref> the variables can in principle perform arbitrary jumps unless restricted by the jump predicate, in <ref type="bibr" target="#b13">[14]</ref>, variables in principle remain unchanged unless changes are enforced by the jump predicate. Most hybrid automata distinguish between flow clauses, or vector fields, and invariants. In <ref type="bibr" target="#b36">[37]</ref>, however, invariants and flow clauses are combined into one predicate (as in ACP srt hs , HyPA, and χ ). Finally, some hybrid automata have a precisely defined syntax, in particular the input languages of the verification tools PHAver <ref type="bibr" target="#b37">[38]</ref> and HyTech <ref type="bibr" target="#b13">[14]</ref>. Many other hybrid automata are mainly semantical models, such as the hybrid automata defined in <ref type="bibr" target="#b9">[10]</ref> and <ref type="bibr" target="#b10">[11]</ref>.</p><p>Where HyPA is a conservative extension of ACP from <ref type="bibr" target="#b38">[39]</ref>, and ACP srt hs is a conservative extension of a combination of the process algebra with continuous relative timing from <ref type="bibr" target="#b39">[40]</ref> and the process algebra with propositional signals from <ref type="bibr" target="#b23">[24]</ref>, hybrid χ is not an extension of any previously existing process algebra. Hybrid χ has been proven to be an operational conservative extension of timed χ in <ref type="bibr" target="#b40">[41]</ref>. The semantics of hybrid χ and timed χ , which is derived from hybrid χ, differs considerably from the semantics of their discrete-event predecessor χ σ as defined in <ref type="bibr" target="#b18">[19]</ref>. Where χ σ has non-delayable guards, a weak timedeterministic alternative composition operator, urgent actions only, and no (global) time variable, the semantics of χ as defined in this paper has delayable guards, a strong timedeterministic alternative composition operator, urgent and non-urgent actions, and a global variable denoting the model time.</p><p>The integration between the DC and CS world views in χ was inspired by HyPA. Also, the use of delay predicates as atomic process term was inspired by HyPA. The χ formalism and ACP srt hs were both strongly influenced by hybrid automata. ACP srt hs , χ , and hybrid automata share the 'consistent equation semantics'. For a hybrid automaton, the invariant of the current location should hold in the current state, and transitions to a new state and new location are allowed only if the invariant of the new location holds in the new state. Correspondingly, in ACP srt hs and χ , the equations (delay predicates) of the process term should be consistent with the current state, and transitions to a new process term are allowed only if the equations (delay predicates) of the new process term are consistent with the new state. The hybrid automaton defined in <ref type="bibr" target="#b5">[6]</ref> has a different semantics in that it allows transitions to a new location only if the invariant of the current location holds in the current state and in the new state. The signal emission operator in χ was inspired by the signal emission operator from ACP srt hs , which in its turn comes from the process algebra with relative timing from <ref type="bibr" target="#b39">[40]</ref>. Some differences between χ , hybrid automata, ACP srt hs , and HyPA are: • Where some hybrid automata and ACP srt hs use continuous variables that are allowed to jump arbitrarily in an action transition with a true reset predicate, and other hybrid automata and HyPA use continuous variables that are not allowed to jump in an action transition, unless explicitly specified, χ uses both classes of continuous variables. Furthermore, χ adds discrete and algebraic variables. Some hybrid automata (e.g. see <ref type="bibr" target="#b10">[11]</ref>) also define discrete variables (instead of locations). The behavior of the algebraic variables from χ is related to the external variables from the semantical hybrid automata defined in <ref type="bibr" target="#b9">[10]</ref>. The external variables are not part of the state, and they can have a dynamic type that allows discontinuous trajectories. However, discrete transitions (action transitions) are defined only on internal variables, and the concept of internal and external variables is linked to visibility and hiding in <ref type="bibr" target="#b9">[10]</ref>. In χ, all variables can be used in action predicates, and the different classes of variables and hiding/abstraction are orthogonal concepts.</p><p>• Where in ACP srt hs and the hybrid automaton definition from <ref type="bibr" target="#b36">[37]</ref> the dotted variables (derivatives) are part of the state (valuation), in HyPA, other hybrid automata, and χ they are not. The reason for this in χ is that the valuation together with the process term and the environment represent all that is needed to be able to determine future behavior. The values of the dotted variables are not needed for this purpose. For the same reason, algebraic variables are not part of the valuation in χ . Their values are determined completely by the process term.</p><p>• Where HyPA does not specify a solution concept for algebraic differential equations, and ACP srt hs requires differentiability of the trajectories of the continuous variables, the χ semantics defines a solution concept that is parameterized with the type of trajectories allowed. In this paper, piecewise continuous functions for the trajectories of the algebraic and dotted variables are allowed. The parametrization of the solution concept in χ is related to the dynamic type present in <ref type="bibr" target="#b9">[10]</ref>. Of course, since the solution concept of HyPA is a parameter of the semantics, it could use the solution concept defined in χ .</p><p>• Where in χ the passage of time cannot make a choice between the operands of alternative composition, in ACP srt hs , the passage of time can enforce such a choice. In HyPA, the passage of time will always make a choice between the operands of the choice operator. This corresponds to the initial behavior of a hybrid automaton: depending on the initial state, a non-deterministic choice can be made for the first location where continuous behavior or discrete behavior may take place. After this first choice, a hybrid automaton cannot change location as a result of time passing, nor can outgoing edges disappear as a result of time passing.</p><p>• The syntactic extensions present in χ are unavailable in the other three formalisms, apart from the delay operator, which is also available in ACP srt hs . However, in ACP srt hs , the expression defining the amount of delay cannot contain variables. Furthermore, the scope operators, and process definition and instantiation process terms for complex system specification are available only in χ , apart from the variable scope operator which is added to HyPA in <ref type="bibr" target="#b41">[42]</ref>. An interesting question is whether the χ functionality could have been obtained by extending HyPA and ACP srt hs with the χ scope operators, with the χ urgent communication operator, and with similar syntactic extensions as defined in χ . This approach suffers from fundamental limitations. The most important of these are:</p><p>• The algebraic variables present in χ cannot be incorporated in this way, because their functionality is reflected in the operational semantics of several process terms. • The χ solution concept is quite different from the solution concept in ACP srt hs .</p><p>• The semantics of the guards in χ (delayable) is fundamentally different from the semantics of the guards in HyPA and ACP srt hs (non-delayable). • The flexibility of urgency in χ , where non-delayable actions have priority over delayable actions, is obtained by a carefully defined semantics of several operators (alternative composition, parallel composition, guard). It cannot be obtained by means of extensions to ACP srt hs or HyPA. • The consistent equation semantics of χ is fundamentally different from the HyPA semantics, where equations can (temporarily) become inconsistent as a result of actions. The additional functionality of χ makes axiomatization more difficult, when compared to ACP srt hs and HyPA. When it comes to tool support, the additional functionality offered by χ probably means additional efforts for implementation. At this moment, it is difficult to further compare the expected efforts required for tool implementations of χ , ACP srt hs and HyPA.</p><p>Other formalisms for hybrid system specification are hybrid Petri nets <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b43">44]</ref>, and formalisms based on hybrid automata such as Charon <ref type="bibr" target="#b44">[45]</ref> and Masaccio <ref type="bibr" target="#b45">[46]</ref>. There are many differences and similarities between χ and these other formalisms. The main difference, however, between χ and other formalisms, including the process algebras and hybrid automata discussed before, is that we consider χ to be overall better suited to modeling. This may mean that certain phenomena can be modeled in χ whereas they cannot be modeled in another formalism, or that certain phenomena can be modeled more concisely or more intuitively in χ .</p><p>Which systems can be modeled in χ and not in other formalisms, or the other way round, is difficult to establish. It also depends on the notion of equivalence. For example, the equation y = step(t -1), where y is an algebraic variable, t denotes time and step is a discontinuous function such that step(x) is 0 for x &lt; 0 and 1 for x ≥ 0, cannot be specified, or does not have the required behavior, in many formalisms. The required behavior can however be approximated by introducing an additional action to model the discontinuity. As another example, steady state initialization, as in ẋ = 0 ẋ = -x + 1, cannot be expressed in most formalisms. When the equations are straightforward enough, however, the same effect can be obtained by direct initializations. In this example, by initializing variable x to 1.</p><p>The following properties make χ highly suited to modeling:</p><p>(1) The integration between the DC and CS world views as explained in Section 1. In this respect χ differs from the other formalisms mentioned above, apart from HyPA and the hybrid automata such as defined in <ref type="bibr" target="#b8">[9]</ref>. (2) The combination of concise and intuitive language primitives, well suited to modeling, with a straightforward semantics, well suited to verification. This was in fact the biggest challenge in the design of χ . After numerous attempts to define the language primitives with associated syntax and semantics, it appeared that either the language was well suited to modeling, but with complex semantics, unsuited to verification; or the semantics was straightforward and elegant, but at the same time the language was cumbersome for modeling. The reason for this apparent contradiction is that the requirements for language primitives for verification and the requirements for language primitives for modeling are not the same. (3) The relatively large number of operators dedicated to the modeling of discrete-event behavior: This makes it easy to abstract from continuous behavior and specify timed discrete-event models, without any continuous variables and without differential (algebraic) equations. In this respect, χ has much in common with the hybrid formalisms based on CSP <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>, and with ACP srt hs . (4) Process instantiation, based on the modeling scope operator: this enables hierarchical composition of processes. It also provides encapsulation and data hiding, and it enables re-use of processes: parameterized processes can be defined once and instantiated many times with the same or different parameters. In this respect, the χ formalism is related to Charon and Masaccio, which allow components to be defined and instantiated. The χ formalism, being a process algebra, does not only allow parallel composition (as Charon and Masaccio) and sequential composition (as Masaccio), but allows in principle any combination of process terms by means of the χ operators.</p><p>Local variables, variable and/or action abstraction are present also in other formalisms. Hybrid I/O automata <ref type="bibr" target="#b9">[10]</ref> define both action abstraction and variable abstraction, which are referred to as hiding of external actions and external variables. Hybrid (I/O) automata, however, need to be 'compatible' to allow parallel composition. Hybrid I/O automata, for example, require disjointness of the internal variables of the automata in parallel composition.</p><p>In χ , the concepts of variable abstraction and channel abstraction (comparable with action abstraction in other formalisms) are integrated in the modeling scope operator, which also provides a local scope for variables, channels, and recursion definitions. In this respect, the χ modeling scope operator is a high level modeling primitive unavailable in the other hybrid formalisms. Also, there are no compatibility restrictions on processes for parallel composition. Modular composition of processes is further supported by means of different interaction mechanisms. Processes can interact in three different ways:</p><p>• By means of shared variables, which is the main interaction mechanism for continuoustime processes consisting of systems of differential algebraic equations. Interaction between processes in Charon and Masaccio also takes place by means of shared variables. Synchronization by means of actions is, however, not supported. • By means of channel based 'handshake synchronization'. It is comparable to actions in (hybrid) (I/O) automata and actions in ACP-based process algebras. A difference is that actions can be used to express synchronization between two or more processes. The synchronization mechanism used in χ is CSP <ref type="bibr" target="#b46">[47]</ref> based. A channel can be shared by any number of processes, but synchronization always occurs on a point-to-point basis, so between exactly two processes. Another difference is that the interaction mechanism in χ also allows synchronous communication, as explained below, whereas actions are strictly used for synchronization. • By means of synchronous communication, which is the CSP interaction mechanism that combines synchronization with data-transfer, as also used in <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions and future work</head><p>The χ formalism differs considerably from other formalisms. On the one hand, it supports the dynamics and control way of hybrid systems modeling by means of discontinuous functions and/or switched equation systems, possibly leading to discontinuous trajectories. On the other hand, it supports the computer science way of hybrid systems modeling, where actions are used to model discontinuities. With respect to the computer science way of modeling, the χ formalism is heavily influenced by hybrid automata. The two formalisms both have a choice mechanism where, apart from initialization in a hybrid automaton, the passage of time cannot result in choices between operands (χ ) or choices between locations or outgoing edges (hybrid automata). The χ formalism also shares the consistency concept with many hybrid automata: state changes in χ need to be consistent with delay predicates, which include the invariant and flow clauses of hybrid automata.</p><p>The χ formalism combines ease of modeling with a straightforward, formal semantics. Ease of modeling is ensured by means of different classes of variables, such as discrete, non-jumping continuous, jumping continuous and algebraic variables; by means of its delayable guard that ensures that the guard always holds when the first action of the guarded process term occurs; by means of its integration of urgent (non-delayable) and non-urgent (delayable) actions on the one hand, and urgent and non-urgent channels on the other hand; by means of allowing the modeling of differential algebraic equations as a process term as in mathematics; by means of allowing straightforward steady-state initialization; and by means of several user-friendly syntactic extensions.</p><p>The χ formalism is suited to modeling, simulation and verification of: (timed) discreteevent systems without (differential) equations, continuous-time systems consisting of ordinary differential equations with algebraic constraints, and combined discrete-event/ continuous-time systems. It is especially suited to the specification and analysis of complex systems. This is achieved by means of the process terms for scoping, that integrate abstraction, local variables, local channels and local recursion definitions; by means of the process definition and instantiation syntactic extensions that enable process re-use, encapsulation, hierarchical and/or modular composition of processes; and by means of the different interaction mechanisms, namely handshake synchronization and synchronous communication that are mainly intended for discrete-event processes that do not share variables, and shared variables that are mainly intended for interaction between continuous-time or hybrid processes.</p><p>Future work entails among others: • The definition of (formal) translations from χ to hybrid automata and input languages of verification tools to enable verification of model properties. For hybrid models PHAver <ref type="bibr" target="#b37">[38]</ref>, HyTech <ref type="bibr" target="#b6">[7]</ref>, CheckMate <ref type="bibr" target="#b47">[48]</ref>, d/dt <ref type="bibr" target="#b48">[49]</ref>, and the tools <ref type="bibr" target="#b49">[50]</ref><ref type="bibr" target="#b50">[51]</ref><ref type="bibr" target="#b51">[52]</ref><ref type="bibr" target="#b52">[53]</ref> are options. • Redesign of the old hybrid χ simulator described in <ref type="bibr" target="#b16">[17]</ref>.</p><p>• Where ACP srt hs and HyPA have derived large sets of axioms to support equational reasoning, in χ , so far, only a limited set of properties has been derived. More properties need to be derived.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Proofs of properties of the Chi semantics</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1. The proof of Lemma 1</head><p>Let p and p be closed process terms, σ, σ be valuations, ξ, ξ be extended valuations, E and E be environments, a be an action, ρ be a trajectory, and t ∈ T . Then</p><formula xml:id="formula_93">p, σ, E ξ,a,ξ -→ _, σ , E ⇒ dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ ∧E = E , p, σ, E t,ρ -→ p , σ , E ⇒ dom(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ ∧E = E , p, σ, E ξ ⇒ ξ σ = σ, where p, σ, E ξ,a,ξ -→ _, σ , E is an abbreviation for p, σ, E ξ,a,ξ -→ p , σ , E for some p .</formula><p>Proof. We prove this lemma by induction on the depth of the proof of the transition in the left-hand side of the implication and case distinction on the deduction rule applied last in such a proof. The proof for the equality E = E in the right-hand side of the implication is trivial, because the equality E = E holds necessarily according to the result of each χ deduction rule. Therefore, we do not give the proof of this equality for each rule. In what follows, we write E as E.</p><p>Firstly, we give the proofs for p, σ, E ξ,a,ξ</p><formula xml:id="formula_94">-→ _, σ , E ⇒ dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>We do not explicitly separate the base cases and the inductive steps.</p><p>The rule applied last is • Rule 1. Then ξ = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → and σ = ξ σ , where ξ σ is an abbreviation for ξ dom(σ ). The domain of the extended valuation ξ is given by dom(σ ) ∪ Ċ ∪ L, and the domain of ξ dom(σ ) is dom(ξ ) ∩ dom(σ ). Since dom(σ ) = dom(ξ σ ), it is not hard to see that dom(σ ) = dom(σ ). For ξ = σ ∪ ξ ĊL , we obtain ξ σ = σ . We also have σ = ξ σ , because dom(σ ) = dom(σ ). • Rules 5 and 6 are similar to the previous case.</p><p>• Rule 10. Then, p = [q] for some q and q, σ, E ξ,a,ξ -→ _, σ , E . By induction we then have dom(σ</p><formula xml:id="formula_95">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 13. Then p ≡ u q for some u and q, q, σ, E ξ,a,ξ -→ _, σ , E and ξ |= u. By induction we then have dom(σ</p><formula xml:id="formula_96">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 16. Then p ≡ q 1 ; q 2 for some q 1 and q 2 , q 1 , σ, E ξ,a,ξ -→ _, σ , E and q 2 , σ , E ξ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By induction we then have dom(σ</head><formula xml:id="formula_97">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 17. Then p ≡ q 1 ; q 2 for some q 1 and q 2 , and q 1 , σ, E ξ,a,ξ -→ _, σ , E . By induction we then have dom(σ</p><formula xml:id="formula_98">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 20. Then p ≡ b → q for some b and q, q, σ, E ξ,a,ξ -→ _, σ , E and ξ |= b. By induction we then have dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</p><p>• Rule 25. Then p ≡ q 1 [] q 2 for some q 1 and q 2 , and q 1 , σ, E ξ,a,ξ -→ _, σ , E and q 2 , σ, E ξ . By induction we then have dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</p><p>• Rule 28. Then p ≡ q 1 || q 2 for some q 1 and q 2 , and q 1 , σ, E a ξ,a,ξ -→ _, σ , E a and q 2 , σ, E b ξ,b,ξ -→ _, σ , E b for some (unimportant) actions a and b, and some (unimportant) environments E a and E b . By induction we then have dom(σ</p><formula xml:id="formula_99">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 29. Then p ≡ q 1 || q 2 for some q 1 and q 2 , and q 1 , σ, E ξ , q 1 , σ, E ξ,a,ξ -→ _, σ , E and q 2 , σ , E ξ . By induction we then have dom(σ</p><formula xml:id="formula_100">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 32. Then p ≡ ∂ A (q) for some A and q, q, σ, E ξ,a,ξ -→ _, σ , E , and a ∈ A. By induction we then have dom(σ</p><formula xml:id="formula_101">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 35. Then p ≡ υ H (q) for some H and q, and q, σ, E ξ,a,ξ -→ _, σ , E . By induction we then have dom(σ <ref type="figure">,</ref><ref type="figure">J,</ref><ref type="figure">L,</ref><ref type="figure">H,</ref><ref type="figure">R</ref>) and p ≡ ι J + (q) for some J + and q, and (C, J ∪</p><formula xml:id="formula_102">) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ . • Rule 38. Then p ≡ X for some X, E = (C, J, L, H, R) and R(X), σ, E ξ,a,ξ -→ _, σ , E . By induction, we have dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ . • Rule 41. Then E = (C</formula><formula xml:id="formula_103">J + , L, H, R) q, σ ξ,a,ξ -→ _, σ , E . By induction we then have dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ .</formula><p>• Rule 44. We assume p, σ, E ξ x ,a,ξ y -→ _, σ , E for some ξ x and ξ y . Then, we have <ref type="figure">d,</ref><ref type="figure">d ,</ref><ref type="figure">x ,</ref><ref type="figure">g ,</ref><ref type="figure">σ d</ref> x , σ , σ = σ σ ; ξ, ξ such that ξ x = ξ (dom(σ ) ∪ Ċ ∪ L) and ξ y = ξ (dom(σ ) ∪ Ċ ∪ L). Note that the syntactical equality of p is not given, because it is irrelevant for this proof.</p><formula xml:id="formula_104">E = (C, J, L, H, R), p ≡ |[ V σ dx ⊥ , {x}, {g} | q ]| for some q, σ dx ⊥ , x, g, (C ∪ {x }, J, L ∪ {g }, H, R) q[d , x , g /d, x, g], σ ∪ σ d x ξ,a,ξ -→ _, σ for some</formula><p>-Firstly, we have to show that dom(σ ) = dom(σ σ ). By induction, we know that dom(σ</p><formula xml:id="formula_105">∪ σ d x ) = dom(σ ) ∪ dom(σ d x ) = dom(σ ). On the other hand, dom(σ σ ) = dom(σ ) ∩ dom(σ ) = (dom(σ ) ∪ dom(σ d x )) ∩ dom(σ ) = dom(σ ), i.e. dom(σ ) = dom(σ σ ).</formula><p>-Secondly, we have to show that ξ x dom(σ ) = σ . By induction, we know that ξ dom(σ</p><formula xml:id="formula_106">∪ σ d x ) = σ ∪ σ d x , then ξ dom(σ ) = σ and ξ dom(σ d x ) = σ d x .</formula><p>On the other hand,</p><formula xml:id="formula_107">ξ x dom(σ ) = (ξ (dom(σ ) ∪ Ċ ∪ L)) dom(σ ) = ξ dom(σ ) = σ , i.e. ξ x dom(σ ) = σ .</formula><p>-Thirdly, we have to show that ξ y dom(σ σ ) = σ σ . By induction, we know that ξ dom(σ ) = σ . On the other hand,</p><formula xml:id="formula_108">ξ y dom(σ σ ) = (ξ (dom(σ ) ∪ Ċ ∪ L)) dom(σ σ ) = (ξ (dom(σ ) ∪ Ċ ∪ L)) (dom(σ ) ∩ dom(σ )) = ξ (dom(σ ) ∩ dom(σ )). From σ = ξ dom(σ ), we obtain σ σ = σ dom(σ ) = (ξ dom(σ )) dom(σ ). It is not hard to see that ξ (dom(σ ) ∩ dom(σ )) = (ξ dom(σ )) dom(σ ), which also means ξ y dom(σ σ ) = σ σ .</formula><p>• Rules 47, 48 and 51. The proofs are similar. We only give the proof for Rule 47. Then</p><formula xml:id="formula_109">p ≡ |[ H {h} | q ]| for some h, q, E = (C, J, L, H, R), (C, J, L, H ∪ {h }, R) q[h /h], σ ξ,b,ξ</formula><p>-→ _, σ , E for some unimportant action b for this proof, h and h ∈ {h } for some h. By induction we then have dom(σ ) = dom(σ ) ∧ ξ σ = σ ∧ ξ σ = σ . The rules that have not been considered could not have been applied last since they conclude a time transition or a consistency predicate.</p><p>Secondly, we give the proofs for p, σ, E t,ρ -→ p , σ , E ⇒ dom(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ . We do not explicitly separate the base cases and the inductive steps.</p><p>The rule applied last is • Rule 3. Then, p ≡ u ≡ p for some u, E = (C, J, L, H, R), ρ ∈ FG (σ, C, L, u, t), and σ = ρ σ (t). Then, by the definition of FG , dom(ρ) = [0, t], and ρ(0) dom(σ ) = ρ σ (0) = σ necessarily. From σ = ρ σ (t), we know that dom(σ ) = dom(σ ). Therefore, we also have σ = ρ σ (t). • Rule 11. Then p ≡ [q] ≡ p for some q, ρ ∈ σEt and σ = ρ σ (t). Then, by the definition of FG , dom(ρ) = [0, t], and ρ(0) dom(σ ) = ρ σ (0) = σ necessarily. From σ = ρ σ (t), we know that dom(σ ) = dom(σ ). Therefore, we have also σ = ρ σ (t). • Rule 14. Then p ≡ u q for some u and q, q, σ, E t,ρ -→ p , σ , E and ρ(0) |= u. By induction we then have dom</p><formula xml:id="formula_110">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>• Rule 18. Then p ≡ q 1 ; q 2 for some q 1 and q 2 , q 1 , σ, E t,ρ -→ q 1 , σ , E for some q 1 and p ≡ q 1 ; q 2 . By induction we then have dom</p><formula xml:id="formula_111">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>• Rule 21. Then p ≡ b → q for some b and q, q, σ, E t,ρ -→ q , σ , E for some q such that p ≡ b → q , and ∀ s∈[0,t] ρ(s) |= b. By induction we then have dom</p><formula xml:id="formula_112">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>• Rule 22. Then p ≡ b → q ≡ p for some b and q, ρ ∈ σEt and σ = ρ σ (t) (some irrelevant information for the proof is omitted). By the definition of FG , dom(ρ) = [0, t], and ρ(0) dom(σ ) = ρ σ (0) = σ necessarily. From σ = ρ σ (t), we know that dom(σ ) = dom(σ ). Therefore, we have also σ = ρ σ (t). • Rule 26. Then p ≡ q 1 [] q 2 for some q 1 and q 2 , q 1 , σ, E t,ρ -→ q 1 , σ , E and q 2 , σ, E t,ρ -→ q 2 , σ , E for some q 1 and q 2 , and p ≡ q 1 [] q 2 . By induction we then have dom</p><formula xml:id="formula_113">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>• Rule 30. Then p ≡ q 1 || q 2 for some q 1 and q 2 , q 1 , σ, E t,ρ -→ q 1 , σ , E and q 2 , σ, E t,ρ -→ q 2 , σ , E , for some q 1 and q 2 , and p ≡ q 1 || q 2 . By induction we then have dom</p><formula xml:id="formula_114">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>• Rule 33. Then p ≡ ∂ A (q) for some A and q, q, σ, E t,ρ -→ q , σ, E for some q , and p ≡ ∂ A (q ). By induction we then have dom</p><formula xml:id="formula_115">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>• Rule 37. Then p ≡ υ H (q) for some H and q, and q, σ, E t,ρ -→ q , σ, E for some q , and p ≡ υ H (q ) (some irrelevant information for this proof is omitted). By induction we then have dom <ref type="figure">E = (C, J, L, H, R)</ref> and<ref type="figure">R(X), σ, E   t,ρ   -→ p , σ , E</ref> . By induction we then have dom</p><formula xml:id="formula_116">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ . • Rule 39. Then p ≡ X for some X,</formula><formula xml:id="formula_117">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>• Rule 42. Then p ≡ ι J + (q) for some term q and set J</p><formula xml:id="formula_118">+ , E = (C, J, L, H, R), (C, J ∪ J + , L, H, R) q, σ t,ρ</formula><p>-→ q , σ for some q , and p ≡ ι J + (q ). By induction we then have dom</p><formula xml:id="formula_119">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ . • Rule 45. We assume p, σ, E t,ρ -→ p , σ , E for some ρ . Then E = C,J ∪ J + ,L, H, R, p ≡ |[ V σ dx ⊥ , {x}, {g} | q ]| for some q, σ dx ⊥ ,x,g, (C ∪ {x },J, L ∪ {g },H, R) q[d , x , g /d, x, g], σ ∪ σ d x t,ρ</formula><p>-→ q , σ for some q , d, d , x , g , σ d x , σ , σ = σ σ , and ρ = ρ σ ĊL = ρ ↓ (dom(σ ) ∪ Ċ ∪ L). Note that the syntactical equality of p is not given, because it is irrelevant for this proof.</p><p>-Firstly, we have to show that dom(ρ ↓ (dom(σ ) ∪ Ċ ∪ L)) = [0, t]. By induction we know that dom(ρ) = [0, t]. On the other hand, we have dom(ρ</p><formula xml:id="formula_120">↓ (dom(σ ) ∪ Ċ ∪ L)) = dom(ρ) = [0, t].</formula><p>-Secondly, we have to show that ρ ↓ dom(σ</p><formula xml:id="formula_121">)(0) = (ρ ↓ (dom(σ ) ∪ Ċ ∪ L)) ↓ dom(σ )(0) = σ . By induction we know that ρ ↓ (dom(σ ∪ σ d x ))(0) = σ ∪ σ d x .</formula><p>Then, we have also ρ ↓ dom(σ</p><formula xml:id="formula_122">)(0) = σ and ρ ↓ dom(σ d x )(0) = σ d x . On the other hand, ρ ↓ dom(σ )(0) = (ρ ↓ (dom(σ ) ∪ Ċ ∪ L)) ↓ dom(σ )(0) = ρ ↓ dom(σ )(0) = σ . -Thirdly, we have to show that ρ ↓ dom(σ σ )(t) = (ρ ↓ (dom(σ ) ∪ Ċ ∪ L)) ↓ dom(σ σ )(t) = σ σ . By induction we know that ρ ↓ dom(σ )(t) = σ . Then, we have (ρ ↓ dom(σ )) ↓ dom(σ )(t) = σ ↓ dom(σ ) = σ σ . On the other hand, ρ ↓ dom(σ σ )(t) = (ρ ↓ (dom(σ ) ∪ Ċ ∪ L)) ↓ dom(σ σ )(t) = ((ρ ↓ (dom(σ ) ∪ Ċ ∪ L)) ↓ (dom(σ ) ∩ dom(σ )))(t) = ρ ↓ (dom(σ ) ∩ dom(σ ))(t) = (ρ ↓ dom(σ )) ↓ dom(σ )(t) = σ σ .</formula><p>• Rules 49 and 52. The proofs are similar. We only give the proof for Rule 49.</p><p>Then</p><formula xml:id="formula_123">p ≡ |[ H {h} | q ]| for some h, q, E = (C, J, L, H, R), (C, J, L, H ∪ {h }, R) q[h /h], σ t,ρ</formula><p>-→ q , σ for some q . Note that the syntactical equality of p is not given, because it is irrelevant for this proof. By induction we then have dom</p><formula xml:id="formula_124">(ρ) = [0, t] ∧ ρ σ (0) = σ ∧ ρ σ (t) = σ .</formula><p>The rules that have not been considered could not have been applied last since they conclude an action transition or a consistency predicate.</p><p>The proof for p, σ, E ξ ⇒ ξ σ = σ is trivial. According to all χ deduction rules for consistency predicates, ξ = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → necessarily. Then we have ξ σ = σ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2. The proof of Lemma 2</head><p>Let p and p be closed process terms, σ and σ be valuations, E and E be environments, ξ and ξ be extended valuations and a be an action. Then <ref type="figure">where p,</ref><ref type="figure">σ,</ref><ref type="figure">E   ξ,</ref><ref type="figure">a,</ref><ref type="figure">ξ</ref> -→ is an abbreviation for p, σ, E ξ,a,ξ -→ p , σ , E for some p , σ , and E .</p><formula xml:id="formula_125">p, σ, E ξ,a,ξ -→ ⇒ p, σ, E ξ ,</formula><p>Proof. We prove this lemma by induction on the depth of the proof of p, σ, E ξ,a,ξ -→ using case distinction based on the deduction rule applied last. We do not explicitly separate the base cases and the inductive steps.</p><p>The rule applied last is • Rule 10. Then, p = [q] for some q, E = (C, J, L, H, R) and q, σ, E ξ,a,ξ -→ . By induction we then have q, σ, E ξ . Then, by Rule 12, we have [q], σ, E ξ , and ξ = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → .</p><formula xml:id="formula_126">• Rule 1. Then p ≡ W : r l a for some W , r, l a , ξ = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → ,</formula><p>• Rule 13. Then p ≡ u q for some u and q, q, σ, E ξ,a,ξ -→ and ξ |= u. By induction q, σ, E ξ . Then, by Rule 15, we have u q, σ, E ξ .</p><p>• Rule 16. Then p ≡ q 1 ; q 2 for some q 1 and q 2 , q 1 , σ, E ξ,a,ξ -→ , σ , E and</p><formula xml:id="formula_127">q 2 , σ , E ξ . By induction q 1 , σ, E ξ .</formula><p>Then, by Rule 19, we have q 1 ; q 2 , σ, E ξ .</p><p>• Rule 17. Then p ≡ q 1 ; q 2 for some q 1 and q 2 , and q 1 , σ, E ξ,a,ξ -→ q 1 , σ , E for some q 1 . By induction q 1 , σ, E ξ . Then, by Rule 19, we have q 1 ; q 2 , σ, E ξ .</p><p>• Rule 20. Then p ≡ b → q for some b and q, q, σ, E ξ,a,ξ -→ and ξ |= b. By induction q, σ, E ξ . Then, by Rule 23, we have b → q, σ, E ξ .</p><p>• Rule 25. Then p ≡ q 1 [] q 2 for some q 1 and q 2 , and q 1 , σ, E ξ,a,ξ -→ and q 2 , σ, E ξ .</p><p>By induction q 1 , σ, E ξ . Then, by Rule 27, we have q 1 [] q 2 , σ, E ξ .</p><p>• Rule 28. Then p ≡ q 1 || q 2 for some q 1 and q 2 , and q 1 , σ, E a ξ,a,ξ -→ and q 2 , σ, E b ξ,b,ξ -→ for some (unimportant) actions a and b, and some (unimportant) environments E a and E b . By induction q 1 , σ, E a ξ and q 2 , σ, E b ξ . Then, by Rule 31 and by Lemma 4, we have q 1 [] q 2 , σ, E a ξ .</p><p>• Rule 29. Then p ≡ q 1 || q 2 for some q 1 and q 2 , and q 1 , σ, E ξ,a,ξ -→ and q 2 , σ, E ξ . By induction q 1 , σ, E ξ . Then, by Rule 31, we have q 1 [] q 2 , σ, E ξ .</p><p>• Rule 32. Then p ≡ ∂ A (q) for some A and q, q, σ, E ξ,a,ξ -→ , and a ∈ A. By induction we then have q, σ, E ξ . Using Rule 34, we obtain ∂ A (q), σ, E ξ .</p><p>• Rule 35. Then p ≡ υ H (q) for some H and q, and q, σ, E ξ,a,ξ -→ . By induction we then have q, σ, E ξ . Using Rule 36, we obtain υ H (q), σ, E ξ .</p><p>• Rule 38. Then p ≡ X for some X and <ref type="figure">E = (C, J, L, H, R)</ref> and<ref type="figure">R(X), σ, E   ξ,a,ξ   -→</ref> .  <ref type="figure">E = (C,</ref><ref type="figure">J,</ref><ref type="figure">L,</ref><ref type="figure">H,</ref><ref type="figure">R</ref>) and p ≡ ι J + (q) for some J + and q, and (C, J ∪</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By induction, we have R(X), σ, E</head><formula xml:id="formula_128">J + , L, H, R) q, σ ξ,a,ξ -→ . By induction we have (C, J ∪ J + , L, H, R) q, σ ξ .</formula><p>By Rule 43, we have ι J + (q), σ, E ξ .</p><p>• Rule 44. We assume p, σ, E ξ x ,a,ξ y -→ for some ξ x , and ξ y . Then, we have that E = (C, J, L, H, R), p ≡ |[ V σ dx ⊥ , {x}, {g} |q]| for some q, σ dx ⊥ , x, g, and</p><formula xml:id="formula_129">(C ∪ {x }, J, L ∪ {g }, H, R) q[d , x , g /d, x, g], σ ∪ σ d x ξ,a,ξ -→ for some d, d , x , g , σ d x , ξ , ξ such that ξ x = ξ (dom(σ ) ∪ Ċ ∪ L) and ξ y = ξ (dom(σ ) ∪ Ċ ∪ L). By induction we have (C ∪ {x }, J, L ∪ {g }, H, R) q[d , x , g /d, x, g], σ ∪ σ d x ξ .</formula><p>Using -→ for some unimportant action b for this proof, h and h ∈ {h } for some h.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By induction we then q[h /h], σ,(C,J,L,H ∪ {h },R)</head><p>ξ . Using Rule 50, we obtain</p><formula xml:id="formula_130">(C, J, L, H, R) |[ H {h} | q ]|, σ ξ</formula><p>. The rules that have not been considered could not have been applied last since they conclude a time transition or a consistency predicate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3. The proof of Lemma 3</head><p>Let p and p be closed process terms, σ and σ be valuations, E and E be environments, t ∈ T , and ρ be a trajectory. Then, <ref type="figure">p,</ref><ref type="figure">σ,</ref><ref type="figure">E   t,</ref><ref type="figure">σ ,</ref><ref type="figure">E ⇒ p,</ref><ref type="figure">σ,</ref><ref type="figure">E   ρ(0)</ref> . Proof. We prove this lemma by induction on the depth of the proof of p, σ, E t,ρ -→ p , σ , E using case distinction based on the deduction rule applied last. We do not explicitly separate the base cases and the inductive steps.</p><p>The rule applied last is • Rule 3. Then, p ≡ u ≡ p for some u, E = (C, J, L, H, R), ρ ∈ FG (σ, C, L, u, t).</p><p>Then, by definition, ρ(0) |= u and ρ(0) dom(σ ) = σ . Thus ρ(0) = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → . Therefore, by Rule 4, we have u, σ, E ρ(0) . • Rule 11. Then p ≡ [q] for some q and ρ(0) ∈ σEt . Then, by definition,</p><formula xml:id="formula_131">ρ(0) dom(σ ) = σ . Thus ρ(0) = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → . Therefore, by Rule 12, [q], σ, E ρ(0)</formula><p>.</p><p>• Rule 14. Then p ≡ u q for some u and p, q, σ, E t,ρ -→ p , σ , E and ρ(0)</p><p>|= u. Therefore, by induction, q, σ, E ρ(0)</p><p>. Then, by Rule 15, u q, σ, E ρ(0)</p><p>.</p><p>• Rule 18. Then p ≡ q 1 ; q 2 for some q 1 and q 2 , q 1 , σ, E t,ρ -→ q 1 , σ , E for some q 1 , and p ≡ q 1 ; q 2 . By induction we have q 1 , σ, E ρ(0)</p><p>, and thus by application of Rule 19 we have q 1 ; q 2 , σ, E ρ(0) .</p><p>• Rule 21. Then p ≡ b → q for some b and q, q, σ, E t,ρ -→ q , σ , E for some q such that p ≡ b → q , and ∀ s∈[0,t] ρ(s) |= b. By induction we have q, σ, E ρ(0)</p><p>. Since we also have ρ(0) |= b, we have, by Rule 23, b → q, σ, E ρ(0) . • Rule 22. Then p ≡ b → q for some b and q, ρ ∈ σEt , ∀ s∈(0,t) ρ(s) |= ¬b, ρ(0)</p><formula xml:id="formula_132">|= b ⇒ q, σ, E 0,ρ {0}</formula><p>-→ q , σ , E for some q , σ and E . In case ρ(0) |= ¬b, we also have σ ∪ ξ ĊL |= ¬b for some ξ ĊL ∈ ( Ċ ∪ L) → . Then, by Rule 24, b → q, σ, E ρ(0) . In case ρ(0) |= b, we have q, σ, E 0,ρ {0} -→ q , σ , E . By induction we then have q, σ, E ρ {0}(0)</p><p>, which gives q, σ, E ρ(0)</p><p>. By Rule 23 we then have b → q, σ, E ρ(0) . • Rule 26. Then p ≡ q 1 [] q 2 for some q 1 and q 2 , q 1 , σ, E t,ρ -→ q 1 , σ , E for some</p><formula xml:id="formula_133">q 1 , q 2 , σ, E t,ρ -→ q 2 ,</formula><p>σ , E for some q 2 , and p ≡ q 1 [] q 2 . By induction we have</p><formula xml:id="formula_134">q 1 , σ, E ρ(0) and q 2 , σ, E ρ(0)</formula><p>, and thus by application of Rule 27 we have</p><formula xml:id="formula_135">q 1 [] q 2 , σ, E ρ(0)</formula><p>.</p><p>• Rule 30. Then p ≡ q 1 || q 2 for some q 1 and q 2 , q 1 , σ, E t,ρ -→ q 1 , σ , E for some</p><formula xml:id="formula_136">q 1 , q 2 , σ, E t,ρ -→ q 2 ,</formula><p>σ , E for some q 2 , and p ≡ q 1 || q 2 . By induction we have</p><formula xml:id="formula_137">q 1 , σ, E ρ(0) and q 2 , σ, E ρ(0)</formula><p>, and thus by application of Rule 31 we have</p><formula xml:id="formula_138">q 1 || q 2 , σ, E ρ(0)</formula><p>.</p><p>• Rule 33. Then p ≡ ∂ A (q) for some A and q, q, σ, E t,ρ -→ q , σ, E for some q , and p ≡ ∂ A (q ). By induction we then have q, σ, E ρ(0)</p><p>. By Rule 34, we obtain</p><formula xml:id="formula_139">∂ A (q), σ ρ(0)</formula><p>.</p><p>• Rule 37. Then p ≡ υ H (q) for some H and q, and q, σ, E t,ρ -→ q , σ, E for some q , and p ≡ υ H (q ) (some irrelevant information for the proof is omitted). By induction we then have q, σ, E ρ(0)</p><p>. By Rule 36, we obtain υ H (q), σ ρ(0) .</p><p>• Rule 39. Then p ≡ X for some X, E = (C, J, L, H, R) and R(X), σ, E t,ρ -→ p , σ , E .</p><p>As the proof for R(X), σ, E t,ρ -→ p , σ , E has smaller depth, by induction we have</p><formula xml:id="formula_140">R(X), σ, E ρ(0)</formula><p>. Then, by Rule 40, we have X, σ, E ρ(0) as well.</p><p>• Rule 42. Then p ≡ ι J + (q) for some term q and set J + , E = (C, J, L, H, R), (C, J ∪ J + , L, H, R) q, σ, t,ρ -→ q , σ for some q , and p ≡ ι J + (q ). By induction we then have</p><formula xml:id="formula_141">(C, J ∪ J + , L, H, R) q, σ ρ(0)</formula><p>. From Rule 43, we deduce</p><formula xml:id="formula_142">ι J + (q), σ, E ρ(0) . • Rule 45. Then p ≡ |[ V σ dx ⊥ , {x}, {g} | q ]| for some q, E = (C,J,L,H,R), σ dx ⊥ , x, g, (C ∪ {x }, J, L ∪ {g }, H, R) q[d , x , g /d, x, g], σ ∪ σ d x t,ρ -→ q , σ for some ρ, q , d, d , x , g , σ d x , σ , σ = σ σ , and ρ = ρ σ ĊL = ρ ↓ (dom(σ ) ∪ Ċ ∪ L).</formula><p>Note that the syntactical equality of p is not given, because it is irrelevant for this proof. By induction we then have</p><formula xml:id="formula_143">(C ∪ {x }, J, L ∪ {g }, H, R) q[d , x , g /d, x, g], σ ∪ σ d x ρ(0)</formula><p>. By</p><p>Rule 46, we obtain</p><formula xml:id="formula_144">(C, J, L, H, R) |[ V σ dx ⊥ , {x}, {g} | q ]|, σ ρ↓(dom(σ )∪ Ċ∪L)(0)</formula><p>. • Rules 49 and 52. The proofs are similar. We only give the proof for Rule 49. Then</p><formula xml:id="formula_145">p ≡ |[ H {h} | q ]| for some h, q, E = (C, J, L, H, R), (C, J, L, H ∪ {h }, R) q[h /h], σ t,ρ</formula><p>-→ q , σ for some q . Note that the syntactical equality of p is not given, because it is irrelevant for this proof. By induction we then have</p><formula xml:id="formula_146">q[h /h], σ, (C, J, L, H ∪ {h }, R) ρ(0)</formula><p>. By Rule 50, we obtain (C, J, L, H, R)</p><formula xml:id="formula_147">|[ H {h} | q ]|, σ ρ(0)</formula><p>. The rules that have not been considered could not have been applied last since they conclude an action transition or a consistency predicate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4. The proof of Lemma 4</head><p>Let p be a closed process term, σ be a valuation, C, J , W , L be sets of various classes of χ variables such that J and W ⊆ dom(σ ) \ {time}, H be a set of channels, R be a recursion definition, and ξ be an extended valuation. Then</p><formula xml:id="formula_148">p, σ, (C, J, L, H, R) ξ ⇔ p, σ, (C, J ∪ W, L, H, R) ξ .</formula><p>Proof. The proof is trivial. The domain of the extended valuation ξ is given by dom(σ ) ∪ Ċ ∪ L for all χ consistency predicate rules. Hence, any variation in the set of jumping variables in the environment of a consistent χ process is irrelevant for the consistency predicate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Proofs of properties of the Chi operators</head><p>In this section, the outline of the proofs for the properties in Section 5.4 is given. For all of these properties, the proofs follow the same lines. A relation R is defined containing at least all closed instantiations of the property to be proved. Then, it must be shown that this relation is a stateless bisimulation. For this in principle for each pair of closed process terms (p, q) ∈ R, it has to be shown that it satisfies the six conditions of Definition 5. Often, the relation R contains pairs of the form (i d , i d ). Since the proofs are trivial for such pairs these are omitted. As the deduction rules of χ are such that the environment does not change in a transition, we only consider those cases in the proofs. As a consequence we use the notation E as much as possible.</p><p>Since a deduction rule A may consist of some sub-deduction rules, we use the notation Rule A.i.s to indicate the sub-deduction rule that has been applied in the proofs, where A represents a deduction rule number, i represents an index, and s indicates the left or right result.</p><p>Consider the following deduction rule A:</p><formula xml:id="formula_149">p,σ,E ξ,a,ξ -→ p 11 . . . p 1n ,σ ,E , q,σ,E ξ,a,ξ -→ q 11 . . . q 1n ,σ ,E l,σ,E ξ,a,ξ -→ l 11 . . . l 1n ,σ ,E , r,σ,E ξ,a,ξ -→ r 11 . . . r 1n ,σ ,E (A)</formula><p>Rule A.1.l refers to the following sub-deduction rule of deduction rule A:</p><formula xml:id="formula_150">p,σ,E ξ,a,ξ -→ p 11 ,σ ,E , q,σ,E ξ,a,ξ -→ q 11 ,σ ,E l,σ,E ξ,a,ξ -→ l 11 ,σ ,E</formula><p>Similarly, Rule A.n.r refers to the following sub-deduction rule of deduction rule A:</p><formula xml:id="formula_151">p,σ,E ξ,a,ξ -→ p 1n ,σ ,E , q,σ,E ξ,a,ξ -→ q 1n ,σ ,E r,σ,E ξ,a,ξ -→ r 1n ,σ ,E</formula><p>Note that i and/or s can be omitted in the notation Rule A.i.s when there is no such a sub-deduction rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1. Properties of signal emission operator</head><p>Lemma 14. For arbitrary closed process term p we have true p ↔ p.</p><formula xml:id="formula_152">Proof. Let R = {(true p, p) | p ∈ P } ∪ {(i d , i d ) | i d ∈ P }.</formula><p>The proofs of conditions 1-3 are similar to the proofs of conditions 1-3 of Lemma 21 (except the premise ξ |= b is replaced by ξ |= u). The proofs of conditions 4 and 5 are similar to the proofs of conditions 2 and 3 (notice that the premise ξ |= u is replaced by ρ(0) |= u in the proofs). The proofs of condition 6 are similar to the proofs of condition 6 of Lemma 21 (except Rule 24 has not been applied, and the premise ξ |= b is replaced by ξ |= u in the proofs). Proof. The fact that there are no action transition rules, time transition rules and consistency predicate rules defined for in which the initialization predicate is not satisfied, also indicates that false p cannot perform any transition. Therefore, the conditions 1-6 hold trivially.</p><p>Lemma 16. For arbitrary predicate u we have</p><formula xml:id="formula_153">u u ↔ u. Proof. Let R = {(u u, u) | predicate u} ∪ {(i d , i d ) | i d ∈ P }.</formula><p>The fact that there are no action transition rules defined for u, also indicates that u u has no action transitions. Therefore, the conditions 1-3 hold trivially.</p><formula xml:id="formula_154">Condition 4: We assume (C, J, L, H, R) u u, σ t,ρ -→ k 1 , σ for some C, J , L, H , R, σ , t, ρ, k 1 ,</formula><p>σ , which means that Rule 14 has been applied necessarily. Then,</p><formula xml:id="formula_155">(C, J, L, H, R) u, σ t,ρ -→ k 1 , σ and ρ(0) |= u. For (C, J, L, H, R) u, σ t,ρ -→ k 1 , σ , Rule 3 has been applied necessarily. Then, ρ ∈ FG (σ, C, L, u, t), σ = ρ σ (t) and k 1 ≡ u. Using Rule 3, we obtain (C, J, L, H, R) u, σ t,ρ -→ u, ρ σ (t) and observe that (u, u) ∈ R. Condition 5: We assume (C, J, L, H, R) u, σ t,ρ -→ k 1 , σ for some C, J , L, H , R, σ , t, ρ, k 1 , σ ,</formula><p>which means that Rule 3 has been applied necessarily. Then, ρ ∈ FG (σ, C, L, u, t), σ = ρ σ (t) and k 1 ≡ u. We know that ∀ s∈[0,t] ρ(s) |= u (from the definition of the function FG ). Hence, we also have ρ(0) |= u. Using Rule 14, we obtain   </p><formula xml:id="formula_156">(C, J, L, H, R) u u, σ t,ρ -→ u, ρ σ (t) and observe that (u, u) ∈ R.</formula><formula xml:id="formula_157">u (u p) ↔ (u ∧ u ) p. Proof. Let R = {(u (u p), (u ∧ u ) p) | p ∈ P , predicates u, u } ∪ {(i d , i d ) | i d ∈ P }. Condition 1: First, we assume E u (u p), σ ξ,a,ξ -→ , σ for some E, σ , ξ , a, ξ , σ ,</formula><formula xml:id="formula_158">-→ k 1 , σ and ρ(0) |= u . From ρ(0) |= u and ρ(0) |= u , we obtain ρ(0) |= u ∧ u . Using Rule 14, we get E (u ∧ u ) p, σ t,ρ -→ (u ∧ u ) k 1 , σ and observe that (k 1 , k 1 ) ∈ R. Condition 5: We assume E (u ∧ u ) p, σ t,ρ -→ k 1 , σ for some E, σ , t, ρ, k 1 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2. Properties of alternative composition</head><p>Lemma 18 (Idempotency of alternative composition). For closed term p we have   Lemma 19 (Commutativity of alternative composition). For arbitrary closed process terms p and q we have p [] q ↔ q [] p.</p><formula xml:id="formula_159">p [] p ↔ p. Proof. Let R = {(p [] p, p) | p ∈ P } ∪ {(i d , i d ) | i d ∈ P }.</formula><formula xml:id="formula_160">-→ k p , σ for some k p such that k 1 ≡ k p [] k p . Take k 2 ≡ k p and observe that (k 1 , k 2 ) ∈ R. Condition 5: We assume E p, σ t,ρ -→ k 1 , σ for some E, σ , t, ρ, k 1 , σ . Using Rule 26, we obtain E p [] p, σ t,ρ -→ k 1 [] k 1 , σ . Take k 2 ≡ k 1 [] k 1 and observe that (k 2 , k 1 ) ∈ R.</formula><formula xml:id="formula_161">Proof. Let R = {(p [] q, q [] p) | p, q ∈ P } ∪ {(i d , i d ) | i d ∈ P }.</formula><p>Since the deduction rules for [] are symmetrical w.r.t. the left and right argument, obviously all conditions are met.</p><p>Lemma 20 (Associativity of alternative composition). For closed process terms p, q and r we have</p><formula xml:id="formula_162">(p [] q) [] r ↔ p [] (q [] r). Proof. Let R = {((p [] q) [] r, p [] (q [] r)) | p, q, r ∈ P } ∪ {(i d , i d ) | i d ∈ P }.</formula><p>The proof of the left implication of condition 1 is similar to the proof of the right implication. The proofs of conditions 3 and 5 are similar to the proofs of conditions 2 and 4. The proof of the left implication of condition 6 is similar to the proof of the right implication.</p><formula xml:id="formula_163">Condition 1: We assume E (p [] q) [] r, σ ξ,a,ξ</formula><p>-→ , σ for some E, σ , ξ , a, ξ , σ , which means that Rule 25.1.l or Rule 25.1.r has been applied necessarily. Hence, we distinguish two cases: </p><formula xml:id="formula_164">we obtain E p [] (q [] r), σ ξ,a,ξ -→ , σ .<label>(2</label></formula><p>) Rule 25.1.r has been applied. The proof is similar to the previous case.</p><formula xml:id="formula_165">Condition 2: We assume E (p [] q) [] r, σ ξ,a,ξ -→ k 1 , σ</formula><p>for some E, σ , ξ , a, ξ , k 1 , σ , which means that either Rule 25.2.l or Rule 25.2.r has been applied necessarily. Hence, we distinguish two cases:</p><p>(1) Rule 25.2.l has been applied. Then</p><formula xml:id="formula_166">E p [] q, σ ξ,a,ξ -→ k 1 , σ and E r, σ ξ . For E p [] q, σ ξ,a,ξ -→ k 1 , σ</formula><p>, this means that again either Rule 25.2.l or Rule 25.2.r has been applied necessarily. Hence, we again distinguish two cases: (a) Rule 25.2.l has been applied. Then, E p, σ ξ,a,ξ We get E q [] r, σ ξ,a,ξ -→ k 1 , σ using Rule 25.2.l. Applying Rule 25.2.r, we</p><formula xml:id="formula_167">-→ k 1 , σ and E q, σ ξ . Us- ing Rule 27, we obtain E q [] r, σ ξ . We further get E p [] (q [] r), σ ξ,a,ξ -→ k 1 ,</formula><formula xml:id="formula_168">obtain E p [] (q [] r), σ ξ,a,ξ -→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R.</formula><p>(2) Rule 25.2.r has been applied. The proof is similar to the previous case. -→ k r , σ for some k pq and k r such that   -→ k 1 , σ for some C, J , L, H , R, σ , t, ρ, k 1 , σ , which means that either Rule 21 or Rule 22 has been applied necessarily. Then we can distinguish two cases:</p><formula xml:id="formula_169">Condition 4: We assume E (p [] q) [] r, σ t,ρ -→ k 1 , σ for some E, σ , t, ρ, k 1 ,</formula><formula xml:id="formula_170">k 1 ≡ k pq [] k r . For E p [] q, σ t,ρ -→ k pq , σ , we obtain E p, σ t,ρ -→ k p , σ and E q, σ t,ρ -→ k q , σ for some k p , k q such that k pq ≡ k p [] k q (using Rule 26). Applying Rule 26, we get E q [] r, σ t,ρ -→ k q [] k r , σ . Again, due to Rule 26, we can have E p [] (q [] r), σ t,ρ -→ k p [] (k q [] k r ), σ . Note that k 1 ≡ (k p [] k q ) [] k r . Take k 2 ≡ k p [] (k q [] k r ) and observe that (k 1 , k 2 ) ∈ R. Condition 6: We assume E (p [] q) [] r,</formula><formula xml:id="formula_171">-→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R. Condition 3: We assume E p, σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 , σ . We also know that ξ |= true. We obtain E true → p, σ ξ,a,ξ -→ k 1 , σ using Rule 20.2 and observe that (k 1 , k 1 ) ∈ R. Condition 4: We assume E true → p, σ t,ρ -→ k 1 , σ for some E, σ , t, ρ, k 1 ,</formula><p>(1) Rule 21 has been applied. Then, (C, J, L, H, R) ⊥, σ t,ρ -→ k p , σ for some k p . This leads a contradiction, because ⊥ cannot perform any action transitions. Thus, Rule 21 cannot have been applied.</p><p>(2) Rule 22 has been applied. Then,</p><formula xml:id="formula_172">k 1 ≡ b → ⊥ and σ = ρ σ (t), ρ ∈ σEt , ∀ s∈(0,t) ρ(s) |= ¬b, ρ(0) |= b ⇒ (C, J, L, H, R) ⊥, σ 0,ρ {0} -→ z, σ for some z, σ and ρ(t) |= b ⇒ (C, J, L, H, R) ⊥, ρ σ (t) ρ(t)</formula><p>. From the facts ρ(0</p><formula xml:id="formula_173">) |= b ⇒ (C, J, L, H, R) ⊥, σ 0,ρ {0} -→ z, σ and ρ(t) |= b ⇒ (C, J, L, H, R) ⊥, ρ σ (t) ρ(t)</formula><p>, we get ρ(0) |= ¬b and ρ(t) |= ¬b, since the right-hand side of these implications are false (due to ⊥ cannot perform any transition). Thus, we have ∀ s∈[0,t] ρ(s) |= ¬b.</p><p>Hence, we can also obtain the following transition (C, J, L, H, R) ¬b, σ t,ρ -→ ¬b, ρ σ (t) (see also Rule 3). Take k 2 ≡ ¬b and observe that (k 1 , k 2 ) ∈ R.  This leads to a contradiction. Therefore this case cannot occur. (2) Rule 25.1.r has been applied. The proof is similar to the proof of the previous case. </p><formula xml:id="formula_174">→ (p [] q) ↔ b → p [] b → q. Proof. Let R = {(b → (p [] q), b → p [] b → q) | p, q ∈ P , guard b} ∪ {(i d , i d ) | i d ∈ P }.</formula><formula xml:id="formula_175">Condition 2: We assume E b → (p [] q), σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 ,</formula><formula xml:id="formula_176">b → p [] b → q, σ ξ,a,ξ -→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R.</formula><p>(2) Rule 25.1.r has been applied. The proof is similar to the proof of the previous case. This leads to a contradiction. Therefore this case cannot occur. (2) Rule 25.1.r has been applied. The proof is similar to the proof of the previous case. -→ b → k q , σ . According to Rule 26, we have</p><formula xml:id="formula_177">Condition 3: We assume (C, J, L, H, R) b → p [] b → q, σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ ,</formula><formula xml:id="formula_178">Condition 4: We assume E b → (p [] q), σ t,ρ -→ k 1 ,</formula><formula xml:id="formula_179">E b → p [] b → q, σ t,ρ -→ b → k p [] b → k q , σ . Note that k 1 ≡ b → k p [] k q . Take k 2 ≡ b → k p [] b → k q and observe that (k 1 , k 2 ) ∈ R.</formula><p>(2) Rule 22 has been applied. Then, k 1 ≡ b → (p [] q) and σ = ρ σ (t), ρ ∈ σEt ,</p><formula xml:id="formula_180">∀ s∈(0,t) ρ(s) |= ¬b, ρ(0) |= b ⇒ E p [] q, σ 0,ρ {0}</formula><p>-→ z, σ for some z, σ and</p><formula xml:id="formula_181">ρ(t) |= b ⇒ E p [] q, ρ σ (t) ρ(t) . From ρ(0) |= b ⇒ E p [] q, σ 0,ρ {0} -→ z, σ , we can also have ρ(0) |= b ⇒ E p, σ 0,ρ {0}</formula><p>-→ p z , σ for some p z , and ρ(0</p><formula xml:id="formula_182">) |= b ⇒ E q, σ 0,ρ {0}</formula><p>-→ q z , σ for some q z (see also <ref type="bibr">Rule 26)</ref>. From</p><formula xml:id="formula_183">ρ(t) |= b ⇒ E p [] q, ρ σ (t) ρ(t)</formula><p>, we also get</p><formula xml:id="formula_184">ρ(t) |= b ⇒ E p, ρ σ (t) ρ(t)</formula><p>and ρ(t</p><formula xml:id="formula_185">) |= b ⇒ E q, ρ σ (t) ρ(t)</formula><p>(see also <ref type="bibr">Rule 27)</ref>. Using Rule 22, we obtain </p><formula xml:id="formula_186">E b → p, σ t,ρ -→ b → p, ρ σ (t) and E b → q, σ t,ρ -→ b → q, ρ σ (t) . According to Rule 26, we obtain E b → p [] b → q, σ t,ρ -→ b → p [] b → q, ρ σ (t) . Take k 2 ≡ b → p [] b → q and observe that (k 1 , k 2 ) ∈ R. Condition 5: We assume E b → p [] b → q, σ t,ρ -→ k 1 ,</formula><formula xml:id="formula_187">-→ k q , σ for some k p , k q such that k 1 ≡ k p [] k q . For E b → p, σ t,ρ -→ k p , σ , and E b → q, σ t,ρ</formula><p>-→ k q , σ , four cases can be distinguished:</p><p>(1) Rule 21 has been applied for both. Then, E p, σ t,ρ</p><formula xml:id="formula_188">-→ k p , σ , E q, σ t,ρ -→</formula><p>k q , σ for some k p , k q such that k p ≡ b → k p , k q ≡ b → k q , and ∀ s∈[0,t] ρ(s) |= b.</p><p>Using Rule 26, we obtain E p [] q, σ t,ρ</p><formula xml:id="formula_189">-→ k p [] k q , σ . Applying Rule 21, we get E b → (p [] q), σ t,ρ -→ b → k p [] k q , σ . Note that k 1 ≡ b → k p [] b → k q .</formula><p>Take k 2 ≡ b → k p [] k q and observe that (k 2 , k 1 ) ∈ R. (2) Rule 22 has been applied for both. Then, k p ≡ b → p, k q ≡ b → q and σ = ρ σ (t),</p><formula xml:id="formula_190">ρ ∈ σEt , ∀ s∈(0,t) ρ(s) |= ¬b, ρ(0) |= b ⇒ E p, σ 0,ρ {0} -→ p z , σ , ρ(0) |= b ⇒ E q, σ 0,ρ {0} -→ q z , σ , for some p z , q z , σ , σ , ρ(t) |= b ⇒ E p, ρ σ (t) ρ(t) and ρ(t) |= b ⇒ E q, ρ σ (t) ρ(t)</formula><p>. From ρ(0) |= b ⇒ E p, σ 0,ρ {0} -→ p z , σ , and</p><formula xml:id="formula_191">ρ(0) |= b ⇒ E q, σ 0,ρ {0}</formula><p>-→ q z , σ , by Lemma 1 we know that σ = σ = ρ σ (0),</p><formula xml:id="formula_192">we get ρ(0) |= b ⇒ E p [] q, σ 0,ρ {0}</formula><p>-→ z , σ for some z (see also <ref type="bibr">Rule 26)</ref>.</p><p>From</p><formula xml:id="formula_193">ρ(t) |= b ⇒ E p, ρ σ (t) ρ(t) and ρ(t) |= b ⇒ E q, ρ σ (t) ρ(t)</formula><p>, we get</p><formula xml:id="formula_194">ρ(t) |= b ⇒ E p [] q, ρ σ (t) ρ(t)</formula><p>(see also <ref type="bibr">Rule 27)</ref>. Using Rule 22, we obtain -→ k q , σ . Then, E p, σ t,ρ -→ k p , σ for some</p><formula xml:id="formula_195">E b → (p [] q), σ t,ρ -→ b → (p [] q), ρ σ (t) . Notice that k 1 ≡ b → p [] b → q. Take k 2 ≡ b → (p [] q) and observe that (k 2 , k 1 ) ∈ R.</formula><formula xml:id="formula_196">k p such that k p ≡ b → k p , σ = ρ σ (t), ∀ s∈[0,t] ρ(s) |= b, ρ ∈ σEt , ∀ s∈(0,t) ρ(s) |= ¬b, ρ(0) |= b ⇒ E q, σ 0,ρ {0} -→ q z , σ , for some q z , σ , ρ(t) |= b ⇒ E q, ρ σ (t) ρ(t)</formula><p>, k q ≡ b → q, and k 1 ≡ b → k p [] b → q. From ∀ s∈[0,t] ρ(s) |= b, and ∀ s∈(0,t) ρ(s) |= ¬b, this leads to a contradiction, unless t = 0. Hence, t = 0.</p><p>Then we consider only the case in which t = 0. From E p, σ</p><formula xml:id="formula_197">0,ρ {0} -→ k p , σ , ρ(0) |= b, and ρ(0) |= b ⇒ E q, σ 0,ρ {0}</formula><p>-→ q z , σ , it is not hard to see that</p><formula xml:id="formula_198">we get ρ(0) |= b ⇒ E p [] q, σ 0,ρ {0}</formula><p>-→ k z , σ for some k z , σ . We know that σ = σ = σ = ρ σ (0) (see also Rule 26 and Lemma 1). Since ρ ∈ σEt , we have σ = ρ σ (0). Also, from E p, ρ σ (0)</p><formula xml:id="formula_199">0,ρ -→ k p , σ , we have E p, ρ σ (0) ρ(0) (by Lemma 3). Using Rule 26, we ρ(0) |= b ⇒ E p [] q, ρ σ (0) ρ(0)</formula><p>. Applying Rule 22,  . The proof is similar to the previous case.</p><formula xml:id="formula_200">we obtain E b → (p [] q), σ 0,ρ -→ b → (p [] q), ρ σ (0) . Take k 2 ≡ b → (p [] q) and observe that (k 2 , k 1 ) ∈ R. (<label>4</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.4. Properties of sequential composition</head><p>Lemma 25 (Left-zero element for sequential comp.). For every closed process term p we have δ; p ↔ δ.</p><p>Proof. Let R = {(δ; p, δ) | p ∈ P }. Since there are no action transition rules and time transition rules defined for δ, and therefore also not for δ; p, the conditions 1-5 hold trivially. Lemma 26 (Associativity of sequential composition). For every closed process terms p, q and r we have (p; q); r ↔ p; (q ; r).</p><p>Proof. Let R = {((p; q); r, p; (q ; r)) | p, q, r ∈ P } ∪ {(i (1) Rule 16 has been applied. Then E p; q, σ ξ,a,ξ -→ , σ . This leads to a contradiction as there is no deduction rule that allows a sequential composition to perform a termination transition. Hence, this case cannot occur.</p><p>(2) Rule 17 has been applied. Then, E p; q, σ ξ,a,ξ -→ k 1 , σ for some k 1 such that Lemma 27 (Distribution of sequential over alternative comp.). For p, q and r arbitrary closed process terms we have </p><formula xml:id="formula_201">k 1 ≡ k 1 ;</formula><formula xml:id="formula_202">(p [] q); r ↔ p; r [] q ; r. Proof. Let R = {((p [] q); r, p; r [] q ; r) | p, q, r ∈ P } ∪ {(i d , i d ) | i d ∈ P }.<label>Condition</label></formula><formula xml:id="formula_203">→ (p; q) ↔ b → p; q. Proof. Let R = {(b → (p; q), b → p; q) | p, q ∈ P , guard b} ∪ {(i d , i d ) | i d ∈ P }.</formula><p>Condition 1: We assume E b → (p; q), σ ξ,a,ξ -→ , σ for some E, σ , ξ , a, ξ , σ , which means that Rule 20.1 has been applied necessarily. Then, E p; q, σ ξ,a,ξ -→ , σ and ξ |= b. This leads to a contradiction as there is no deduction rule that allows a sequential composition to perform a termination transition. Second, we assume E b → p; q, σ ξ,a,ξ -→ , σ for some E, σ , ξ , a, ξ , σ . This also leads to a contradiction as there is no deduction rule that allows a sequential composition to perform a termination transition. Thus, condition 1 holds trivially. -→ q, σ and observe that (q, q) ∈ R.</p><formula xml:id="formula_204">Condition 2: We assume E b → (p; q), σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 ,</formula><p>( -→ q, σ and observe that (q, q) ∈ R.</p><p>( -→ (b → k p ); q, σ . Note that k 1 ≡ b → (k p ; q). Take k 2 ≡ (b → k p ); q and observe that (k 1 , k 2 ) ∈ R.</p><p>(2) Rule 22 has been applied. Then, -→ b → (k p ; q), σ . Note that k 1 ≡ b → k p ; q. Take k 2 ≡ b → (k p ; q) and observe that (k 2 , k 1 ) ∈ R.</p><formula xml:id="formula_207">k 1 ≡ b → (p; q), σ = ρ σ (t), ρ ∈ σEt , ∀ s∈(0,t) ρ(s) |= ¬b, ρ(0) |= b ⇒ E p; q, σ 0,ρ {0} -→ p , σ , for some p , σ , ρ(t) |= b ⇒ E p; q, ρ σ (t) ρ(t) . For ρ(0) |= b ⇒ E p; q, σ 0,ρ {0} -→ p , σ , we get ρ(0) |= b ⇒ E p, σ 0,ρ {0} -→ k p ,</formula><p>(2) Rule 22 has been applied. Then, (2) Rule 24 has been applied. Then, ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b.</p><formula xml:id="formula_208">k 1 ≡ b → p, σ = ρ σ (t), ρ ∈ σEt , ∀ s∈(0,t) ρ(s) |= ¬b, ρ(0) |= b ⇒ E p, σ 0,ρ {0} -→ p , σ , for some p , σ , and ρ(t) |= b ⇒ E p, ρ σ (t) ρ(t) . From ρ(0) |= b ⇒ E p, σ 0,ρ {0} -→ p , σ , we get ρ(0) |= b ⇒ E p; q, σ 0,ρ {0} -→ k p ,</formula><p>Using Rule 24 we get (C, J, L, H, R) b → (p; q), σ σ ∪ξ ĊL .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.5. Properties of parallel composition</head><p>Lemma 29 (Commutativity of parallel comp.). For arbitrary closed process terms p and q we have</p><formula xml:id="formula_209">p || q ↔ q || p. Proof. Let R = {(p || q, q || p) | p, q ∈ P } ∪ {(i d , i d ) | i d ∈ P }.</formula><p>Since the deduction rules for || are symmetrical w.r.t. the left and right argument, obviously all conditions are met.</p><p>Lemma 30 (Associativity of parallel composition). For arbitrary closed process terms p, q and r we have  </p><formula xml:id="formula_210">(p || q) || r ↔ p || (q || r). Proof. Let R = {((p || q) || r, p || (q || r)) | p, q, r ∈ P } ∪ {(i d , i d ) | i d ∈ P }.</formula><formula xml:id="formula_211">1: We assume (C, J, L, H, R) (p || q) || r, σ ξ,a,ξ</formula><p>-→ , σ for some C, J , L, H , R, σ , ξ , a, ξ , σ , which means that either Rule 28.1.l or Rule 28.1.r has been applied necessarily. Hence, we distinguish two cases:</p><p>(1) Rule 28.1.l has been applied. Then, we have</p><formula xml:id="formula_212">(C,J ∪ W, L, H, R) p || q, σ ξ,isa(h,cs),ξ -→ , σ , (C, J, L, H, R) r, σ ξ,ira(h,cs,W ),ξ</formula><p>-→ , σ for some W , h ,cs and a = ca(h, cs). Since we do not have a rule for (C, J, ∪W, L, H, R)</p><formula xml:id="formula_213">p || q, σ ξ,isa(h,cs),ξ -→</formula><p>, σ , we obtain a contradiction and the right implication of condition 1 holds trivially.</p><p>(2) Rule 28.1.r has been applied. Then,</p><formula xml:id="formula_214">(C, J ∪ W, L, H, R) r, σ ξ,isa(h,cs),ξ -→ , σ , (C, J, L, H, R) p || q, σ ξ,ira(h,cs,W ),ξ</formula><p>-→ , σ for some W , h, cs, and a = ca(h, cs).</p><p>Since we do not have a rule for (C, J, L, H, R) p || q, σ ξ,ira(h,cs,W ),ξ -→ , σ , we obtain a contradiction and the right implication of condition 1 holds trivially. -→ k 1 , σ for some C, J , L, H , R, σ , ξ , a, ξ , k 1 , σ . Based on the deduction rule that has been applied we can distinguish 10 cases:</p><p>(1) Rule 28. </p><formula xml:id="formula_215">, J ∪ W, L, H, R) q, σ ξ , (C, J ∪ W, L, H R) p, σ ξ,isa(h,cs),ξ -→ , σ , (C, J ∪ W, L, H, R) q, σ ξ ,<label>and</label></formula><formula xml:id="formula_216">k 1 ≡ q. Using Rule 29.1.r we obtain (C, J, L, H, R) q || r, σ ξ,ira(h,cs,W ),ξ -→ q, σ . Using Rule 28.3.l we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ</formula><p>-→ q, σ , and observe that (q, q) ∈ R. (b) Rule 29.1.r has been applied. Then, (C, J ∪ W, L, H, R) -→ , σ for some W , h, cs, and a = ca(h, cs). For (C, J, L, H, R) p || q, σ ξ,ira(h,cs,W ),ξ -→ k 1 , σ we can distinguish four more cases: (a) Rule 29.1.l has been applied. Then, we have (C, J, L, H, R) q, σ ξ , (C, J, L, H, R) p, σ ξ,ira(h,cs,W ),ξ -→ , σ , (C, J, L, H, R) q, σ ξ and k 1 ≡ q. Using Rule 29.1.r we obtain (C, J, L, H, R) q || r, σ ξ,isa(h,cs),ξ -→ q, σ . Using Rule 28.2.r we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ q, σ and observe that (q, q) ∈ R.  -→ q || k r , σ . Notice that k 1 ≡ q || k r . Take k 2 ≡ q || k r and observe that (k 1 , k 2 ) ∈ R.  -→ , σ for some W , h, cs, and a = ca(h, cs). Then, using Rule 29.1.l we obtain (C, J ∪ W, L, H, R) q || r, σ -→ q, σ .</p><formula xml:id="formula_217">p, σ ξ , (C, J ∪ W, L, H, R) q, σ ξ,isa(h,cs),ξ -→ , σ ,(C, J ∪ W, L, H, R) p,</formula><p>Then, using Rule 29.2.r, we obtain (C, J, L, H, R) p || (q || r), σ ξ,a,ξ -→ p || q, σ . Take k 2 ≡ p || q and observe that (k 1 , k 2 ) ∈ R. , σ and (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ -→ k pq , σ for some W , h, cs, and a = ca(h, cs). Then Rule 29.2.l followed by Rule 28. -→ k q , σ for some W , h, cs, k p , k q such that k pq ≡ k p || k q , and a = ca(h, cs). Then applying Rule 29.2.l followed by Rule 28.4.l gives (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ k p || (k q || r), σ . Notice that k 1 ≡ (k p || k q ) || r. Take k 2 ≡ k p || (k q || r) and observe that (k 1 , k 2 ) ∈ R. (f) Rule 28.4.r has been applied. Then, we have (C, J ∪ W, L, H, R) q, σ ξ,isa(h,cs),ξ -→ k q , σ and (C, J, L, H, R) p, σ ξ,ira(h,cs,W ),ξ -→ k p , σ for some W , h, cs, k p , k q such that k pq ≡ k p || k q , and a = ca(h, cs). Then applying Rule 29.2.l followed by Rule 28.4.r gives (C, J, L, H, R) p || (q || r), σ ξ,a,ξ -→ k p || (k q || r), σ . Notice that k 1 ≡ (k p || k q ) || r. Take k 2 ≡ k p || (k q || r) and observe that (k 1 , k 2 ) ∈ R. (g) Rule 29.1.l has been applied. Then, we have (C, J, L, H, R) q, σ ξ , (C, J, L, H, R) p, σ ξ,a,ξ -→ , σ , (C, J, L, H, R) q, σ ξ , and k pq ≡ q. We have (C,J, L,H,R) p || q, σ ξ and (C, J, L, H, R) p || q, σ ξ (see <ref type="bibr">Rule 31)</ref>. Applying Rule 29.1.l gives (C, J, L, H, R) p || (q || r), σ ξ,a,ξ -→ q || r, σ . Notice that k 1 ≡ q || r. Take k 2 ≡ q || r and observe that (k 1 , k 2 ) ∈ R.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>where σ ⊥ denotes a valuation of local variables, where values may be undefined (⊥), C denotes a set of local (non-jumping) continuous variables, and L denotes a set of local algebraic variables. The set of local discrete variables is dom(σ ⊥ ) \ C. We assume C ⊆ dom(σ ⊥ ), dom(σ ⊥ ) ∩ L = ∅, and C ∩ L = ∅. It is allowed that the local variables have been declared on a more global level already. Any occurrence of a variable from dom(σ ⊥ ) ∪ Ċ ∪ L in process term p refers to the local variable and not to any more global declaration of the same variable name. For similar purposes, local channels can be declared by means of a channel scope process term |[ H H | p ]|, and local recursive definitions by means of a recursion scope process term |[ R R | p ]|. The channel scope process term |[ H H | p ]| is used to declare the channels from the set H ⊆ H to be local. Communication actions via those local channels are abstracted from (replaced by internal action τ ), and the separate send and receive actions via local channels are blocked. The recursion scope process term |[ R R | p ]| is used to declare local recursion definitions R ⊆ R (see Section 3.1 for the definition of R).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>that is used in an environment (C, J, L, H, R), with valuation σ , and where σ dx ⊥ denotes a local valuation that may have undefined values and that has domain {d, x}, d denotes the local discrete variables d 1 , . . . , d k , x denotes the local (non-jumping) continuous variables x 1 , . . . , x n , and g denotes the local algebraic variables g 1 , . . . , g m , behaves as p after taking the union of the respective categories (discrete, continuous and algebraic) of local and global variables and taking the union of the local and global valuation. To ensure that all local variables are fresh with respect to the global variables, the local variables are first renamed. Thus d , x , g , in the rules below, denote fresh variables d 1 , . . . , d k , x 1 , . . . , x n , g 1 , . . . , g m with respect to dom(σ ) ∪ L ∪ {d} ∪ {x} ∪ {g}. Notation p[</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Constrained pendulum.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. Glider take-off.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The bottle filling system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Iconic representation of the bottle filling system model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Proposition 9 (</head><label>9</label><figDesc>The property p [] δ ↔ p does not hold. Consider, for example p = true. Then p [] δ cannot perform any time transitions, while p can perform arbitrary time transitions. Property p [] δ ↔ δ does not hold either. Consider, for example p = skip. Then p [] δ can perform a τ transition, while δ cannot. Guard operator). The following properties hold for closed process terms p ∈ P and guards b:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>and a = l a . Therefore, by Rule 2, we have W : r l a , σ, E ξ . • Rule 5. Then p ≡ h !! e n for some h and e n , ξ = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → , and a = isa(h, [ξ(e n )]). Therefore, by Rule 7, we have h !! e n , σ, E ξ .• Rule 6. Then p ≡ h ?? x n for some h and x n , ξ = σ ∪ ξ ĊL for some ξ ĊL ∈ ( Ċ ∪ L) → , and a = ira(h, [c n ], {x n }) for some c n . Then, by Rule 8, we have h ?? x n , σ, E ξ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>ξ.</head><label></label><figDesc>Then, by Rule 40, X, σ, E ξ . • Rule 41. Then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Rule 46, we obtain (C, J, L, H, R) |[ V σ dx ⊥ , {x}, {g} | p ]|, σ ξ (dom(σ )∪ Ċ∪L) . • Rules 47, 48 and 51. The proofs are similar. We only give the proof for Rule 47. Then p ≡ |[ H {h} | q ]| for some h, q, E = (C, J, L, H, R), q[h /h], σ, (C,J,L,H ∪ {h },R) ξ,b,ξ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Lemma 15 .</head><label>15</label><figDesc>For arbitrary closed process term p we have false p ↔ ⊥.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Condition 6 :Lemma 17 .</head><label>617</label><figDesc>First, we assume (C, J, L, H, R) u u, σ ξ for some C, J , L, H , R, σ , ξ , which means that Rule 15 has been applied necessarily. Then, (C, J, L, H, R) u, σ ξ and ξ |= u. Second, we assume (C, J, L, H, R) u, σ ξ for some C, J , L, H , R, σ , ξ , which means Rule 4 has been applied necessarily. Then, ξ = σ ∪ ξ ĊL for some ξ ĊL and σ ∪ ξ ĊL |= u. According to Rule 15, we get (C, J, L, H, For arbitrary closed process term p and arbitrary predicates u, u we have</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Condition 1 :</head><label>1</label><figDesc>First, we assume E p [] p, σ ξ,a,ξ -→ , σ for some E, σ , ξ , a, ξ , σ , which means that Rule 25.1.l or Rule 25.1.r has been applied necessarily. Since the left and right argument of the [] are the same, we only give the proofs in which Rule 25.1.l has been applied. Then, E p, σ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Condition 6 :.</head><label>6</label><figDesc>First, we assume E p [] p, σ ξ for some E, σ , ξ , which means Rule 27 has been applied necessarily. Then, we get E p, σ ξ Second, we assume E p, σ ξ for some E, σ , ξ . Using Rule 27, we obtain E p [] p, σ ξ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>( 1 )...</head><label>1</label><figDesc>Rule 25.1.l has been applied. Then, E p [] q, σ ξ,a,ξ -→ , σ and E r, σ ξ For E p [] q, σ ξ,a,ξ -→ , σ , this means that again either Rule 25.1.l or Rule 25.1.r has been applied necessarily. Hence, we can further distinguish two cases: (a) Rule 25.1.l has been applied. Then, E p, σ ξ,a,ξ , σ and E q, σ ξ . Using Rule 27, we obtain E q [] r, σ ξ We further get E p [] (q [] r), σ ξ,a,ξ -→ , σ using Rule 25.1.l. (b) Rule 25.1.r has been applied. Then, E q, σ ξ,a,ξ -→ , σ and E p, σ ξ Using Rule 25.1.l, we obtain E q [] r, σ ξ,a,ξ -→ , σ . Applying Rule 25.1.r,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>σ using Rule 25.2.l and observe that (k 1 , k 1 ) ∈ R. (b) Rule 25.2.r has been applied. Then E q, σ ξ,a,ξ -→ k 1 , σ and E p, σ ξ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>(Lemma 23 .Condition 4 :</head><label>234</label><figDesc>C, J, L, H, R) false → p, σ σ ∪ξ ĊL . For arbitrary closed process term p and arbitrary guard b we have b → ⊥ ↔ ¬b. Proof. Let R = {(b → ⊥, ¬b) | p ∈ P , guard b} ∪ {(i d , i d ) | i d ∈ P }. Since there are no action transition rules defined for ⊥, also b → ⊥ has no action transition rules defined, and there are no action transition rules defined for delay predicates, the conditions 1-3 hold trivially. We assume (C, J, L, H, R) b → ⊥, σ t,ρ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Condition 5 :Lemma 24 (</head><label>524</label><figDesc>We assume (C, J, L, H, R) ¬b, σ t,ρ -→ k 1 , σ for some C, J , L, H , R, σ , t, ρ, k 1 , σ , which means that Rule 3 has been applied necessarily. Then, k 1 ≡ ¬b, ρ ∈ FG (σ, C, L, ¬b, t) and σ = ρ σ (t). From ρ ∈ FG (σ, C, L, ¬b, t), we know that ∀ s∈[0,t] ρ(s) |= ¬b and ⊥ also cannot perform any transition. Then the following premisesρ(0) |= b ⇒ (C, J, L, H, R) ⊥, σ 0,ρ {0}-→ z, σ for some z, σ , andρ(t) |= b ⇒ (C, J, L, H, R) ⊥, ρ σ (t) ρ(t)hold (because the left-hand side of the implications are false). Using Rule 22, we obtain(C, J, L, H, R) b → ⊥, σ t,ρ -→ b → ⊥, ρ σ (t) . Take k 2 ≡ b → ⊥ and observe that (k 2 , k 1 ) ∈ R.Condition 6: First, we assume (C, J, L, H, R) b → ⊥, σ ξ for some C, J , L, H , R, σ , ξ , which means that Rule 24 has been applied necessarily. Notice that Rule 23 cannot be applied, because the premise (C, J, L, H, R) ⊥, σ ξ does not hold. Then ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b. Applying Rule 4, we get (C, J, L, H, R) ¬b, σ σ ∪ξ ĊL . Second, we assume (C, J, L, H, R) ¬b, σ ξ for some C, J , L, H , R, σ , ξ , which means Rule 4 has been applied necessarily. Then ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b. Using Rule 24, we obtain (C, J, L, H, R) b → ⊥, σ σ ∪ξ ĊL . Distributivity of guard over alternative comp.). For arbitrary closed process terms p and q and arbitrary guard b we have b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Condition 1 :( 1 )..</head><label>11</label><figDesc>First, we assume E b → (p [] q), σ ξ,a,ξ -→ , σ for some E, σ , ξ , a, ξ , σ , which means that Rule 20.1 has been applied necessarily. Then, E p [] q, σ ξ,a,ξ -→ , σ and ξ |= b. For E p [] q, σ ξ,a,ξ -→ , σ , we distinguish two cases: Rule 25.1.l has been applied. Then E p, σ ξ,a,ξ -→ , σ and E q, σ ξ . Using Rule 20.1, we have E b → p, σ ξ,a,ξ -→ , σ . We also obtain E b → q, σ ξ using Rule 23. Applying Rule 25.1.l, we get E b → p [] b → q, σ ξ,a,ξ -→ , σ . (2) Rule 25.1.r has been applied. The proof is similar to the proof of the previous case. Second, we assume(C, J, L, H, R) b → p [] b → q, σ ξ,a,ξ-→ , σ for some C, J , L, H , R, σ , ξ , a, ξ , σ , which means that Rule 25.1.l or Rule 25.1.r has been applied necessarily. We distinguish two cases:(1) Rule 25.1.l has been applied.Then (C, J, L, H, R) b → p, σ ξ,a,ξ -→ , σ and (C, J, L, H, R) b → q, σ ξ According to Rule 20.1, we must have (C, J, L, H, R) p, σ ξ,a,ξ -→ , σ and ξ |= b. For E = C, J, L, H, R, b → q, σ ξ , which means that either Rule 23 or Rule 24 has been applied necessarily. We distinguish two cases: (a) Rule 23 has been applied. Then (C, J, L, H, R) q, σ ξ Applying Rule 25.1.l, we can have (C, J, L, H, R) p [] q, σ ξ,a,ξ -→ , σ . Due to Rule 20.1, we finally get (C, J, L, H, R) b → (p [] q), σ ξ,a,ξ -→ , σ . (b) Rule 24 has been applied. Then ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>.</head><label></label><figDesc>k 1 , σ , which means that Rule 25.1.l or Rule 25.1.r has been applied necessarily. We distinguish two cases: (1) Rule 25.2.l has been applied. Then (C, J, L, H, R) b → p, σ ξ,a,ξ -→ k 1 , σ and (C, J, L, H, R) b → q, σ ξ According to Rule 20.2, we must have (C, J, L, H,R) p, σ ξ,a,ξ -→ k 1 , σ and ξ |= b. For (C, J, L, H, R) b → q, σ ξ , which means that either Rule 23 or Rule 24 has been applied necessarily. We distinguish two cases: (a) Rule 23 has been applied. We have (C, J, L, H, R) q, σ ξ using Rule 23. Applying Rule 25.2.l, we have (C, J, L, H, R) p [] q, σ ξ,a,ξ -→ k 1 , σ . Due to Rule 20.2, we finally get (C, J, L, H, R) b → (p [] q), σ ξ,a,ξ -→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R. (b) Rule 24 has been applied. Then ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>( 3 )</head><label>3</label><figDesc>Rule 21 has been applied for E b → p, σ t,ρ -→ k p , σ , and Rule 22 has been applied for E b → q, σ t,ρ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>( 1 )... ( 2 )( 1 ).. ( 2 )( 3 ).( 4 )</head><label>121234</label><figDesc>Rule 23 has been applied. Then (C, J, L, H, R) p [] q, σ ξ and ξ |= b. Using Rule 27, we have (C, J, L, H, R) According to Rule 23, we obtain (C, J, L, H, R) b → p, σ ξ and (C, J, L, H, R) b → q, σ ξ Applying Rule 27, we get (C, J, L, H, R) b → p [] b → q, σ ξ Rule 24 has been applied. Then ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b. Using Rule 24, we can have (C, J, L, H, R) b → p, σ σ ∪ξ ĊL and(C, J, L, H, R) b → q, σ σ ∪ξ ĊL . Applying Rule 27, we get that (C, J, L, H, R) b → p [] b → q, σ σ ∪ξ ĊL . Second, we assume (C, J, L, H, R) b → p [] b → q, σ ξfor some C, J , L, H , R, σ , ξ , which means that Rule 27 has been applied necessarily. Then,(C, J, L, H, R) b → p, σ ξ and (C, J, L, H, R) b → q, σ ξ . For (C, J, L, H, R) b → p, σ ξ and(C, J, L, H, R) b → q, σ ξ , four cases can be distinguished: Rule 23 has been applied for both. Then, we have (C, J, L, H, R) |= b. According to Rule 27, we obtain (C, J, L, H, R) p [] q, σ ξ Using Rule 23, we get (C, J, L, H, R) b → (p [] q), σ ξ Rule 24 has been applied for both. Then ξ ≡ σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b. According to Rule 24, we can have (C, J, L, H, R) b → (p [] q), σ σ ∪ξ ĊL . Rule 23 has been applied for (C, J, L, H, R) b → p, σ ξ and Rule 24 has been applied for (C, J, L, H, R) b → q, σ ξ . Then, (C, J, L, H, R) p, σ ξ , ξ |= b, and ξ = σ ∪ ξ ĊL , and σ ∪ ξ ĊL |= ¬b. This leads to a contradiction. Therefore, Rule 23 cannot have been applied for (C, J, L, H, R) b → p, σ ξ and Rule 24 cannot have been applied for (C, J, L, H, R) b → q, σ ξ Rule 23 has been applied for (C, J, L, H, R) b → q, σ ξ and Rule 24 has been applied for (C, J, L, H, R) b → p, σ ξ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Condition 6 :.</head><label>6</label><figDesc>First, we assume (C, J, L, H, R) δ; p, σ ξ for some C, J , L, H , R, σ , ξ , which means that Rule 19 has been applied necessarily. Then, (C, J, L, H, R) δ, σ ξ . Second, we assume (C, J, L, H, R) δ, σ ξ Using Rule 19, we obtain (C, J, L, H, R) δ; p, σ ξ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>The proof of the left implication of condition 1 is similar to the proof of the right implication of condition 1. The proof of condition 3 is similar to the proof of condition 2. The proofs of conditions 4-6 are the same as the proofs of conditions 4-6 of Lemma 20 (apart from the operator that has been used), because the deduction rules defined for the time transitions and the consistency predicates for [] and || are the same. To increase the readability of this proof, we often apply Lemma 4 to obtain (C, J ∪ W, L, H, R) p, σ ξ from (C, J, L, H, R) p, σ ξ or the other way around without mentioning explicitly the use of the Lemma 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Condition</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Condition 2 :</head><label>2</label><figDesc>We assume (C, J, L, H, R) (p || q) || r, σ ξ,a,ξ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head></head><label></label><figDesc>(b) Rule 29.1.r has been applied. Then, we have (C, J, L, H, R) p, σ ξ , (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ -→ , σ , (C, J, L, H, R) p, σ ξ , and k 1 ≡ p. Using Rule 28.1.r we obtain (C, J, L, H, R) q || r, σ ξ,ca(h,cs),ξ -→ , σ . Using Rule 29.1.r we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ p, σ and observe that (p, p) ∈ R. (c) Rule 29.2.l has been applied. Then, we have (C, J, L, H, R) q, σ ξ , (C, J, L, H, R) p, σ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>..</head><label></label><figDesc>(b) Rule 29.1.r has been applied. Then, we have (C, J, L, H, R) p, σ ξ , (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ -→ , σ , (C, J, L, H, R) p, σ ξ and k pq ≡ p. Using Rule 28.2.r we obtain (C, J, L, H, R) q || r, σ ξ,ca(h,cs),ξ -→ k r , σ . Using Rule 29.2.r we obtain (C, J, L, H, R) b → q, σ ξ p || (q || r), σ ξ,ca(h,cs),ξ -→ p || k r , σ . Notice that k 1 ≡ p || k r . Take k 2 ≡ p || k r and observe that (k 1 , k 2 ) ∈ R. (c)Rule 29.2.l has been applied. Then, we have (C, J, L, H, R) q, σ ξ , (C, J, L, H, R) p, σ ξ,ira(h,cs,W ),ξ -→ k p , σ for some k p such that k pq ≡ k p || q, and (C, J, L, H, R) q, σ ξ Using Rule 29.2.r we obtain (C, J ∪ W, L, H, R) q || r, σ ξ,isa(h,cs),ξ -→ q || k r , σ . Using Rule 28.4.r we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ-→ k p || (q || k r ), σ . Notice that k 1 ≡ (k p || q) || k r . Take k 2 ≡ k p || (q || k r ) and observe that (k 1 , k 2 ) ∈ R. (d) Rule 29.2.r has been applied. Then, we have (C, J, L, H, R) p, σ ξ , (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ-→ k q , σ for some k q such that k pq ≡ p || k q , and (C, J, L, H, R) p, σ ξ Using Rule 28.4.r we obtain(C,J,L, H, R) q || r, σ ξ,ca(h,cs),ξ -→ k q || k r , σ . Using Rule 29.2.r we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ-→ p || (k q || k r ), σ . Notice that k 1 ≡ (p || k q ) || k r . Take k 2 ≡ p || (k q || k r ) and observe that (k 1 , k 2 ) ∈ R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>( 7 ).</head><label>7</label><figDesc>Rule 29.1.l has been applied. Then, (C, J, L, H, R) r, σ ξ , (C, J, L, H, R)p || q, σ ξ,a,ξ -→ , σ , k 1 ≡ r,and (C, J, L, H, R) r, σξ Then two cases can be considered:(a) Rule 28.1.l has been applied. Then, we have(C, J ∪ W, L, H, R) p, σ ξ,isa(h,cs),ξ -→ , σ , (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ-→ , σ for some W , h, cs and a = ca(h, cs). Using Rule 29.1.l we obtain (C, J, L, H, R) q || r, σ ξ,ira(h,cs,W ),ξ -→ r, σ . Using Rule 28.3.l we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ r, σ , and observe that (r, r) ∈ R. (b) Rule 28.1.r has been applied. Then, we have (C, J ∪ W, L, H, R) q, σ ξ,isa(h,cs),ξ -→ , σ , (C, J, L, H, R) p, σ ξ,ira(h,cs,W ),ξ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>( 9 ).</head><label>9</label><figDesc>Rule 29.2.l has been applied. Then, (C, J, L, H, R) r, σ ξ , (C, J, L, H, R) p || q, σ ξ,a,ξ -→ k pq , σ for some term k pq such that k 1 ≡ k pq || r and (C, J, L, H, R) r, σ ξ For (C, J, L, H, R) p || q, σ ξ,a,ξ -→ k pq , σ , 10 cases can be distinguished. (a) Rule 28.2.l has been applied. Then, we have (C, J, L, H, R) r, σ ξ , (C, J ∪ W, L, H, R) p, σ ξ,isa(h,cs),ξ -→ k pq , σ and (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ-→ , σ for some W , h, cs, and a = ca(h, cs). Then applying Rule 29.1.l followed by Rule 28.4.l gives (C, J, L, H, R)p || (q || r), σ ξ,ca(h,cs),ξ -→ k pq || r, σ . Take k 2 ≡ k pq || r and observe that (k 1 , k 2 ) ∈ R. (b) Rule 28.2.r has been applied. Then, we have (C, J ∪ W, L, H, R) q, σ ξ,isa(h,cs),ξ -→ , σ and (C, J, L, H, R) p, σ ξ,ira(h,cs,W ),ξ-→ k pq , σ for some W , h, cs, and a = ca(h,cs). Then Rule 29.1.l followed by Rule 28.4.r gives (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ k pq || r, σ . Take k 2 ≡ k pq || r and observe that (k 1 , k 2 ) ∈ R. (c) Rule 28.3.l has been applied. Then, we have (C, J ∪ W, L, H, R) p, σ ξ,isa(h,cs),ξ -→</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head></head><label></label><figDesc>3.l gives(C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ k pq || r, σ . Take k 2 ≡ k pq || r and observe that (k 1 , k 2 ) ∈ R.(d) Rule 28.3.r has been applied. Then, we have(C, J ∪ W, L, H, R) q, σ ξ,isa(h,cs),ξ -→ k pq , σ and (C, J, L, H, R) p, σ ξ,ira(h,cs,W ),ξ-→ , σ for some W , h, cs, a = ca(h, cs). Then applying Rule 29.1.l followed by Rule 28.4.r gives (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ k pq || r, σ . Take k 2 ≡ k pq || r and observe that (k 1 , k 2 ) ∈ R. (e) Rule 28.4.l has been applied. Then, we have (C, J ∪ W, L, H, R) p, σ ξ,isa(h,cs),ξ -→ k p , σ , (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>..</head><label></label><figDesc>(h) Rule 29.1.r has been applied. Then, we have (C, J, L, H, R) (C, J, L, H, R) p, σ ξ and k pq ≡ p. Applying Rule 29.1.l and then Rule 29.2.r gives (C, J, L, H, R)p || (q || r), σ ξ,a,ξ -→ p || r, σ . Notice that k 1 ≡ q || r. Take k 2 ≡ p || r and observe that (k 1 , k 2 ) ∈ R. (i) Rule 29.2.l has been applied. Then, we have (C, J, L, H, R) q, σ ξ , (C, J, L, H, R) p, σ ξ,a,ξ -→ k p , σ for some k p such that k pq ≡ k p || q, and (C, J, L, H, R) q, σ ξ We have (C, J, L, H, R) p || q, σ ξ and (C, J, L, H, R) p || q, σ ξ (seeRule 31). Applying Rule 29.2.l gives(C, J, L, H, R) p || (q || r), σ ξ,a,ξ -→ k p || (q || r), σ . Take k 2 ≡ k p || (q || r) and observe that (k 1 , k 2 ) ∈ R.(j) Rule 29.2.r has been applied. Then, we have (C, J, L, H, R) p, σ ξ , (C, J, L, H, R) q, σ ξ,a,ξ -→ k q , σ for some k q such that k pq ≡ p || k q , and (C, J, L, H, R) p, σ ξ Applying Rule 29.2.l and then Rule 29.2.r gives (C, J, L, H, R) p || (q || r), σ ξ,a,ξ -→ p || (k q || r), σ . Notice k 1 ≡ (p || k q ) || r. Take k 2 ≡ p || (k q || r) and observe that (k 1 , k 2 ) ∈ R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>( 10 )..</head><label>10</label><figDesc>Rule 29.2.r has been applied. Then, we have (C, J, L, H, R)p || q, σ ξ , (C, J, L, H, R) r, σ ξ,a,ξ-→ k r , σ for some k r such that k 1 ≡ (p || q) || k r , and (C, J, L, H, R) p || q, σ ξ According to Rule 31, we have(C, J, L, H, R) p, σ ξ , (C, J, L, H, R) q, σ ξ , (C, J, L, H, R) p, σ ξ and (C, J, L, H, R) q, σ ξ Using Rule 29.2.r, we obtain (C, J, L, H, R) q || r, σ ξ,a,ξ -→ q || k r , σ . Using Rule 29.2.r, we obtain (C, J, L, H, R) p || (q || r), σ ξ,a,ξ -→ p || (q || k r ), σ . Take k 2 ≡ p || (q || k r ) and observe that (k 1 , k 2 ) ∈ R.B.6. Properties of action encapsulation operatorLemma 31. For arbitrary closed process term p we have∂ ∅ (p) ↔ p. Proof. Let R = {(∂ ∅ (p), p) | p ∈ P } ∪ {(i d , i d ) | i d ∈ P }.Condition 1: First, we assume E ∂ ∅ (p), σ ξ,a,ξ -→ , σ for some E, σ , ξ , a, ξ , σ , which means Rule 32.1 has been applied necessarily. Then, E p, σ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>H a higher priority than time transitions. Action behavior and consistency are not affected by the urgent communication operator, see Rules 35 and 36. Time transitions are allowed only if at each intermediate state while delaying no communication actions via channels from H are possible.</figDesc><table><row><cell></cell><cell>33</cell><cell>E</cell><cell>p, σ</cell></row><row><cell></cell><cell>σ</cell><cell></cell></row><row><cell>p, σ</cell><cell>α</cell><cell></cell></row><row><cell>E</cell><cell></cell><cell></cell></row></table><note><p><p><p>ξ ∂ A (p), σ ξ 34</p>3.4.8. Urgent communication operator</p>The urgent communication operator υ H (p) gives communication actions via channels from set H ⊆</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Let p and p be closed process terms, σ and σ be valuations, E and E be environments, t ∈ T , and ρ be a trajectory. Then,</figDesc><table><row><cell></cell><cell>σ, E</cell><cell>ξ ,</cell><cell></cell></row><row><cell>where p, σ, E</cell><cell cols="2">ξ,a,ξ -→ is an abbreviation for ∃ p ,σ ,E p, σ, E</cell><cell>ξ,a,ξ -→ p</cell><cell>, σ , E .</cell></row><row><cell>Lemma 3. p, σ, E</cell><cell>t,ρ -→ ⇒ p, σ, E</cell><cell>ρ(0) ,</cell><cell></cell></row><row><cell>where p, σ, E</cell><cell>t,ρ</cell><cell></cell><cell></cell></row></table><note><p>-→ is an abbreviation for ∃ p ,σ ,E p, σ, E t,ρ -→ p , σ , E .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>which means Rule 13.1 has been applied necessarily.-→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R. , σ and ξ |= u ∧ u . From ξ |= u ∧ u , we also have ξ |= u and ξ |= u . Using</figDesc><table><row><cell cols="5">Condition 2: We assume E</cell><cell>u</cell><cell>(u</cell><cell>p), σ</cell><cell>ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ ,</cell></row><row><cell cols="6">k 1 , σ , which means Rule 13.2 has been applied necessarily. Thus, E</cell><cell>u</cell><cell>p, σ</cell><cell>ξ,a,ξ -→</cell></row><row><cell cols="6">k 1 , σ and ξ |= u. Again, Rule 13.2 has been applied necessarily. Therefore, we have</cell></row><row><cell>E</cell><cell>p, σ</cell><cell>ξ,a,ξ</cell><cell></cell><cell></cell></row><row><cell cols="6">Rule 13.2, we get E (u ∧ u )</cell><cell>p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell cols="6">Condition 3: We assume E</cell><cell>(u ∧ u )</cell><cell>p, σ</cell><cell>ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ ,</cell></row><row><cell cols="6">k 1 , σ , which means Rule 13.2 has been applied necessarily. Therefore, E</cell><cell>p, σ</cell><cell>ξ,a,ξ -→</cell></row><row><cell cols="5">k 1 Rule 13.2 we obtain E</cell><cell>u</cell><cell>p, σ</cell><cell>ξ,a,ξ -→ k 1 , σ . Again using Rule 13.2 we obtain</cell></row><row><cell cols="2">E u</cell><cell>(u</cell><cell>p), σ</cell><cell>ξ,a,ξ</cell></row><row><cell cols="5">Condition 4: We assume E</cell><cell>u</cell><cell>(u</cell><cell>p), σ</cell><cell>t,ρ</cell></row><row><cell cols="6">which means that Rule 14 has been applied necessarily. Then, E u</cell><cell>p, σ</cell><cell>t,ρ -→ k 1 , σ</cell></row><row><cell cols="4">and ρ(0) |= u. For E</cell><cell>u</cell><cell>p, σ</cell><cell>t,ρ</cell></row><row><cell cols="2">Then, E</cell><cell>p, σ</cell><cell>t,ρ</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Then, E</cell><cell>u</cell><cell>p, σ</cell><cell>ξ,a,ξ -→</cell></row><row><cell></cell><cell cols="5">, σ and ξ |= u. Again, Rule 13.1 has been applied necessarily. Therefore, we have</cell></row><row><cell>E</cell><cell>p, σ</cell><cell>ξ,a,ξ</cell><cell></cell><cell></cell></row><row><cell cols="5">Rule 13.1, we obtain E</cell><cell>(u ∧ u )</cell><cell>p, σ</cell><cell>ξ,a,ξ -→</cell><cell>, σ . Second, we assume</cell></row><row><cell cols="3">E (u ∧ u )</cell><cell>p, σ</cell><cell cols="2">ξ,a,ξ -→ , σ for some E, σ , ξ , a, ξ , σ , which means Rule 13.1 has</cell></row><row><cell cols="6">been applied necessarily. Thus, E</cell><cell>p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Using Rule 13.1, we obtain E</cell><cell>u</cell><cell>p, σ</cell><cell>ξ,a,ξ -→ , σ .</cell></row><row><cell cols="6">Again using Rule 13.1, we obtain E u</cell><cell>(u</cell><cell>p), σ</cell><cell>ξ,a,ξ -→ , σ .</cell></row></table><note><p><p>-→ , σ and ξ |= u . From ξ |= u and ξ |= u we get ξ |= u ∧ u . Using -→ , σ and ξ |= u ∧ u . From ξ |= u ∧ u we obtain ξ |= u and ξ |= u . -→ k 1 , σ and ξ |= u . From ξ |= u and ξ |= u , we obtain ξ |= u ∧ u . Using -→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R.</p>-→ k 1 , σ for some E, σ , t, ρ, k 1 , σ , -→ k 1 , σ , Rule 14 has been applied necessarily.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>|= u ∧ u . From ρ(0) |= u ∧ u , we can also have ρ(0) |= u and ρ(0) |= u . |= u and ξ |= u , we can have ξ |= u ∧ u . Using Rule 15, we obtain From ξ |= (u ∧ u ), we get ξ |= u and ξ |= u . According to Rule 15, we</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>σ ,</cell></row><row><cell cols="6">which means that Rule 14 has been applied necessarily. Then, E</cell><cell>p, σ</cell><cell>t,ρ -→ k 1 , σ</cell></row><row><cell cols="4">and ρ(0) Using Rule 14, we obtain E</cell><cell>u</cell><cell>p, σ</cell><cell>t,ρ -→ k 1 , σ . Again, using Rule 14 we get</cell></row><row><cell>E u</cell><cell>(u</cell><cell>p), σ</cell><cell>t,ρ</cell><cell></cell></row><row><cell cols="5">Condition 6: First, we assume E u</cell><cell>(u</cell><cell>p), σ</cell><cell>ξ</cell><cell>for some E, σ , ξ , which means</cell></row><row><cell cols="6">that Rule 15 has been applied necessarily. Then, E</cell><cell>u</cell><cell>p, σ</cell></row><row><cell>E u</cell><cell>p, σ</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">E (u ∧ u )</cell><cell>p, σ</cell><cell></cell><cell></cell></row><row><cell cols="2">obtain E u</cell><cell>p, σ</cell><cell cols="3">ξ . Using Rule 15, we get E u</cell><cell>(u</cell><cell>p), σ</cell></row></table><note><p>-→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R. ξ and ξ |= u. For ξ , Rule 15 has been applied necessarily. Then E p, σ ξ and ξ |= u . From ξ ξ . Second, we assume E (u ∧ u ) p, σ ξ for some E, σ , ξ , which means Rule 15 has been applied necessarily. Then, E p, σ ξ and ξ |= (u ∧ u ). ξ .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>-→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 , σ , which means that Rule 25.2.l or Rule 25.2.r has been applied necessarily. Since the left and right argument of the [] are the same, we only the proofs in which Rule 25.1.l has been applied. , σ and observe that (k 1 , k 1 ) ∈ R.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">ξ,a,ξ -→</cell><cell>, σ . Second, we assume E</cell><cell>p, σ</cell><cell>ξ,a,ξ -→</cell><cell>, σ for</cell></row><row><cell cols="7">some E, σ , ξ , a, ξ , σ . We know that E</cell><cell>p, σ</cell><cell>ξ</cell><cell>(see also Lemma 2). Using Rule 25.1.l,</cell></row><row><cell cols="2">we obtain E</cell><cell cols="2">p [] p, σ</cell><cell cols="3">ξ,a,ξ -→ , σ .</cell></row><row><cell cols="4">Condition 2: We assume E</cell><cell></cell><cell cols="2">p [] p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell>Then, E</cell><cell cols="2">p, σ</cell><cell>ξ,a,ξ</cell><cell></cell><cell></cell></row><row><cell>that E</cell><cell>p, σ</cell><cell>ξ</cell><cell cols="4">(see also Lemma 2). Using Rule 25.2.l, we obtain E</cell><cell>p [] p, σ</cell><cell>ξ,a,ξ -→</cell></row><row><cell cols="5">k 1 Condition 4: We assume E</cell><cell cols="2">p [] p, σ</cell><cell>t,ρ</cell></row></table><note><p><p><p>-→ k 1 , σ and observe that (k 1 , k 1 ) ∈ R.</p>Condition 3: We assume E p, σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 , σ . We also know -→ k 1 , σ for some E, σ , t, ρ, k 1 ,</p>σ , which means Rule 26 has been applied necessarily. Then, we get E p, σ t,ρ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>Proof. Let R = {(true → p, p) | p ∈ P } ∪ {(i d , i d ) | i d ∈ P }.</figDesc><table><row><cell cols="8">B.3. Properties of guard operator</cell></row><row><cell cols="9">Lemma 21. For arbitrary closed process term p we have</cell></row><row><cell></cell><cell cols="4">true → p ↔ p.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="8">Condition 1: First, we assume E</cell><cell>true → p, σ</cell><cell>ξ,a,ξ -→ , σ for some E, σ, ξ, a, ξ , σ ,</cell></row><row><cell cols="9">which means that Rule 20.1 has been applied necessarily. Then, E</cell><cell>p, σ</cell><cell>ξ,a,ξ -→ , σ .</cell></row><row><cell cols="5">Second, we assume E</cell><cell></cell><cell>p, σ</cell><cell cols="2">ξ,a,ξ -→ , σ for some E, σ, ξ, a, ξ , σ . We also know that</cell></row><row><cell cols="6">ξ |= true, and obtain E</cell><cell cols="3">true → p, σ</cell><cell>ξ,a,ξ -→ , σ using Rule 20.1.</cell></row><row><cell cols="7">Condition 2: We assume E</cell><cell cols="2">true → p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>σ</cell><cell>ξ , which means Rule 27 has been ap-</cell></row><row><cell cols="6">plied necessarily. Then E</cell><cell cols="3">p [] q, σ</cell><cell>ξ</cell><cell>and E</cell><cell>r, σ</cell><cell>ξ . For E</cell><cell>p [] q, σ</cell><cell>ξ , we</cell></row><row><cell cols="2">obtain E</cell><cell cols="2">p, σ</cell><cell>ξ</cell><cell cols="2">and E</cell><cell cols="2">q, σ</cell><cell>ξ</cell><cell>(see also Rule 27). Applying Rule 27, we get</cell></row><row><cell>E</cell><cell cols="2">q [] r, σ</cell><cell cols="6">ξ . Again, due to Rule 27, we can have E</cell><cell>p [] (q [] r), σ</cell><cell>ξ .</cell></row></table><note><p><p>-→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 ,</p>σ , which means that Rule 20.2 has been applied necessarily. Then, E p, σ ξ,a,ξ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>σ , which means Rule 21 has been applied necessarily. Notice that Rule 22 cannot be applied, because the premise ∀ s∈(0,t) ρ(s) |= ¬true does not hold.-→ k p , σ for some k p such that k 1 ≡ true → k p and ∀ s∈[0,t] ρ(s) |= true. Take k 2 ≡ k p and observe that (k 1 , k 2 ) ∈ R.-→ true → k 1 , σ using Rule 21. Take k 2 ≡ true → k 1 and observe that (k 2 , k 1 ) ∈ R. , ξ , which means Rule 23 has been applied necessarily. Notice that Rule 24 cannot have applied, because the premiseσ ∪ ξ ĊL |= ¬true does not hold. Then E p, σ Let R = {(false → p, true) | p ∈ P } ∪ {(i d , i d ) | i d ∈ P }.Since there no are action transition rules defined for guard that evaluates to false in the extended valuation (i.e. ξ |= false), and for the process term true also no action transition rules are defined, the conditions 1-3 hold trivially. , R, σ , t, ρ, k 1 , σ which means Rule 22 has been applied necessarily. Notice that Rule 21 cannot be applied, because the premise ∀ s∈[0,t] ρ(s) |= false does not hold. Then k 1 ≡ false → p, σ = ρ σ (t), ρ ∈ σEt and ∀ s∈(0,t) ρ(s) |= ¬false. For ρ ∈ σEt , we can , t, ρ, k 1 , σ , which means Rule 3 has been applied necessarily. Then k 1 ≡ true, σ = ρ σ (t), and ρ ∈ FG (σ, C, L, true, t). We know that ∀ s∈(0,t) ρ(s) |= ¬false, ρ(0) |= -→ false → p, σ . Take k 2 ≡ false → p and observe that (k 2 , k 1 ) ∈ R. , ξ , which means Rule 24 has been applied necessarily. Notice that Rule 23 cannot have been applied, because ξ |= false does not hold. Then, ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL .We know that σ ∪ ξ ĊL |= true. Using Rule 4, we obtain (C, J, L, H, R) true, σ , L, H , R, σ , ξ , which means Rule 4 has been applied necessarily. Then, ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= true. We also know that σ ∪ ξ ĊL |= ¬false. Using Rule 24 we get</figDesc><table><row><cell>Then E -→ k 1 , σ for some E, σ , t, ρ, k 1 , σ . We also know p, σ t,ρ t,ρ that ∀ s∈[0,t] ρ(s) |= true. We obtain E Condition 5: We assume E p, σ true → p, σ t,ρ Condition 6: First, we assume E true → p, σ ξ for some E, σ ξ . Second, we assume E p, σ ξ for some E, σ , ξ . We also know ξ |= true. We obtain E true → p, σ ξ using Rule 23. Lemma 22. For arbitrary closed process term p we have false → p ↔ true. Proof. Condition 4: We assume (C, J, L, H, R) false → p, σ t,ρ -→ k 1 , σ for some C, J , true, σ t,ρ -→ true, ρ σ (t) (see also Rule 3). Take k 2 ≡ true and observe that (k 1 , k 2 ) ∈ R. Condition 5: We assume (C, J, L, H, R) true, σ t,ρ -→ k 1 , σ for some C, J , L, H , R, σ false ⇒ (C, J, L, H, R) p, σ 0,ρ {0} -→ p , σ for some p , σ , and ρ(t) |= false ⇒ (C, J, L, H, R) p, ρ σ (t) ρ(t) (since the left-hand sides of the implications are false, these two implications hold trivially). Using Rule 22, we obtain (C, J, L, H, R) false → p, σ t,ρ Condition 6: First, we assume (C, J, L, H, R) false → p, σ ξ for some C, J , L, H , R, σ σ ∪ξ ĊL . L, H have (C, J, L, H, R) Second, we assume (C, J, L, H, R) true, σ</cell></row></table><note><p>ξ for some C, J</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>σ for some E, σ, t, ρ, k 1 , σ , which means that either Rule 21 or Rule 22 has been applied necessarily.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Then we can</cell></row><row><cell cols="3">distinguish two cases:</cell><cell></cell><cell></cell></row><row><cell cols="5">(1) Rule 21 has been applied. Then, E</cell><cell>p [] q, σ</cell><cell>t,ρ -→ k pq , σ for some k pq such</cell></row><row><cell cols="6">that k 1 ≡ b → k pq and ∀ s∈[0,t] ρ(s) |= b. For E</cell><cell>p [] q, σ</cell><cell>t,ρ -→ k pq , σ , we</cell></row><row><cell>get E</cell><cell>p, σ</cell><cell cols="2">t,ρ -→ k p , σ and E</cell><cell></cell><cell>q, σ</cell><cell>t,ρ -→ k q , σ for some k p , k q such that</cell></row><row><cell cols="6">k pq ≡ k p [] k q (using Rule 26). Applying Rule 21, we obtain E</cell><cell>b → p, σ</cell><cell>t,ρ -→</cell></row><row><cell cols="3">b → k p , σ and E</cell><cell>b → q, σ</cell><cell>t,ρ</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>σ for some E, σ , t, ρ, k 1 ,</figDesc><table><row><cell cols="3">σ , which means that Rule 26 has been applied necessarily. Then E</cell><cell>b → p, σ</cell><cell>t,ρ -→</cell></row><row><cell>k p , σ , and E</cell><cell>b → q, σ</cell><cell>t,ρ</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>-→ k p , σ . The proof is similar to the previous case. R, σ , ξ , which means that Rule 23 or Rule 24 has been applied necessarily. Then, we distinguish two cases:</figDesc><table><row><cell cols="3">) Rule 21 has been applied for E</cell><cell cols="2">b → q, σ</cell><cell>t,ρ -→ k q , σ , and Rule 22 has been</cell></row><row><cell>applied for E</cell><cell>b → p, σ</cell><cell>t,ρ</cell><cell></cell></row><row><cell cols="4">Condition 6: First, we assume (C, J, L, H, R)</cell><cell>b → (p [] q), σ</cell><cell>ξ</cell><cell>for some C, J , L,</cell></row><row><cell>H ,</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head></head><label></label><figDesc>d , i d ) | i d ∈ P }. The proofs of conditions 4 and 5 are similar to the proofs of conditions 2 and 3 (except Rule 16 has not been applied, because no χ process can transform to terminated process by means of time transitions) since the deduction rules for non-terminating action transitions and time transitions of ; are similar.</figDesc><table><row><cell cols="8">Condition 1: Since there are no termination transitions defined for the transition</cell></row><row><cell>E</cell><cell>(p; q); r, σ</cell><cell>ξ,a,ξ -→</cell><cell>, σ and E</cell><cell cols="2">p; (q ; r), σ</cell><cell>ξ,a,ξ -→</cell><cell>, σ , condition 1 holds</cell></row><row><cell cols="2">trivially.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Condition 2: We assume E</cell><cell cols="2">(p; q); r, σ</cell><cell cols="3">ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 ,</cell></row><row><cell cols="8">σ , which means that either Rule 16 or Rule 17 has been applied necessarily. Hence, we</cell></row><row><cell cols="3">distinguish two cases:</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head></head><label></label><figDesc>-→ q ; r, σ . Note that k 1 ≡ q ; r. Take k 2 ≡ q ; r and observe that (k 1 , k 2 ) ∈ R. ≡ (k p ; q); r. Take k 2 ≡ k p ; (q ; r) and observe that (k 1 , k 2 ) ∈ , k 1 , σ , which means that either Rule 16 or Rule 17 has been applied necessarily.</figDesc><table><row><cell></cell><cell cols="7">r. We distinguish two cases for E</cell><cell>p; q, σ</cell><cell>ξ,a,ξ -→ k 1 , σ :</cell></row><row><cell cols="7">(a) Rule 16 has been applied. Then, E</cell><cell>p, σ</cell><cell>ξ,a,ξ -→</cell><cell>, σ , E</cell><cell>q, σ</cell><cell>ξ</cell><cell>and</cell></row><row><cell></cell><cell cols="7">k 1 ≡ q. According to Rule 19, we have E</cell><cell>q ; r, σ</cell><cell>ξ . Using Rule 16, we</cell></row><row><cell></cell><cell>have E</cell><cell cols="2">p; (q ; r), σ</cell><cell>ξ,a,ξ</cell><cell></cell><cell></cell></row><row><cell cols="7">(b) Rule 17 has been applied. Then, E</cell><cell>p, σ</cell><cell>ξ,a,ξ -→ k p , σ for some k p such that</cell></row><row><cell></cell><cell cols="7">k 1 ≡ k p ; q. Using Rule 17 we obtain E</cell><cell>p; (q ; r), σ</cell><cell>ξ,a,ξ -→ k p ; (q ; r), σ .</cell></row><row><cell></cell><cell cols="2">Note that k 1 R.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Condition 3: We assume E</cell><cell></cell><cell cols="3">p; (q ; r), σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Hence, we</cell></row><row><cell cols="3">distinguish two cases:</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="6">(1) Rule 16 has been applied. Then, E</cell><cell></cell><cell>p, σ</cell><cell>ξ,a,ξ -→</cell><cell>, σ , E</cell><cell>q ; r, σ</cell></row><row><cell cols="6">(2) Rule 17 has been applied. Then, E</cell><cell cols="2">p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell></cell><cell cols="5">Using Rule 17, we obtain E</cell><cell>p; q, σ</cell><cell>ξ,a,ξ -→ k p ; q, σ . Again, using</cell></row><row><cell cols="3">Rule 17, we obtain E</cell><cell cols="3">(p; q); r, σ</cell><cell cols="2">ξ,a,ξ</cell></row><row><cell cols="5">Condition 6: First, we assume E</cell><cell cols="3">(p; q); r, σ</cell><cell>ξ</cell><cell>for some E, σ , ξ , which means</cell></row><row><cell cols="7">that Rule 19 has applied necessarily. Then E</cell><cell>p; q, σ</cell><cell>ξ . Again, due to Rule 19, we</cell></row><row><cell>get E</cell><cell>p, σ</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Then E</cell><cell>p, σ</cell><cell cols="6">ξ . Again, due to Rule 19, we get E</cell><cell>p; q, σ</cell><cell>ξ . Using Rule 19, we</cell></row><row><cell>obtain E</cell><cell cols="2">(p; q); r, σ</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p><p>-→ k 1 , σ for some E, σ , ξ , a, ξ ξ and k 1 ≡ q ; r. According to Rule 19, we have E q, σ ξ . Using Rule 16, we obtain E p; q, σ ξ,a,ξ -→ q, σ . Using Rule 17, we obtain E (p; q); r, σ ξ,a,ξ -→ q ; r, σ and observe that (k 1 , k 1 ) ∈ R.</p>-→ k p , σ for some k p such that k 1 ≡ k p ; (q ; r).</p>-→ (k p ; q); r, σ . Take k 2 ≡ (k p ; q); r and observe that (k 2 , k 1 ) ∈ R. ξ . Using Rule 19, we obtain E p; (q ; r), σ ξ . Second, we assume E p; (q ; r), σ ξ for some E, σ , ξ , which means that Rule 19 has applied necessarily. ξ .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head>1 :</head><label>1</label><figDesc>Since there are no action transition rules defined for any closed process term Rule 25.1.r has been applied. The proof is similar to the proof of the previous case. Take k 2 ≡ k 1 ; r and observe that (k 1 , k 2 ) ∈ R. (b) Rule 25.2.r has been applied. The proof is similar to the proof of the previous case. Rule 25.2.r has been applied. The proof is similar to the proof of the previous case. ; r [] k q ; r, σ . Note that k 1 ≡ (k p [] k q ); r. Take k 2 ≡ k p ; r [] k q ; r and observe that(k 1 , k 2 ) ∈ R.-→ k qr , σ for some k pr , k qr such that k 1 ≡ k pr [] k qr . For E p; r, σ -→ k q , σ for some k p , k q such that k pr ≡ k p ; r Take k 2 ≡ (k p [] k q ); r and observe that (k 2 , k 1 ) ∈ R.</figDesc><table><row><cell cols="6">Condition 2: We assume E E q ; r, σ t,ρ -→ k q ; r, σ . According to Rule 26 we obtain E (p [] q); r, σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 , σ ; p; r [] q ; r, σ t,ρ -→</cell></row><row><cell cols="6">which means that either Rule 16 or Rule 17 has been applied necessarily. Hence, we can distinguish two cases: (1) Rule 16 has been applied. Then, E p [] q, σ ξ,a,ξ -→ , σ , and E r, σ ξ k p Condition 5: We assume E p; r [] q ; r, σ t,ρ -→ k 1 , σ for some E, σ , t, ρ, k 1 , σ ; . For E p [] q, σ ξ,a,ξ which means Rule 26 has been applied necessarily. Then, E p; r, σ t,ρ -→ k pr , σ and -→ , σ we again distinguish two cases: (a) Rule 25.1.l has been applied. Then, k 1 ≡ r, E p, σ ξ,a,ξ E q ; r, σ t,ρ t,ρ -→ -→ , σ and E q, σ ξ . Using Rule 16, we get E p; r, σ ξ,a,ξ k pr , σ and E q ; r, σ t,ρ -→ k qr , σ , Rule 18 has been applied to both. Then, -→ r, σ . Due to Rule 19, we have E q ; r, σ ξ . According to Rule 25.2.l, we have E p; r [] q ; r, σ E p, σ t,ρ -→ k p , σ and E t,ρ q, σ ξ,a,ξ -→ and k qr ≡ k q ; r. Using Rule 26 we then obtain E p [] q, σ t,ρ -→ k p [] k q , σ . Applying r, σ and observe that (r, r) ∈ R. Rule 19, we get E t,ρ (p [] q); r, σ (b) (2) Rule 17 has been applied. Then, E ξ,a,ξ p [] q, σ ξ,a,ξ Condition 6: First, we assume E (p [] q); r, σ ξ for some E, σ , ξ ; which means -→ k 1 , σ we can further distinguish two cases: (a) Rule 25.2.l has been applied. Then, E p, σ Rule 19 has been applied necessarily. Then, E p [] q, σ ξ . Using Rule 27, we have ξ,a,ξ -→ k 1 , σ and E q, σ E p, σ ξ and E q, σ ξ . Applying Rule 19, we get E p; r, σ</cell></row><row><cell>E</cell><cell>p, σ</cell><cell>ξ</cell><cell>and E</cell><cell>q, σ</cell></row><row><cell cols="6">which means that either Rule 25.2.l or Rule 25.2.r has been applied necessarily. Hence, we</cell></row><row><cell cols="5">can distinguish two cases:</cell></row><row><cell></cell><cell cols="5">(1) Rule 25.2.l has been applied. Then, E</cell><cell>p; r, σ</cell><cell>ξ,a,ξ -→ k 1 , σ and E</cell><cell>q ; r, σ</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>ξ,a,ξ -→</cell></row><row><cell></cell><cell cols="5">k 1 , σ we again distinguish two cases:</cell></row><row><cell></cell><cell cols="5">(a) Rule 16 has been applied. Then, k 1 ≡ r, E</cell><cell>p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell cols="5">Applying Rule 25.1.l, we get E</cell><cell>p [] q, σ</cell><cell>ξ,a,ξ -→ , σ . According to Rule 16,</cell></row><row><cell></cell><cell cols="3">we have E</cell><cell cols="2">(p [] q); r, σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell cols="5">(b) Rule 17 has been applied. Then, E</cell><cell>p, σ</cell><cell>ξ,a,ξ -→ k p , σ for some k p such that</cell></row><row><cell></cell><cell cols="5">k 1 ≡ k p ; r. Using Rule 25.2.l, we get E</cell><cell>p [] q, σ</cell><cell>ξ,a,ξ -→ k p , σ . According to</cell></row><row><cell></cell><cell cols="4">Rule 17, we have E</cell><cell>(p [] q); r, σ</cell><cell>ξ,a,ξ -→ k p ; r, σ and observe that (k 1 , k 1 ) ∈</cell></row><row><cell></cell><cell>R.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">(2) Condition 4: We assume E</cell><cell>(p [] q); r, σ</cell><cell>t,ρ -→ k 1 , σ for some E, σ , t, ρ, k 1 , σ ;</cell></row><row><cell cols="6">which means Rule 18 has been applied necessarily. Then, E</cell><cell>p [] q, σ</cell><cell>t,ρ -→ k pq , σ</cell></row><row><cell cols="6">k 1 and k 2 such that E for some k pq such that k 1 ≡ k pq ; r. For E k 1 ; k 2 , σ ξ,a,ξ -→ , σ , condition 1 holds trivially. p [] q, σ t,ρ -→ k pq , σ , Rule 26 has been applied necessarily. Then, E p, σ t,ρ -→ k p , σ and E q, σ t,ρ -→ k q , σ for some</cell></row><row><cell cols="6">k t,ρ -→ k p ; r, σ and</cell></row></table><note><p><p><p><p><p><p><p><p>-→ k 1 , σ for some k 1 such that</p>k 1 ≡ k 1 ; r. For E p [] q, σ ξ .</p>Using Rule 17, we get E p; r, σ ξ,a,ξ -→ k 1 ; r, σ . Using Rule 19, we get q ; r, σ ξ . According to Rule 25.2.l, we have E</p>p; r [] q ; r, σ ξ,a,ξ -→ k 1 ; r, σ . Condition 3: We assume E p; r [] q ; r, σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 , σ ; ξ .</p>For E q ; r, σ ξ , we also get E q, σ ξ using Rule 19. For E p; r, σ -→ , σ , and r, σ ξ .</p>-→ r, σ and observe that (r, r) ∈ R. p , k q such that k pq ≡ k p [] k q . Using Rule 18, we obtain E p; r, σ</p>-→ (k p [] k q ); r, σ . Note that k 1 ≡ k p ; r [] k q ; r</p>. ξ and E q ; r, σ ξ . According to Rule 27, we get E p; r [] q ; r, σ ξ . Second, we assume E p; r [] q ; r, σ ξ for some E, σ , ξ ; which means Rule 27 has been applied necessarily. Then, E p; r, σ ξ and E q ; r, σ ξ . Due to Rule 19, we obtain ξ . Using Rule 27, we get E p [] q, σ ξ . Applying Rule 19, we have E (p [] q); r, σ ξ . Lemma 28. For arbitrary closed process terms p and q and arbitrary guard b we have b</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20"><head></head><label></label><figDesc>, which means that either Rule 21 or Rule 22 has been applied necessarily. Then we can distinguish two cases: for some k p such that k 1 ≡ k p ; q using Rule 18. Applying Rule 21, we get</figDesc><table><row><cell cols="3">Using Rule 17, we get E</cell><cell>p; q, σ</cell><cell>ξ,a,ξ</cell></row><row><cell cols="4">(1) Rule 21 has been applied. Then, E</cell><cell>p; q, σ</cell><cell>t,ρ</cell></row><row><cell></cell><cell></cell><cell></cell><cell>t,ρ -→ k 1 , σ , we get E</cell><cell>p, σ</cell><cell>t,ρ -→</cell></row><row><cell>k p , σ E</cell><cell>b → p, σ</cell><cell cols="2">t,ρ -→ b → k p , σ . According to Rule 18, we obtain</cell></row><row><cell>E</cell><cell>b → p; q, σ</cell><cell>t,ρ</cell></row></table><note><p><p><p>) Rule 17 has been applied. Then E b → p, σ ξ,a,ξ -→ k p , σ for some k p such that k 1 ≡ k p ; q. Using Rule 20.2, we obtain E p, σ ξ,a,ξ -→ k p , σ and ξ |= b.</p>-→ k p ; q, σ . Applying Rule 20.2, we have</p>E b → (p; q), σ ξ,a,ξ -→ k p ; q, σ and observe that (k 1 , k 1 ) ∈ R. Condition 4: We assume E b → (p; q), σ t,ρ -→ k 1 , σ for some E, σ, t, ρ, k 1 , σ -→ k 1 , σ and ∀ s∈[0,t] ρ(t) |= b such that k 1 ≡ b → k 1 . For E p; q, σ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_21"><head></head><label></label><figDesc>σ , for some k p (see alsoRule 18). For</figDesc><table><row><cell>ρ(t) |= b ⇒ E also Rule 19). Using Rule 22, we obtain E b → p, σ p; q, ρ σ (t) ρ(t) , we get ρ(t) |= b ⇒ E t,ρ -→ b → p, ρ σ (t) . Using p, ρ σ (t) ρ(t) (see Rule 18, we obtain E b → p; q, σ t,ρ -→ b → p; q, ρ σ (t) . Take k 2 ≡ b → p; q and observe that (k 1 , k 2 ) ∈ R. Condition 5: We assume E b → p; q, σ t,ρ -→ k 1 , σ for some E, σ, t, ρ, k 1 , σ , which means that Rule 18 has been applied necessarily. Then E b → p, σ t,ρ -→ k 1 , σ for some k 1 such that k 1 ≡ k 1 ; q. For E b → p, σ t,ρ -→ k 1 , σ , two cases can be distinguished: (1) Rule 21 has been applied. Then, E p, σ t,ρ -→ k p , σ and ∀ s∈[0,t] ρ(t) |= b for some k According to Rule 21, we have E b → (p; q), σ t,ρ</cell></row></table><note><p>p such that k 1 ≡ b → k p . Using Rule 18, we get E p; q, σ t,ρ -→ k p ; q, σ .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_22"><head></head><label></label><figDesc>. Note that k 1 ≡ b → p; q. Take k 2 ≡ b → (p; q) and observe that (k 2 , k 1 ) ∈ R. R, σ , ξ , which means that either Rule 23 or Rule 24 has been applied necessarily. Then we can distinguish two cases: Rule 24 has been applied. Then, ξ = σ ∪ ξ ĊL for some σ ∪ ξ ĊL and σ ∪ ξ ĊL |= ¬b.</figDesc><table><row><cell></cell><cell cols="4">σ for some k p . From ρ(t) |= b ⇒ E</cell><cell>p, ρ σ (t)</cell><cell>ρ(t) ,</cell></row><row><cell>we get ρ(t) |= b ⇒ E</cell><cell cols="2">p; q, ρ σ (t)</cell><cell>ρ(t)</cell><cell>using Rule 19. Applying Rule 22, we</cell></row><row><cell cols="5">obtain E -→ b → (p; q), ρ σ (t) Condition 6: First, we assume (C, J, L, H, R) b → (p; q), σ t,ρ b → (p; q), σ</cell></row><row><cell cols="5">(1) Rule 23 has been applied. Then, (C, J, L, H, R) p; q, σ</cell><cell>ξ</cell><cell>and ξ |= b. Rule 19,</cell></row><row><cell cols="2">we obtain (C, J, L, H, R)</cell><cell>p, σ</cell><cell></cell></row><row><cell cols="3">Using Rule 24 we get (C, J, L, H, R)</cell><cell cols="2">b → p, σ</cell><cell>σ ∪ξ ĊL</cell><cell>. Applying Rule 19, we</cell></row><row><cell>obtain (C, J, L, H, R)</cell><cell cols="2">b → p; q, σ</cell><cell cols="2">σ ∪ξ ĊL</cell></row><row><cell cols="2">For this, we can distinguish two cases:</cell><cell></cell><cell></cell></row><row><cell cols="5">(1) Rule 23 has been applied. Then, (C, J, L, H, R)</cell><cell>p, σ</cell></row></table><note><p><p><p><p><p><p>ξ for some C, J , L, H , ξ . Applying Rule 23, we get (C, J, L, H, R) b → p, σ ξ . Again, due to Rule 19, we obtain</p>(C, J, L, H, R) b → p; q, σ ξ .</p>(2)</p>. Second, we assume (C, J, L, H, R) b → p; q, σ ξ for some C, J , L, H , R, σ , ξ , which means that Rule 19 has been applied necessarily.</p>Then (C, J, L, H, R</p>) b → p, σ ξ . ξ and ξ |= b. Using Rule 19, we obtain (C, J, L, H, R) p; q, σ ξ . Applying Rule 23, we get (C, J, L, H, R) b → (p; q), σ ξ .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_24"><head></head><label></label><figDesc>|| q, σ . Take k 2 ≡ k p || q and observe that(k 1 , k 2 ) ∈ R. (d) Rule 29.2.r has been applied. Then, (C, J ∪ W, L, H, R) || k q , σ . Take k 2 ≡ p || k qand observe that (k 1 , k 2 ) ∈ R. , σ cannot be obtained from the deduction rules. Hence, this case cannot occur. (4) Rule 28.3.r has been applied. Then, we have (C, J, L, H, R) p || q, σ</figDesc><table><row><cell cols="2">ξ,ca(h,cs),ξ -→</cell><cell cols="3">, σ . Using Rule 29.1.r we obtain (C, J, L, H, R)</cell></row><row><cell cols="3">p || (q || r), σ</cell><cell cols="2">ξ,ca(h,cs),ξ -→</cell><cell>p, σ and observe that (p, p) ∈ R.</cell></row><row><cell cols="5">(c) Rule 29.2.l has been applied. Then, (C, J ∪ W, L, H, R)</cell></row><row><cell>q, σ</cell><cell cols="4">ξ , (C, J ∪ W, L, H, R) p, σ</cell><cell>ξ,isa(h,cs),ξ -→</cell><cell>k p , σ for some k p such that</cell></row><row><cell cols="5">k 1 ≡ k p || q, and (C, J ∪ W, L, H, R) q, σ</cell><cell>ξ . Using Rule 29.1.r we obtain</cell></row><row><cell cols="3">(C, J, L, H, R)</cell><cell cols="2">q || r, σ</cell><cell>ξ,ira(h,cs,W ),ξ -→</cell><cell>q, σ . Using Rule 28.4.l we obtain</cell></row><row><cell cols="5">(C, J, L, H, R) p || (q || r), σ k p p, σ ξ,ca(h,cs),ξ -→ ξ , (C, J ∪ W, L, H, R) q, σ ξ,isa(h,cs),ξ -→</cell><cell>k q , σ for some k q such</cell></row><row><cell cols="5">that k 1 ≡ p || k q , and (C, J ∪ W, L, H, R)</cell><cell>p, σ</cell><cell>ξ . Using Rule 28.2.l we</cell></row><row><cell cols="4">obtain (C, J, L, H, R)</cell><cell>q || r, σ</cell><cell>ξ,ca(h,cs),ξ -→</cell><cell>k q , σ . Using Rule 29.2.r we ob-</cell></row><row><cell cols="5">tain (C, J, L, H, R) p || (q || r), σ p (2) Rule 28.2.r has been applied. Then, (C, J, L, H, R) p || q, σ ξ,ca(h,cs),ξ -→</cell><cell>ξ,ira(h,cs,W ),ξ -→</cell><cell>, σ</cell></row><row><cell cols="4">and (C, J ∪ W, L, H, R)</cell><cell>r, σ</cell></row><row><cell>-→</cell><cell></cell><cell cols="3">, σ cannot be obtained from the deduction rules.</cell></row><row><cell cols="5">(3) Rule 28.3.l has been applied. Then, we have (C, J ∪ W, L, H, R)</cell><cell>p || q, σ</cell></row><row><cell>ξ,isa(h,cs),ξ -→</cell><cell></cell><cell cols="3">, σ and (C, J, L, H, R) r, σ</cell><cell>ξ,ira(h,cs,W ),ξ -→</cell><cell>k</cell></row><row><cell>σ</cell><cell cols="4">ξ , and k 1 ≡ p. Using Rule 28.1.l we obtain (C, J, L, H, R)</cell><cell>q || r, σ</cell></row></table><note><p>ξ,isa(h,cs),ξ -→ k 1 , σ for some W , h, cs, and a = ca(h, cs). This case cannot occur since the conclusion (C, J, L, H, R) p || q, σ ξ,ira(h,cs,W ),ξ 1 , σ for some W , h, cs, and a = ca(h, cs). The conclusion (C, J ∪ W, L, H, R) p || q, σ ξ,isa(h,cs),ξ -→ ξ,ira(h,cs,W ),ξ -→ k 1 , σ and (C, J ∪ W, L, H, R) r, σ ξ,isa(h,cs),ξ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_25"><head></head><label></label><figDesc>|| q, σ . Take k 2 ≡ k p || q and observe that (k 1 , k 2 ) ∈ R. (d) Rule 29.2.r has been applied. Then, we have (C, J, L, H, R) || k q , σ . Take k 2 ≡ p || k q and observe that (k 1 , k 2 ) ∈ R. (5) Rule 28.4.l has been applied. Then, we have(C, J ∪ W, L, H, R) p || q, σ cs, k pq , k r such that k 1 ≡ k pq || k r , and a = ca(h, cs). For (C, J ∪ W, L, H, R) p || q, σ ξ,isa(h,cs),ξ -→ k pq , σ four cases can be distinguished: (a) Rule 29.1.l has been applied. Then, (C, J ∪ W, L, H, R) q, σ || k r . Take k 2 ≡ q || k r and observe that (k 1 , k 2 ) ∈ R. (b) Rule 29.1.r has been applied. Then, (C, J ∪ W, L, H, R) p, σ || k r , σ . Notice that k 1 ≡ p || k r . Take k 2 ≡ p || k r and observe that (k 1 , k 2 ) ∈ R. || (q || k r ), σ . Notice that k 1 ≡ (k p || q) || k r . Take k 2 ≡ k p || (q || k r ) and observe that (k 1 , k 2 ) ∈ R. || (k q || k r ), σ . Notice that k 1 ≡ (p || k q ) || k r . Take k 2 ≡ p || (k q || k r ) and observe that (k 1 , k 2 ) ∈ R.(6) Rule 28.4.r has been applied. Then, (C, J, L, H, R) p || q, σ , σ for some W , h, cs, k pq , k r such that k 1 ≡ k pq || k r , and a = ca(h, cs). For (C, J, L, H, R) p || q, σ ξ,ira(h,cs,W ),ξ -→ k pq , σ we can distinguish four more cases: (a) Rule 29.1.l has been applied. Then, we have (C, J, L, H, R)</figDesc><table><row><cell cols="6">that k pq ≡ p || k q , and (C, J ∪ W, L, H, R) p, σ ξ,ira(h,cs,W ),ξ -→ k p , σ for some k p such that ξ . Using Rule 28.4.l we k 1 ≡ k p || q, and (C, J, L, H, R) q, σ obtain (C, J, L, H, R) q || r, σ ξ,ca(h,cs),ξ -→ k q || k r , σ . Using Rule 29.2.r we ξ . Using Rule 29.1.r we obtain (C, J ∪ W, L, H, R) q || r, σ ξ,isa(h,cs),ξ -→ q, σ . Using Rule 28.4.r we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ p ξ,ira(h,cs,W ),ξ -→ k p p, σ ξ , (C, J, L, H, R) q, σ ξ,ira(h,cs,W ),ξ -→ k q , σ for some k q such that k 1 ≡ p || k q , and (C, J, L, H, R) p, σ ξ . Using Rule 28.3.r we obtain (C, J, L, H, R) q || r, σ ξ,ca(h,cs),ξ -→ k q , σ . Using Rule 29.2.r we obtain k pq , σ , (C, J ∪ W, L, H, R) r, σ ξ,isa(h,cs),ξ -→ k q, σ ξ , (C, J, L, H, R) p, σ ξ,ira(h,cs,W ),ξ -→ , σ , (C, J, L, H, R) q, σ</cell></row><row><cell cols="6">(C, J, L, H, R) p (c) Rule p || (q || r), σ ξ,ca(h,cs),ξ -→ 29.2.l has been applied. Then,</cell><cell>(C, J ∪ W, L, H, R)</cell></row><row><cell>q, σ</cell><cell cols="3">ξ , (C, J ∪ W, L, H, R)</cell><cell>p, σ</cell><cell>ξ,isa(h,cs),ξ -→</cell><cell>k Using Rule 29.2.r we obtain</cell></row><row><cell cols="2">(C, J, L, H, R)</cell><cell>q || r, σ</cell><cell cols="2">ξ,ira(h,cs,W ),ξ -→</cell><cell>q || k r , σ . Using Rule 28.4.l we ob-</cell></row><row><cell cols="6">tain (C, J, L, H, R) p || (q || r), σ k p (d) Rule ξ,ca(h,cs),ξ -→ 29.2.r has been applied. Then,</cell><cell>(C, J ∪ W, L, H, R)</cell></row><row><cell>p, σ</cell><cell cols="3">ξ , (C, J ∪ W, L, H, R)</cell><cell>q, σ</cell><cell>ξ,isa(h,cs),ξ -→</cell><cell>k q , σ for some k q such</cell></row></table><note><p><p><p><p><p><p>ξ,isa(h,cs),ξ</p>-→ k pq , σ , (C, J, L, H, R) r, σ ξ,ira(h,cs,W ),ξ</p>-→ k r , σ for some W , h, ξ , (C, J ∪ W, L, H, R) p, σ ξ,isa(h,cs),ξ -→ , σ , (C, J ∪ W, L, H, R) q, σ ξ</p>, and k pq ≡ q. Using Rule 29.2.r we obtain (C, J, L, H, R) q || r, σ ξ,ira(h,cs,W ),ξ -→ q || k r , σ . Using Rule 28.3.l, we obtain (C, J, L, H, R)</p>p || (q || r), σ ξ,ca(h,cs),ξ -→ q || k r , σ . Notice that k 1 ≡ q ξ , (C, J ∪ W, L, H, R) q, σ ξ,isa(h,cs),ξ -→ , σ , (C, J ∪ W, L, H, R) p,</p>σ ξ , and k pq ≡ p. Using Rule 28.3.l we obtain (C, J, L, H, R) q || r, σ ξ,ca(h,cs),ξ -→ k r , σ . Using Rule 29.2.r we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ -→ p p , σ for some k p such that k pq ≡ k p || q, (C, J ∪ W, L, H, R) q, σ ξ . r ξ and k pq ≡ q. Using Rule 29.2.r we obtain (C, J ∪ W, L, H, R) q || r, σ ξ,isa(h,cs),ξ -→ q || k r , σ . Using Rule 28.2.r we obtain (C, J, L, H, R) p || (q || r), σ ξ,ca(h,cs),ξ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_26"><head></head><label></label><figDesc>, and observe that (r, r) ∈ R. (8) Rule 29.1.r has been applied. Then, we have (C, J, L, H, R)</figDesc><table><row><cell>ξ,isa(h,cs),ξ -→</cell><cell cols="3">r, σ . Using Rule 28.3.r we obtain (C, J, L, H, R)</cell></row><row><cell cols="2">p || (q || r), σ r, σ p || q, σ ξ,ca(h,cs),ξ -→ ξ , (C, J, L, H, R)</cell><cell>r, σ</cell><cell>ξ,a,ξ</cell></row></table><note><p><p>-→ , σ , (C, J, L, H, R</p>) p || q, σ ξ , and k 1 ≡ p || q. According to Rule 31, we have (C, J, L, H, R) p, σ ξ , (C, J, L, H, R) q, σ ξ , (C, J, L, H, R) p, σ ξ , and (C, J, L, H, R) q, σ ξ . Using Rule 29.1.r, we obtain (C, J, L, H, R) q || r, σ ξ,a,ξ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_27"><head></head><label></label><figDesc>, σ for some k p such that k 1 ≡ ∂ ∅ (k p ). Take k 2 ≡ k p and observe that (k 1 , k 2 ) ∈ R. ∅ (k 1 ), σ . Take k 2 ≡ ∂ ∅ (k 1 ) and observe that (k 2 , k 1 ) ∈ R.-→ k p , σ for some k p such that k 1 ≡ ∂ ∅ (k p ). Take k 2 ≡ k p and observe that (k 1 , k 2 ) ∈ R. -→ k 1 , σ for some E, σ, t, ρ, k 1 , σ . Using Rule 33, -→ ∂ ∅ (k 1 ), σ . Take k 2 ≡ ∂ ∅ (k 1 ) and observe that (k 2 , k 1 ) ∈ R.For arbitrary closed process term p and sets of actions A and A we have∂ Let R = {(∂ A (∂ A (p)), ∂ A∪A (p)) | p ∈ P , sets of actions A, A } ∪ {(i d , i d ) | i d ∈ P }. -→ ,σ and a ∈ A . From a ∈ A and a ∈ A , we know that a ∈ A ∪ A . Using Rule 32.1, we obtain E ∂ A∪A (p), σ -→ , σ for some E, σ, ξ, a, ξ , σ , which means Rule 32.1 has been applied necessarily. Then, E p, σ ξ,a,ξ -→ , σ and a ∈ A ∪ A . From a ∈ A ∪ A , we know that a ∈ A and a ∈ A . Using Rule 32.1, we get E ∂ A (p), σ , σ for some k p such that k 1 ≡ ∂ A∪A (k p ) and a ∈ A ∪ A . From a ∈ A ∪ A , we know that a ∈ A and a ∈ A . Using Rule 32.2, we get E ∂ A (p), σ ξ,a,ξ -→ ∂ A (k p ), σ . Again, due to Rule 32.2, A (k p )) and observe that (k 2 , k 1 ) ∈ R. Condition 4: We assume E ∂ A (∂ A (p)), σ t,ρ -→ k 1 , σ for some E, σ , t, ρ, k 1 , σ , which means Rule 33 has been applied necessarily. Then, E ∂ Note that k 1 ≡ ∂ A (∂ A (k p )). Take k 2 ≡ ∂ A∪A (k p ) and observe that (k 1 , k 2 ) ∈ R. -→ k 1 , σ for some E, σ, t, ρ, k 1 , σ , which means Rule 33 has been applied necessarily. Then, E p, σ t,ρ -→ k p , σ for some k p such that k 1 ≡ ∂ A∪A (k p ). Using Rule 33, we get E ∂ A (p), σ -→ ∂ A (∂ A (k p )), σ . Take k 2 ≡ ∂ A (∂ A (k p )) and observe that (k 2 , k 1 ) ∈ R.</figDesc><table><row><cell cols="4">Condition 1: First, we assume E</cell><cell>∂ A (∂ A (p)), σ</cell><cell>ξ,a,ξ -→ , σ for some E, σ, ξ, a, ξ , σ ,</cell></row><row><cell cols="5">which means Rule 32.1 has been applied necessarily. Then, E ∂ A (p), σ</cell><cell>ξ,a,ξ -→ , σ and</cell></row><row><cell cols="5">a ∈ A. Again, due to Rule 32.1, we have E p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>ξ,a,ξ -→ , σ .</cell></row><row><cell cols="5">Second, we assume E ∂ A∪A (p), σ</cell><cell>ξ,a,ξ</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>ξ,a,ξ -→</cell></row><row><cell cols="5">, σ . Again, using Rule 32.1, we obtain E</cell><cell>∂ A (∂ A (p)), σ</cell><cell>ξ,a,ξ</cell></row><row><cell>we have E</cell><cell cols="2">∂ A (∂ A (p)), σ</cell><cell>ξ,a,ξ</cell></row><row><cell cols="3">Condition 3: We assume E</cell><cell>p, σ</cell><cell>ξ,a,ξ</cell></row><row><cell cols="3">Condition 4: We assume E</cell><cell cols="2">∂ ∅ (p), σ</cell><cell>t,ρ</cell></row><row><cell cols="5">means Rule 33 has been applied necessarily. Then, E</cell><cell>p, σ</cell><cell>t,ρ</cell></row><row><cell cols="3">Condition 5: We assume E Condition 5: We assume E</cell><cell cols="2">p, σ ∂ A∪A (p), σ t,ρ</cell><cell>t,ρ</cell></row><row><cell cols="5">we obtain E Condition 6: First, we assume E t,ρ ∂ ∅ (p), σ has been applied necessarily. Then, E ∂ ∅ (p), σ p, σ Rule 33, we obtain E ∂ A (∂ A (p)), σ t,ρ</cell><cell>ξ . Second, we assume E t,ρ -→ ∂ A (k p ), σ . Due to for some E, σ, ξ , which means Rule 34 ξ p, σ ξ for</cell></row><row><cell cols="5">some E, σ, ξ . Using Rule 34, we obtain E Condition 6: First, we assume E ∂ A (∂ A (p)), σ ∂ ∅ (p), σ</cell><cell>ξ</cell><cell>for some E, σ, ξ , which means</cell></row><row><cell cols="5">Rule 34 has been applied necessarily. Then, E</cell><cell>∂ A (p), σ</cell><cell>ξ . Again, due to Rule 34,</cell></row><row><cell>we have E</cell><cell>p, σ</cell><cell cols="3">ξ . Then using Rule 34, we obtain E</cell><cell>∂ A∪A (p), σ</cell></row></table><note><p><p><p><p><p><p><p><p>ξ,a,ξ -→ , σ . Second, we assume E p, σ ξ,a,ξ -→ , σ for some E, σ, ξ, a, ξ , σ . We know that a ∈ ∅. Using Rule 32.1, we obtain E ∂ ∅ (p), σ ξ,a,ξ -→ , σ . Condition 2: We assume E ∂ ∅ (p), σ ξ,a,ξ -→ k 1 , σ for some E, σ, ξ, a, ξ , k 1 , σ , which means Rule 32.2 has been applied necessarily. Then, E p, σ ξ,a,ξ -→ k p -→ k 1 , σ for some E, σ, ξ, a, ξ , k 1 , σ . We know that a ∈ ∅. Using Rule 32.2, we obtain E ∂ ∅ (p), σ ξ,a,ξ</p>-→ ∂ -→ k 1 , σ for some E, σ, t, ρ, k 1 , σ , which ξ . Lemma 32. A (∂ A (p)) ↔ ∂ A∪A (p).</p>Proof.</p>-→ , σ .</p>Condition 2: We assume E ∂ A (∂ A (p)), σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 ,</p>σ , which means Rule 32.2 has been applied necessarily. Then, E ∂ A (p), σ ξ,a,ξ -→ k p , σ for some k p such that k 1 ≡ ∂ A (k p ) and a ∈ A. Using Rule 32.2, we get E p, σ ξ,a,ξ -→ k p , σ for some k p such that k p ≡ ∂ A (k p ) and a ∈ A . From a ∈ A and a ∈ A , we know that a ∈ A ∪ A . Using Rule 32.2, we get E ∂ A∪A (p), σ ξ,a,ξ</p>-→ ∂ A∪A (k p ), σ . Note that k 1 ≡ ∂ A (∂ A (k p )). Take k 2 ≡ ∂ A∪A (k p ) and observe that (k 1 , k 2 ) ∈ R. Condition 3: We assume E ∂ A∪A (p), σ ξ,a,ξ -→ k 1 , σ for some E, σ , ξ , a, ξ , k 1 ,</p>σ , which means Rule 32.2 has been applied necessarily. Then, E p, σ ξ,a,ξ -→ k p -→ ∂ A (∂ A (k p )), σ . Take k 2 ≡ ∂ A (∂ A (p), σ t,ρ -→ k p , σ for some k p such that k 1 ≡ ∂ A (k p ). Again, due to Rule 33, we get E p, σ t,ρ -→ k p , σ for some k p such that k p ≡ ∂ A (k p ). Using Rule 33, we obtain E ∂ A∪A (p), σ t,ρ -→ ∂ A∪A (k p ), σ . ξ . Second,</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors would like to thank Jos Baeten, Pieter Cuijpers, Albert Hofkamp, Niek Jansen, Erjen Lefeber, Bas Luttik, Henk Nijmeijer, Sasha Pogromsky, and Frits Vaandrager for helpful comments and stimulating discussions. The authors also wish to thank the anonymous reviewers for their valuable comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof. Since there are no transition rules defined for ⊥, also note that p [] ⊥ has no transitions, the conditions 1-6 hold trivially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 35. For arbitrary closed process term p we have</head><p>Proof. Since there are no transition rules defined for ⊥, also note that p || ⊥ has no transitions, the conditions 1-6 hold trivially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 36. For arbitrary set of actions A we have</head><p>Proof. Since there are no transition rules defined for ⊥, also note that ∂ A (⊥) has no transitions, the conditions 1-6 hold trivially.</p><p>Lemma 37. For arbitrary closed process term p we have</p><p>Proof. Since there are no transition rules defined for ⊥, also note that p; ⊥ has no transitions, the conditions 1-6 hold trivially.</p><p>Lemma 38. We have skip; ⊥ ↔ δ.</p><p>Proof. We know that skip ≡ ∅ : true τ . Let R = {(∅ : true τ ; ⊥, δ)}. Since there are no action transition rules and time transition rules defined for δ and ⊥, also ∅ : true τ ; ⊥ cannot perform any action transitions (because ⊥ is not consistent) and time transitions (because no time transition rules defined for ∅ : true τ ), the conditions 1-5 hold trivially. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Equivalence of hybrid dynamical models</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P M H</forename><surname>Heemels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Schutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bemporad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1085" to="1091" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R H</forename><surname>Schiffelers</surname></persName>
		</author>
		<idno>04-37</idno>
		<title level="m">Syntax and consistent equation semantics of hybrid Chi</title>
		<meeting><address><addrLine>The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CS-Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Filippov</surname></persName>
		</author>
		<title level="m">Differential Equations with Discontinuous Right Hand Sides</title>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">I</forename><surname>Utkin</surname></persName>
		</author>
		<title level="m">Sliding Modes in Control Optimization</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An approach to the description and analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Theory of Hybrid Systems</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="149" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The algorithmic analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="34" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic symbolic verification of embedded systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="181" to="201" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Verification of Digital and Hybrid Systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">NATO ASI Series F: Computer and Systems Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Inan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Kurshan</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">170</biblScope>
			<biblScope unit="page" from="265" to="292" />
			<date type="published" when="2000">2000</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>The theory of hybrid automata</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Introduction to Hybrid Dynamical Systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Van Der Schaft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Schumacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Control and Information Sciences</title>
		<imprint>
			<biblScope unit="volume">251</biblScope>
			<date type="published" when="2000">2000</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vaandrager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I/O</forename><surname>Hybrid</surname></persName>
		</author>
		<author>
			<persName><surname>Automata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Comput</title>
		<imprint>
			<biblScope unit="volume">185</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="105" to="157" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dynamical properties of hybrid automata</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lygeros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Simic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sastry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Automat. Control</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2" to="17" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pogromsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nijmeijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
		</author>
		<title level="m">Convex equations and differential inclusions in hybrid systems</title>
		<meeting><address><addrLine>Nassau Bahamas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1424" to="1429" />
		</imprint>
	</monogr>
	<note>rd IEEE Conference on Decision and Control</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R H</forename><surname>Schiffelers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Modeling and Analysis of Timed Systems: First International Workshop, FORMATS 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Niebert</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2791</biblScope>
			<biblScope unit="page" from="151" to="165" />
		</imprint>
	</monogr>
	<note>Formal semantics of hybrid Chi</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First International Conference on Tools and Algorithms for the Construction and Analysis of Systems TACAS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1019</biblScope>
			<biblScope unit="page" from="41" to="71" />
		</imprint>
	</monogr>
	<note>A user guide to HyTech</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A discrete-event simulator for systems engineering</title>
		<author>
			<persName><forename type="first">G</forename><surname>Naumoski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Alberts</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Modelling and control of process industry batch production systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Van Den Ham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
		</author>
		<imprint>
			<pubPlace>Barcelona, 2002, CD-ROM</pubPlace>
		</imprint>
	</monogr>
	<note>in: 15th Triennial World Congress of the International Federation of Automatic Control</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A language and simulator for hybrid systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Fábián</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Languages and applications in hybrid modelling and simulation: positioning of Chi</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Control Eng. Pract</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="91" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Formal specification and analysis of industrial systems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J T</forename><surname>Kleijn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Automatic verification of a manufacturing system</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J T</forename><surname>Kleijn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Robot. Comput. Integr. Manufactur</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="185" to="198" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A hybrid language for modeling, simulation and verification</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R H</forename><surname>Schiffelers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFAC Conference on Analysis and Design of Hybrid Systems</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Engell</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Guéguen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Zaytoon</surname></persName>
		</editor>
		<meeting><address><addrLine>Saint-Malo; Brittany, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="235" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">A structural approach to operational semantics</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Aarhus University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. DIAMI FN-19</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Hybrid transition systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J L</forename><surname>Cuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P M H</forename><surname>Heemels</surname></persName>
		</author>
		<idno>02-12</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>The Netherlands</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CS-Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Process algebra with propositional signals</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">177</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="381" to="405" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Process algebra for hybrid systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">335</biblScope>
			<biblScope unit="issue">2/3</biblScope>
			<biblScope unit="page" from="215" to="280" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<idno>no. 0-40</idno>
		<title level="m">Simulation News Europe</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Breitenecker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Husinsky</surname></persName>
		</editor>
		<imprint>
			<publisher>Ch. ARGESIM Comparisons</publisher>
			<date type="published" when="1990">1990-2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Notions of bisimulation and congruence formats for SOS with data</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Mousavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Comput</title>
		<imprint>
			<biblScope unit="volume">200</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="107" to="147" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M R</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Concurrency and automata on infinite sequences</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Deussen</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="page" from="167" to="183" />
		</imprint>
	</monogr>
	<note>Proceedings 5th GI Conference</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Calculus of Communicating Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Concrete process algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Verhoef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Logic in Computer Science, Semantic Modelling</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Maibaum</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="149" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Hybrid process algebra</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J L</forename><surname>Cuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Algebr. Program</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="191" to="245" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The φ-calculus: a language for distributed control of reconfigurable embedded systems</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Rounds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, 6th International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2623</biblScope>
			<biblScope unit="page" from="435" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Jifeng</surname></persName>
		</author>
		<title level="m">From CSP to hybrid systems</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</editor>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="171" to="189" />
		</imprint>
	</monogr>
	<note>A Classical Mind</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A formal description of hybrid systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Chaochen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems III-Verification and Control</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Sonntag</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1066</biblScope>
			<biblScope unit="page" from="511" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A process algebra for hybrid systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Vereijken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Second European Workshop on Real-Time and Hybrid Systems</title>
		<editor>
			<persName><forename type="first">Maler</forename><surname>Bouajjani</surname></persName>
		</editor>
		<meeting><address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Structural operational semantics</title>
		<author>
			<persName><forename type="first">L</forename><surname>Aceto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Fokkink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Verhoef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Bergstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Smolka</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="197" to="292" />
		</imprint>
	</monogr>
	<note>Chapter 3</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Algorithmic analysis of nonlinear hybrid systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Automat. Control</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="540" to="554" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">PHAVer: algorithmic verification of hybrid systems past HyTech</title>
		<author>
			<persName><forename type="first">G</forename><surname>Frehse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, 8th International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Morari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3414</biblScope>
			<biblScope unit="page" from="258" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Process Algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Weijland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Cambridge Tracts in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="1990">1990</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, United Kingdom</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
		<title level="m">Process Algebra with Timing, EACTS Monographs in Theoretical Computer Science</title>
		<meeting>ess Algebra with Timing, EACTS Monographs in Theoretical Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rooda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R H</forename><surname>Schiffelers</surname></persName>
		</author>
		<idno>05-09</idno>
		<title level="m">Syntax and semantics of timed Chi</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology, Department of Computer Science, The Netherlands</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CS-Report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Linearization of hybrid processes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Van De Brand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J L</forename><surname>Cuijpers</surname></persName>
		</author>
		<idno>04-29</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>The Netherlands</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CS-Report</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">On hybrid Petri nets</title>
		<author>
			<persName><forename type="first">R</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Alla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Event Dyn. Syst.: Theory Appl</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="9" to="40" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Special Issue on Hybrid Petri Nets</title>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Event Dyn. Syst</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Febbraro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Giua</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Menga</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Hierarchical modeling and analysis of embedded systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ivancić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sokolsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="11" to="28" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Masaccio: a formal model for embedded components</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First IFIP International Conference on Theoretical Computer Science (TCS)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1872</biblScope>
			<biblScope unit="page" from="549" to="563" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="666" to="677" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Modeling and verification of hybrid dynamical system using CheckMate</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">I</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Richeson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chutinan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Dynamical Systems-Proc. of 4th International Conference on Automation of Mixed Processes</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Engell</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Kowalewski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Zaytoon</surname></persName>
		</editor>
		<meeting><address><addrLine>Dortmund</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="323" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Approximate reachability analysis of piecewise-linear dynamical systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Asarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Bournez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, Third International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1790</biblScope>
			<biblScope unit="page" from="20" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Progress on reachability analysis of hybrid systems via predicate abstraction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ivancić</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, 6th International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2623</biblScope>
			<biblScope unit="page" from="4" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Verification of hybrid systems based on counterexample-guided abstraction</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Stursberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2619</biblScope>
			<biblScope unit="page" from="192" to="207" />
			<date type="published" when="2003">2003</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Tools and Algorithms for the Construction and Analysis of Systems</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Refining abstractions of hybrid systems using counterexample fragments</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, 8th International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Morari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3414</biblScope>
			<biblScope unit="page" from="242" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Safety verification of hybrid systems by constraint propagation based abstraction refinement</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ratschan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>She</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, 8th International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Morari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3414</biblScope>
			<biblScope unit="page" from="573" to="589" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
