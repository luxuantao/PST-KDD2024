<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Locales: A Module System for Mathematical Theories</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Clemens</forename><surname>Ballarin</surname></persName>
							<email>ballarin@in.tum.de</email>
							<affiliation key="aff0">
								<address>
									<addrLine>Stephanienstr. 61</addrLine>
									<postCode>76133</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<address>
									<addrLine>Stephanienstr. 61</addrLine>
									<postCode>76133</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Locales: A Module System for Mathematical Theories</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BB9BF12186521EA794E12D3F7386E836</idno>
					<idno type="DOI">10.1007/s10817-013-9284-7</idno>
					<note type="submission">Received: 30 November 2012 / Accepted: 18 March 2013</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Theorem prover</term>
					<term>Module system</term>
					<term>Theory hierarchy</term>
					<term>Theory interpretation</term>
					<term>Isabelle</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Locales are a module system for managing theory hierarchies in a theorem prover through theory interpretation. They are available for the theorem prover Isabelle. In this paper, their semantics is defined in terms of local theories and morphisms. Locales aim at providing flexible means of extension and reuse. Theory modules (which are called locales) may be extended by definitions and theorems. Interpretation to Isabelle's global theories and proof contexts is possible via morphisms. Even the locale hierarchy may be changed if declared relations between locales do not adequately reflect logical relations, which are implied by the locales' specifications. By discussing their design and relating it to more commonly known structuring mechanisms of programming languages and provers, locales are made accessible to a wider audience beyond the users of Isabelle. The discussed mechanisms include ML-style functors, type classes and mixins (the latter are found in modern object-oriented languages).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The developers of the computer algebra system Axiom pioneered implementing complex hierarchies of algebraic structures in a computer language. The user manual <ref type="bibr" target="#b12">[13]</ref> shows a graph of 45 interconnected algebraic structures at 15 levels in the basic algebra hierarchy all of which are implemented as types in that system. Standard libraries of programming languages usually have many more classes, but hierarchies tend to be less deep. (For example, the Java 6 Standard Edition class library contains almost 3800 classes at only eight levels <ref type="bibr" target="#b19">[20]</ref>.) It is evident that such libraries are only maintainable if they can be extended easily.</p><p>Locales provide flexible means of building and using hierarchic developments of theory modules and were designed so that abstract algebraic theories could be represented in an adequate fashion. Today, locales are used in many domains. Examples include proofs in graph theory <ref type="bibr" target="#b17">[18]</ref>, set theory <ref type="bibr" target="#b20">[21]</ref> and state space management in programming language semantics <ref type="bibr" target="#b21">[22]</ref>. Also Isabelle's class package uses locales <ref type="bibr" target="#b9">[10]</ref>.</p><p>Locales provide some of the automation that makes Isabelle's type classes attractive, but they are not restricted to a single carrier type. Theorem reuse is rigourously based on interpretation (often called theory interpretation in the context of provers), and locales can deal with important forms of circular theory module dependencies.</p><p>A re-implementation of locales was released with Isabelle 2009. Users have mainly benefited from more powerful locale expressions, which provide flexible means for composing theory hierarchies. In particular, locale expressions now admit parameter instantiation, while previously only renaming was possible. This is useful, for example, for expressing duality. Local theories <ref type="bibr" target="#b10">[11]</ref>, which became available in Isabelle at that time, helped clarify the design and reduce the code size of the locales implementation to about two thirds.</p><p>The purpose of the present paper is to provide an operational semantics of locales relative to local theories, and to outline the design goals. Relations to other structuring mechanisms, both for formal theory developments and programming languages, are established. Users of locales should also consult the tutorial <ref type="bibr" target="#b4">[5]</ref>.</p><p>The following section contains formalisations of algebraic structures that illustrate important features of locales and serve as a base for examples in the subsequent sections. Local theories and other devices necessary to define locales are introduced in Section 3. Section 4 is the core of the paper. Locales and the user-level operations are defined. In Section 5 relations to ML-style modules and other means of reuse in provers and programming languages are discussed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Example-the Lattice of Subgroups</head><p>The formalisation presented in this section serves to introduce locales by example. It involves two algebraic structures, lattice and group, who are related by identifying the lattice induced by the subgroup relation.</p><p>Isabelle's notation for formulas is close to what is common in mathematics. Both and ∀ denote universal quantification, and =⇒ and -→ denote implication. 1 Double square brackets abbreviate nested implication:</p><formula xml:id="formula_0">[[ A 1 ; . . . ; A n ]] =⇒ B means A 1 =⇒ . . . =⇒ A n =⇒ B.</formula><p>The double arrow ←→ is an alternative notation for equality on Booleans, and with precedence lower than that of the logical connectives ∧, ∨ etc. 1 The differences between Isabelle's meta-logical connectives and =⇒ and the connectives ∀ and -→ of the HOL object-logic are not relevant for understanding the examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Algebraic Structures</head><p>An abstract algebraic structure like group or lattice is declared with the locale command. Our example is based on lattices and we start with the formalisation of partial orders. locale partial_order = fixes S and le (infixl " " 50) assumes refl: "x ∈ S =⇒ x x" and antisym: "[[ x y; y x; x ∈ S; y ∈ S ]] =⇒ x = y" and trans: "[[ x y; y z; x ∈ S; y ∈ S; z ∈ S ]] =⇒ x z"</p><p>The carrier set S and the order relation le (with concrete syntax ) are the parameters (fixes) of the specification, which consists of the usual axioms (assumes).</p><p>Infima do not necessarily exist in partial orders, but it is useful to have a notion for the concept already here. The context command enables to focus on a locale and to extend it-in this case, by a definition. context partial_order begin definition is_inf where "is_inf x y w ←→ w x ∧ w y ∧ (∀ z ∈ S. z x ∧ z y -→ z w) ∧ x ∈ S ∧ y ∈ S ∧ w ∈ S" end That is, is_inf is a predicate, and is_inf x y w means that w is the infimum of x and y in the carrier set. A semilattice is a partial order where infima for any two elements exist. locale semilattice = partial_order "S" "le" for S and le (infixl " " 50) + assumes existence: "[[ x ∈ S; y ∈ S ]] =⇒ ∃ inf. is_inf x y inf"</p><p>This declaration consists of a locale expression (the second line), and an additional axiom. A locale expression contains one or several locale instances and an optional for clause. Here the expression describes an instance of partial_order, which is imported. While in the previous locale the parameters were declared in a fixes clause, here they have moved to the for clause so that they can be referred to in the instance of the imported locale. Within semilattice we can now define an operation for the infimum, by means of the definite selection operator, 2 and elaborate its properties, for example associativity: context semilattice begin definition meet (infixl " " 70) where "op = (λx ∈ S. λy ∈ S. THE inf. is_inf x y inf)" lemma assoc: "(x y) z = x (y z)" proof . . . end 2 Since HOL is total, bounded λ-abstraction denotes a function that maps all arguments outside the domain to a fixed but unknown value, about which nothing can be proved. Likewise for the definite selection operator THE if the described element does not exist or is not unique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Duality</head><p>It is immediate from the axioms that the inverse relation of a partial order is again a partial order. With locales, this can be expressed with the sublocale command:</p><p>sublocale partial_order ⊆ dual!: partial_order "S" "λx y. y</p><p>x"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>proof</head><p>The declaration consists of a locale (to the left of ⊆) called the target and a locale expression. Based on the provided proof, the target locale is enriched by definitions and theorems of the locale instance given in the expression. The qualifier dual identifies these dual versions. For example, dual.is_inf is now recognised as the dual of is_inf. The exclamation mark asserts that the qualifier is required when referencing names in the dual instance. This prevents accidental hiding of names of the original locale. In contrast to the expression in the locale declaration above, here a for clause is not needed: S and are parameters of the target.</p><p>We may now introduce syntax for the supremum predicate.</p><p>context partial_order begin abbreviation is_sup where "is_sup ≡ dual.is_inf" end Its definition is already available through the sublocale declaration.</p><p>A lattice consists of a lower semilattice and a dual upper semilattice. In contrast to the previous situation, where duality only implied new definitions and theorems, we now need to obtain a new axiom, namely the existence of the supremum. This is achieved by declaring a locale that imports two instances of semilattice. locale lattice = semilattice "S" "le" + dual!: semilattice "S" "λx y. y</p><p>x"</p><p>for S and le (infixl " " 50)</p><p>Like for is_sup, syntax for the supremum operation could now be declared.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">A Concrete Instance</head><p>Interpretation facilitates reuse of definitions and theorems from locales in other contexts. Given a proof of an instance of the axioms within a context, the context is enriched by instances of the theorems. To illustrate this, we consider the power set of a set X, which is a lattice with respect to the subset relation.</p><p>The interpretation command interprets a locale in the context of Isabelle's global background theory. We proceed in two steps, first showing that the power set is partially ordered: interpretation power!: partial_order "Pow X" "op ⊆" proof Since the base set X is arbitrary it is represented by a variable. The interpretation yields theorems qualified by power-for example, power.trans,</p><formula xml:id="formula_1">[[x ⊆ y; y ⊆ z; x ∈ Pow X; y ∈ Pow X; z ∈ Pow X]] =⇒ x ⊆ z</formula><p>and its dual power.dual.trans,</p><formula xml:id="formula_2">[[y ⊆ x; z ⊆ y; x ∈ Pow X; y ∈ Pow X; z ∈ Pow X]] =⇒ z ⊆ x</formula><p>The above interpretation merely instantiated the locale parameters. For lattice it is desirable to replace definitions in the locale by corresponding concepts from the target context. This is achieved by extending the interpretation. interpretation power!: lattice "Pow X" "op ⊆"</p><p>where "power.meet = (λA ∈ Pow X. λB ∈ Pow X. A ∩ B)" and "power.dual.meet = (λA ∈ Pow X. λB ∈ Pow X. A ∪ B)"</p><formula xml:id="formula_3">proof</formula><p>The infimum is, of course, set intersection and its dual set union. In order to meet the definitions, the operations need to be restricted to the carrier set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Interpretation in Generic Contexts</head><p>Interpretations occur naturally in the contexts of algebraic structures themselves. A well-known example is the lattice of subgroups of a group. The carrier set of a group is closed under group operations. Since this notion is required for both the definition of groups and subgroups, we declare a locale for it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>locale closed =</head><p>fixes G and mult (infixl "•" 70) and one ("1") and inv</p><formula xml:id="formula_4">assumes mult_closed: "[[ x ∈ G; y ∈ G ]] =⇒ x • y ∈ G" and one_closed: "1 ∈ G" and inv_closed: "x ∈ G =⇒ inv x ∈ G"</formula><p>The locale declaration for the actual group definition imports this locale:</p><formula xml:id="formula_5">locale group = closed + assumes assoc: "[[ x ∈ G; y ∈ G; z ∈ G ]] =⇒ (x • y) • z = x • (y • z)" and l_one: "x ∈ G =⇒ 1 • x = x" and l_inv: "x ∈ G =⇒ inv x • x = 1"</formula><p>Here, the parameters of closed are not instantiated explicitly. A short-hand notation is used that makes the parameters of the instance implicit parameters of the declared locale. For details, see the locales tutorial <ref type="bibr" target="#b4">[5]</ref>.</p><p>A subgroup is a subset that is closed under group operations. This naturally leads to the set G of all subgroups of G and the closure S of a set S, which is the smallest subgroup of G that contains S. where "G = {H. H G}" definition closure (" _ ")</p><p>where " S = {H. S ⊆ H ∧ H</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G}" end</head><p>The definition of subgroup involves the predicate closed, which is generated by the declaration of the locale closed and abbreviates its specification.</p><p>We are now ready to show that G is a lattice. By means of the sublocale command, we provide an interpretation of lattice in the context of group, where the supremum operation is set intersection, and the infimum of two subgroups is the group generated by the union of their carrier sets: sublocale group ⊆ sub!: lattice "G " "op "</p><p>where "sub.meet = (λK ∈ G . λL ∈ G . K ∩ L)" and "sub.dual.meet = (λK</p><formula xml:id="formula_6">∈ G . λL ∈ G . K ∪ L )" proof</formula><p>The group context is now enriched by instances of lattice theorems qualified by sub-for example associativity of the join operation, sub.dual.assoc, (λK∈G . λL∈G . K ∪ L ) ((λK∈G . λL∈G . K ∪ L ) x y) z = (λK∈G . λL∈G . K ∪ L ) x ((λK∈G . λL∈G . K ∪ L ) y z)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Logic and Architecture Prerequisites</head><p>Locales provide means for building and working with large theory developments based on small components or little theories <ref type="bibr" target="#b7">[8]</ref>. In Isabelle, these components are the local theories implemented by Haftmann and Wenzel <ref type="bibr" target="#b10">[11]</ref> on top of the Isabelle/Isar framework. While locales are implemented in the local theories framework, conceptually they are not closely tied to Isabelle and Isar and could be implemented in other provers as well. Properties of the logic and facilities of a theorem prover architecture required by locales are defined in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Logic Calculus</head><p>Locales require certain properties of the calculus implemented by the prover. These, along with notation, are introduced now.</p><p>Terms s, t, . . . and formulas A, B, . . . are distinguished, and formulas are terms.<ref type="foot" target="#foot_0">3</ref> Theorems are sequents A 1 , . . . , A n B, where n ≥ 0 and the hypotheses A 1 , . . . , A n and the proposition B are formulas. Variables are denoted by x, y, . . ., sequences of variables, terms and formulas by x, y, . . . etc. Free variables in theorems are implicitly universally quantified, and theorems are closed under instantiation of variables:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A[x] B[x] A[t] B[t]</head><p>Instantiation may be restricted-for example, to ensure type correctness if the logic is typed. There is an equivalence ≡ of terms, where s ≡ t is a formula, and implication and conjunction over formulas, denoted by =⇒ and ∧ respectively. Theorems are closed under substitution of equivalent terms:</p><formula xml:id="formula_7">A s ≡ t B[s] C[s] A, B[t] C[t]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Global Theories</head><p>Based on the calculus, the prover provides global theories. These are not parametric.</p><p>Locales require global background theories to store deductive information and socalled foundational constants, which are the base for operations provided in local theories. Global theories implement the calculus, and they provide facilities for defining foundational constants and noting theorems. These are the operations on global theories (thy):</p><p>base : thy</p><formula xml:id="formula_8">def : name → term → thy → thy note : name → thm → thy → thy</formula><p>The base theory base is the global theory that implements the logic calculus by providing its connectives and deductive machinery. It may contain additional axioms, operation symbols and definitions that are not part of the calculus. Examples are Isabelle's object logics HOL and ZF. The prover must implement a mechanism for retrieving axioms and theorems from a theory, and, of course, for deriving new theorems. This is not made explicit here, and axioms and theorems in global theories are not distinguished. Constant and theorem names are qualified-that is, are of the form q 1 . • • • .q k .n in general.</p><p>The operation def c t extends a global theory by the foundational constant c along with its definition c ≡ t. For readability, we will write def c x ≡ t instead of def c (λx. t).</p><p>The note operation models binding a theorem: note b ( A) extends a theory by binding A to b . Theorems in global theories may not have hypotheses. Whether derivability of theorems is checked depends on the prover, which-as is the case for Isabelle-may request and check a proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Local Theories</head><p>Local theories are parametric. Unlike global theories, whose sets of axioms are extensible (by definitions of foundational constants), the specification of a local theory is fixed. New operation symbols are simulated through abbreviations, and definitions are derived. These operations are available on local theories (lthy): initialize : vars → form → thy → lthy promote : (thy → thy) → lthy → lthy abbreviate : name → term → lthy → lthy note : name → thm → lthy → lthy A local theory may be obtained from a global theory by initialize x A <ref type="bibr">[x]</ref>. It has the parameters x and the specif ication A, whose only free variables are the parameters. <ref type="foot" target="#foot_1">4</ref>The local theory inherits language and theorems of the global theory, which is called its underlying theory; promote f changes the underlying theory of a local theory via f . Only extensions of the underlying theory by def and note are allowed.</p><p>An operation in a local theory is introduced by adding an abbreviation: abbreviate c t[x] causes the term t[x] to be displayed as c when a term is printed, and c to be stored as t[x] in the internal representation when a term is read; x refers to the parameters of the local theory that is extended. Operation symbols introduced through abbreviate must be distinct from symbols inherited from the global theory. In contrast to global theories, theorems in local theories may have the local theory specification A[x] as a hypothesis: note b (A[x] B[x]).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Morphisms</head><p>Morphisms are a key ingredient to the composition of specifications (and their local theories) to hierarchies. They also define how local theories are interpreted in contexts. A morphism ϕ = (ϕ n , ϕ t , ϕ th ) consists of three mappings: ϕ n is applied to operation and theorem names, ϕ t maps terms, and ϕ th transforms theorems. Application of a morphism ϕ to a name n, term t or theorem A B is denoted by ϕ(n), ϕ(t) and ϕ(A B), respectively. Composition of morphisms is by component and denoted by "•".</p><p>There are the four primitive morphisms:</p><formula xml:id="formula_9">qual(q) = (n → q.n, t[c] → t[q.c], th[c] → th[q.c]) inst(t/x) = (id, t [x] → t [t], th[x] → th[t]) intp(A B) = (id, id, B C → A C) rewr(A s ≡ t) = (id, t [s] → t [t], A C[s] → A C[t])</formula><p>All morphisms used in locales are composed from these; id denotes the identity morphism. The qualif ication morphism qual(q) prepends operation and theorem names with the qualifier q. Qualification of operation names is not necessarily a morphism on theorems. It is, though, in the context of a local theory, where operation names are bound names, and thus are renamed in definitions and theorems in a consistent manner.</p><p>For the other three to be morphisms, the underlying logic must enjoy the properties outlined in Section 3.1. The instantiation morphism inst(t/x) instantiates a variable x by a term t. If some specification A entails some other specification B then theorems may be lifted from the weaker to the stronger context. This is known as theory interpretation, and we denote the corresponding interpretation morphism by intp(A B). Finally, the rewrite morphism rewr(A s ≡ t) replaces all occurrences of s in terms and theorems by t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Locales</head><p>Locales are a means of persisting local theories, and they provide flexible means of reuse: a locale declaration may extend one or several locales (import), a locale can be made available in other locales, or in other kinds of contexts the prover provides (interpretation). Locales are defined in this section, and their semantics is given by mapping them to local theories.</p><p>The core algorithm will be presented in pseudo code based on Standard ML <ref type="bibr" target="#b15">[16]</ref>. Finite sequences (lists) will be denoted by square brackets; ":" is infix notation for the cons operator and "@" concatenation. Juxtaposition denotes function application, and x f is an alternative notation for f x. The function fold folds a binary operation f over a list:</p><formula xml:id="formula_10">fun fold f [] y = y | fold f (x : xs) y = fold f xs ( f x y)</formula><p>Parentheses are used for morphism application: ϕ(x).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definition</head><p>Locales are named, and there is a locale environment lenv that maps locale names to locales. A locale lenv n consists of these components:</p><p>-The parameters parms n, a sequence of variables x.</p><p>-The specif ication spec n, a proposition A.</p><p>-The declarations decls n, a sequence of declarations of either the form abbreviates c t or notes b B. Declarations are templates that will eventually be converted to the corresponding local theory operations-that is, they correspond to definitions and theorems inside the locale. -The dependencies deps n, a sequence of pairs of locale names and morphisms.</p><p>Such a pair (m, ϕ) is called locale interpretation. Dependencies model the relationship between locales as given by import and sublocale declarations.</p><p>Parameters and specification are the head of a locale, declarations the body part. Parameters, specification and declarations are also called locale elements. In the sequel, n is generally used instead of lenv n when there is no danger of confusion.</p><p>Occasionally, locales are denoted as 4-tuples where the components appear in the order (parms n, spec n, decls n, deps n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Mapping Locales to Local Theories</head><p>A local theory is obtained from a locale through application of local theory operations, which are generated from the locale elements. For a locale without dependencies this is straightforward. For a locale with dependencies, it involves traversing the graph defined by the locale dependencies. In both cases, this takes place in the presence of some global background theory 0 and the locale environment lenv.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Locales without Dependencies</head><p>The case of a locale without dependencies is considered first. The local theory corresponding to a locale is obtained by initialising a local theory from its parameters and specification and adding the declaration elements. The latter is achieved by means of the activate operator:</p><formula xml:id="formula_11">fun activate (n, ϕ) ctxt = fold (fn abbreviates (c ≡ t) ⇒ abbreviate ϕ(c ≡ t) | notes b B ⇒ note ϕ(b ) ϕ(B)) (decls n) ctxt</formula><p>It folds local theory operations over the sequence of declaration of the locale n. Using this operator, the local theory corresponding to locale n is</p><formula xml:id="formula_12">0 initialize (parms n) (spec n) activate (n, id)</formula><p>The morphism argument ϕ enables to transform declarations before applying them to the local theory. This is required for resolving locales with dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Locales with Dependencies</head><p>If a locale n has the interpretation (m, ϕ) as a dependency this means that the declarations of m, transformed by ϕ, are part of the local theory corresponding to n. For this to be sound, ϕ must map the parameters of the interpreted locale m to terms in the local theory and the specification of m to a theorem of the local theory.</p><p>Since m may have dependencies as well, obtaining the local theory corresponding to n is a recursive process, which traverses the locale dependency graph given by the dependencies of all locales in the locale environment, and computes an enumeration of locale interpretations, all of whose declarations become part of the local theory corresponding to n. It is useful to allow cycles in the locale dependency graphfor example, for situations as in Section 2.2, where the locale partial_order has an interpretation of itself as a dependency. See also Fig. <ref type="figure" target="#fig_0">1</ref>, which shows the locale dependency graph of that example. For obtaining a concrete local theory, the enumeration must be finite.</p><p>The enumeration of locale dependencies is based on the principle that an enumeration of locale interpretations contains at most one interpretation for each locale instance. This avoids duplication of declarations and enables to deal with cycles to a certain extent. A locale instance is a pair of locale name and terms (n, (t 1 , . . . , t k ))</p><p>where k is the number of parameters of n. The locale instance of a locale interpretation (n, ϕ) is (n, (ϕ(x 1 ), . . . , ϕ(x k ))), where x 1 , . . . , x k are the parameters of n. The notion of a locale instance is thus an abstraction of locale interpretation, taking only the effect of the interpretation on the locale parameters into account. <ref type="foot" target="#foot_2">5</ref>A locale instance (n, s) subsumes another instance (n, t) if there is a substitution σ such that σ (s i ) = t i simultaneously for all i. Depending on the logic, subsumption may be modulo an equational theory-for example, modulo α, β and η-conversion in the case of higher-order logic. Lifting subsumption to locale interpretations is straightforward: (n, ϕ) (m, ψ) if n = m and the locale instance of (n, ϕ) subsumes the locale instance of (m, ψ). Subsumption of locale interpretations is a quasi orderthat is, it is reflexive and transitive.</p><p>We are now ready to introduce the roundup algorithm, which is the key to activating locales with dependencies:</p><formula xml:id="formula_13">fun add χ (n, ϕ) (interps, marked) = if ∃(m, ψ) ∈ marked. (m, ψ) (n, χ • ϕ) then (interps, marked) else let val (interps , marked ) = fold (add (χ • ϕ)) (deps n) ([], marked ∪ {(n, χ • ϕ)}) in (interps @ interps @[(n, χ • ϕ)], marked ) end fun roundup activate (n, ϕ) ctxt = let val (interps, _) = add id (n, ϕ) ([], ∅)</formula><p>in fold activate interps ctxt end roundup activate (n, ϕ) recursively processes the locale interpretation (n, ϕ) and its dependencies. It computes the enumeration of locale interpretations for (n, ϕ) and folds the operation activate over it. The local theory corresponding to locale n with dependencies is defined thus:</p><formula xml:id="formula_14">0 initialize (parms n) (spec n) roundup activate (n, id)</formula><p>The roundup operator traverses the locale dependency graph depth-first. It is important to note that the depth-first search is not on locales but on the graph of locale instances induced by the locale dependency graph reachable from the initial instance (n, (ϕ(x 1 ), . . . , ϕ(x k ))).</p><p>The function add performs the traversal. add χ (n, ϕ) (interps, marked) extends the enumeration interps by all nodes reachable via the morphism χ pointing to the interpretation (n, ϕ). Nodes subsumed by nodes that are already marked and their descendants are skipped to avoid duplicate declarations. The enumeration of interpretations is in post-fix order. Post-fix is necessary so that declarations in the dependencies of a locale are available to the declarations in its body.</p><p>Roundup terminates if the locale dependency graph is acyclic. It also terminates if every path eventually reaches a locale instance that is subsumed by an instance earlier on the path.</p><p>Roundup omits instances that are subsumed by instances occurring earlier in the enumeration. Instances subsumed by later instances are not removed, because there might already be instances in the enumeration whose declarations depend on such an instance. This leads to redundancy in enumerations if a specific interpretation of a locale is declared first and later a more general interpretation of the same locale is added. 6   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">User-Level Operations</head><p>Most user-level operations of locales were encountered in Section 2. They are: locale declaration, entering the context of a locale, adding theorems, definitions and syntax abbreviations to a locale, introducing new locale dependencies and interpreting locales in the background theory. In addition to these, locales may also be interpreted in Isar proof contexts. The operations are now explained in terms of locales and local theories. They operate on a global state consisting of the background theory</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Locale Declaration</head><p>A locale declaration consists of an import expression, parameter declarations and assumptions. The general form of a locale declaration is this:</p><formula xml:id="formula_15">locale n = q 1 : n 1 t 1 + . . . + q k : n k t k for x + fixes y + assumes a 1 : A 1 , . . . , a j : A j</formula><p>It adds a new locale named n, where x and y are the parameters, q 1 : n 1 t 1 + . . . + q k : n k t k for x is the imported expression, and A 1 , . . . , A j are the assumptions. Each q i : n i t i denotes a locale instance (n i , t i ) with qualifier q i . The a i are the names of the assumptions. Of the parameters, the x may occur in the imported expression and both x and y may occur in the assumptions. The latter are versions of the user input where free variables except parameters are universally closed.</p><p>The specification of the locale is combined from the import expression and the assumptions. Let x i = parms n i be the parameters of locale n i . Instantiation and qualification are described by the instantiation morphism</p><formula xml:id="formula_16">σ i = inst(t i /x i ) • qual(q i ).</formula><p>Let B i = spec n i be the specification of locale n i . The specification of the new locale involves the locale predicate</p><formula xml:id="formula_17">P n x y ≡ σ 1 (B 1 ) ∧ . . . ∧ σ k (B k ) ∧ A 1 ∧ . . . ∧ A j</formula><p>and is A ≡ P n x y.</p><p>By definition the specification A of n implies the specification σ i (B i ) for each locale instance (n i , t i ). This enables to lift theorems from the instance to the new locale via the interpretation morphism</p><formula xml:id="formula_18">τ i = intp(A σ i (B i )).</formula><p>The locale predicate is added to the background theory-that is, 0 becomes</p><formula xml:id="formula_19">0 def P n x y ≡ σ 1 (B 1 ) ∧ . . . ∧ σ k (B k ) ∧ A 1 ∧ . . . ∧ A j .</formula><p>The locale environment is extended such that</p><formula xml:id="formula_20">lenv n = ([x, y], A, [notes a 1 (A A 1 ), . . . , notes a j (A A j )], [(n 1 , τ 1 • σ 1 ), . . . , (n k , τ k • σ k )]).</formula><p>Example The declaration of locale partial_order in Section 2.1 defines the locale predicate partial_order by extending the background theory via def partial_order S le ≡</p><p>x. x ∈ S =⇒ le x x ∧ . . . holds. The locale has no import and consequently no dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Working in the Context of a Locale</head><p>The context command enables to access a locale. It is followed by a block of declarations, which form the body:</p><formula xml:id="formula_21">context n begin . . . end</formula><p>In the scope of the body, a current local theory 1 is maintained. Initially it is the local theory corresponding to n:</p><formula xml:id="formula_22">0 initialize (parms n) (spec n) roundup activate (n, id).</formula><p>Declarations in the body update the current local theory and add declarations to the locale. When leaving the scope of the context command, the current theory is discarded, but it can be recreated from the declarations stored in the locale when entering the locale for the next time.</p><p>The commands that are available in the body of the context command are syntax abbreviation, theorem declaration and definition: The first two are straightforward, for they correspond directly to local theory operations and locale declarations. For the syntax abbreviation command the current local theory is updated via abbreviate c t, and the declaration abbreviates c t is added to the declarations of the locale n. Likewise, for a theorem declaration the current local theory is extended by note b (A B) and the declaration that is added to the locale is notes b (A B).</p><p>Definition is more complicated, for it involves defining a foundational constant in the background theory. Let x be the parameters of the locale n and A its specification. The foundational constant is n.c, and its definition is that of c lifted over the parameters of the locale. That is, the background theory is replaced by this:</p><formula xml:id="formula_23">0 def n.c x ≡ t</formula><p>The definition is also made in the underlying theory of the current local theory, which is then extended by the foundational constant.</p><formula xml:id="formula_24">1 promote (def n.c x ≡ t) abbreviate c (n.c x) note c_def (A c ≡ t)</formula><p>This becomes the new current local theory.</p><p>To persist the change, the declarations abbreviates c (n.c x) and notes c_def (A c ≡ t) are added to the locale.</p><p>Examples Further declarations from Section 2.1 can now be explained. 2. The locale semilattice extends partial_order. This is reflected in the definition of the locale predicate, which is based on the locale predicate of the extended locale.</p><p>def semilattice S le</p><formula xml:id="formula_25">≡ partial_order S le ∧ x y. x ∈ S ∧ y ∈ S =⇒ ∃inf . is_inf x y inf</formula><p>The locale environment entry only contains declarations related to semilattices:</p><formula xml:id="formula_26">lenv semilattice = ([S, le], semilattice S le, [notes existence x y. x ∈ S ∧ y ∈ S =⇒ ∃inf . is_inf x y inf ],</formula><p>[(partial_order, intp(semilattice S le partial_order S le))])</p><p>Import of partial_order is reflected in the dependency. It incorporates declarations from partial_order, lifting them to the context of semilattices via the interpretation morphism intp(semilattice S le partial_order S le).</p><p>Enumeration of interpretations for (semilattice, id) via the roundup algorithm yields a sequence with two elements:</p><p>(partial_order, intp(semilattice S le partial_order S le))</p><p>(semilattice, id)</p><p>The local theory corresponding to this sequence of interpretations is obtained by applying the morphisms to the declarations of the locales, which lifts them to the context of semilattice: Declarations for antisymmetry and transitivity have again been indicated by dots.</p><formula xml:id="formula_27">0 initialize [S,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Sublocale Declaration</head><p>Theory interpretation relations between locales are established with the sublocale command.</p><p>sublocale n ⊆ q 1 : n 1 t 1 + . . . + q k : n k t k where s ≡ u proof</p><p>This extends the target locale n with interpretations of the locale instances (n i , t i ).</p><p>Equations of the optional rewrite clauses, identified by the keyword where after the locale instances, enable to specify more elaborate mappings from the languages of the locale instances to the target locale than what is possible through instantiation. This is intended for (but not restricted to) mapping derived operations to suitable concepts in the target locale as illustrated in Section 2.4. Let x i again be the parameters of n i and A i the specification. Let A be the specification of n. The instantiation morphisms of the locale instances are</p><formula xml:id="formula_28">σ i = inst(t i /x i ) • qual(q i ).</formula><p>Interpretation is based on these theorems:</p><formula xml:id="formula_29">A σ (A 1 ), . . . , A σ (A k ) A s 1 ≡ u 1 , .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. . , A s j ≡ u j</head><p>To simplify establishing them, the local theory corresponding to n is provided when presenting the proof obligations. Proofs are provided by the user. The first set of theorems gives rise to the interpretation morphisms</p><formula xml:id="formula_30">τ i = intp(A σ i (A i )),</formula><p>the second set to the rewrite morphism υ:</p><formula xml:id="formula_31">υ i = rewr(A s i ≡ u i ) υ = υ j • . . . • υ 1</formula><p>Finally, the locale environment is changed at n by adding the interpretations (n i , υ • τ i • σ i ) for i = 1, . . . , k after the existing dependencies.</p><p>Examples We are now ready to explain the sublocale declarations from Section 2.</p><p>1. The sublocale declaration at the beginning of Section 2.2, sublocale partial_order ⊆ dual: partial_order "S" "λx y. y</p><p>x"</p><p>extends contexts generated from the locale partial_order by facts for the dual partial order induced by λx y. le y x. This is achieved by adding a dependency on itself to the locale partial_order. First, duality needs to be established. This proof obligation is generated, and a proof supplied by the user:</p><p>partial_order S le partial_order S (λx y. le y x)</p><p>Based on the theorem, the locale is extended by a dependency, which is an interpretation that also takes care of qualification and instantiation of the order relation by its dual: </p><formula xml:id="formula_32">lenv partial_order = ([S,</formula><formula xml:id="formula_33">G op = (λK ∈ G . λL ∈ G . K ∩ L) group G mult one inv semilattice.meet G (λK L.L K) = (λK ∈ G .λL ∈ G . K ∪ L )</formula><p>The notations sub.meet and sub.dual.meet are unfolded to semilattice.meet G op and semilattice.meet G (λK L. L K) respectively in the obligations. <ref type="foot" target="#foot_4">7</ref> After discharging the proof obligations, the locale group is extended by a dependency to lattice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Interpretation</head><p>These commands interpret locales in global theories and Isar proof contexts, respectively:</p><p>interpretation q 1 : n 1 t 1 + . . . + q k : n k t k where s ≡ u proof interpret q 1 : n 1 t 1 + . . . + q k : n k t k where s ≡ u proof They are discussed in detail in an earlier publication on locales <ref type="bibr" target="#b3">[4]</ref>. Interpretations for all given locale instances, and for all locale instances reachable from these by the roundup algorithm, are added immediately to the global theory or proof context. Equations refine the interpretations as in the sublocale command. The interpreted instances are tracked (they correspond to marked instances in roundup), and interpretations subsumed by earlier interpretations, possibly from previous interpretation commands, are skipped. Tracking of interpreted instances enables providing two additional services in global theories: whenever a declaration is added to a locale, it is propagated to the global theory for all instances of that locale in the global theory; likewise, whenever a dependency is added to a locale, interpretations of locale instances newly entailed by existing instances are added to the global theory. In this way, global theories "subscribe" to locales via interpretations like locales do to locales via sublocale declarations.</p><p>Such facilities are not provided for interpretation in proof contexts: these disappear after closing, and the Isar proof language does not permit extending locales from within the body of a proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Other Theory Module Structuring Mechanisms</head><p>Locales employ interpretation as the main means of reuse. This, and the high amount of automation obscure how locales are related to more commonly known structuring mechanisms. In this section, relations to ML-style modules, type classes and also mixin modules, the latter of which are found in modern object-oriented languages, are studied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">ML-Style Module Systems</head><p>The module system of the programming language ML (actually, Standard ML <ref type="bibr" target="#b15">[16]</ref>) is a well-understood means for structuring software developments. Locales enable modular development of formal theories. Both languages are different, nonetheless modularity provided by locales can be explained with notions borrowed from ML modules.</p><p>In ML a module consists of component bindings, which represent data fields and code. A signature consists of component declarations, which merely assert the component's types. A module m is said to implement a signature I, written m : I, if for every declaration in I there is a binding in m, and each bound value in m is of the type given in the corresponding declaration. This arrangement enables a programmer to code against a module without having it available. The signature is sufficient.</p><p>The situation is analogous in formal theory developments, where if the components bindings of modules contain proofs and the component declarations of signatures contain the theorem statements, knowing the signature of an imported theory module is sufficient to use its theorems when providing new proofs.</p><p>For explaining locales, this idea is now elaborated. The notation for ML-style modules from Harper and Pierce <ref type="bibr" target="#b11">[12]</ref> is modified to accommodate theorems and proofs. A formal development P consists of module and signature bindings: Rather than denoting proofs explicitly, we write t for a proof of the theorem t.</p><p>Of signatures only the basic ones are required:</p><formula xml:id="formula_34">I :: = sig CD + CD :: = val x | abbrev y = t | thm X : t | module m = M</formula><p>The component declaration syntax of signatures corresponds to the component binding syntax of modules. The notation thm X : t says that X will be bound to a proof of t.</p><p>In terminology of modules and signatures, a locale is a functor that maps a parameter module, consisting of several value bindings and a theorem binding, to a module, which extends the parameter module by abbreviation bindings and (typically many) additional theorem bindings. Developing this connection formally is beyond the scope of this discussion, but we will illustrate key points in a series of examples, which are taken from the previous sections.</p><p>The locale created in the initial declaration of the locale partial_order in Section The body functor contains no value bindings, these have moved to the dependency functor, which imports the body functor. When adding a dependency to a locale, this amounts to extending the dependency functor by import declarations or module bindings of applications of body functors of locales as enumerated by roundup. To illustrate this, we consider adding the dependency of its dual to the locale partial_order. The dependency functor changes to this: A second instance of po_body is applied to the partial order obtained by inverting the order relation. The resulting submodule is bound to the module variable dual in order to achieve qualification of identifiers. Within the dependency functor the "wiring" of parameters of the body functors takes place. Notably, while both applications of po_body share the parameter S, one application is to the order relation le, the other to its inverse λx y. le y x. The theorem partial_order in the functor argument of the module binding dual is derived from the incoming theorem po.partial_order via the theorem provided in the dependency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Type Classes</head><p>Isabelle's type classes are an adaption of Haskell-style type classes to the type system of Gordon's HOL prover. They replace the plain Hindley-Milner polymorphism of the latter by an order-sorted polymorphism where the sorts are finite sets of classes.</p><p>Nipkow <ref type="bibr" target="#b16">[17]</ref> discusses the idea and Wenzel <ref type="bibr" target="#b23">[24]</ref> shows how the integration with the logic can be done in a sound manner.</p><p>A class represents the set of types for which certain operation symbols are available (systematic overloading as in Haskell) and for which certain axioms hold. Classes are ordered and the overloaded operations and axioms of a superclass are available in each of its subclasses. A sort denotes the set of types present in each of the contained classes. The order on classes ⊆ induces an order on sorts . Both are reflexive and transitive.</p><p>Instantiation of classes is available in two flavours: arity declarations of type constructors and class inclusion. An arity declaration tc :: (s 1 , . . . , s n ) c means that the type constructor tc applied to types of sorts s 1 , . . . , s n yields a type of class c. Class inclusion c ⊆ c means that all types in c also belong to c. Arities and class inclusion must be established formally. That is, proofs that the axioms of class c are fulfilled need to be supplied in both cases.</p><p>Both forms of instantiation can be expressed in the framework of locales through interpretation. To illustrate this, here is a formalisation of partial orders and semilattices with type classes:<ref type="foot" target="#foot_6">9</ref> axclass order_syntax ⊆ type consts le :: "'a::order_syntax ⇒ 'a ⇒ bool" (infixl " " 50)</p><formula xml:id="formula_35">axclass partial_order ⊆ order_syntax refl: "x x" antisym: "[[ x y; y x ]] =⇒ x = y" trans: "[[ x y; y z ]] =⇒ x z" definition is_inf where "is_inf x y w ←→ w x ∧ w y ∧ (∀ z. z x ∧ z y -→ z w)"</formula><p>The class partial_order is declared in two steps: order_syntax extends the class type of all types. At this level the overloaded operation le is introduced. The class is then extended with axioms, obtaining partial_order. The predicate is_inf is, by type inference, also associated to order_syntax. A class for (lower) semilattices is obtained by a further extension: axclass semilattice ⊆ partial_order existence: "∃ inf. is_inf x y inf" definition meet (infixl " " 70) where "op = (λx y. THE inf. is_inf x y inf)"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Class Inclusion</head><p>A natural example for class inclusion through instantiation are total orders, which are partial orders that fulfill an additional axiom: axclass total_order ⊆ partial_order total: "x y ∨ y x"</p><p>On the other hand, they are lattices, and the class hierarchy can be changed by adding a class inclusion relation with an instance declaration:</p><formula xml:id="formula_36">instance total_order ⊆ semilattice proof</formula><p>The formalisation with locales is analogous. The locale for total orders is obtained by extending the locale partial_order from Section 2, and the inclusion is established with a sublocale declaration: locale total_order = partial_order "S" "le"for S and le(infixl " " 50)+ assumes total: "[[x ∈ S; y ∈ S]] =⇒ x y ∨ y x" sublocale total_order ⊆ lattice "S" "le" proof</p><p>Since the second argument of the sublocale command is an expression, lattices other than the order relation le could be interpreted as well. This is not possible with class inclusion, where the second argument is only a class name.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Type Instantiation</head><p>There are two ways of translating type instantiation to locales, and which one is applicable depends on the arity of the type constructor. For type constructors without parameters-that is, for primitive types-instantiation is achieved through interpretation in the background theory. For type constructors with parameters, the interpretation is relative to a locale. The first example involves the primitive type nat of natural numbers, which is totally ordered by magnitude. Like declaration, type instantiation of classes proceeds in two steps: instance nat :: order_syntax makes the operation le available for nat. It can then be defined (using a variant of the definition command with reduced syntactic checks):</p><formula xml:id="formula_37">defs (overloaded) le_nat_def: "(m::nat) n ≡ m ≤ n"</formula><p>Finally, the validity of the instance is shown, using facts of the natural numbers.</p><p>instance nat :: total_order proof</p><p>The corresponding construction is achieved in locales via an interpretation in the background theory: interpretation nat: total_order "UNIV::nat set" "op ≤" proof An instantiation of a type constructor with parameters requires a locale that represents the sorts of the type parameters. For example, the order on pairs can be defined based on the orders of the left and right components. First, again the formalisation with type classes. Let " * " be the type constructor for pairs. The first instance declaration makes the syntax available for pairs: instance * :: (order_syntax, order_syntax) order_syntax There are several ways of defining an order relation on pairs. We choose the lexicographic order: defs (overloaded) le_pair_def: "x y ≡ if fst x = fst y then fst x fst y else snd x snd y"</p><p>This order is partial if the orders on the left and right components are partial. It is total, if the orders on the components are total. Such a mapping of one class hierarchy to another is common, and it can be expressed through two instance declarations.</p><p>instance * :: (partial_order, partial_order) partial_order proof instance * :: (total_order, total_order) total_order proof Representing these instantiations in locales requires a target locale per arity. In the first instantiation both parameters are partial orders: locale pair_partial_order = left: partial_order "S 1 " "le 1 " + right: partial_order "S 2 " "le 2 "for S 1 and le 1 (infixl " 1 " 50) and S 2 and le 2 (infixl " 2 " 50) begin definition le_lex (infixl " lex " 50) where "x lex y ←→ (if fst x = fst y then fst x 1 fst y else snd x 2 snd y)" end</p><p>The definition of the combined order relation op lex takes place in the target locale, and the dependency is introduced with this sublocale declaration: sublocale pair_partial_order ⊆ lex:</p><p>partial_order "S 1 × S 2 " "op lex " proof</p><p>In the target locale for the second instantiation both order relations are total orders: locale pair_total_order = left: total_order "S 1 " "le 1 " + right: total_order "S 2 " "le 2 " for S 1 and le 1 (infixl " 1 " 50) and S 2 and le 2 (infixl " 2 " 50)</p><p>This is a special case of the previous target locale, and so the definition and theorems can be carried over from pair_partial_order and, by transitivity of the dependency relation, from its dependencies with a first sublocale declaration: sublocale pair_total_order ⊆ pair_ partial_order "S 1 " "le 1 " "S 2 " "le 2 " proof The interpretation representing the instantiation follows:</p><p>sublocale pair_total_order ⊆ lex: total_order "S 1 × S 2 " "op lex " proof</p><p>The resulting locale dependencies are shown in Fig. <ref type="figure" target="#fig_7">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Comparison</head><p>As a mechanism for structuring theory modules, type classes are relatively weak.</p><p>The type system does not provide dependent types, and in some systems, including Isabelle, a class is restricted to a single type parameter. Locales do not have these shortcomings. On the other hand, classes provide more automation. A deeper comparison is possible by observing that in terms of a functorial module system type classes are the signatures and instance declarations are the functors. See also Harper and Pierce <ref type="bibr" target="#b11">[12]</ref>, who discuss this relationship for Haskell's type classes. The order-sorted polymorphism of Isabelle's type classes admits principal types and therefore sort information can be computed by type inference. This means that functor applications are computed "on the fly" when automatic tools such as Isabelle's rewrite engine (commonly known as the simplif ier) are active.</p><p>Locales compute functor applications by resolving locale dependencies with the roundup algorithm. Since this is only executed when entering a context target, locales are required that serve as working contexts. Target locales express specification situations that are the focus of particular mathematical analyses. A type instantiation tc :: (s 1 , . . . , s n ) c can be translated to the language of locales by providing a target locale that imports the locales corresponding to s 1 , . . . , s n and adding c as a dependency by showing that the target locale is a sublocale of c. If there is another type instantiation tc :: (s 1 , . . . , s n ) c of the same type constructor and s 1 s 1 , . . . , s n s n , then it needs to be shown that the target locale of the former type instantiation is a sublocale of the latter. This enriches the working context by information that would be inferred by type classes.</p><p>Type instantiation of primitive types is a special case and dealt with by interpretation in the global background theory. Class inclusion declarations translate directly to sublocale declarations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Beyond Parameter Substitution</head><p>Many module systems have in common that the desired ways of reuse must be anticipated. For example, in the case of a functor, only the parameters can be instantiated when the functor is applied. It is not possible to identify components defined in the body of one functor with components of some other functor. In general, when combining two modules, components of one may need to be identified with components of the other. This is known as the coherence problem <ref type="bibr" target="#b11">[12]</ref>. The diamond problem, where one module is inherited through two different paths in an inheritance diagram, is a special case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Mixin Modules</head><p>In object-oriented programming languages the coherence problem occurs with multiple inheritance. A solution adopted by some languages is to restrict multiple inheritance to classes that do not encapsulate state-that is, without member fields. Coherence is achieved by redefining a method inherited from more than one superclass such that the desired version is called. Usually, one superclass with member fields is allowed. The others are said to be mixed in. This approach is known as mixin modules <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6]</ref>. Terminology varies. For example, in the programming language Scala, classes that are amenable to mixing in with other classes are called traits <ref type="bibr" target="#b18">[19]</ref>.</p><p>The coherence problem also exists when combining mathematical theories. Here, usually some base operations are specified via axioms; other, derived operations are defined in terms of the base operations. A natural representation of such a theory module as a functor puts the base operations in the parameter signature and the derived operations in the functor body. We have done so in the locale examples in Section 2, where the order relation le is a base operation of the partial_order locale and the group operations are base operations of groups. Supremum and infimum and the subgroup relation are derived.</p><p>When transporting the theorems of a theory module to some other context, replacing the base operations only is in general not sufficient. In Section 2.3 the supremum and infimum operations were mapped to set operations that already existed in the background theory. Likewise, in Section 2.4, they were mapped to group operations of the target locale. Locales enable replacing derived operations by means of rewrite morphisms. There is an analogy to redefining a method in a class: in either case the modified component is not a parameter. In other words, the change is not anticipated. The soundness of rewrite morphisms is rooted in the underlying logical system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Equivalent Formalisations</head><p>An important use case of rewrite morphisms, other than the one described above, are equivalent formalisations. Often there is not only one (the canonical) set of base operations for a mathematical theory. For example, while the base operations of groups are usually the binary operation, unit and inverse, the latter two are unique in a semigroup (if they exist) and they can be formalised as derived operations. Gunter <ref type="bibr" target="#b8">[9]</ref> proposed this, presumably because fewer parameters are simpler to manage. A more involved example are lattices, which allow for an alternative set of axioms where supremum and infimum are the base operations. This is elaborated in Fig. <ref type="figure">3</ref>. The top part shows the formalisation based on partial orders (like the Fig. <ref type="figure">3</ref> Two formalisations of lattice example in Section 2, but for conciseness omitting the carrier set). Beneath follows the alternative formalisation. At the bottom, equivalence of the two locales is established formally with two circular sublocale declarations. It is worth noting that roundup terminates both when entering the context of lattice and when entering the context of lattice'. The arrangement achieved with these declarations makes theorems from one formalisation of lattice available in the other and vice versa.</p><p>The roundup algorithm operates on locale instances, which are an abstraction of locale interpretations: if there are two interpretations such that the effect of both their morphisms on the locale parameters is the same, then only one interpretation will be generated (the one that appears first in the enumeration). This means that there cannot be two interpretations that agree on the parameters but map a derived operation, via a rewrite morphism, to different (but equivalent) terms. In such a situation, a possible solution is choosing an alternative formalisation where the operation in question is a parameter. 10   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Locales are a powerful tool for organising mathematical knowledge. They provide commands for declaring locales, entering the context of a locale, extending locales, identifying logical relations between locales and translating the knowledge of a locale to other contexts-in particular, global theories and proof contexts. And, locales can be integrated with local theories, an abstraction of various forms of theories and contexts found in Isabelle, but which are not fundamentally linked to Isabelle or to its logic.</p><p>Locales are organised in a dependency graph that encodes the logical relations between them. A locale is persisted mathematical knowledge that can be "brought to life" by converting it to a local theory, in which reasoning may take place. This is called activation, and relations from the dependency graph are resolved by the roundup algorithm. Activation makes locales dynamic: declarations added to a locale are propagated to all instances automatically. This enables users to provide definitions, theorems and interpretations, including locale dependencies, in an order that is natural for the mathematics that is being formalised.</p><p>Activation is along morphisms. A locale can be activated to its induced local theory via the identity morphism, or, by interpretation, to other target contexts. For interpretation, the image of the specification under the morphism must be derivable in the target context. Interpretation makes locales first-order functors. By tracking interpreted instances, the dynamic flavour of activation is also provided for interpretation in global theories.</p><p>Locale predicates reflect locales, which are by themselves extra-logical, into the logic and enable reasoning about locales. This was used in this paper only in passing, in the definition of the subgroup relation based on the locale closed. Locale predicates can, for example, be used to deal with infinite families of locales. This is demonstrated in detail elsewhere <ref type="bibr" target="#b3">[4]</ref>.</p><p>Locales are partially correct: if roundup terminates then the generated theorems are derivable from the specification. Roundup terminates if the dependency graph is acyclic. It also terminates for important cyclic cases: logically equivalent specifications and operators that are self-dual. <ref type="foot" target="#foot_7">11</ref>Activation is a fairly expensive operation. When a locale is activated, morphisms are applied to all its declarations and to the declarations of all dependencies. Nevertheless, the implementation is efficient enough so that locales have become a mainstay of Isabelle's theory libraries. Morphisms can be applied to declarations that are to be activated in parallel, which enables making use of modern, parallel hardware. Users can improve the performance of theory developments by putting several declarations into the block of a single context command, which avoids unnecessary repetitions of activation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Management of Theory Module Hierarchies</head><p>One can distinguish declared and derived relations between theory modules. Declared relations are given as import in locale declarations, and derived relations are provided with the sublocale command. Both are via morphisms, which enable mapping the language of the source to the language of the target. Internally, both kinds of relations are uniformly implemented through interpretation of locale dependencies.</p><p>Module hierarchies in programming languages are usually trees (or directed acyclic graphs if multiple inheritance is supported) and extension is only possible at the fringe. This can lead to the same concept being developed at several places in a library simultaneously. To avoid this redundancy, the tiny theories method was proposed <ref type="bibr" target="#b6">[7]</ref>. This is a more radical version of the little theories approach, where extensions of theory modules are done by introducing one axiom at a time. This would ensure that in a theory library of, for example, order relations or rings even the more obscure variants of these structures are readily available. While being a great convenience for the user, the tiny theories method can complicate library design, because it requires anticipating all variants.</p><p>Locales enable the library designer to insert a theory module into an existing hierarchy via the sublocale command, a feature that is inspired by Isabelle's type classes. This means that theory modules are not required to be built up incrementally in a per-axiom fashion. Neither need more rarely used variants of theories be anticipated from the beginning, just because they are in the middle of the hierarchy. They may be added when needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Extensibility of Theory Modules</head><p>While locales can be seen as first-order ML-style functors, this does not capture all operational aspects adequately. In particular, bodies of ML functors are not extensible. But this is an important requirement for a module system for mathematical theories. The Coq module system <ref type="bibr" target="#b22">[23]</ref>, which implements a higher-order variant of ML-style functors fairly closely, overcomes this problem by introducing namespaces as an additional layer of abstraction so that bindings from several functors contributing to a theory module can be referred to in a uniform manner. Locales have been designed to be extensible by theorem bindings right away. Extensibility by definitions was introduced with local theories <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Rewrite Morphisms and Coherence</head><p>Locales can be combined by means of locale expressions, either in the import section of a locale declaration, or in an interpretation. Locales can be combined with target contexts through interpretation. In the case of the sublocale command, the target context is again a locale.</p><p>In order to achieve coherence between the combined locales, relations between parameters may be given through parameter instantiations in the expression. In interpretations, including sublocale declarations, additionally value bindings (i.e., definitions) in locale bodies may be changed through rewrite morphisms, which map bound names to terms in the target context of the interpretation. (In principle, locale declarations could also accept rewrite morphisms, but requesting the needed proofs might seem counter-intuitive to users.)</p><p>The need for instantiation as opposed to, for example, renaming, is immediately clear for interpretation. But also in locale declarations instantiation leads to a more expressive system. One may, for example, consider a locale for homomorphisms where one parameter represents the operation of the domain and another parameter the operation of the co-domain. With instantiation, a locale for endomorphisms can be derived easily by setting both parameters to the same operation <ref type="bibr" target="#b4">[5,</ref><ref type="bibr">Section 6.2]</ref>. With renaming this is not possible, since distinct names need to remain distinct.</p><p>The relation of rewrite morphisms to mixin modules of object-oriented programming languages discussed in Section 5.3 is a striking example of how the need for flexible means of reuse in module systems can lead to related solutions in different domains. This was understood by the author only after conceiving rewrite morphisms as a natural extension to interpretation of definitions as they are handled in local theories.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1 Locale dependency graph for the examples in Section 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>For</head><label></label><figDesc>brevity, only reflexivity is shown; antisymmetry and transitivity are indicated by dots. The locale environment is extended such that lenv partial_order = ([S, le], partial_order S le, [notes refl x. x ∈ S =⇒ le x x , notes antisym . . . , notes trans . . .], [])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>abbreviation c where c ≡ t theorem b : B definition c where c ≡ t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 .</head><label>1</label><figDesc>abbreviates is_inf (partial_order.is_inf S le), notes is_inf_def (is_inf x y w ←→ le w x ∧ le w y ∧ . . .)], [])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>P 8 F</head><label>8</label><figDesc>::= B + B ::= module m[: I] = M | signature J = I A module can be a basic module consisting of component bindings, the reference to a module variable (unqualifed or qualifed), a functor, or be obtained by functor application. , M :: = mod CB + | m | M.m | λm : I.M | F(M) CB :: = val x = t | abbrev y = t | thm X = T | module m = M | open M Conceptually, a component binding either binds a value to its definition or it binds a proof. To model local theories more adequately, value bindings, which instantiate parameters, and syntax abbreviations are distinguished. Qualified and unqualified import of modules is also available. Terms include values and values bound in nested modules. Likewise for proofs. t ::= . . . | x | M.x T::= t | X | M.X</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>2.1 corresponds to a functor whose parameter has the signature signature PO = sig { val S val le thm partial_order : partial_order S le } and the functor itself is this: module po_fun = λ po : PO. mod { val S = po.S val le = po.le thm partial_order = po.partial_order thm refl = x. x ∈ S =⇒ le x x thm antisym = . . . thm trans = . . . } Reflexivity, antisymmetry and transitivity are derived from the theorem parameter. In favour of concise notation this is not made explicit here. The definition of is_inf extends the functor to this: module po_fun = λ po : PO. mod { val S = po.S val le = po.le thm partial_order = po.partial_order thm refl = x. x ∈ S =⇒ le x x thm antisym = . . . thm trans = . . . abbrev is_inf = partial_order.is_inf S le thm is_inf_def = is_inf x y w ←→ le w x ∧ le w y ∧ . . . } Composition of locales is achieved through interpretation, either by sublocale declarations, or through interpretations generated from imports in locale declarations. Within locales, interpretations are stored as dependencies, and are resolved by the roundup algorithm. The functor po_fun above models extensibility of the locale partial_order by syntax abbreviations and theorems. In order to model extensibility through dependencies, the functor is split into a body functor, modelling the body part of the locale, and a functor for dependencies: module po_body = λ po : PO. mod { thm partial_order = po.partial_order thm refl = x. x ∈ S =⇒ le x x • • • } module po_deps = λ po : PO. mod { val S = po.S val le = po.le open po_body(po) }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>module po_deps = λ po : PO. mod { val S = po.S val le = po.le module dual = po_body( mod { val S = S val le = (λx y. le y x) thm partial_order = partial_order S le }) open po_body(po) }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Locale dependency graph for the examples in Section 5.2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>The subgroup relation itself is denoted by .</figDesc><table><row><cell cols="2">context group begin</cell></row><row><cell cols="2">definition subgroup (infixl " " 50)</cell></row><row><cell>where "H</cell><cell>K ←→ H ⊆ K ∧ closed H mult one inv"</cell></row><row><cell cols="2">definition groups ("G ")</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>Alternatively, terms and formulas may be distinct syntactic categories. Then all requirements for terms are duplicated for formulas.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>Although the parameters are represented by variables, they may not be instantiated within the local theory itself. That would violate the contract of the specification and prohibit interpretation. In the implementation of local theories in Isabelle parameters are represented by free, not schematic variables.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>It does not matter whether this is achieved through instantiation morphisms, rewrite morphisms or a combination of both.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="0" xml:id="foot_3"><p>and the locale environment lenv. In Isabelle, the locale environment is part of . The background theory is initialised to base, the locale environment is initially empty.<ref type="bibr" target="#b5">6</ref> That might be necessary when "bootstrapping" a development, but in practice it appears to happen rarely.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>These abbreviations are declared in lattice and are only introduced to group by the sublocale declaration. To simplify the notation in where clauses, from Isabelle 2011-1, they are already available when the where clauses are processed.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>The grammar permits higher-order modules, but they will not be used.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_6"><p>Isabelle's type classes are also known as axiomatic type classes. The examples here are deliberately based on the old user interface in Isabelle 2009, because it provides more direct access to the discussed mechanisms than the combination of type classes and locales, called constructive type classes, from later versions. The structures' carrier is not made explicit. This is merely a convenience, not a restriction of type classes.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_7"><p>The latter relies on term equivalence being modulo αβη-conversion in Isabelle. Important other cyclic locale dependencies can be made acyclic by introducing additional logically equivalent locales. For an example, see the tutorial<ref type="bibr" target="#b4">[5]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The first design of locales was inspired by Coq sections <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>. Wenzel integrated locales with the Isar proof language and provided means for constructing locale hierarchies <ref type="bibr" target="#b1">[2]</ref>. Theorem reuse through interpretation and means for changing the locale hierarchy were added by the author <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>. Local theories <ref type="bibr" target="#b10">[11]</ref> considerably helped clarify locales. Without them, the redesign for Isabelle 2009 would not have been possible.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A theory of mixin modules: basic and derived operators</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ancona</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Zucca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Struct. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="401" to="446" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Locales and locale expressions in Isabelle/Isar</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ballarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Types for Proofs and Programs</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Berardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</editor>
		<meeting><address><addrLine>Torino, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003. 2004</date>
			<biblScope unit="volume">3085</biblScope>
			<biblScope unit="page" from="34" to="50" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Interpretation of locales in Isabelle: managing dependencies between locales</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ballarin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. TUM-I0607</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Interpretation of locales in Isabelle: theories and proof contexts</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ballarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Knowledge Management, MKM 2006</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Borwein</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Farmer</surname></persName>
		</editor>
		<meeting><address><addrLine>Wokingham, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4108</biblScope>
			<biblScope unit="page" from="31" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Tutorial to locales and locale interpretation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ballarin</surname></persName>
		</author>
		<editor>Lambán, L., Romero, A., Rubio, J.</editor>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Logroño, Spain</pubPlace>
		</imprint>
	</monogr>
	<note>Also part of the Isabelle user documentation</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The programming language Jigsaw: mixins, modulariy and multiple inheritance</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<idno>UUCS-92-007</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>University of Utah</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Also Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Carette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Farmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jeremic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Maccio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>O'connor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">M</forename><surname>Tran</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1106.1862v1</idno>
		<title level="m">The MathScheme library: some preliminary experiments</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Little theories</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Farmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Guttman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Thayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated deduction, CADE-11: Saratoga Springs</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Kapur</surname></persName>
		</editor>
		<meeting><address><addrLine>NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">607</biblScope>
			<biblScope unit="page" from="567" to="581" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Doing algebra in simple type theory</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Gunter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. MS-CIS-89-38</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Constructive type classes in Isabelle</title>
		<author>
			<persName><forename type="first">F</forename><surname>Haftmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-74464-1_11</idno>
	</analytic>
	<monogr>
		<title level="m">Types for Proofs and Programs</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Altenkirch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Mcbride</surname></persName>
		</editor>
		<meeting><address><addrLine>Nottingham, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006. 2007</date>
			<biblScope unit="volume">4502</biblScope>
			<biblScope unit="page" from="160" to="174" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Local theory specifications in Isabelle/Isar</title>
		<author>
			<persName><forename type="first">F</forename><surname>Haftmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-02444-3_10</idno>
	</analytic>
	<monogr>
		<title level="m">Types for Proofs and Programs</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Berardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>De'liguoro</surname></persName>
		</editor>
		<meeting><address><addrLine>Torino, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008. 2009</date>
			<biblScope unit="volume">5497</biblScope>
			<biblScope unit="page" from="153" to="168" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Design considerations for ML-style module systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Topics in Types and Programming Languages</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</editor>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">AXIOM: The Scientific Computation System</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Jenks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sutor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Modular reasoning in Isabelle</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kammüller</surname></persName>
		</author>
		<idno>No. 470</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>University of Cambridge, Computer Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Also Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Locales: a sectioning concept for Isabelle</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kammüller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theorem Proving in Higher Order Logics: TPHOLs&apos;99</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Bertot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Dowek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Hirschowitz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Paulin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Théry</surname></persName>
		</editor>
		<meeting><address><addrLine>Nice, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1690</biblScope>
			<biblScope unit="page" from="149" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tofte</surname></persName>
		</author>
		<title level="m">Commentary on Standard ML</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Order-sorted polymorphism in Isabelle</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logical Environments</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="164" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Verified efficient enumeration of plane graphs modulo isomorphism</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive Theorem Proving (ITP 2011)</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Van Eekelen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Geuvers</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Schmaltz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Wiedijk</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6898</biblScope>
			<biblScope unit="page" from="281" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An overview of the Scala programming language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Altherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cremet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Emir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maneth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micheloud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mihaylov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stenman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zenger</surname></persName>
		</author>
		<idno>IC/2004/64</idno>
	</analytic>
	<monogr>
		<title level="j">École Polytechnique Fédérale de Lausanne</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<ptr target="http://docs.oracle.com/javase/6/docs/api/" />
		<title level="m">Java platform, standard edition 6 API specification</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The reflection theorem: a study in meta-theoretic reasoning</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Deduction-CADE-18 International Conference</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2392</biblScope>
			<biblScope unit="page" from="377" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">State spaces-the locale way</title>
		<author>
			<persName><forename type="first">N</forename><surname>Schirmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electr. Notes Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">254</biblScope>
			<biblScope unit="page" from="161" to="179" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Modular development of theories and name-space management for the Coq proof assistant</title>
		<author>
			<persName><forename type="first">E</forename><surname>Soubiran</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>École Polytechnique</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Type classes and overloading in higher-order logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
		<idno type="DOI">{10.1007/BFb0028402}</idno>
	</analytic>
	<monogr>
		<title level="m">Theorem Proving in Higher Order Logics</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1275</biblScope>
			<biblScope unit="page" from="307" to="322" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
