<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Hespanha</surname></persName>
							<email>hespanha@ece.ucsb.edu</email>
						</author>
						<author>
							<persName><forename type="first">C</forename><surname>Lim</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Delaware</orgName>
								<address>
									<postCode>19716</postCode>
									<settlement>Newark</settlement>
									<region>DE</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical and Computer Engi-neering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>93106</postCode>
									<settlement>Santa Barbara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Sookmyung Women&apos;s University</orgName>
								<address>
									<postCode>140-742</postCode>
									<settlement>Seoul</settlement>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Southern California</orgName>
								<address>
									<postCode>90089</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>95064</postCode>
									<settlement>Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9741F51E21DBCAA14F44145CDDC3D11D</idno>
					<idno type="DOI">10.1109/TNET.2006.873366</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:00+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A New TCP for Persistent Packet Reordering</head><p>Stephan Bohacek, Member, IEEE, Jo√£o P. Hespanha, Senior Member, IEEE, Junsoo Lee, Chansook Lim, Student Member, IEEE, and Katia Obraczka, Member, IEEE Abstract-Most standard implementations of TCP perform poorly when packets are reordered. In this paper, we propose a new version of TCP that maintains high throughput when reordering occurs and yet, when packet reordering does not occur, is friendly to other versions of TCP. The proposed TCP variant, or TCP-PR, does not rely on duplicate acknowledgments to detect a packet loss. Instead, timers are maintained to keep track of how long ago a packet was transmitted. In case the corresponding acknowledgment has not yet arrived and the elapsed time since the packet was sent is larger than a given threshold, the packet is assumed lost. Because TCP-PR does not rely on duplicate acknowledgments, packet reordering (including out-or-order acknowledgments) has no effect on TCP-PR's performance.</p><p>Through extensive simulations, we show that TCP-PR performs consistently better than existing mechanisms that try to make TCP more robust to packet reordering. In the case that packets are not reordered, we verify that TCP-PR maintains the same throughput as typical implementations of TCP (specifically, TCP-SACK) and shares network resources fairly. Furthermore, TCP-PR only requires changes to the TCP sender side making it easier to deploy. Index Terms-Congestion control, packet reordering, transport protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>T HE design of TCP's error and congestion control mech- anisms was based on the premise that packet loss is an indication of network congestion. Therefore, upon detecting loss, the TCP sender backs off its transmission rate by decreasing its congestion window. TCP uses two strategies for detecting packet loss. The first one is based on the sender's retransmission timeout (RTO) expiring and is sometimes referred to as coarse timeout. When the sender times out, congestion control responds by causing the sender to enter slow-start, drastically decreasing its congestion window to one segment. The other loss detection mechanism originates at the receiver and uses TCP's sequence number. Essentially, the receiver observes the sequence numbers of packets it receives; a "hole" in the sequence is considered indicative of a packet loss. Specifically, the receiver generates a "duplicate acknowledgment" (or DU-PACK) for every "out-of-order" segment it receives. Note that until the lost packet is received, all other packets with higher sequence number are considered "out-of-order" and will cause DUPACKs to be generated. Modern TCP implementations adopt the fast retransmit algorithm which infers that a packet has been lost after the sender receives a few DUPACKs. The sender then retransmits the lost packet without waiting for a timeout and reduces its congestion window in half. The basic idea behind fast retransmit is to improve TCP's throughput by avoiding the sender to timeout (which results in slow-start and consequently the shutting down of the congestion window to one).</p><p>Fast retransmit can substantially improve TCP's performance in the presence of sporadic reordering but it still operates under the assumption that out-of-order packets indicate packet loss and therefore congestion. Consequently, its performance degrades considerably in the presence of "persistent reordering." This is the case for reordering of both data and acknowledgment packets. Indeed, it is well known that TCP performs poorly under significant packet reordering (which may not be necessarily caused by packet losses) <ref type="bibr" target="#b0">[1]</ref>.</p><p>Packet reordering is generally attributed to transient conditions, pathological behavior, and erroneous implementations. For example, oscillations or "route flaps" among routes with different round-trip times (RTTs) are a common cause for out-oforder packets observed in the Internet today <ref type="bibr" target="#b1">[2]</ref>. Internet experiments performed through MAE-East and reported in <ref type="bibr" target="#b2">[3]</ref> show that 90% of all connections tested experience packet reordering. Researchers at SLAC performed similar experiments and found that 25% of the connections monitored reordered packets <ref type="bibr" target="#b3">[4]</ref>. However, networks with radically different characteristics (when compared to the Internet, for example) can exhibit packet reordering as a result of their normal operation. This is the case of wireless networks, in particular multi-hop mobile ad-hoc networks (MANETs). In MANETs, which are also known as "networks without a network," there is no fixed infrastructure and every node can be source, sink, as well as forwarder of traffic. The potential for unconstrained mobility poses many challenges to routing protocols including frequent topology changes. Thus MANET routing protocols need to recompute routes often, which may lead to (persistent) packet reordering. In fact, improving the performance of TCP in such environments (by trying to differentiate out-of-order packets from congestion losses) has been the subject of several recent research efforts <ref type="bibr" target="#b4">[5]</ref>- <ref type="bibr" target="#b6">[7]</ref>.</p><p>Mechanisms that provide different quality of service (QoS) by differentiating traffic may introduce packet reordering. An example of such mechanisms is DiffServ <ref type="bibr" target="#b7">[8]</ref>, which has been proposed to provide different QoS on the Internet. In the case of Expedited Forwarding, packets receive preferential treatment as long as the flow obeys negotiated bandwidth constraints. If the flow exceeds these constraints, the nonconformant packets are typically dropped. However, an alternative to dropping these packets is to lower their priority. In this case, the packets will be placed in different queues and will likely experience different latency, resulting in out-of-order delivery to the final destination. While this alternative is atypical, RFC 3246 simply specifies that packets should not be reordered, a weaker requirement than must not be reordered <ref type="bibr" target="#b37">[38]</ref>.</p><p>While packet reordering is often considered to be pathological in today's Internet, as shown in <ref type="bibr" target="#b2">[3]</ref>, it is actually part of normal operation for a number of routers containing parallel paths through the switch. Due to the scheduling algorithms used, different packet sizes and arrivals times may result in the reordering of packets entering on a single interface. While the exact cause of packet reordering lies in the details of the scheduling algorithm, a more general reason is that parallel paths are employed for economic reasons; it is cheaper to build multiple moderate speed paths than a single very high-speed path. The result of seeking this increase in cost efficiency is that packets may sometimes be reordered. TCP-PR is a transport protocol compatible with multipath routing, hence it will not limit the drive for efficiency at the lower layers.</p><p>Beyond router design, there are other areas that stand to gain efficiency if multiple paths are permitted. For example, load balancing is greatly simplified if single flows are permitted to use different paths. When a flow is restricted to use a single path, then optimal load balancing reduces to an NP-hard integer programming problem (cf. <ref type="bibr">[9, p. 359]</ref>) but if the single path restriction is lifted, then optimal load balancing is a simpler linear programming problem. In <ref type="bibr" target="#b9">[10]</ref>, different flows may be split along multiple paths in order to meet QoS requirements. Permitting even single flows to be split results in a more efficient use of network resources. In the case of MANETs, spreading packets across different links also decreases the battery drain on any particular mobile node and may increase the lifetime of the network.</p><p>While efficiency is one area that may benefit from multipath routing, fault tolerance and security can also be improved by utilizing multiple paths. For example, in wired networks, multipath routing has been shown to reduce the impact of link failures <ref type="bibr" target="#b10">[11]</ref>. Similarly, multipath routing can increase robustness to eavesdropping by spreading packets across different paths, thus forcing the attacker to sniff multiple links <ref type="bibr" target="#b10">[11]</ref>. Multipath routing can take advantage of the considerable path redundancy that already exists in today's Internet. For example, in <ref type="bibr" target="#b11">[12]</ref>, it was shown that in the U.S. Sprintlink topology, 90% of PoP pairs are connected through at least four distinct paths.</p><p>In MANETs, alternate path routing has been an active area of research. In <ref type="bibr" target="#b12">[13]</ref>, it is suggested that alternate paths be found and stored in an attempt to anticipate failures in the primary path. However, it was shown in <ref type="bibr" target="#b13">[14]</ref> that alternate paths may grow stale and no longer exist when the primary path fails. One way to learn that alternate paths have failed is to send part of the data stream along them, as in multipath routing.</p><p>While multipath routing has many advantages, it leads to persistent packet reordering. Today's implementations of TCP are not compatible with networks that reorder packets and suffer great reductions in throughput when faced with persistent packet reordering. TCP's incompatibility with persistent packet reordering has been a major deterrent to the deployment of the mechanisms mentioned above on the Internet or on other networks in which TCP is prevalent. There are a number of methods for improving TCP's performance in packet-reordering prone environments, but most of them try to recover from occasional reordering and rely on the packet ordering itself to detect drops. However, under persistent reordering conditions, packet ordering conveys very little information on what is actually happening inside the network.</p><p>In this paper, we describe TCP-PR, a transport protocol that performs well under persistent packet reordering (Section III).</p><p>The key feature of TCP-PR is that duplicate ACKs are not used as an indication of packet loss. Rather, TCP-PR relies exclusively on timeout. Both worst-case analysis and Internet traces are used to ensure that the timeout threshold is not too small and only actual packet losses cause retransmissions (Section IV). Through extensive ns-2 simulations, we evaluate the performance of TCP-PR, comparing it to a number of existing schemes that address TCP's poor performance under packet reordering (Section VI). We find that under persistent packet reordering, TCP-PR achieves significantly higher throughput. We also test TCP-PR's compatibility and fairness to standard TCP variants, specifically TCP-SACK (Section V). In the absence of packet reordering, TCP-PR is shown to have similar performance and competes fairly with TCP-SACK. TCP-PR neither requires changes to the TCP receiver nor uses any special TCP header option. Hence, TCP-PR is suitable for incremental deployment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>As previously mentioned, several mechanisms that address TCP's lack of robustness to packet reordering have been recently proposed. This section summarizes them and puts TCP-PR in perspective.</p><p>Upon detecting spurious retransmissions, the Eifel algorithm <ref type="bibr" target="#b14">[15]</ref> restores TCP's congestion control state to its value prior to when the retransmission happened. The more spurious retransmissions of the same packet are detected, the more conservative the sender gets. For spurious retransmission detection, Eifel uses TCP's timestamp option and has the sender timestamp every packet sent. The receiver echoes back the timestamp in the corresponding acknowledgment (ACK) packets so that the sender can differentiate among ACKs generated in response to the original transmission as well as retransmissions of the same packet. <ref type="foot" target="#foot_0">1</ref>DSACK <ref type="bibr" target="#b15">[16]</ref> proposes another receiver-based mechanism for detecting spurious retransmission. Information from the receiver to the sender is carried as an option (the DSACK option) in the TCP header. The original DSACK proposal does not specify how the TCP sender should respond to DSACK notifications. In <ref type="bibr" target="#b0">[1]</ref>, a number of responses to DSACK notifications were proposed. The simplest one relies on restoring the sender's congestion window to its value prior to the spurious retransmission detected through DSACK. <ref type="foot" target="#foot_1">2</ref> Besides recovering the congestion state prior to the spurious retransmission, other proposed strategies also adjust the DUPACK threshold (dupthresh). The different dupthresh adjustment mechanisms proposed include: 1) increment dupthresh by a constant; 2) set the new value of dupthresh to the average of the current dupthresh and the number of DUPACKs that caused the spurious retransmission; and 3) set dupthresh to an exponentially weighted moving average of the number of DUPACKs received at the sender. Recently, another scheme that relies on adjusting the dupthresh has been proposed <ref type="bibr" target="#b16">[17]</ref>.</p><p>Time-delayed fast-recovery (TD-FR), which was first proposed in <ref type="bibr" target="#b17">[18]</ref> and analyzed in <ref type="bibr" target="#b0">[1]</ref>, addresses packet reordering. This method stands out from the others in that it utilizes timers as well as DUPACKs. It sets a timer when the first DUPACK is observed. If DUPACKs persists longer than a threshold, then fast retransmit is entered and the congestion window is reduced. The timer threshold is set to , where is the difference between the arrival of the first and third DUPACK.</p><p>A number of mechanisms to improve TCP's performance in MANET environments have been proposed. For example, TCP-DOOR <ref type="bibr" target="#b4">[5]</ref> detects out-of-order packets by using additional sequence numbers (carried as TCP header options). To detect out-of-order data packets, the TCP sender uses a 2-byte TCP header option called TCP packet sequence number to count every data packet including retransmissions. For out-of-order DUPACK detection, the TCP receiver uses a 1-byte header option to record the sequence in which DUPACKs are generated. Upon detecting out-of-order packets (internally or informed by the receiver<ref type="foot" target="#foot_2">3</ref> ), the TCP sender responds by either: (1) temporarily disabling congestion control for a given time interval (i.e., freezing the congestion control state, which includes the congestion window and the retransmission timer ), or (2) resetting the state to its value prior entering congestion avoidance. More recently, TCP-DCR <ref type="bibr" target="#b18">[19]</ref>, another variant of TCP for wireless networks, has been developed. Similarly to TD-FR, TCP-DCR delays response to DUPACKs. However, the delay of one RTT imposed by TCP-DCR is longer than that of TD-FR.</p><p>To some extent, the approaches described above still utilize packet ordering to detect drops. Indeed, when reordering is not persistent, packet ordering is still somewhat indicative of drops and therefore of congestion. However, if packets are persistently reordered, packet ordering conveys little information regarding congestion and thus should not be used to trigger congestion control. Consequently, as shown in Section VI, TD-FR and methods that use DSACK along with adjusting dupthresh perform poorly when faced with persistent packet reordering.</p><p>We propose to neglect DUPACKs altogether and rely solely on timers to detect drops: if the ACK for a packet has not arrived and the elapsed time since the packet is sent exceeds a threshold, then the packet is assumed to be lost. In the next section we describe the TCP-PR algorithm in detail. There are two main design challenges in developing an adaptive timer threshold. First, the threshold must be chosen such that it is only surpassed when a packet has actually been lost. This is discussed in Section IV. The second challenge, covered in Section V, is to maintain fairness with current implementations of TCP. Section VI presents extensive simulation results that show that under persistent packet reordering, TCP-PR performs significantly better than existing packet reordering recovery methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. TCP-PR</head><p>As mentioned above, the basic idea behind TCP-PR is to detect packet losses through the use of timers instead of duplicate acknowledgments. This is prompted by the observation that, under persistent packet reordering, duplicate acknowledgments are a poor indication of packet losses. Because TCP-PR relies solely on timers to detect packet loss, it is also robust to acknowledgment losses as the algorithm does not distinguish between data (on the forward path) or acknowledgment (on the reverse path) losses.</p><p>The proposed algorithms only require changes in the TCP sender and are therefore backward-compatible with any TCP receiver. TCP-PR's sender algorithm is still based on the concept of a congestion window, but the update of the congestion window follows slightly different rules than standard TCP. However, significant care was placed in making the algorithm fair with respect to other versions of TCP to ensure they can coexist.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Basic Algorithm</head><p>Packets being processed by the sender are kept in one of two lists: the to-be-sent list contains all packets whose transmission is pending, waiting for an "opening" in the congestion window. The to-be-ack list contains those packets that were already sent but have not yet been acknowledged. Typically, when an application produces a packet it is first placed in the to-be-sent list; when the congestion window allows it, the packet is sent to the receiver and moved to the to-be-ack list; finally when an ACK for that packet arrives from the receiver, it is removed from the to-be-ack list (under cumulative ACKs, many packets will be simultaneously removed from to-be-ack). Alternatively, when it is detected that a packet was dropped, it is moved from the to-be-ack list back into the to-be-sent list.</p><p>As mentioned above, drops are always detected through timers. To this effect, whenever a packet is sent to the receiver and placed in the to-be-ack list, a timestamp is saved. When a packet remains in the to-be-ack list more than a certain amount of time it is assumed dropped. In particular, we assume that a packet was dropped at time when exceeds the packet's timestamp in the to-be-ack list plus an estimated maximum possible round-trip time . As data packets are sent and ACKs received, the estimate of the maximum possible round-trip time is continuously updated. The estimate used is given by <ref type="bibr" target="#b0">(1)</ref> where is a constant larger than 1 and an exponentially weighted average of past s. Whenever a new ACK arrives, we update as follows:</p><formula xml:id="formula_0">cwnd (2)</formula><p>where denotes a positive constant smaller than 1, the floor of the current congestion window size, and the for the packet whose acknowledgment just arrived. <ref type="foot" target="#foot_3">4</ref>The reason to raise to the power is that in one the formula in ( <ref type="formula">2</ref>) is iterated times. This means that, e.g., if there were a sudden decrease in the then would decrease by a rate of cwnd cwnd per , independently of the current value of the congestion window. The parameter can therefore be interpreted as a smoothing factor in units of s. As discussed in Section IV, the performance of the algorithm is actually not very sensitive to changes in the parameters and , provided they are chosen in appropriate ranges.</p><p>Note that tracks the peaks of RTT. The rate that decays after a peak is controlled by . The right-hand plot shows how large jumps can cause (for this data set, occurrences at 15 s, 45 s, 75 s, etc.) resulting in spurious timeouts (note that the jumps in RTT in the right-hand plot were artificially generated). In order for these jumps to cause a spurious timeouts, the jumps in RTT could occur no sooner than every 15 seconds. In this case, 1500 packets were delivered between these jumps. If the jumps occurred more frequently, then, as can be seen from the figure , 
would not have decayed to a small enough value and spurious timeouts would not occur. Furthermore, if the jumps were larger, then the time between jumps to cause a timeout would be no smaller. The issue of spurious timeouts is closely examined in Section IV.</p><p>Two modes exist for the update of the congestion window: slow-start and congestion-avoidance. The sender always starts in slow-start and will only go back to slow-start after periods of extreme losses (cf. Section III-B). In slow-start, starts at 1 and increases exponentially (increases by one for each ACK received). Once the first loss is detected, is halved and the sender transitions to congestion-avoidance, where increases linearly ( for each ACK received). Subsequent drops cause further halving of , without the sender ever leaving congestion-avoidance. An important but subtle point in halving is that when a packet is sent, not only a timestamp but the current value of is saved in the to-be-ack list. When a packet drop is detected, then is actually set equal to half the value of at the time the packet was sent and not half the current value of . This makes the algorithm fairly )10</p><formula xml:id="formula_1">3 x := ((bcwndc 0 1)=bcwndc)x + (=bcwndcx cwnd ) 4 end</formula><p>The larger the value of n, the better the approximation. In our implementation, we are using n = 10. However, if cwnd is bounded by a small enough value, it might be simpler to save cwnd in a look-up table . 

insensitive to the delay between the time a drop occurs until it is detected.</p><p>To prevent bursts of drops from causing excessive decreases in , once a drop is detected a snapshot of the to-be-sent list is taken and saved into an auxiliary list called memorize. As packets are acknowledged or declared as dropped, they are removed from the memorize list so that this list contains only those packets that were sent before was halved and have not yet been unaccounted for. When a packet in this list is declared dropped, it does not cause to be halved. The rational for this is that the sender already reacted to the congestion that caused that burst of drops. This type of reasoning is also present in TCP-NewReno and TCP-SACK.</p><p>The pseudo-code in Table <ref type="table" target="#tab_0">I</ref> corresponds to the algorithm just described. Table <ref type="table" target="#tab_1">II</ref> summarizes the notation used in the code.</p><p>Remark 1: From a computational view-point, TCP-PR is more demanding than TCP-(New)Reno because it requires the sender to maintain the list to-be-ack of packets whose acknowledgment are pending, but is not significantly more demanding than TCP-SACK. It does maintain the extra memorize list used to detect drop bursts, but this list is empty most of the time and otherwise only needs to contain pointers to packets also in the to-be-ack list. Recall that the transport layer must maintain the data to be transmitted until the packet has been ACKed by a cumulative ACK. If static memory allocation is used, the transport layer must allocate enough memory to hold a maximum sender's window's worth of packets. In the typical case where the MSS is several hundred to over a thousand bytes, TCP-PR's requirement of two bytes per packet for timestamps and lists of pointers results in a relatively minor increase in the transport layer's memory requirements. On the other hand, cwnd must be computed every time is incremented and requires a number of multiplications, divisions and additions. Alternatively, cwnd can be tabulated requiring table look-up operations. Clearly, table look-ups are less computationally intensive, but require more memory (again, this memory demand is small compared to what is required for packet buffering).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Extreme Losses</head><p>When more than half of a window's worth of packets is dropped, TCP-NewReno/SACK may timeout in the fast-recovery mode <ref type="bibr" target="#b19">[20]</ref>. This is because not enough ACKs are received for the congestion window to open and allow for the sender to perform the needed retransmissions. The occurrence of a timeout typically depends on the number of packets dropped, the congestion window size , the round-trip time, and the value of . In the ns-2 simulations whose results we report, we observed timeouts in TCP SACK when more than packets are dropped within a window, which is consistent with the results in <ref type="bibr" target="#b19">[20]</ref>. TCP-NewReno and SACK also enter the timeout mode when the retransmitted packets are lost or when drops occur while the congestion window size is smaller than 4. In the latter case, there are not enough ACKs to trigger fast recovery, so a timeout eventually occurs.</p><p>The "correct" behavior of congestion control under extreme losses is somewhat controversial and perhaps the more reasonable approach is to leave to the application to decide what to do   in this case. However, we have found that without special attention to the behavior during extreme losses, TCP-PR is unfair to today's implementations of TCP. In order to maintain fairness (a key goal of this work), we propose a version of TCP-PR that mimics TCP-SACK's timeout, i.e., upon detecting an extreme loss situation, TCP-PR sets SSTHRESH to , resets to one, performs exponential back-off, etc. It should be emphasized that this variation of TCP-PR is not required for the proper functioning of TCP-PR in sense that throughput is maintained without this enhancement. Rather, this variation results in lower, but more fair, throughput in high loss situations.</p><p>TCP-PR detects extreme losses by counting the number of packets lost in a burst. This can be done using a counter that is incremented each time a packet is removed from the list due to drops and is reset to zero when this list becomes empty. We recall that this list is usually kept empty but when a drop occurs it "memorizes" the packets that were outstanding. In the spirit of TCP-NewReno and TCP-SACK, packets from this list that are declared dropped do not lead to further halving of the congestion window.</p><p>To emulate as close as possible what happens during a TCP-NewReno or TCP-SACK timeout, we check if (and therefore the number of drops in a burst) exceeds , or if a drop is detected while , or if a retransmitted packet is dropped. When one of these conditions occurs, we reset and transition to the slow-start mode. Moreover, and for fairness with implementations of TCP-NewReno/SACK that use coarse-grained timers, we increase to one second and delay sending packets by <ref type="bibr" target="#b20">[21]</ref>. If further (new) drops occur while , instead of dividing by two we double , thus emulating the usual exponential back-off. The pseudo-code in Table III implements this algorithm. In this pseudo-code, we also inhibited increments of while the memorize list is not empty. This was also done to improve fairness with respect to TCP-NewReno/SACK, because it emulates the fact that in these algorithms only goes back to the usual increase of per ACK after the sender leaves the fast-recovery mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. SELECTION OF TCP-PR PARAMETERS</head><p>In this section, we discuss the selection of the parameters and used in the estimation of the maximum round-trip time . When the time elapsed since a packet was sent exceeds and its acknowledgment has not yet arrived, TCP-PR assumes the packet was dropped and divides the congestion window by two. However, there is the risk that if is set too low, the algorithm will assume that a packet has been lost when it merely experienced a large round-trip time. We refer to such events as spurious timeouts. While occasional spurious timeouts are of little consequence, throughput may suffer severely if they occur too frequently.</p><p>In order to determine adequate values for and that reduce the occurrence of spurious timeouts, we employ two different methods: 1) an analytical approach that determines a worstcase relationship between the rate of spurious timeouts and the  values of the parameters, and 2) an empirical method that utilizes traces to determine the probability of spurious timeouts in today's Internet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Worst-Case Analysis of Spurious Timeouts</head><p>A spurious timeout occurs when the estimate of the maximum round-trip time is actually smaller than . Since adapts online to the current , this can occur when takes small values for a period of time and suddenly increases. We consider a worst-case situation where packets exhibit one of two possible s: a small value and a large one . This would occur, e.g., if multipath routing were employed in the network depicted in Fig. <ref type="figure">1</ref>. In this network periodic spurious timeouts can occur if several packets take the shorter path until essentially becomes equal to and then a packet takes the longer path. A timeout will then occur if</p><p>(3) Fig. <ref type="figure">1</ref>. Worst-case topology for spurious timeouts. When the packet latency along the longer path is at least times longer than that of the shorter path and the packets take the shorter path infrequently enough, a spurious timeout will occur every time a packet follows the longer path.</p><p>Suppose that this is indeed the case. One can then ask under what conditions a spurious timeout can occur again. To answer this question note that, right after a packet goes through the longer path, jumps to . In the worst-case it will be followed by several packets taking the shorter path as otherwise will not decrease and further spurious timeouts will not occur. As discussed in Section III, after congestion windows worth of packets have been ACKed, . Therefore, a spurious timeout will be produced by a packet taking the long route seconds after the previous one, as long as We conclude from here that the minimum number of shorter round-trip times between spurious timeouts is equal to . In this worst-case situation, most packets take the shorter path and therefore the average is essentially . We can summarize our conclusions as follows. When (3) does not hold there will be no spurious timeouts, otherwise the time between spurious timeouts must be larger than where is the average round-trip time. This means that and result in low rates for spurious timeouts (approximately seconds between spurious timeouts) and yield good performance, as confirmed in the following sections.</p><p>Remark 2: This worst-case analysis also applies to conditions such as highly variable processing delay within a router, or delay variations due to link layer ARQ or media access in wireless channels which may also cause spurious timeouts. Similarly to the scenario investigated above, the worst case situation is when the latency mostly takes a small value and occasionally jumps to a large value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Analysis of Traces</head><p>The above analysis determined the worst-case frequency of spurious timeouts.</p><p>traces can be utilized to estimate the probability of getting a spurious timeout in the more typical case of today's Internet. Using a July 25, 2001 snapshot of round-trip times from the National Laboratory for Applied Network Research (NLANR) data set, we computed empirical probability of spurious timeouts. The total data set consists of nearly 13 000 connections between 122 sites and 17.5 million round-trip time measurements. This data consisted of time series of round-trip times for each connection with each time series containing 1440 round-trip times (one sample per minute over the entire day). For each time series, the and were computed and spurious timeouts noted. This process was repeated for several values of and . Fig. <ref type="figure" target="#fig_0">2</ref> shows the probability of a drop versus the parameters and .</p><p>For these computations, it was assumed that . However, for we have that cwnd and therefore cwnd Hence, assuming actually reduces , leading to an overestimate on the number of spurious timeouts. The data used was also collected at one minute intervals, whereas TCP-PR would likely sample much more frequently. Since is positively correlated <ref type="bibr" target="#b21">[22]</ref>, large jumps are observed less frequently when is sampled at closely spaced intervals. The more frequent sampling that occurs within TCP-PR would likely drive down the probability of spurious timeouts even further.</p><p>Despite these two conservative assumptions, Fig. <ref type="figure" target="#fig_0">2</ref> shows that as long as and the probability of a spurious timeout occurring is less than . For and , the probability of a spurious timeout becomes vanishingly small.</p><p>Standard implementations of TCP <ref type="bibr" target="#b22">[23]</ref> compute which is a filtered version of that is used to trigger TCP's timeout. Typically, is computed using Van Jacobson's algorithm <ref type="bibr" target="#b23">[24]</ref> While the typical value of is 4, there is some discrepancy over the value of . Often, it is assumed that second (as specified in RFC 2988 <ref type="bibr" target="#b20">[21]</ref>), but some implementations use different values, e.g., BSD and MS Windows uses 500 ms, and Linux uses 200 ms. Fig. <ref type="figure" target="#fig_0">2</ref> shows the empirical probability of from the NLARN data set under the assumption that . For , we obtained , i.e., a little more than 1% of all packets would timeout. It is difficult to determine the best value of . If , then we can expect 1% of packets sent will trigger a spurious timeout. For RTO too large, the throughput of TCP-PR would be reduced. While it is possible that an intermediate value of MinRTO would result in less than 1% spurious timeouts while maintaining high throughput, it is difficult to find a single MinRTO that works well in many situations. A similar conclusion was also reached in <ref type="bibr" target="#b24">[25]</ref> where no obvious "sweet spots" were found for when used in TCP. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PERFORMANCE AND FAIRNESS WITHOUT PACKET REORDERING</head><p>Two issues arise when considering TCP-PR over networks without packet reordering: performance and fairness. The first issue is whether TCP-PR performs as well as other TCP implementations under "normal" conditions, i.e., no packet reordering. Specifically, for a fixed topology and background traffic, does TCP-PR achieve similar throughput as standard TCP implementations? The second concern is whether TCP-PR and standard TCP implementations are able to coexist fairly. To some extent, the fairness issue encompasses the performance issue: if TCP-PR competes fairly against standard TCP implementations in a variety of network conditions, then it seems reasonable that TCP-PR and other TCP implementations are able to achieve similar throughput (and thus perform similarly) when exposed to similar network conditions. Therefore, while this section focuses on fairness, it indirectly addresses the performance issue. Additionally, in Section VI, we also show that, when no packet reordering occurs, TCP-PR achieves the same throughput as other TCP implementations.</p><p>We performed extensive ns-2 <ref type="bibr" target="#b25">[26]</ref> simulations to show that TCP-PR is fair with respect to standard TCP implementations, for a wide range of network conditions and topologies. In this section, a sample of our simulation results is presented, with attention focused on the compatibility with TCP-SACK <ref type="bibr" target="#b26">[27]</ref>. One of the topologies we use is the dumbbell topology, also known as single-bottleneck. A number of simulation-based studies have used the dumbbell topology to evaluate the performance of network protocols. One recent example is the comparison between the performance (including fairness) of TCP-SACK and an implementation of the "TCP-friendly" formula <ref type="bibr" target="#b27">[28]</ref>. The other topology used is the parking-lot topology, which includes multiple bottleneck links and has also been employed in a number of recent performance studies of network protocols including <ref type="bibr" target="#b28">[29]</ref> and <ref type="bibr" target="#b29">[30]</ref>. Fig. <ref type="figure" target="#fig_1">3</ref> shows the parking-lot and dumbbell topologies used, including the source and destination nodes for the cross traffic. Previous studies that used the parking-lot topology only included cross traffic between nodes , , and . In our simulations, we also considered cross traffic between , , and</p><p>. For the single-bottleneck (dumbbell) topology, we ran simulations both with and without HTTP background traffic. When background traffic was used, it corresponded to around 10% of the total traffic. <ref type="foot" target="#foot_4">5</ref> HTTP traffic flowed from node 1 to node 2; more specifically, we set up five Web server-client pairs, each of which running ten concurrent connections. All Web clients ran in node 2 and all Web servers in node 1 so that the HTTP traffic direction coincides with the TCP flows under study. For the parking-lot topology, we always considered HTTP cross traffic. Eight Web server-client pairs were configured each of which with ten concurrent active sessions. While and have two pairs of Web server-client each, all other pairs have a single Web server-client pair. In both topologies, each Web session used the following parameters: inter-page time was exponentially distributed with mean 1 second, the number of objects per page was uniformly distributed with mean 1, the inter-object time was exponentially distributed with mean 10 ms, and object size was Pareto-distributed with mean 40 KB and shape parameter equal to 1.2. <ref type="foot" target="#foot_5">6</ref> A large number of distinct link speeds and number of flows were investigated.</p><p>Following the approach taken in <ref type="bibr" target="#b27">[28]</ref>, the fairness of TCP-PR to TCP-SACK is judged by simulating an equal number of TCP-PR and TCP-SACK flows. These flows have a common source and destination. The steady state fairness can be quantified with a single number, the mean normalized throughput. If there are flows, then the normalized throughput of flow is where the throughput, , is the total data sent during the last 60 seconds of the simulation. The mean normalized throughput for a particular protocol is the average value of , averaged over all the flows of that protocol. Note that if , then flow achieves the average throughput. Similarly, if the mean normalized throughout of both protocols is one, then they achieved the same average throughput.</p><p>Figs. 4-10 show the normalized throughput and the mean normalized throughput for different numbers of flows, topologies, link speeds, queue disciplines, propagation delays, and with and    While the mean normalized throughput describes the average behavior of all flows, the coefficient of variation describes the variation of the throughput and is defined by where denotes the set of flows of a particular protocol, and the number of elements in the set . Fig. <ref type="figure" target="#fig_8">11</ref> shows the coefficient of variation for ten simulations as well as the mean coefficient of variation for the simulation set. From Figs. 4-11, we conclude that the mean and variance of the throughput for TCP-PR and TCP-SACK are similar. In light of these results, incremental TCP-PR deployment should have no adverse effects on competing flows that use other implementations of TCP.</p><p>Fig. <ref type="figure" target="#fig_9">12</ref> shows TCP-SACK's mean normalized throughput for different values of and . For these simulations, the number of flows was held constant at 64 total flows (32 TCP-SACK and 32 TCP-PR flows). Surprisingly, fairness is maintained for a wide range of and . Note that for , TCP-SACK exhibits higher throughput. However, for larger than 1, both implementations achieve nearly identical performance. A large number of simulations show that these results are consistent for different levels of background traffic and different topologies. We noticed that even in situations where cross traffic causes extreme loss conditions (over 15% drop probability), TCP-SACK only gets up to 20% more throughput when , while throughput is essentially the same for . Such extreme loss scenarios are not of particular concern since TCP's throughput is very low when the loss probability is this large.</p><p>Under normal traffic conditions, fairness is not so much evidence of the remarkableness of TCP-PR, but rather it attests to the robustness of additive-increase/multiplicative-decrease (AIMD) schemes. An important feature of these schemes is that if two flows detect drops at the same rate, then their congestion windows will converge to the same value. In fact, it was shown in <ref type="bibr" target="#b32">[33]</ref> and, in more detail, in <ref type="bibr" target="#b33">[34]</ref> that, at least for a dumbbell topology, competing TCP flows converge to the same bandwidth exponentially fast. While these proofs rely on the protocols being identical, they also point to the inherent stability of the AIMD scheme which is witnessed in the simulation results presented here.</p><p>While the focus here is on fairness, packet delay is also of interest. TCP-PR results in delays that, on average, are similar to today's implementations of TCP, even though their loss detection mechanisms differ. In the case of a single packet loss in the middle of a file transfer, today's implementations of TCP will deliver the lost packet sooner than TCP-PR. We note that our simulations use . On the other hand, if there are over losses, TCP-PR will deliver packets sooner than TCP New Reno. In the multiple loss scenario, the packet delay of TCP-SACK compared to TCP-PR depends (in a complicated way) on the total number of losses and the window size. In general, as the number of losses increases, the difference between TCP-PR and TCP-SACK decreases.</p><p>In the case of small file transfers, it is likely that a packet loss will not invoke triple duplicate ACKs (either because is small, or because the lost packet is near the end of the file). In the case that the packet is at the end of the file, TCP-PR will deliver the packet sooner than current TCP implementations. On the other hand, if the packet loss occurs when is small, TCP-PR will recognize the loss sooner than many of today's TCP implementations. Exceptions are implementations that use Limited Transmit <ref type="bibr" target="#b34">[35]</ref>, which allows packets to be sent even   when DUP-ACKs arrive. Such implementations would detect the loss two RTTs after the lost packet is sent, whereas TCP-PR would detect it after it was sent. Implementations that do not use Limited Transmit enter timeout in such situations. In order to maintain fairness with implementations that do not use Limited Transmit, TCP-PR will enter the extreme loss state and will deliver the packet at the same time as these implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. PERFORMANCE UNDER PACKET REORDERING: COMPARISON WITH OTHER METHODS</head><p>This section compares the performance of TCP-PR against existing algorithms that make TCP more robust to packet reordering. Two types of packet reordering are investigated: packet reordering due to queue swaps which might occur within a switch as suggested by <ref type="bibr" target="#b0">[1]</ref>, and reordering due to multipath routing. Our goal in designing TCP-PR is to provide a transport protocol that is suitable for environments that exhibit persistent reordering, yet achieving adequate performance (including fairness) in environments with no or occasional reordering. While queue swaps may lead to the latter scenarios, as discussed in Section IV, multipath routing typically results in persistent packet reordering and can be especially demanding since packets sent back-to-back may experience very different latencies.</p><p>Besides TCP-PR, several other approaches to TCP are considered. These include TCP-SACK with the DSACK feature enabled. In this case, spurious drops are detected, but no mitigation is performed. This method is labeled DSACK-NM. In <ref type="bibr" target="#b0">[1]</ref>, several methods were examined and are considered here as well. These methods use "limited transmit" <ref type="bibr" target="#b34">[35]</ref> so that packets are still sent when duplicate ACKs arrive. These methods also adjust dupthresh. In the graphs that follow, Inc by 1 refers to the approach that increments the dupthresh by one every time a spurious retransmission is detected. Upon detecting a spurious retransmission, the method labeled Inc by N increases the dupthresh such that the just observed spurious retransmission would not have occurred. The method labeled EWMA varies the dupthresh according to an exponentially weighted moving average filter. Another method first suggested in <ref type="bibr" target="#b17">[18]</ref> and further investigated in <ref type="bibr" target="#b0">[1]</ref> is referred to as time-delayed fast-retransmit (TD-FR). In this case, fast retransmit is only entered when a triple duplicate ACK is observed and a certain amount of time has passed since the packet was sent. Recently another method for adapting dupthresh has been suggested <ref type="bibr" target="#b16">[17]</ref>. Since a simulation implementation of this method is not yet available, it was not included in this comparison.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Performance Under Packet Reordering Due to Queue Swaps</head><p>In <ref type="bibr" target="#b0">[1]</ref> the different versions of TCP were compared by examining their performance in the face of queue swaps. A queue swap is when two packets in a queue are exchanged. We assume that queue swap events occur every one second, and each event consists of individual packet swaps. The ns-2 simulations presented refer to a single bottleneck topology with drop-tail queuing, a maximum queue size of 250 packets, and one flow. The experiments were repeated for different propagation delays. Since the critical concern is whether or not the throughput is affected by queue swaps, Fig. <ref type="figure" target="#fig_10">13</ref> shows the relationship between throughput and the number of packet swaps per queue swap event.</p><p>The left plot in Fig. <ref type="figure" target="#fig_10">13</ref> shows the throughput for a 30 ms propagation delay and the right plot for a 180 ms propagation delay. In the low propagation delay case, most algorithms work relatively well. Indeed, even TCP-SACK with no special mitigation for packet reordering achieves a throughput that is merely 1.5% smaller than the other algorithms. However, for higher propagation delays the situation is quite different. In the right plot of Fig. <ref type="figure" target="#fig_10">13</ref>, we observe that most methods only achieve a throughput that is 25% smaller than TCP-PR and TD-FR. In both cases the throughput achieved by TCP-PR is nearly independent of the number of packet swaps per swap event. This result is to be expected since reordering of packets in a queue will merely produce duplicate ACKs. The ACK arrival rate is not changed and hence TCP-PR's throughput is not affected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Performance Under Packet Reordering Due to Multipath Routing</head><p>As before, we ran extensive simulations using ns-2 to compare the performance of the different algorithms in the face of persistent packet reordering due to multipath routing. The tests presented were performed on the topology shown in Fig. <ref type="figure" target="#fig_11">14</ref>. Different sets of simulations were performed. In the first set, the propagation delay for each link was set to 10 ms, while in the second set it was set to 60 ms. These simulations were performed with and without background traffic.</p><p>Many multipath routing strategies are possible over this topology. We developed a family of strategies that is parameterized by a single variable (cf. <ref type="bibr" target="#b35">[36]</ref> for details). This parameter controls the degree to which routing accounts for link cost: When the link cost is heavily penalized, resulting in minimum-hop routing. When the link cost is not penalized at all and all independent paths from source to destination are used with equal probability. Intermediate values of correspond to compromises between these two extreme cases. We compared the performance of TCP-PR with that of the various TCP versions with dupthresh compensation schemes in <ref type="bibr" target="#b0">[1]</ref>. This was done for several fixed routing strategies, each corresponding to a distinct value of . In these simulations only one flow was active at a time.</p><p>Fig. <ref type="figure" target="#fig_12">15</ref> shows the throughput for various values of . The simulations show that for (single-path routing), all methods achieve the same throughput. For (full multi-path routing) most protocols other than TCP-PR suffer drastic decreases  in throughput. The exception is time-delayed fast-recovery (TD-FR) and TCP-DCR, which still achieves a reasonable throughput for small values of when the propagation delay is small (the left plot in Fig. <ref type="figure" target="#fig_12">15</ref>). However, as shown in Fig. <ref type="figure" target="#fig_12">15</ref> and Fig. <ref type="figure" target="#fig_13">16</ref>, TD-FR and TCP-DCR still suffer a large decrease in throughput when the propagation delay is increased. The reason for this drop in throughput is that TD-FR and TCP-DCR make use of both dupthresh and timers. While the "limited transmit algorithm" attempts to reduce it, burstiness remains a problem for TD-FR over connections with long latency. These simulations demonstrate the effectiveness of TCP-PR's timer-based packet drop detection. This confirms that duplicate ACKs are indicative of packet loss in single path routing, but their occurrence convey little information when multi-path routing is utilized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>In this paper we proposed and evaluated the performance of TCP-PR, a variant of TCP that is specifically designed to handle persistent reordering of packets (both data and acknowledgment packets). Our simulation results show that TCP-PR is able to achieve high throughput when packets are reordered and yet is fair to standard TCP implementations, exhibiting similar performance when packets are delivered in order. From a computational view-point, TCP-PR is more demanding than TCP-(New)Reno but carries essentially the same overhead as TCP-SACK.</p><p>Because of its robustness to persistent packet reordering, TCP-PR allows mechanisms that introduce packet reordering as part of their normal operation to be deployed in the Internet. Such mechanisms include proposed enhancements to the original Internet architecture such as multi-path routing for increased throughput, load balancing, and security; protocols that provide differentiated services (e.g., DiffServ <ref type="bibr" target="#b7">[8]</ref>); and traffic engineering approaches.</p><p>A Linux implementation of TCP-PR is under development and is available at <ref type="bibr" target="#b36">[37]</ref>. Furthermore, TCP-PR is expected to work well in wireless multi-hop environments allowing wireless routing protocols to make use of multiple paths when available. While the protocol described in this paper focuses on wired networks, we plan to adapt it for wireless environments as part of our future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Right: probability of spurious timeouts computed from the NLANR data set. For many pairs of , there were no spurious timeouts. However, in order to view the data on a log scale a perturbation of 10 has added. Hence, all the pairs , that show a probability of 10 actually had no spurious timeouts at all. Left: probability of spurious timeouts when Van Jacobson's Algorithm is used.</figDesc><graphic coords="7,301.14,74.16,252.00,99.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Left: parking-lot topology with multiple bottlenecks and cross traffic. The source and destination are labeled S and D respectively. The cross-traffic connections are CS1 ! CD1, CS1 ! CD2, CS1 ! CD3, CS2 ! CD2, CS2 ! CD3, and CS3 ! CD3. The data rates are: 5 Mb/s for CS1 ! 1, 1.66 Mb/s for CS2 ! 2, 2.5 Mb/s for CS3 ! 3, and 15 Mb/s for all other links. This results in the following three bottlenecks: 1 ! 2, 2 ! 3, and 3 ! 4. Right: the dumbbell topology.</figDesc><graphic coords="8,55.08,66.78,483.00,96.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. TCP-PR and TCP-SACK Normalized Throughput over a Single Bottleneck Topology with RED Queue Discipline. The left-hand figure shows the case of 200 ms round-trip propagation delay and a 250 packet queue, while the right-hand plot shows the case of 20 ms round-trip propagation delay and a 25 packet queue. In both cases, the bottleneck link bandwidth was 15 Mb/s.</figDesc><graphic coords="9,80.28,67.82,429.00,157.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. TCP-PR and TCP-SACK Normalized Throughput over a Single Bottleneck Topology with Drop-Tail Queue Discipline. The left-hand figure shows the case of 200 ms round-trip propagation delay and a 250 packet queue, while the right-hand plot shows the case of 20 ms round-trip propagation delay and a 250 packet queue. In both of these cases, the bottleneck link bandwidth was 15 Mb/s.</figDesc><graphic coords="9,79.32,287.84,431.00,157.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Normalized Throughput for TCP-PR and TCP-SACK. The left-hand plot shows the results for the drop-tail queue discipline while the right-hand plot shows the results for RED queue discipline. In these simulations the topology was a single bottleneck topology with a 1.5 Mb/s bandwidth bottleneck. The round-trip propagation delay was 20 ms and the queue size was 25 packets.</figDesc><graphic coords="10,97.20,66.22,398.00,143.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Normalized throughput of TCP-Reno and TCP-SACK. The left-hand plot shows the throughput of TCP-SACK and TCP-Reno for the drop-tail queue discipline, while the right-hand plot shows the results for RED queue discipline. In these simulations the topology was a single bottleneck topology with a 1.5 Mb/s bandwidth bottleneck. The round-trip propagation delay was 20 ms and the queue size was 25 packets.</figDesc><graphic coords="10,39.60,272.34,252.00,111.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Normalized throughput for TCP-PR and TCP-SACK with HTTP Background Traffic. The left-hand plot shows the results for the drop-tail queue discipline while the right-hand plot shows the results for RED queue discipline. In these simulations the topology was a single bottleneck topology with a 15 Mb/s bandwidth bottleneck. The round-trip propagation delay of 20 ms and a queue size of 250 packets.</figDesc><graphic coords="11,79.50,66.28,431.00,158.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Normalized Throughput for TCP-PR and TCP-SACK with HTTP Cross Traffic. The left-hand plot shows the results for the drop-tail queue discipline while the right-hand plot shows the results for RED queue discipline. In these simulations the topology was the parking-lot topology with a 15 Mb/s links. Each link has the round-trip propagation delay of 20 ms with a queue size of 250 packets.</figDesc><graphic coords="11,38.10,281.10,252.00,102.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Coefficient of variation. The coefficient of variation as a function of packet loss probability. The variation in loss probability was simulated by decreasing the link bandwidth. The left plot is the coefficient of variation for the dumbbell topology and the right plot is for the parking lot topology. The single bottleneck had a round-trip propagation delay of 20 ms and a queue size of 250 packets. The parking-lot topology had a round-trip propagation delay of 20 ms with a queue size of 250 packets. In both cases, the link speed was 15 Mb/s and the drop-tail queueing discipline was used. The parking-lot topology had HTTP cross traffic.</figDesc><graphic coords="11,38.10,464.96,252.00,121.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. TCP-SACK normalized throughput for different TCP-PR parameters. The left plot shows the mean normalized throughput of TCP-SACK using the single bottleneck topology, while the right plot shows normalized throughput for the parking-lot topology. The single bottleneck had a round-trip propagation delay of 20 ms and a queue size of 250 packets. The parking-lot topology had a two-way propagation delay of 20 ms with a queue size of 250 packets. In all cases, the link speed was 15 Mb/s and the drop-tail queueing discipline was used. The parking-lot topology had HTTP cross traffic.</figDesc><graphic coords="11,301.14,281.58,252.00,117.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Throughput as a function of the number of packet swaps per swap event. The left plot shows the throughput for a 30 ms propagation delay and the right plot for a 180 ms propagation delay.</figDesc><graphic coords="12,119.40,67.12,354.00,128.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Topology to compare TCP implemenations. Each link has a delay of 20 ms, bandwidth of 10 Mb/s, and queue has a size of 100 packets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 15 .</head><label>15</label><figDesc>Fig.<ref type="bibr" target="#b14">15</ref>. Throughput for different TCP implementations and different degrees of multi-path routing. " = 500 corresponds to single path routing, whereas for smaller values of " alternative paths are sometimes used. In the limit " = 0, all paths are used with equal probability. The left plot corresponds to the topology in Fig.14with a 10 ms propagation delay for each link and the right plot corresponds to the same topology but with a 60 ms propagation delay for each link.</figDesc><graphic coords="13,49.62,66.58,228.00,128.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Throughput of TCP-PR and TCP-DCR for different values of and different propagation delays.</figDesc><graphic coords="13,55.62,281.20,216.00,122.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="5,127.14,94.20,336.00,270.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="6,117.84,94.16,357.00,421.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I PSEUDO</head><label>I</label><figDesc>-CODE FOR TCP-PR (CF. NOTATION IN</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II )</head><label>II</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II NOTATION</head><label>II</label><figDesc>USED IN TABLES I AND III</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE III PSEUDO</head><label>III</label><figDesc>-CODE FOR TCP-PR WITH EXTREME LOSSES (CF. NOTATION IN</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE II )</head><label>II</label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>As an alternative to timestamping every packet, Eifel can also use a single bit to mark the segment generated by the original transmission.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Instead of instantaneously increasing the congestion window to the value prior to the retransmission event, the sender slow-starts up to that value in order to avoid injection of sudden bursts into the network.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>As suggested in<ref type="bibr" target="#b4">[5]</ref>, the TCP receiver can notify the sender by setting a OOO bit in the TCP ACK packet.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We currently have an implementation of TCP-PR in the Linux kernel.In order to compute cwnd in the kernel, we employ Newton's method through the following loop:1 x := result from last calculation or 1 if there has not been a previous calculation of cwnd 2 while jx 0 ((bcwndc 0 1)=bcwndc)x + (=bcwndcx cwnd ))j&gt; (1 0</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Generating HTTP background traffic to correspond to 10% of the total traffic was motivated by the observation that, "while the exact fraction of short-lived traffic found on the Internet is unknown, it appears that short-lived flows make up for at least 10% of the total Internet traffic"<ref type="bibr" target="#b30">[31]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>These are the same parameters used by sample ns-2 scripts included in the ns-2 distribution; furthermore, these same parameters have also been used in simultaions conducted by other researchers (e.g.,<ref type="bibr" target="#b31">[32]</ref>).</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Manuscript received October 12, 2003; revised May 3, 2004, and December 16, 2004; approved by IEEE/ACM TRANSACTIONS ON NETWORKING Editor N. Shroff. This work was supported in part by the National Science Foundation under Grants ANI-0322476 and CCR-0311084. S. Bohacek is with the Department of Electrical and Computer Engineering,</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Stephan Bohacek (M'00) received the B.S. degree in electrical engineering from the University of California at Berkeley in 1989, and the Ph.D. degree in electrical engineering from the University of Southern California, Los Angeles, in 1999.</p><p>He is currently an Assistant Professor in the Department of Electrical and Computer Engineering at the University of Delaware, Newark. His research focuses on the design, analysis, and control of data networks. His current interests include congestion control and routing for wireless and wireline networks, modeling mobile wireless networks, and cross-layer design for wireless networks. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On making TCP more robust to packet reordering</title>
		<author>
			<persName><forename type="first">E</forename><surname>Blanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Allman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">End-to-end routing behavior in the Internet</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIG-COMM</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="25" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Packet reordering is not pathological network behavior</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Partridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="789" to="798" />
			<date type="published" when="1999-12">Dec. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Packet reordering</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cottrell</surname></persName>
		</author>
		<ptr target="http://www-iepm.slac.stanford.edu/monitoring/reorder/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Improving TCP performance over mobile ad-hoc networks with out-of-order detection and response</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MOBIHOC</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="217" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A comparison of TCP performance over three routing protocols for mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Boppana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MOBI-HOC</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="56" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Analysis of TCP performance over mobile ad-hoc networks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vaidya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MOBICOM</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="219" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">An architecture for differentiated services</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blake</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Davies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Whang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weiss</surname></persName>
		</author>
		<idno>RFC 2475</idno>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Bertsekas</surname></persName>
		</author>
		<title level="m">Network Optimization: Continuous and Discrete Models</title>
		<meeting><address><addrLine>Belmont, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Athena Scientific</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Quality-of-service routing using maximally disjoint paths</title>
		<author>
			<persName><forename type="first">N</forename><surname>Taft-Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bellur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ogier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/IFIP IWQoS&apos;99</title>
		<meeting>IEEE/IFIP IWQoS&apos;99</meeting>
		<imprint>
			<date type="published" when="1999-06">Jun. 1999</date>
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Secure stochastic routing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bohacek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hespanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Obraczka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lim</surname></persName>
		</author>
		<idno>ICCCN&apos;02</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Miami, FL</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Characterizing and measuring path diversity of Internet topologies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Marzullo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Voelker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMETRICS</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06">Jun. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Demand multipath routing for mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nasipuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the ICCCN&apos;99</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-10">Oct. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The impact of alternate path routing for load balancing in mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pearlman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sholander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tabrizi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MobiHoc</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-08">Aug. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The Eifel algorithm: making TCP robust against spurious retransmissions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ludwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An extension to the Selective Acknowledgment (SACK) option for TCP</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mahdavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mathis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Podolsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">2883</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">RR-TCP: A reorderingrobust TCP With DSACK</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<idno>TR-02-006</idno>
	</analytic>
	<monogr>
		<title level="j">ICSI</title>
		<imprint>
			<date type="published" when="2002-07">Jul. 2002</date>
			<pubPlace>Berkeley, CA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">End-to-end Internet packet dynamics</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
		<meeting><address><addrLine>Cannes, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">TCP-DCR: a novel protocol for tolerating wireless channel errors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bhandarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L N</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vaidya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Mobile Comput</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="517" to="529" />
			<date type="published" when="2004-10">Sep.-Oct. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Analytic models for the latency and steady-state throughput of TCP Tahoe, Reno, and SACK</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sikdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kalyanaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Vastola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="959" to="971" />
			<date type="published" when="2003-12">Dec. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Computing TCP&apos;s retransmission timer</title>
		<author>
			<persName><forename type="first">M</forename><surname>Allman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">2988</biblScope>
			<date type="published" when="2000-11">Nov. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A stochastic model of TCP and fair video transmission</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bohacek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="1134" to="1144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Requirements for Internet Hostsdoctype-communication layers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Braden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">1122</biblScope>
			<date type="published" when="1989-10">Oct. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Congestion avoidance and control</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM&apos;88</title>
		<meeting>SIGCOMM&apos;88<address><addrLine>Stanford, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-08">Aug. 1988</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="314" to="329" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On estimating end-to-end network path properties</title>
		<author>
			<persName><forename type="first">M</forename><surname>Allman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The ns Manual (formerly ns Notes and Documentation)</title>
		<ptr target="http://www.isi.edu/nsnam/ns/ns-documentation.html" />
	</analytic>
	<monogr>
		<title level="m">The VINT Project, a collaboration between researchers at UC Berkeley, LBL, USC/ISI, and Xerox PARC</title>
		<imprint>
			<date type="published" when="2000-10">Oct. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">TCP selective acknowledgment options</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mathis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mahdavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Romanow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<date type="published" when="1996">2018. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Equation-based congestion control for unicast applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">presented at the ACM SIG-COMM</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Stockholm, Sweden</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Connections with multiple congested gateways in packetswitched networks part 1: one-way traffic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="30" to="47" />
			<date type="published" when="1991-10">Oct. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Internet congestion control for future high bandwidth-delay product environments</title>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rohrs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
		<meeting><address><addrLine>Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Variable heavy tail duration in Internet traffic</title>
		<author>
			<persName><forename type="first">F</forename><surname>Hern√°ndez-Campos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Marron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Samorodnitsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM MASCOTS</title>
		<meeting><address><addrLine>Fort Worth, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Scripts for Adaptive Red Simulations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<ptr target="http://www.icir.org/floyd/adaptivered/papersims/single1.tcl" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Analysis of the increase/decrease algorithms for congestion avoidance in computer networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Netw. ISDN</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Analysis of a TCP hybrid model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bohacek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hespanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Obraczka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 39th Annu. Allerton Conf. Communication, Control and Computing</title>
		<meeting>39th Annu. Allerton Conf. Communication, Control and Computing<address><addrLine>Monticello, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Enhancing TCP&apos;s loss recovery using limited transmit</title>
		<author>
			<persName><forename type="first">M</forename><surname>Allman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3042</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Preliminary results in routing games</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hespanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bohacek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">American Control Conf</title>
		<meeting><address><addrLine>Arlington, VA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-06">Jun. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Tcp-Pr Web</forename><surname>The</surname></persName>
		</author>
		<author>
			<persName><surname>Page</surname></persName>
		</author>
		<ptr target="http://eecis.udel.edu/bo-hacek/tcp-pr.htm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">An expedited forwarding PHB (Per-Hop Behavior)</title>
		<author>
			<persName><forename type="first">B</forename><surname>Davie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Charny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C R</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Le Boudec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Courtney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Davari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Firoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stiliadis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3246</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
