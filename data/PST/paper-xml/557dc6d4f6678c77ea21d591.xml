<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Communicating Real-Time State Machines</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alan</forename><forename type="middle">C</forename><surname>Shaw</surname></persName>
						</author>
						<title level="a" type="main">Communicating Real-Time State Machines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">095E55C5DA8AE41C24C8FF72565AF63F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Concurrent systems</term>
					<term>executable specifications</term>
					<term>real-time specification</term>
					<term>requirements specification</term>
					<term>state machines</term>
					<term>time</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Communicating real-time state machines (CRSM's) are a new, complete, and executable notation for specifying concurrent real-time systems including the monitored and controlled physical environment. They are essentially state machines that communicate synchronously in a manner much like the input-output in Hoare's CSP. In addition, CRSM's have a novel and small set of facilities for describing timing properties and accessing real time. The paper defines the CRSM language, gives many examples of its use in requirements specification, outlines an algorithm for executing or simulating CRSM's, introduces some techniques for reasoning about the specifications, and discusses some open problems and issues.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>HE language of communicating real-time state machines T (CRSM's) is a new notation for specifying the requirements of real-time systems. Many specification techniques already exist, so a natural question is: why another one? The answer, and the reason for our development of CRSM's, is that none of the existing methods completely satisfy the needs of real-time applications, as discussed below. We hope that ours comes closer to this goal.</p><p>The CRSM scheme was designed with several objectives and needs in mind. A real-time system is embedded in, and part of, a physical environment with a given behavior. It seems important that a specification scheme be capable of describing the given behavior of the environment as well as the required behavior of the computer system. Real-time systems are inherently parallel, usually must communicate and synchronize with the environment and among its own components, and execute under timing constraints; a specification language should be able to express this concurrency, communications, synchronization, and time explicitly. Many specification methods are not universal in the Turing machine sense (for example, a pure finite state automaton or regular expression language) and require ad hoc "hooks" to deal with the inevitable exceptions. We believe that such universality is necessary.</p><p>A less quantitative, but nevertheless extremely important, goal was simplicity and naturalness-straightforward requirements should be expressible in a simple, familiar, brief way. The scheme should be amenable to analysis so that various properties can be proven formally. It is also important that a scheme be executable so that parts of a system may be simulated or fast-prototyped, since in practice there will be many properties that are just not feasible to express or prove formally, but must be observed experimentally. One main purpose of requirements is to provide implementors with precise descriptions of their tasks; this implies a notation that is not foreign to an implementor and one that can be used to demonstrate that implementations meet requirements. Finally, because most engineers prefer to work with pictures (e.g., schematics), a graphical representation is highly desirable.</p><p>CRSM's are essentially state machines that communicate synchronously over unique unidirectional channels. Transitions of a state machine are guarded commands, where a command can be an IO (send or receive a message) or an internal command (computation or physical activity). All commands have execution or synchronization times associated with them. Time is not discrete but continuous. Corresponding to each CRSM is a very simple clock machine that can be interrogated (using the synchronous IO communications) in order to specify timing behaviors other than execution times, such as alarm clocks.</p><p>The choice of non-real-time features of CRSM's was most influenced by CSP <ref type="bibr">[10]</ref>, <ref type="bibr">[11]</ref>. In particular, our guarded commands and synchronous IO are simplified versions of CSP. We selected state machines because of the proven convenience of the notation, and because of the great success of statecharts [SI for structuring real-time specifications, for representing concurrency, and as a graphical language. However, we felt that the CSP IO and guarded command notions were superior to the statechart's event broadcast and "event[condition]/action" mainly because of the differences in IO; the reasons for our choice of a CSP-like IO are explained at the end of <ref type="bibr">Section 111.</ref> We believe that our approach to specifying time is novel and useful. Other related methods that include time are Communicating Shared Resources (CSR) [6], Timed CSP <ref type="bibr">[4]</ref>, <ref type="bibr" target="#b17">[20]</ref>, <ref type="bibr">Modecharts [14]</ref>, extended state machines (ESM's) <ref type="bibr">[18]</ref>, and Hierarchical Multi-State Machines (HMS) <ref type="bibr">[5]</ref>.l CSR is a programming language notation and formalism, based also on CSP but with additions to deal with time, interrupts, and resources. There does not seem to be a means of defining data with IO or performing computations in commands; a local computation is represented as an event that consumes time. Time is not associated with IO as in CRSM's, and is discrete. A unique feature of CSR is that it permits the description of resource constraints (e.g., processors, IO devices). Timed CSP adds time to <ref type="bibr">CSP [11]</ref>, primarily through the use of a delay operator wait t, where t is the amount of time to be delayed.</p><p>The other schemes are explicitly state-based. Modecharts are similar to statecharts. One major difference is the inclusion of time; a transition can be a time-bound pair which defines the smallest time (delay) and largest time (deadline) for making a transition. Time is discrete. Events, e.g., <ref type="bibr">IO,</ref> cannot have data such as messages accompanying them. Some emphasis is placed on translating Modecharts into assertional specifications in the real-time logic language (RTL) <ref type="bibr">[13]</ref> for the purpose of reasoning about the specifications. The HMS notation is a state-based executable formalism, with a corresponding graphical representation, that uses aspects of Petri-nets, statecharts and Modecharts, and temporal logic. A temporal interval logic language describes state transitions. HMS appears to be a complete and very powerful scheme, but it is excessively complex. ESM's have CSP-like IO that appears similar to ours, but differs in the way in which transitions are defined and time is handled. In addition to IO, ESM state transitions can be guarded vector assignments with "event" labels that can be shared across machines. A global clock machine provides discrete ticks to a system, and transitions have upper and lower time bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">SYSTEM MODEL</head><p>A real-time system is represented as a finite set of machines. Any system has at least two machines, one to model the environment and the other to specify the required computer system behavior. The machines execute concurrently and independently of one another, except when they directly communicate. There are no user shared variables; thus the model is a distributed one.2 When machines communicate, they do so synchronously and instantaneously over channels that connect pairs of machines.</p><p>A channel serves two purposes. It is an abstraction for a 1-1, directed connection between two machines. It is also identified uniquely with an event or message type. A separate channel is associated with each such type of communication between two machines. A channel designation will have the general syntax:</p><formula xml:id="formula_0">( name ) (( message-components ))</formula><p>where ( name ) gives the type of the message or event and the ( message-components ) define the detailed composition of the messages that may be communicated. When the message component part is empty, i.e., the channel denotes a pure synchronization signal, the parentheses will be omitted. For example, the following are channel designators:</p><formula xml:id="formula_1">Position( (( x-coord ), ( y-coord ))) Temperature( ( degrees-centigrade )) OpenGate /*Empty Message*/ Clock( ( calendar-time ))</formula><p>'There is one system shared variable denoting global real time (Section IV). For particular instances of communications, actual values will pass over the channels as the message components. Using the above, we might have:</p><p>Position <ref type="bibr">((3.7,39.16</ref>)) Temperature ( <ref type="formula">23</ref>) OpenGate Clock(((7,01~91), 1700.36))</p><p>A global view of a system will consist of an enumeration of the machines and a description of each channel. Such a view can be represented naturally as a directed graph with labeled edges and nodes. The graph can be drawn pictorially as shown in Fig. <ref type="figure" target="#fig_1">1</ref>. There are three machines, M I , M2, and M3, and six channels, Temperature, OpenGate, Position, P, V, and Clock.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">COMMUNICATING STATE MACHINES: NON-REAL-TIME FEATURES</head><p>A machine M will have a finite number of states, with one start state and zero or more halt states. Each state transition is described by a guarded command:</p><formula xml:id="formula_2">( guard ) + ( command )</formula><p>where a ( guard ) is a Boolean expression over the local variables of M and the ( command ) can be either an input, output, or internal command. The ( guard ) part may be omitted (equivalent to a guard of true). A transition can only be executed (fired) if its guard is evaluated to true. Several commands may be eligible for execution at the same time; selection is made nondeterministically.</p><p>Each machine bears some resemblance to a CSP process [ 101. The transitions have some superficial similarities to those defined for an <ref type="bibr">IO automaton [17]</ref>. However, our detailed definitions differ considerably from both of the above.</p><p>Internal commands can specify either a computation or a physical activity. In the former, we permit an arbitrary sequential program (hopefully terminating); specification universality is obtained through this possibility of arbitrary computations. Physical activities include such tasks as, for example, opening a gate, pressing a button, moving a robot arm, or lowering a wing flap. Examples of guarded internal commands are</p><formula xml:id="formula_3">c = 0 + 1: := i + t; A[i] := B [ j ] + 3 Going-Up A (Floor = bottom) --f OpenIlevator-Door.</formula><p>Input and output are synchronous and modeled directly after CSP. A n input command has the syntax:</p><formula xml:id="formula_4">( name )(( target))?</formula><p>where ( name ) is an event type (channel) and ( target ) is a Deposit(data)</p><p>Remove(data) asynchronous communications can be described easily with our scheme. Finally, the scheme can be extended to handle real time in a natural and easy manner.</p><p>(a)</p><p>IV. TIMED MACHINES An ideal global real-time clock is assumed. When transitions are selected, they are based on an earliest-time-first policy-that transition that can execute first is chosen. Ties are broken arbitrarily, i.e., nondeterministically. Real time is considered a real number, rather than a fixed point number based on discrete ticks. This convention eliminates any need to worry about tick size, synchronizing all machines to a global tick, or relating ticks to real-time (e.g., how many ticks in one-third of a second?) Discretization to computer times can be accomplished when necessary or convenient.</p><p>The execution time for an internal command C is given by a best case/worst case pair:  There are several reasons for choosing a CSP-like synchronous scheme for real-time specifications, as compared with other alternatives such as an asynchronous method with or without broadcast. One is the very simple assignment semantics of the <ref type="bibr">IO.</ref> Another is that no signals are "lost" -all messages or events have to be explicitly accounted for somehow. A third is that there is no need to assume unbounded buffer capacities on communication channels. Broadcast and</p><formula xml:id="formula_5">0 I t m i n ( C ) I d 5 t m a x ( C ) ,</formula><p>These bounds can be interpreted as a requirement (i.e., all implementations must obey these constraints) or as a given behavior (i.e., the given C obeys these constraints). The pair will be written directly after the command, e.g.,</p><formula xml:id="formula_6">in, := in + 1 (mod n ) : full := full + 1 [2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7,3.25].</head><p>A transition with an internal command is ready at the same time that its "from" state is entered. This method of associating time with computations was used in <ref type="bibr">[22]</ref> for program timing analysis.</p><p>IO times are also represented by pairs, only in this case denoting the earliest and latest times that the IO can occur after entering a given state. The idea is that a machine is ready to perform IO at its earliest time and remains ready throughout the interval. The intersection of a sender's and a receiver's interval gives the time of possible communications. We assume that IO happens as soon as possible. More precisely, suppose 1. machine M1 enters state U at time tu;</p><p>2. U has a transition g1 + E ( z ) ? <ref type="bibr">[al,a2]</ref> where a l , a2 are times and g1 evaluates true;</p><p>3. machine M2 enters state V at time tv;</p><p>4. V has a transition 92 i E(ezpr)! <ref type="bibr">[ b l , b2]</ref> where g2 evaluates true; then IO, if it occurs, will happen at the earliest possible time, which is</p><formula xml:id="formula_7">t = max(tu + a l . tv + b l ) .</formula><p>However. it could be that either t &gt; tc + a2 or t &gt; tv + b2</p><p>In both cases, IO could not happen. Fig. <ref type="figure" target="#fig_3">3</ref> illustrates these possibilities.</p><p>If a machine M reaches a state S where one or more of its IO transitions are not possible to perform because of the  above timing violations and if these IO transitions are the only transitions out of S, then M is said to be deadlocked in S. (Deadlock can also occur in a more usual fashion.</p><p>For example, a machine M1 could be blocked forever, i.e., deadlocked, waiting for IO with a machine Adz that cannot reach a state wherein it can engage in IO with MI.) Note that IO is instantaneous, and causes the source and target machines to change state simultaneously. Any IO preparation time involving interactions between the two communicating machines can be incorporated as part of the IO bounds; processing and/or communication times could also be accounted for, if necessary, by an internal action immediately following the <ref type="bibr">IO.</ref> Examples follow. If [ a l , a23 = [l, 31 in 1 above, then t = 11 as before but 11 + 7 + 3, so IO can not happen.</p><p>The infinite interval [0, m ] for a sender's or a receiver's times indicates that the machine is ready for IO at any time that its partner is. To specify this common case, we will just omit the interval completely.</p><p>The interval [a, a ] for a given machine's IO time indicates that the machine is ready for communications at only one time. This common case will be represented by a simple scalar, up to 12 units of time following its previous IO. However, the Consumer might enter Cl, say 3 time units before the Buffer and Producer simultaneously enter Bo and P . Because T2 is ready first, it fires after 5 units of time (8 -3 ) ; if Ta takes greater than 7 time units to execute, the Producer is not able to send its Deposit signal and is thus deadlocked. This analysis is independent of the number n of buffers in Buffer and illustrates the necessity of timing analysis. So far, we have assumed implicitly that a state change occurs exactly at the same time as a transition completes, i.e., at the end of an internal activity or execution of an IO operation. Also an IO or internal activity can execute immediately, as early as 0 time, after entering a state. This can lead to some logical difficulties related to causality and time. For example, if two successive transitions TI and T2 on the same machine execute in zero time each, then it would seem that TI and T2 both occur simultaneously (at the same time t ) rather than in succession (in times tl and t 2 , tl &lt; t 2 ) .</p><p>Similarly, for example, if the Producer in Fig. <ref type="figure" target="#fig_5">4</ref> had a timing for the Deposit of [0, 01, then it would seem that time never advances!</p><p>To avoid these problems and also to reflect the reality that it always takes some nonzero amount of time to do an IO or an internal command, we assume that every machine will spend a minimal nonzero amount of time 6 in each state that it enters. More formally, every timing specification [a, b], 0 5 a 5 b, is interpreted as</p><formula xml:id="formula_9">[ a + h , b + b ] .</formula><p>A similar trick was used in Timed CSP to provide a minimal separation time between successive events in the same sequential process [4], <ref type="bibr" target="#b17">[20]</ref>. Most of the time, we will be able to ignore 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. REAL-TIME CLOCKS</head><p>A complete specification method must provide mechanisms for accessing absolute and relative real-time and for describing timeouts. These are equivalent to the get-time and alarm-clock functions available on almost all computer systems, and permit the description of complex timing constraints and timing faults. Our timed state machines already permit the definition of a sufficient and convenient set of facilities.  A real-time clock machine RTCtr is associated with each machine M . Each RTCnf has the same behavior, illustrated in Fig. <ref type="figure">5</ref>. The only new and unique addition to our system is the global variable rt which always contains the current value of real time. "Real time" here is defined as the perfect but unobtainable time, known by its properties (e.g., monotonicity), and approximated by various standard clocks. r f is globally available to all clock machines. RTChr acts as an ideal time-server to its host M . An IO command by M :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RTA,(l)'! IYI</head><p>executed by M in a transition T from state U to state V, will generate a timeout at relative time y and set s to the realtime rt at the timeout. Following our definitions, assuming M entered state U at time t L , and that transition T is selected we have:</p><p>The RTAI IO occurs at time tc + 6 + y. T := rt, at the IO, where rt = t~ + 6 + y.</p><p>M changes state from U to V at time L .</p><p>The value of z gives a time stamp for the time-out event.</p><p>By omitting y (equivalent to y = 0 or [O. x] here), we get an approximate time stamp for entering state S. Omission of .T, using the form RT,!,? <ref type="bibr">[y]</ref>, gives a pure time-out.</p><p>One basic application that uses all parts of the clock machine is the control of a periodic process. Suppose that a machine M with start state 5'1 and halt state Sf, is to be executed every p time units; i.e., p is the period of execution. Fig. <ref type="figure" target="#fig_6">6</ref> shows a machine M' that implements this periodic control.</p><p>The principal subtlety lies in defining the correct wait time before starting a new period in S1. This is given by the expression (y -,r). This machine works correctly provided that g 2 2, i.e., provided that M's execution time is shorter than the period p . To handle the case when y &lt; T , one can add a guarded transition from S, to a state that starts a suitable response to such a timing exception.</p><p>Let us also use the real-time clock to define a discrete time clock chip named Ticker, This version is illustrated in Fig. <ref type="figure" target="#fig_4">7</ref>.</p><p>The user machine can obtain the current discrete time ct by issuing the IO command</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CT(now)'?</head><p>The Ticker has the same organization of Fig. <ref type="figure" target="#fig_6">6</ref>; the Ticker process has a period tt and is represented by the machine with start state U, and halt state Uh. The CC clock will keep perfect time, i.e., not miss a tick, provided that cp is sufficiently smaller than the tick interval and that CC does not become overwhelmed by CT requests during a single tick period. These problems, including deadlock on the Tick, can be avoided by restricting the frequency of CT responses in GC, say to a small number per tick and by using the stale data overwriting technique described in Section 7.4, Fig. <ref type="figure" target="#fig_3">13</ref>. One could account for errors in the Ticker "chip" (e.g., drift) by adjusting .E with a more elaborate expression on each cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXECUTING A SYSTEM OF CRSM'S</head><p>We sketch an algorithm for simulating the execution of a system of CRSM's. The algorithm serves as a more formal definition of CRSM's, thus providing an operational semantics for our specification method. It also demonstrates that CRSM's are indeed executable; a designer can thus observe the (simulated) behavior of a system under various conditions. A simulator based on this algorithm has been implemented recently by <ref type="bibr">Raju.</ref> Input is a set of CRSM's and their communicating event channels, and the definition of each machine-states and transitions with time. The basic output is a global trace of the external behavior of the system, consisting of a sequence ordered by time of the IO executions: where the t, are times such that t , &lt; 1: 2 0, and L, is a list of IO commands (associated with transitions) that were computer clock CC. Assume that CC gets its ticks from a completed at time t i . A more detailed history also covering internal commands could be produced easily if desired.' The algorithm iterates through three phases.</p><p>Phase I: For each machine, construct a Next Event List (NEL), which gives the one or more earliest events that could occur on the machine. A possible next event could be an IO execution or the start of an internal activity, if the machine's most recent event caused a state transition, i.e., an IO execution or the completion of an internal activity; otherwise, the most recent event was the start of an internal activity and the next event is the completion of the activity.</p><p>Phase 2: Determine the subset of machines that are to be executed to (one of) their next event(s). Using the Phase 1 NEL's, the global earliest time events are selected from the earliest time events of each machine.</p><p>Phase 3: Execute the selected events on their machines, as determined from Phase 2, incrementing simulated real time and producing the next output (L,, t i ) if an IO is executed.</p><p>Execution of an IO command:</p><formula xml:id="formula_10">E(z)'! t E(expr)!</formula><p>involves performing the assignment :I: := e z p r on the target machine and changing state on both source and target machines. For an internal activity completion, the computation (if defined) is performed and the state changed.</p><p>The start of an internal activity does not involve a state ~h a n g e , ~ but just a note that the machine is in a particular transition. We now describe some nonobvious details of each phase and analyze the complexity of the algorithm. Let there be m machines, with each machine having a maximum of r transitions leaving any state. The entire system is initialized and each machine is started at real-time rt = 0 in its start state.</p><p>For Phase 1, if the most recent event caused a state transition, there could be more than one earliest next event, each corresponding to a different transition. For each of these, the associated guard must evaluate to true. An IO execution is eligible only if its partner is also ready to engage in an IO. This phase has a time complexity of O(rn x r ) , since each of the m machines examines at most r transitions. Note that it appears in practice that much fewer than r transitions, often just one or two, are possible at each state so that the expected behavior is O(m).</p><p>Consider next Phase 2. Each NEL will have at most 'r elements. The global minimum time for the next event can be determined by a simple scan of each NEL, taking O(m) time. (This could be computed during Phase 1 at little extra cost.) For each machine, either eliminate it from contention if its next event is later than the global minimum time or add it to the executable set. If ,the latter, then an earliest event must be selected from the list of possibilities; if there are several candidates, one is chosen arbitrarily ("nondeterministica11y").</p><p>'Underlying these definitions of history is our notion that the execution behavior of a system of CRSM's can be represented as a set of (possibly infinite) sequences of events; each such sequence denotes an "accepted" run or execution.</p><p>41n the special case that the duration is zero, the start is treated also as a completion.</p><p>We are finished if the chosen event is the start of an internal activity. However, some care is required when the event is an IO, say ELo. In particular, the partner machine must also be added to the set, with the same IO transition selected. But, if the partner was already in the set (due to an earlier selection of an IO or start internal activity), then the original IO, E,,, is eliminated from contention and another choice is made, if available; if this process exhausts the front of the NEL list, i.e., all elements at the head of the list have been eliminated, then the machine will not get executed at this time.</p><p>The worst case occurs when every NEL has r elements, all with the same next event time, and every element is an IO involving the same machine M . Constructing the set of executable machines and events is then an O(m, x r ) process in the worst case: M I successfully makes its first selection and also inserts the 1 0 partner, A d 2 say, in the set; then M3 through iLl,i, all fail after checking all of their r elements (because they do IO with MI).</p><p>Phase 3 is straightforward and has a time complexity of O(m). Thus the worst case time for each iteration is O ( m</p><formula xml:id="formula_11">x r ) + O ( m x r ) + O ( m ) = O(nt x r ) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. EXAMPLE SPECIFICATIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Mouse Clicker Recognizer</head><p>The purpose is to specify a recognizer for a single button mouse, that distinguishes between single clicks, double clicks, and selections. This is an interesting application because it deals exclusively with IO signals (no internal activities) and because the required signal classification is based solely on the relative times between signals.</p><p>A single click is defined when the time between pressing the button down ( D event) and releasing it (U event) is less than a given time interval tsc. A double click is two single clicks separated by a time interval less than a given t ~c . M's behavior, equivalent to that of the user controlling the mouse, is to emit a D signal at any time after entering the Up state (a is selected from [U. m]) and then to write U at some bounded time afterwards ( b is in [0, max-hold-time]). Note that the use of <ref type="bibr">[a] and [b]</ref> implies that an immediate "rendezvous" is made by R. Intervals should really be employed instead, e.g., [ a , a + deltn-U] and [ b , b + deltab], else the system could deadlock. (For example, a deadlock could occur if R reached its Home state too late after a U.) D I , Single, and D2. For example, both the RTR and U events could occur simultaneously at tsc in state D1? It is convenient to abbreviate a simple ,-hain of several state changes by a number Of trains can be in the area at One time.6 The problem is to ensure that the gate is closed whenever there are single transition; for example, D1 to Home can be described by a single transition: RTR? [tsc] </p><formula xml:id="formula_12">/ SS! [O] ;U? ;SE! [O]</formula><p>trains in the area-a physical safety requirement; and to keep the gate open if there are no trains in the area-a physical The chain from Single to Home and the two chains from D2 to Home can be similarly condensed. liveness requirement (i.e., automobiles may eventually cross the track).</p><p>The specification machines and their interacting channels</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Train Crossing Gate</head><p>This is an extension of a monitoring and control problem described in <ref type="bibr">[16]</ref>. It illustrates the use of guards and internal activities, as well as timing constraints. A (1 -directional) railway track crosses a road. At the crossing point, there is a gate that may be lowered or raised, under computer control. At some point, say a few hundred yards, before the crossing, a sensor can detect that a train is entering the crossing area. When a train leaves the crossing area, say a few hundred yards after the crossing point, the exit is detected by another sensor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>' t s ~</head><p>and t ~c should actually be replaced by t S r -6 and frjch , but as long as il is small relative to t S c and f D r , one need not bother with this technicality.</p><p>are drawn in Fig. <ref type="figure">9(a)</ref>. The external part of the system is represented by the train entering sensor Se, the train leaving sensor S1, and the gate G. The computer system has a monitor M that keeps track of the number of trains in the area via trin and trout signals, and a controller C that controls the gate with opengate (og) and closegate (cg) commands. The CRSM's are given in Fig. <ref type="figure">9(b)</ref>. The Se machine will output train-in signals trZTL according to some train interarrival time expression given by a; for example a could be a random number chosen between a pair <ref type="bibr">[x, y]</ref>. S, will also signal to Si so that it can expect a train exit in the future. On being "armed" by a tr signal, S l is prepared in state F to sense train exits and pass the signal trout to M , as well as for more entries. b could 6For example, imagine an area several hundred yards long deluged by a convoy of single engineizero car trains. be simply zero, for a loose specification; more accurately, b is a function of c, train speeds, and train entry times. The count c is the number of trains having entered but not left the area at any time. The gate G ignores og commands when open and cg commands when closed; otherwise, a cg command causes the gate to physically close, taking z units of time, and an og command opens the gate. The abbreviations mentioned in the last example are used thoughout.</p><p>The M machine closely resembles Sl, in that both keep track of the state of the area using a train count. The difference is that M must monitor the area state in order to send appropriate open and close messages to the controller-a required behavior; the Sl machine, however, is a simulation of the real behavior of a physical device. The controller C just passes its signals to the gate. A more elaborate and interesting controller would also monitor the correct operation of the gate (with appropriate gate sensors), for example, to ensure that the gate is not stuck in one of its positions. All computation times in this example are specified as zeros because the granularity of time for the other activities is so much larger than the expected computer time as to make the latter insignificant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Process Control</head><p>Many interesting features of real-time process control systems are described in <ref type="bibr" target="#b9">[12]</ref> using an informal state machine model. For our purposes, their examples can be rewritten to illustrate CRSM facilities for message passing with data, and for expressing timing constraints and errors. Their sample problem is to express software requirements for "controlling the coolant temperature of a reactor tank by moving two independent control rods." A temperature sensor sends the coolant temperature to a controller whenever the temperature changes by CO K. At least 30 s must elapse between rod movements. The task of the controller is to maintain the temperature at a given C" K.</p><p>A partial view of the system machines is shown in Fig. <ref type="bibr">lO(a)</ref>. (Note that <ref type="bibr" target="#b9">[12]</ref> does not use state machines for the environment descriptions-our machines TANK, SENSOR, and RODS.) The TANK, SENSOR, and RODS machines given in Fig. <ref type="figure" target="#fig_10">10(b</ref>) simulate the (partial) behavior of the reactor tank, temperature sensor, and rods. For the TANK machine, ChangeTemperature computes the coolant temperature (degrees) according to some physical model and sends it to the SENSOR approximately every a units of time. If the temperature change equals the threshold c, the SENSOR will send the new temperature to the CONTROLLER. However, the sensor may also fail (simulated by a Boolean function sensor-fail) and send either a physically meaningless temperature (e.g., below -273' K or above 500" K) or one that violates the c constraint. In the RODS machine, the rods are assumed to take b s to physically move up or down ( b &lt; 30).</p><p>The CONTROLLER (Fig. <ref type="figure" target="#fig_1">1O(c</ref>)) has the same functionality as that explained in Fig. <ref type="figure" target="#fig_6">6</ref> and the preceding pages in <ref type="bibr" target="#b9">[12]</ref>; namely, it deals only with Rod 1 under normal (nonstartup) operation, contains a substantial amount of checking for the validity of data and its time of arrival, and is only partially specified (no transitions from states Error and Temp Stable). The following definitions are used:</p><formula xml:id="formula_13">Valid12 = ValidTemp A ValidTime ValidTemp = (-273 5 d 5 500) A abs(d -oldd) = c ValidTime = (newt -oldt) 2 tmin</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.">Other Forms of Communications</head><p>Our model assumes that all communication is synchronous, 1-way, and has a unique sender and receiver. We show here how other useful forms can be specified easily. In each case, a communications handler machine is inserted between a sender and a receiver to exhibit the desired behavior.  First, asynchronous communications with a nonblocking send and a blocking receive can be approximated using a Buffer machine, as shown in Figs. <ref type="figure">2</ref> and<ref type="figure" target="#fig_5">4</ref>, by choosing a large enough value (n) for the number of buffers. A message sender (e.g., producer) and receiver (e.g., consumer) would communicate by issuing Deposit and Remove commands, respectively, with time bounds of <ref type="bibr">[O,m]</ref>.</p><p>Suppose next that we wish to describe a simple broadcast mechanism, where a broadcaster machine BC will broadcast a signal to a number of client machines Ul, . . . . U,. This can be accomplished using the broadcast handler BH shown in Fig. <ref type="figure" target="#fig_11">11</ref>. The message e is passed through the target x in BH to the user target y in each U, that is prepared to receive it. BH will broadcast BC's message for b units of time before timing out on the RTBH transition. In this version, if a client repeats a request within a time interval n x b, it may starve some other client.</p><p>Synchronous but undirected one-to-one message passing where a sender sends a message to the first receiver that wishes to accept it can be simulated with a handler as shown in Fig. <ref type="figure" target="#fig_12">12</ref>. The sender would perform an output as in the BC machine of Fig. <ref type="figure" target="#fig_11">11</ref> and the potential receivers would indicate their desires in a manner similar to the clients U, of Fig. <ref type="figure" target="#fig_11">11</ref>. To avoid a deadlock when no client wishes to receive a message, an RT transition could also be inserted in the handler machine.</p><p>A common policy in some real time systems, especially cyclic ones, is to overwrite stale unused sensor data with the most recent version. Fig. <ref type="figure" target="#fig_3">13</ref> illustrates how a message can be overwritten if not used. A producer (e.g., sensor) produces data approximately every a units of time. A user U requests the data (y) as needed and receives the most recent copy. The handler H overwrites x with the new version. (Aside:</p><p>Deadlock is avoided provided that An &gt; S and state 5'2 in U</p><p>does not also have a F(y)! <ref type="bibr">[O,d]</ref>, since in the case that U gets selected over the Producer on an H transition, H will service the Producer S units of time thereafter.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. REASONING ABOUT SYSTEM BEHAVIORS</head><p>An operational specification, such as CRSM, exhibits or describes its behavior when it executes. Each execution produces a history trace of events, for example, as in the algorithm presented in Section VI. How does one know, other than by inspection, that the requirements for all traces are indeed embedded in a given CRSM system? The general answer is that the executions must satisfy certain required properties, and that there must be other ways to specify these properties and analyze a system for them.</p><p>Usually, these requirements are stated in the form of assertions involving system state, variables, history, events, and time. At the level of an individual machine, a local assertional logic can be used to make and deduce statements that are true in particular given states. Globally, and sometimes locally, assertions will deal directly with the history of events <ref type="bibr">(IO messages)</ref>. In both the local and global cases, reasoning must include time. In this section, we outline techniques that are compatible with CRSM's to express requirements, but just hint at proof methods.</p><p>One can associate pre-and post-assertions with transitions, using ideas from standard program logic (e.g., [9]). An IO message is just treated as an assignment statement at the destination (receiving) machine and a null (no-op) at the source (sender). To incorporate time, we adapt the techniques first presented in <ref type="bibr">[22]</ref> for timing analysis of programs, as explained below.</p><p>On a state transition T, real time rt is incremented by the transition time t ( T ) . Suppose a transition T goes from state U to state V. Then, the transition is augmented with the indivisible assignment</p><formula xml:id="formula_14">r t := rt + t ( T )</formula><p>and pre-and post-conditions (assertions) could be inserted as follows:</p><p>{ P ( r t , . . .)}T{Q(rtt ( T ) , . . .)} or { P(rt + t ( T ) ) , . . .}T{ q r t . . . .)} where P(rt, . . .) and Q ( r t . . . .) are assertions involving realtime and other variables, that must follow from the transition type. For example, if T i s a sample assignment, z := ezpr, and &amp; ( r t , . . .) = Q ( r t , x ) , then P(rt.. . .) = &amp;(rt + t ( T ) , expr). Guards are used on the preconditions.</p><p>If T is an internal activity say C [ a l , a*], then the transition time is</p><formula xml:id="formula_15">t ( T ) = s + a, a in [ a l . a 2 ] .</formula><p>An IO activity is similar except that it may deadlock; if T is an input E(x)? <ref type="bibr">[ul,a2]</ref>  if IO is deadlocked. Happily, one can be more predictable in many cases by doing the timing reasoning together for all transitions between two given states U and V. In particular, if one transition is an internal one C [ a l , a z ] , and a second transition is an IO, say E(x)? <ref type="bibr">[bl, b 2 ]</ref> or E(expr)![bl, bz], then provided that bl = 0,' we have</p><formula xml:id="formula_16">rt := rt + S + c , c in [O. riiax(a2. b 2 ) ]</formula><p>at the end of the transition. Another common case is with an IO transition, such as the above, and a timeout transition, say RZ? <ref type="bibr">[b]</ref>. This yields a transition time of S + c, c in [0, min(b2, For more global reasoning involving the history of events in the system it is convenient to define a history sequence H(E) for each channel E. H(E) at time t is the sequence of events that have occurred on channel E up to and including t: b)l.</p><p>H ( E ) = ( ( ' U l , t 1 ) , ( <ref type="formula">7</ref>  Yet another way to express machine and system properties is through some form of regular or extended regular expressions over the event symbols of the system (e.g., [1],[ 211). For example, the R machine of Fig. <ref type="figure">8</ref> accepts the event strings generated by the regular expression:</p><formula xml:id="formula_17">H ( D C ) +-H ( D C ) c a t ( ( , t ) ) * emitDCatt.vpartisempty. * 1 if and only if 1. # H ( D ) = # H ( U ) . # H ( U ) 2 2 /* at least 2 clicks*/</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">( t # H ( U ) -t # H ( D ) ) 5 tSCA(t#H(G)-l -t # H ( D ) -l ) 5 tsc</head><formula xml:id="formula_18">( D ((RTR ss U S E ) u(U ((RTR SG) u(D ( ( U D C ) U(RTR SG ss U S E ) ) ) ) ) ) *</formula><p>In the train example, the environmental constraint that the number of trains entering the area must always be greater than or equal to the number leaving can be expressed by the flow expression:</p><p>(trlntrout) 0 where @ is the closure of the shuffle operator, i.e., it denotes zero or more interleaves (shuffles) of the expression with itself. The global requirement that the cg command should follow the first entering train and that the og command should follow the last leaving train can be described by the flow expression:</p><p>The system of machines { S e , Sl, M ; C, G} must generate an event history consistent with this.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ix. SOME PROBLEMS AND ISSUES</head><p>Our CRSM specification scheme, as defined so far, still needs some further development, analysis, and testing. For example, there is no facility for structuring a system of machines or for grouping components of individual machines into higher level entities. We intend to borrow ideas from statecharts <ref type="bibr">[8]</ref> and Modecharts [ 141 to provide such a structuring mechanism. One new problem here is whether and how to associate timing properties with higher level entities, e.g., superstates, such that timing constraints at one level are consistent with those at lower and higher levels. If individual machines are permitted to have independent, concurrently executing components, then there is the issue of how to define unique communications channels at each level and whether or not communication is possible between different levels.</p><p>There are also some benefits in combining state-machine methods with object-oriented specifications, e.g., [2],[15], <ref type="bibr">[19]</ref>. An encapsulated object that exports, imports, and inherits various properties has also proven to be a manageable abstraction for dealing with the semantics of components. In an object-based approach, communications consists of sending and receiving method or operation invocations-essentially calls on the procedures exported by the object. An object methodology potentially provides a natural structuring process for systems, but needs to be studied further within the framework of CRSM's. The statechart and object schemes also have convenient graphical representations that should be useable here.</p><p>Several proposed specification schemes have explicit mechanisms for modeling interrupts <ref type="bibr">(e.g., [6]</ref>). In CRSM's, internal activities cannot be interrupted. However, an interrupt can be modeled in a CRSM by decomposing an internal activity into a chain of atomic (uninterruptible) activities. For example, a computation C[al. Q] might be broken into two indivisible parts C l [ a l l . a 1 2 ] and C2[a2l.a22], where a 1 = a l l + (121 and a2 = a12 + n,22; then C could be interrupted by an interrupt I between G1 and C2 using the specification in Fig. <ref type="figure" target="#fig_5">14(a</ref>). In the figure, F is a small time interval, used to assure that the interrupt receives priority.' A notation similar to that used in statecharts could be employed to represent interrupts emanating from longer chains or from superstates. Alternatively, as shown in Fig. <ref type="figure" target="#fig_5">14(b</ref>), a computation C can be modeled by a "server" machine that receives a Cstart message to initiate C and sends a CfiVLjS,, message upon completion. If an interrupt or fault I occurs during C's execution, the client machine receives it immediately. More experience is necessary to determine whether or not a separate interrupt facility is desirable.</p><p>In an earlier version of CRSM's, the start of an internal activity was ignored and the completion was interpreted in the same way as an IO with a fictitious partner. For example, an internal activity C [ ( L ~, was treated as an IO, say C? <ref type="bibr">[h]</ref> with b in [al ~ a 2 ] . This had a pleasant consistency and, incidentally, permitted a simple specification of interrupts. However, the idea was abandoned because of the following practical implication: it seems that all internal activities possible from a given state must proceed in parallel until a selection is madein which case, the ones that were not selected must be aborted or "undone" in some manner.</p><p>The reasoning approach discussed in the last section requires a more formal development and, eventually, some software tools to aid in checking and proving assertions. We expect that some of the ideas from real-time logic (RTL) [13] can be adapted to CRSM's. A longer term goal in this area is to demonstrate that implementations are consistent with 'This trick would not be necessary if I/O was given priority over internal commands. This changc is being seriously considered. specifications, where implementation timing constraints are expressed within the software timing schema model developed in <ref type="bibr">[22] and [23]</ref>, which is compatible with the CRSM method of treating time for internal computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. SUMMARY</head><p>We have introduced a new notation for specifying requirements of real-time systems. CRSM's have a number of desirable properties-they handle concurrency and synchronization; they have a uniform and complete mechanism for describing timing properties; they are executable and computationally universal; they are state-based with a natural graphical representation; they are amenable to formal analysis; and they permit straightforward descriptions of given and required behaviors. Current work includes extending the notation to provide a structuring mechanism, testing and refining our simulator, and developing formal reasoning techniques.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Manuscript received November 1, 1991; revised June 2, 1992. This work was supported in part by the Office of Naval Research under Grant N00014-89-5-1040. Recommended by R. Kemmerer and C. Gheui. The author is with the Department of Computer Science and Engineering, University of Washington, Seattle, WA 98195. IEEE Log Number 9202410. 0162-8828/92$03</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Global view of a system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Timed IO. (a) IO is possible. (b) IO is not possible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Let tLr = 7 ,</head><label>7</label><figDesc>[ a l , a21 = [l, 61, t b -= 9, and [ b l , b 2 ] = [2, 131. Then IO is possible only at t = inax(7+ 1 , 9 + 2 ) = 11. (11 &lt; 7 + 6 , l I &lt; 9 + 13).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Timed state machines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 5. Real-time clock machine</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Discrete time computer clock.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Doubleclicks do not overlap and override single clicks. Finally, if the time between a D and a U event is larger than tsc, a selection is defined. This example was originally inspired by the double clicker used in[3]; we used a program version in[22].The mouse clicker system is specified globally in Fig.8(a). The mouse device M (or user) sends D and U events to the recognizer R. R , in turn, will send single click events (SC) to a Single Click Handler, Double Click Events (DC) to a Double Click Handler, and selection start (SS) and selection end(SE)    events to the selection handler. The CRSM's in Fig.8(b) describe the given behavior of M and the required behavior of R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 .Fig. 9 .</head><label>89</label><figDesc>Fig. 8. Mouse clicker system. (a) Machines and events. (b) CRSM's for M and R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Part of coolant controller requirements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Broadcast mechanism.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Undirected 1-1 message passing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Fig. 13. Overwriting messages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>RT</head><label></label><figDesc>Fig. 14. Modeling an interrupt I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>machines Producer and Consumer through two channels Deposit and Remove, respectively. Buffer has three states Bo, B1, and B2, with Bo as starting state. All internal activities of Buffer are computational. The IO Deposit can occur if Producer is in state PI, Buffer is in Bo, and full &lt;</head><label></label><figDesc></figDesc><table><row><cell>Buffer</cell><cell>in:=in+l(mod n); full:=full+l</cell></row><row><cell>in:=out:=full:=O</cell><cell></cell></row><row><cell cols="2">out:=out+l (mod n); full:=full-1</cell></row><row><cell>Producer</cell><cell>Consumer</cell></row><row><cell></cell><cell>[ t m i n ( C ) ? tmax( C ) ]</cell></row><row><cell></cell><cell>indicating that the duration d of C is somewhere in the interval</cell></row><row><cell></cell><cell>(b)</cell></row><row><cell cols="2">Fig. 2. Non-timed state machines: Buffer example. (a)</cell></row><row><cell cols="2">Three interacting machines. (b) State machine details.</cell></row><row><cell cols="2">variable. Output takes the form:</cell></row><row><cell cols="2">( name )( ( message-components ))!</cell></row><row><cell cols="2">An IO can occur only if the event names of the communi-</cell></row><row><cell cols="2">cants match and the target type is compatible with the message</cell></row><row><cell cols="2">components. For example, M I issues an input E ( z ) ? and</cell></row><row><cell cols="2">M2 sends an output E(ezppr)!. MI or M2 may have to wait</cell></row><row><cell cols="2">until communication is possible. After the IO occurs, they</cell></row><row><cell cols="2">both continue concurrently. The result of the IO is equivalent</cell></row><row><cell>to the assignment</cell><cell></cell></row><row><cell></cell><cell>z := ezpr</cell></row><row><cell cols="2">on the input machine M I .</cell></row><row><cell cols="2">Fig. 2 shows a simple example of a state machine Buffer,</cell></row><row><cell cols="2">which interacts with n. If the IO transitions occur, they occur simultaneously on</cell></row><row><cell cols="2">both machines with the effect:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>. . . , ( ~~r ~, t r ~) ) . ~~</head><label></label><figDesc>~2 , t 2 ) . 'U, is the value of the message component of the IO at time t,.' One common form that required properties Requirements for both the Mouse Clicker and Train Crossing Gate examples of the last section can be formulated in this way. Consider first the Mouse Clicker (Fig.8) and the requirements for emitting a double-click event DC at time t. Formally, the requirements are:</figDesc><table><row><cell>2 0</cell></row><row><cell>where n is the length of the sequence (denoted #H(E), so that</cell></row><row><cell>t, = t # H ( ~) )</cell></row></table><note><p>and have is "The system should produce an event E(x) at some time t in the time interval (t'. t' + At] if and only if some assertion A(H(E;), H(Ej), H(Ek), . . . ) on events Ei, Ej, Ek, . . . became true at time t' &lt; t."</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>The notation cat means sequence concatenation.One requirement for the train example (Fig.9) is: "The gate must be closed if there are trains in the area.""Send a cg command to close the gate if and only if the gate is not closed or closing and a train enters the area. The cg command must be activated within At time units of the</figDesc><table><row><cell cols="2">The assertion is given by 1, 2, 3, 4, and 5 and is the form</cell></row><row><cell>A(H(D), H(U), H(DC)). train entering time." which can be translated to:</cell><cell></cell></row><row><cell cols="2">Formally, this may be expressed</cell></row><row><cell>H ( c g ) t H ( c g ) cat (, t )</cell><cell>/*generate next cg*/</cell></row><row><cell>if and only if</cell><cell></cell></row><row><cell cols="2">1. t # H ( o g ) 2 t#H(,,)/*gate is open or opening*/</cell></row><row><cell cols="2">2. #H(tr;,,) &gt; # H ( t r O u t ) /*train(s) in the area*/</cell></row><row><cell cols="2">A ( t -t # H ( t l , , ) ) 5 At /*emit cg in time*/.</cell></row><row><cell cols="2">The assertion A(H(og), H(cg), H(trZT1), H(troUt)) is given by</cell></row><row><cell>1 and 2.</cell><cell></cell></row><row><cell>/*2 single clicks*/</cell><cell></cell></row><row><cell>3. (t#H(D) -t # H ( ~) -l ) 5 t D c /*separated by less than</cell><cell></cell></row><row><cell>4. (t -t # H ( C ) ) 5 At /*DC is emitted within At of the</cell><cell></cell></row><row><cell>last U.*/</cell><cell></cell></row><row><cell>5. if # H ( D C ) &gt; 1 /*at least one previous DC*/ then</cell><cell></cell></row><row><cell>t#H(DC)-l &lt; t # ~( ~) --l /*no overlap*/.</cell><cell></cell></row></table><note><p><p>t D c * / 'If bl # 0, then C is always selected.</p>notation is similar to that used for traces in CSP [ l l ] .</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The author is grateful to H. Callison, T. Craig, C. Park, and S. Raju for their comments and suggestions. Thanks are also to the referees for their helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Constraint expressions: Adding analysis capabilities to design methods for concurrent software systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Avrunin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="278" to="292" />
			<date type="published" when="1986-02">Feb. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Graphical specification of object-oriented systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bear</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECCOPiOOPSLA 90, SIGPLAN Notices 25</title>
		<meeting>ECCOPiOOPSLA 90, SIGPLAN Notices 25</meeting>
		<imprint>
			<date type="published" when="1990-10">Oct. 1990</date>
			<biblScope unit="page" from="28" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Squeak: A language for communicating with mice</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pike</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Davies</surname></persName>
		</author>
		<author>
			<persName><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 19</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Gabrielian</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1985-07">July 1985. Aug. 1989. May 1991</date>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="51" to="60" />
		</imprint>
		<respStmt>
			<orgName>Oxford University Computing Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Monograph PRG-75</note>
	<note>Comtn. of ACM</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Communicating shared resources: A model for distributed real-time systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gerber</surname></persName>
		</author>
		<author>
			<persName><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Real-Time Systems Symp</title>
		<meeting>IEEE Real-Time Systems Symp</meeting>
		<imprint>
			<date type="published" when="1989-12">Dec. 1989</date>
			<biblScope unit="page" from="68" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A unified high-level Petri net formalism for time-critical systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mandrioli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Morasea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pezzk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="160" to="172" />
			<date type="published" when="1991-02">Feb. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Statecharts: A visual formalism for complex systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="231" to="274" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="576" to="580" />
			<date type="published" when="1969-10">Oct. 1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page">666677</biblScope>
			<date type="published" when="1978-08">Aug. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall International</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Software requirements analysis for real-time process control systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jaffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leveson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Heimdahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Melhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="241" to="258" />
			<date type="published" when="1991-03">Mar. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Safety analysis of timing properties in realtime systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jahanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mok</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="890" to="904" />
			<date type="published" when="1986-09">Sept. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Modechart: A Specification Language For Real Time Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jahanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mok</surname></persName>
		</author>
		<idno>RC 15140</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Soffware Eng</title>
		<imprint>
			<date type="published" when="1989-11">Nov. 1989</date>
		</imprint>
	</monogr>
	<note type="report_type">IBM Tech Report</note>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Objectoriented specification of reactive systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jarvinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sakkinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Systa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th IEEE Conf: Software Eng</title>
		<meeting>12th IEEE Conf: Software Eng</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="63" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Safety analysis using Petri nets</title>
		<author>
			<persName><forename type="first">N</forename><surname>Leveson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stolzy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="386" to="397" />
			<date type="published" when="1987-03">Mar. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An introduction to inputloutput automata</title>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tuttle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CWI -Quarterly</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1988">1989. Nov. 1988</date>
		</imprint>
		<respStmt>
			<orgName>Laboratory for Computer Science, MIT</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Memo. MITILCSITM-373</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Modeling and verifying real-time embedded computer systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ostroff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wonham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Real-Time Systems Symp</title>
		<meeting>IEEE Real-Time Systems Symp</meeting>
		<imprint>
			<date type="published" when="1987-12">Dec. 1987</date>
			<biblScope unit="page" from="124" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Formal object-oriented specifications for real time systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Raju</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-06">June 1991</date>
		</imprint>
		<respStmt>
			<orgName>Dept. Computer Science and Engineering, Univ. Washington</orgName>
		</respStmt>
	</monogr>
	<note>Internal Working Paper</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A timed model for communicating sequential processes</title>
		<author>
			<persName><forename type="first">G</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP &apos;86</title>
		<meeting>ICALP &apos;86</meeting>
		<imprint>
			<publisher>Springer-Verlag LCNS</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">226</biblScope>
			<biblScope unit="page" from="314" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Reasoning about time in higher-level language software</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="1231">May 1978. July 1989. 1231</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="875" to="889" />
		</imprint>
	</monogr>
	<note>Deterministic timing schema for parallel programs</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m">Fifth Intern. Parallel Proc. Symp</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1991-04">Apr. 1991</date>
			<biblScope unit="page" from="56" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">He was a visiting professor at ETH, Zurich, and at the University of Paris, and was a member of the faculty of the Department of Computer Science at Cornell University. He joined the faculty of the Department of Computer Science and Engineering at the University of Washington in 1971</title>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">C</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Sc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">His current research interests are in operating systems, real-time systems, software engineering, and software specification methods</title>
		<meeting><address><addrLine>Stanford, CA</addrLine></address></meeting>
		<imprint/>
		<respStmt>
			<orgName>D. degree in computer science from Stanford University</orgName>
		</respStmt>
	</monogr>
	<note>engineering physics from the University of Toronto, and the M.S. degree in mathematics and Ph</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
