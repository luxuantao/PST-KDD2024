<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Blending Object-2 and Timed CSP: An introduction to TCOZ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Brendan</forename><surname>Mahony</surname></persName>
							<email>brendan.mahony@dsto.defence.gov.au</email>
						</author>
						<author>
							<persName><forename type="first">Jin</forename><forename type="middle">Song</forename><surname>Dong</surname></persName>
							<email>jinsong.dong@cmis.csiro.aii</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Information Technology Division Defence Science and Technology Organisation Salisbury</orgName>
								<address>
									<addrLine>SA 5 108</addrLine>
									<postCode>+61 8 8259 6000</postCode>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Mathematical and Information Sciences C&apos; wealth Science &amp; Ind&apos;l Research Organisation Canberra</orgName>
								<address>
									<addrLine>ACT 260 1</addrLine>
									<region>Australlia</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Blending Object-2 and Timed CSP: An introduction to TCOZ</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D164933277DDCE1ED3253AC0D00BD97E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Real-time</term>
					<term>concurrency</term>
					<term>specification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Object-Z is an extension to the Z language designed to facilitate specification in an object-oriented style. It is an excellent tool for modeling data and algorithms, but its object semantics are single threaded and operations are atomic. Therefore, it is difficult to use Object-Z to capture the behaviour of concurrent real-time reactive systems. On the other hand, Timed CSP is good at modeling real-time concurrent behaviour, but has little support for modeling the state of a complex system. This paper introduces a blending of Object-Z and Timed CSP, known as TCOZ. The blended notation is particularly suited for specifying complex systems whose components have their own thread of control.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A complex system often has an intricate system state and a control structure involving concurrency and real-time interaction.</p><p>Object-Z [4] is a variant of the 2 formal specification language designed to facilitate the modular design of complex data and algorithms through the application of object oriented techniques. The main aim of Object-Z is to improve the clarity of large specifications through enhanced structuring. Object-Z has a single threaded semantics and operations are atomic. There is no notion of duration associated with operations, just the abstract notion of termination. Therefore, it is difficult to use Object-Z to model concurrent real-time reactive systems.</p><p>Timed CSP [I61 is an extension of Hoare's Communicating Sequential Processes (CSP) process algebra notation. It builds on CSP's strengths in modeling process control issues, such as concurrency and synchronisation, by adding primitives for modeling real-time. However, CSP has only the most rudimentary mechanisms for modeling data and algo-rithmic issues and it is cumberso'me to capture the state of i i complex system. This paper introduces a blending of Object-Z and Timed CSP, called Timed Communicating Object-2 (TCOZ). TCOZ builds on the respective strengths of both notations in order to provide a single elegant notation for modeling both state and process aspects of complex systems. The notioii of blending Object-Z with CSP h.as been suggested independently by Fischer <ref type="bibr" target="#b6">[6]</ref> and Smith <ref type="bibr">[ 181.</ref> TCOZ is novel in that it includes timing primitives and supports the modeling of true multi-threaded concurrency.</p><p>To facilitate our discussion the common ,example of a firstidfirst-out queue is used. We first discuss the queue without and then with timing constraints. This example is used through out the paper to illustrate the differences betweein and to demonstrate the advantages and disadvantages of the Object-Z, Timed CSP, and TCOZ notations respectively. Modeling the same system in e,ach of the notations allows the reader to concentrate more on understanding the relative merits of the notations and less on understanding the sub'- tleties of systems being modeled. The main body of the paper thus consists of three sections of similar structure. In Section 2 the Object-Z notation lis briefly introduced and the queue example used to demonstrate its weakness in model,ing timing and concurrency issues. In Section 3 the Timed CSP notation is briefly introduced and the queue example used to demonstrate its weakness in the modeling of CONl- plex data and algorithms. In Section 4, the blended notation, TCOZ, is introduced and the queue example used to show how it uses the strengths of the individual notatioru to address their respective weaknesses. l'inally, the multithreaded capabilities of TCOZ ;Ire illustrated by a buffered consumer/producer process example. This paper is aimed at readers with some familiarity wirh mathematical approaches to th.e modeling of data, algo- rithms, and process control issues, though it should not tie necessary to have any detailed knowledge of the Object-Z and Timed CSP notations.</p><p>tions through enhanced structuring.</p><p>The main Object-Z construct is the class definition. A class is a template for objects of that class: for each such object, its states are instances of the class' state schema and its individual state transitions conform to individual operations of the class. An object is said to be an instance of a class and to evolve according to the definitions of its class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Simple Queue Example</head><p>Consider the following specification of the generic class Queue.</p><p>-Queue[X]</p><formula xml:id="formula_0">items : seqX A h : X items # ( ) + h = head(items) = ( ) Join A (items) item? : X Leave A (items) item! : X item! = h A items' = tail(items)</formula><p>The state schema is nameless and contains declarations (the attributes) above the short dividing line and a predicate (class invariant) below the line.</p><p>In this example, it has one (true) attribute items denoting a sequence of elements of the generic type X. The Z toolkit supports sequences with the following mechanisms: the set of finite sequences over type X is written seqX; sequence constants are written as list of constants enclosed in angled brackets, eg. (2,3,3,1) is an integer sequence, ( ) is the empty sequence; sequences may be joined using concatenation, eg. s1 -sz; the first element of a sequence is the head and rest of the sequence is its tail.</p><p>The queue state also has secondary attribute h representing the head element of the queue, when it is non-empty. Syntactically, the declarations of secondary attributes appear below the A separator placed in the declaration section of the state schema. For a detailed discussion on secondary attributes</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>see [31.</head><p>The initial state schema is distinguished by the keyword INIT. The state schema is implicitly included in the initial state schema. In this example, an initialised queue contain!; no elements of X (i.e. items is the: empty sequence).</p><p>The remaining two schemas are operation schemas. Operation schemas have a A-list of those attributes whose values may change. By convention, no A-list means no attribute: changes value. Every operation schema implicitly includes the state schema in un-primed form (the state before the op.. eration) and primed form (the stalte after the operation). Implicitly associated with each schema is a precondition which describes the initial states for which there exists some final state satisfying the schema predicate.</p><p>In this example, operation Join appends a given input item? to the existing sequence of items. Operation Leave outputs :i value item! defined as the head of sequence items and reducer; items to the tail of its original value. The precondition of Join, written pre Join, is true anti pre Leave is items # ( ).</p><p>Note that the values of the secondary attributes are always subject to change. This is achieved by implicit inclusion OF secondary attributes in the A-list of every operation. In this case, the value of h is always siubject to change wheneve.r operation Join or Leave is invokeid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Transition System Interpretation</head><p>The standard be,havioural interpretation of Object-Z objects is as transitiori systems <ref type="bibr" target="#b18">[17]</ref>. A behaviour of a, transition system consists of a series of state transitions each effected by one of the class operations. A Queue object starts with items empty then evolves by successively performing either Join or Leave operations. This is sometimes expressed semi-formally by an equation such as Qbeh (Join 0 Leave); Qbeh.</p><p>Here Qbeh represents the behaviour of the Queue, (-0 -) represents a choice between operations, and (-; -) represent,s sequential composition'. Operations in Ob,ject-Z are atomic, only one may occur at each transition, and there is no notion of time or duration. It is difficult to use the standard Object-Z semantics to model a queue for which the Leave and Join operations have duration, let alone one for which those durations may overlap.</p><p>A crucial point is that the operations enabled at each point are those whose preconditions are satisfied by the currant state. Thus if the items list is empty the Leave operation may not occur. This entwining (of behavioural control matters with algorithmic matters creates unnecessary complexity in the design process and fails to promote a clear separation of concerns. For example, in orcler to ensure that operations occur in some desired order the designer must painstakingly craft the preconditions of all the operations in a class so as to ensure the desired interactions and may evcn need to add unnecessary process state in order to represent control state. I:t is important to note that this use of preconditions to control the sequencing of transitions is incompatible with standard algorithmic refinement techniques which would allow arbitrary weakening of preconditions, thus playing havoc with the delicate interplay of preconditions in the original specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Timed Object-Z</head><p>Suppose that a queue has the following timing properties. Firstly, that it takes a small but non-zero time (tl and tj respectively) to update the internal state during a Leave or Join operation. Secondly, that each element of the queue becomes stale if it is not passed on within C time units of being added to the queue and that stale elements should never be passed on.</p><p>Such issues cannot be adequately addressed in the standard interpretation of Object-Z, extended conventions for modeling time and environment are required. One such approach is the Timed Object-Z notation <ref type="bibr" target="#b1">[2]</ref>. Here, various Z-based approaches for specifying real-time requirements [5, 131 are integrated into the Object-Z notation.</p><p>Describing time and other physical quantities in terms of standard units of measurement is an important aspect of ensuring the completeness and soundness of specifications of real-time, reactive, and hybrid systems. In order to support the use of standard units of measurement, extensions to the Z typing system suggested by Hayes and Mahony [7] are adopted. Under this convention, time quantities are represented by the type</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T==ROT,</head><p>where R represents the real numbers and T is the SI symbol for dimensions of time. Time literals are expressed in the usual way with a value and a unit symbol and all the arithmetic operators are extended in the obvious way to allow calculations involving units of measurement. Timed Object-Z extends Object-2 in two ways. Firstly, environmental interactions are modeled as functions of time and are included in the system state. In the queue with timeouts the environment is modeled by functions env, and env1 representing the willingness of the environment to participate in addinghemoving a particular item to/from the queue respectively. The second extension is to include a global real-time clock, conventionally represented by a distinguished state attribute now. The clock may only be updated during an operation and the next operation must start immediately the last is finished. Inheritance in Object-2 is a mechanism for incremental specification, whereby new classes may be derived from one or more existing classes. The timed queue is defined by inheriting the simple queue with re-definitions of the operations Join and Leave in order to reflect interactions with the environment and the passage of time. Since some operation must always be in action, a new operation Drop is introduced to timeout queue items and progress time to the next interesting action. The length of the Drop operation is determined by a secondary attribute idle, which computes the amount of time until the environment is ready to allow a Join or Leave operation.</p><p>-TimedQueue[X] -</p><formula xml:id="formula_1">Queue[X x T][redef: Join, Leave] env,, envl : T -n X A now : T [current time] idle : T [time before next Join/Leave] let rm = { t : dom(envj U envl) I It &gt; now} rm # 0 + idle = min(rm) --now Join A (items) item? : X now E dom envj A env,i(now) = item? now' -now = tj items' = ds(tj, items) ,-. ((item?, C)) Leave A (items) now E domenvr A env1(now) = item! now' -now = t 1 A item! =jrst(h) A (items) items # 0 + now now' -now = idle items' = ds(idle, items) envl</formula><p>The Z toolkit supports tuples 0 1 : vectors with the following mechanisms: the cross product of X and Y is written X x If, elements of which consist of pairs ( x , y ) ; the first element of tuple t isjrst(t) and the second is second(t). The generiic function ds (drop stale) is defineid as forexamPleds( <ref type="figure" target="#fig_1">2,</ref><ref type="figure">( ( a &gt;</ref>  In this model, changes to data (items) are well captured. However, Timed Object-Z requires interactions with the environment and the progress of time must be micro-managed in a most intrusive manner. A proliferation of additional attributes are required to deal with process control and time resulting in significant over specification of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TIMEDCSP</head><p>Timed CSP [I61 extends the well-known CSP (Communicating Sequential Processes) notation of Hoare <ref type="bibr" target="#b9">[9]</ref> with timing primitives. As indicated by its name, CSP is an event based notation primarily aimed at describing the sequencing of behaviour within a process and the synchronisation of behaviour (or communication) between processes. Timed CSP extends CSP by introducing a capability to consider temporal aspects of sequencing and synchronisation.</p><p>CSP adopts a symmetric view of process and environment.</p><p>Events represent a co-operative synchronisation between process and environment. Both process and environment may control the behaviour of the other by enabling or refusing certain events or sequences of events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Process Primitives</head><p>The primary building blocks for Timed CSP processes are sequencing, parallel composition, and choice.</p><p>A process which may participate in event a then act according to process description P is written</p><formula xml:id="formula_2">a @ t + P ( t ) .</formula><p>The event a is initially enabled by the process and occurs as soon as it is also enabled by its environment. The event a is sometimes referred to as the guard of the process. The (optional) timing parameter, t, records the time (relative to the start of the process) at which the event a occurs and allows the subsequent behaviour, P, to depend on its value.</p><p>Thc second form of sequencing is process sequencing. A distinguished event J is used to represent and detect process termination. The sequential composition of P and Q, written P; Q, acts as P until P terminates by communicating J and then proceeds to act as Q. The termination signal is hidden from the process environment. The process which may only terminate is written SKIP,</p><p>The parallel evolution of processes P and Q , synchronised on event set X is written  <ref type="formula">2</ref>) is implic_itly_taken to describe the solution to the vector recursion p X F ( X ) .</p><formula xml:id="formula_3">No event from X is enabled in P ] [ X ] l Q unless enabled</formula><p>In general, the behaviour of a process at any point in time may be dependent on its internad state and this may conceivably take an infinite range of values. It is often not possible to provide a finite representation of a process without introducing some notation for representing this internal process stale. The approach adopted by CSP is to allow a process definition to be intentionally parameterisad by state variables. Thus a definition of the form represents a (possibly infinite) family of definitions, one for each possible value of n. It is important to note that there is no inherent notion of process state in CSP, but rather that this intentional form of expression is a convenient way to provide a finite representation of an infinite family of process descriptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Queue Example</head><p>A queue is a process with two channels, left and right respectively. Elements are added to the queue through communications on the left channel and removed through communications on the right channel. The sequence of communications on the right channel must be a subsequence of those on the left channel at all times. The difference between the two sequences is loosely referred to as the queue and constitutes the internal state of the queue process.</p><p>Initially the queue is empty.</p><formula xml:id="formula_4">Queue Q( )</formula><p>At any stage a new element may enter the queue or the head of the queue (if any) may leave.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q(</head><p>) left?a : x 4 e(,)</p><formula xml:id="formula_5">Q(/+-ti : x 3 Q(h)-ii-(o) right!h 4</formula><p>Even for such a simple example CSP is superior to Object-Z as a means of describing process control. The allowed sequences of events are clearly and concisely determined by the CSP code, there is no need to calculate preconditions nor is any other form of deep reasoning required to understand the ways in which the queue may evolve., On the other hand the state annotations are quite cumbersome, even in this example. There is no standard support for state modeling in the form of mathematical toolkits and libraries nor modular techniques to constructing and reasoning about complex internal state. For example, the CSP queue is not truly generic.</p><p>Queues with various base types can only be specified by repeating the queue definition for each type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Timing Primitives</head><p>To the standard CSP process primitives, Timed CSP adds two time specific primitives, the delay and the timeout.</p><p>A process which allows no communications for period f then terminates is written WAIT t. The process WAIT^; P is used to represent P delayed by time t.</p><p>The timeout construct passes control to an exception handler if no event has occurred in the primary process by some deadline. The process</p><formula xml:id="formula_6">U + P D{t} Q</formula><p>will pass control to Q if the a event has not occurred by time t, as measured from the invocation of the process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The Queue With Timeouts</head><p>The timeouts queue can be described using delays and timeouts.</p><p>Once again the initial state is represented by the empty sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TimedQueue g TQ( )</head><p>When the first element joins the queue it is stamped with a timeout and the time taken to update th,e process state is represented by a delay.</p><p>TQ( ) g left?a : X + WAIT f, ; TQ(( <ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">c</ref>))</p><p>When the queue is non-empty the process is ready to accept left or right events as per the untimed queue with the exception that staleness stamps are updated with each communication and state update delays are introduced. If no communication occurs before the head of the queue becomes stale:, the stale element is dropped.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TQ((h,i))-ii</head><p>(left?a : X @ t l + WAIT tj;</p><p>right!h@tl -+ WAIT tl; T Q ~v ( f l + . f , , f ~) ) <ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">((h,</ref><ref type="figure">f</ref>)</p><formula xml:id="formula_7">TQd~(fi+i</formula><formula xml:id="formula_8">)-r/)-((~,c)) '1 b { f ) WAIT t d ; ~42dY(f,fL)</formula><p>The advantages and disadvantagies of Timed CSP are thrown into even sharper focus by this example. Timed CSP handles the issues of delays and timeouts simply and elegantly. It is difficult to see how the timeout issue could be treated at all in the standard Object-Z. Thle Timed Object-Z approach results in a too complex model which over specifies this simple system. Note that this example does not even make use of the multi-threading and :synchronisation capabilities of Timed CSP which are clearly well beyond the scope of Object-Z's atomic state transition semantics. On the other hand, the treatment of internal state in the above has become intolerably complex, distracting strongly ffrom the basically elegant treatment of the delay anid timeout issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BLENDING OBJECT-Z AND TIMED CSP</head><p>Object-Z and Timed CSP seem in many ways to complement each other in their capabilities. Object-Z has strong data and algorithm modeling capabilities. The Z mathematical toolkit is extended with object oriented structuring techniques. Timed CSP has strong process control modeling capabilities. The multi-threading and synclhronisation primitives of CSP are extended with riming primitives. Moreover both formalisms are already stro'ngly influenced by the other in their areas of weakness. Object-Z supports a number of primitives which have been inspired by CSP notions such as external choice and synchronisation. CSP practitiorwrs tend to make use of notation inspired by the Z mathematicia1 toolkit in the specification of processes with internal stati:. This is not surprising given their joint associations in the Programming Research Group, Oxford. Another important connection is the well-known duality between the state transiticln behavioural model and the event based behavioural model <ref type="bibr">[8]</ref> which makes it a simple matter to develop complementary semantics for the two languages.</p><p>Given these factors it is natural to consider the possibility of blending the two notations into a more complete approach to modeling real-time and/or concurrent systems. Fischer <ref type="bibr" target="#b6">[6]</ref> and Smith [ 181 have independently suggested CSP-style semantics for Object-Z classes in which operation calls become CSP events. Operation names take on the role of CSP channels, with input and output parameters being passed down the operation channel as values. This view fits nicely with the Object-Z interpretation of operations being atomic, but is therefore not well suited to considering multithreading and real-time. Restricting operations to atomic events completely collapses the concurrent and temporal aspects of operations, everything happens at a single point and instantaneously.</p><p>The approach taken in the TCOZ notation is to model operations as terminating CSP processes and to model objects as non-terminating CSP processes. A simple operation consists of accepting a number of inputs, performing a calculation on the object state, performing a number of outputs, and then terminating. Each input and output communication is represented by a separate event and occurs on a CSPstyle channel. Since the atomic operation's input and output communications are separated in time by calculations on the local state, it becomes feasible to specify the temporal properties of this calculation when describing the operation. Note that the temporal properties of an entire operation are not so easilyspecified. CSP communications require the co-operation of the environment and may in general be deferred indefinitely by a malicious environment. Another advantage of this approach is that, by combining simple operations with CSP operators it becomes possible to represent true multi-threaded computation even at the operation level. The Fischer/Smith approach of identifying operation names with CSP channels is not followed, channels are given an independent, first class role. This allows the communications and control topology of a network of objects to be designed orthogonally to their class structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Extensions to Operation Definition</head><p>The Object-Z operation definition conventions are extended in two ways.</p><p>The first extension is to the variable declaration conventions used in the operation schemas. In order to support fully the CSP channel a new class of declaration is introduced to Object-Z. An input or output parameter may be declared to have occurred on a particular channel. For example, a declaration of the form x? : X o n c within an operation schema not only declares an input parameter x? of type x, but also requires that an input communication c?x must occur before the operation commences state update calculations. Output communications may be declared in a similar manner, except that output communications are not enabled until after the completion of any state update calculations. A variant form of input communication declaration, analogous to the general form of Timed CSP event sequencing, is allowed. A declaration of the form x? : X o n c @ t declares a time variable t in addition to the input variable x?. The time variable t represents the time, relative to the start of the operation, at which the input occurred. For several reasons, including backward compatibility, it is convenient to retain the standard input and output decorations. Variables of the form x? and x! not assigned to channels are called stundard parameters and do not correspond to any CSP event activity.</p><p>In order to allow consideration of the temporal properties of an operation, a distinguished identifier b is introduced to represent the duration of the state calculations performed by the operation. This time is calculated starting from the time of occurrence of the last input communication required by the operation. This convention is adopted because the semantics of Timed CSP mean that communications events may be delayed indefinitely by a malicious environment, so that it is generally not possible to put a hound on the duration of the overall operation. Only the actual state update calculations may be bounded. If the total elapsed time is required in a specification, it may be obtained by placing timing variables on the input communications as described above.</p><p>As an example, consider the specification of the Join operation of the simple queue example making use of these new conventions. The CSP view of the new item input may now be taken, that is that it is communicated to the queue object along a channel left. This is indicated by declaring the item? parameter to be Xonleft. In order to determine the timing characteristics of the operation the condition 6 = tj is added to the predicate part of the operation schema. Otherwise the schema remains unchanged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Join item? X on left</head><formula xml:id="formula_9">I 6 = tj A items' = items -(item?)</formula><p>This operation schema is given a Timed CSP interpretation as a terminating process. Its CSP-style behaviour (ignoring state effects) is similar to left?item</p><p>The second extension is a more radical (at least at first sight) departure from existing Object-Z techniques. Since operations are identified with terminating CSP processes, it is natural to allow their definition in terms CSP primitives, such as event sequencing, as well as through the schema calculus. In the case of the Leave operation, the communication of the leaving item must precede the updating of the queue WAIT tj.</p><p>state. Since the schema convention is for outputs to follow state calculations, this behaviour cannot be described using a simple schema. Instead, the update operation is described using a schema</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remove</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A (items)</head><p>tl A items' = tailitems and the overall leave operation consists of this operation guarded by a communication on the right channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Leave [items # ( )] 0 right!h -+ Remove</head><p>The first part of the definition of Leave is a novel process control primitive known as a state guard.</p><p>Every process definition has (at least) an initial state which may be addressed using schema notation. This is the function of the first part of the expression defining Leave. It is a schema-based method of restricting the action of the process to initial states for which the queue is non-empty. For other states this process will deadlock or block, which is to say refuse any communication.</p><p>Note that the precondition requirement in the Remove schema, though identical, could not achieve the desired restriction on the behaviour of Leave. Failure to satisfy a precondition when control is passed to an operation instead results in divergence, which is to say unspecified subsequent behaviour. Remove places no restrictions at all on its behaviour when the initial queue is empty. The precondition is the state-based equivalent of process divergence and the guard is the state-based equivalent to process deadlock.</p><p>For every operation P.(even those'constructed using the process calculus) the collection of initial states for which the process will not diverge is called its precondition (written pre P ) and the collection of states for which it will not deadlock is called its guard (written grd P).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Schemas vs</head><p>Processes A schema expression describes a relationship on or between process state/% A process expression describes the overall behaviour or evolution of a process. These views are not in general compatible and it is necessary to strictly distinguish the schema calculus from the process calculus. The two exceptions to this are the interpretation of operation schema expressions as terminating processes and the use of initial state schema expressions as state guards. In all other circumstance the schema and process calculi are separate and distinct. For example, if P and Q are operations schema expressions, the expression a + ( P A Q) is legal whilst the expression (a + P) A Q is not. The full power of the schema calculus may be used to construct schema expressions, but once a schema expression has been cast into a process-like role it may no longer act in a schema-like role. Some existing Object-Z schema calculus operators, such as -0 -, -11 -, and -; -, have name-sakes wiith similar semantics in the CSP process calculus, The convention is adopted that it is always the CSP operator that is intended. In most cases, such as -0and -11 -, this is justified by the fact that the schema operator is inspired by the corresponding process operator and that a satisfactory treatment of the operator is only possible in the process semantics. For example, the schema operator -0does not rlespect operation refinement, whilst the process operator -0does respect process refinement. In the case of -; -, the state-based and process-based semantics are fully compatible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Extensions to Classes</head><p>The extensions made to classes derive for the most part from the extensions made to operation definitions.</p><p>Firstly, the state schema convention is extended to allow the declaration of object communications channels. If c is to be used as a communications channel by any of the operations of a class, then it must be declareld in the state schema to be of type chan. Channels are type heterogeneous and may carry communications of any type. Contrary to the conventionis adopted for internal state variablles, channels are viewed a s global rather then as encapsulated entities. This is an essential consequence of their role as communications interfaces between objects.</p><p>The second extension is that as well as operations (terminal[ing processes), non-terminating processes may also be de:scribed. A distinguished identifier MAIN is used to determine the default behaviour of objects of a given class.</p><p>Consider once again the queue example (operations with du- ration). In addition to the list of ,items, the state schema must declare channels left and right. 'The class operations are described as in Section 4. l and are then used to define a M A I N process similar to that described in Section 3.2.</p><p>-Queue[X]</p><formula xml:id="formula_10">items : seqX left, right : chan items # ( ) + h = he,ad(items) Join A (hems) item? : X on [eft A (items) 6 = t r A items' = tailitems Leave 2 [items # ( )] right!h -+ Remove MAIN C p Q 0 (Join 0 Leave); Q</formula><p>If this description is less concise than the standard CSP description of Section 3.2 (though it does avoid the need for the separate "empty queue" process definition), it at least represents a more robust and significantly more scalable treatment of process state. The structure of the process' internal state and communications interfaces are prominently documented. The structured schema based approach to describing state transitions, supported as it is by the full power of the Z toolkit and the schema calculus, is better able to handle large and complex process state than the essentially ad hoc state annotation conventions of standard CSP.</p><p>The conciseness of this description is essentially comparable to the the standard Object-Z description of Section 2.1. Additional aspects of this specification represent elegant descriptions of matters not treated at all in that specification. The standard Object-Z specification merely described a data structure and a collection of operations applicable to that data. The TCOZ specification describes the behaviour of an object evolving through time and interacting with its environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Using Standard Parameters</head><p>As noted in Section 4.1, operations may have standard parameters which are not assigned to any communications channel. In order to make use of such operations in the definition of process behaviour it is necessary to "produce" values for the input parameters and "consume" values from the outputs as part of the process definition. The general method of consuming outputs is to compose an operation with other operations in such a way that its outputs become their inputs. Much of the production problem may of course be addressed in the complementary manner, but it is necessary to have some method for starting off such a chain in the first place. This is achieved through the generalisation of the state guard construct to allow the declaration of new variables. If an operation 0 with standard input parameter i? : X is to be called with value x : X then this may described by [i : X I i = x] 0 Op. Note that the declared variable does not have the "?" decoration, the convention is that such decorations occur only within operation schemas. Input parameters are decorated at the commencement of the operation and output parameters are undecorated at the termination of the operation. If pre, post, input, or output decorations occur in a schema definition it is considered to be an operation schema and cannot appear in a state guard expression. The state guard with local variable takes the place of CSP's intentional external choice. Thus [i : X ] 0 P(i) is used instead of 0 i : X 0 P(i) and [i : XI 0 c.i +-P(i) instead of c?i : X -+ P(i).</p><p>The intentional form of internal choice is not used. Instead the outputs of operations are used. Thus [n! : NI; P(n) is used instead of n n : N 0 P(n) and [n! : NI; c.n -+ P ( n ) instead of c!n : N P(n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The Queue With Timeouts</head><p>Some glimpse of the scalability of the TCOZ notation may be obtained by considering the queue with timeouts example. The time queue model can be defined by inheriting the TCOZ Queue class.</p><p>- The TCOZ specification of this system is of similar syntactic complexity to the simple queue specification in TCOZ. Tlie Join and Leave operations are imodified to ensure that stale items are removed and the Drop operation is added to be in- voked when the head of the queue becomes stale. Each of tlhe operation and process specifications remain simple and elegant. The comparison with the relative jumps in complexlity in the Object-Z and Timed CSP specifications would seem to suggest a higher degree of scalability in TCOZ, blending as it does Object-Z's capabilities for handling data complexity with Timed CSP's capabilities for handling process coin-plexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">A Multithreaded Example</head><p>In order to give an example of the the multi-threaded capabilities of the TCOZ notation, a buffered consumer/producer process is considered.</p><p>A consumer/producer process accepts inputs of type L on its left channel, calculates some function In order to ensure that all inputs are accepted and outputs are received, the process is buffered left and right with queue processes. The buffered process consists of a left buffer, a right buffer, and an internal consumer/producer.</p><p>In order to hookup the buffer queues to the consumer/producer correctly it is necessary to rename the various channels. The renaming convention is essentially the same as for Object-Z and Timed CSP, that is P[u/b] is P with all occurrences of b replaced by U . In order to retain a consumer/producer like interface, the right channel of the left buffer is renamed to ml, the left channel of the right buffer renamed to mr and the left and right channels of the internal consumerlproducer are renamed to ml and mr respectively.</p><p>In order to protect the internal interfaces from environmental interference they are hidden. The hiding notation is again essentially the same as for both Object-2 and Timed CSP, that is ( P \ c ) is P with c protected from external influence. In the case where P is process-like and c is a channel this has the important result of freeing communications on c from the requirement of synchronising with the environment. Thus communications on mr and ml occur as soon as the local processes are ready and cannot be blocked by any other entity.</p><p>-BufConProd</p><formula xml:id="formula_11">1 : Queue[L][ml/right] r : Queue[R][mr/left] cp : ConProd[ml/left, mrlright]</formula><p>The BufConProd class definition allows true multithreading of the two buffers and the consumer/producer. For example. the left buffer may be accepting a new item at the same time as the consumer/producer is processing another item, at the same time as the right buffer is releasing yet another item to the environment. This concurrency is coerced into smooth co-operation through the requirement for synchronisation between the processes when communication occurs on the internal channels ml and mr.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>Many established formal specification and design notations have tended to concentrate either on data modeling and algorithmic concerns (eg. 2, VDM, Object-2, etc.) or else on process control concerns (eg. CSP, CCS, SlateCharts, etc.).</p><p>In order to address the needs of complex interactive systems it is necessary to be able to address both in a smoothly integrated, but also highly structured and modular, manner. In this regard, Timed CSP and Object-Z complement each other not only in their expressive capabilities, but also in their underlying semantics. In addition, the object oriented flavour of Object-Z provides an ideal foundation for promoting modularity and separation of concerns in system design. The intention of the proposed blending of these notations, TCOZ, is to treat data and algorithmic concerns in thie Object-2 style and to treat process control concerns in the CSP style. Timing concerns are distributed according to their status as relating to algorithm or control. TCOZ preserves in large part both the syntax and semantics of the individual notations and hence can potentially benefit from the large body of experience developed in the use of and tool support for the individual notations and their parents, such as verification and refinement techniques and tools, model checkers, etc..</p><p>The basis for the successful blending of the two notations is the duality between state transition semantics and event semantics. This has long been recognised [8, 10, 141 and has undoubtedly helped shape the development of Object-Z's behavioural semantics. Perhaps the most mature formalism based on this duality is Butler's blendhg of CSP with Back's Action Systems [ 13. An important lesson from this work is the need to distinguish strongly between the notions of guards and precondition in the state-transition view. The failure to do so in Object-2 has made it impossible to reconcile algorithmic refinement with behavioural semantics, greatly reducing the value of refinement in Object-2. The adoption of a distinct notion of state guards in TCOZ makes possible a full blending of Z-style algorithm and CSP-style process refinement.</p><p>The notion of blending the untimed CSP and Object-Z has been proposed independently by Fischer [6] and Smith [ 181.</p><p>Both take the approach of identifying the notion of channel with that of operation, operation invocations becoming atomic events. Not only does this prevent the modeling of timing and concurrency at the operation level, it also forces an unnatural class structure since in order 1. 0 communicate, objects must have like named operations. Neither formalism makes a full distinction between preconditions and guards2 so that refinement is greatly restricted in both.</p><p>This paper serves merely as brief introduction to the TCOZ notation. A separate paper describes the blended state/event process model which forms the basis for the TCOZ semantics [ 121. The TCOZ notation has been effectively applied to the specification of a real-time multi-lift system [ 111. During the development of this case study considerable experience was gained in the use of TCOZ and progress was made in developing a TCOZ modelling style. For example, the relative appropriateness of using of process-like mechanisms such as channels versus state-like mechanisms such as shared objects is an interesting topic for further investigation. Additional planned work includes developing refinement rules for the TCOZ specification language based on existing Z and CSP refinement systems. Schneider has described a system for capturing and verifying abstract temporal requirements of Timed CSP processes [15], it is hoped that this might also form a valuable addition to the TCOZ notation.</p><p>We believe that TCOZ to be a good candidate for specifying complex parallel and distributed real-time systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>IMAIN 2</head><label>2</label><figDesc>f : L -r R of the inputs, and outputs the result on its right channel. Process;MAIN    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>e a?n 3 b!f(n) + P</head><label></label><figDesc>begins with both a and b enabledl and performs the first to be enabled by its environment. Subsequent behaviour is determined by the event which actually occurred, P after a and (2</figDesc><table><row><cell>after b respectively. External choice may also be written in</cell></row><row><cell>an intentional form,</cell></row><row><cell>0 Internal choice represents variation in behaviour determined</cell></row><row><cell>by the internal state of the process. The process</cell></row><row><cell>a + P n b + Q</cell></row><row><cell>may initially enable either a, or b, or both, as it wishes, Ibu t</cell></row><row><cell>must act subsequently according: to which event actually oc-</cell></row><row><cell>curred. Again an intentional form is allowed.</cell></row></table><note><p><p><p>jointly by both P and Q. Other events occur in either P or Q separately. Diversity of behaviour is introduced through two choice operators. The external choice operator allows a process a choice of behaviour according to what events are enabled by its environment. The process a + P U b + Q a : A 0 P(a).</p>An important derived concept in CSP is the notion of channel. A channel is a collection of events of the form c.n: the prefix c is called the channel nume and the collection of SUSfixes the allowed values of the channel. When an event c.11 occurs it is said that the value n 1;s communicated on channtd c. By convention, when the value of a communication on a channel is determined by the environment (external choice:) it is called an input and when it is determined by the iriternal state of the process (intcxnal choice) it is called an output. It is convenient to write c?n : iV + P(n) to de:scribe behaviour over a range of allowed inputs instead of the longer 0 n : N 0 c.n + P(n). Similarly the notation c!n : N + P(n) is used instead of n n : N 0 c.n + P(n) to represent a range of outputs. Expressions of the form c?n and c!n do not represent events, the actual event is c.n in both cases.</p>Recursion is used to given finite representations of nonterminating processes. The process expression p P describes a process which repeatedly inputs an integer on channel a, calculated some function f of the input, and them outputs the result on channel b. CSP specifications are typically written as a sequence of simultaneous equations in a finite collection of process variables. Such a specification 2 2 g(</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>TimedQueue[X] -</figDesc><table><row><cell>Queue[X x T][redef : Join, Remove, Leave]</cell></row><row><cell>-Join</cell></row><row><cell>A(items)</cell></row><row><cell>item? : X on leftet1</cell></row><row><cell>items' = ds( tl + t, , ite,ms) -((item?, C ) ) s = t ,</cell></row><row><cell>Remove A (items) r tl? : T items # ( ) A 6 = tl items' = ds(t1 + tl, rail(items))</cell></row><row><cell>Leave 2 [items # ( ) ]</cell></row><row><cell>right!$rst( h ) e t 1 -+ Remove</cell></row><row><cell>A(items) 6 = td F --items' = ds(second(h:l + td, tail(items)) ~</cell></row><row><cell>MT 2 [items = ( )] 0 Join</cell></row><row><cell>NMT 2 [items # ( ) ] 0</cell></row><row><cell>((Join C1 Leave)</cell></row><row><cell>D{second(h)} Drop)</cell></row></table><note><p>MAIN 2 p TQ (MT Cl NMT); TQ</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank John Colton, Neale Fulton and Lin Zucconi for many helpful comments on this work. This work is supported in part by the DSTO/CSIRO Fellowship programme.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A CSP Approach to Action Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Butler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Wolfson College, Oxford University, Michaelmas Term</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A formal object approach to real-time specification</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Colton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zucconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 3rd Asia-PaciJic Sofnyare Engineering Conference (APSEC&apos;96)</title>
		<meeting><address><addrLine>Seoul, Korea</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996-12">December 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The role of secondary attributes in formal object modelling</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The First IEEE International Conference on Engineering Complex Computer Systems (ICECCS&apos;95)</title>
		<editor>
			<persName><forename type="first">Alex</forename><surname>Stoyenko</surname></persName>
		</editor>
		<meeting><address><addrLine>Ft. Lauderdale, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995-11">November 1995</date>
			<biblScope unit="page" from="3" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Object-Z: a specification language advocated for the description of standards</title>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Standards and Integaces</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="5" to="11" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A formal method for building concurrent real-time software</title>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">C</forename><surname>Fidge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kearney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Utting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Soffware</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Fixher does allow a distinction between guards and preconditions, but Ihe def2ult IS to identify them</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">CSP-OZ: A combination of Object-Z and CSP</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods for Open Object-Based Distributed Systems (FMOODS &apos;97)</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Bowmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Derrick</surname></persName>
		</editor>
		<imprint>
			<publisher>Chapman &amp; Hall</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="423" to="438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Using units of measurement in formal specifications</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Process simulation and refinement</title>
		<author>
			<persName><forename type="first">Jifeng</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formcil Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="229" to="241" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<imprint>
			<publisher>Prentice-Hall International</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A state-basted approach to communicating processes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Josephs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="9" to="18" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Blending Object-Z and Timed CSP: Applying TCOZ</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<idno>97- 23</idno>
	</analytic>
	<monogr>
		<title level="j">Commonwealth Scientific and Industrial Research Organisaticin (CSIRO)</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Australia</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Mathematical and Infoirmation Sciences</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Blending Object-Z and Timed CSP: The semantics; of TCOZ</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<idno>97-24</idno>
	</analytic>
	<monogr>
		<title level="s">Mathematical and I[nformation Sciences, Commonwealth Scientific and Industrial Research Organisation</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Australia</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A case-study in tinned refinement: A mine pump</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Halyes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on SojSware Engineering</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="17" to="826" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Of wp and CSP</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Morgan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Beauty is our Business: a Birthday Salute 1 &apos; 0</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">H J</forename><surname>Et A1 Feijen</surname></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">W</forename><surname>Edsger</surname></persName>
		</author>
		<author>
			<persName><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="19" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Correctness (2nd Communication in Real-Time Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
		<imprint>
			<date>19910</date>
		</imprint>
		<respStmt>
			<orgName>Oxford University Computing Laboratory, Programming Research Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
	<note>Available as Technical Motnograph PRG-84</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A brieF history of Timed CSP</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Davies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A fully abstract semantics of classes for Object</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Z. Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="313" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A semantic integration of Object-Z and CSP for the specification of conlcurrent systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceadings of FME&apos;97: Industrial Benefit of Formal Methods</title>
		<meeting>eadings of FME&apos;97: Industrial Benefit of Formal Methods<address><addrLine>Graz, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997-09">September 1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
