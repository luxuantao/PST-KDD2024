<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exploiting Linear Structure Within Convolutional Networks for Efficient Evaluation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Emily</forename><surname>Denton</surname></persName>
							<email>denton@cs.nyu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution" key="instit1">Courant Institute</orgName>
								<orgName type="institution" key="instit2">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wojciech</forename><surname>Zaremba</surname></persName>
							<email>zaremba@cs.nyu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution" key="instit1">Courant Institute</orgName>
								<orgName type="institution" key="instit2">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joan</forename><surname>Bruna</surname></persName>
							<email>bruna@cs.nyu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution" key="instit1">Courant Institute</orgName>
								<orgName type="institution" key="instit2">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yann</forename><surname>Lecun</surname></persName>
							<email>lecun@cs.nyu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution" key="instit1">Courant Institute</orgName>
								<orgName type="institution" key="instit2">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rob</forename><surname>Fergus</surname></persName>
							<email>fergus@cs.nyu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution" key="instit1">Courant Institute</orgName>
								<orgName type="institution" key="instit2">New York University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Exploiting Linear Structure Within Convolutional Networks for Efficient Evaluation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BFC92FF1FA1E0DADC465EC45799FF0B5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present techniques for speeding up the test-time evaluation of large convolutional networks, designed for object recognition tasks. These models deliver impressive accuracy, but each image evaluation requires millions of floating point operations, making their deployment on smartphones and Internet-scale clusters problematic. The computation is dominated by the convolution operations in the lower layers of the model. We exploit the redundancy present within the convolutional filters to derive approximations that significantly reduce the required computation. Using large state-of-the-art models, we demonstrate speedups of convolutional layers on both CPU and GPU by a factor of 2×, while keeping the accuracy within 1% of the original model.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Large neural networks have recently demonstrated impressive performance on a range of speech and vision tasks. However, the size of these models can make their deployment at test time problematic. For example, mobile computing platforms are limited in their CPU speed, memory and battery life. At the other end of the spectrum, Internet-scale deployment of these models requires thousands of servers to process the 100's of millions of images per day. The electrical and cooling costs of these servers is significant. Training large neural networks can take weeks, or even months. This hinders research and consequently there have been extensive efforts devoted to speeding up training procedure. However, there are relatively few efforts aimed at improving the test-time performance of the models.</p><p>We consider convolutional neural networks (CNNs) used for computer vision tasks, since they are large and widely used in commercial applications. These networks typically require a huge number of parameters (∼ 10 8 in <ref type="bibr" target="#b0">[1]</ref>) to produce state-of-the-art results. While these networks tend to be hugely over parameterized <ref type="bibr" target="#b1">[2]</ref>, this redundancy seems necessary in order to overcome a highly nonconvex optimization <ref type="bibr" target="#b2">[3]</ref>. As a byproduct, the resulting network wastes computing resources. In this paper we show that this redundancy can be exploited with linear compression techniques, resulting in significant speedups for the evaluation of trained large scale networks, with minimal compromise to performance.</p><p>We follow a relatively simple strategy: we start by compressing each convolutional layer by finding an appropriate low-rank approximation, and then we fine-tune the upper layers until the prediction performance is restored. We consider several elementary tensor decompositions based on singular value decompositions, as well as filter clustering methods to take advantage of similarities between learned features.</p><p>Our main contributions are the following: <ref type="bibr" target="#b0">(1)</ref> We present a collection of generic methods to exploit the redundancy inherent in deep CNNs. <ref type="bibr" target="#b1">(2)</ref> We report experiments on state-of-the-art Imagenet CNNs, showing empirical speedups on convolutional layers by a factor of 2 -3× and a reduction of parameters in fully connected layers by a factor of 5 -10×.</p><p>Notation: Convolution weights can be described as a 4-dimensional tensor: W ∈ R C×X×Y ×F . C is the number of number of input channels, X and Y are the spatial dimensions of the kernel, and F is the target number of feature maps. It is common for the first convolutional layer to have a stride associated with the kernel which we denote by ∆. Let I ∈ R C×N ×M denote an input signal where C is the number of input maps, and N and M are the spatial dimensions of the maps. The target value, T = I * W , of a generic convolutional layer, with ∆ = 1, for a particular output feature, f , and spatial location, (x, y), is</p><formula xml:id="formula_0">T (f, x, y) = C c=1 X x =1 Y y =1 I(c, x -x , y -y )W (c, x , y , f )</formula><p>If W is a tensor, W denotes its operator norm, sup x =1 W x F and W F denotes its Frobenius norm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Vanhoucke et al. <ref type="bibr" target="#b3">[4]</ref> explored the properties of CPUs to speed up execution. They present many solutions specific to Intel and AMD CPUs and some of their techniques are general enough to be used for any type of processor. They describe how to align memory, and use SIMD operations (vectorized operations on CPU) to boost the efficiency of matrix multiplication. Additionally, they propose the linear quantization of the network weights and input. This involves representing weights as 8-bit integers (range <ref type="bibr">[-127, 128]</ref>), rather than 32-bit floats. This approximation is similar in spirit to our approach, but differs in that it is applied to each weight element independently. By contrast, our approximation approach models the structure within each filter. Potentially, the two approaches could be used in conjunction.</p><p>The most expensive operations in CNNs are the convolutions in the first few layers. The complexity of this operation is linear in the area of the receptive field of the filters, which is relatively large for these layers. However, Mathieu et al. <ref type="bibr" target="#b4">[5]</ref> have shown that convolution can be efficiently computed in Fourier domain, where it becomes element-wise multiplication (and there is no cost associated with size of receptive field). They report a forward-pass speed up of around 2× for convolution layers in state-of-the-art models. Importantly, the FFT method can be used jointly with most of the techniques presented in this paper.</p><p>The use of low-rank approximations in our approach is inspired by work of Denil et al. <ref type="bibr" target="#b1">[2]</ref> who demonstrate the redundancies in neural network parameters. They show that the weights within a layer can be accurately predicted from a small (e.g. ∼ 5%) subset of them. This indicates that neural networks are heavily over-parametrized. All the methods presented here focus on exploiting the linear structure of this over-parametrization.</p><p>Finally, a recent preprint <ref type="bibr" target="#b5">[6]</ref> also exploits low-rank decompositions of convolutional tensors to speed up the evaluation of CNNs, applied to scene text character recognition. This work was developed simultaneously with ours, and provides further evidence that such techniques can be applied to a variety of architectures and tasks. Our work differs in several ways. First, we consider a significantly larger model. This makes it more challenging to compute efficient approximations since there are more layers to propagate through and thus a greater opportunity for error to accumulate. Second, we present different compression techniques for the hidden convolutional layers and provide a method of compressing the first convolutional layer. Finally, we present GPU results in addition to CPU results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Convolutional Tensor Compression</head><p>In this section we describe techniques for compressing 4 dimensional convolutional weight tensors and fully connected weight matrices into a representation that permits efficient computation and storage. Section 3.1 describes how to construct a good approximation criteria. Section 3.2 describes techniques for low-rank tensor approximations. Sections 3.3 and 3.4 describe how to apply these techniques to approximate weights of a convolutional neural network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Approximation Metric</head><p>Our goal is to find an approximation, W , of a convolutional tensor W that facilitates more efficient computation while maintaining the prediction performance of the network. A natural choice for an approximation criterion is to minimize W -W F . This criterion yields efficient compression schemes using elementary linear algebra, and also controls the operator norm of each linear convolutional layer. However, this criterion assumes that all directions in the space of weights equally affect prediction performance. We now present two methods of improving this criterion while keeping the same efficient approximation algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mahalanobis distance metric:</head><p>The first distance metric we propose seeks to emphasize coordinates more prone to produce prediction errors over coordinates whose effect is less harmful for the overall system. We can obtain such measurements as follows. Let Θ = {W 1 , . . . , W S } denote the set of all parameters of the S-layer network, and let U (I; Θ) denote the output after the softmax layer of input image I. We consider a given input training set (I 1 , . . . , I N ) with known labels (y 1 , . . . , y N ). For each pair (I n , y n ), we compute the forward propagation pass U (I n , Θ), and define as {β n } the indices of the h largest values of U (I n , Θ) different from y n . Then, for a given layer s, we compute</p><formula xml:id="formula_1">d n,l,s = ∇ Ws (U (I n , Θ) -δ(i -l)) , n ≤ N , l ∈ {β n } , s ≤ S ,<label>(1)</label></formula><p>where δ(i-l) is the dirac distribution centered at l. In other words, for each input we back-propagate the difference between the current prediction and the h "most dangerous" mistakes.</p><p>The Mahalanobis distance is defined from the covariance of d: W 2 maha = wΣ -1 w T , where w is the vector containing all the coordinates of W , and Σ is the covariance of (d n,l,s ) n,l . We do not report results using this metric, since it requires inverting a matrix of size equal to the number of parameters, which can be prohibitively expensive in large networks. Instead we use an approximation that considers only the diagonal of the covariance matrix. In particular, we propose the following, approximate, Mahalanobis distance metric:</p><formula xml:id="formula_2">W maha := p α p W (p) , where α p = n,l d n,l,s (p) 2 1/2<label>(2)</label></formula><p>where the sum runs over the tensor coordinates. Since ( <ref type="formula" target="#formula_2">2</ref>) is a reweighted Euclidiean metric, we can simply compute W = α . * W , where . * denotes element-wise multiplication, then compute the approximation W on W using the standard L 2 norm, and finally output W = α -1 . * W .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data covariance distance metric:</head><p>One can view the Frobenius norm of W as</p><formula xml:id="formula_3">W 2 F = E x∼N (0,I) W x 2 F .</formula><p>Another alternative, similar to the one considered in <ref type="bibr" target="#b5">[6]</ref>, is to replace the isotropic covariance assumption by the empirical covariance of the input of the layer. If W ∈ R C×X×Y ×F is a convolutional layer, and Σ ∈ R CXY ×CXY is the empirical estimate of the input data covariance, it can be efficiently computed as</p><formula xml:id="formula_4">W data = Σ 1/2 W F F ,<label>(3)</label></formula><p>where W F is the matrix obtained by folding the first three dimensions of W .As opposed to <ref type="bibr" target="#b5">[6]</ref>, this approach adapts to the input distribution without the need to iterate through the data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Low-rank Tensor Approximations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Matrix Decomposition</head><p>Matrices are 2-tensors which can be linearly compressed using the Singular Value Decomposition. If W ∈ R m×k is a real matrix, the SVD is defined as</p><formula xml:id="formula_5">W = U SV , where U ∈ R m×m , S ∈ R m×k , V ∈ R k×k .</formula><p>S is a diagonal matrix with the singular values on the diagonal, and U , V are orthogonal matrices. If the singular values of W decay rapidly, W can be well approximated by keeping only the t largest entries of S, resulting in the approximation W = Ũ S Ṽ , where</p><formula xml:id="formula_6">Ũ ∈ R m×t , S ∈ R t×t , Ṽ ∈ R t×k Then, for I ∈ R n×m , the approximation error I W -IW F satisfies I W -IW F ≤ s t+1 I F ,</formula><p>and thus is controlled by the decay along the diagonal of S. Now the computation I W can be done in O(nmt + nt 2 + ntk), which, for sufficiently small t is significantly smaller than O(nmk).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Higher Order Tensor Approximations</head><p>SVD can be used to approximate a tensor W ∈ R m×n×k by first folding all but two dimensions together to convert it into a 2-tensor, and then considering the SVD of the resulting matrix. For example, we can approximate W m ∈ R m×(nk) as Wm ≈ Ũ S Ṽ . W can be compressed even further by applying SVD to Ṽ . We refer to this approximation as the SVD decomposition and use K 1 and K 2 to denote the rank used in the first and second application of SVD respectively.</p><p>Alternatively, we can approximate a 3-tensor, W S ∈ R m×n×k , by a rank 1 3-tensor by finding a decomposition that minimizes</p><formula xml:id="formula_7">W -α ⊗ β ⊗ γ F ,<label>(4)</label></formula><p>where α ∈ R m , β ∈ R n , γ ∈ R k and ⊗ denotes the outer product operation. Problem ( <ref type="formula" target="#formula_7">4</ref>) is solved efficiently by performing alternate least squares on α, β and γ respectively, although more efficient algorithms can also be considered <ref type="bibr" target="#b6">[7]</ref>.</p><p>This easily extends to a rank K approximation using a greedy algorithm: Given a tensor W , we compute (α, β, γ) using ( <ref type="formula" target="#formula_7">4</ref>), and we update</p><formula xml:id="formula_8">W (k+1) ← W k -α ⊗ β ⊗ γ. Repeating this operation K times results in WS = K k=1 α k ⊗ β k ⊗ γ k .<label>(5)</label></formula><p>We refer to this approximation as the outer product decomposition and use K to denote the rank of the approximation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pointwise matrix multiplication</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RGB input</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intermediate representation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Output</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Monochromatic Convolution Approximation</head><p>Let W ∈ R C×X×Y ×F denote the weights of the first convolutional layer of a trained network. We found that the color components of trained CNNs tend to have low dimensional structure. In particular, the weights can be well approximated by projecting the color dimension down to a 1D subspace. The low-dimensional structure of the weights is illustrated in Figure <ref type="figure" target="#fig_3">4</ref>.1.</p><p>The monochromatic approximation exploits this structure and is computed as follows. First, for every output feature, f , we consider the matrix W f ∈ R C×(XY ) , where the spatial dimensions of the filter corresponding to the output feature have been combined, and find the SVD,</p><formula xml:id="formula_9">W f = U f S f V f , Approximation technique Number of operations No approximation XY CF N M ∆ -2 Monochromatic C CN M + XY F N M ∆ -2 Biclustering + outer product decomposition GHK(N M C G + XY N M ∆ -2 + F H N M ∆ -2 ) Biclustering + SVD GHN M ( C G K 1 + K 1 XY K 2 ∆ -2 + K 2 F H )</formula><p>Table <ref type="table">1</ref>: Number of operations required for various approximation methods.</p><p>where U f ∈ R C×C , S f ∈ R C×XY , and V f ∈ R XY ×XY . We then take the rank</p><formula xml:id="formula_10">1 approximation of W f , Wf = Ũf Sf Ṽ f , where Ũf ∈ R C×1 , Sf ∈ R, Ṽf ∈ R 1×XY .</formula><p>We can further exploit the regularity in the weights by sharing the color component basis between different output features. We do this by clustering the F left singular vectors, Ũf , of each output feature f into C clusters, for C &lt; F . We constrain the clusters to be of equal size as discussed in section 3.4. Then, for each of the F C output features, f , that is assigned to cluster c f , we can approximate</p><formula xml:id="formula_11">W f with Wf = U c f Sf Ṽ f where U c f ∈ R C×1</formula><p>is the cluster center for cluster c f and Sf and Ṽf are as before. This monochromatic approximation is illustrated in the left panel of Figure <ref type="figure" target="#fig_0">1(c)</ref>. Table <ref type="table">1</ref> shows the number of operations required for the standard and monochromatic versions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Biclustering Approximations</head><p>We exploit the redundancy within the 4-D weight tensors in the higher convolutional layers by clustering the filters, such that each cluster can be accurately approximated by a low-rank factorization. We start by clustering the rows of W C ∈ R C×(XY F ) , which results in clusters C 1 , . . . , C a . Then we cluster the columns of W F ∈ R (CXY )×F , producing clusters F 1 , . . . , F b . These two operations break the original weight tensor W into ab sub-tensors {W Ci,Fj } i=1,...,a,j=1,...,b as shown in Figure <ref type="figure" target="#fig_0">1</ref>(b). Each sub-tensor contains similar elements, and thus is easier to fit with a low-rank approximation.</p><p>In order to exploit the parallelism inherent in CPU and GPU architectures it is useful to constrain clusters to be of equal sizes. We therefore perform the biclustering operations (or clustering for monochromatic filters in Section 3.3) using a modified version of the k-means algorithm which balances the cluster count at each iteration. It is implemented with the Floyd algorithm, by modifying the Euclidean distance with a subspace projection distance.</p><p>After the input and output clusters have been obtained, we find a low-rank approximation of each sub-tensor using either the SVD decomposition or the outer product decomposition as described in Section 3.2.2. We concatenate the X and Y spatial dimensions of the sub-tensors so that the decomposition is applied to the 3-tensor, W S ∈ R C×(XY )×F . While we could look for a separable approximation along the spatial dimensions as well, we found the resulting gain to be minimal. Using these approximations, the target output can be computed with significantly fewer operations. The number of operations required is a function the number of input clusters, G, the output clusters H and the rank of the sub-tensor approximations (K 1 , K 2 for the SVD decomposition; K for the outer product decomposition. The number of operations required for each approximation is described in Table <ref type="table">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Fine-tuning</head><p>Many of the approximation techniques presented here can efficiently compress the weights of a CNN with negligible degradation of classification performance provided the approximation is not too harsh. Alternatively, one can use a harsher approximation that gives greater speedup gains but hurts the performance of the network. In this case, the approximated layer and all those below it can be fixed and the upper layers can be fine-tuned until the original performance is restored.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We use the 15 layer convolutional architecture of <ref type="bibr" target="#b7">[8]</ref>, trained on the ImageNet 2012 dataset <ref type="bibr" target="#b8">[9]</ref>. The network contains 5 convolutional layers, 3 fully connected layers and a softmax output layer. We We present results showing the performance of the approximations described in Section 3 in terms of prediction accuracy, speedup gains and reduction in memory overhead. All of our fine-tuning results were achieved by training with less than 2 passes using the ImageNet12 training dataset. Unless stated otherwise, classification numbers refer to those of fine-tuned models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Speedup</head><p>The majority of forward propagation time is spent on the first two convolutional layers (see Supplementary Material for breakdown of time across all layers). Because of this, we restrict our attention to the first and second convolutional layers in our speedup experiments. However, our approximations could easily applied to convolutions in upper layers as well.</p><p>We implemented several CPU and GPU approximation routines in an effort to achieve empirical speedups. Both the baseline and approximation CPU code is implemented in C++ using Eigen3 library <ref type="bibr" target="#b9">[10]</ref> compiled with Intel MKL. We also use Intel's implementation of openmp and multithreading. The baseline gives comparable performance to highly optimized MATLAB convolution routines and all of our CPU speedup results are computed relative to this. We used Alex Krizhevsky's CUDA convolution routines<ref type="foot" target="#foot_0">1</ref> as a baseline for GPU comparisons. The approximation versions are written in CUDA. All GPU code was run on a standard nVidia Titan card.</p><p>We have found that in practice it is often difficult to achieve speedups close to the theoretical gains based on the number of arithmetic operations (see Supplementary Material for discussion of theoretical gains). Moreover, different computer architectures and CNN architectures afford different optimization strategies making most implementations highly specific. However, regardless of implementation details, all of the approximations we present reduce both the number of operations and number of weights required to compute the output by at least a factor of two, often more.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">First Layer</head><p>The first convolutional layer has 3 input channels, 96 output channels and 7x7 filters. We approximated the weights in this layer using the monochromatic approximation described in Section 3.3. The monochromatic approximation works well if the color components span a small number of one dimensional subspaces. Figure <ref type="figure" target="#fig_1">2</ref> illustrates the effect of the monochromatic approximation on the first layer filters.</p><p>The only parameter in the approximation is C , the number of color channels used for the intermediate representation. As expected, the network performance begins to degrade as C decreases. The number of floating point operations required to compute the output of the monochromatic convolution is reduced by a factor of 2 -3×, with the larger gain resulting for small C . Figure <ref type="figure" target="#fig_2">3</ref> shows the empirical speedups we achieved on CPU and GPU and the corresponding network performance for various numbers of colors used in the monochromatic approximation. Our CPU and GPU imple-  mentations achieve empirical speedups of 2 -2.5× relative to the baseline with less than 1% drop in classification performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Second Layer</head><p>The second convolutional layer has 96 input channels, 256 output channels and 5x5 filters. We approximated the weights using the techniques described in Section 3.4. We explored various configurations of the approximations by varying the number of input clusters G, the number of output clusters H and the rank of the approximation (denoted by K 1 and K 2 for the SVD decomposition and K for the outer product decomposition).</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows our empirical speedups on CPU and GPU and the corresponding network performance for various approximation configurations. For the CPU implementation we used the biclustering with SVD approximation. For the GPU implementation we using the biclustering with outer product decomposition approximation. We achieved promising results and present speedups of 2 -2.5× relative to the baseline with less than a 1% drop in performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Combining approximations</head><p>The approximations can also be cascaded to provide greater speedups. The procedure is as follows. Compress the first convolutional layer weights and then fine-tune all the layers above until performance is restored. Next, compress the second convolutional layer weights that result from the fine-tuning. Fine-tune all the layers above until performance is restored and then continue the process.</p><p>We applied this procedure to the first two convolutional layers. Using the monochromatic approximation with 6 colors for the first layer and the biclustering with outer product decomposition approx-  imation for the second layer (G = 48; H = 2; K = 8) and fine-tuning with a single pass through the training set we are able to keep accuracy within 1% of the original model. This procedure could be applied to each convolutional layer, in this sequential manner, to achieve overall speedups much greater than any individual layer can provide. A more comprehensive summary of these results can be found in the Supplementary Material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Reduction in memory overhead</head><p>In many commercial applications memory conservation and storage are a central concern. This mainly applies to embedded systems (e.g. smartphones), where available memory is limited, and users are reluctant to download large files. In these cases, being able to compress the neural network is crucial for the viability of the product.</p><p>In addition to requiring fewer operations, our approximations require significantly fewer parameters when compared to the original model. Since the majority of parameters come from the fully connected layers, we include these layers in our analysis of memory overhead. We compress the fully connected layers using standard SVD as described in 3.2.2, using K to denote the rank of the approximation.</p><p>Table <ref type="table" target="#tab_1">2</ref> shows the number of parameters for various approximation methods as a function of hyperparameters for the approximation techniques. The table also shows the empirical reduction of parameters and the corresponding network performance for specific instantiations of the approximation parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>In this paper we have presented techniques that can speed up the bottleneck convolution operations in the first layers of a CNN by a factor 2 -3×, with negligible loss of performance. We also show that our methods reduce the memory footprint of weights in the first two layers by factor of 2 -3× and the fully connected layers by a factor of 5 -13×. Since the vast majority of weights reside in the fully connected layers, compressing only these layers translates into a significant savings, which would facilitate mobile deployment of convolutional networks. These techniques are orthogonal to other approaches for efficient evaluation, such as quantization or working in the Fourier domain. Hence, they can potentially be used together to obtain further gains.</p><p>An interesting avenue of research to explore in further work is the ability of these techniques to aid in regularization either during or post training. The low-rank projections effectively decrease number of learnable parameters, suggesting that they might improve generalization ability. The regularization potential of the low-rank approximations is further motivated by two observations. The first is that the approximated filters for the first conolutional layer appear to be cleaned up versions of the original filters. Additionally, we noticed that we sporadically achieve better test error with some of the more conservative approximations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A visualization of monochromatic and biclustering approximation structures. (a) The monochromatic approximation, used for the first layer. Input color channels are projected onto a set of intermediate color channels. After this transformation, output features need only to look at one intermediate color channel. (b) The biclustering approximation, used for higher convolution layers. Input and output features are clustered into equal sized groups. The weight tensor corresponding to each pair of input and output clusters is then approximated. (c) The weight tensors for each input-output pair in (b) are approximated by a sum of rank 1 tensors using techniques described in 3.2.2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Visualization of the 1st layer filters. (Left) Each component of the 96 7x7 filters is plotted in RGB space. Points are colored based on the output filter they belong to. Hence, there are 96 colors and 7 2 points of each color. Leftmost plot shows the original filters and the right plot shows the filters after the monochromatic approximation, where each filter has been projected down to a line in colorspace. (Right) Original and approximate versions of a selection of 1st layer filters.</figDesc><graphic coords="6,294.40,100.34,280.02,66.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FinetunedFigure 3 :</head><label>3</label><figDesc>Figure 3: Empirical speedups on (Left) CPU and (Right) GPU for the first layer. C is the number of colors used in the approximation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Empirical speedups for second convolutional layer. (Left) Speedups on CPU using biclustered (G = 2 and H = 2) with SVD approximation. (Right) peedups on GPU using biclustered (G = 48 and H = 2) with outer product decomposition approximation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Number of parameters expressed as a function of hyperparameters for various approximation methods and empirical reduction in parameters with corresponding network performance.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://code.google.com/p/cuda-convnet/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors are grateful for support from ONR #N00014-13-1-0646, NSF #1116923, #1149633 and Microsoft Research.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Overfeat: Integrated recognition, localization and detection using convolutional networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Eigen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1312.6229</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Denil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shakibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1306.0543</idno>
		<title level="m">Predicting parameters in deep learning</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Improving neural networks by preventing co-adaptation of feature detectors</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1207.0580</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Improving the speed of neural networks on cpus</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Senior</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Deep Learning and Unsupervised Feature Learning NIPS Workshop</title>
		<meeting>Deep Learning and Unsupervised Feature Learning NIPS Workshop</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Henaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1312.5851</idno>
		<title level="m">Fast training of convolutional networks through ffts</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Speeding up convolutional neural networks with low rank expansions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jaderberg</surname></persName>
		</author>
		<author>
			<persName><surname>Vedaldi</surname></persName>
		</author>
		<author>
			<persName><surname>Andrea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1405.3866</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Rank-one approximation to high order tensors</title>
		<author>
			<persName><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Golub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Matrix Anal. Appl</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="534" to="550" />
			<date type="published" when="2001-02">February 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Visualizing and understanding convolutional neural networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Zeiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1311.2901</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">ImageNet: A Large-Scale Hierarchical Image Database</title>
		<author>
			<persName><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fei-Fei</surname></persName>
		</author>
		<idno>CVPR09</idno>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Guennebaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jacob</surname></persName>
		</author>
		<ptr target="http://eigen.tuxfamily.org" />
		<title level="m">Eigen v3</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Adaptive deconvolutional networks for mid and high level feature learning</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Zeiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">W</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision (ICCV), 2011 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2018" to="2025" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Tiled convolutional neural networks</title>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ngiam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Koh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Monga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Devin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1112.6209</idno>
		<title level="m">Building high-level features using large scale unsupervised learning</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Object recognition from local scale-invariant features</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The proceedings of the seventh IEEE international conference on</title>
		<imprint>
			<publisher>Ieee</publisher>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1150" to="1157" />
		</imprint>
	</monogr>
	<note>Computer vision</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Neural Information Processing Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1106" to="1114" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
