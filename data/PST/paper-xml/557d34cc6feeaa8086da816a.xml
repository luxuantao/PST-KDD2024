<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Genetic Algorithms for the Floorplan Design Problem</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">James</forename><forename type="middle">P</forename><surname>Cohoon</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science. University IEEE Log Number</orgName>
								<address>
									<addrLine>9042070. of Virginia</addrLine>
									<postCode>22903</postCode>
									<settlement>Charlottesville</settlement>
									<region>VA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Shailesh</forename><forename type="middle">U</forename><surname>Hegde</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science. University IEEE Log Number</orgName>
								<address>
									<addrLine>9042070. of Virginia</addrLine>
									<postCode>22903</postCode>
									<settlement>Charlottesville</settlement>
									<region>VA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Worthy</forename><forename type="middle">N</forename><surname>Martin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science. University IEEE Log Number</orgName>
								<address>
									<addrLine>9042070. of Virginia</addrLine>
									<postCode>22903</postCode>
									<settlement>Charlottesville</settlement>
									<region>VA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dana</forename><forename type="middle">S</forename><surname>Richards</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science. University IEEE Log Number</orgName>
								<address>
									<addrLine>9042070. of Virginia</addrLine>
									<postCode>22903</postCode>
									<settlement>Charlottesville</settlement>
									<region>VA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">H</forename><forename type="middle">J M</forename><surname>Otten</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science. University IEEE Log Number</orgName>
								<address>
									<addrLine>9042070. of Virginia</addrLine>
									<postCode>22903</postCode>
									<settlement>Charlottesville</settlement>
									<region>VA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Distributed Genetic Algorithms for the Floorplan Design Problem</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">ED097D7394AE94D5412CFEF47617E2E9</idno>
					<note type="submission">received October 17, 1988; revised August 29, 1989.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Floorplan design is an important stage in the VLSI design cycle. Designing a floorplan calls for arranging a given set of modules in the plane to minimize the weighted sum of area and wirelength measures. This paper presents a method to solve the floorplan design problem using distributed genetic algorithms. Distributed genetic algorithms, based on the paleontological theory of punctuated equilibria, offer a conceptual modification to the traditional genetic algorithms. Experimental results on several problem instances demonstrate the efficacy of our method, and point out the advantages o f using this method over other methods, such as simulated annealing. Our method has performed better than the simulated annealing approach, both in terms of the average cost of the solutions found and the best-found solution, in almost all the problem instances tried.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>LOORPLAN design is an important stage in the overall F cycle of VLSI design, as clearly indicated by the considerable attention it has received in the literature <ref type="bibr" target="#b16">[21]</ref>- <ref type="bibr" target="#b19">[24]</ref>, <ref type="bibr" target="#b22">[27]</ref>, <ref type="bibr" target="#b25">[30]</ref>, <ref type="bibr" target="#b28">[33]</ref>- <ref type="bibr" target="#b30">[35]</ref>. The floorplan design problem is to arrange a given set of modules in the plane to minimize the weighted sum of the area within the bounding rectangle of the arranged modules and the wirelength measures between modules that must be connected in the circuit. In this way, floorplan design can be seen as an optimization problem. However, the bin-packing aspect of the design criteria causes the problem to have a combinational nature and thereby, precludes the direct application of many standard optimization techniques, e.g., gradient-based hill climbing. This combinatorial nature has caused some researchers to turn to probabilistic search mechanisms, such as simulated annealing [ 191 and genetic algorithms [ 161. In particular, these investigations have considered parallel search formulations (e.g., simulated annealing [2], [5], <ref type="bibr" target="#b15">[20]</ref>, <ref type="bibr" target="#b21">[26]</ref> and genetic algorithms [6], <ref type="bibr">[18]</ref>, <ref type="bibr" target="#b20">[25]</ref>, <ref type="bibr" target="#b26">[31]</ref>.</p><p>We are studying a novel formulation of genetic algorithms, called GAPE, that is motivated by the concept of punctuated equilibria in evolution theory <ref type="bibr">[IO]</ref>, [ 1 11 and the desire to effectively use large scale, distributed memory, message passing, parallel processing systems <ref type="bibr" target="#b23">[28]</ref>. In this paper we present the results of our study of the applicability of GAPE to floorplan design. In order to have a scale against which to judge the ef-fectiveness of GAPE, we decided to use the formulation of floorplan design given by Wong and Liu <ref type="bibr" target="#b28">[33]</ref>. We believe their work to be one of the best examples in the recent literature of the application of probabilistic search techniques (in this case, simulated annealing) to floorplan design. By using this formulation we are able to run GAPE and simulated annealing, as well as a sequential genetic algorithm, on exactly the same test suite of floorplan instances.</p><p>Having the exact same test cases allows us to directly compare the resulting best "scores" of each method. Final comparison of the effectiveness of the methods, however, is problematic due to the substantial difference in the underlying computational schemes. For example, direct machine runtimes can be quite misleading because of the extensive opportunities to "fine tune" the operating parameters and the low-level utility functions of each method. The comparison to Wong and Lui is based on our version of simulated annealing. That version was implemented in a straightforward manner and might contain extremely inefficient (in terms of CPU seconds) components. Thus we do not base our evaluation of the effectiveness of the techniques upon CPU runtimes. Rather, we allow each technique to perform the same amount of "work" and then compare the "scores" of the best designs found in the process. Since the problem is being formulated as a combinatorial optimization problem, we define "work" to be measured in terms of the number of tentative solutions each technique examines in its optimization process. Under the constraint of equivalent "work," GAPE has performed better than the simulated annealing approach, both in terms of the average cost of the solutions found and the best-found solution, in almost all the problem instances tried.</p><p>Section I1 of this paper reviews the floorplan design problem formulation. In Section 111, we briefly discuss sequential genetic algorithms, and present our distributed genetic algorithm paradigm based on the theory of punctuated equilibra, GAPE. Section IV presents the implementation details of the application of the distributed genetic algorithms to the floorplan design problem. In Section V, we show experimental results to demonstrate the efficacy of our method. Conclusions and future directions are discussed in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">FLOORPLAN DESIGN PROBLEM</head><p>Following Wong and Liu <ref type="bibr" target="#b28">[33]</ref>, the floorplan design problem is formulated as follows: there is a set of m modules, denoted { M, } for i = 1, 2, . . . , m. In this formulation, the modules are restricted to be rectangular. Thus each module i is characterized by a triple ( A , , l , , U , ), where A , is the area of the module, and 1, and U , are the lower and upper bounds, respectively, on the allowed aspect ratio, i.e., the ratio of the height h , to 0278-0070/9110400-0483$01 .OO 0 1991 IEEE width w i of the module. That specification leads to the following relationships:</p><p>(1) w . h . = A . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>W i</head><p>If 1 , = U , then M, is said to be rigid, otherwise, it i s j e x i b l e . The aspect ratio can also be defined as the inverse of that indicated in (2), so modules are further designated as being of either fixed orfree orientation. The fixed orientation modules are constrained by ( 2 ) , while the free orientation modules are constrained by the following: h .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>W .</head><p>l i I 1 I u i or l i I 2 I ui.</p><p>wi hi</p><formula xml:id="formula_0">(3)</formula><p>For example, a rigid module of fixed orientation specifies its height and width by h , =</p><p>and w , = m, while a rigid module of free orientation allows those two dimensions to be interchanged. A flexible module of free orientation allows its configuration to be any rectangle satisfying both (1) and (3). Further, the bounding rectangle, R, is constrained to have an aspect ratio that lies between two given numbers, p and 4, p I q. Each floorplan is evaluated by an objective function having a total-area component and a weighted wirelength component.</p><p>The total area is the area of R , i.e., Er=, x l y I . The wirelength between each pair of modules M, and MJ is the Manhattan distance between the centers of the corresponding regions r, and rJ, and is denoted d , . The center of a region is the geometric center of the region. Each connection between modules has an associated cost, c,, 2 0. Note the fact that two modules are not to be connected is represented by the cost being set to 0. The overall evaluation of a particular floorplan is summarized in its score, as given in the following:</p><formula xml:id="formula_1">m m score = c x i y i + X c c u d u . i = 1 iJ = 1 (4)</formula><p>Thus the floorplan design problem is to find a floorplan having the minimum score. The user specified constant, A, controls the relative importance of total area and weighted wirelength. In all of the experiments described in this paper, X = 1.</p><p>By restricting the partitions of the rectangle R to recursive subdivisions, one obtains a slicing structure. An example is provided in Fig. <ref type="figure">l(a)</ref>. Henceforth, our attention will be restricted to floorplans which are slicing structures. Let the operations of a horizontal cut and a vertical cut be denoted by the operators +. and *, respectively. Operators + and * are of different types. Slicing structures comprising the m given modules (also called operands) can be represented by slicing trees p2], <ref type="bibr" target="#b18">[23]</ref> or Polish expressions [33] over the alphabet C = { 1, 2, . . . , m , *, + }. pote that here the index is used to name the module. In a slicing tree operators are internal nodes and operands are leaves. There exists a one-to-one mapping from the set of slicing trees to the set of Polish expressions. The Polish expression associated with a slicing tree can be obtained by a post-order traversal [l] of the slicing tree. Although there can be more than one slicing tree or Polish expression for the same slicing structure, uniqueness can be achieved by systematically partitioning R from top to bottom and from right to left at any stage of recursive subdivision. This results in slicing structures being represented as skewed slicing trees or normalized Polish expressions <ref type="bibr" target="#b28">[33]</ref>. Note that a slicing tree, a Polish expression, a skewed slicing tree, and a normalized Polish expression all have m operands and ( m -1 ) operators, resulting in a total size of ( 2 x m -1 ). By convention, we number the items, i.e., operands or operators, in a Polish expression or a normalized Polish expression from left to right ranging from 1 to ( 2 x m -1 ).</p><p>The set of possible dimensions, ( x i , y , ) of the region r, accommodating M, can be determined using the following information: ( A t , l , , U , ), whether M, has fixed or free orientation, and (1)-(3). Such a set, termed the boundary region of M,, is a subset of the Cartesian plane, and is characterized by a monotonically nonincreasing curve, called the bounding curve of M,.</p><p>When bounding curves of the modules are piecewise linear, the bounding curve of a slicing structure can be obtained by doing simple addition operations on the "comers" identifying the piecewise-linear curves <ref type="bibr" target="#b28">[33]</ref>. This gives a method of computing the area and wirelength measures of a floorplan.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">GENETIC ALGORITHMS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Sequential Genetic Algorithm</head><p>The genetic algorithm paradigm has been proposed to generate solutions to a wide range of problems [16], <ref type="bibr">[17]</ref>. In particular, several optimization problems have been investigated. These include control systems [ 131, function optimization [3], and combinatorial problems 171, [9], <ref type="bibr">[121, [141, [151, [291</ref>. A more complete motivation and exposition for the material in this section can be found in our recent paper <ref type="bibr">[6]</ref>.</p><p>In a genetic algorithm, a population of solutions to the problem at hand is maintained and allowed to evolve through successive generations. A suitable encoding of each solution in the population is used to allow computation of the$tness, i.e., a measure of the solution's competence, and manipulation to form new solutions. The capabilities provide the means to create a sequence of generations. To create the next generation, new solutions are formed by either merging two solutions from the current generation via a crossover operator or modifying an individual solution using a mutation operator. The solutions to be cally, a constant number of solutions are selected so that the maintained population is of fixed size. After an arbitrary number of generations the process is terminated and the best remaining solution (or the best ever seen) is reported.</p><p>There are many simple avenues to parallelize a sequential genetic algorithm (assuming a global shared memory), e.g., selecting and crossing over pairs of solutions in parallel, and mutating solutions in parallel. However, such avenues result in only a simple hardware accelerator, and will not be suitable for local memory, message passing, distributed models of computation. Therefore, we have turned our attention to the theory of punctuated equilibria that provides a suitable paradigm to map genetic algorithms onto a distributed system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Punctuated Equilibria</head><p>The theory of punctuated equilibria has been proposed to resolve certain paleontological dilemmas in the geological record [lo], [ 1 11. Punctuated equilibria is based on two principles: allopatric speciation and stasis. Allopatric speciation involves the rapid evolution of new species after a small set of members of a species, peripheral isolates, becomes segregated into a new environment. Stasis, or stability, of a species is simply the notion of lack of change. It implies that after equilibria is reached in an environment there is very little drift away from the genetic composition of a species. Ideally, a species would persist until its environment changes (or the species would drift very little). Punctuated equilibria stresses that a powerful method for generating new species is to thrust an old species into a new environment, where change is beneficial and rewarded. For this reason we should expect a genetic algorithm approach based on punctuated equilibria to perform better than the typical single environment scheme.</p><p>What are the implications for the genetic algorithm approach? If the environment is unchanging, then equilibrium should be rapidly attained. The resulting "equivalence classes'' of similar solutions would correspond to "species." It is possible that solutions in the "vicinities" of the minima of the objective function have not been explored. A genetic algorithm relies on the mutation and crossover operators to eventually create solutions "near" the minima. While stasis indicates that an isolated population will stabilize over time, allopatric speciation indicates that continued evolution can be obtained through the introduction of previously stabilized species into different environments. Therefore, a genetic algorithm should alternate the maintenance of populations isolated in different environments to allow the development of species with the introduction of species to new environments.</p><p>We create different environments by having the fitness measure defined relative to the current local population. In this way, exchanging sets of solutions between local populations will al-ter the evaluation of the members (of the local populations), and introduce new competitors, thereby effecting the desired allopatric speciation. Alternate schemes for establishing different environments are possible, of course. For example, if the problem domain requires a multi-objective fitness measure, various low-order approximations to or projections of the true fitness measure could be used at different populations. This multi-objective fitness scheme and others will be investigated in our continuing research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Genetic Algorithms with Punctuated Equilibria</head><p>Our basic model of a genetic algorithm with punctuated equilibria assigns a set of n solutions to each of N processors, for a total population of size n x N . The set assigned to each processor is its subpopulation. The processors are connected by an interconnection network. In practice, we might expect a conventional topology to be used, such as a mesh or a hypercube. The network should have sufficient connectivity and small diameter to ensure adequate mixing as time progresses.</p><p>The overall structure of our approach is seen in Fig. <ref type="figure">2</ref> . There are E major iterations called epochs. During an epoch, each processor, disjointly and in parallel, executes the genetic algorithm on its subpopulation. Theoretically each processor continues until it reaches equilibrium. Since, as yet, we know of no adequate stopping criteria, we have used a fixed number, G , of generations per epoch. This considerably simplifies the problem of synchronizing the processors, since each processor should be completed at nearly the same time. After each processor has stopped, there is a phase during which each processor copies randomly selected subsets (of size S = I S,, I ) of its population to neighboring processors. Each processor now has acquired a surplus of solutions and must probabilistically select a set of n solutions to survive to be its initial subpopulation at the beginning of the next epoch.</p><p>The relationship to punctuated equilibria is the following. Each processor corresponds to a disjoint environment (as characterized by the mix of solutions residing in it). After G generations we expect to see the emergence of some very fit species. Then a catastrophe occurs and the environments change. This is simulated by having representatives of geographically adjacent environments regroup to form the new environments. By varying the amount of redistribution, S, we can control the amount of disruption.</p><p>The genetic algorithm code used by each processor is shown is Fig. <ref type="figure" target="#fig_4">3</ref>. The crossover rate, 0 5 C 5 1, determines how many new offspring are produced during each generation. Parents are chosen probabilistically (by fitness) with replacement. The crossover and other details are discussed below. The fitnesses are recalculated, relative to the new larger population. We have already developed a system to simulate a distributed genetic algorithm, experimented with the NP-complete optimal linear arrangement problem, and empirically demonstrated that our formulation is much more than a simple hardware accelerator version of sequential genetic algorithms [6].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. SEARCH OPERATORS</head><p>In simulated annealing the search of the solution space is largely unconstrained during the high-temperature phase, and becomes more conservative through the low-temperature phase. In genetic algorithms there is a similar but not strictly analogous phenomenon. At the beginning when there is a wide almost random, diversity, the crossover operators tend to produce dramatic "jumps" in the solution space. Later, as clusters of high fitness solutions develop, the crossover operators provide efficient exploration in the neighborhood of each cluster. During the later stages, crossovers between individuals from different clusters continue, of course, to exploit the remaining diversity. Note that the change in character of the exploration mode is not due primarily to the specific form of the crossover operators. In most systems discussed to date, the form of the operators, in fact, remain unchanged throughout the evolutionary process. The prime cause of the shift in the exploration mode is the clustering of individuals, in terms of the genotypes, i.e., string representations, through the evolutionary process. We contend that the crossover operators discussed below share information from the parents in the offspring, and thus the offspring are "between" the parents.</p><p>Mutation operators also are largely unconstrained at the beginning, since the average fitness is low and the population is comparatively large. Later, after the average fitness has increased, explorations by the mutation operators are decreased. The change in exploration mbde is again not due to a change in the mutation operator. The primary causes are the selection process at the end of each generation and the changing distribution of fitness values in the population. As the evolutionary process proceeds, the fitness values tend to cluster and the random modifications made by the mutation operators will most often create individuals with fitnesses well below the average fitness of the cluster, just as simulated annealing would at high temperatures. The GAPE mutation operations appear to always "accept," (in the sense of simulated annealing) the random change. However, the analogous selection against the resulting poor individuals is not made by the mutation operators. Rather, at the end of each generation the selection is made against the whole population. Thus the degree of exploratory search is determined by the "selective pressure," i.e., the relationship between the population size, the crossover and mutation rates, and the current distribution of individuals in the population.</p><p>The current version of GAPE has four crossover loperators, CO,, CO2, CO,, and CO,. The first two, CO, and CO,, operate primarily in terms of string manipulation, though they are designed so that the resulting string is a valid Polish expression for a slicing tree. Each of CO, and CO, take two parent strings and create one offspring string, which we denote by P I , P2 and 0 with a possible index, i (1 I i I 2m -l ) , indicating a selected position within the given string.</p><p>Crossover operator CO, first copies the operands from parent PI into the corresponding positions in the offspring, 0. Then, it copies operators from P2, by making a left-to-right scan, to complete 0. It is to be noted that COI propagates groups of operands from PI into 0. Notationally, for PI let the set, { n,,} with 1 I j I m , be the indexes of the m operands of PI. Thus CO, starts out by copying the operators from P, into the corresponding positions in 0. Then, it completes the construction of 0 by copying the operands from P1, by making a left-to-right scan. By propagating the groups of operators from PI into 0, CO2 produces an offspring having the same overall slicing structure as that of P,. CO, performs the following steps: 1) get operators: for each k , 1 I k I m -1, assign 0 The remaining two operators, CO, and CO,, have been designed to function in terms of subtrees, i.e., subexpressions, because we consider subtrees to be the natural building blocks of slicing trees. We intend GAPE to use CO, and CO, to maintain building blocks in the offspring in much the same manner as Holland describes [16]. Each subtree in a slicing tree corresponds to a contiguous substring in the Polish expression with an operator as the leftmost element, i.e., the root of the subtree. Notationally, the subtree, s, of P I , is represented by the substring of P, beginning at index b, and ending at e,.</p><p>CO, again takes two parents, P, and P,, and creates a single offspring, 0, propagating into 0 the overall nature of the slicing and a complete slicing substructure, i.e., a subtree, from PI. The overall slicing is propagated, as in CO2 by copying the operators in place from P I . The propagated subtree is completed by also copying its operands from PI. The order of the remaining operands is derived from P,. The following steps are performed by CO,: 1) get operators: for each k, 1 I k 5 m -1, assign 0 [ r1 k ] the value of PI [ rl k ] ; 2) subtree operands: randomly select sI, a subtree of PI specified by ( b l , e l ) , and for each i in { n,,} such that b, 5 i I e,, assign O[i ] the value of PI [ i 1; and 3) remaining operands: for each i in { n, , } such that ( i &lt; b, or e, &lt; e , ) , assign O[i] the value of NEXT-OPERAND ( P2 ) .</p><p>NEXT-OPERAND is a function that returns the leftmost "unused," i.e., not previously selected in this instance of CO,, operand of its parameter string. Note that the subtree is selected by randomly choosing an index of an operator in P I , called e, above. A leftward scan of P, can determine the appropriate bl CO*. in ( e , -b, ) simple steps. The operation of CO3 is illustrated in Fig. <ref type="figure">6</ref> , with the randomly selected operator being the rightmost + from Parent 1.</p><p>Crossover operator CO4 takes two parents P , and P,, and creates two offspring, 0, and 02, by directly interchanging building blocks, i.e., subtrees, between the parents. CO, begins by randomly selecting s,, a subtree of P I specified by ( b , , e , ) , and s2, a subtree of P , specified by (b,, e 2 ) , under the constraint that s, and s2 have the same size, i.e. <ref type="figure">,</ref><ref type="figure">( e ,</ref>) . If no solutions satisfying the constraint can be selected, then CO4 fails. If appropriate subtrees can be selected, then CO, performs the following steps to create 0,: 1) get operators: for</p><formula xml:id="formula_2">each k , 1 5 k s m -1,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>assign O [ r l k ] the value of P I [ r l k ] ;</head><p>2 ) insert subtree: for each i, 0 5 i 5 ( e , -b, ) assign 0, [ b,</p><p>+ i ] the value of P2[b2 + i ] (possibly overwriting some operators); and 3 ) remaining operands: for each i in { a,,} such that ( i &lt; b, or e , &lt; i), assign 0, [ i ] the value of NEXT -OPERAND ( P , ).</p><p>In a similar manner 0, is created by the following steps: 1) get operators: for each k ,</p><formula xml:id="formula_3">1 5 k I m -1, assign O2 [ r 2 k ] the value of P 2 [ r 2 k ] ;</formula><p>2 ) insert subtree: for each i, 0 5 i I ( e 2b 2 ) assign 0 2 [ b 2 + i ] the value of P2[b2 + i ] (possibly overwriting some operators); and 3 ) remaining operands: for each i in { a2, } such that ( i &lt; b, or e2 &lt; i ), assign 0, [ i ] the value of NEXT-OPERAND ( P I ). Fig. <ref type="figure" target="#fig_8">7</ref> illustrates the operation of CO4.</p><p>The selection of the appropriate subtrees is done by first calculating, for each operator in P , and P,, the size of the subtree rooted at that operator. This calculation can be done in a leftto-right scan of the strings, and thus requires on the order of 2m -1 steps. Let SZ, and SZ2 be the set of distinct subtree sizes (other than 1) in P , and P 2 , respectively. Let COMMON = SZ, fl SZ,. If COMMON = 0 the crossover fails as no subtrees of the same size exist. Otherwise, a subtree size, z ( 2 &lt; z &lt; m ) , is randomly selected from COMMON. The restriction on z is imposed because the effect of exchanging subtrees with z = 2 can be easily achieved by mutation operators (described later), and the case z = m results in exchanging the entire tree thus creating no new solutions. Having selected z , the sets E , and can be created to contain the ending indexes of the subtrees having size z in P I and P2, respectively. Random selections from E I Z and E2: yield the appropriate e , and e2, and thereby the subtrees, si and s2.</p><p>Having a set of crossover operators means that GAPE must choose among the possibilities. In all the experiments within this study a crossover operator is selected randomly from the set { CO,, CO,, CO3, CO, } whenever a crossover operation is to be performed. In creating this particular set for the floorplan design application, our motivation is to have the operators propagate and modify two types of information: string information, i.e., genotype building blocks, and slicing tree information, i.e., phenotype building blocks. CO, and CO2 are primarily string operations and are a "symmetric" pair with regard to operand/ operator orientation. CO, and CO, provide two levels of subtree operations, with CO3 propagating a subtree from a selected parent and CO, interchanging subtrees between parents. Given that no theory of crossover selection has emerged in the GA literature, several studies were performed using various combinations of the four crossover operators. Throughout those experiments the selection from the full set resulted in the best average scores and best-found scores.</p><p>The mutation operators take a single individual and modify it in a localized manner. We use the moves specified by Wong and Liu [33] as our mutation operators. They are: swapping two adjacent operands, switching a sequence of adjacent operators, and swapping an operator and a neighboring operand. Wong and Liu note that slicing trees are not unique representations because two trees may be distinct in terms of the ordered string of operands and operators in the Polish expression, yet represent the same floorplan. Restricting the annealing process to the domain of normalized [33] trees yields a one-to-one mapping between floorplans and slicing trees. This restricted search space is not "biased" [33] in terms of representational frequency, i.e., each floorplan represented has a representational frequency of one. While the restriction has the stated effect, bias in the search of a space is not completely determined by the representational frequency. The incremental search operations, i.e., the "next state" moves of Wong and Liu and the crossover operators of GAPE specify limited access paths in the search space. For example, in the simulated annealing of Wong and Liu it is not possible for the next state to be an arbitrary element of the search space. The possibilities are severely limited by the available "next state" moves. We contend that for GAPE the bias created by the multiple representations is more than counterbalanced by the reduction in access bias throughout the search space. To support this contention we duplicated experiments configuring GAPE with and without unique representations. In every case, the multiple representation version of GAPE derived superior solutions. Since the search strategies are different between GAPE and simulated annealing the above contention does not contradict Wong and Liu's statement that normalized representations are best for simulated annealing. Thus in the experiments reported in the next section our implementation of simulated annealing uses only normalized representations, while we allow GAPE to use unnormalized representations.</p><p>With any minimization problem, such as the floorplan design problem, the scores of the solutions should decrease over time. The score is the value of the objective function, (4). Two simple fitness functions suggest themselves. First, the fitness could be inversely related to the score; this could cause excessive compression of the range of fitnesses. Second, the fitness could be a constant minus the score. The constant must be large enough to ensure all fitnesses are positive (since they are used in the selection process) and not too large (effectively causing compression). If such a constant were optimal initially, it would become a poor choice near equilibria. For these reasons we use a time-varying "normalized" fitness.</p><p>We choose our fitness to be a function of ail the scores in the current subpopulation. We have empirically found that randomly generated solutions to the floorplan design problem have scores that are "normally distributed," i.e., have a bell-shaped curve. Fig. <ref type="figure" target="#fig_9">8</ref> shows the distribution of scores of 10 000 randomly generated solutions for a problem of size 25 to be discussed in the subsequent sections. For the data in Fig. <ref type="figure" target="#fig_9">8</ref>, 95.74% of the solutions live within two standard deviations (SD) of the mean, and 99.93% within four SD's. (Related evidence on normal distribution of scores can be found in [8], <ref type="bibr" target="#b27">[32]</ref>.) Therefore, we use</p><formula xml:id="formula_4">( ps -score(x)) + au, fitness(x) = ( 5 ) 2au,</formula><p>where p, is the mean of the scores, U, is the SD, and a is a small constant parameter. However, for the experiments discussed in the following section we set a = 1. We use clipping, i.e., setting the fitness to a very small positive value if it is negative, to ensure that fitness of a solution is positive. Our current implementation, GAPE, is a sequential simula-tion of the distributed genetic algorithm with punctuated equilibria. The system has been developed in C in a UNIX environment on a VAX 11 /780. We are in the process of porting our system to a hypercube machine recently made available to us by the University of Virginia's Institute for Parallel Computation. To make a comparative study, we also implemented a sim- ulated annealing approach of Wong and Liu [33] in C in a UNIX environment on a VAX 11 /780.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EMPIRICAL STUDIES</head><p>We have performed several experiments to demonstrate that GAPE is an effective approach. The demonstration takes the form of a comparative study of GAPE and simulated annealing. As mentioned in the introduction simulated annealing was chosen for comparison because it is a probabilistic search technique of substantial interest in the research community. In addition, from an experimental point of view, the choice is important because of the documented work on floorplan design using a formulation of the problem that allows direct comparison of the resulting solutions. The comparison will be with regard to the quality of the solutions (average scores and best-found scores) derived, while holding the number of opportunities to create possible solutions nearly constant.</p><p>The quality of solution is a better measure than precise computation times, for instance, for two reasons. First, the degree to which both GAPE and simulated annealing can be "fine tuned," in terms of CPU utilization, is enormous and we cannot with our current implementation be "fair" to the simulated annealing approach. Second, and more importantly, GAPE admits a natural extension to a parallel processing system. Here "natural" means that one should expect the additional processors to provide ''linear speedup' ' over the current sequential simulation of GAPE. Evidence of the correctness of this expectation is currently being documented in a version of GAPE implemented for the NCUBE and Intel hypercubes. Preliminary experiments on these machines indicate that GAPE communication costs are negligible with respect to total computation cost, and that linear speedup is being obtained [4]. We do not foresee such a natural extension for simulated annealing. As noted previously, there are several parallel simulated annealing algorithms in the literature [2], [5], <ref type="bibr" target="#b15">[20]</ref>, <ref type="bibr" target="#b21">[26]</ref>; however, these all involve changes in the basic model, whereas GAPE can be parallelized without change.</p><p>The comparison of quality of the resulting solution will be in the context of constant work. We define "work" to be measured in terms of the number of tentative solutions each technique examines in its optimization process. In particular, for the experiments described in the following, GAPE is configured with the following set of parameters: n = 80, E = 16, G = 50, C = 0.5, and M = 0.3. Recall that n is the number of solutions in each subpopulation, E is the number of epochs, G is the number of generations per epoch, C is the crossover rate, and M is the mutation rate. For a GAPE configuration with four subpopulations, i.e., N = 4, the above parameters specify the creation of N X E x G = 4 X 16 x 50 = 3200 generations. If we assume, in the most optimistic sense, that each crossover creates a new solution not seen before, C x n = 0.5 x 80 = 40 new solutions are seen per generation. Adding the solutions produced due to mutations (i.e., M X n = 0.3 X 80 = 24) to the above number, we come at a figure of 64 solutions per generation, resulting in 64 x 3200 = 204 800 as the total number of solutions seen by GAPE. (The qualification, "optimistic," is used due to the phenomenon of stasis, i.e., not all crossovers and mutations result in new solutions, reducing the total number of distinct strings seen.) With simulated annealing "work" is in the form of moves per temperature change and the number of such changes. For example, 175 temperature changes with 1200 moves allowed in each temperature regime results in 175 x 1200 = 210 000 solutions seen. We note that one advantage of the simulated annealing formulation is not accounted for in our work measure. The move operators of Wong and Liu allow information from the previous state to be used in calculating the new score with a savings up to possibly 30% of the score computation time <ref type="bibr" target="#b25">[30]</ref>. We have yet to derive incremental scoring for the GAPE crossover operators, causing the score of each newly created solution to be calculated completely. Developing an incremental scorer is important, as scoring dominates significantly both mutation and crossover.</p><p>In the following we will describe two types of problems. The first type has been specifically fabricated to be "artificial" problems for which the optimal solution is known. This knowledge provides an absolute scale against which to measure the scores of the solutions found. The second type is "random" and follows the specifications given by Wong and Liu <ref type="bibr" target="#b28">[33]</ref>. For the random instances it is very difficult to know what the optimal score is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. ArtiJcial Problem Instances</head><p>Let A1 and A2 denote two artificial problem instances. A1 has sixteen modules ( m = 16) each of which is a rigid square (1, = U , = 1 ) of unit area, yielding a minimum total area of 16. The wirelength costs are binary (c,, = 0 or 1) with the nonzero costs selected so that the minimum wirelength of 48 is obtained when the modules are arranged in a 4 by 4 matrix. This means that the cost between pairs of modules having unit Manhattan distance between their centers, i.e., horizontal and vertical neighbors, is set to 1 and all other costs are set to 0. Thus the optimal overall score is the sum of the minimum area and the minimum number of unit connections in the grid, 16 + 48 = 64.</p><p>For the runs on A1 , GAPE uses a mesh configuration with N = 4, i.e., each subpopulation is able to "communicate" during the interepoch transition with two other subpopulations. Each initial subpopulation is selected by creating n "random" solutions, i.e., strings representing valid Polish expressions of 16 operands. The other parameters are as given at the beginning of this section.</p><p>The simulated annealing runs of A1 also use the parameters given above, but we further specify that the annealing schedule is given by T, + = 6 * TI, with 6 = 0.973. The initial temperature was determined by making 1000 moves starting from a randomly generated solution, computing the average uphill cost, and setting the acceptance probability to 0.95 for that average uphill cost. The initial state is a randomly selected normalized solution.</p><p>Since each run of either GAPE or simulated annealing is probabilistic, ten runs, each with a distinct "random number seed," are made by each system on Al. For each run the bestfound solution is saved and the scores associated with those solutions are reported in the rows marked 1 , 2, * 10 in Table <ref type="table" target="#tab_1">I</ref> with the best score found overall given in row 1 . The average of the ten scores is reported as s.  may not be 1 . The U are chosen in conjunction with the binary costs so that the optimal placement is as shown in Fig. <ref type="figure" target="#fig_10">9</ref>. For example, us = 1, cg4 = 1, cg7 = 1, cgy = 1, c8, = 1 , and cgj = 0 for the remainingj; also, uy = 1 /3 = hy/wy, cy4 = 1, cyg = 1, cy, I I = 1, cy, 12 = 1, and cyj = 0 for the remainingj. Thus for A2 the optimal score is 42 (area) + 83 (wirelength) = 125.</p><p>The configuration for GAPE and simulated annealing are the same as for A1 , except that for simulated annealing 6 = 0.970. The results for ten runs are also shown in Table <ref type="table" target="#tab_1">I</ref>.</p><p>In interpreting Table <ref type="table" target="#tab_1">I</ref>, it is clear that GAPE performed much better on problem A1 in both the best-found and the averagebest, s, senses. On A2 simulated annealing found two solutions better than any found by GAPE. However, we make two observations. First, the average best is essentially identical for the two sets of runs. Second, the spread of the best-found scores over the sets of runs is slightly smaller for GAPE. In summary, GAPE performed much better on A1 , but marginally worse on A2. Note: the data columns in both Tables I and I1 are independently sorted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Random Problem Instances</head><p>Let R1, R2, and R3 denote three instances, randomly selected using the following characteristics. All instances have twentyfive modules ( m = 25). The area ( A i ) of each module is selected randomly from a uniform distribution over [ 1 , 201. The cost matrices have random entries selected from a uniform distribution over [0, 11. For R1 and R2, the modules have u i = 3, while for R,, U , is randomly selected from a uniform distribution over [ 1 , 41. For all three instances the modules are specified to be flexible by setting li = U;', i.e., by creating a range of allowable aspect ratios for the modules. In all cases the mod-duce solutions (of relatively inferior quality) faster. We conjecture that CY plays a role equivalent to that of temperature in simulated annealing [ 191. Therefore, various schedules can be tried on C Y . Similarly, the mutation rate can be varied over time.</p><p>The objective function in (4) has two distinct componentsarea and wirelength-to be minimized which can be tackled by two separate sets of communicating subpopulations, one set emphasizing the area term and another emphasizing the wirelength term (by using different vlaues of A). Similarly, the area and the wirelength terms can be given dynamically, changing relative importance over different epochs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1 . A slicing structure and its representations. (a) Slicing structure. (b) Skewed slicing tree and normalized Polish expression. (c) Slicing tree and Polish expression.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Fig. l(b) and (c) both provide slicing trees and Polish expressions that correspond to slicing structure of Fig. l(a). In a skewed slicing tree, no operator of the same type appears as the right son of an operator. In a normalized Polish expression, operators of the same type do not occur next to one another. There also exists a one-to-one mapping from the set of skewed slicing trees to the set of normalized Polish expressions. Thus the slicing tree and Polish expression given in Fig. l(b) are skewed and normalized, respectively. While the slicing tree and Polish expression of Fig. l(c) are not.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Fig. 2. High-level description of a genetic description of a genetic algorithm with punctuated equilibria.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Genetic algorithm used with an epoch at each processor</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>{ n,, } indicates the string positions, ordered left-to-right, of the operands of the Polish expression. Also, let the set, { r l k } with 1 I k I m -1 , be the indexes of the m -1 operators of Pi. Similarly, for P2 define { n2,} and { rZk}. CO, then performs the following steps: 1) get operands: for eachj, 1 5 j I m , assign O[n,,] the value of PI [ n l k ] ; and 2) get operators: for each k, 1 5 k I m -1, assign O[r,,] the value of P 2 [ 1 2 k ] . Fig. 4 gives an illustration of CO,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>[ I, k ] the value of P, [ r , J ; and 2) get operands: for eachj, 1 I j I m, assign O[nl,] the value of P , [ n , , ] . Fig. 5 illustrates the operation of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 4. Illustration of the crossover operator, CO,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 6. Illustration of the crossover operator, CO,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Distribution of scores of 10 000 random solutions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Optimal floorplan for problem A2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I</head><label>I</label><figDesc></figDesc><table><row><cell cols="5">PERFORMANCE COMPARISON ON PROBLEMS WITH</cell></row><row><cell></cell><cell cols="3">KNOWN OPTIMAL SOLUTIONS</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">Problem</cell><cell></cell></row><row><cell></cell><cell cols="2">A1 (16 Modules)</cell><cell cols="2">A2 (20 Modules)</cell></row><row><cell>Trial</cell><cell>GAPE</cell><cell>SA</cell><cell>GAPE</cell><cell>SA</cell></row><row><cell>1</cell><cell>72</cell><cell>94</cell><cell>166</cell><cell>154</cell></row><row><cell>2</cell><cell>80</cell><cell>98</cell><cell>166</cell><cell>164</cell></row><row><cell>3</cell><cell>80</cell><cell>99</cell><cell>167</cell><cell>176</cell></row><row><cell>4</cell><cell>83</cell><cell>100</cell><cell>183</cell><cell>178</cell></row><row><cell>5</cell><cell>89</cell><cell>105</cell><cell>184</cell><cell>186</cell></row><row><cell>6</cell><cell>91</cell><cell>106</cell><cell>184</cell><cell>190</cell></row><row><cell>7</cell><cell>94</cell><cell>107</cell><cell>187</cell><cell>194</cell></row><row><cell>8</cell><cell>94</cell><cell>109</cell><cell>193</cell><cell>196</cell></row><row><cell>9</cell><cell>96</cell><cell>109</cell><cell>199</cell><cell>196</cell></row><row><cell></cell><cell>91</cell><cell>112</cell><cell>202</cell><cell>198</cell></row><row><cell>S</cell><cell>87.6</cell><cell>103.9</cell><cell>183.3</cell><cell>183.5</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by the Office of Naval Research under Grant N00014-88-K-0486 and by the Jet Propulsion Laboratory of the California Institute of Technology under Contract 957721 to the University of Virginia's Institute for Parallel Computation. The work of J. P. Cohoon was supported by the National Science Foundation under Grant DMC 8505354. This paper was recommended by Associate Editor R.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ules have free orientations. Since the data are random, we do not know the optimal costs. For these three problem instances GAPE is in a hypercube configuration having N = 8, i.e., a regular cube, and each subpopulation communicates with three other subpopulations. All the other GAPE parameters are the same as above. On these problems, simulated annealing runs for 350 temperature changes with 1200 moves allowed in each temperature regime in order to make the "work" conformable. Further, 6 = 0.9874, 0.9840, and 0.9827 for R I , R2, and R3, respectively. Finally, for each of the three random problem instances, GAPE and simulated annealing run ten times, with the results reported in Table 11.</p><p>In interpreting Table <ref type="table">11</ref>, it is clear that GAPE performs substantially better than simulated annealing. In fact, in each set of ten runs all but one or two of the GAPE runs yields a solution having a score that is better than any solution found in simulated annealing runs.</p><p>In order to explore the effects of utilizing more computational resources, consider the results from five additional runs of each system on each problem, R1, R2, and R3. GAPE uses more resources by being configured as a five-dimensional hypercube, i.e., N = 32, having each subpopulation communicating with 5 other subpopulations. Simulated annealing increases its allowable work by having 4800 moves per temperature regime.</p><p>The resulting 3's are shown in Table <ref type="table">111</ref>. Again, GAPE performs better than simulated annealing. Note also, that as one expects, the increased resources helps both systems relative to the original runs, but that the simulated annealing with additional resources still did not perform as well as the original runs of GAPE.</p><p>To provide some indication of the dynamic behavior of GAPE, beyond the quality of derived solutions we display Fig. <ref type="figure">10</ref>. The plot depicts the average and the best-found performance of one subpopulation of the hypercube. The average computed is the average score of the solutions forming a subpopulation after a given generation has been completed. The best score is the score of the best solution produced in that generation. We note a steep fall in the first four epochs, and a local search in the later epochs. Also of interest is the fact that the curves are not monotonically decreasing. The often found increase in the average score and the best score is the result of two factors: catastrophic mixing during the communication phase of GAPE, and the creation and survivial of solutions with  relatively "bad" scores. We contend that these factors are necessary to avoid getting trapped in local minima. The key parameter affecting the steepness of the curves is a in the fitness function, (5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS AND EXTENSIONS</head><p>We have shown how distributed genetic algorithms can be used to solve the floorplan design problem. We have also empirically demonstrated the efficacy of our method, and compared it with the SA approach. Given approximately the same number of strings to be examined, our method performed consistently better than the simulated annealing approach in almost all the problem instances tried, both in terms of the average cost of the solutions found and the best-found solution. Our method can be easily implemented on a local memory, message passing distributed computer.</p><p>GAPE is characterized by many parameters. We are currently studying the detailed dynamics of GAPE to understand the specific effects of these parameters. The scaling factor, a, of (5) determines the importance of relative differences in the scores of members forming a subpopulation. In some of our preliminary experiments we have observed that lower values of a pro- He is currently an Associate Professor of Computer Science at the University of Virginia, having joined the faculty in 1982. He is also a member of the Institute for Parallel Computation at the University of Virginia. His research interests include dyhamic scene analy-sis, probabilistic problem solving methods (e.g., genetic algorithms), and applications of computer vision (e.g., user interfaces for the handicapped, and computer-aided analysis of imagery from archaeological artifacts). Among his published work is the book, Motion Understanding: Robot and Human Vision, co-edited with J. K. <ref type="bibr">Agganval, (1988)</ref>.</p><p>Dr. Martin is a member of the </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A parallel simulated annealing algorithm for standard cell placement on a hypercube computer</title>
		<author>
			<persName><forename type="first">P</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. on Computer-Aided Design</title>
		<meeting>IEEE Int. Conf. on Computer-Aided Design<address><addrLine>Santa Clara, A. Bethke</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
	<note>Genetic algorithms as function optimizers</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Genetic Algorithms for Feature Selection for Counterpropogation Networks</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Brill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Charlottesville</title>
		<imprint>
			<biblScope unit="page" from="90" to="105" />
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>VA: Instute of Parallel Computation, University of Virginia</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A parallel simulated annealing algorithm for the placement of macrocells</title>
		<author>
			<persName><forename type="first">A</forename><surname>Casotto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Romeo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="838" to="847" />
			<date type="published" when="1987-09">Sept. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Punctuated equilibria: A parallel genetic algorithm</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Cohoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">U</forename><surname>Hegde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Richards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int. Con$ Genetic Algorithms and Their Applications</title>
		<meeting>Second Int. Con$ Genetic Algorithms and Their Applications<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="148" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Genetic placement</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Cohoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">D</forename><surname>Paris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Jump Starting Simulated Annealing</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Cohoon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Roberson</surname></persName>
		</editor>
		<imprint>
			<publisher>Univ. of Virginia</publisher>
			<date type="published" when="1987-11">Nov. 1987. 1987</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="956" to="964" />
		</imprint>
	</monogr>
	<note>Dept. Comput. Sci.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Job shop scheduling with genetic algorithms</title>
		<author>
			<persName><forename type="first">L</forename><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Con&amp; on Genetic Algorithms and Their Applications</title>
		<meeting>Int. Con&amp; on Genetic Algorithms and Their Applications<address><addrLine>Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="136" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Punctuated equilibria: An alternative to phyletic gradualism</title>
		<author>
			<persName><forename type="first">N</forename><surname>Eldredge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Gould</surname></persName>
		</author>
		<editor>Models of Paleobiology, T. J. M. Schopf</editor>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Simon and Schuster</publisher>
			<pubPlace>Ed. San Francisco: CA, Freeman; Eldredge, Time Frames; New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Comparison of symbolic layout using genetic algorithms</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Fourman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. on Genetic Algorithms and Their Applications</title>
		<meeting>Int. Conf. on Genetic Algorithms and Their Applications<address><addrLine>Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Computer-aided gas pipeline opertion using genetic algorithms and learning rules</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Goldberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
		<respStmt>
			<orgName>Civil Eng., Univ. Michigan</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation Dept</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Genetic algorithms for the traveling salesperson problem</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lingle</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Grefenstette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gopal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Rosmaita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Van Gucht</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. on Genetic Algorithms and Their Applications</title>
		<meeting>Int. Conf. on Genetic Algorithms and Their Applications<address><addrLine>Pittsburgh, PA; Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985. 1985</date>
			<biblScope unit="page" from="160" to="168" />
		</imprint>
	</monogr>
	<note>Proc. Int. Conf. on Genetic Algorithms and Their Appications</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Adaptation in Natural and Artificial Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<pubPlace>Ann Arbor, MI</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Michigan</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Holyoak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Nisbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Thagard</surname></persName>
		</author>
		<title level="m">Induction: Processes of Inference, Learning, and Discovery</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parallelisation of probabilistic sequential search algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Jog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Van Gucht</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int. Conf. on Genetic Algorithms and Their Applications</title>
		<meeting>Second Int. Conf. on Genetic Algorithms and Their Applications<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1972">1987. 1986. 1972</date>
			<biblScope unit="page" from="82" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Optimization by simulated annealing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Gelatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Vecchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci</title>
		<imprint>
			<biblScope unit="volume">220</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="1983-05-13">May 13. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Placement by simulated annealing on a multiprocessor</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kravitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rutenbar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Mason: A global footplanning tool</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Lapotin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Director</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. on Computer-Aided Design</title>
		<meeting>IEEE Int. Conf. on Computer-Aided Design<address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="143" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automatic floorplan design</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H J M</forename><surname>Otten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th ACM-IEEE Design Automation Conf</title>
		<meeting>19th ACM-IEEE Design Automation Conf<address><addrLine>Minneapolis, MN</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient floorplan optimization</title>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. on Computer Design</title>
		<meeting>IEEE Int. Conf. on Computer Design<address><addrLine>Port Chester, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="499" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Floorplan design using simulated annealing</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H J M</forename><surname>Otten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P P P</forename><surname>Van Ginneken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. on Computer-Aided Design</title>
		<meeting>IEEE Int. Conf. on Computer-Aided Design<address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="96" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A parallel genetic algorithm</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Pettey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Leuze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Grefenstette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int. Conf. on Genetic Algorithms and Their Applications</title>
		<meeting>Second Int. Conf. on Genetic Algorithms and Their Applications<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="155" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Parallel standard cell placement algorithms with quality equivalent to simulated annealing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Snelgrove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">2</forename><forename type="middle">G</forename><surname>Vranesic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="387" to="396" />
			<date type="published" when="1988-03">Mar. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Timbenvolf placement and routing package</title>
		<author>
			<persName><forename type="first">C</forename><surname>Sechen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Solid-state Circuits</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The cosmic cube</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Seitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Bin packing with adaptive search</title>
		<author>
			<persName><forename type="first">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Con$ on Genetic Algorithms and Their Applications</title>
		<meeting>Int. Con$ on Genetic Algorithms and Their Applications<address><addrLine>Pittsburgh</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Optimal orientations of cells in slicing floorplan designs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Contr</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="91" to="101" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Parallel genetic algorithm for a hypercube</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tanese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int. Conf. on Genetic Algorithms and Their Applications</title>
		<meeting>Second Int. Conf. on Genetic Algorithms and Their Applications<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="177" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Concepts of scale in simulated annealing</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. on Computer Design: VLSI in Computer</title>
		<meeting>IEEE Int. Conf. on Computer Design: VLSI in Computer<address><addrLine>Port Chester, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="646" to="651" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A new algorithm for floorplan design</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd ACM-IEEE Design Automation Conf</title>
		<meeting>23rd ACM-IEEE Design Automation Conf<address><addrLine>Las Vegas, NV</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="101" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Leong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Liu</surname></persName>
		</author>
		<title level="m">Simulated Annealing for VLSI Design</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Pioneer: A macrobased floorplanning design system</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">T</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLSI Systems Design, pp. CAD-4</title>
		<imprint>
			<date type="published" when="1985">July 1987. 1985. 1985</date>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="22" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><surname>Pa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="202" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Boston</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986-08">1988. 32-43, Aug. 1986</date>
			<publisher>Kluwer Academic</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">D. degree in computer science from the University of Minnesota, Minneapolis, MN in 1982. In 1983, he joined the Department of Computer Science at the University of Virginia, Charlottesville, VA. where he is currently an Associate Professor. He is also a member of the Institute for Parallel Computation and the Center for Semicustom Integrated Systems. His primary research interests are in various aspects of computer-aided design, with particular emphasis on circuit layout. Other research interests include computational geometry, parallel algorithms, and heuristic search</title>
		<author>
			<persName><forename type="first">P</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Cohoon</surname></persName>
		</author>
		<author>
			<persName><surname>Sigact</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Datc</forename><surname>Sigda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Upsilon</forename><surname>Pi Epsilon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">He has served on such programming committees as the IEEE International Conference on Computer-Aided Design and the International Workshop on Layout Synthesis</title>
		<meeting><address><addrLine>Mahwah, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975">1975</date>
		</imprint>
		<respStmt>
			<orgName>Pennsylvania State University, State College</orgName>
		</respStmt>
	</monogr>
	<note>M&apos;82) received the B.S. degree in mathematics from Ramapo College of New Jersey. He is a member of the SIGDA Advisory Board and administers their travel and library grant programs</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
