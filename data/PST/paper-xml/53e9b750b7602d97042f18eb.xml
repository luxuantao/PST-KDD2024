<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Network Adiabatic Theorem: An Efficient Randomized Protocol for Contention Resolution</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shreevatsa</forename><surname>Rajagopalan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Devavrat</forename><surname>Shah</surname></persName>
							<email>devavrat@mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Jinwoo</forename><surname>Shin</surname></persName>
							<email>jinwoos@mit.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="laboratory">Laboratory for Information and Decision Systems</orgName>
								<address>
									<region>MIT</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<address>
									<settlement>Seattle</settlement>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Network Adiabatic Theorem: An Efficient Randomized Protocol for Contention Resolution</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F5FACD8E517FC094FB82B686A802CF7F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G.3 [Probability and Statistics]: Stochastic processes</term>
					<term>Markov processes</term>
					<term>Queueing theory; C.2.1 [Network Architecture and Design]: Distributed networks</term>
					<term>Wireless communication Algorithms</term>
					<term>Performance</term>
					<term>Design Wireless multi-access</term>
					<term>Markov chain</term>
					<term>Mixing time</term>
					<term>Aloha</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The popularity of Aloha(-like) algorithms for resolution of contention between multiple entities accessing common resources is due to their extreme simplicity and distributed nature. Example applications of such algorithms include Ethernet and recently emerging wireless multi-access networks. Despite a long and exciting history of more than four decades, the question of designing an algorithm that is essentially as simple and distributed as Aloha while being efficient has remained unresolved.</p><p>In this paper, we resolve this question successfully for a network of queues where contention is modeled through independent-set constraints over the network graph. The work by <ref type="bibr" target="#b31">Tassiulas and Ephremides (1992)</ref> suggests that an algorithm that schedules queues so that the summation of "weight" of scheduled queues is maximized, subject to constraints, is efficient. However, implementing such an algorithm using Aloha-like mechanism has remained a mystery. We design such an algorithm building upon a Metropolis-Hastings sampling mechanism along with selection of "weight" as an appropriate function of the queue-size. The key ingredient in establishing the efficiency of the algorithm is a novel adiabatic-like theorem for the underlying queueing network, which may be of general interest in the context of dynamical systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>A multiple-access channel is a broadcast channel that allows multiple users to communicate with each other by sending messages onto the channel. If two or more users simultaneously send messages, then the messages interfere with each other (collide), and the messages are not transmitted successfully. The channel is not centrally controlled. Instead, users need to use a distributed protocol or algorithm to resolve contention. The popular Aloha protocol or algorithm was developed more than four decades ago to address this (e.g. see <ref type="bibr" target="#b1">[1]</ref>). The key behind such a protocol is using collision or busyness of the channel as a signal of congestion and then reacting to it using a simple randomized rule.</p><p>Although the most familiar multiple-access channels are wireless multiple-access media (a la IEEE 802.11 standards) and wired local-area networks (such as Ethernet networks), now multiple-access channels are also being implemented using a variety of technologies including packet-radio, fiberoptics, free-space optics and satellite transmission (e.g. see <ref type="bibr" target="#b12">[12]</ref>). These multiple-access channels are used for communication in many distributed networked systems, including emerging communication networks such as the wireless mesh networks <ref type="bibr" target="#b25">[25]</ref>.</p><p>Despite the long history and great importance of multiaccess contention-resolution protocols, the question of designing an efficient Aloha-like simple protocol (algorithm) has remained unresolved in complete generality even for one multiple-access channel. In this paper, we are interested in designing a distributed contention resolution protocol for a network of multiple-access channels in which various subsets of these network users (nodes) interfere with each other. For example, in a wireless network placed in a geographic area, two users interfere with each other if they are nearby and do not interfere if they are far apart. Such networks can be naturally modeled as queueing networks with contentions modeled through independent-set constraints over the network interference graph. For this setup, we will design a simple randomized, Aloha-like, algorithm that is efficient. Indeed, as a special case, it resolves the classical multipleaccess single broadcast channel problem as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related work</head><p>Design and analysis of multiple-access contention resolution algorithms have been of great interest for four decades across research communities. Due to its long and rich history, it will be impossible for us to provide a complete history. We will describe a few of these results that are closer to our result. Primarily, research has been divided into two classes: single channel multiple-access protocols and network multiple-access protocols.</p><p>Single multi-access channel. The research in single channel setup evolved into two branches: (a) Queue-free model and (b) Queueing model. For the queue-free model, some notable works about inefficiency of certain class of protocols are due to Kelly and McPhee <ref type="bibr" target="#b18">[18]</ref>[19] <ref type="bibr" target="#b20">[20]</ref>, Aldous <ref type="bibr" target="#b2">[2]</ref>, Goldberg, Jerrum, Kannan and Paterson <ref type="bibr" target="#b10">[10]</ref> and Tsybakov and Likhanov <ref type="bibr" target="#b32">[32]</ref> -the last one establishing impossibility of throughput optimality for any protocol in the queuefree model. On the positive side for the queue-free model, work by Mosley and Humblet establishes existence of a "treeprotocol" with a positive rate. There are many other results on related models; we refer an interested reader to Ephremides and Hajek <ref type="bibr" target="#b6">[6]</ref> and the online survey by Leslie Goldberg <ref type="bibr" target="#b11">[11]</ref>.</p><p>For the queueing model, a notable positive result is due to Hastad, Leighton and Rogoff <ref type="bibr" target="#b15">[15]</ref> that establishes that if there are N users with each having the same rate λ/N , a (polynomial) version of the standard back-off protocol is stable as long as λ &lt; 1. Of course, this does not extend to case when users have different rates even though their net rate might be less than 1. In summary, there is no known algorithm that operates without any information exchange between queues while being efficient (or throughput-optimal) in the queueing model even for single multi-access channel.</p><p>Network of multiple-access channels. The lack of any efficient protocol without information exchange even for a single channel has led to an exciting progress in the past 5 years or so for designing message-passing algorithms for a network of multiple-access channels. Interest in such algorithms has been fueled by emergence of wireless multi-hop networks as a canonical architecture for an access network in a residential area or a metro-area network in a dense city. In what follows, we briefly describe some of the key recent results.</p><p>Primarily, the focus has been on a network queueing model with an associated interference graph. Here two queues can not transmit simultaneously if they are neighbors in their interference graph. Therefore effectively a contentionresolution protocol or scheduling algorithm is required to schedule, at each time, transmissions of queues that form an independent set of the network interference graph (see Section 2 for a detailed formal description). Now, ignoring implementation concerns, the work by Tassiulas and Ephremides <ref type="bibr" target="#b31">[31]</ref> established that the maximum weight (MW) algorithm, which schedules queues satisfying independent-set constraints with maximum summation of their weights, where the weight of a queue is its queue-size, is throughput-optimal. However, implementing the MW algorithm, i.e. finding a maximum weighted independent set in the network interference graph in a distributed and simple manner, is a daunting task. Ideally, one wishes to design a MW algorithm that is as simple as the random-access protocols (or Aloha). This has led researchers to exploit two approaches: (1) design of random-access algorithms with access probabilities that are arrival-rate-aware, and (2) design of distributed implementations of MW algorithms.</p><p>We begin with the first line of approach. Here the question boils down to finding appropriate channel access probabilities for head-of-line packets as a function of their local history (i.e. age, queue-size or backoff). In a very important and exciting recent work, Bordenave, McDonald and Proutiére <ref type="bibr" target="#b3">[3]</ref> obtained characterization of the capacity region of a multi-access network with given (fixed) access probabilities in the limit of the large network size (mean-field limit). Notably, this work settled an important question that had remained open for a while. On the flip side, it provides an approximate characterization of the capacity region for a small network (precise approximation error is not clear to us). Also, a fixed set of access probabilities is unlikely to work for any arrival rate vector in the capacity region. Therefore, to be able to support a larger capacity region, one needs to select access probabilities that should be adjusted depending on system arrival process and this will require some information exchange.</p><p>In an earlier work motivated by this concern, Marbach <ref type="bibr" target="#b21">[21]</ref> as well as Eryilmaz, Marbach and Ozdaglar <ref type="bibr" target="#b22">[22]</ref> did consider the selection of access probabilities based on the arrival rates. In a certain asymptotic sense, they established that their rate-aware selection of the access probabilities allocate rates to queues so that the allocated rates are no less than the arrival rates. A caveat of their approach was "saturated system" analysis and the goodness of the algorithm in an asymptotic sense.</p><p>Another sequence of works by Gupta and Stolyar <ref type="bibr" target="#b14">[14]</ref>, Stolyar <ref type="bibr" target="#b30">[30]</ref> and Liu and Stolyar <ref type="bibr" target="#b17">[17]</ref> considered randomaccess algorithms where the access probabilities are determined as a function of the queue-sizes by means of solving an optimization problem in a distributed manner. The algorithm has certain throughput (Pareto) optimality property. However, it requires solving an optimization problem in a distributed manner every time! This can lead to a lot of information exchange per time step. We take note of a very recent work by Jiang and Walrand <ref type="bibr" target="#b16">[16]</ref> that employs a similar approach for determining the access probabilities using arrival rate information. They also speculate an intuitively pleasing connection between their rate-aware approach with a queue-aware approach. However, they do not establish the stability of the network under their algorithm. Interestingly enough, we strongly believe that our proof techniques may establish the stability of (a variant of) their algorithm.</p><p>Many of these approaches for determining access probabilities based on rates are inherently not 'robust' against change of rates and this is what strongly motivates queuebased approaches, i.e. distributed implementation of MW algorithm. As the first non-trivial step, Modiano, Shah and Zussman <ref type="bibr" target="#b24">[24]</ref> provided a totally distributed, simple gossip algorithm to find an approximate MW schedule each time for matching constraints (it naturally extends to independentset constraints and to cross-layer optimal control of a multihop network, e.g. see <ref type="bibr" target="#b7">[7]</ref>). This algorithm is throughputoptimal, like the standard MW algorithm it does not require information about arrival rates, or it does not suffer from the caveat of "saturated system" analysis. In this algorithm, the computation of each schedule requires up to O(n 3 ) information exchange. In that sense, the algorithm is not implementable and merely a proof-of-concept. Mo-tivated by this, Sanghavi, Bui and Srikant <ref type="bibr" target="#b26">[26]</ref> designed (almost) throughput-optimal algorithm with constant (but large) amount of information exchange per node for computing a new schedule. However, their approach is applicable only to matching constraints and it does require (large) constant amount of co-ordination between local neighborhoods for good approximation guarantee (e.g. for 95% throughput, it requires co-ordination of neighbors within ∼ 20 hops!). Finally, their approach does not extend to independent-set constraints.</p><p>In summary, none of the random-access based algorithms that are studied in the literature have desirable properties, as one or more of the following limitation exists. (1) They assume "saturated system", hence need to solve an optimization problem using the knowledge of arrival rate that requires a lot of message-passing. (2) The capacity region is not the largest possible. (3) The distributed implementation of the MW algorithm, though provides the proof-of-concept of existence of a distributed, simple and throughput-optimal algorithm; they require a lot of information exchange for the computation of each schedule. That is, they are not simple or elegant enough (like Aloha) to be of practical utility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Contributions</head><p>As the main contribution of this paper, we design a throughput-optimal and stable<ref type="foot" target="#foot_0">1</ref> random-access algorithm for a network of queues where contention is modeled through independent set constraints. Our random-access algorithm is elegant, simple and, in our opinion, of great practical importance. And it indeed achieves the desired throughputoptimality property by making the random-access probabilities time-varying and a function of the queue-size. The key to the efficiency of our algorithm lies in the careful selection of this function.</p><p>To this end, first we observe that if queue-sizes were fixed then one can use Metropolis-Hastings based sampling mechanism to sample independent sets so that sampled independent sets provides a good approximation of the MW algorithm. As explained later in detail (or an informed reader may gather from the literature), the Metropolis-Hastings based sampling mechanism is essentially a continuous time random access protocol (like Aloha). Therefore, for our purposes the use of Metropolis-Hastings sampler would suffice only if queue-sizes were fixed. But queue-sizes change essentially at unit rate and the time for Metropolis-Hastings to reach "equilibrium" can be much longer. Therefore, in essence the Metropolis-Hastings mechanism may never reach "equilibrium" and hence such an algorithm may perform very poorly.</p><p>We make the following crucial observations to resolve this issue: (1) the queue-size may change at unit rate, but a function (say f ) of the queue-size may change slowly (i.e. has a small derivative f ); (2) the MW algorithm is stable even when the weight is not the queue-size but some slowly changing function of the queue-size. In this paper, we will use a function f (x) ∼ log log x for this purpose. Motivated by this, we design Metropolis-Hastings sampling mechanism to sample independent sets with weights defined as this slowly changing function of the queue-size. This is likely to allow our network to be in a state so that the random-access al-gorithm based on Metropolis-Hastings method is essentially sampling independent sets as per the "correct" distribution all the time. As the key technical contribution, we indeed establish this non-trivial desirable result. This technical result is a "robust probabilistic" analogue of the standard adiabatic theorem <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b13">13]</ref> in physics which states that if a system changes in a reversible manner at an infinitesimally small rate, then it always remains in its ground state (see statement of Lemma 12 and Section 5.5 for precise details).</p><p>As a consequence of this (after overcoming necessary technical difficulties), we obtain a random-access based algorithm under which the network Markov process is positive Harris recurrent (or stable) and throughput-optimal. We present simulation results to support its practical relevance. Our results (both in simulation and theory) suggest that our choice of f is critical since the natural choice of weight as the queue-size (i.e. f (x) = x) will not lead to a throughputoptimal algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>Notation. We will reserve bold letters for vectors: e.g. u = [ui] d i=1 denotes a d-dimensional vector; 1 and 0 denote the vector of all 1s and all 0s. Given a function φ : R → R, by φ(u) we mean φ(u) = [φ(u i )]. For any vector u = [u i ], define u max = max i u i and u min = min i u i . For a probability vector π ∈ R d + on d elements, we will use a notation π = [π(i)] where π(i) is the probability of i,</p><formula xml:id="formula_0">1 ≤ i ≤ d.</formula><p>Network model. Our network is a collection of n queues. Each queue has a dedicated exogenous arrival process through which new work arrives in the form of unit-sized packets. Each queue can be potentially serviced at unit rate, resulting in departures of packets from it upon completion of their unit service requirement. The network will be assumed to be single-hop, i.e. once work leaves a queue, it leaves the network. At first glance, this appears to be a strong limitation. However, as we discuss later in Section 3, the results of this paper, in terms of algorithm design and analysis, naturally extend to the case of the multi-hop setting.</p><p>Let t ∈ R + denote the (continuous) time and τ = t ∈ N denote the corresponding discrete time slot. Let Qi(t) ∈ R+ be the amount of work in the ith queue at time t. Queues are served in First-Come-First-Serve manner. Q i (t) is the number of packets in queue i at time t, e.g. Q i (t) = 2.7 means head-of-line packet has received 0.3 unit of service and 2 packets are waiting behind it. Also, define Qi(τ</p><formula xml:id="formula_1">) = Qi(τ + ) for τ ∈ N. Let Q(t), Q(τ ) denote the vector of queue- sizes [Q i (t)] 1≤i≤n , [Q i (τ )</formula><p>] 1≤i≤n respectively. Initially, time t = τ = 0 and the system starts empty, i.e. Q(0) = 0.</p><p>Arrival process is assumed to be discrete-time with unitsized packets arriving to queues, for convenience. Let Ai(τ ) denote the total packets that arrive to queue i in [0, τ ] with assumption that arrivals happen at the end in each time slot, i.e. arrivals in time slot τ happen at time (τ + 1) -and are equal to Ai(τ +1)-Ai(τ ) packets. For simplicity, we assume Ai(•) are independent Bernoulli processes with parameter λi. That is, A i (τ +1)-A i (τ ) ∈ {0, 1} and Pr(A i (τ +1)-A i (τ ) = 1) = λ i for all i and τ . Denote the arrival rate vector as λ = [λ i ] 1≤i≤n .</p><p>The queues are offered service as per a continuous-time (or asynchronous/non-slotted) scheduling algorithm. Each of the n queues is associated with a wireless transmissioncapable device. Under any reasonable model of communica-tion deployed in practice (e.g. 802.11 standards), in essence if two devices are close to each other and share a common frequency to transmit at the same time, there will be interference and data is likely to be lost. If the devices are far away, they may be able to simultaneously transmit with no interference. Thus the scheduling constraint here is that no two devices that might interfere with each other can transmit at the same time. This can be naturally modeled as an independent-set constraint on a graph (called the interference graph), whose vertices correspond to the devices, and where two vertices share an edge if and only if the corresponding devices would interfere when simultaneously transmitting. Specifically, let G = (V, E) denote the network interference graph with V = {1, . . . , n} representing n nodes and E = {(i, j) : i and j interfere with each other} .</p><p>Let N (i) = {j ∈ V : (i, j) ∈ E} denote the neighbors of node i. We assume that if node i is transmitting, then all of its neighbors in N (i) can "listen" to it. Let I(G) denote the set of all independent sets of G, i.e. subsets of V so that no two neighbors are adjacent to each other. Formally,</p><formula xml:id="formula_2">I(G) = {σ = [σi] ∈ {0, 1} n : σi + σj ≤ 1 for all (i, j) ∈ E}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Under this setup, the set of feasible schedules S = I(G).</head><p>Given this, let σ(t) = [σi(t)] denote the collective scheduling decision at time t ∈ R + , with σ i (t) being the rate at which node i is transmitting. Then as discussed, it must be that σ(t) ∈ I(G), σ i (t) ∈ {0, 1} for all i, t.</p><p>The queueing dynamics induced under the above described model can be summarized by the following equation: for any 0 ≤ s &lt; t and 1</p><formula xml:id="formula_3">≤ i ≤ n, Qi(t) = Qi(s) - t s σi(y)1 {Q i (y)&gt;0} dy + Ai(s, t),</formula><p>where A i (s, t) denotes the cumulative arrival to queue i in time interval [s, t] and 1 {x} denotes the indicator function. Finally, define the cumulative departure process</p><formula xml:id="formula_4">D(t) = [D i (t)],</formula><p>where</p><formula xml:id="formula_5">D i (t) = t 0 σ i (y)1 {Q i (y)&gt;0} dy.</formula><p>Performance metric. We need an algorithm to select schedule σ(t) ∈ S = I(G) for all t ∈ R+. Thus, a scheduling algorithm is equivalent to scheduling choices σ(t), t ∈ R + . From the perspective of network performance, we would like the scheduling algorithm to be such that the queues in network remain as small as possible given the arrival process. From the implementation perspective, we wish that the algorithm be simple and distributed, i.e. perform constant number of logical operations at each node (or queue) per unit time, utilize information only available locally at the node or obtained through a neighbor and maintain as little data structure as possible at each node.</p><p>First, we formalize the notion of performance. In the setup described above, we define capacity region C ⊂ [0, 1] n as the convex hull of the feasible scheduling set I(G) = S, i.e.</p><formula xml:id="formula_6">C =    σ∈S ασσ : σ∈S ασ = 1 and ασ ≥ 0 for all σ ∈ I(G)    .</formula><p>The intuition behind this definition of capacity region comes from the fact that any algorithm has to choose schedule from I(G) each time and hence the time average of the 'service rate' induced by any algorithm must belong to C. Therefore, if arrival rates λ can be 'served' by any algorithm then it must belong to C. Motivated by this, we call an arrival rate vector λ admissible if λ ∈ Λ, where Λ = {λ ∈ R n + : λ ≤ σ componentwise, for some σ ∈ C} . We say that an arrival rate vector λ is strictly admissible if λ ∈ Λ o , where Λ o is the interior of Λ formally defined as</p><formula xml:id="formula_7">Λ o = {λ ∈ R n + : λ &lt; σ componentwise,</formula><p>for some σ ∈ C} . Equivalently, we may say that the network is underloaded. Now we are ready to define the performance metric for a scheduling algorithm.</p><p>Definition 1 (throughput-optimal). We call a scheduling algorithm throughput-optimal, or stable, or providing 100% throughput, if for any λ ∈ Λ o the underlying network Markov process is positive Harris recurrent.</p><p>Positive Harris recurrence &amp; its implications. For completeness, we define the well known notion of positive Harris recurrence (e.g. see <ref type="bibr" target="#b5">[5]</ref>). We also state its useful implications to explain its desirability. In this paper, we will be concerned with discrete-time, time-homogeneous Markov process or chain evolving over a complete, separable metric space X. Let B X denote the Borel σ-algebra on X. Let X(τ ) denote the state of Markov chain at time τ ∈ N.</p><p>Consider any A ∈ B X . Define stopping time</p><formula xml:id="formula_8">TA = inf{τ ≥ 1 : X(τ ) ∈ A}. Then the set A is called Harris recurrent if Prx(TA &lt; ∞) = 1 for any x ∈ X,</formula><p>where Pr x (•) ≡ Pr(•|X(0) = x). A Markov chain is called Harris recurrent if there exists a σ-finite measure µ on (X, B X ) such that whenever µ(A) &gt; 0 for A ∈ B X , A is Harris recurrent. It is well known that if X is Harris recurrent then an essentially unique invariant measure exists (e.g. see Getoor <ref type="bibr" target="#b9">[9]</ref>). If the invariant measure is finite, then it may be normalized to obtain a unique invariant probability measure (or stationary probability distribution); in this case X is called positive Harris recurrent.</p><p>A popular algorithm. In this paper, our interest is in scheduling algorithms that utilize the network state, i.e. the queue-size Q(t), to obtain a schedule. An important class of scheduling algorithms with throughput-optimality property is the well known maximum-weight scheduling algorithm which was first proposed by Tassiulas and Ephremides <ref type="bibr" target="#b31">[31]</ref>. We describe the slotted-time version of this algorithm. In this version, the algorithm changes decision in the beginning of every time slot using Q(τ ) = Q(τ + ). Specifically, the scheduling decision σ(τ ) remains the same for the entire time slot τ , i.e. σ(t) = σ(τ ) for t ∈ (τ, τ + 1], and it satisfies</p><formula xml:id="formula_9">σ(τ ) ∈ arg max ρ∈S i ρiQi(τ ).</formula><p>Thus, this maximum weight or MW algorithm chooses schedule σ ∈ S that has the maximum weight, where weight is defined as</p><formula xml:id="formula_10">σ • Q(τ ) = n i=1 σ i Q i (τ ). A natural generaliza- tion of MW algorithm uses a weight f (Q i (•)) instead of Q i (•)</formula><p>as above for some function f (e.g. see <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b28">28]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MAIN RESULT</head><p>This section presents the main result of this paper, namely an efficient distributed scheduling algorithm. In what follows, we begin by describing the algorithm. Our algorithm is designed with the aim of approximating the maximum weight in a distributed manner. For our distributed algorithm to be efficient (or throughput-optimal), the approximation quality of the maximum weight has to be good. As we shall establish, such is the case when the selection of weight function is done carefully. Therefore, first we describe the algorithm for a generic weight function. Next, we formally state the efficiency of the algorithm for a specific weight function. This is followed by some details for distributed implementation. Finally, we discuss the extension of the algorithm for the multi-hop setting, as well as a conjecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Algorithm description</head><p>As before, let t ∈ R+ denote the time. Let</p><formula xml:id="formula_11">W (t) = [W i (t)] ∈ R n</formula><p>+ denote the vector of weights at the n queues at time t. As we shall see, W (t) will be a certain function of the queue-sizes Q(t). The algorithm we describe is a continuous time algorithm that wishes to compute schedule σ(t) ∈ I(G) in a distributed manner so as to have weight i σ i (t)W i (t) as large as possible. The algorithm is randomized and asynchronous. Each node has an independent Exponential clock of rate 1. Let T i k be the time when the clock of node i ticks for the kth time. Initially, k = 0 and T i 0 = 0 for all i. Then T i k+1 -T i k are i.i.d. and have Exponential distribution of mean 1. The nodes change their scheduling decisions only upon their clock ticks. That is, σi(t) remains constant for t ∈ (T i k , T i k+1 ]. Note that due to the property of continuous random variables, no two clock ticks at different nodes will happen at the same time (with probability 1).</p><p>Let the algorithm start with null-schedule, i.e. σ(0) = [0] ∈ I(G). Consider time T i k , the kth clock tick of node i for k &gt; 0. Now node i at this particular time instant t = T i k "listens" to the medium and does the following:</p><p>• If any neighbor is transmitting, then σi(t + ) = 0.</p><p>• Else, σ i (t + ) = 1 with probability exp(W i (t))</p><p>1+exp(W i (t)) and σ i (t + ) = 0 otherwise. This randomized decision is done independently of everything else. We assume that if σ i (t) = 1, then node i will always transmit data irrespective of the value of Qi(t) so that the neighbors of node i, i.e. nodes in N (i), can infer σi(t) by "listening" to the medium.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Efficiency of algorithm</head><p>We describe a specific choice of weight W (t) for which the above described algorithm is throughput-optimal for any network graph G. In what follows, let f (•) : R + → R + be a strictly concave monotonically increasing function with f (0) = 0. We will be interested in functions growing much slower than log(•) function. Specifically, we will use the function f (x) = log log (x + e) in our algorithm, where log(•) is the natural logarithm. For defining the weight, we will utilize a given small constant ε &gt; 0. Let Qmax,i(t) be an estimation of Qmax(t) at node i at time t. A straightforward algorithm to compute Q max (t) is described in Section 3.3. As will be established in Lemma 2, Q max (t) -2n ≤ Q max,i (t) ≤ Q max (t) for all i and t &gt; 0. Now define the weight at node i,</p><formula xml:id="formula_12">W i (t) = max f (Q i ( t )), ε n f ( Q max,i ( t )) . (1)</formula><p>For such a choice of weight, we state the following throughput optimality property of the algorithm.</p><p>Theorem 1. Consider any ε &gt; 0. Suppose the algorithm uses weight as defined in (1) with f (x) = log log(x + e), and</p><formula xml:id="formula_13">| Q max,i (t) -Q max (t)</formula><p>| is uniformly bounded 2 by a constant for all t. Then, for any λ ∈ (1 -2ε)Λ o , the (appropriately defined) network Markov process is positive Harris recurrent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Distributed implementation</head><p>The goal here is to design an algorithm that is truly distributed and simple. That is, each node makes only constant number of operations locally each time, communicates only constant amount of information to its neighbors, maintains only constant amount of data structure and utilizes only local information. Further, we wish to avoid algorithms that satisfy the above properties by collecting some information over time. In essence, we want simple "Markovian" algorithms.</p><p>The algorithm described above, given the knowledge of node weight W i (•) at node i for all i, does have these properties. Now the weight Wi(•) as defined in (1) depends on</p><formula xml:id="formula_14">Q i (•) and Q max (•) (or its estimate Q max,i (•)). Trivially, the Q i (•</formula><p>) is known at each node. However, the computation of Q max (•) requires global information. Next, we describe a simple scheme in which each node maintains an estimate Q max,i (•) at node i. To keep this estimate updated, each node broadcasts exactly one number to all of its neighbors every time slot. And, using the information received from its neighbors each time, it updates its estimate. Before describing it, we make a note of the following: In section 3.5, we provide a conjecture (supported by simulation results, see section 6) that the algorithm without the term corresponding to Qmax,i(t) in (1) should be throughput-optimal. Therefore, for the practioner we recommend the algorithm that is conjectured in section 3.5. Now, we state the precise procedure to compute Qmax,i(t), the estimate of Qmax(t) at node i at time t. It is updated once every time slot. That is, Q max,i (t) = Q max,i ( t ). Let Qmax,i(τ ) be the estimate of node i at time slot τ ∈ N. Then node i broadcasts this estimate to its neighbors at the end of time slot τ . Let Q max,j (τ ) for j ∈ N (i) be the estimates received by node i at the end of time slot τ . Then, update</p><formula xml:id="formula_15">Q max,i (τ +1) = max max j∈N (i)∪{i} Q max,j (τ ) -1, Q i (τ + 1) .</formula><p>We state the following property of this estimation algorithm, the proof follows in a straightforward manner from the fact that Q i (τ ) is 1-Lipschitz.</p><p>Lemma 2. Assuming that graph G is connected, we have, for all τ ≥ 0 and all i,</p><formula xml:id="formula_16">Q max (τ ) -2n ≤ Q max,i (τ ) ≤ Q max (τ ).</formula><p>2 See Lemma 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Extensions</head><p>The algorithm described here is for the single-hop network with the exogenous arrival process. As the reader will find, the key reason behind the efficiency of the algorithm is similar to the reason behind the efficiency of the standard maximum weight scheduling (here, the weight is log log(•) function of the queue-size). The standard maximum weight algorithm has a known version for a general multi-hop network with choice of routing by Tassiulas and Ephremides <ref type="bibr" target="#b31">[31]</ref>. This is popularly known as back pressure algorithm, where weight of an action of transferring a packet from node i to node j is determined in terms of the difference of queuesizes at node i and node j. Analogously, our algorithm can be modified for such a setup by using the weight of an action of transferring a packet from node i to node j as the difference of log log(•) of queue-sizes at node i and node j. The corresponding changes in algorithm described in Section 3.1 is strongly believed to be efficient using the similar proof method as that in this paper. More generally, there have been clever utilizations of such a back-pressure approach in designing congestion control and scheduling algorithm in a multi-hop wireless network, e.g. see the survey by Shakkottai and Srikant <ref type="bibr" target="#b29">[29]</ref>. Again, we strongly believe that the utilization of our algorithm with appropriate weights will lead to a complete solution for congestion control and scheduling in a multi-hop wireless network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">A conjecture</head><p>The algorithm described for the single hop network utilizes the weight W i (t) defined as <ref type="bibr" target="#b1">(1)</ref>. This weight W i (t) depends on Qi( t ), the queue size of node i; and Qmax,i(t), the estimate of Q max (t). Among these, the use of Q max,i (t) is for 'technical' reasons. While the algorithm described here provides a provably random access algorithm, we conjecture that the algorithm that operates without the use of Qmax,i(•) in the weight definition should be efficient. Formally, we state our conjecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conjecture 3. Consider the algorithm described in Section 3.1 with weight of node i at time t as</head><formula xml:id="formula_17">W i (t) = f (Q i ( t )).</formula><p>(2)</p><p>Then, this algorithm is positive Harris recurrent as long as λ ∈ Λ o and f (x) = log log(x + e).</p><p>This conjecture is empirically found to be true in the context of a specific class of network graph topologies (grid graph) as suggested in section 6. However, such a verification can only be accepted with partial faith.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">TECHNICAL PRELIMINARIES</head><p>We present some known results about stationary distribution and convergence time (or mixing time) to stationary distribution for a specific class of finite-state Markov chains known as Glauber dynamics (or Metropolis-Hastings). As the reader will find, these results will play an important role in establishing the positive Harris recurrence of the network Markov chain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Finite state Markov chain</head><p>Consider a time-homogeneous Markov chain over a finite state space Ω. Let the |Ω| × |Ω| matrix P be its transition probability matrix. If P is irreducible and aperiodic, then the Markov chain has an unique stationary distribution and it is ergodic in the sense that lim τ →∞ P τ (j, i) → π i for any i, j ∈ Ω. Here π = [πi] denotes the stationary distribution of the Markov chain. The adjoint of the transition matrix P , also called the time-reversal of P , is denoted by P * and defined as: for any i, j ∈ Ω, π(i)P * (i, j) = π(j)P (j, i). By definition, P * has π as its stationary distribution. If P = P * then P is called reversible.</p><p>Our interest is in a specific irreducible, aperiodic and reversible Markov chain on the finite space Ω = I(G), the set of independent sets of a given network graph G = (V, E). This is also known as Glauber dynamics (or Metropolis-Hastings). We define it next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Glauber dynamics). Consider a node weighted graph G = (V, E) with W = [W i ] i∈V the vector of node weights. Let I(G) denote the set of all independent sets of G. Then the Glauber dynamics on I(G) with weights given by W , denoted by GD(W ), is the following Markov chain. Suppose the Markov chain is at state σ = [σi]i∈V , then the next transition happens as follows:</head><p>• Pick a node i ∈ V uniformly at random.</p><formula xml:id="formula_18">• If σj = 0 for all j ∈ N (i), then σi = 1 with probability exp(W i ) 1+exp(W i ) 0 otherwise.</formula><p>• Otherwise, σi = 0.</p><p>As the reader will notice, our algorithm described in Section 3 is effectively an asynchronous version of the above described Glauber dynamics with time-varying weights. In essence, we will be establishing that even with asynchronous time-varying weights, the behavior of our algorithm will be very close to that of the Glauber dynamics with fixed weight in its stationarity. To this end, next we state a property of this Glauber dynamics in terms of its stationary distribution, which follows easily from the reversibility of GD(W ).</p><p>Lemma 4. Let π be the stationary distribution of GD(W ) on the space of independent sets I(G) of the graph G = (V, E). Then,</p><formula xml:id="formula_19">π(σ) = 1 Z exp(W • σ) • 1 σ∈I(G) ,</formula><p>where Z is the normalizing factor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Mixing time</head><p>The Glauber dynamics as described above converges to its stationary distribution π starting from any initial condition. To establish our results, we will need quantitative bounds on the time it takes for the Glauber dynamics to reach "close" to its stationary distribution. To this end, we start with the definition of distances between probability distributions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. (Distance of measures) Given two probability distributions ν and µ on a finite space Ω, we define the following two distances. The total variation distance, denoted as</head><formula xml:id="formula_20">ν -µ T V is ν -µ T V = 1 2 i∈Ω |ν(i) -µ(i)| .</formula><p>The χ 2 distance, denoted as ν µ -1</p><formula xml:id="formula_21">2,µ is ν µ -1 2 2,µ = ν -µ 2 2, 1 µ = i∈Ω µ(i) ν(i) µ(i) -1 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>More generally, for any two vectors</head><formula xml:id="formula_22">u, v ∈ R |Ω| + , we define v 2 2,u = i∈Ω uiv 2 i .</formula><p>We make note of the following relation between the two distances defined above: using the Cauchy-Schwarz inequality, we have</p><formula xml:id="formula_23">ν µ -1 2,µ ≥ 2 ν -µ T V . (<label>3</label></formula><formula xml:id="formula_24">)</formula><p>Next, we define a matrix norm that will be useful in determining the rate of convergence or the mixing time of a finite-state Markov chain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Matrix norm). Consider a |Ω| × |Ω| non-negative valued matrix</head><formula xml:id="formula_25">A ∈ R |Ω|×|Ω| +</formula><p>and a given vector u ∈ R |Ω| + . Then, the matrix norm of A with respect to u is defined as follows:</p><formula xml:id="formula_26">A u = sup v:Eu[v]=0 Av 2,u v 2,u ,</formula><p>where Eu[v] = i uivi.</p><p>For a probability matrix P , we will mostly be interested in the matrix norm of P with respect to its stationary distribution π, i.e. P π . Therefore, in this paper if we use a matrix norm for a probability matrix without mentioning the reference measure, then it is with respect to the stationary distribution. That is, in the above example P will mean P π . With these definitions, it follows that for any distribution</p><formula xml:id="formula_27">µ on Ω µP π -1 2,π ≤ P * µ π -1 2,π , (<label>4</label></formula><formula xml:id="formula_28">) since E π µ π -1 = 0, where µ π = [µ(i)/π(i)].</formula><p>The Markov chain of our interest, Glauber dynamics, is reversible i.e. P P * . This suggests that in order to bound the distance between a Markov chain's distribution after some steps and its stationary distribution, it is sufficient to obtain a bound on P . One such bound can be obtained as below using Cheeger's inequality, and the details of its proof are omitted due to space constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5. Let P be the transition matrix of the Glauber dynamics GD(W ) on a graph</head><formula xml:id="formula_29">G = (V, E) of n = |V | nodes. Then, P ≤ 1 - 1 8n 2 exp(4nW max )</formula><p>,</p><p>where W max = max{1, W max } and W max = max i∈V W i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PROOF OF MAIN RESULT</head><p>This section presents the detailed proof of Theorem 1. We will present the sketch of the proof followed by details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Proof sketch</head><p>We first introduce the necessary definition of the network Markov process under our algorithm. As before, let τ ∈ N be the index for discrete time. Let Q(τ ) = [Qi(τ )] denote the vector of queue-sizes at time τ , Q(τ ) = [ Qmax,i(τ )] be the vector of estimates of Qmax(τ ) at time τ and σ(τ ) = [σi(τ )] be the scheduling choices at the n nodes at time τ . Then it can be checked that the tuple</p><formula xml:id="formula_30">X(τ ) = (Q(τ ), Q(τ ), σ(τ ))</formula><p>is the Markov state of the network operating under the algorithm. Note that X(τ ) ∈ X where</p><formula xml:id="formula_31">X = R n + × R n + × I(G).</formula><p>Clearly, X is a Polish space endowed with the natural product topology. Let B X be the Borel σ-algebra of X with respect to this product topology. Let P denote the probability transition matrix of this discrete-time X-valued Markov chain. We wish to establish that X(τ ) is indeed positive Harris recurrent under this setup. For any Next, we present the proof based on a sequence of lemmas. The proofs will be presented subsequently.</p><formula xml:id="formula_32">x = (Q, Q, σ) ∈ X,</formula><p>We will need some definitions to begin with. Given a probability distribution (also called sampling distribution) a on N, the a-sampled transition matrix of the Markov chain, denoted by Ka is defined as</p><formula xml:id="formula_33">K a (x, B) = τ ≥0 a(τ )P τ (x, B), for any x ∈ X, B ∈ B X .</formula><p>Now, we define a notion of a petite set. A non-empty set A ∈ B X is called µa-petite if µa is a non-trivial measure on (X, B X ) and a is a probability distribution on N such that for any x ∈ A,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ka(x, •) ≥ µa(•).</head><p>A set is called a petite set if it is µ a -petite for some such nontrivial measure µ a . A known sufficient condition to establish positive Harris recurrence of a Markov chain is to establish positive Harris recurrence of closed petite sets as stated in the following lemma. We refer an interested reader to the book by Meyn and Tweedie <ref type="bibr" target="#b23">[23]</ref> or the recent survey by Foss and Konstantopoulos <ref type="bibr">[8]</ref> for details. Lemma 6. Let B be a closed petite set. Suppose B is Harris recurrent, i.e. Prx(TB &lt; ∞) = 1 for any x ∈ X. Further, let</p><formula xml:id="formula_34">sup x∈B Ex [TB] &lt; ∞.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Then the Markov chain is positive Harris recurrent.</head><p>Lemma 6 suggests that to establish the positive Harris recurrence of the network Markov chain, it is sufficient to find a closed petite set that satisfies the conditions of Lemma 6. To this end, we first establish that there exist closed sets that satisfy condition of Lemma 6. Later we will establish that they are indeed petite sets. This will conclude the proof of positive Harris recurrence of the network Markov chain.</p><p>Recall that the 'weight' function is f (x) = log log(x + e). Define its integral, F (x) = x 0 f (y)dy. The system Lyapunov function, L : X → R+ is defined as</p><formula xml:id="formula_35">L(x) = n i=1 F (Q i ) = F (Q) • 1, where x = (Q, Q, σ) ∈ X.</formula><p>We will establish the following, whose proof is given in Section 5.3.</p><formula xml:id="formula_36">Lemma 7. Let λ ∈ (1 -2ε)Λ o . Then there exist functions h, g : X → R such that for any x ∈ X, E [L(X(g(x))) -L(X(0))|X(0) = x] ≤ -h(x),</formula><p>and satisfy the following conditions: (a)</p><formula xml:id="formula_37">inf x∈X h(x) &gt; -∞, (b) lim inf L(x)→∞ h(x) &gt; 0, (c) sup L(x)≤γ g(x) &lt; ∞ for all γ &gt; 0, and (d) lim sup L(x)→∞ g(x)/h(x) &lt; ∞.</formula><p>Now define B κ = {x : L(x) ≤ κ} for any κ &gt; 0. It will follow that B κ is a closed set. Therefore, Lemma 7 and Theorem 1 in survey <ref type="bibr">[8]</ref> imply that there exists constant κ0 &gt; 0 such that for all κ 0 &lt; κ, the following holds:</p><formula xml:id="formula_38">E x [T B κ ] &lt; ∞, for any x ∈ X (5) sup x∈B κ E x [T B κ ] &lt; ∞. (<label>6</label></formula><formula xml:id="formula_39">)</formula><p>Now we are ready to state the final nugget required in proving positive Harris recurrence as stated below.</p><p>Lemma 8. Consider any κ &gt; 0. Then, the set</p><formula xml:id="formula_40">B κ = {x : L(x) ≤ κ} is a closed petite set.</formula><p>The proof of Lemma 8 is technical and omitted due to space constraints. Lemmas 6, 7 and 8 imply that the network Markov chain is positive Harris recurrent. This completes the proof of Theorem 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Some preliminaries</head><p>Now we relate our algorithm described in Section 3.1 with an appropriate continuous time version of the Glauber dynamics described in Section 4.1. To this end, recall that the algorithm changes its scheduling decision when a node's Exponential clock of rate 1 ticks. Due to the property of the Exponential distribution, no two nodes have clocks ticking at the same time. Now given a clock tick, it is equally likely to be any of the n nodes. The node whose clock ticks, decides its transition based on probability prescribed by the Glauber dynamics GD(W (t)) where recall that W (t) are determined based on Q( t ), Q( t ). Thus the transition probabilities of the Markov process determining the schedule σ(t) change every discrete time. Let P (t) denote the transition matrix prescribed by the Glauber dynamics GD(W (t)) and π(t) denote its stationary distribution. Now the scheduling algorithm evolves the scheduling decision σ(•) over time with time varying P (t) as described before. Let µ(t) be the distribution of the schedule σ(t) at time t. The algorithm is essentially running P (t) on I(G) when a clock ticks at time t. Since there are n clocks with rate 1 and P (t) = P ( t ), we have</p><formula xml:id="formula_41">µ(t) = ∞ i=0 Pr(ζ = i)µ( t )P ( t ) i = µ( t )e n(t-t )(P ( t )-I) , (<label>7</label></formula><formula xml:id="formula_42">)</formula><p>where ζ be the number of clock ticks in time ( t , t] and it is distributed as a Poisson random variable with mean n(t -t ). Thus, for any τ ∈ N, µ(τ + 1) = µ(τ )e n(P (τ )-I) .</p><p>(</p><p>The equation <ref type="bibr">(8)</ref> gives the discrete-time interpretation on µ, hence the mixing-time based analysis on µ with the transition matrix e n(P (τ )-I) becomes possible. The transition matrix e n(P (τ )-I) has properties similar to that of P (τ ), as stated below. The details of its proof are omitted due to space constraints; they use Lemma 5 and properties of the matrix norm.</p><p>Lemma 9. e n(P (τ )-I) is reversible and its stationary distribution is π(τ ). Furthermore, its matrix norm is bounded as e n(P (τ )-I) ≤ 1 -1 16n exp(4nW max (τ )) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Proof of Lemma 7</head><p>We have λ</p><formula xml:id="formula_44">∈ (1 -2ε)Λ o . That is, for some δ &gt; 0, λ ≤ (1 -2ε -δ)Λ.</formula><p>The proof of Lemma 7 crucially utilizes the following Lemma 10, which we will prove in Section 5.4.</p><formula xml:id="formula_45">Lemma 10. For given δ, ε &gt; 0, let λ ≤ (1 -2ε -δ)Λ.</formula><p>Define a large enough constant B = B(n, ε) such that it satisfies the following:</p><formula xml:id="formula_46">B ≥ (16n -1) 16n-1 and 256n 2 (log (x + e)) 4n e (log(x-2n+e)) ε/n -e -1 &lt; ε, for all x ≥ B. 3 Now, given any starting condition x = (Q(0), Q(0), σ(0)), there exists a constant C = C(Q(0)) such that for T ∈ I ∩ N where I = [C, Qmax(0) -B], Ex[L(X(T )) -L(X(C))] ≤ - δ n T -1 τ =C E x [f (Q(τ )) • 1] + 6n(T -C), with C(Q(0)) = O log 16n+1 Q max (0) .</formula><p>Here, as usual, E x [•] denotes expectation with respect to the condition that X(0) = x.</p><p>Now proceed towards the proof of Lemma 7. We choose</p><formula xml:id="formula_47">g(x) = log Q max (0) + 2 C. Since g = O(C log Q max (0)) = O log 16n+2 Qmax(0) , there exists a constant D = D(n, ε, δ) such that g &lt; Q max (0) -B whenever Q max (0) ≥ D. Hence if Qmax(0) ≥ D, using Lemma 10, Ex[L(X(g(x))) -L(X(0))] ≤ - δ n g(x)-1 τ =C E x [f (Q(τ )) • 1] + 6n(g(x) -C) + E x [L(X(C)) -L(X(0))] ≤ - δ n g(x)-1 τ =C E x [f (Q max (τ ))] + 6n(g(x) -C) + Ex[L(X(C)) -L(X(0))] ≤ - δ n (g(x) -C)f (Q max (0) -g(x)) + + 6n(g(x) -C) + E x [F (Q(C)) • 1 -F (Q(0)) • 1] ≤ - δ n (g(x) -C)f (Qmax(0) -g(x)) + + 6n(g(x) -C) + C n f (Q max (0) + C) = k(x). (<label>9</label></formula><formula xml:id="formula_48">)</formula><p>3 There exists such a constant B since lim x→∞ 256n 2 (log(x+e)) 4n e (log(x-2n+e)) ε/n -e-1 = 0 for any fixed n, ε &gt; 0.</p><formula xml:id="formula_49">When Q max (0) ≤ D, E x [L(X(g(x))) -L(X(0))] is bounded by a constant E = E(n, ε, δ) since g(x)</formula><p>is bounded in terms of Qmax(0) and Qmax(g(x)) ≤ Qmax(0) + g(x). Therefore, we can define functions h as follows</p><formula xml:id="formula_50">h(x) = -k(x) if Q max (0) ≥ D -E otherwise ,</formula><p>which satisfies</p><formula xml:id="formula_51">E [L(X(g(x))) -L(X(0))|X(0) = x] ≤ -h(x).</formula><p>The desired conditions of Lemma 7 can be checked as: (c) is trivial and (a), (b) and (d) follow since h/g grows in order of f (Q max (0)) for a large Q max (0) due to our choice of g(x).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Proof of Lemma 10</head><p>Here we prove Lemma 10 using the following two lemmas.</p><p>Lemma 11. Consider a vector of queue-sizes Q ∈ R n + . Let the vector of estimation of Qmax be Q ∈ R n + satisfying the property of Lemma 2. Let weight vector W based on these queues be defined as per equation <ref type="bibr" target="#b1">(1)</ref>. Consider the Glauber dynamics GD(W ) and let π denote its stationary distribution. If σ is distributed as per π then</p><formula xml:id="formula_52">E π [f (Q) • σ] ≥ (1 -ε) max ρ∈I(G) f (Q) • ρ -3n.</formula><p>The proof of Lemma 11 is omitted due to space constraints.</p><p>Lemma 12 (Network adiabatic Theorem). For any given F = {Q(τ ), Q(τ )|τ = 0, 1, . . . t }, let μ(t) be the (conditional) distribution of the schedule over I(G) at time t, and let π(t) be the stationary distribution of the Markov process over I(G) given by the probability transition matrix P (t) as defined in Section 5.2. Then, for t The proof of Lemma 12 is presented in Section 5.5. Now we proceed towards proving Lemma 10. From Lemma 12 and relation <ref type="bibr" target="#b3">(3)</ref> we have that for t ∈ I,</p><formula xml:id="formula_53">∈ I = [C 1 (Q max (0)), Q max (0) -B], μ(t) π(t) -1<label>2</label></formula><formula xml:id="formula_54">E π(t) [f (Q(t)) • σ] -E μ(t) [f (Q(t)) • σ] ≤ ε max ρ∈I(G) f (Q(t)) • ρ .</formula><p>Thus from Lemma 11,</p><formula xml:id="formula_55">E μ(t) [f (Q(t)) • σ] ≥ (1 -2ε) max ρ∈I(G) f (Q(t)) • ρ -3n.</formula><p>Now we can bound the difference between L(X(τ + 1)) and L(X(τ )) as follows.</p><formula xml:id="formula_56">L(X(τ + 1)) -L(X(τ )) = (F (Q(τ + 1)) -F (Q(τ ))) • 1 ≤ f (Q(τ + 1)) • (Q(τ + 1) -Q(τ )), (as F is convex), (a) ≤ f (Q(τ )) • (Q(τ + 1) -Q(τ )) + n = f (Q(τ )) • A(τ, τ + 1) - τ +1 τ σ(y)1 {Q i (y)&gt;0} dy + n (b) ≤ f (Q(τ )) • A(τ, τ + 1) - τ +1 τ f (Q(y)) • σ(y)1 {Q i (y)&gt;0} dy + 2n = f (Q(τ )) • A(τ, τ + 1) - τ +1 τ f (Q(y)) • σ(y) dy + 2n,<label>(10)</label></formula><p>where (a) and (b) follow from the fact that f is 1-Lipschitz<ref type="foot" target="#foot_1">4</ref> and Q(•) changes at unit rate. For τ, τ + 1 ∈ I, if we take the expectation of ( <ref type="formula" target="#formula_56">10</ref>) over the distribution of σ given F , we have</p><formula xml:id="formula_57">E[L(X(τ + 1)) -L(X(τ )) | F ] ≤ E[f (Q(τ )) • A(τ, τ + 1) | F] - τ +1 τ E μ(t) [f (Q(y)) • σ(y)] dy + 2n ≤ f (Q(τ )) • λ - τ +1 τ (1 -2ε)E max ρ∈I(G) f (Q(y)) • ρ dy + 5n ≤ f (Q(τ )) • λ -(1 -2ε) max ρ∈I(G) f (Q(τ )) • ρ + 6n ≤ -δ max ρ∈I(G) f (Q(τ )) • ρ + 6n,</formula><p>where the last inequality follows from λ ∈ (1 -2ε -δ)Λ. If we take the expectation again over the distribution of F given the initial state X(0) = x, we obtain</p><formula xml:id="formula_58">E x [L(X(τ + 1)) -L(X(τ ))] ≤ -δE x max ρ∈I(G) f (Q(τ )) • ρ dy + 6n (a) ≤ - δ n E x [f (Q(τ )) • 1] dy + 6n.</formula><p>In above, for (a), we use the fact that 1 can be written as a convex combination of n singleton independent sets. Therefore, by summing over τ from C1 = C1(Qmax(0)) to T -1, we have</p><formula xml:id="formula_59">E x [L(X(T )) -L(X(C 1 ))] ≤ - δ n T -1 τ =C 1 Ex[f (Q(τ )) • 1] + 6n(T -C 1 ).</formula><p>From Lemma 12, by the choice of</p><formula xml:id="formula_60">C(Q(0)) = C 1 (Q max (0)) = O log 16n+1 Q max (0)</formula><p>, we obtain the desired result and complete the proof of Lemma 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Proof of Network adiabatic theorem</head><p>This section establishes the proof of Lemma 12. In words, Lemma 12 states that, if queue-sizes are large, the observed distribution of schedules is essentially the same as the desired stationary distribution for large enough time despite the fact that the weights (or queue-sizes) keep changing. In a nutshell, by selecting the weight function f (•) = log log(•+e), the dynamics of weights become "slow enough", thus allowing for the distribution of scheduling decisions to remain close to the desired stationary distribution. This is analogous to the classical adiabatic theorem which states that if the system is changed gradually (slowly) in a reversible manner and if the system starts in the ground states then it remains in the ground state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.1">Two useful results</head><p>We state two lemmas that will be useful for establishing Lemma 12. Before we state these lemmas, we define a transformation of the queue-size vector: define Q i = f -1 (W i ) and let Q be its corresponding vector.</p><p>Lemma 13. Given τ ∈ N, define</p><formula xml:id="formula_61">α τ = f ( Q(τ )) + f ( Q(τ + 1)) • 1.</formula><p>Then if α τ &lt; 1, the followings hold:</p><formula xml:id="formula_62">1. For any ρ ∈ I(G), exp (-α τ ) ≤ π(τ +1)(ρ) π(τ )(ρ) ≤ exp (α τ ) . 2. And, π(τ + 1) -π(τ ) 2, 1 π(τ +1) ≤ 2α τ .</formula><p>The proof of Lemma 13 is quite standard and omitted due to space constraints. Next, we state a lemma which implies that the change in π(•) is "small" compared to the "mixing time" of the Glauber dynamics when the queue-size is large. It will play a crucial role in establishing Lemma 12, and the appropriate choice of large enough B in Lemma 10 is necessary for its proof.</p><formula xml:id="formula_63">Lemma 14. If Qmax(τ + 1) ≥ B, Tτ+1ατ ≤ ε 8 , (<label>11</label></formula><formula xml:id="formula_64">)</formula><p>where T τ stands for the mixing time of the transition matrix e n(P (τ )-I) and is defined as Tτ =</p><p>1-e n(P (τ )-I) . Note that</p><formula xml:id="formula_66">α τ &lt; T τ +1 α τ ≤ ε 8 &lt; ε 4+ε &lt; 1. Proof. First note that Q min = f -1 (W min ) ≥ f -1 ε n f ( Q max,i ) ≥ f -1 ε n f (Qmax -2n) + = f -1 ε n f ( Q max -2n) + ,</formula><p>from Qmax = Qmax and Lemma 2. From Lemma 9, we have that</p><formula xml:id="formula_67">T τ +1 ≤ 16n log Q max (τ + 1) + e 4n . Additionally by using f (x) = 1 (x+e) log(x+e) &lt; 1</formula><p>x , the following bound can be obtained:</p><formula xml:id="formula_68">T τ +1 ατ ≤ 16n log 4n Q max (τ + 1) + e f ( Q(τ )) + f ( Q(τ + 1)) • 1 ≤ 16nlog 4n Q max (τ + 1) + e n Q min (τ ) + n Q min (τ + 1) ≤ 32n 2 log 4n Qmax(τ + 1) + e Q min (τ + 1) -1 (as Q is 1-Lipschitz) ≤ 32n 2 log 4n Q max (τ + 1) + e f -1 ε n f Qmax(τ + 1) -2n -1 (from (12)) ≤ 32n 2 log 4n (x + e) e (log(x-2n+e)) ε n -e -1 ,<label>(12)</label></formula><p>where x := Q max (τ + 1) ≥ B. By our choice of B in Lemma 10, the right hand side of ( <ref type="formula" target="#formula_68">12</ref>) is bounded above by ε/8. This completes the proof of Lemma 14.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.2">Proof of Lemma 12</head><p>For simplifying notations, let µ(t) = μ(t) in this section. First note that we can assume 0 &lt; C 1 (Q max (0)) ≤ Q max (0) -B. Otherwise the conclusion is trivial since I is empty. We wish to establish that for t ∈ I,</p><formula xml:id="formula_69">µ(t) π(t) -1 2,π(t) &lt; ε.</formula><p>It is enough to show the statement for τ = t ∈ I since</p><formula xml:id="formula_70">µ(t) π(t) -1 2,π(t) = µ(t) π( t ) -1 2,π( t ) (as π(t) = π( t )) ≤ e n(t-t )(P ( t )-I) µ( t ) π( t ) -1 2,π( t ) (from (7)) ≤ µ( t ) π( t ) -1 2,π( t ) &lt; ε.</formula><p>Now we first show that for any τ ∈ N with τ + 1 ∈ I,</p><formula xml:id="formula_71">µ(τ + 1) π(τ ) -1 2,π(τ ) &lt; ε/2. (<label>13</label></formula><formula xml:id="formula_72">)</formula><p>Suppose ( <ref type="formula" target="#formula_71">13</ref>) is correct. Then, for τ ∈ I, using (13), Lemmas 13 and 14, one can obtain the desired bound:</p><formula xml:id="formula_73">µ(τ ) π(τ ) -1 2,π(τ ) = µ(τ ) -π(τ ) 2, 1 π(τ ) ≤ (e α τ -1 /2 ) µ(τ ) -π(τ ) 2, 1 π(τ -1) (a) ≤ (1 + α τ -1 ) µ(τ ) -π(τ ) 2, 1 π(τ -1) ≤ (1 + α τ -1 ) µ(τ ) -π(τ -1) 2, 1 π(τ -1) + π(τ -1) -π(τ ) 2, 1 π(τ -1) ≤ (1 + α τ -1 ) ε 2 + 2α τ -1 (b) ≤ 1 + ε 8 ε 2 + ε 4 &lt; ε, (<label>14</label></formula><formula xml:id="formula_74">)</formula><p>where (a) and (b) are due to α τ -1 ≤ ε/8 &lt; 1 from Q max (τ ) ≥ Q max (0) -τ ≥ B and Lemma 14. Therefore, it suffices to establish <ref type="bibr" target="#b13">(13)</ref> for completing the proof of Lemma 12. For simplicity of notation, define</p><formula xml:id="formula_75">aτ = µ(τ + 1) π(τ ) -1 2,π<label>(τ )</label></formula><p>.</p><p>Consider the following recursive relation for a τ :</p><formula xml:id="formula_76">a τ +1 = µ(τ + 2) π(τ + 1) -1 2,π(τ +1) ≤ e n(P (τ +1)-I) µ(τ + 1) π(τ + 1) -1 2,π(τ +1) (from (8)) = 1 - 1 T τ +1 µ(τ + 1) -π(τ + 1) 2, 1 π(τ +1) ≤ 1 - 1 T τ +1 µ(τ + 1) -π(τ ) 2, 1 π(τ +1) + π(τ ) -π(τ + 1) 2, 1 π(τ +1) ≤ 1 - 1 T τ +1 e ατ /2 µ(τ + 1) -π(τ ) 2, 1 π(τ ) + 2ατ ≤ 1 - 1 T τ +1 ((1 + α τ ) a τ + 2α τ ) , (<label>15</label></formula><formula xml:id="formula_77">)</formula><p>where each inequality can be derived similarly as we derived <ref type="bibr" target="#b14">(14)</ref>. From ( <ref type="formula" target="#formula_76">15</ref>), if we have aτ &lt; ε/2 and τ + 1 ∈ I, then</p><formula xml:id="formula_78">a τ +1 &lt; 1 - 1 T τ +1 (ε/2 + (2 + ε/2)α τ ) ≤ 1 - 1 T τ +1 ε/2 + ε 2T τ +1 (from Lemma 14) &lt; ε/2. (<label>16</label></formula><formula xml:id="formula_79">)</formula><p>Hence, for establishing <ref type="bibr" target="#b13">(13)</ref> it is enough to show that there exists a C such that a C &lt; ε/2 and C ≤ C 1 (Q max (0)) -1.</p><p>To this end, fix τ &lt; Qmax(0) -B and assume as ≥ ε/2 for all integers s &lt; τ . Then, from <ref type="bibr" target="#b15">(15)</ref>, Finally, a0 is also bounded above as: i a 0 &lt; ε/2. Otherwise, there exists C &lt; C such that a C &lt; ε/2, which also implies aC &lt; ε/2 from ( <ref type="formula" target="#formula_78">16</ref>). In either case, aC &lt; ε/2 and it completes the proof of ( <ref type="formula" target="#formula_71">13</ref>) and hence the proof of Lemma 12.</p><formula xml:id="formula_80">aτ ≤ 1 - 1 Tτ ((1 + α τ -1 ) a τ -1 + 2α τ -1 ) ≤ 1 - 1 T τ (1 + α τ -1 ) a τ -1 + 4α τ -1 a τ -1 ε = 1 - 1 T τ 1 + 1 + 4 ε α τ -1 a τ -1 ≤ 1 - 1 Tτ 1 + 1 Tτ a τ -1 (from Lemma 14) &lt; e -1 T 2 τ a τ -1 &lt; e -τ s=1 1 T 2 s a 0 . (<label>17</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SIMULATION RESULTS</head><p>Setup. We consider a N × N two-dimensional grid graph topology to understand the performance of our algorithm. The selection of such a topology is for two reasons: One, due to the bipartite nature of the grid graph, we have a precise characterization of the capacity region, denoted by Λ(1), given by Λ(ρ) = {λ : λ u + λ v ≤ ρ for all edges (u, v)} where ρ ∈ [0, 1] is the load and λ v is the arrival rate at node v. Two, it is a reasonable approximation of the wireless network arising in the mesh network scenario. We assume arrival process to be Bernoulli. For a given load ρ ∈ [0, 1], we consider two traffic patterns: (1) Uniform traffic, where λ u = ρ/2 for all u; and (2) chessboard traffic, where for u = (i, j), λ u = 2ρ/3 if i + j is even, and ρ/3 otherwise.</p><p>Results/observations. Our algorithm is, in essence, a learning mechanism that tries to find good schedules. For that reason, the uniform traffic pattern is good as there are many options for good independent sets and hence it is easier for an algorithm to learn them. On the other hand, the chessboard pattern is much harder as it requires the algorithm to essentially select one of the few good schedules almost all the time. Indeed, our simulation results verify this intuition. For uniform traffic, the algorithm does very well. Due to space constraints, we therefore present results for the chessboard traffic only.</p><p>Here we report results for N = 10 (total N 2 = 100 nodes) and different loading ρ = 0.5, 0.6, 0.7, 0.8 for algorithm that uses weight f (x) = log log(x + e) along with adjustment using Qmax,i(•).The time-evolution of the total queue-size over the whole network is presented in Figure <ref type="figure" target="#fig_2">1</ref>. As the reader will notice, the algorithm keeps queue-sizes stable as expected for all loads. We observe that the algorithm without using information of estimation of Qmax(•) has essentially identical performance (see performance of log log weight in Figure <ref type="figure" target="#fig_4">2</ref>)! And thus it supports our conjecture.  As expected, we find that for f (x) = x, system is clearly unstable (we do not report here due to space constraints). A comparison of log and log log (without any Q max,i (•) based modification) weight functions is presented in Figure <ref type="figure" target="#fig_4">2</ref>. It clearly shows that the algorithm is stable for both of these weight functions; it is more stable (milder oscillations) for log log compared to log weight but at the cost of higher queue-sizes. This plot clearly explains the effect of the selection of weight function: for stability, slowly changing weight function is necessary (i.e. log x or log log x but not x); and among such functions slower function (i.e. log log compared to log) leads to more stable network but at the cost of increased queue-sizes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>In this paper, we resolved the long-standing and important question of designing an efficient random-access algorithm for contention resolution in a network of queues. Our algorithm is essentially a random-access based implementation, inspired by Metropolis-Hastings sampling method, of the classical maximum weight algorithm with "weight" being an appropriate function (f (x) = log log(x + e)) of the queuesize. The key ingredient in establishing the efficiency of the algorithm is a novel adiabatic-like theorem for the underlying queueing network. We strongly believe that this network adiabatic theorem in particular and methods of this paper in general will be of interest in understanding the effect of dynamics in networked system.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>)</head><label></label><figDesc>max (0) + s + e) 8n &gt; τ 16 2 n 2 (log (Q max (0) + τ + e)) 8n (a) ≥ √ τ 16 2 n 2 (log (Q max (0) + 1 + e)) 8n , where (a) follows from the fact that τ ≥ 1, Q max (0) ≥ B ≥ (16n -1) 16n-1 and √ x ≥ log(x + y) log(1 + y) 8n , ∀x ≥ 1, y ≥ (16n -1) 16n-1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>≤ 2 n 2 i</head><label>22</label><figDesc>e nf (Qmax(0)) ≤ (2 log(Qmax(0) + e)) n/2 . Now if we choose C as a 0 &lt; ε/2. So from (17), if a s ≥ ε/2 for all s &lt; C, a C &lt; e -C i=1 1 T 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The evolution of queue-size with time, for different arrival rates</figDesc><graphic coords="11,340.69,465.60,191.27,143.47" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Finally, we</head><label></label><figDesc>try to understand the effect of the weight function f : we simulate for f (x) = x, log(x+1) and log log(x+e).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A comparison of log and log log policies</figDesc><graphic coords="12,77.68,159.43,191.27,143.47" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>we define norm of x denoted by |x| as |x| = |Q| + | Q| + |σ|, where |Q| and | Q| denote the standard 1 norm while |σ| is defined as its index in {0, . . . , |I(G)| -1}, which is assigned arbitrarily. Thus, |σ| is always bounded. Further, by Lemma 2, we have | Q| ≤ |Q| under the evolution of Markov chain. Therefore, in essence |x| → ∞ if and only if |Q| → ∞.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In this paper, the notion of stability is defined as positive recurrence or positive Harris recurrence of the network Markov process.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>A continuous function f : R → R is K-Lipschitz if |f (x)f (y)| ≤ K|x -y| for all x, y ∈ R.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in parts by NSF projects HSD 0729361, CNS 0546590, TF 0728554 and DARPA ITMANET project.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Abramson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kuo</surname></persName>
		</author>
		<title level="m">The aloha system. Computer-Communication Networks</title>
		<imprint>
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Ultimate instability of exponential back-off protocol for acknowledgement-based transmission control of random access communication channels</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Aldous</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="219" to="223" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Performance of random medium access -an asymptotic approach</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bordenave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Proutiere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Sigmetrics</title>
		<meeting>ACM Sigmetrics</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Beweis des adiabatensatzes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Born</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Fock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zeitschrift für Physik a Hadrons and Nuclei</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="165" to="180" />
			<date type="published" when="1928">1928</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Stability of fluid and stochastic processing networks</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Dai</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Miscellanea Publication</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Information theory and communication networks: an unconsummated union</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ephremides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hajek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="2416" to="2432" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Distributed cross-layer algorithms for the optimal control of multi-hop wireless networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Eryilmaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ozdaglar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Modiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>submitted to</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An overview of some stochastic stability methods</title>
		<author>
			<persName><forename type="first">S</forename><surname>Foss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takis</forename><surname>Konstantopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Operations Research, Society of Japan</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Transience and recurrence of markov processes</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Getoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Séminaire de Probabilités XIV</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Az Őma</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yor</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="397" to="409" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A bound on the capacity of backoff and acknowledgement-based protocols</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jerrum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Report</title>
		<imprint>
			<biblScope unit="volume">365</biblScope>
			<date type="published" when="2000-01">January 2000</date>
			<pubPlace>Coventry CV4 7AL, UK</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Warwick</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Design and analysis of contention-resolution protocols</title>
		<author>
			<persName><forename type="first">Ann</forename><surname>Leslie</surname></persName>
		</author>
		<author>
			<persName><surname>Goldberg</surname></persName>
		</author>
		<ptr target="http://www.csc.liv.ac.uk/leslie/contention.html" />
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
			<biblScope unit="page">60982</biblScope>
		</imprint>
	</monogr>
	<note>Last updated</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Estimating the multiplicities of conflicts to speed their resolution in multiple access channels</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Flajolet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="289" to="325" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Introduction to Quantum Mechanics</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Griffiths</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Pearson Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Optimal throughput allocation in general random-access networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Stolyar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 40th Annual Conf</title>
		<meeting>40th Annual Conf<address><addrLine>Princeton, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1254" to="1259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Analysis of backoff protocols for multiple access channels</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Hastad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Rogoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A distributed csma algorithm for throughput and utility maximization in wireless networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Walrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 46th Allerton Conference on Communication, Control, and Computing</title>
		<meeting>46th Allerton Conference on Communication, Control, and Computing<address><addrLine>Urbana-Champaign, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Distributed queue length based algorithms for optimal end-to-end throughput allocation and stability in multi-hop random access networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Stolyar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 45th Allerton Conference on Communication, Control, and Computing</title>
		<meeting>45th Allerton Conference on Communication, Control, and Computing<address><addrLine>Urbana-Champaign, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Stochastic models of computer communication systems</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Kelly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. R. Statist. Soc B</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="379" to="395" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The number of packets transmitted by collision detect random access schemes</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Macphee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Probability</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1557" to="1568" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">On optimal strategies in stochastic decision processes</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Macphee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
	<note>d. phil. thesis, university of cambridge</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Distributed scheduling and active queue management in wireless networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Marbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<publisher>Minisymposium</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Achievable rate region of csma schedulers in wireless networks with primary interference constraints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Marbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Eryilmaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ozdaglar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Conference on Decision and Control</title>
		<meeting>IEEE Conference on Decision and Control</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Meyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Tweedie</surname></persName>
		</author>
		<title level="m">Markov Chains and Stochastic Stability</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Maximizing throughput in wireless network via gossiping</title>
		<author>
			<persName><forename type="first">E</forename><surname>Modiano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zussman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMETRICS/Performance</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Microsoft research lab. self organizing neighborhood wireless mesh networks</title>
		<ptr target="http://research.microsoft.com/mesh/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Distributed link scheduling with constant overhead</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sanghavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Sigmetrics</title>
		<meeting>ACM Sigmetrics</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Optimal scheduling algorithm for input queued switch</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Wischik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of IEEE INFOCOM</title>
		<meeting>eeding of IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Heavy traffic analysis of optimal scheduling algorithms for switched networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Wischik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>Submitted</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">S</forename><surname>Shakkottai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Network Optimization and Control. Foundations and Trends in Networking</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>NoW Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dynamic distributed scheduling in random access networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Stolyar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Probabability</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="297" to="313" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Tassiulas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ephremides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<date type="published" when="1936">1936-1948, 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Upper bound on the capacity of a random multiple-access system</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Tsybakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">B</forename><surname>Likhanov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Problemy Peredachi Informatsii</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="64" to="78" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
