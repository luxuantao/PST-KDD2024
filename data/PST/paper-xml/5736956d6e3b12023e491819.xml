<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Stream Ciphers for Efficient FHE with Low-Noise Ciphertexts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Pierrick</forename><surname>Méaux</surname></persName>
							<email>pierrick.meaux@ens.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">ENS and PSL Research University</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Anthony</forename><surname>Journault</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">ICTEAM/ELEN/Crypto Group</orgName>
								<orgName type="institution">Université catholique de Louvain</orgName>
								<address>
									<settlement>Louvain-la-Neuve</settlement>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">François-Xavier</forename><surname>Standaert</surname></persName>
							<email>fstandae@uclouvain.be</email>
							<affiliation key="aff1">
								<orgName type="department">ICTEAM/ELEN/Crypto Group</orgName>
								<orgName type="institution">Université catholique de Louvain</orgName>
								<address>
									<settlement>Louvain-la-Neuve</settlement>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Claude</forename><surname>Carlet</surname></persName>
							<email>claude.carlet@gmail.com</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Mathematics</orgName>
								<orgName type="laboratory">LAGA</orgName>
								<orgName type="institution" key="instit1">University of Paris VIII</orgName>
								<orgName type="institution" key="instit2">University of Paris XIII</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Stream Ciphers for Efficient FHE with Low-Noise Ciphertexts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1E541E1B33FC7B5F0EA98964B38B8735</idno>
					<idno type="DOI">10.1007/978-3-662-49890-3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Symmetric ciphers purposed for Fully Homomorphic Encryption (FHE) have recently been proposed for two main reasons. First, minimizing the implementation (time and memory) overheads that are inherent to current FHE schemes. Second, improving the homomorphic capacity, i.e. the amount of operations that one can perform on homomorphic ciphertexts before bootstrapping, which amounts to limit their level of noise. Existing solutions for this purpose suggest a gap between block ciphers and stream ciphers. The first ones typically allow a constant but small homomorphic capacity, due to the iteration of rounds eventually leading to complex Boolean functions (hence large noise). The second ones typically allow a larger homomorphic capacity for the first ciphertext blocks, that decreases with the number of ciphertext blocks (due to the increasing Boolean complexity of the stream ciphers' output). In this paper, we aim to combine the best of these two worlds, and propose a new stream cipher construction that allows constant and small(er) noise. Its main idea is to apply a Boolean (filter) function to a public bit permutation of a constant key register, so that the Boolean complexity of the stream cipher outputs is constant. We also propose an instantiation of the filter function designed to exploit recent (3rd-generation) FHE schemes, where the error growth is quasi-additive when adequately multiplying ciphertexts with the same amount of noise. In order to stimulate further investigation, we then specify a few instances of this stream cipher, for which we provide a preliminary security analysis. We finally highlight the good properties of our stream cipher regarding the other goal of minimizing the time and memory complexity of calculus delegation (for 2nd-generation FHE schemes). We conclude the paper with open problems related to the large design space opened by these new constructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Purpose: Calculus Delegation. Recent years have witnessed massive changes in communication technologies, that can be summarized as a combination of</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>two trends: <ref type="bibr" target="#b0">(1)</ref> the proliferation of small embedded devices with limited storage and computing facilities, and (2) the apparition of cloud services with extensive storage and computing facilities. In this context, the outsourcing of data and the delegation of data processing gains more and more interest. Yet, such new opportunities also raise new security and privacy concerns. Namely, users typically want to prevent the server from learning about their data and processing. For this purpose, Gentry's breakthrough Fully Homomorphic Encryption (FHE) scheme <ref type="bibr" target="#b30">[30]</ref> brought a perfect conceptual answer. Namely, it allows applying processing on ciphertexts in a homomorphic way so that after decryption, plaintexts have undergone the same operations as ciphertexts, but the server has not learned anything about these plaintexts. <ref type="foot" target="#foot_0">1</ref>Application Scenario. Cloud services can be exploited in a plethora of applications, some of them surveyed in <ref type="bibr" target="#b52">[51]</ref>. In general, they are always characterized by the aforementioned asymmetry between the communication parties. For illustration, we start by providing a simple example where data outsourcing and data processing delegation require security and privacy. Let us say that a patient, Alice, has undergone a surgery and is coming back home. The hospital gave her a monitoring watch (with limited storage) to measure her metabolic data on a regular basis. And this metabolic data should be made available to the doctor Bob, to follow the evolution of the post-surgery treatment. Quite naturally, Bob has numerous patients and no advanced computing facilities to store and process the data of all his patients. So this is a typical case where sending the data to a cloud service would be very convenient. That is, Alice's data could be sent to and stored on the cloud, and associated to both her and the doctor Bob. And the cloud would provide Bob with processed information in a number of situations such as when the metabolic data of Alice is abnormal (in which case an error message should be sent to Bob), or during an appointment between Alice and Bob, so that Bob can follow the evolution of Alice's data (possibly after some processing). Bob could in fact even be interested by accessing some other patient's data, in order to compare the effect of different medications. And of course, we would like to avoid the cloud to know anything about the (private) data it is manipulating. Typical Framework. More technically, the previous exemplary application can be integrated in a quite general cloud service application framework, that can be seen as a combination of 5 steps, combining a symmetric encryption scheme and an asymmetric homomorphic encryption scheme, as summarised in Fig. <ref type="figure" target="#fig_0">1</ref> and described next:</p><p>1. Initialization. Alice runs the key generation algorithms H.KeyGen and S.KeyGen of the two schemes, and sends her homomorphic public key pk H and the homomorphic ciphertext of her symmetric key C H (sk S i ).</p><p>2. Storage. Alice encrypts her data m i with the symmetric encryption scheme, and sends C S (m i ) to Claude. 3. Evaluation. Claude homomorphically evaluates, with the H.Eval algorithm, the decryption C H (m i ) of the symmetric scheme on Alice's data C S (m i ). 4. Computation. Claude homomorphically executes the treatment f on Alice's encrypted data. 5. Result. Claude sends a compressed encrypted result of the data treatment c H (f (m i )), obtained with the H.Comp algorithm, and Alice decrypts it.</p><p>Note that if we assume the existence of a trusted third party active only during the initialization step, Alice can avoid Step 1, which needs a significant computational and memory storage effort. Note also that this framework is versatile: computation can be done in parallel (in a batch setting) or can be turned into a secret key FHE. FHE Bottlenecks. The main limitation for the deployment of cloud services based on such FHE frameworks relates to its important overheads, that can be related to two main concerns: computational and memory costs (especially on the client side) and limited homomorphic capacity (i.e. noise increase). More precisely:</p><p>-The computational and memory costs for the client depend overwhelmingly on the homomorphic encryption and decryption algorithms during the steps 1 and 5. The memory cost is mostly influenced by the homomorphic ciphertexts and public key sizes. Solving these two problems consists in building sizeefficient FHE schemes with low computational cost <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b38">38]</ref>. On the server side, this computational cost further depends on the symmetric encryption scheme and function to evaluate. -The homomorphic capacity relates to the fact that FHE constructions are built on noise-based cryptography, where the unbounded amount of homomorphic operations is guaranteed by an expensive bootstrapping technique.</p><p>The homomorphic capacity corresponds to the amount of operations doable before the noise grows too much forcing to use bootstrapping. Therefore, and in order to reduce the time and computational cost of the framework, it is important to manage the error growth during the homomorphic operations (i.e. steps 3 and 4). Furthermore, since the 4th step is the most important one from the application point-of-view (since this is where the useful operations are performed by the cloud), there is strong incentive to minimize the cost of the homomorphic decryption in the 3rd step.</p><p>Previous Works. In order to mitigate these bottlenecks, several works tried to reduce more and more the homomorphic cost of evaluating a symmetric decryption algorithm. First attempts in this direction, which were also used as benchmark for FHE implementations, used the AES for this purpose <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b31">31]</ref>. Various alternative schemes were also considered, all with error and sizes depending on the multiplicative depth of the symmetric encryption scheme, such as BGV <ref type="bibr" target="#b8">[9]</ref> and FV <ref type="bibr" target="#b25">[26]</ref>. Additional optimizations exploited batching and bitslicing, leading to the best results of performing 120 AES decryptions in 4 minutes <ref type="bibr" target="#b31">[31]</ref>.</p><p>Since the multiplicative depth of the AES decryption evaluation was a restrictive bound in these works, other symmetric encryption schemes were then considered. The most representative attempts in this direction are the family of block ciphers LowMC <ref type="bibr" target="#b0">[1]</ref> and the stream cipher Kreyvium <ref type="bibr" target="#b10">[11]</ref>. These constructions led to reduced and more suitable multiplicative depths. Yet, and intuitively, these attempts were still limited by complementary drawbacks. First for LowMC, the remaining multiplicative depth remains large enough to significantly reduce the homomorphic capacity (i.e. increase the noise). Such a drawback seems to be inherent in block cipher structures where the iteration of rounds eventually leads to Boolean functions with large algebraic degree, which inevitably imply a constant per block but high noise after homomorphic evaluation. For example, ciphers dedicated to efficient masking against side-channel attacks <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b53">52]</ref>, which share the goal of minimizing the multiplicative complexity, suffer from similar issues and it seems hard to break the barrier of one multiplication per round (and therefore of 12 to 16 multiplications for 128-bit ciphers). Second for Kreyvium, the error actually grows with the number of evaluated ciphertexts, which implies that at some point, the output ciphertexts are too noisy, and cannot be decrypted (which requires either to bootstrap or to re-initialize the stream cipher).</p><p>Our Contribution. In view of this state-of-the-art, a natural direction would be to try combining the best of these two previous works. That is, to design a cipher inheriting from the constant noise property offered by block ciphers, and the lower noise levels of stream ciphers (due to the lower algebraic degree of their outputs), leading to the following contributions.</p><p>First, we introduce a new stream cipher construction, next denoted as a filter permutator (by analogy with filter generators). Its main design principle is to filter a constant key register with a variable (public) bit permutation. More precisely, at each cycle, the key register is (bit) permuted with a pseudorandomly generated permutation, and we apply a non-linear filtering function to the output of this permuted key register. The main advantage of this construction is to always apply the non-linear filtering directly on the key bits, which allows maintaining the noise level of our outputs constant. Conceptually, this type of construction seems appealing for any FHE scheme.</p><p>Second, and going deeper in the specification of a concrete scheme, we discuss the optimization of the components in a filter permutator, with a focus on the filtering function (which determines the output noise after homomorphic evaluation). For this purpose, we first notice that existing FHE schemes can be split in (roughly) two main categories. On one hand the so-called 2nd-generation FHE (such as <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b14">15]</ref>) where the metric for the noise growth is essentially the multiplicative depth of the circuit to homomorphically evaluate. On the other hand, the so-called 3rd-generation FHE (such as <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b32">32]</ref>) where the error growth is asymmetric, and in particular quasi-additive when considering a multiplicative chain. From these observations, we formalize a comb structure which can be represented as a (possibly long) multiplicative chain, in order to take the best advantage of 3rd-generation FHE schemes. We then design a filtering function based on this comb structure (combined with other technical ingredients in order to prevent various classes of possible attacks against stream ciphers) and specify a family of filter permutators (called FLIP).</p><p>Third, and in order to stimulate further investigations, we instantiate a few version of FLIP designs, for 80-bit and 128-bit security. We then provide a preliminary evaluation of their security against some of the prevailing cryptanalysis from the open literature -such as (fast) algebraic attacks, (fast) correlation attacks, BKW-like attacks <ref type="bibr" target="#b5">[6]</ref>, guess and determine attacks, etc. -based on state-of-the-art tools. We also analyze the noise brought by their filtering functions in the context of 3rd-generation FHE. In this respect, our main result is that we can limit the noise after the homomorphic evaluation of a decryption to a level of the same order of magnitude as for a single homomorphic multiplication -hence essentially making the impact of the symmetric encryption scheme as small as possible.</p><p>We finally observe that our FLIP designs have a very reduced multiplicative depth, which makes them suitable for 2nd-generation FHE schemes as well, and provide preliminary results of prototype implementations using HElib that confirm their good behavior compared to state-of-the-art block and stream ciphers designed for efficient FHE.</p><p>Overall, filter permutators in general and FLIP instances in particular open a large design space of new symmetric constructions to investigate. Hence, we conclude the paper with a list of open problems regarding these algorithms, their best cryptanalysis, the Boolean functions used in their filter and their efficient implementation in concrete applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Boolean Functions</head><p>In this section, we recall the cryptographic properties of Boolean functions that we will need in the rest of the paper (mostly taken from <ref type="bibr" target="#b11">[12]</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Boolean Function</head><formula xml:id="formula_0">W f (a) = x∈F n 2 (-1) f (x)+ a,x ,</formula><p>where a, x denotes the inner product in F n 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Balancedness).</head><p>A Boolean function f ∈ B n is said to be balanced if its outputs are uniformly distributed over {0, 1}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Non-linearity).</head><p>The non-linearity NL of a Boolean function f ∈ B n , where n is a positive integer, is the minimum Hamming distance between f and all the affine functions g:</p><formula xml:id="formula_1">NL(f ) = min g {d H (f, g)}, with d H (f, g) = #{x ∈ F n 2 | f (x) = g(x)</formula><p>} the Hamming distance between f and g. The non-linearity of a Boolean function can also be defined by its Walsh Transform:</p><formula xml:id="formula_2">NL(f ) = 2 n-1 - 1 2 max a∈F n 2 |W f (a)|.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Resiliency).</head><p>A Boolean function f ∈ B n is said m-resilient if any of its restrictions obtained by fixing at most m of its coordinates is balanced. We will denote by res(f ) the resiliency m of f and set res(f ) = -1 if f is unbalanced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (Algebraic Immunity).</head><p>The algebraic immunity of a Boolean function f ∈ B n , denoted as AI(f ), is defined as:</p><formula xml:id="formula_3">AI(f ) = min g =0 {deg(g) | fg = 0 or (f ⊕ 1)g = 0},</formula><p>where deg(g) is the degree of g. The function g is called an annihilator of f (or (f ⊕ 1)).</p><p>Definition 7 (Fast Algebraic Immunity). The fast algebraic immunity of a Boolean function f ∈ B n , denoted as FAI(f ), is defined as:</p><formula xml:id="formula_4">FAI(f ) = min{2AI(f ), min 1≤deg(g)&lt;AI(f ) (max[deg(g) + deg(fg), 3deg(g)])}.</formula><p>Summarizing, the good balancedness, non-linearity and resiliency properties have to be ensured to widthstand correlation attacks <ref type="bibr" target="#b57">[56]</ref> and fast correlation attacks <ref type="bibr" target="#b49">[48]</ref>. The high algebraic immunity and fast algebraic immunity have to be ensured to widthstand algebraic attacks <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">(Ring) Learning with Errors</head><p>In this section, we recall useful notations and definitions needed about the decisional LWE problem and its ring variation. For an integer modulus q, we denote by Z q the quotient ring of integers modulo q. We denote vectors with bold letters e and matrices with bold capital letters A. The notation s ← $ S (resp. s ← $ χ) denotes that s is picked uniformly at random from a finite set S (resp. from a distribution χ).</p><p>The decisional Learning With Error problem (dLWE) was introduced by Regev <ref type="bibr" target="#b54">[53]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (dLWE).</head><p>For an integer q = q(n) ≥ 2, an adversary A and an error distribution χ = χ(n) over Z q , we define the following advantage function:</p><formula xml:id="formula_5">Adv dLWEn,m,q,χ A := | Pr[A(A, z 0 ) = 1] -Pr[A(A, z 1 ) = 1]|, where A ← $ Z n×m q , s ← $ Z n q , e ← $ χ m , z 0 := s A + e and z 1 ← $ Z m q .</formula><p>The dLWE n,m,q,χ assumption asserts that for all PPT adversaries A, the advantage Adv dLWEn,m,q,χ A is a negligible function in n.</p><p>The ring variant was introduced by Lyubashevsky, Peikert and Regev in <ref type="bibr" target="#b46">[46]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 9 (dR-LWE).</head><p>For a polynomial ring R = Z[X]/f (X) with f of degree n, an integer q ≥ 2, an adversary A and an error distribution χ over R q = R/qR, R ∨ being R dual fractional ideal, we define the following advantage function:</p><formula xml:id="formula_6">Adv dRLWER,q,χ A := | Pr[A(a, z 0 ) = 1] -Pr[A(a, z 1 ) = 1]|, where a ← $ R q , s ← $ R ∨ q , e ← $ χ, z 0 := a • s + e and z 1 ← $ R.</formula><p>With f (X) a cyclotomic polynomial, the dRLWE R,q,χ assumption asserts that for all PPT adversaries A, the advantage Adv dRLWER,q,χ A is a negligible function in n.</p><p>For our constructions, we need to take the distribution χ as a subgaussian random variable which we define hereafter. More details about the subgaussian distribution and the lemmas' proof can be found in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b59">58]</ref>.</p><p>Definition 10 (Subgaussian Random Variables). Let X be a random variable. We say X is subgaussian with parameter σ if there exists σ such that:</p><formula xml:id="formula_7">∀t ∈ R, E[e tX ] ≤ e σ 2 t 2 /2 ,</formula><p>where E[e tX ] is the moment generating function of X.</p><p>Lemma 1 (Subgaussian Random Variables Properties). Let X, X be independent subgaussian random variables of parameter σ and σ respectively. Assuming E(X) = E(X ) = 0 we have the following properties:</p><p>-Tails: ∀t ≥ 0 we have P r[|X| ≥ t] ≤ 2e -πt 2 /σ 2 . -Homogeneity: ∀c ∈ R, cX is subgaussian with parameter |c|σ.</p><p>-Pythagorean additivity: X + X is subgaussian with parameter</p><formula xml:id="formula_8">√ σ 2 + σ 2 .</formula><p>We extend the notion of subgaussianity to vectors and polynomials. Since the coefficients of a polynomial are seen as a vector, we call subgaussian vector of parameter σ a vector where each coefficient follows an independent subgaussian distribution with parameter σ. Lemma 2 (Subgaussian Vector Norm, Adapted from <ref type="bibr" target="#b1">[2]</ref>, Lemma 2.1). Let x ∈ R n be a random vector where each coordinate follows an independent subgaussian distribution of parameter σ. Then for some universal constant C &gt; 0</p><formula xml:id="formula_9">we have P r [||x|| 2 &gt; Cσ √ n] ≤ 2 -Ω(n) and therefore ||x|| 2 = O(σ √ n).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Fully Homomorphic Encryption</head><p>In this section we recall the definition of (Fully) Homomorphic Encryption and present the Homomorphic Encryption schemes we will use, both based on GSW <ref type="bibr" target="#b32">[32]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 11 (Homomorphic Encryption Scheme</head><formula xml:id="formula_10">∈ M. -H.Eval(f, c 1 , • • • , c k , pk H ). With c i = H.Enc(m i , pk H ) for 1 ≤ i ≤ k, output a ciphertext c f ∈ C such that H.Dec(c f ) = f (m 1 , • • • , m k ).</formula><p>A homomorphic encryption scheme is called a Fully Homomorphic Encryption (FHE) scheme when f can be any function and |C| is finite. A simpler primitive to consider is the SomeWhat Homomorphic Encryption (SWHE) scheme, where f is restricted to be any univariate polynomial of finite degree.</p><p>Since the breakthrough work of Gentry <ref type="bibr" target="#b30">[30]</ref>, the only known way to obtain FHE consists in adding a bootstrapping technique to a SWHE. As bootstrapping computational cost is still expensive in comparison to the other FHE algorithms, in the following part of the article we will only consider SWHE for our applications.</p><p>GSW Homomorphic Encryption Scheme. In 2013, Gentry, Sahai and Waters <ref type="bibr" target="#b32">[32]</ref> introduced a Homomorphic Encryption scheme based on LWE using a new technique stemming from the approximate eigenvector problem. This new technique led to a new family of FHE, called 3rd-generation FHE, consisting in Homomorphic Encryption schemes such that the multiplicative error growth is quasi-additive. Hereafter, we present two schemes belonging to this generation, the first one with security based on dLWE and the second one based on dRLWE. We first set some useful notations considering the different schemes.</p><p>For a matrix E we refer to the i-th row as e i and to the j-th column as e j . The log q notation refers to the logarithm in base 2 of q. The notation [a] q is for a mod q and [a] q 2 ∈ {0, 1} is a function in a ∈ Z q giving 1 if q 4 ≤ a ≤ 3q 4 mod q and 0 otherwise. We denote by [n] the set of integers {1, • • • , n}. We finally use |x| and ||x|| 2 for the standard norms 1 and 2 on vectors x ∈ R n .</p><p>Batched GSW. This scheme is a batched version of GSW presented in <ref type="bibr" target="#b36">[36]</ref>, enabling to pack independently r plaintexts in one ciphertext. From the security parameter λ and the considered applications, we can derive the parameters n, q, r, χ of the scheme described below.</p><p>H.KeyGen(n, q, r, χ). On inputs the lattice dimension n, the modulus q, the number of bits by ciphertext r and the error distribution χ do:</p><formula xml:id="formula_11">-Set = log q , m = O(n ), N = (r + n) , M = {0, 1} r and C = Z (r+n)×N q . -Pick A ← $ Z n×m q , S ← $ χ r×n and E ← $ χ r×m . -Set S = [I| -S ] ∈ Z r×(r+n) q and B = S A + E A q ∈ Z (r+n)×m q .</formula><p>-For all m ∈ {0, 1} r :</p><formula xml:id="formula_12">• Pick R m ← $ {0, 1} m×N . • Set P m = ⎡ ⎢ ⎢ ⎢ ⎣ BR m + ⎛ ⎜ ⎜ ⎜ ⎝ m 1 • s 1 . . . m r • s r 0 ⎞ ⎟ ⎟ ⎟ ⎠ G ⎤ ⎥ ⎥ ⎥ ⎦ q ∈ Z (r+n)×N q .</formula><p>with s i the i-th row of S and</p><formula xml:id="formula_13">G = (2 0 , • • • , 2 -1 ) ⊗ I ∈ Z (r+n)×N q . -Output pk H := ({P m }, B) and sk H := S.</formula><p>H.Enc(pk H , m). On input pk H , and m ∈ {0, 1} r , do:</p><formula xml:id="formula_14">-Pick R ← $ {0, 1} m×N , and output C = [BR + P m ] q ∈ Z (r+n)×N q .</formula><p>H.Dec(C, sk H ). On input the secret key sk H , and a ciphertext C, do:</p><p>-For all i ∈ [r] :</p><formula xml:id="formula_15">m i = [ s i , c i ] q 2 where c il is the column i of C. -Output m 1 , • • • , m r ∈ {0, 1} r . Note that SC = SBR+SP m = ER+ER m + ⎛ ⎜ ⎝ m 1 • s 1 . . . m r • s r ⎞ ⎟ ⎠ G = E + ⎛ ⎜ ⎝ m 1 • s 1 . . . m r • s r ⎞ ⎟ ⎠ G.</formula><p>The H.Eval algorithm finally consists in iterating, following a circuit f , the homomorphic operations H.Add and H.Mul:</p><formula xml:id="formula_16">-H.Add(C 1 , C 2 ) : C + = C 1 + C 2 . -H.Mul(C 1 , C 2 ) : C × = C 1 × G -1 C 2 with G -1 a function such that ∀C ∈ Z (r+n)×N q</formula><p>, GG -1 (C) = C and the values of G -1 (C) follow a subgaussian distribution with parameter O(1) (see <ref type="bibr" target="#b50">[49]</ref> for the existence and proof of G -1 ).</p><p>The correctness and security of this scheme are proven in the extended version of this paper.</p><p>Remark 1. For practical use, we only need to store r + 1 matrices P m , namely the r + 1 ones with m of hamming weight equal to 0 or 1 are sufficient to generate correct encryption of all m ∈ {0, 1} r with at most r additions of the corresponding P m matrices. <ref type="bibr" target="#b38">[38]</ref>, transposing the approximate eigenvector problem into the ring setting. From λ the security parameter and the considered applications, we can derive the parameters n, q and M of the scheme described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ring-GSW. This scheme is a ring version of GSW presented in</head><p>H.KeyGen(n, q, χ, M). On inputs the lattice dimension n, which is set to a power of 2, the modulus q, the error distribution χ and the plaintext space M do:</p><formula xml:id="formula_17">-Set R = Z[X]/(X n + 1), R q = R/qR, = log q , N = 2 and C = R 2×N q . -Set R 0,1 = {P ∈ R q , p i ∈ {0, 1}, 0 ≤ i &lt; n}. -Pick a ← $ R q , s ← $ χ and e ← $ χ. -Set s = [1| -s ] ∈ R 1×2 q and b = s a + e a ∈ R 2×1 q .</formula><p>-Output pk H := b and sk H := s.</p><p>H.Enc(pk H , m). On input pk H , and m ∈ M, do:</p><p>-</p><formula xml:id="formula_18">Pick E ← $ χ 2×N . -Pick r ← $ R N 0,1 , and output C = [br + mG + E] q ∈ R 2×N q .</formula><p>H.Dec(C, sk H ). On input the secret key sk H , and a ciphertext C, do:</p><formula xml:id="formula_19">-Compute m = [&lt; s, c l &gt;] q 2 . -Output m ∈ R q .</formula><p>The H.Eval algorithm finally consists in iterating H.Add and H.Mul:</p><formula xml:id="formula_20">-H.Add(C 1 , C 2 ) : C + = C 1 + C 2 . -H.Mul(C 1 , C 2 ) : C × = C 1 × G -1 C 2 .</formula><p>The correctness and security of this scheme are proven in the extended version of this paper.</p><p>Remark 2. The plaintext space M has a major influence on the considered application in terms of quantity of information contained in a single ciphertext and error growth. For our application we choose M as the set of polynomials with all coefficients of degree greater than 0 being zero, and the constant coefficient being bounded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">New Stream Cipher Constructions</head><p>In this section, we introduce our new stream cipher construction. We first describe the general filter permutator structure. Next we list a number of Boolean building blocks together with their necessary cryptographic properties. Third, we specify a family of filter permutators (denoted as FLIP) and analyze its security based on state-of-the art cryptanalysis and design tools. Finally, we propose a couple of parameters to fully instantiate a few examples of FLIP designs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Filter Permutators</head><p>The general structure of filter permutators is depicted in Fig. <ref type="figure" target="#fig_1">2</ref>. It is composed of three parts: a register where the key is stored, a (bit) permutation generator parametrised by a Pseudo Random Number Generator (PRNG) <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b37">37]</ref> (which is initialized with a public IV), and a filtering function which generates a keystream. The filter permutator can be compared to a filter generator, in which the LFSR is replaced by a permuted key register. In other words, the register is no longer updated by means of the LFSR, but with pseudorandom bit permutations. More precisely, at each cycle (i.e. each time the filtering function outputs a bit), a pseudo-random permutation is applied to the register and the permuted key register is filtered. Eventually, the encryption (resp. decryption) with a filter permutator simply consists in XORing the bits output by the filtering function with those of the plaintext (resp. ciphertext).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Boolean Building Blocks for the Filter Permutator</head><p>We will first exploit direct sums of Boolean functions defined as follows:</p><formula xml:id="formula_21">Definition 12 (Direct Sum). Let f 1 (x 0 , • • • , x n1-1 ) and f 2 (x n1 , • • • , x n1+n2-1</formula><p>) be two Boolean functions in respectively n 1 and n 2 variables. The direct sum of f 1 and f 2 is defined as</p><formula xml:id="formula_22">f = f 1 ⊕ f 2 , which is a Boolean function in n 1 + n 2 variables such that: f (x 0 , • • • , x n1+n2-1 ) = f 1 (x 0 , • • • , x n1-1 ) ⊕ f 2 (x n1 , • • • , x n1+n2-1 ).</formula><p>They inherit from the following set of properties, proven in the extended version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 (Direct Sum Properties).</head><p>Let f be the direct sum of f 1 and f 2 with n 1 and n 2 variables respectively. Then f has the following cryptographic properties:</p><formula xml:id="formula_23">1. Non Linearity: NL(f ) = 2 n2 NL(f 1 ) + 2 n1 NL(f 2 ) -2NL(f 1 )NL(f 2 ). 2. Resiliency: res(f ) = res(f 1 ) + res(f 2 ) + 1. 3. Algebraic Immunity: AI(f 1 ) + AI(f 2 ) ≥ AI(f ) ≥ max(AI(f 1 ), AI(f 2 )). 4. Fast Algebraic Immunity: FAI(f ) ≥ max(FAI(f 1 ), FAI(f 2 )).</formula><p>Our direct sums will then be based on three parts: a linear function, a quadratic function and triangular functions, defined as follows.</p><p>Definition 13 (Linear Functions). Let n &gt; 0 be a positive integer, the L n linear function is a n-variable Boolean function defined as:</p><formula xml:id="formula_24">L n (x 0 , • • • , x n-1 ) = n-1 i=0 x i .</formula><p>Definition 14 (Quadratic Functions). Let n &gt; 0 be a positive integer, the Q n linear function is a 2n-variable Boolean function defined as:</p><formula xml:id="formula_25">Q n (x 0 , • • • , x 2n-1 ) = n-1 i=0 x 2i x 2i+1 .</formula><p>Definition 15 (Triangular Functions). Let k &gt; 0 be a positive integer. The k-th triangular function T k is a k(k+1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>-variable Boolean function defined as:</p><formula xml:id="formula_26">T k (x 0 , • • • , x k(k+1) 2 -1 ) = Σ k i=1 Π i-1 j=0 x j+Σ i-1 =0 .</formula><p>For example, the 4th triangular function T 4 is:</p><formula xml:id="formula_27">T 4 = x 0 ⊕ x 1 x 2 ⊕ x 3 x 4 x 5 ⊕ x 6 x 7 x 8 x 9 .</formula><p>These three types of functions allow us to guarantee the following properties.</p><p>Lemma 4 (Linear Functions Properties). Let L n be a linear function in n variables, then L n has the following cryptographic properties:</p><p>1. Non Linearity:</p><formula xml:id="formula_28">NL(L n ) = 0. 2. Resiliency: res(L n ) = n -1. 3. Algebraic Immunity: AI(L n ) = 1. 4. Fast Algebraic Immunity: FAI(L n ) = 2.</formula><p>Lemma 5 (Quadratic Functions Properties). Let Q n be a linear function in 2n variables, then Q n has the following cryptographic properties:</p><formula xml:id="formula_29">1. Non Linearity: NL(Q n ) = 2 2n-1 -2 n-1 . 2. Resiliency: res(Q n ) = -1. 3. Algebraic Immunity: AI(Q 1 ) = 1 and ∀n &gt; 1, AI(Q n ) = 2. 4. Fast Algebraic Immunity: FAI(Q 1 ) = 2 and ∀n &gt; 1, FAI(Q n ) = 4.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 6 (Triangular Functions Properties).</head><p>Let k a positive integer and let T k the k-th triangular function. Then the following properties hold:</p><p>1. Non Linearity follows the recursive formula defined as:</p><formula xml:id="formula_30">(i) NL(T 1 = 0), (ii) NL(T k+1 ) = (2 k+1 -2)NL(T k ) + 2 k(k+1)/2 . 2. Resiliency: res(T k ) = 0. 3. Algebraic Immunity: AI(T k ) = k. 4. Fast Algebraic Immunity: FAI(T k ) = k + 1.</formula><p>The proof of Lemma 6 can be found in the extended version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The FLIP Family of Stream Ciphers</head><p>Based on the previous definitions, we specify the FLIP family of stream ciphers as a filter permutator using a forward secure PRNG <ref type="bibr" target="#b4">[5]</ref> based on the AES-128 (e.g. as instantiated in the context of leakage-resilient cryptography <ref type="bibr" target="#b58">[57]</ref>), the Knuth shuffle (see below) as bit permutation generator and such that the filter F is the N -variable Boolean function defined by the direct sum of three Boolean functions f 1 , f 2 and f 3 of respectively n 1 , n 2 and n 3 variables, such that:</p><formula xml:id="formula_31">-f 1 (x 0 , • • • , x n1-1 ) = L n1 , -f 2 (x n1 , • • • , x n1+n2-1 ) = Q n2/2 , -f 3 (x n1+n2 , • • • , x n1+n2+n3-1 ) is the direct sum of nb triangular functions T k ,</formula><p>i.e. such that each T k acts on different and independent variables, that we denote as nb Δ k .</p><p>That is, we have F : F n1+n2+n3 2 → F 2 the Boolean function such that:</p><formula xml:id="formula_32">F (x 0 , • • • , x n1+n2+n3-1 ) = L n1 ⊕ Q n2/2 ⊕ nb i=1 T k .</formula><p>In the following section, we provide a preliminary security analysis of the FLIP filter permutators against a couple of standard attacks against stream ciphers, based on state-of-the-art tools. For this purpose, we will assume that no additional weaknesses arise from its PRNG and bit permutation generator. In this respect, we note that our forward secure PRNG does not allow malleability, so it should be hard to obtain a collision in the chosen IV model better than with birthday probability. This should prevent collisions on the generated permutations. Besides, the Knuth shuffle <ref type="bibr" target="#b41">[41]</ref> (or Fisher-Yates shuffle) is an algorithm allowing to generate a random permutation on a finite set. This algorithm has the interesting property of giving the same probability to all permutations if used with a random number generator. As a result, we expect that any deviation between a bit permutation based on a Knuth shuffle fed with the PRNG will be hard to exploit by an adversary. Our motivation for this assumption is twofold. First, it allows us to focus on whether the filter permutator construction is theoretically sound. Second, if such a choice was leading to an exploitable weakness, it remains possible to build a pseudorandom permutation based on standard cryptographic constructions <ref type="bibr" target="#b45">[45]</ref>.</p><p>Remark 3. Since the permutation generation part of FLIP has only birthday security (with respect to the size of the PRNG), it implies that it is only secure up to 2 64 PRNG outputs when implemented with the AES-128. Generating more keystream using larger block ciphers should be feasible. However, in view of the novelty of the FLIP instances, our claims are only made for this limited (birthday) data complexity so far, which should not be limiting for the intended FHE applications. We leave the investigation of their security against attacks using larger data complexities as a scope for further research. Besides, we note that using a PRNG based on a tweakable block cipher <ref type="bibr" target="#b44">[44]</ref> (where a part of the larger IV would be used as tweak) could be an interesting track to reduce the impact of a collision on the PRNG output in the known IV model, which we also leave as an open research direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Security Analysis</head><p>Since the filter permutator shares similarities with a filter generator, it is natural to start our investigations with the typical attacks considered against such types of stream ciphers. For this purpose, we next study the applicability of algebraic attacks and correlation attacks, together with more specialized cryptanalyses that have been considered against stream ciphers. Note that the attacks considered in the rest of this section frequently require to solve systems of equations and to implement a Gaussian reduction. Our complexity estimations will consider Strassen's algorithm for this purpose and assume ω = log 7 to be the exponent in a Gaussian reduction. Admittedly, approaches based on Gröbner bases <ref type="bibr" target="#b26">[27]</ref> or taking advantage of the sparsity of the matrices <ref type="bibr" target="#b60">[59]</ref> could lead to even faster algorithms. We ignore them for simplicity in these preliminary investigations. Note also that we only claim security in the single-key setting.</p><p>Algebraic Attacks were first introduced by Courtois and Meier in <ref type="bibr" target="#b17">[18]</ref> and applied to the stream cipher Toyocrypt. Their main idea is to build an overdefined system of equations with the initial state of the LFSR as unknown, and to solve this system with Gaussian elimination. More precisely, by using a nonzero function g such that both g and h = gF have low algebraic degree, an adversary is able to obtain T equations with monomials of degree at most AI(f ). It is easily shown that g can be taken equal to the annihilator of F or of F ⊕ 1, i.e. such that gF = 0 or g(F ⊕ 1) = 0. After a linearisation step, the adversary obtains a system of T equations in D = AI(F ) i=0 N i variables. Therefore, the time complexity of the algebraic attack is O(D ω ), that is, O(N ωAI(f ) ).</p><p>Fast Algebraic Attacks are a variation of the previous algebraic attacks introduced by Courtois at Crypto 2003 <ref type="bibr" target="#b16">[17]</ref>. Considering the relation gF = h, their goal is to find and use functions g of low algebraic degree e, possibly smaller than AI(f ), and h of low but possibly larger degree d, and to lower the degree of the resulting equations by an off-line elimination of the monomials of degrees larger than e (several equations being needed to obtain each one with degree at most e). Following <ref type="bibr" target="#b3">[4]</ref>, this attack can be decomposed into four steps: Correlation Attacks. In their basic versions, correlation attacks try to distinguish the output sequence of a stream cipher from a random one, by exploiting the bias δ of the filtering function. We can easily rule out such attacks by considering a (much) simplified version of filter permutator where the bit permutations P i 's would be made on two independent permutations P 1 i and P 2,3 i (respectively acting on the n 1 + 1 bits of the linear part and the n 2 + n 3 -1 bits of the non-linear part of F ). Suppose for simplicity that P 1 i is kept constant t times, then the output distribution of F has a bias δ and it can be distinguished for the right choice of the n 1 + 1 = res + 1 bits of the linear part. In this case, a correlation attack would have a data complexity of O(δ -2 ) and a time complexity</p><formula xml:id="formula_33">of O(2 res(F )+1 δ -2 ), with δ = 1 2 - NL(F ) 2 N</formula><p>. For simplicity, we will consider this conservative estimation in our following selection of security parameters. Yet, we note that since the permutation P i of a filter permutator is acting on all the N bits of the filter F , the probability that the linear part of F is kept invariant by the permutations t times is in fact considerably smaller than what is predicted by the resilience.</p><p>BKW-like Attack. The BKW algorithm was introduced in <ref type="bibr" target="#b5">[6]</ref> as a solution to solve the LPN problem using smart combinations of well chosen vectors and their associated bias. Intuitively, our stream cipher construction simplified as just explained (with two independent permutations P 1 i and P 2,3 i rather than a single one P i ) also shares similarities with this problem. Indeed, we could see the linear part as the parity of an LPN problem and the non-linear one (with a small bias) as a (large) noise. Adapting the BKW algorithm to our setting amounts to XOR some linear parts of F in order to obtain vectors of low Hamming weight, and then to consider a distinguishing attack with the associated bias. Denoting h the target Hamming weight, x the log of the number of XORs and δ the bias, the resulting attack (which can be viewed as an extension of the previous correlation attack) has data complexity O(2 h δ -2(x+1) ) (more details are given in the extended version of this paper).</p><p>Higher-Order Correlation Attacks were introduced by Courtois <ref type="bibr" target="#b15">[16]</ref> and exploit the so-called XL algorithm. They look for good correlations between F and an approximation g of degree d &gt; 1, in order to solve a linearised system based on the values of this approximation. The value ε is defined such that g is equal to F with probability greater than 1-ε. Such attacks have a (conservative) time complexity estimate:</p><formula xml:id="formula_34">O N D ω (1 -ε) -m , where D ≥ d and m ≥ N D N D-d .</formula><p>Guess and Determine Attacks. Note that this section has been motivated by a private communication from Sébastien Duval, Virginie Lallemand and Yann Rotella, of which the details will be available in an upcoming ePrint report <ref type="bibr" target="#b24">[25]</ref>.</p><p>Guess and determine attacks are generic attacks which consist in guessing bits of the key in order to cancel some monomials. In our context, it allows an adversary to focus on a filtering function restricted to a subset of variables. This weaker function can then be cryptanalyzed, e.g. analyzed with the four aforementioned attacks, i.e. the algebraic attack, the fast algebraic attack, the correlation/BKW-like attacks and the higher-order correlation attack. The complexity of a guess and determine attack against a function F of N variables is min {2 C(F [ ])} where F [ ] is a function of N [ ] variables obtained by fixing variables of F , C(F ) is the complexity of the best of the four attacks considered on the filtering function F and the minimum is taken over all 's. The case = 0 corresponds to attacking the scheme without guess and determine. We next bound the minimal complexity over these four attacks considering the weakest functions obtained by guessing. To do so, we introduce some notations and criteria allowing us to specify the cryptographic properties of Boolean functions obtained by guessing variables of Boolean functions being direct sums of monomials. As the impact of guessing is most relevant for fast algebraic attacks and CA/BKW-like attacks, we defer the other part of the analysis and extra lemmas to the extended version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 16 (Direct Sum Vector). For a boolean function F of N variables obtained as a direct sum of monomials we associate its direct sum vector</head><formula xml:id="formula_35">: m F of length k = deg(F ): [m 1 , m 2 , • • • , m k ]</formula><p>such that m i is the number of monomials of degree i of F and N = k i=1 im i . We define two quantities related to this vector:</p><p>m * F is the number of nonzero values of m F . -δ mF = 1 2 -NL(F ) 2 N . These notations will be useful to quantify the impact of guessing some bits on the cryptographic properties of a Boolean function obtained by direct sums. m F , m * F and δ mF are easily computable from the description of F , the latter can be computed recursively using Lemma 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7 (Guessing and Direct Sum Vector). For all guessing of 0 ≤ ≤ N variables of a Boolean function F in N variables obtained by direct sums associated with m F , we obtain a function F [ ] in N [ ] variables associated with m</head><formula xml:id="formula_36">F [ ] such that: 1. deg(F [ ]) i=1 m i [ ] ≥ ( deg(F ) i=1 m i ) -. 2. m * F [ ] ≥ m * F -min 1≤i≤deg(F ) mi . 3. δ m F [ ] ≤ δ mF 2 .</formula><p>Hereafter we describe the bounds we have used in order to assess the security of our instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 8 (Guess And Determine &amp; Fast Algebraic Attacks). Let F be a boolean function in N variables and C GDF AA (F ) be the minimum complexity of the Guess And Determine with Fast Algebraic Attacks on F , then:</head><formula xml:id="formula_37">C GDF AA (F ) ≥ min 0≤ ≤N 2 ( min N [ ] m * F [ ] ) log 2 ( min N [ ] m * F [ ] )+(min N [ ]) 2 ( min N [ ] m * F [ ] )+(min N [ ]) ω , where m * F [ ] = m * F -min i∈[deg(F )] mi .</formula><p>Lemma 9 (Guess and Determine &amp; CA/BKW-like Attacks). Let F be a boolean function in N variables and C GDCA/BKW (F ) be the minimum complexity of the Guess And Determine with Correlation/BKW Attacks on F , then:</p><formula xml:id="formula_38">C GDCA/BKW (F ) ≥ min 0≤ ≤N {2 -δ -2 mF }.</formula><p>Other Attacks. Besides the previous attacks that will be taken into account quantitatively when selecting our concrete instances of FLIP designs, we also investigated the following other cryptanalyses. First, fast correlation attacks were introduced by Meier and Staffelbach at Eurocrypt 1988 <ref type="bibr" target="#b49">[48]</ref>. A recent survey can be found in <ref type="bibr" target="#b48">[47]</ref>. The attack is divided into two phases. The first one aims at looking for relations between the output bits a i of the LFSR to generate a system of parity-check equations. The second one uses a fast decoding algorithm (e.g. the belief propagation algorithm) in order to decode the words of the code z i = F (a i ) satisfying the previous relations, where the channel has an error probability p = NL(F ) 2 N . The working principles of this attack are quite similar to the ones of the previously mentioned correlation attacks and BKW-like attacks. So we assume that the previous (conservative) complexity estimates rule out this variation as well. Besides, note that intuitively, the belief propagation algorithm is best suited to the decoding of low-density parities, which is what our construction (and the LPN problem) typically avoids.</p><p>Second, weak keys (i.e. keys of low or high hamming weights) can produce a keystream sufficiently biased to determine this hamming weight, and then to recover the key among the small amount of possible ones. The complexity of such attacks can be computed from the resiliency of F . However, since our N parameter will typically be significantly larger than the bit-security of our filter permutator instances, we suggest to restrict the key space to keys of Hamming weight N/2 to rule out this concern. For this purpose, master keys can simply be generated by applying a first (secret) random permutation to any stream with Hamming weight N/2.</p><p>Third, augmented function attacks are attacks focusing on multiple outputs of the function rather than one. The goal is to find coefficients j 1 , • • • , j r such that a relation between the key and the outputs s i+j1 , • • • , s i+jr can be exploited. This relation can be a correlation (as explained in <ref type="bibr" target="#b2">[3]</ref>) or simply algebraic <ref type="bibr" target="#b27">[28]</ref>. In both cases, a prerequisite is that the relation holds on a sufficient number of i. As each bit output by FLIP depends on a different permutation, we believe that there is no exploitable relation between different outputs.</p><p>Eventually, cube attacks were introduced by Dinur and Shamir at Eurocrypt 2009 <ref type="bibr" target="#b19">[20]</ref> as a variant of algebraic attacks taking advantage of the public parameters of a cryptographic protocol (plaintext in block ciphers, IV in stream cipher) in order to generate a system of equations of low degree. However in filter permutator constructions, the only such public parameter is the seed of the PRNG allowing to generate the pseudo-random bit permutations P i . Since controlling this seed hardly allows any control of the F function's inputs, such attacks do not seem applicable. A similar observation holds for conditional differential cryptanalysis <ref type="bibr" target="#b39">[39]</ref> and for integral/zero-sum distinguishers <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b40">40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Cautionary Note and Design Tweaks</head><p>As already mentioned, all the previous analyzes are based on standard cryptanalysis and design tools. In particular, the security of our FLIP designs is based on properties of Boolean functions that are generally computed assuming a uniform input distribution. Yet, for filter permutators this condition is not strictly respected since the Hamming weight of the key register is fixed (we decided to set it to N/2 in order to avoid weak keys, but even without this condition, it would be fixed to an unknown value). This means the input distribution of our linear, quadratic and triangle functions is not uniform. We verified experimentally that the output of FLIP is sufficiently balanced despite this non-uniformity. More precisely, we could not detect biases larger than 2 q 2 when generating 2 q bits of keystream (based on small-scale experiments with q = 32). But we did not study the impact of this non-uniformity for other attacks, which we leave as an important research scope, both from the cryptanalysis and the Boolean functions points-of-view.</p><p>Note that in case the filter permutator of Sect. 3.1 turns out to have weaknesses specifically due to the imbalanced F function's inputs, there are tweaks that could be used to mitigate their impact. The simplest one is to apply a public whitening to the input bits of the non-linear parts of F (using additional public PRNG outputs), which has no impact on the homomorphic capacity. The adversary could then bias the F function's inputs based on his knowledge of the whitening bits, but to a lower extent than with our fixed Hamming weight keys. Alternatively, one could add a (more or less complex) linear layer before the non-linear part of F , which would then make the filter permutator conceptually more similar to filter generators, and (at least for certain layers) only imply moderate cost from the FHE point-of-view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">80-&amp; 128-bit Security Instances</head><p>We selected a few instances aiming at 80-and 128-bit security based on the previous bounds, leading to the attack complexities listed in Table <ref type="table">1</ref>, where FLIP(n 1 , n 2 , nb Δ k ) denotes the instantiation of FLIP with linear part of n 1 bits, quadratic part of n 2 bits and nb triangular functions of degree k. These instances are naturally contrasted. On the one hand, the bounds taken are conservative with respect to the attacks considered: if these attacks were the best ones, more aggressive instances could be proposed (e.g. in order to reduce the key size). On the other hand, filter permutators are based on non-standard design principles, and our security analysis is only preliminary, which naturally suggests the need of security margins. Overall, we believe the proposed instances are a reasonable trade-off between efficiency and security based on our current understanding of filter permutators, and therefore are a good target for further investigations.</p><p>Table <ref type="table">1</ref>. Attack complexities in function of n1, n2 and nb Δ k . AA stands for algebraic attacks, FAA stands for fast algebraic attacks, CA/BKW stands for correlation or BKW-like attacks, HOC stands for higher-order correlation attacks and stands for the number of bits guessed leading to the best complexity for guess and determine attacks. For the CA/BKW column, we reported the minimum complexity between the correlation and BKW-like attack. Eventually, λ stands for the security parameter of F and is simply taken as the minimum between AA, FAA,CA/BKW and HOC. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instance</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Indirect Sums</head><p>Before analyzing the FHE properties of filter permutators, we finally suggest FLIP designs based on indirect sums as another interesting topic for evaluation, since they lead to quite different challenges. Namely, the main motivation to use direct sums in the previous sections was the possibility to assess their cryptographic properties based on existing tools. By contrast, filter permutator designs based on indirect sums seem harder to analyze (both for designers and cryptanalysts). This is mainly because in this case, not only the inputs of the Boolean functions vary, but also the Boolean functions themselves. For illustration, we can specify "multi-FLIP" designs, next denoted as b-FLIP designs, such that we compute b instances of FLIP in parallel, each with the same filtering function but with different permutations, and then to XOR the b computed bits in order to produce a keystream bit. We conjecture that such b-FLIP designs could lead to secure stream ciphers with smaller states, and suggest 10-FLIP(10, 20, 1 Δ 20 ) and 15-FLIP(15, 30, 1 Δ 30 ) as exemplary instances for 80-and 128-bit security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Application to FHE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">80-&amp; 128-bit Security Parameters</head><p>For the security parameters choices, we follow the analysis of Lindner and Peikert <ref type="bibr" target="#b43">[43]</ref> for the hardness of LWE and RLWE, considering distinguishing and decoding attacks using BKZ <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b56">55]</ref>. We assume that the distribution χ in the considered LWE instances is the discrete Gaussian distribution with mean 0 and standard deviation σ. First we compute the best root Hermite factor δ of a basis (see <ref type="bibr" target="#b29">[29]</ref>) computable with complexity 2 λ from the conservative lower bound of <ref type="bibr" target="#b43">[43]</ref>:</p><formula xml:id="formula_39">log(δ) = 1.8/(110 + λ). (<label>1</label></formula><formula xml:id="formula_40">)</formula><p>The distinguishing attack described in <ref type="bibr" target="#b43">[43,</ref><ref type="bibr" target="#b51">50,</ref><ref type="bibr" target="#b55">54]</ref> is successful with advantage ε by finding vectors of length α q σ with α = ln(1/ε)/π. The length of the shortest vector that can be computed is 2 2 √ n log q log δ , leading to the inequality:</p><formula xml:id="formula_41">α q σ &lt; 2 2 √ n log q log δ . (<label>2</label></formula><formula xml:id="formula_42">)</formula><p>Given σ ≥ 2 √ n from Regev's reduction <ref type="bibr" target="#b54">[53]</ref>, we can choose parameters for n and q matching Eq. ( <ref type="formula" target="#formula_41">2</ref>) for the considered security parameter λ. The parameters we select for our application are summarized in Table <ref type="table" target="#tab_3">2</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Noise Analysis</head><p>Considering our framework of Fig. <ref type="figure" target="#fig_0">1</ref>, Claude has at its disposal the homomorphic encryption of the symmetric key C H (sk S i ), the homomorphic public key pk H and the symmetric encrypted messages C S (m i ). He has to perform the homomorphic evaluation of the symmetric decryption circuit, i.e. to perform homomorphic operations on the ciphertexts C H (sk S i ) in order to get C H (m i ), the homomorphic encryption of m i . In this section, we study the error growth in these ciphertexts after the application of the homomorphic operations. As we are considering SWHE, we need to control the magnitude of the error and keep it below a critical level to ensure the correctness of a final ciphertext. This noise management is crucial for the applications, it is directly linked with the quantity of computation that the server can do for the client. We now study the error growth stemming from the homomorphic evaluation of FLIP. In this case, all the ciphertexts used by the server in the computation step will have a same starting error. The knowledge of this starting error (defined by some parameter) and its growth for additions and multiplications (in a chosen order) is enough to determine the amount of computation that can be performed correctly by the server.</p><p>In the remainder of this section we proceed in three steps. First we recall the error growth implied by the H.Add and H.Mul operations: for GSW-like HE it has already been done in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b36">36]</ref>. As our homomorphic encryption schemes are slightly differently written to fit our applications (batched version to perform in parallel the same computations, generic notations for various frameworks), we give these error growth with our notations for completeness and consistency of the paper. Then we analyse the error for a sub-case of homomorphic product, namely H.Comb, which gives a practical tool to study the error growth in FLIP. As the asymmetric property of GSW multiplication and plaintext norm have been pointed out relatively to the error growth, we consider important to focus on both when analysing this error metric. Considering H.Comb types of operations is therefore suited to be consistent with this metric and is very important for practical purpose (in term of real life applications). Finally we analyse the error in a ciphertext output by FLIP and study some optimizations to reduce the noise growth further.</p><p>Error Growth in H.Add and H.Mul. We first need to evaluate the error growth of the basic homomorphic operations, the addition and the multiplication of ciphertexts. We use the analysis of <ref type="bibr" target="#b1">[2]</ref> based on subgaussian distributions to study the error growth in these homomorphic operations. From a coefficient or a vector following a subgaussian distribution of parameter σ, we can bound its norm with overwhelming probability and then study the evolution of this parameter while performing the homomorphic operations. Hence we can bound the final error to ensure correctness.</p><p>For simplicity we use two notations arising from the error growth depending on the arithmetic of the underlying ring of the two schemes, γ the expansion factor (see <ref type="bibr" target="#b8">[9]</ref>) and Norm(m j ) such that:</p><p>-Batched GSW: γ = 1 and Norm(m j ) = |m j | (arithmetic in Z).</p><p>-Ring GSW: γ = n and Norm(m j ) = ||m j || 2 (arithmetic in R).</p><p>Lemma 10 (H.Add Error Growth). Suppose C i for 1 ≤ i ≤ k are ciphertexts of a GSW based Homomorphic Encryption scheme with error components e i of coefficients following a distribution of parameter σ i . Let C f = H.Add(C i , for 1 ≤ i ≤ k) and e f the related error with subgaussian parameter σ such that:</p><formula xml:id="formula_43">σ = k i=1 σ 2 i or σ = σ √ k if σ i = σ, ∀i ∈ [k].</formula><p>Lemma 11 (H.Mul Error Growth). Suppose C i for 1 ≤ i ≤ k are ciphertexts of a GSW based Homomorphic Encryption scheme with error components e i , of coefficients following a subgaussian distribution of parameter σ i , and plaintext m i . C f is the result of a multiplicative homomorphic chain such that:</p><formula xml:id="formula_44">C f = H.Mul(C 1 , H.Mul(C 2 , H.Mul(• • • , H.Mul(C k , G)))),</formula><p>and e f the corresponding error with subgaussian parameter σ such that:</p><formula xml:id="formula_45">σ = O ⎛ ⎝ Nγ σ 2 1 + k i=2 σ i Π i-1 j=1 Norm(m j ) 2 ⎞ ⎠ .</formula><p>Lemmas 10 and 11 are proven in the extended version of this paper.</p><p>Error Growth in H.Comb. For the sake of clarity, we formalize hereafter the comb homomorphic product H.Comb and the quantity σ comb which stands for the subgaussian parameter. We study the error growth of H.Comb as we will use it as a tool for the error growth analysis of FLIP.  <ref type="figure">(y,</ref><ref type="figure">σ,</ref><ref type="figure">c,</ref><ref type="figure">k</ref>). Then we have:</p><formula xml:id="formula_46">σ comb (y, σ, c, k) = yσc k , wherec k = k-1 i=0 c 2i .</formula><p>Proof. Thanks to Lemma 11 we obtain:</p><formula xml:id="formula_47">σ comb = √ Nγ σ 2 + k i=2 (σΠ i-1 j=1 Norm(m j )) 2 , σ comb = y σ 2 + k i=2 (σc i-1 ) 2 , σ comb = yσ k i=1 (c i-1 ) 2 , σ comb = yσc k .</formula><p>The compatibility of this comb structure with the asymmetric multiplicative error growth property of GSW enables us to easily quantify the error in our construction, with a better accuracy than computing the multiplicative depth. In order to minimize the quantity σ comb , we choose the plaintext space such that c = 1 for freshly generated ciphertexts. The resulting σ comb (y, σ, 1, k) quantity is therefore yσ √ k, growing less than linearly in the number of ciphertexts. Fixing the constant c to be 1 is usual with FHE. As we mostly consider Boolean circuits, it is usual to use plaintexts in {-1, 0, 1} to encrypt bits, leading to c = 1 and therefore c k = √ k.</p><p>Error Growth in FLIP. In the previous paragraphs, we have evaluated the error growth in the basic homomorphic operations H.Add, H.Mul and H.Comb. We will use them as building blocks in order to evaluate the error growth in the homomorphic evaluation of FLIP. Coming back to the framework of Fig. <ref type="figure" target="#fig_0">1</ref>, the error in the ciphertexts C H (m i ) is of major importance as it will determine the possible number of homomorphic computations f that Claude is able to perform. The main feature of the filter permutator model, considering FHE settings, is that it allows to handle ciphertexts having the same error level, whatever the number of output bits. Consequently all ciphertexts obtained by FLIP evaluation will have the same constant and small amount of noise and will be considered as fresh start for more computation.</p><p>Evaluating homomorphically the FLIP decryption (resp. encryption) algorithm consists in applying three steps of homomorphic operations on the ciphertexts C H (sk S i ) in our application framework, each one encoding one bit of the key register. For each ciphertext bit, these steps are: a (bit) permutation, the application of the filtering function F and a XOR with the ciphertext (resp. plaintext). The (bit) permutation consists only in a public rearrangement of the key ciphertexts, leading to a noise-free operation. The last XOR is done with a freshly encrypted bit. Hence the error growth depends mostly on the homomorphic evaluation of F .</p><p>As H.Dec outputs quantities modulus 2, we can evaluate the XORs of F by H.Add and the ANDs by H.Mul. We then determine the subgaussian parameter of the error of a ciphertext from the homomorphic evaluation of F . For a given encrypted key, this parameter will be the same for every homomorphic evaluation of FLIP and is computed from σ comb .</p><p>Lemma 13 (Error Growth Evaluating F ). Let F be the FLIP filtering function in N variables defined in Sect. <ref type="bibr">3.3</ref>. Assume that C i for 0 ≤ i ≤ N -1 are ciphertexts of a GSW HE scheme with same subgaussian parameter σ and c = 1. We define C F = H.Eval(F, C i ) the output of the homomorphic evaluation of the ciphertexts C i 's along the circuit F . Then the error parameter σ is:</p><formula xml:id="formula_48">σ = O σ n 1 + y 2 (n 2 + n 3 ) ≈ O σy √ N .</formula><p>Proof. We first evaluate the noise brought by F for each of its components L n1 , Q n2 , nb Δ k , defining the respective ciphertexts C Ln 1 , C Qn 2 , C T k (the last one standing for one triangle only) and the subgaussian parameter of the respective error distributions (of the components of the error vectors) σ Ln 1 , σ Qn 2 , σ T k :</p><p>-</p><formula xml:id="formula_49">L n1 : C Ln 1 = H.Eval(L n1 , C 0 , • • • , C n1-1 ) = H.Add(C 0 , • • • , C n1-1 ) then σ Ln 1 = σ √ n 1 . -Q n2 : C Qn 2 = H.Add(H.Mul(C n1+2j , C n1+2j+1 , G)) for 0 ≤ j ≤ n 2 . H.Mul(C n1+2j , C n1+2j+1 , G) = H.Comb(y, σ, 1, 2) has subgaussian parameter O(σ comb (y, σ, 1, 2)) = O(yσ √ 2) for 0 ≤ j ≤ n 2 . Then σ Qn 2 = O(yσ √ 2 n2 2 ) = O(yσ √ n 2 ). -T k : C T k = H.Add(H.Mul(C n1+n2+j+(i-1)(i-2)/2 ; 1 ≤ j ≤ i); 1 ≤ i ≤ k). C T k = H.Add(H.Comb(y, σ, 1, i), 1 ≤ i ≤ k). then σ T k = O( k i=1 (yσ √ i) 2 ) = O(yσ k(k+1)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>). As nb Δ k is obtained by adding nb independent triangles, we get:</p><formula xml:id="formula_50">Cnb Δ k = H.Add(C T k ,i , 1 ≤ i ≤ nb),</formula><formula xml:id="formula_51">and σnb Δ k = O(yσ √ nb k(k+1) 2 ) = O(yσ √ n 3 ).</formula><p>By Pythagorean additivity the subgaussian parameter of C F is finally:</p><formula xml:id="formula_52">σ = O( (σ √ n 1 ) 2 + (yσ √ n 2 ) 2 + (yσ √ n 3 ) 2 ) = O(σ n 1 + y 2 (n 2 + n 3 )).</formula><p>Optimizations. The particular error growth in GSW Homomorphic Encryption enables to use more optimizations to reduce the error norm and perform more operations without increasing the parameter's size. The error growth in H.Comb depends on the quantity c k derived from bounds on norms of the plaintexts; these quantities can be reduced using negative numbers. A typical example is in the LWE-based scheme to use m ∈ {-1, 0, 1} rather than {0, 1}; the c k quantity is the same and in average the sums in Z are smaller. Then the norm | m i | is smaller which is important when multiplying. Conserving this norm as low as possible gives better bounds and c k coefficients, leading to smaller noise when performing distinct levels of operations. An equivalent way of minimizing the error growth is to still use</p><formula xml:id="formula_53">M = {0, 1} but with H.Add(C 1 , C 2 ) = C 1 ± C 2 .</formula><p>This homomorphic addition is still correct because:</p><formula xml:id="formula_54">S -C 2 = -E 2 - ⎛ ⎜ ⎝ m 2,1 • s 1 . . . m 2,r • s r ⎞ ⎟ ⎠ G = E 2 + ⎛ ⎜ ⎝ -m 2,1 • s 1 . . . -m 2,r • s r ⎞ ⎟ ⎠ ,</formula><p>where the coefficients in E 2 rows follow distribution of same subgaussian parameter as the one in E 2 by homogeneity and -m = m mod 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Concrete Results</head><p>Contrary to other works published in the context of symmetric encryption schemes for efficient FHE <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b31">31]</ref>, our primary focus is not on the performances (see SHIELD <ref type="bibr" target="#b38">[38]</ref> for efficient implementation of Ring-GSW) but rather on the error growth. As pointed out in <ref type="bibr" target="#b10">[11]</ref>, in most of these previous works, after the decryption process the noise inside the ciphertexts was too high to perform any other operation on them, whereas it is the main motivation for a practical use of FHE.</p><p>In this section, we consequently provide experimental results about this error growth in the ciphertexts after different operations evaluated on the Ring GSW scheme. As the link between subgaussian parameter, ciphertext error and homomorphic computation is not direct, we make some choices for representing these results focusing on giving intuition on how the error behaves.</p><p>The choice of the Ring GSW setting rather than Batched GSW is for convenience. It allows to deal with smaller matrices and faster evaluations, providing the same confirmation on the heuristic error growth. We give the parameters n and defining the polynomial ring and fix σ = 2 √ n for the error distribution. An efficient way of measuring the error growth within the ciphertexts is to compute the difference by applying the rounding • 2 in H.Dec between various ciphertexts with known plaintext. This difference (for each polynomial coefficient or vector component) corresponds to the amount of noise contained in this ciphertext. The correctness requires this quantity to be inferior to 2 -2 . Then, considering its logarithm in base 2, it enables to have an intuitive and practical measure of the ciphertext noise: this quantity grows with the homomorphic operations until this log equals -2. Concretely, in our experiments we encrypt polynomials being m = 0 or m = 1, compute on the constant coefficient the quantity e = |( s, c -m2 -1 ) mod q|, and give its logarithm. We give another quantity in order to provide intuition about the homomorphic computation possibilities over the ciphertexts, by simply computing a percentage of the actual level of noise relatively to the maximal level -2.</p><p>Remark 4. The quantity exhibited by our measures is roughly the subgaussian parameter of the distribution of the error contained in the ciphertexts. Considering the simpler case of a real Gaussian distribution N (0, σ 2 ), the difference that we compute then follows a half normal distribution with mean σ</p><formula xml:id="formula_55">√ 2 √ π .</formula><p>We based our prototype implementation on the NTL library combined with GMP and the discrete gaussian sampler of BLISS <ref type="bibr" target="#b22">[23]</ref>. We report in Table <ref type="table" target="#tab_5">3</ref> experimental results on the error growth for different RLWE and FLIP parameters, based on an average over a hundred of samples.</p><p>The results confirm the quasi-additive error growth when considering the specific metric of GSW given by the asymptotic bounds. The main conclusion of these results is that the error inside the ciphertexts after a homomorphic evaluation of FLIP is of the same order of magnitude as the one after a multiplication. The only difference between these noise increases is a term provided by the root of the symmetric key register size, that is linear in λ. Therefore, with the FLIP construction the error growth is roughly the basic multiplicative error growth of two ciphertexts. Hence, we conclude that filter permutators as FLIP release the bottleneck of evaluating symmetric decryption, and lead the further improvement of the calculus delegation framework to depend overwhelmingly on improvements of the homomorphic operations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Performances for 2nd-Generation Schemes</head><p>Despite our new constructions are primarily designed for 3rd-generation FHE, a look at Table <ref type="table" target="#tab_6">4</ref> suggests that also from the multiplicative depth point of view, FLIP instances bring good results compared to their natural competitors such as LowMC <ref type="bibr" target="#b0">[1]</ref> and Trivium/Kreyvium <ref type="bibr" target="#b10">[11]</ref>. In Trivium/Kreyvium, the multiplicative depth of the decryption circuit is at most 13, while the LowMC family has a record multiplicative depth of 11 which is still larger than our FLIP instances. For completeness, we finally investigated the performances of some instances of FLIP for 2nd-generation FHE schemes using HElib, as reported in Table <ref type="table" target="#tab_7">5</ref>, where the latency is the amount of time (in seconds) needed to homomorphically decrypt (Nb * Number of Slots) bits, and the throughput is calculated as (Nb * Number of Slots * 60)/latency. As in <ref type="bibr" target="#b10">[11]</ref>, we have considered two noise levels: a first one that does not allow any other operations on the ciphertexts, and a second one we allow operations of multiplicative depth up to 7. Note that the (max) parenthesis in the Nb column recalls that for Trivium/Kreyvium, the homomorphic capacity decreases with the number of keystream bits generated, which therefore bounds the number of such bits before re-keying. We observe that for 80-bit security, our instances outperform the ones based on Trivium.</p><p>As for 128-bit security, the gap between our instances and Kreyvium is limited (despite the larger state of FLIP), and LowMC has better throughput in this context. Note also that our results correspond to the evaluation of the F function of FLIP (we verified that the time needed to generate the permutations only marginally affects the overall performances of homomorphic FLIP evaluations). We finally mention that these results should certainly not be viewed as strict comparisons, since obtained on different computers and for relatively new ciphers for which we have limited understanding of the security margins (especially for LowMC <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b20">21]</ref> and FLIP). So they should mainly be seen as an indication that besides their excellent features from the FHE capacity point-of-view, filter permutators inherently have good properties for efficient 2nd-generation FHE implementations as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions and Open Problems</head><p>In the context of our Homomorphic Encryption -Symmetric Encryption framework, where most of the computations are delegated to a server, we have designed a symmetric encryption scheme which fits the FHE settings, with as main goal to get the homomorphic evaluation of the symmetric decryption circuit as cheap as possible, with respect to the error growth. In particular the error growth obtained by our construction, only one level of multiplication considering the metric of third generation FHE, achieves the lowest bound we can get with a secure symmetric encryption scheme. The use of zero-noise operations as permutations enables us to combine the advantages of block ciphers and stream ciphers evaluation, namely constant noise on the one hand and starting low noise on the other hand. As a result, the homomorphic evaluation of filter permutators can be made insignificant relatively to a complete FHE framework.</p><p>The general construction of our encryption scheme -i.e. the filter permutator -and its FLIP instances are admittedly provocative. As a result, we believe an important contribution of this paper is to open a wide design space of symmetric constructions to investigate, ranging from the very efficient solutions we suggest to more classical stream ciphers such as filter generators. Such a design space leads to various interesting directions for further research. Overall, the main question raised by filter permutators is whether it is possible to build a secure symmetric encryption scheme with aggressively reduced algebraic degree. Such a question naturally relates to several more concrete problems. First, and probably most importantly, additional cryptanalysis is needed in view of the nonstandard design principles exploited in filter permutators. It typically includes algebraic attack taking advantage of the sparsity of their systems of equations, attacks exploiting the imbalances at the input of the filter, and the possibility to exploit chosen IVs to improve those attacks. Second, our analyses also raise interesting problems in the field of Boolean functions, e.g. the analysis of such functions with non-uniform input distributions and the investigation of the best fixed degree approximations of a Boolean function (which is needed in our study of higher-order correlation attacks). More directly related to the FLIP instances, it would also be interesting to refine our security analyses, with a stronger focus on the attacks data complexity, and to evaluate whether instances with smaller key register could be sufficiently secure. In case of new cryptanalysis results, the design tweaks we suggest in the paper are yet another interesting research path. Eventually, and from the FHE application point-of-view, optimizing the implementations of filter permutators, e.g. by taking advantage of parallel computing clusters that we did not exploit so far, would be useful in order to evaluate their applicability to real-world scenarii.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Homomorphic Encryption -Symmetric Encryption framework. H and S respectively refer to homomorphic and symmetric encryption schemes, for algorithms (e.g. H.KeyGen) or scheme components (e.g. sk S ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Filter permutator construction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 . 2 .</head><label>12</label><figDesc>The search of the polynomials g and h generating a system of D+E equations in D + E unknowns, where D = The search of linear relations which allow the suppression of the monomials of degree more than e. This step has a time complexity in O(D log 2 (D)). 3. The elimination of monomials of degree larger than e using the Berlekamp-Massey algorithm. This step has a time complexity in O(ED log(D)). 4. The resolution of the system. This step has a time complexity in O(E ω ).Given the FAI of F , the time complexity of this attack is in O(N FAI ), or more precisely O(D log 2 D +E 2 D +E ω ) (ignoring Step 1 which is trivial for our choice of F ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>). A Boolean function f with n variables is a function from F n 2 to F 2 . The set of all Boolean functions in n variables is denoted by B n .</figDesc><table /><note><p><p>Definition 2 (Walsh Transform). Let f ∈ B n a Boolean function. Its Walsh</p>Transform W f at a ∈ F n 2 is defined as:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Output pk H and sk H the public and secret keys of the scheme. -H.Enc(m, pk H ). From the plaintext m ∈ M and the public key, output a ciphertext c ∈ C. -H.Dec(c, sk H ). From the ciphertext c ∈ C and the secret key, output m</figDesc><table><row><cell>-H.KeyGen(1 λ ).</cell></row><row><cell>). Let M be the plain-</cell></row><row><cell>text space, C the ciphertext space and λ the security parameter. A homomorphic</cell></row><row><cell>encryption scheme consists of four algorithms:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>(R)LWE parameters used in our applications.</figDesc><table><row><cell cols="2">Security λ n</cell><cell>log q</cell></row><row><cell>80</cell><cell cols="2">256 80</cell></row><row><cell>128</cell><cell cols="2">512 120</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>= max 1≤i≤k (Norm(m i )) is a constant which depends on the plaintexts, and C comb = H.Comb(y, σ, c, k) as error components following a subgaussian distribution of parameter O(σ comb ). comb Quantity). Let C 1 , • • • , C k be k ciphertexts of a GSW based Homomorphic Encryption scheme with same error parameter σ and C comb = H.Comb</figDesc><table><row><cell cols="2">Definition 17 (Homomorphic Comb H.Comb). Let C 1 , • • • , C k be k cipher-</cell></row><row><cell cols="2">texts of a GSW based Homomorphic Encryption scheme with error coefficients</cell></row><row><cell cols="2">from independent distributions with same subgaussian parameter σ. We define</cell></row><row><cell cols="2">H.Comb(y, σ, c, k) = H.Mul(C 1 , • • • , C k , G) where:</cell></row><row><cell>-y =</cell><cell>√ Nγ is a constant depending on the ring,</cell></row><row><cell cols="2">-c Lemma 12 (σ</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 .</head><label>3</label><figDesc>Experimental error growth of Ring-GSW. Fresh, H.Add, H.Mul and H.Eval(FLIP) respectively stands for the noise e measure after a fresh homomorphic encryption, the homomorphic addition of two fresh ciphertexts, the homomorphic multiplication of two fresh ciphertexts and the homomorphic evaluation of FLIP on fresh ciphertexts. The first value is the log of the error e inside the corresponding ciphertexts and the percentage represents the proportion of the noise with respect to the capacity of decryption (i.e. -2).</figDesc><table><row><cell cols="2">Ring (n, ) FLIP</cell><cell>Fresh</cell><cell>H.Add</cell><cell>H.Mul</cell><cell>H.Eval(FLIP)</cell></row><row><cell></cell><cell></cell><cell>log e %</cell><cell>log e %</cell><cell>log e %</cell><cell>log e %</cell></row><row><cell>256 80</cell><cell cols="5">(42, 128, 8 Δ 9 ) 13, 07 17 % 13, 96 18 % 19, 82 25 % 24, 71 31 %</cell></row><row><cell>512 120</cell><cell>(82, 224,</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>8 Δ 16 ) 14, 68 12 % 15, 14 13 % 23, 27 20 % 28, 77 24 %</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 .</head><label>4</label><figDesc>Multiplicative depth of different symmetric ciphers.</figDesc><table><row><cell>Algorithm</cell><cell cols="3">Reference Multiplicative depth Security</cell></row><row><cell>SIMON-32/64</cell><cell>[42]</cell><cell>32</cell><cell>64</cell></row><row><cell>Trivium-12</cell><cell>[11]</cell><cell>12</cell><cell>80</cell></row><row><cell>Trivium-13</cell><cell>[11]</cell><cell>13</cell><cell>80</cell></row><row><cell>LowMc-80</cell><cell>[1]</cell><cell>11</cell><cell>80</cell></row><row><cell cols="3">FLIP(42, 128, 8 Δ 9 ) This work log 9 = 4</cell><cell>80</cell></row><row><cell>AES-128</cell><cell>[15, 31]</cell><cell>40</cell><cell>128</cell></row><row><cell>SIMON-64/128</cell><cell>[42]</cell><cell>44</cell><cell>128</cell></row><row><cell>Prince</cell><cell>[22]</cell><cell>24</cell><cell>128</cell></row><row><cell>Kreyvium-12</cell><cell>[11]</cell><cell>12</cell><cell>128</cell></row><row><cell>Kreyvium-13</cell><cell>[11]</cell><cell>13</cell><cell>128</cell></row><row><cell>LowMc-128</cell><cell>[1]</cell><cell>12</cell><cell>128</cell></row><row><cell>FLIP(82, 224,</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>8 Δ 16 ) This work log 16 = 4 128</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5 .</head><label>5</label><figDesc>Timings of the homomorphic evaluation of several instances of the Boolean function of FLIP using HElib on an Intel Core i7-3770. The other results are taken from<ref type="bibr" target="#b10">[11]</ref>. L and Number of Slots are HElib parameters which stand respectively for the level of noise and the number of bits packed in one ciphertext. (Nb * Number of Slots) corresponds to the number of decrypted bits.</figDesc><table><row><cell>Algorithm</cell><cell cols="2">Security Nb</cell><cell cols="3">L Number Latency (sec) Throughput</cell></row><row><cell></cell><cell></cell><cell></cell><cell>of Slots</cell><cell></cell><cell>(bits/min)</cell></row><row><cell>Trivium-12</cell><cell>80</cell><cell cols="2">45 (max) 12 600</cell><cell>1417.4</cell><cell>1143.0</cell></row><row><cell></cell><cell>80</cell><cell cols="2">45 (max) 19 720</cell><cell>4420.3</cell><cell>439.8</cell></row><row><cell>Trivium-13</cell><cell>80</cell><cell cols="2">136 (max) 13 600</cell><cell>3650.3</cell><cell>1341.3</cell></row><row><cell></cell><cell>80</cell><cell cols="2">136 (max) 20 720</cell><cell>11379.7</cell><cell>516.3</cell></row><row><cell>Kreyvium-12</cell><cell>128</cell><cell cols="2">42 12 504</cell><cell>1715.0</cell><cell>740.5</cell></row><row><cell></cell><cell>128</cell><cell cols="2">42 (max) 19 756</cell><cell>4956.0</cell><cell>384.4</cell></row><row><cell>Kreyvium-13</cell><cell>128</cell><cell cols="2">124 (max) 13 682</cell><cell>3987.2</cell><cell>1272.6</cell></row><row><cell></cell><cell>128</cell><cell cols="2">124 (max) 20 420</cell><cell>12450.8</cell><cell>286.8</cell></row><row><cell>LowMC-128</cell><cell cols="2">? ≤ 128 256</cell><cell>13 682</cell><cell>3368.8</cell><cell>3109.6</cell></row><row><cell></cell><cell cols="2">? ≤ 128 256</cell><cell>20 480</cell><cell>9977.1</cell><cell>739.0</cell></row><row><cell cols="2">FLIP(42, 128, 8 Δ 9 ) 80</cell><cell>1</cell><cell>5 378</cell><cell>4.72</cell><cell>4805.08</cell></row><row><cell></cell><cell>80</cell><cell>1</cell><cell>12 600</cell><cell>17.39</cell><cell>2070.16</cell></row><row><cell cols="2">FLIP(82, 224, 8 Δ 16 ) 128</cell><cell>1</cell><cell>6 630</cell><cell>14.53</cell><cell>2601.51</cell></row><row><cell></cell><cell>128</cell><cell>1</cell><cell>13 720</cell><cell>102.51</cell><cell>421.42</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In the remaining of the paper, and when not specified otherwise, the term FHE will also be used for related schemes such as Leveled HE, SomeWhat HE, Scalable HE, etc..</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We are highly grateful to Sébastien Duval, Virginie Lallemand and Yann Rotella for sharing their ideas about guess and determine attacks before the publication of this paper, which allowed us to modify the instances of FLIP accordingly. We are also indebted to Anne Canteaut for numerous useful suggestions about the design of filter permutators, and for putting forward some important open problems they raise. Finally, we would like to thank Thierry Berger, Sergiu Carpov, Rafaël Delpino, Malika Izabachene, Nicky Mouha, Thomas Prest and Renaud Sirdey for their feedback about early (and less early) versions of this paper. This work was funded in parts by the H2020 ICT COST CryptoAction, by the H2020 ICT Project SAFECrypto, by the H2020 ERC Staring Grant CRASH and by the INNOVIRIS SCAUT project. François-Xavier Standaert is a research associate of the Belgian Fund for Scientific Research (F.R.S.-FNRS).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Ciphers for MPC and FHE</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Albrecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tiessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zohner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2015-34th Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<meeting><address><addrLine>Sofia, Bulgaria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">April 26-30, 2015. 2015</date>
			<biblScope unit="page" from="430" to="454" />
		</imprint>
	</monogr>
	<note>Proceedings, Part I</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Faster bootstrapping with polynomial error</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alperin-Sheriff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2014 -34th Annual Cryptology Conference</title>
		<meeting><address><addrLine>Santa Barbara, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">August 17-21, 2014. 2014</date>
			<biblScope unit="page" from="297" to="314" />
		</imprint>
	</monogr>
	<note>Proceedings, Part I</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Searching for the optimum correlation attack</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption: Second International Workshop</title>
		<meeting><address><addrLine>Leuven, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-12-16">14-16 December 1994. 1994</date>
			<biblScope unit="page" from="137" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient computation of algebraic immunity for algebraic and fast algebraic attacks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Armknecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gaborit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Künzli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ruatta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2006</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4004</biblScope>
			<biblScope unit="page" from="147" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Forward-security in private-key cryptography</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Yee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">35</biblScope>
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Noise-tolerant learning, the parity problem, and the statistical query model</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wasserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="506" to="519" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">How to generate cryptographically strong sequences of pseudo random bits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="850" to="864" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Zero-sum distinguishers for iterated permutations and application to keccak-f and hamsi-256</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Canteaut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Selected Areas in Cryptography</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Biryukov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Gong</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Stinson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6544</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">(leveled) fully homomorphic encryption without bootstrapping</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Innovations in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="page" from="309" to="325" />
			<date type="published" when="2012-01-08">2012. January 8-10, 2012. 2012</date>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Lattice-based FHE as secure as PKE</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Innovations in Theoretical Computer Science, ITCS 2014</title>
		<meeting><address><addrLine>Princeton, NJ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">January 12-14, 2014. 2014</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Stream ciphers: A practical solution for efficient homomorphic-ciphertext</title>
		<author>
			<persName><forename type="first">A</forename><surname>Canteaut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Carpov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fontaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naya-Plasencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sirdey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">113</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
		<title level="m">Boolean Models and Methods in Mathematics, Computer Science, and Engineering, chap. Boolean Functions for Cryptography and Error Correcting Codes</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="257" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Enhanced Boolean functions suitable for the filter model of pseudo-random generator</title>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Des. Codes Crypt</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="571" to="587" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">BKZ 2.0: Better lattice security estimates</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2011</title>
		<editor>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">7073</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scale-invariant fully homomorphic encryption over the integers</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tibouchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2014</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8383</biblScope>
			<biblScope unit="page" from="311" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Higher order correlation attacks, XL algorithm and cryptanalysis of toyocrypt</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">T</forename><surname>Courtois</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICISC 2002</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Lim</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2587</biblScope>
			<biblScope unit="page" from="182" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast algebraic attacks on stream ciphers with linear feedback</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">T</forename><surname>Courtois</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2003</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="176" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Algebraic attacks on stream ciphers with linear feedback</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">T</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2003</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="345" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Optimized interpolation attacks on lowmc</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">418</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Cube attacks on tweakable black box polynomials</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="278" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Higher-order cryptanalysis of lowmc</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dobraunig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Eichlseder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mendel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">407</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Toward practical homomorphic evaluation of block ciphers using prince</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Doröz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shahverdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FC 2014 Workshops</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Böhme</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Brenner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Moore</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Smith</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8438</biblScope>
			<biblScope unit="page" from="208" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Lattice signatures and bimodal gaussians</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ducas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Durmus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part I</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8042</biblScope>
			<biblScope unit="page" from="40" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">FHEW: Bootstrapping homomorphic encryption in less than a second</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ducas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EURO-CRYPT 2015</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="617" to="640" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cryptanalysis of the FLIP family of stream ciphers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Duval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lallemand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Rotella</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">271</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
	<note>Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Somewhat practical fully homomorphic encryption. IACR Cryptology ePrint Archive</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="page">144</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A new efficient algorithm for computing grobner bases (f4)</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Faugère</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Pure Appl. Algebra</title>
		<imprint>
			<biblScope unit="volume">139</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="61" to="88" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Algebraic immunity of S-boxes and augmented functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Fischer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4593</biblScope>
			<biblScope unit="page" from="366" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Predicting lattice reduction</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2008</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="31" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption using ideal lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 41st Annual ACM Symposium on Theory of Computing<address><addrLine>Bethesda, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-05-31">2009. May 31 -June 2, 2009. 2009</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Homomorphic evaluation of the AES circuit</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2012</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7417</biblScope>
			<biblScope unit="page" from="850" to="867" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Homomorphic encryption from learning with errors: conceptually-simpler, asymptotically-faster, attribute-based</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2013</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8042</biblScope>
			<biblScope unit="page" from="75" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Block ciphers that are easier to mask: How far can we go?</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gérard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Grosso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naya-Plasencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES 2013</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Bertoni</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8086</biblScope>
			<biblScope unit="page" from="383" to="399" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">LS-Designs: Bitslice encryption for efficient masked software implementations</title>
		<author>
			<persName><forename type="first">V</forename><surname>Grosso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Leurent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Varici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2014</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Cid</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">8540</biblScope>
			<biblScope unit="page" from="18" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Algorithms in HElib</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2014, Part I</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8616</biblScope>
			<biblScope unit="page" from="554" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Packing messages and optimizing bootstrapping in GSW-FHE</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hiromasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2015</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">9020</biblScope>
			<biblScope unit="page" from="699" to="715" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Introduction to Modern Cryptography</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Chapman and Hall/CRC Press</publisher>
			<pubPlace>Boca Raton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">SHIELD: Scalable homomorphic implementation of encrypted data-classifiers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khedr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Gulak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="volume">838</biblScope>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Conditional differential cryptanalysis of NLFSR-based cryptosystems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Knellwolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naya-Plasencia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2010</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6477</biblScope>
			<biblScope unit="page" from="130" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Integral cryptanalysis</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2002</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Daemen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2365</biblScope>
			<biblScope unit="page" from="112" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">The Art of Computer Programming. Seminumerical Algorithms</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A comparison of the homomorphic encryption schemes FV and YASHE</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AFRICACRYPT 2014</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Vergnaud</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8469</biblScope>
			<biblScope unit="page" from="318" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Better key sizes (and attacks) for lwe-based encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lindner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology -CT-RSA 2011</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6558</biblScope>
			<biblScope unit="page" from="319" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Tweakable block ciphers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="588" to="613" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">How to construct pseudorandom permutations from pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">On ideal lattices and learning with errors over rings</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Fast correlation attacks: Methods and countermeasures</title>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6733</biblScope>
			<biblScope unit="page" from="55" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Fast correlation attacks on stream ciphers</title>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Staffelbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1988</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Günther</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">330</biblScope>
			<biblScope unit="page" from="301" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Trapdoors for lattices: simpler, tighter, faster, smaller</title>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2012</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7237</biblScope>
			<biblScope unit="page" from="700" to="718" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Lattice-based cryptography</title>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Can homomorphic encryption be practical?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd ACM Cloud Computing Security Workshop, CCSW 2011</title>
		<meeting>the 3rd ACM Cloud Computing Security Workshop, CCSW 2011<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-10-21">October 21, 2011. 2011</date>
			<biblScope unit="page" from="113" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">PICARO -A block cipher allowing efficient higherorder side-channel resistance</title>
		<author>
			<persName><forename type="first">G</forename><surname>Piret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applied Cryptography and Network Security</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Bao</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Samarati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Zhou</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7341</biblScope>
			<biblScope unit="page" from="311" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, and cryptography</title>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 37th Annual ACM Symposium on Theory of Computing<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">May 22-24, 2005. 2005</date>
			<biblScope unit="page" from="84" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Estimating the security of lattice-based cryptosystems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rückert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">137</biblScope>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Lattice basis reduction: Improved practical algorithms and solving subset sum problems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Schnorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Euchner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Program</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="181" to="199" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Decrypting a class of stream ciphers using ciphertext only</title>
		<author>
			<persName><forename type="first">T</forename><surname>Siegenthaler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="85" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Leakage-resilient symmetric cryptography under empirically verifiable assumptions</title>
		<author>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part I</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8042</biblScope>
			<biblScope unit="page" from="335" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Introduction to the non-asymptotic analysis of random matrices</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vershynin</surname></persName>
		</author>
		<idno>CoRR abs/1011.3027</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Solving sparse linear equations over finite fields</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Wiedemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theor</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="54" to="62" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
