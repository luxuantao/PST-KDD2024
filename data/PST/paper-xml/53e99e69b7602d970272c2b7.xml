<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MODEL WITH RELATION-VALUED ATTRIBUTES</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">H.-J</forename><surname>Schek</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Lm</forename><forename type="middle">H</forename><surname>Scholl</surname></persName>
						</author>
						<author>
							<persName><surname>Introdcctios</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Technical University of Darmstadt</orgName>
								<address>
									<addrLine>Alexanderstrasse 24</addrLine>
									<postCode>D-6100</postCode>
									<settlement>Darmstadt</settlement>
									<country>West Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Relarion-VaOred Arrriblrtr.7</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">MODEL WITH RELATION-VALUED ATTRIBUTES</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">200917EA8CBBF4BF02A56A0883F16F61</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Motivated by new applications of database systems we introduce relations which may have relation-valued attributes and propose a related algebra. Formal definitions for this extended relational model can be given by applying usual notions recursively. The main problem considered in this paper is the formal definition of an appropriate relational algebra for these non-first-normal-form relations. We allow the application of the basic relational operators to any relation-valued attribute u;ithin a relation. This leads to a (hierarchically) nested relational algebra.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The First Normal Form (INF) condition of the relational model of data!11 is widely accepted as a reasonable restriction for the relations to be considered further. In [2, p. 2391 we find: "The only hard requirement is that relations be in at least first normal form". Nevertheless we have practical and theoreticai reasons for investigations on relations which may have relations as attribute values which, in turn, may have relations as attributes values and so on.</p><p>On the practical side, we try to get a better solid basis for new applications of data base management systems (DBMS). Examples are textual data. engineering data or images; that is, objects which usually have not been considered as data to be stored in currently available DBMS. In this situation, preprocessor solutions are the usual way to overcome the difficulties. A DBIMS is then used as a byte string storage manager with the responsibility of the preprocessor to take care of the inte~retation of the byte string by imposing a data structure on it. The consequence is that the preprocessor becomes responsible for many primitive functions such as updating, indexing, or integrity control functions which are normally meant to be managed by the DBIMS.</p><p>We believe that some of the bottlenecks can be avoided by dropping the INF and allowing relationvalued attributes. User or application specific data structures and operations, e.g. retrieving elements of the k-th row of a huge matrix should then be better supported by this model than by the naive storage of the large matrix as a long byte string. Furthermore, already for conventional applicatidns of DBMS we observe that repeating groups or sets occur often in the description of real world objects. Disallowing those as attributes (in the sense of the <ref type="bibr">Entity~Relationship-~fodel)</ref> leads to an artiticiaf separation into several (entity) relations.</p><p>Constructs such as weak entities(3f or referential in-tegrity contraints must be introduced to maintain integrity. From a theoretical point of view we have been motivated by the question whether Eve are able to keep the main formalism: e.g. according to <ref type="bibr">[4]</ref> for relations with relation-valued attributes in such a way that the INF case is a degeneration.</p><p>Several authors already investigated "Non-First-Normal-Form" relations, shortly called NF' relations in [S, 61. Aspects mainly of the design theory with unnormalized relations and transformations of dependencies are contained in <ref type="bibr">[7-l I]</ref>.</p><p>A discussion on the role of the new algebra operators nest and unnest in their interactions with the usual ones (e.g. whether a projection and a nest on a relation can be computed, or whether a specific NF' relation can be reached by a sequence of nests and unnests starting with a 1NF relation) is contained in [ 12, 91. An extension of the selection operation for relation-valued attributes is contained in [l31.</p><p>A general formal description of hierarchical data structures has been given recently by <ref type="bibr">[14]</ref>. The application of hierarchically structured data for the user interface called "forms" and the conversion problem between data models is described in <ref type="bibr">[15-191.</ref> The introduction of so-called complex objects in <ref type="bibr">[20]</ref> for engineering applications is a first step into the direction of allowing unnormalized relations. The effect of "quotient relations"[21] can also be described in terms of the NF' model. A proposal for generally allowing recursive data models is described in <ref type="bibr">[22]</ref>.</p><p>An interesting connection exists also to the "compacted relations" 1231 for hardware search faciiities. The transformation from INF relational expressions at a user interface into equivalent expressions for the internal compacted relations can be described by the NF' relational algebra. In fact, our approach is to describe all data at the three levels (external, conceptual and internal) according to <ref type="bibr">[24]</ref>, especially including internal data structures like access paths as NF* relations. As we then have a single formal model for the conceptual and internal schema we get the mappings between these by NF' relational algebra expressions. This aspect is described in f6].</p><p>In this paper, we restrict ourselves to a foundation of the NF' relational model. We give a precise definition of the NF' relational data structure and of the related NF' relational algebra. As far as known to the authors, no satisfying definition of a complete NF' relational algebra has been proposed until now.</p><p>The report is structured in the following way: We give a formal description of an NF' relation and its several components in section 2 where we extend the usual notions by introducing recursion to reveal the nested structure. In section 3, we propose an NF' relational algebra, for which we give recursive definitions too. First, we use our formalism to define the usual INF algebra precisely and in a second step we extend selection and projection with the objective to allow algebra expressions also within the selection formula or within the projection list in a nested manner. Finally, we show that the nested selection can be expressed by a suitable projection-selection expression. This serves as a first example for equivalent NF' algebra expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATIOXS WITH RELATION-VALUED ATTRIBUTES</head><p>We try to preserve the usual notions of schema, value and attributes of a relation, etc. The formal definitions which follow will contain the INF case as a degeneration.</p><p>At a first gfance the reader might be astonished at the formalism introduced for more or less common facts. But in case of NF' relations, we cannot dispense with formal definitions of basic concepts like schema, value, attributes and tuples of relations, because otherwise we could not define the effects of relational algebra operators formally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">I Tile NF' relational data structure</head><p>In the 1NF case we assume that 6 sets Di, i = I, 2, . . . , 6 are given which serve as "basic domains". The elements from Di will not be regarded as decomposable by the DBMS. For our purpose of defTning a relational algebra it is sufficient to introduce one basic domain R : = Di U +--U Da. (This setting simplifies the discussion without loosing generality. The restriction of attribute values to certain subsets of D (e.g. o,) can be regarded as a special kind of integrity constraints which are not of interest in this paper.) We further assume a given set NAME the elements of which will be used for naming purposes.</p><p>We denote with P(S) the powerset of a set S and with .Si x .S2 the Cartesian product of two sets Si and Sz, 0 is the empty set. For the elements of a Cartesian product we write f.,*), that is, for s E .S, x .Y: we can write s = {s,, sz), with sl E S1 and s: E S:, (3) and (\d) denote the existential and uni-versa1 quantifiers respectively.</p><p>The following definitions (1, 2, 3) are preparations for defining NF' relations.</p><p>Definition 1 "Complex Domains C". The set C of "complex domains" is defined by (I) D E c (2) c,, c:, . . . , Cr E c j P(C, x C2 x ... x Ca) E C (3) nothing else is in C rl Definition 1 simply allows powersets of Canesian products of the (basic or complex) domains to be also a complex domain.</p><p>Definition :! " Schema S and Description B". The set of allowed schemata S and desc~ptions B is defined by ( <ref type="formula" target="#formula_8">1</ref>)</p><formula xml:id="formula_0">N E NAME 3 {N. 0) E B (2) bi = (Vi, St) E B, i = 1, . . . , k, Ni Z Njfor i f j 3 {b,, b,, . . , bk} E S (3) N E NAME A S E S 3 (N, S) E B</formula><p>Cl Obviously, the intention of definition 2 is to have a pair as a description consisting of a name as first component and a schema as second. On the other hand, a schema is a ser of descriptions, especially a schema might be the empty set. Further, the names which appear in the descriptions bi of a single schema must be unique.</p><p>As we assume one basic domain D only (see above), the domain of a given description is uniquely determined by its schema, as we see from the following definition. u In the usual terminology v is called "instance" or "value" of the schema defined by b. We do not consider further restrictions for 21, e.g. satisfaction of integrity constraints, throughout this paper because this aspect is not relevant for the definitions given. Furtheron we use the following notational conventions:</p><p>For the two components of a relation R we use (1) des(R) for the first component of R ( <ref type="formula">2</ref> of the given relation R. As we will often need the schema of a relation to describe its transformation by algebraic operations to be defined in the next chapter, we extend the function sch to be directly applicable to relations by the following definition:</p><p>(5) sch(R) : = sch(des(R)) An element y E sch(R) is called an "attribute description" and its first component nam(y) is called an "attribute" of relation R. This corresponds to the usual terminology. As the schema of a relation is the set of attribute descriptions and not only the set of attributes (that is, names) as in the flat relational model we introduce attr(R) to be the set of attributes according to (6) attr(R) : = attr(des(R)) = {N 1 (3) y E sch(R) A N = nam(r)} Definition 2 requires that the elements of a single schema have different names (that is, for any given schema S E S and 6, E S, b2 E S, b, # bz we have nam(b,) f nam(bJ). Therefore we use the function &amp;:attr(R) --$ sch(R) which is inverse to nam according to (7) A E attr(R) 3</p><p>(3) y E sch(R) A d,(A) = y A nam(_v) = A In the following we will omit the subscript "R" of the function &amp; when the meaning is clear from the context. An element of a relation value is called a tuple; that is, (8) R is a relation j I E val(R) is a tuple of R We know that val(R) E P( X dam(y)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>yEsch(Rl</head><p>Therefore a tuple has as many components as the cardinality of sch(R). If sch(R) = {yl, yz, . . . , yl,} and if the order is fixed for the moment, we can state f = (f,,, fy2, . . , t+) with tyi E dom(yi). AS the following lemma shows, we can adopt the setof-mapping notion of a relation: --Lemma 2 indicates that an attribute value together with its attribute description may again be a (1NF or NF') relation supposed it has a non-empty schema. If the schema of an attribute description is empty, the attribute value is from the atomic domain D (see definition 3). Therefore we can characterize a INF relation as a special case of a relation.</p><p>Lemmcz 3:</p><formula xml:id="formula_1">A relation R is a INF relation e (V) y E sch(R): sch(y) = 0 A relation R is a "real" NF' relation ts (3) ?: E sch(R) A sch(_v) 7 0 0</formula><p>The following consequences can be drawn from these definitions.</p><p>1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.2</head><p>We have introduced the notion of "attribute description" which was not necessary in the flat model (where the description degenerates to (attribute, 0)). On the other side, we use this format also for the description of a relation in the form (relname, schema), where now the second component schema is important, also for the 1NF case. The notion of the attribute value in a tuple is not changed. As an attribute value together with its attribute description forms a relation which, in turn, may have attributes which are relation-valued we are able to apply the definitions and notation introduced so far in a nested manner. Especially, if r = (d(A), f(A)) is a relation consisting of the description d(A) and the value r(A) of an attribute A of a relation R and if a E attr(r) is an attribute and 7 E val(r) is a tuple of r we have T(a) as an attribute value from dom(d(a)). The operations of the NF' algebra to be defined in the next chapter may be applied in a nested manner; that is, to a given relation R but also to relations which are constructed from its relation-valued attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Representations</head><p>of NF' relations 2.2.1 Linearform of the schema. We extend the usual linear form R(A,, AZ, . , A,,) for a schema of a INF relation R with attributes A,, , A,, by repeating the linear form for RV-attributes. In the example R (Ai (Ai17 A,:), AZ* A3 (AZ,, A32 (A~zI, Aj?l), A33))</p><p>we have AI! as AV-attribute and two RV-attributes A, and A3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Example applications of the formal definitions</head><p>The relation DEP'T of Fig. <ref type="figure">3</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">General remarks</head><p>Since NF' relations are sets, the set operations union (u) and difference (-) are applicable without any changes to the NF' case. The selection (01~1 will select whofe tuples based on the predicate F to be applied on a tuple. The projection (n) will determine specQ?c components of all tuples of a relation and eliminate duplicates. In that aspect no change is introduced compared to the 1NF case. Also the definition of the Cartesian product (X) is unchanged.</p><p>The only new operations to be introduced are "nest" (u) and "unnest" (CL). They are used to transform between 1NF and NF' relations and vice versa. Therefore, as the 1NF relational algebra has j independent operations (U. -. X, u. n) we will now have 7 operations (U. -, X, cr. hi. v, I*) in the NF' case. This is not exciting and, in fact, would not allow an effective manipulation of NF' relations.</p><p>However, since attribute values may be relations whose attribute values again may be relations, etc.. a nested application of the basic operations mentioned above leads to a high level of expressiveness. In order to formally define nested expressions we will first define the seven "building blocks" in such a way that we are able to extend some of them to become nested in a second step.</p><p>Generally, we use recursive definitions for the algebraic operators. Any operation applied to a (pair of) relation(s) yields a relation, therefore we can build algebraic expressions by recursively applying algebraic operations. Usually these kind of expressions are called "nested" expressions. However, in our case, relation-valued attributes_allow another type of recursive application of the algebra (now within the square brackets "[. . .I" as opposed to the parentheses "(. .I" as usual). In this paper we use the terminology of expressions versus operations for the first kind of recursion and nested algebra for the second one.</p><p>It is also important to inspect the structural effects of our algebra more carefully. Usually, in the 1NF case, the schema transformations caused by several algebraic operators are not described explicitly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Schenza preserving opernlions</head><p>In the INF case there are three out of the live basic operations that do not affect the relation schema: the two binary set operations union and difference and the unary relational selection. If F is a selection-atom, then two subcases are regarded:</p><formula xml:id="formula_2">(i) F is SAI-type; that is, F = A cop C if A E attr(R) and C E dom(d(A)). then val(a[F](R)) : = {f 1 t E val(R) A f(A) cop C} (ii) F is SA2-type; that is, F = A, cop AZ if A,, A: E attr(R), then val(u[F](R)) := {r 1 I E val(R) A [(A,) cop GA?)} If F is (nor F'), then val(u[F](R) := val(R -u[F'](R)) If F is (F, A F?), then val(u[F](R)) : = val(u[F,l(R) n a[F&amp;R)) If F is (Fl V f?). then val(u[F](R)) := val(u[F,](R) U u[F,](R))</formula><p>EI As in the 1NF algebra a selection with formula F selects a subset of tuples in val(R). A tuple f is in the result relation, iff F evaluates to true if attributes in F are substituted by the corresponding values of t. The only changes introduced are set comparisons and constant sets in connection with RV-attributes. We will extend the definition (a) of selection atoms in section 3.4.1 but keep the de6 nitions (b), (c), (d).</p><p>As in the 1NF case we do not state context conditions explicitely here and in the following, e.g. for "Al cop A2" in (2.a.ii). We assume that dom(d(A1)) and dom(d(A2)) are comparable w.r.t. cop and thus regard the selection as being undefined for noncomparable domains. As a first example of a selection with set comparisons we could be interested in the department the administrational employee with the number 121 and job description "library" works in:</p><formula xml:id="formula_3">Ql : = u[AE &gt; {(121, library)}] (DEPT)</formula><p>The result Ql contains the whofe tuple of depanment 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Schema transforming operations</head><p>1NF algebra has two basic operators transforming relational schemata: Cartesian product and projection. NF' algebra introduces the two additional operators nest and unnest. 3.3.2 Projection. The definition of the projection for 1NF relations can be applied to NF* relations without change. But as attribute values in NF' relations may be relations in turn, this form of projection is not powerful enough for RV-attributes, since we can take an attribute vafue as a whole or not at ah. In order to prepare for a major extension of the projection (section 3.4.2) we give a formal definition of the common projection in a modular, unusual way and we introduce a renaming facility.</p><p>Definition 12 "projection list". If we'consider a projection n <ref type="bibr">[L]</ref>(R) we call L the projection list, which has the following form: (1)</p><p>(2)</p><p>The projection list has only one element, that is, L = Ai: 8. If A, E attr(R), then (i) sch(sr <ref type="bibr">[L]</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SCh(T[Ai:B](R)) (ii) val(p[L]fR)) : = {t 1 (3). r E val(R) A r(L") E vaUn[L'l(R))</head><p>This definition seems too complicated. But we wilI later be able to replace simple elements in the projection list by whole relational expressions (section 3.4.2) by extending only part (1) of the above definition.</p><p>The new names for projected attributes are a mean of renaming. This will be necessary when the complex NF' projections are considered. If renaming is not necessary, we allow *'A," as an abbreviation for "A,:Aij" in the projection list. From this definition it can easily be seen, that the nest operator takes a set of attributes and forms a new RV-att~bute out of these (see Fig. <ref type="figure">4</ref>).</p><p>The schema transfo~ation performed by nesting can be described by the schema tree: a new node is inserted as a direct descendent of the root. A set of formerly direct descendents of the root become descendents of this new node.</p><p>Next the unnest operator on R with respect to , A,_, , A,:A;] (R) 0</p><p>The schema transformation of unnest can be described as eliminating a direct descendent of the root of the schema tree and connecting the direct descendents of the removed node directly to the root. If the node to be removed has no children, then no transformation is performed except renaming.</p><p>As shown in [9] the unnest operation is inverse to the nest operation. However, first unnesting can not generally be reversed by nesting (also see [ 121).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Nested application of algebraic opera&amp;s</head><p>The idea of the nested relational algebra is to apply some of the operators defined so far also to (RV-) attributes. As attributes occur in selection atoms and projection lists, selection and projection become the entry points for the nested algebra. The nested application of algebraic operators can easily be defined using recursive definitions for the value function. The termination of this recursion is guaranteed by the fact that each recursive call of the value function corresponds to descending one level in the schema tree. Because any schema tree has a finite depth the recursion ends when the leaf nodes are reached.</p><p>A side remark to the definitions we have chosen is in place here: we do not assume that every NF2 relation can be obtained by a sequence of nest operations. Therefore, we cannot define the nested relational algebra by unnesting the involved relations into the INF form, applying some basic algebraic expressions and finally converting the result back to NF' relations. Furthermore, we would arrive at the problem of null values generated by unnesting empty sets. These problems are treated in <ref type="bibr">[25]</ref>. For our definitions we decided to use the "direct NF' approach" presented below.</p><p>3.4.1 Extended selection. Any selection which does not specify the value of an attribute as a whole could not be formulated in selection atoms until now. In order to allow conditions for single tuples in an RV-attribute we apply selections and projections to attributes in selection atoms.</p><p>Obviously, also other operations could be useful within selection formulae. However, as will be seen later (section 3.5.2), the extended selection can be defined via simple selections and extended projection. Therefore we only give explicit definitions for CT -a and u -hi: Definition 16 "extended selection atoms". The two types of selection atoms from definition 8 are extended by the following two classes which are only applicable to RV-attributes.</p><p>Type SA3: (u -u) "attribute" may be substituted by "a[F'] (attribute)" in SAl and SA2 Type SA4: (a -n) "attribute" may be substituted by "T~ <ref type="bibr">[L]</ref> (attribute)" in SAl and SA2 c! On the syntactical level algebraic operations are applied to attributes (that is, names) instead of relations within the nested formulations. Therefore we must define which relations have to be taken for the semantical interpretation.</p><p>We have to add two subcases to the definition of the value of a selection given in definition IO, (2a). According to the nested structure the value of au -u-or u -T-operation is defined via recursive calls of the value function val.</p><p>Definition 17 "extended selection". Definition 10 ( <ref type="formula" target="#formula_8">1</ref>) and (2b-d) remain unchanged. Two subcases (iii) and (iv) are added to (2a): (iii) F is SA3-type (a -u); that is, F contains a selection applied to an RV-attribute: at any place in (i) and (ii) substitute "t(A)" and "r(Ai)" by "val(a[F'] ((d(A), t(A))))" and "val(u[F'] ((d(Ai), [(Ai))))" respectively. (iv) F is SA4-type (u -7~); that is, F contains a projection applied to an RV-attribute: at any place in (i) and (ii) substitute "r(A)" and "[(Ai)" by "val(a <ref type="bibr">[L]</ref> ((d(A), t(A))))" and "val(v <ref type="bibr">[L] ((d(Ai)</ref>, f(Ai))))" respectively. Cl In order to keep the definitions readable we did not give the explicit definitions for all of the possible operations combining SAl-and SAl-type with SA3-and SA4-type selections. One sample explicit definition, a u -u-operation for a SAl-type formula, is added:</p><p>(</p><formula xml:id="formula_4">1) sch(a[u[F'] (A) cop C] (R)) : = sch(R) (2) val(a[u[F'] (A) cop C] (R) : = {t 1 t E val(R) A Wa[F'l ((d(A). r(A)))) cop Cl</formula><p>Notice that operations are applied to attribute values in the selection formula to determine the selected tuples but nevertheless u -a-and u -zoperations select \vhole tuples out of val(R)!</p><p>As an example for a u -u-type operation consider Q2 asking for research departments employing translators:</p><formula xml:id="formula_5">Q2 : = u[DN = research A u[AJD = translation] (AE) f 01 (DEPT)</formula><p>The use of u -r is illustrated in the following query 43 selecting departments having at least two tech- In either case, Q:! and 43, the department 1 is the only result tuple.</p><formula xml:id="formula_6">I-t-i H.-J.</formula><p>It should be noted here that by means of CJ -u and comparisons "iQ*' w can easily forrnu&amp;e existential quantifications.</p><p>AIso universal quantification can be formulated as shown by the following query Q3 asking for departments whose administrational staff consists of secretaries only:</p><formula xml:id="formula_7">Q3 : = ~[r;[.4JDj [AE) = {secretary]] (DEPT)</formula><p>In our example, however, the result would be an empty relation with the schema sch(DEPT).</p><p>Using an extended notion of constants (cf. section 3.4.3) enables us to formulate more saphisticated conditions in the universal quantification, e.g. the relationaf division operator.</p><p>3.42 Exrended projecfiun. As the projection is a schema transforming operation involving specification of attributes we decided to introduce major extensions to this operator as a means of manipulating a complex NF' schema. It would be unsatisfactory iP one could only take an RV-attribute as a whole or nothing of it by projections. Parts of these subrelations should be selectable. We can distinguish two cases: not all tuples (G -~1 are selected or not all attributes (TI -V) are specified. There are some more schema transformations that should be supported. We decided to let the projection t7i or 7i-. . . -pi) be rhe "navigator" in the NF" schema which allows the application of any unary operation to any node in the schema tree including nest (V -V) and unnest (x -p).</p><p>The next problem to be solved was the generalization of joins: with the extensions of the projection and of the selection described so far we are able to do transformation of single NF' relations. But how can two of them be combined? Cartesian product (and thus join) merely enables us to combine two retations at the outermost level. This is not sufficient; we should be able to join a relation also at a lower level in the schema of another. Several alternatives were discussed among them was the consideration to extend the definition of the Cartesian product. But, instead, we decided to atlow binary operations within the projection list (that is, T; -X, pi -U. TS --1. Since we can reach any node in the schema tree by a sequence of n -?i expressions we are able to combine thkvalues of two attributes or an attribute and a constant (relation) by binary relational operators. This seems to be restrictive but the notion of a constant relation we use is very general (see next section).</p><p>De+!?rti~iorl 18 "e.vrended projection krs". Now the elements in a projection list t (see definition 123 x Cl:5 0 The definition (I?) of the projection operator has to be extended accordingly. This is not difficult because we must only give new definitions for singleelement projection lists due to our modular definition (cf. section 3.3.2).</p><p>Definiri~r~ 20 "exrended projt4nn".</p><p>( Notice that the renaming of TE to IME was optional in this case.</p><p>As a comprehensive overview of the schema transfo~ations caused by several operations consider the following illustration (Fig. <ref type="figure">5</ref>).</p><p>3.4.3 The notion of constants. In the INF case, a11 elements of the basic domain D are regarded as allowed constants for the selection atoms of type SAI. These constants are specified in algebraic expressions explicitly. Xn our case of higher order domains we would be able to specify constant sets. tiple nested r -z -n-. . . operation and apply It seems to be useful to allow expressions not the usual algebraic operators within the appropriate only on the outermost level but also within nested nesting level. applications of the algebra. As an example, con-3.5.2 Omitting extended selection atoms. Using sider the natural join within a projection list. Unthe construction rule from the previous section and doubtedly this would be a convenient operation an additional "trick", we can see that u -u and which could be defined as r-rr(cr(x)). Up to now, (T -r are not essential but can be defined via uexpressions within the z-list are not permitted. Any &amp;-r -n in connection with a simple selection and kind of expression within a projection list can be projection. The only problem is that u -u and defined via an expression at the outermost level u -r select rr+role tuples. while pi -u and pi -n containing no nested expressions: that is, "iterachange the subrelations.</p><p>To overcome this diffition" of the algebra can always be transformed to culty we project all attributes of the relations and the outermost level. The way we do that is best additionally the one which is modified by u or rr. explained by the following example:</p><p>Next (n[attr(R). expr:A'l (R))) As an example for the use of a nested expression consider the following query Q7 asking for a rela-This shows that the extension of selection atoms tion showing technical and administrational em-is unnecessary.</p><p>The only essential extension conployees for each department who share the same sists in the nested application of the seven basic job description. (Q7 is a 7-1 X I-type query expres-operations (see section 3.1) within the projection send here as pi-~i(cr(X))) list. first defined primitives (section 3.2, 3.3) in such a way that we could apply recursive definitions (section 3.4). As shown in section 3.5. the essential extension we introduced was the new projection operator. Expressions in selection formulae can be defined via expressions in projection lists. Special attention was given to the detinition of constants (section 3.1.3).</p><p>We have not yet solved the problem of equivalent expressions and the question of algebraic optimization on nested expressions. Both areas must be considered when we follow the plan of using this data model for a description of internal data structures and for a description of related mappings. The formalism of this paper gives the solid basis for further research on this subject. As we see this relational algebra at an internal level we did not consider the aspects of a user query language nor did we touch the aspects of integrity constraints and design theory. A protype database system based on our model is currently being implemented at the Technical University of Darmstadt.</p><p>,-tcknorrledgemenf--We are grateful for many discussions with G. Jaeschke and P. Pistor which have influenced further investigations since the reports[9, 51 have been written. While G. Jaeschke tries to define recursive relational algebra expressions in a VDM-like approach <ref type="bibr">[26]</ref> we have decided to define the meaning of general nested expressions bottom-up by sequences of a few basic-building blocks. We also thank the referees for their constructive comments <ref type="bibr">[II PI</ref> </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>values of this function are in C. De~ffitian 4 "NF' Relation". Given b = (N, S} E 3 a pair R = (b, V) is an NF' relation, iff S # 0 and v E dam(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>) val(R) for the second component of R For the two components of a description b E B we use (3) nam(b) for the first component of b (4) sch(b) for the second component of b Therefore, if b = (N. S) = des(R) is the description of a given relation R we get by nam~des(R~) the name (N) sch(desfR1) the schema (S)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Lemma 1: A tuple t of a relation R is a mapping of the form fWe prove this by an explicit assignment: For Ai E attr(R) with d(Ai) = yi E sch(R) we set t(Ai) = tyi. AS fyi E dom(y;) the function t has the desired property. 0 Definition 6 "Attribute Value". Let R be an (NF') relation, t E val(R) and A an attribute. The value of the function t(A) is called "attribute value" of A. For a set of attributes A = {A,, . . . , A,,} C attr(R), f E val(R), we also apply the usual shorthand notation t(A) := ?(A,, A2, . . . , A,) := (t(A,), r(Az), . . . , t(An)) Lemma 2: Under the assumptions of definition 6 the pair (d(A), f(A)) is a relation, iff sch(d(A)) f 0 Proof: Obviously, the first component d(A) is in B since A E attr(R). For the second component we have, according to lemma 1. t(A) E dom(d(A)) which is in C (see definition 3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Tree representation of R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>has the description (according to (1 )I des(DEPT) = (DEPTN, ( (U. 2). (DN. 0). (AE. S,). (TE. S:)}, with S, = {(AN,0},{'4JD,0)} Sz = {(TN,iZI).(TJD,0).(C,((CN.~i,{~,0,}&gt;&gt; The attribute description of attribute AE in DEPT is according to (7) d(AE) = (AIL {(AN. 0). (;\JD. 0,}) The schema part of this attribute is sch(d(AE)) = ((AN, 0), (AJD, 0)} which is not empty. Therefore AE is a relation-valued attribute (see definition 4). A sample value of this attribute is (see definition 6) t(AE) = {( 119, SECRETARY) (125, TRANSACTION) (135, PROCUREMENT)} which appears in the "second" tuple t E val(DEPT). The relation (see lemma 2) AER : = (d(AE), r(AE)) is a INF relation (see lemma 3) since attr(AER) = {AN, AJD} and sch(d(AN)) = sch(d(AJD)) = + The DEPT relation is a real NF' relation. For this "outer" relation there is one description and only one value at any point in time. Therefore we could have used the name nam(des(DEPT)) = DEPTN to identify the relation. This, however, can not be done for "subrelations" such as AER. The relation is not uniquely identified by the name AE but rather by the name AE and the tuple t E val(DEPT) under consideration. AE only identifies the description d(AE). We construct the domain of AE according to definition 3 as dom({A~, {(AN, 0). (AJD, Q)}) = P(dom((AN, 0)) x dom((AJD, 0))) = P(D x D) 3. THENFLRELXTIOSr\LALGEBRs\</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>3.2.1 Set operations. As in the 1NF case set operations on NF' relations Rl and R2 are only defined if sch(R1) = sch(R2). Definition 7 "set operalions". If sch(R1) = sch( R2) then (1) sch(Rl u R2) : = sch(RI -R2) : = sch(R1 il R7) : = sch(R1) (2) (a) val(R1 U R2) := val(Rl) U val(R2) (b) val(RI -R2) := val(R1) -val(R2) (c) val(R1 n R2) : = val(R1) n val(R2) (=val(Rl -(Rl -R2))) q 3.2.2 Selecrion. We give a modular definition which corresponds to the usual selection. The reason for these explicit definitions will be seen when we extend the definitions to the nested selection (see 3.1. I). Definition 8 "selection atom". A selection atom ( SX) has one of the following two forms: Type SAl: attribute cop constant Type SAZ: attribute1 cop attribute2 COP E {&lt;. s, &gt;, 2. = . f, c, c, 3, 2. E, 3) c Notice that in the 1NF case the set comparison operators would be omitted. Definition 9 "selection formula". A selection formula (SF) is a logical combination of selection atoms: (1) Each SA is a SF (2) S is a SF 3 (not F) is a SF (3) F,, F: are SF 3 (F, A F:), (F, V F:) are SF (4) nothing else is a SF q Now we can give a definition of the selection operation u[F](R). Definition 10 "selection". (1) sch(a[F](R) : = sch(R) (2) The value of a selection is determined according to 4 cases, depending on the type of F:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>3.3.1 Cartesian product. The definition of the Cartesian product applies to NF' relations without change: De~nition 11 "Cartesianprod~~ct". If sch(R1) fl sch(R2) = 0, then (I) sch(R1 x R2) := sch(R1) U sch(R2) (7) valfR1 x R2) := {t 1 t(attr(Rl1)) E val(R1) A t(attr(R2)) E val(RZ)} cl Notice that we assume sch(RI) fl sch(R2) = 0 otherwise we must perform renaming (seee 3.3.2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>L = &amp;:B,, Ai2:Bz, , . . , Ai,:B, where the Aij are attributes of R and the Sj are new names for the projected attributes. Again the ordering of the Ail is arbitrarily fixed. For a given L as above we define L' : = Ai,, . . . , Ai, L' := B,, , . . , B, that is, L' contains the projected attributes Aij E attr(R) and L" contains new names for these attributes in the resulting relation. The ordering in L' and L2 is the same as in L. 0 Definition 13 "projection". We give a recursive definition which distinguishes two cases:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>(Rf : = {{B, sch(d(&amp;)))} (ii) val(tr[LlfR) : = {t 1 (3) r E val(R) A r(Ai) = t(B)} The projection list has more than one element, that is, L = L', Ai:B. If Ai E attr(R), then (i) sch(n[Ll(R)) : = sch(n[L'](R))$</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>3.3.3 Nest nnd unnest. Nest (VI and Unnest (p)f9] change the height of the schema tree; especially they transform between INF and NF* relations. Assume a relation R with attributes AI, . . , A,, We define the nest operator v applied to R along the last k attributes in the above ordering. This is no loss of generality because the ordering is arbitrary. Definition 14 "nest". Let R be a relation and attr(R) = {At, . . , A,}, A' E NAME, A' f Aj, i = 1 ,.--3 n. Let further Al : = A,, . . . , An-k and A2 := An_k+l, . . . , A,. Then v[A,_~+~, . . . , A,, :A'] (R) abbreviated by v[A2:A'] (R) is defined as follows: (I) sch(v[AZ:A'] (R)) := sch(R) -{d(Aj) 1 j = n-k+ I, . . , n) U {(A', {SCh(d(Aj)) /j = n-k-k I, . . . , )I))} (2) val(u[A2:A'] CR)) := {t 1 (3) r E val(T;[Al] (R)) A [(Al) = r(A1) A t(A') = val(n[A2] (cr[A, = r(A,) A . . * A An--r = rLL.-Jl CR))bj</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Fig. 4. Effect of nesting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>;[TJD] (TE) 2 {research. planning]] (DEPT)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>ii M. H. Sc6iotr.of ;[L]  (RI may hat,s one of the following formats (Ai. ilk are attributes of R. C E dom(d(&amp;)) is a constant): tl1 f7 -type1 .i,:B(theonlyoncuptonow) (2) (li -7-t)'pe1 z[L'j(il;f:B (3) (Tiu-t&gt;.peI 0[/--](.&amp;):5 (4) (ii -v-type) L'[, , , l(A,):B (5) !Tb-type) k[. . . ](.+):I3 (6) in -U-type) i,4: UA~i:BortAiUC):8 (7) (71 ---type) (.-1. -&amp;):Bor(.% -C):B (8) (75 -X-type) l.i, x &amp;l:Bor(A,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>) L = A;:B see definition 13 G-j1 to avoid unnecessary distinctions we use the following notation: Let uop E {GIL']. a[FJb V[ . . , ]+ F[ . . 1) and t = uopl.4,l:B. schid[A;fiSt 0. Further let ~2, E domiri(&amp;lf be an arbitrary value. Then (i) sch(r[ll (I'?)) : = {(B, SCh(uOp((d(Ai), :'i})))} tii) vatf$f_] (RI) := if i (3) r E vai[R) A r!B) = ~~l~UO~(~~~~~;~, P(A;l)))} V5-81 now let bop E {U, -. X}. I'~ E dom(d(&amp;)) and 1'1, E dom(cI(,&amp;)). We must distinguish two cases: (a) L 3 (=I: bop &amp;):B, sch(d(A;)), schf d(Ar )1 f 0. Then (i) sch(z[LI fR)) : = j$. sch((dfAi), I'#) bop idtAo), Q}))) Iii) val(?;[L] (RI) : = {I 1 (31 r E val(R) fj r(B) = val({&amp;A;). ,(A,)) bop (CO&amp;l. r(&amp;))JI (b) L = iAi hop C):B. sch(~!(ili)f + 0. (iI sch(aII.1 (Rfl := {(S. sch((d(A;), 1~;) bop 01 iii) vnlMLj (R)) : = {f / (3) r E val(R) i', f(R) = val[(d(rlj). r(A,)) bop 01 cl Let us consider two examples of extended projections for our sample DEPT relation (Fig. 3): We are interested in a relation QS comprising information about the technical staff of all departments but we do not want to see the employees' courses (n --rr-type): Q5: = nfD,DN,r;lTN,TJD](TE):TE'](DE~~ Here we see the use of the renaming facility: as the schema of the subrelation TE is not the same as the one of TE' in QS and because we identify the schema of an attribute by its name, we have to assign a new name to the result of the inner projection. If we are interested in the maintenance person-nel of each department, we can get this information by the following query Q6 (n -o-type): Q6 := 7i[D. DN. (r[TJD = 'maintenance'] tTE): ME] (DEPT)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>For example "u{n[C#] (COURSES) 3 {I, 2, 311 (EMP)" is a well-formed selection with the constant set "(I I 2, 3)" given expiicitly by enumeration. Ob-nodes of .A,: that is. the nodes attr(d(&amp;)) -{A,}, Let us consider one additional query indicating Constants iv.r.t. A are circled in Fig. 6. how binary operations can be directed to relations deeper in the schema: Imagine a (1NF) relation 3.5 Torc,ards a minimal set of SF' operators CD(C#, CDES) containing descriptions of the In this section we first show how we can define courses attended by our technical personnel. We the meaning of nested expressions. We will also want to get this information into the DEPT relation, show that the nested expressions in a selection for-The query Q8 does that by joining the "outer" remula can be replaced by nested expressions in a lation CD with any C relation in DEPT. Notice that projection list. CD is a constant w.r.t. node C. 3.5.1 Expressions in nested algebraic operators. With the given definitions of the basic oper-QS := n[D, DN, r[TN, TJD, n[CN, CDES, yl ators we can recursively define the meaning of any (o[CN = C#] (C x CD)) : TCD] (TE) : TECI (DEPT) expression: that is, any series of subsequently applied operators. Each algebraic operator results in As can be seen from this sample expression, we an NF' relation and hence an expression can be locate any node in a relation schema tree by a muldefined via an induction over its finite (!) structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>, a simple selection refers to this new attribute. Let E be an expression of the form E = Finally, the additionai attribute is eliminated by a ~[expr(&amp;):rl] (R) and expr = op(expr'(A;)) simple projection. For instance: The we define E to be equivalent to u[u[F'] (Ai) cop C] (R), with A; E attr(R) and C E = n[op(A'):A] (n[expr'(Ai):A'l (R)) E dom(d(Ai)) is equivalent to n[attr(R)] (cr[A,! cop CI (T[attr(R), o[F'I (Ai):AfI (R))) Notice. that expr' is "shorter" than expr. By induction over the number of operators in E and in-Generally, we define a selection with a general spection of all cases for op we conclude that expres-expression expr in its formula by the following sions within a projection list do not add expres-equation siveness. But they are a convenient abbreviation that can be defined formally via the above decom-u[expr cop C] (R) : = 7i[attr(R)] (u[A' cop C] position.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>Q7:= x[D.DN.(~[AN.TN,TJDl 4. coscLuIoNs (u[XJD = TJD] (AE x TE))): ATE] (DEPT) We extended the usual notion of schema, value, According to our previous discussion this expres-attribute and domain of 1NF relations to relations sion is equivalent to with relation-valued attributes by applying them recursively. The usual definitions are contained as a Hl : = :[D, DN, (AE x TE):ATE'] (DEPT) special case, The relational algebra, first extended by two new operators nest and unnest, gets more H2 : = z[D. DN, a[.4JD = TJD] (ATE')] (Hl) effective by allowing algebraic expressions also for Q7 := T;[D, DN, ;;[AN. TN, TJDI the relations within relations. In order to find simple formal definitions for such nested expressions, we (ATE' 1: ATE] (H2)</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>viously, specifying set-valued constants explicitly can be very lengthy. Therefore, further solutions would be suitable for this problem. The advantage of constants, as far as query evaiuation is concerned, is that tuples can be checked against predetermined values which are independent of the considered tuples. Hence, variables that have been set to some (constant) value could be used in algebraic expressions instead of explicitly specified constants. We want to go even one step further. Imagine a query on an NF' relation to be evaluated using an hierarchical (depth first) scan over the set of tupies, When we descend from the hierarchical level k to k + 1 in this scan, we fix the values of the attributes on level k. Therefore, the attributes of level k can be regarded as "dynamic" constants (or variables with constant values) throughout the following part of the scan referring to the entered subrelation.</p><p>So we arrive at an extended notion of constants according to the following definition.</p><p>Definition Z'i "constants". </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Relational Model for Large Shared WI Data Banks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
		<title level="m">An Inrroduction IO DarabaseSvstems</title>
		<imprint/>
	</monogr>
	<note>rd</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>Addison-Wesley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Entity-Relationship Model-Toward a Unified View of Data</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS l(1)</title>
		<imprint>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The Theory of Relational Databases Com-[22]</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>puter Science Press</publisher>
			<pubPlace>Rockville, Maryland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Data Structures for an Integrated Database Management and Information Retrieval System</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Schek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pistor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Conf Mexico City</title>
		<meeting>VLDB Conf Mexico City</meeting>
		<imprint>
			<biblScope unit="page">1231</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><surname>Mexico</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The NF&apos; Relational Algebra for a Uniform Manipulation of the External</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Schek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Scholl</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">1341</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m">Conceptual and Internal Data Models</title>
		<editor>
			<persName><forename type="first">(</forename><forename type="middle">J W</forename><surname>Sorachen Fuer Datenbanken</surname></persName>
		</editor>
		<editor>
			<persName><surname>Schmidt</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin WI</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="volume">72</biblScope>
		</imprint>
	</monogr>
	<note>Informatik Fachberichte Nr</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Synthesis of Unnormalized Relations Incorporating More WI Meaning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kambayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takeda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. Journal of Information Sciences</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Special Issue on Databases</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">K</forename><surname>Atisawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moriya</surname></persName>
		</author>
		<author>
			<persName><surname>Miura</surname></persName>
		</author>
		<title level="m">Operations and Properties on Non-First-Sormal-Form Relational</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><surname>Databases</surname></persName>
		</author>
		<title level="m">Proc. VLDB Conf</title>
		<meeting>VLDB Conf<address><addrLine>Florence. Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Remarks on the Algebra of Non-First-Normal-Form Relations</title>
		<author>
			<persName><forename type="first">G</forename><surname>Jaeschke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Schek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. isr. AC.Lf SlGACTISlG.UOD Sump. on Prim</title>
		<meeting>isr. AC.Lf SlGACTISlG.UOD Sump. on Prim</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">-\n Ob.erview of Darabase .Mancqemen! Technoloq?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Report TRCS-I. S.ANNO College. Kanaeawa. Japan</title>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
	<note type="report_type">Techn</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Consideration on Normal Form of Not-Necessarily-Normalized Relations in the Relational Data Model</title>
		<author>
			<persName><forename type="first">A</forename><surname>Makinouch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Conf</title>
		<meeting>VLDB Conf<address><addrLine>Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Operators for Non-First-Normal-Form Relations. f&apos;roc</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE COMP-S</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Non First Normal Form Relations to Represent Hierarchically Organised Data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd ACM SIGACTISIGMOD STmp. on Print. of Darabase Systems</title>
		<meeting>2nd ACM SIGACTISIGMOD STmp. on Print. of Darabase Systems<address><addrLine>Waterloo, Ontario. Canada</addrLine></address></meeting>
		<imprint>
			<date>111984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Seven-Tuple Representation for Hierarchical Data Structures</title>
		<author>
			<persName><forename type="first">T</forename><surname>Niemi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Infbrm. Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Data Modelling Appreach for Office Information Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gibbs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tsichritzis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Office Information Svslems l</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Specification of Forms Processing and Business Procedures for Office Automation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Y</forename><surname>Lum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Sofitie. Eng. SE-S</title>
		<imprint>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Form Operation by Example, A Language for Office Information Processing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Conf</title>
		<meeting>ACM SIGMOD Conf<address><addrLine>Ann Arbor, Mich</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Schema Analysis for Database Restructuring. rlC</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Navathe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cf TODS. j(Z)</title>
		<imprint>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Form Management</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tsichritzis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Omega</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">Alpha</orgName>
		</author>
		<idno>CSRG- 127</idno>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Univ. of Toronto</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Techn. Report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On Extending the Functions of a Relational Database System</title>
		<author>
			<persName><forename type="first">R</forename><surname>Haskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lorie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pr&amp;. AC:M SIG-iC1OD Co&amp;</title>
		<meeting><address><addrLine>Orlando. Fl</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">F&amp;tad0 and L. Kerschberg. An Algebra of Quotient Relations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Conf Toronto</title>
		<meeting>ACM SIGMOD Conf Toronto</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Lamersdorf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Schmidt</surname></persName>
		</author>
		<title level="m">Recursive Data Models</title>
		<imprint>
			<publisher>Sprachenfirer Dalerrbanken</publisher>
		</imprint>
	</monogr>
	<note>in German</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Schmidt</surname></persName>
		</author>
		<title level="m">Informatik-Fachberichte Nr</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<author>
			<persName><surname>Berlin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">ANSIIX3ISPARC Study Group on Data Base Management Systems</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Bancilhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Richard</surname></persName>
		</author>
		<author>
			<persName><surname>Scholl</surname></persName>
		</author>
		<idno>75-02-08</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Conf. Mexico City</title>
		<meeting>VLDB Conf. Mexico City<address><addrLine>Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975">1982. 1975</date>
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Interim Report</note>
	<note>On Line Processing of Compacted Relations</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">iull Values and [heir Integrarion inro the NF&apos; Relarional Model</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hoeller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
		<respStmt>
			<orgName>Techn. Univ. of Darmstadt</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Diploma Thesis</note>
	<note>in German</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Recursive Algebra J)r Relarions n,ith</title>
		<author>
			<persName><forename type="first">G</forename><surname>Jaeschke</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
