<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient monitoring of safety properties</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2003-11-28">28 November 2003</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Klaus</forename><surname>Havelund</surname></persName>
							<email>havelund@email.arc.nasa.gov</email>
							<affiliation key="aff0">
								<orgName type="department">Kestrel Technology</orgName>
								<orgName type="institution">NASA Ames Research Center</orgName>
								<address>
									<settlement>Moffett Field</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Grigore</forename><surname>Roşu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient monitoring of safety properties</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2003-11-28">28 November 2003</date>
						</imprint>
					</monogr>
					<idno type="MD5">8BC7A1AA952C5739C7B424584F299476</idno>
					<idno type="DOI">10.1007/s10009-003-0117-6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Monitoring -Safety -Temporal logics</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The problem of testing whether a finite execution trace of events generated by an executing program violates a linear temporal logic (LTL) formula occurs naturally in runtime analysis of software. Two efficient algorithms for this problem are presented in this paper, both for checking safety formulae of the form "always P ", where P is a past-time LTL formula. The first algorithm is implemented by rewriting, and the second synthesizes efficient code from formulae. Further optimizations of the second algorithm are suggested, reducing space and time consumption. Special operators suitable for writing succinct specifications are discussed and shown to be equivalent to the standard past-time operators. This work is part of NASA's PathExplorer project, the objective of which is to construct a flexible framework for efficient monitoring and analysis of program executions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The work presented in this paper is part of a project at NASA Ames Research Center called PathExplorer <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b33">34</ref>] that aims at developing a practical testing environment for NASA software developers. The basic idea of the project is to analyze the execution trace of a running program to detect errors. The errors being considered at this stage are multithreading errors such as deadlocks and data races and nonconformance with linear temporal logic specifications, which is the main focus of this paper.</p><p>Linear temporal logic (LTL) <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b32">33]</ref> is a logic for specifying properties of reactive and concurrent systems. * Supported in part by joint NSF/NASA grant CCR-0234524.</p><p>The models of LTL are infinite execution traces, reflecting the behavior of such systems as ideally always being ready to respond to requests, operating systems being a typical example. LTL has been mainly used to specify properties of concurrent and interactive down-scaled models of real systems so that fully formal correctness proofs could subsequently be carried out, for example using theorem provers or model checkers (see, e.g., <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref>). However, formal proof techniques are usually not scalable to realsized systems without a substantial effort to abstract the system more or less manually to an analyzable model. Model checking of programs has received increased attention from the formal methods community within the last couple of years, and several systems have emerged that can directly model check source code, such as Java and C <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b36">37]</ref>. Stateless model checkers <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b35">36]</ref> try to avoid the abstraction process by not storing states. Although these systems provide high confidence, they scale less well because most of their internal algorithms are exponential or worse.</p><p>Testing scales well, and it is by far the most used technique in practice to validate software systems. The merging of testing and temporal logic specification is an attempt to achieve the benefits of both approaches while avoiding some of the pitfalls of ad hoc testing and the complexity of full-blown theorem proving and model checking. Of course, there is a price to pay to obtain a scalable technique -the loss of coverage. The suggested framework can only be used to examine single execution traces and can therefore not be used to prove a system correct. Our work is based on the belief that software engineers are willing to trade coverage for scalability, so our goal is to provide tools that are completely automatic, implement very efficient algorithms, and find many errors in programs. A longer-term goal is to explore the use of conformance with a formal speci-fication to achieve fault tolerance. The idea is that the failure may trigger a recovery action in the monitored program.</p><p>The idea of using LTL in program testing is not new. It has already been pursued in commercial tools such as Temporal Rover (TR) <ref type="bibr" target="#b9">[10]</ref>, which inspired our work in a major way. In TR, future-and past-time LTL properties are stated as formal comments within the program at chosen program points, like assertions. These formal comments are then translated by a preprocessor into code, which is inserted at the position of the comments, and executed whenever reached during program execution. <ref type="foot" target="#foot_0">1</ref> The MaC tool <ref type="bibr" target="#b25">[26]</ref> is another example of a runtime monitoring tool that has inspired this work. Here Java bytecode is automatically instrumented to generate events of interest during the execution. Of special interest is the temporal logic used in MaC, which can be classified as a past-time interval logic convenient for expressing monitoring properties in a succinct way. A theoretical contribution in this paper is Theorem 1, which shows that the MaC temporal logic, together with ten others, is equivalent to the standard past-time temporal logic. The path exploration tool described in <ref type="bibr" target="#b12">[13]</ref> uses a future-time temporal logic formula to guide the execution of a program for debugging purposes. Hence the role of a temporal logic formula is turned around from monitoring a trace to generation of a trace.</p><p>Past-time LTL has been shown to have the same expressiveness as future-time LTL <ref type="bibr" target="#b10">[11]</ref>. However, pasttime LTL is exponentially more succinct than future-time LTL <ref type="bibr" target="#b28">[29]</ref>. For example, a property like "every response should be preceded by a request" can be easily stated in past-time logic (reflecting directly the previous sentence), but the corresponding future-time representation becomes "it is not the case that (there is no request until (there is a response and no request))". Hence past-time LTL is more convenient for specifying certain properties and is the focus of this paper.</p><p>We present two efficient monitoring algorithms for checking safety formulae of the form "always P ", where P is a past-time LTL formula, one based on formula rewriting and the other based on synthesizing efficient monitoring code from a formula. The rewriting-based algorithm illustrates how rewriting can be used to easily and elegantly define new logics for monitoring. This may be of interest when experimenting with logics, or if logics are domain specific and change with the application, or if one simply wants a small and elegant implementation. The synthesis-based algorithm, on the other hand, generates a very effective monitor for the particular past-time logic and focuses on efficiency. Also, in contrast to the rewriting approach, where a rewriting engine must be called by an external call, the synthesis-based algorithm is better suited for gen-erating code that can be inserted in the monitored program.</p><p>The first algorithm is implemented by rewriting using Maude <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref>, an executable specification language whose main operational engine is based on term rewriting. Since flexibility with respect to defining/modifying monitoring logics is a very important factor at this stage in the development of PathExplorer, we have actually developed a general framework using Maude that allows one to easily and effectively define new logics for runtime analysis and to monitor execution traces against formulae in these logics. The rewriting algorithm presented in this paper instantiates that framework to our logic of interest, past-time LTL. The second algorithm presented in this paper is designed to be as efficient and specialized as possible, thus adding the minimum possible amount of runtime overhead. It essentially synthesizes a special purpose, efficient monitoring code from formulae, that is further compiled into an executable monitor. Further optimizations of the second algorithm are suggested, making each monitoring step typically run in time lower than the size of the monitored formula. Both algorithms are based on the fact that the semantics of past-time LTL can be defined recursively in such a way that one only needs to look one step, or event, backwards to compute the new truth value of a formula and of its subformulae, thus allowing one to process and then discard the events as they are received from the instrumented program. Several special operators suitable for writing succinct monitoring safety specifications are introduced and shown to be semantically equivalent to the standard pasttime operators.</p><p>Section 2 gives a short description of the PathExplorer architecture, putting the presented work in context. Section 3 recalls past-time LTL and introduces several monitoring operators together with their semantics, then discusses several past-time logics, and finally shows their equivalences. Section 4 first presents our rewritingbased framework for defining and executing new monitoring logics and then shows how past-time LTL fits into this framework. Section 5 finally explains our monitorsynthesis algorithm together with optimizations and two ways to implement it. Section 6 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The PathExplorer architecture</head><p>PathExplorer (PaX) is a flexible environment for monitoring and analyzing program executions. A program (or a set of programs) to be monitored is supposed to be instrumented to emit execution events to an observer, which then examines the events and checks whether they satisfy certain user-defined constraints. We first give an overview of the observer that monitors the event stream. Then we discuss how a program is instrumented for monitoring of temporal logic properties. The instrumentation presented is specialized for Java, but the principles carry over to any programming language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The observer</head><p>The constraints to be monitored can be of different kinds and defined in different languages. Each kind of constraint is represented by a module. Such a constraint module in principle implements a particular logic or program analysis algorithm. Currently there are modules for checking deadlock potentials, data race potentials, and temporal logic formulae in different logics. Among the latter, several modules have been implemented for checking future-time temporal logic, and the work presented in this paper is the basis for a module for checking past-time logic formulae. In general, the user can program new constraint modules and in this manner easily extend PaX.</p><p>The system is defined in a component-based way, based on a dataflow view, where components are put together using a "pipeline" operator (Fig. <ref type="figure">1</ref>). The dataflow between any two components is a stream of events in simple text format, without any a priori assumptions about the format of the events; the receiving component just ignores events it cannot recognize. This simplifies composition and allows for components to be written in different languages and in particular to define observers of arbitrary systems, programmed in a variety of programming languages. This latter fact is important at NASA since several systems are written in a mixture of C, C++, and Java.</p><p>The central component of the PaX system is a socalled dispatcher . The dispatcher receives events from the executing program or system and then retransmits the event stream to each of the constraint modules. Each module is running in its own process with one input pipe, dealing only with events that are relevant to the module. For this purpose, each module is equipped with an event parser. The dispatcher takes as input a configuration script, which specifies a list of commands -a com-Fig. <ref type="figure">1</ref>. Overview of the PaX observer mand for each module that starts the module in a process. The dispatcher may read its input event stream from a file, or alternatively from a socket, to which the instrumented running program must write the event stream. In the latter case, monitoring can happen on the fly as the event stream is produced, and potentially on a different computer than the observed system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Code instrumentation</head><p>The program or system to be observed must be instrumented to emit execution events to the dispatcher (writing them to a file or to a socket as discussed above). We have currently implemented an automated instrumentation package for Java bytecode using the Java bytecode engineering tool JTrek <ref type="bibr" target="#b24">[25]</ref>. The instrumentation package together with PaX is called Java PathExplorer (JPaX). Given information about what kind of events are to be emitted, the instrumentation package instruments the bytecode by inserting extra code for emitting events. For deadlock analysis, for example, events are generated that inform about lock acquisitions and releases. For temporal logic monitoring, one specifies the variables to be observed and what predicates over these variables one wants to refer to in the temporal properties to be monitored. Imagine, for example, that the observer monitors the formula "always p", involving the predicate p, and that p is intended to be defined as p ≡ x &gt; y, where x and y are static variables defined in a class C. In this case, all updates to these variables must be instrumented such that an update to any of them causes the predicate to be evaluated and a toggle p to be emitted to the observer in case it has changed. The instrumentation script is written in Java (using reflection) but in essence can be represented as follows: monitor C.x, C.y; proposition p is C.x &gt; C.y; The code will then be instrumented to emit changes in the predicate p. More specifically, first the initial value of the predicate is transmitted to the observer. Subsequently, whenever one of the two variables is updated, the predicate is evaluated, and in case its value has changed since Fig. <ref type="figure">2</ref>. Events corresponding to observing predicate p ≡ x &gt; y the last evaluation, the predicate name p is transmitted to the observer as a toggle. The observer keeps track of the value of the predicate, based on its initial value, and the subsequent predicate toggles. Figure <ref type="figure">2</ref> shows an execution trace where x and y initially are 0 and then subsequently updated. The corresponding values of p are shown. Also shown are the events that are sent to the observer. That is, the initial value of p and the subsequent p toggles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Finite trace past-time LTL</head><p>In this section, we recall some basic notions of finite trace linear past-time temporal logic <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28]</ref>, establish some conventions, and introduce some operators that we found particularly useful for runtime monitoring. We emphasize that the semantics of past-time LTL can be elegantly defined recursively, thus allowing us to implement monitoring algorithms that only need to look one step backwards. We also show that past-time LTL can be entirely defined using just the special operators that were introduced essentially because of practical needs, thus strengthening our belief that past-time LTL is an appropriate candidate logic for expressing monitoring safety requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Syntax</head><p>We allow the following constructors for formulae, where A is a finite set of "atomic propositions":</p><formula xml:id="formula_0">F ::= true | false | A | ¬F | F op F (propositional operators) • • F | • F | • F | F S s F | F S w F (standard past-time operators) ↑ F |↓ F | [F, F ) s | [F, F ) w (monitoring operators)</formula><p>The propositional binary operators, op, are the standard ones, that is, disjunction, conjunction, implication, equivalence, and exclusive disjunction. The standard past-time and the monitoring operators are often called "temporal operators" because they refer to other (past) moments in time. The operator • • F should be read "previously F "; its intuition is that F held at the immediately previous moment in time. • F should be read "eventually in the past F ", with the intuition that there is some past moment in time when F was true. • F should be read "always in the past F ", with the obvious meaning. The operator F 1 S s F 2 , which should be read "F 1 strong since F 2 ", reflects the intuition that F 2 held at some moment in the past and that since then F 1 has held all the time. F 1 S w F 2 is a weak version of "since", read "F 1 weak since F 2 ", saying that either F 1 was true all the time or otherwise F 1 S s F 2 .</p><p>The monitoring operators ↑, ↓, [_, _) s , and [_, _) w were inspired by work in runtime verification in <ref type="bibr" target="#b25">[26]</ref>. We often found these operators more intuitive and compact than the usual past-time operators in specifying runtime requirements, despite the fact that they have the same expressive power as the standard ones, as we discovered later. The operator ↑ F should be read "start F "; it says that the formula F just started to be true, that is, it was false previously but is true now. At the same time, the operator ↓ F which is read "end F ", carries the intuition that F stops being true, that is, it was previously true but is now false. The operators [F 1 , F 2 ) s and [F 1 , F 2 ) w are read "strong/weak interval F 1 , F 2 " and carry the intuition that F 1 was true at some point in the past but F 2 has not been seen to be true since then, including that moment. For example, if Start and Down are predicates on the state of a Web server to be monitored, then [Start, Down) s is a property stating that the server was rebooted recently and since then it has not been down, while [Start, Down) w says that the server was not down recently, meaning that it was either not down at all recently or it was rebooted and since then has not been down.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Formal semantics</head><p>We next present formally the intuitive semantics described above. We regard a trace as a finite sequence of abstract states. In practice, these states are generated by events emitted by the program or system that we want to observe. Such events could indicate when variables' values are changed or when locks are acquired or released by threads or processes, or even when a physical action takes place such as opening or closing a valve, a gate, or a door. If s is a state and a is an atomic proposition, then a(s) is true if and only if a holds in the state s. Notice that we are loose with respect to the meaning of "holds" because, depending on the context, it can mean anything. However, in the case of JPaX, the atomic predicates are simply any Java boolean expressions, and their satisfaction is decided by evaluating them in the current state of the Java program. If t = s 1 s 2 . . . s n (n ≥ 1) is a trace, then we let t i denote the trace s 1 s 2 . . . s i for each 1 ≤ i ≤ n. The formal semantics of the operators defined in the previous subsection is given in Fig. <ref type="figure">3</ref>.</p><p>Notice the special semantics of the operator "previously " on a trace of one state: s |= • • F iff s |= F . This is consistent with the view that a trace consisting of exactly one state s is considered as a stationary infinite trace containing only the state s. We adopted this view because of intuitions related to monitoring. One can start monitoring a process potentially at any moment, so the first state in the trace might be different from the initial state of the monitored process. We think that the "best guess" one can have with respect to the past of the monitored program is that it was stationary. Alternatively, one could consider that is false on a trace of one state for any atomic proposition F , but we find this semantics inconvenient because some atomic propositions may be related, such as, for example, a proposition "gate-up" and a proposition "gate-down".</p><formula xml:id="formula_1">• • F t |= true is always true, t |= false is always false, t |= a iff a(s n ) holds, t |= ¬F iff t |= F , t |= F 1 op F 2 iff t |= F 1 and/or/etc. t |= F 2 , when op is ∧/∨/etc., t |= • • F iff t |= F , where t = t n-1 if n &gt; 1 and t = t if n = 1, t |= • F iff t i |= F for some 1 ≤ i ≤ n, t |= • F iff t i |= F for all 1 ≤ i ≤ n, t |= F 1 S s F 2 iff t j |= F 2 for some 1 ≤ j ≤ n and t i |= F 1 for all j &lt; i ≤ n, t |= F 1 S w F 2 iff t |= F 1 S s F 2 or t |= • F 1 , t |=↑ F iff t |= F and t n-1 |= F , t |=↓ F iff t n-1 |= F and t |= F , t |= [F 1 , F 2 ) s iff t j |= F 1 for some 1 ≤ j ≤ n and t i |= F 2 for all j ≤ i ≤ n, t |= [F 1 , F 2 ) w iff t |= [F 1 , F 2 ) s or t |= • ¬F 2 . Fig. 3. Semantics of finite trace past time LTL t |= • F iff t |= F or (n &gt; 1 and t n-1 |= • F ), t |= • F iff t |= F and (n &gt; 1 implies t n-1 |= • F ), t |= F 1 S s F 2 iff t |= F 2 or (n &gt; 1 and t |= F 1 and t n-1 |= F 1 S s F 2 ), t |= F 1 S w F 2 iff t |= F 2 or (t |= F 1 and (n &gt; 1 implies t n-1 |= F 1 S w F 2 )), t |= [F 1 , F 2 ) s iff t |= F 2 and (t |= F 1 or (n &gt; 1 and t n-1 |= [F 1 , F 2 ) s )), t |= [F 1 , F 2 ) w iff t |= F 2 and (t |= F 1 or (n &gt; 1 implies t n-1 |= [F 1 , F 2 ) w )).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Recursive semantics</head><p>An observation of crucial importance in the design of the subsequent algorithms is that the semantics above can be defined recursively in such a way that the satisfaction relation for a formula and a trace can be calculated along the execution trace looking only one step backwards, as shown in Fig. <ref type="figure" target="#fig_0">4</ref>.</p><p>For example, according to the formal, nonrecursive semantics, a trace t = s 1 s 2 ...s n satisfies the formula [F 1 , F 2 ) w if and only if either F 2 was false all the time in the past or otherwise F 1 was true at some point and since then F 2 has always been false, including at that moment. Therefore, in the case of a trace of size 1, i.e., when n = 1, it follows immediately that t |= [F 1 , F 2 ) w if and only if t |= F 2 . Otherwise, if the trace has more than one event, then first t |= F 2 , and then either t |= F 1 , or else the prefix trace satisfies the interval formula, that is,</p><formula xml:id="formula_2">t n-1 |= [F 1 , F 2 ) w .</formula><p>Similar reasoning applies to the other recurrences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Equivalent logics</head><p>We call the past-time temporal logic presented above ptLTL. There is a tendency among logicians to minimize the number of operators in a given logic. For example, it is known that two operators are sufficient in propositional calculus, and two more ("next" and "until") are needed for future-time temporal logics. There are also various ways to minimize ptLTL. Let ptLTL Ops be the restriction of ptLTL to the propositional operators plus the operations in Ops. Then Theorem 1. The following 12 logics are all equivalent to ptLTL: The first two are known in the literature <ref type="bibr" target="#b26">[27]</ref>.</p><formula xml:id="formula_3">1. ptLTL {• •,Ss} , 2. ptLTL {• •,Sw} , 3. ptLTL {• •,[)s} , 4. ptLTL {• •,[)w} , 5. ptLTL {↑,</formula><p>Proof. We first show the following properties:</p><p>1.</p><p>• F =true S s F 2.</p><p>•</p><formula xml:id="formula_4">F =¬ • ¬F 3. F 1 S w F 2 =( • F 1 ) ∨ (F 1 S s F 2 ) 4.</formula><p>• F =F S w false 5.</p><p>•</p><formula xml:id="formula_5">F =¬ • ¬F 6. F 1 S s F 2 =( • F 2 ) ∧ (F 1 S w F 2 ) 7. ↑ F =F ∧ ¬ • •F 8. ↓ F =¬F ∧ • • F 9. [F 1 , F 2 ) s =¬F 2 ∧ ((• • ¬F 2 ) S s F 1 ) 10. [F 1 , F 2 ) w =¬F 2 ∧ ((• • ¬F 2 ) S w F 1 ) 11. ↓ F =↑ ¬F 12. ↑ F =↓ ¬F 13. [F 1 , F 2 ) w =( • ¬F 2 ) ∨ [F 1 , F 2 ) s 14. [F 1 , F 2 ) s =( • F 1 ) ∧ [F 1 , F 2 ) w 15. • • F =(F → ¬ ↑ F ) ∧ (¬F →↓ F ) 16. F 1 S s F 2 =F 2 ∨ [ • •F 2 , ¬F 1 ) s</formula><p>These properties are intuitive and relatively easy to prove. For example, property 15, the definition of • • F in terms of ↑ F and ↓ F , says that to find out the value of a formula F in the previous state, it suffices to look at the value of the formula in the current state and then, if it is true, see if the formula just started being true or else see if the formula just stopped being true. We next only prove property 10; the proofs of the others are similar and straightforward.</p><p>To prove property 10, one needs to show that for any trace t, it is the case that</p><formula xml:id="formula_6">t |= [F 1 , F 2 ) w if and only if t |= w ¬F 2 ∧ ((• • ¬F 2 ) S w F 1 )</formula><p>. We show this by induction on the size of the trace t. </p><formula xml:id="formula_7">If the size of t is 1, that is, if t = s 1 , then t |= [F 1 , F 2 ) w iff iff t |= F 2 iff t |=</formula><formula xml:id="formula_8">) iff t |= ¬F 2 ∧ ((• • ¬F 2 ) S w F 1 ).</formula><p>If the size of the trace t is n &gt; 1 then</p><formula xml:id="formula_9">t |= [F 1 , F 2 ) w iff iff (by the recursive semantics) t |= F 2 and (t |= F 1 or t n-1 |= [F 1 , F 2 ) w ) iff (by the induction hypothesis) t |= F 2 and (t |= F 1 or t n-1 |= ¬F 2 ∧ ((• • ¬F 2 ) S w F 1 )) iff t |= F 2 and (t |= F 1 or t n-1 |= ¬F 2 and t n-1 |= (• • ¬F 2 ) S w F 1 ) iff t |= F 2 and (t |= F 1 or t |= • • ¬F 2 and t n-1 |= (• • ¬F 2 ) S w F 1 ) iff (by the recursive semantics) t |= F 2 and t |= (• • ¬F 2 ) S w F 1 iff t |= ¬F 2 ∧ ((• • ¬F 2 ) S w F 1 ). Therefore, [F 1 , F 2 ) w = ¬F 2 ∧ ((• • ¬F 2 ) S w F 1 ).</formula><p>The equivalences of the 12 logics with ptLTL follow now immediately. For example, to show the eighth logic, ptLTL {↑,[)s} , equivalent to ptLTL, one needs to show how the operators ↑ and [_, _) s can define all the other pasttime temporal operators. This is straightforward because property 11 shows how ↓ can be defined in terms of ↑, 15</p><p>shows how • • F can be defined using just ↑ and ↓, 16 defines S s , 1 defines • , 2 • , 3 S w , and 13 the weak interval. The interested reader can check the other 11 equivalences of the logics.</p><p>Unlike in theoretical research, in practical monitoring of programs we want to have as many temporal operators available as possible and not to automatically translate them into a reduced kernel set. The reason is twofold. On the one hand, the more operators that are available, the more succinct and natural the task of writing requirement specifications. On the other hand, as seen later in the paper, additional memory is needed for each temporal operator, so we want to keep the formulae as concise as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Monitoring safety by rewriting</head><p>The architecture of JPaX is such that events extracted from a running program are sent to an observer that decides whether or not requirements are violated. An important concern that we had and are still having at this relatively incipient stage of JPaX is whether the chosen monitoring logics are expressive enough to specify powerful, practical, and interesting requirements. Since flexibility with respect to defining/modifying monitoring logics is a very important factor at this stage, we have developed a rewriting-based framework that allows one to easily and effectively define new logics for runtime analysis and to monitor execution traces against formulae in these logics. We use the rewriting system Maude as a basis for this framework. In the next four subsections, we present Maude and describe how formulae and important data structures are represented in Maude. Then we describe how basic propositional calculus is defined in Maude, and then how ptLTL is defined. Finally, it is described how this Maude definition of ptLTL is used for monitoring requirements stated by the user on execution traces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Maude</head><p>We have implemented our logic-defining framework by rewriting in Maude <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref>. Maude is a modularized membership equational <ref type="bibr" target="#b30">[31]</ref> and rewriting logic <ref type="bibr" target="#b29">[30]</ref> specification and verification system whose operational engine is based mainly on a very efficient implementation of rewriting. A Maude module consists of sort and operator declarations as well as equations relating terms over the operators and universally quantified variables. Modules can be composed in a hierarchical manner, building new theories from old theories. A particularly attractive aspect of Maude is its mix-fix notation for syntax, which, together with precedence attributes of operators, gives us an elegant way of compactly defining the syntax of logics. For example, the operation declarations define a simple syntax over the sort Expression, where conjunction and disjunction are infix operators (the underscores stand for arguments whose sorts are listed after the colon), while the interval and the conditional are mix-fix: operator and arguments can be mixed. Conjunction binds tighter than disjunction because it has a lower precedence (the lower the precedence the tighter the binding), so one is relieved of having to add useless parentheses to one's formulae.</p><p>It is often the case that equational and/or rewriting logics act like foundational logics, in the sense that other logics, or more precisely their syntax and operational semantics, can be expressed and efficiently executed by rewriting, so we regard Maude as a good choice to develop and prototype with various monitoring logics. The Maude implementations of the current logics supported by JPaX are quite compact. They are based on a simple, general architecture to define new logics, which we only describe informally in the next subsection. Maude's notation will be introduced "on the fly" as needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Formulae and data structures</head><p>We have defined a generic module, called FORMULA, that defines the infrastructure for all the user-defined logics. Its Maude code is rather technical and so will not be given here. The module FORMULA includes some designated basic sorts, such as Formula for syntactic formulae, FormulaDS for formula data structures needed when more information than the formula itself should be stored for the next transition as in the case of past-time LTL, Atom for atomic propositions (or state variables), AtomState for assignments of boolean values to atoms, also called "states", and AtomState* for such assignments together with final assignments, i.e., those that are followed by the end of a trace, sometimes requiring a special evaluation procedure. A state As is made terminal by applying to it a unary operator, _* : AtomState -&gt; AtomState*. Formula is a subsort of FormulaDS because there are logics in which no extra information but a modified formula needs to be carried over for the next iteration (such as future-time LTL, which is also provided by JPaX). There are two constants of the sort Formula provided, namely, true and false, with the obvious meanings. The propositions that hold in a certain program state are generated by the executing instrumented program.</p><p>One of the most important operators in FORMULA is _{_}:FormulaDS AtomState* -&gt; FormulaDS, which updates the formula data structure when an (abstract) state change occurs during the execution of the program. Notice the use of mix-fix notation for the operator declaration in which underscores represent places of arguments, their order being the one in the arity of the operator. On atomic propositions, say, A, the module FORMULA defines the "update" operator as follows: A{As*} is true or false depending on whether As* assigns true or false to the atom A, where As* is an atom state (i.e., an assignment from atoms to boolean values), which is either a terminal state (the last in a trace) or not. In the case of propositional calculus, this update operation basically evaluates propositions in the new state. For other logics, it can be more complicated, depending on their trace semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Propositional calculus</head><p>Propositional calculus should be included in any monitoring logic. Therefore, we begin with the following module, which is heavily used in JPaX. It implements an efficient rewriting procedure devised by Hsiang <ref type="bibr" target="#b22">[23]</ref> to decide the validity of propositions, reducing any boolean expression to an exclusive disjunction (formally written _++_) of conjunctions (_/\_):</p><p>fmod PROP-CALC is extending FORMULA . *** Constructors *** op _/\_ : Formula Formula -&gt; Formula [assoc comm] . op _++_ : Formula Formula -&gt; Formula [assoc comm] .</p><p>vars X Y Z : Formula . var As* : AtomState* . eq true /\ X = X . eq false /\ X = false . eq false ++ X = X . eq X ++ X = false . eq X /\ X = X . eq X /\ (Y ++ Z) = (X /\ Y) ++ (X /\ Z) .</p><p>*** Derived operators *** op _\/_ : Formula Formula -&gt; Formula . op _-&gt;_ : Formula Formula -&gt; Formula . op _&lt;-&gt;_ : Formula Formula -&gt; Formula . op !_ : Formula -&gt; Formula . eq X \/ Y = (X /\ Y) ++ X ++ Y . eq ! X = true ++ X . eq X -&gt; Y = true ++ X ++ (X /\ Y) . eq X &lt;-&gt; Y = true ++ X ++ Y . *** Operational Semantics eq (X /\ Y){As*} = X{As*} /\ Y{As*} . eq (X ++ Y){As*} = X{As*} ++ Y{As*} endfm</p><p>In Maude, operators are introduced after the op and ops (when more than one operator is introduced) symbols. Operators can be given attributes in square brackets, such as associativity and commutativity. Universally quantified variables used in equations are introduced after the var and vars symbols. Finally, equations are introduced after the eq symbol. The specification of the simple propositional calculus above shows the flexibility of the mix-fix notation of Maude, which allows us to define the syntax of a logic in the most natural way.</p><p>The equations above are interpreted as rewriting rules by Maude, so they will be applied from left to right only. However, due to the associativity and commutativity attributes, rewrites as well as matchings are applied modulo associativity and commutativity (AC), making the procedure implied by the rewrite rules for propositional calculus above highly nontrivial. As proved by Hsiang <ref type="bibr" target="#b22">[23]</ref>, the AC rewriting system above has the property that any proposition is reduced to true or false if it is semantically true or false, or otherwise to a canonical form modulo AC; thus two formulae are equivalent if and only if their canonical forms are equal modulo AC. We found this procedure quite convenient so far, as we were able to efficiently reduce formulae of hundreds of symbols that occurred in practical examples. However, one should of course not expect this procedure to work efficiently on any proposition because the propositional validity problem is NP-complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Past-time linear temporal logic</head><p>Past-time LTL can now be implemented on top of the provided logic-defining framework. Our rewriting-based implementation below follows the recursive semantics of ptLTL defined in Sect. 3.3, and it appears similar to the Java implementation used in <ref type="bibr" target="#b25">[26]</ref>. We next explain the PT-LTL module in detail.</p><p>We start by defining the syntax of ptLTL. Since it extends the module PROP-CALC of propositional calculus, we only have to define syntax for the temporal operators: fmod PT-LTL is extending PROP-CALC . op (*)_ : Formula -&gt; Formula . *** previously op &lt;*&gt;_ : Formula -&gt; Formula .</p><p>*** eventually in the past op [*]_ : Formula -&gt; Formula .</p><p>*** always in the past op _Ss_ : Formula Formula -&gt; Formula .</p><p>*** strong since op _Sw_ : Formula Formula -&gt; Formula .</p><p>*** weak since op start : Formula -&gt; Formula .</p><p>*** start op end : Formula -&gt; Formula . *** end op [_,_}s : Formula Formula -&gt; Formula .</p><p>*** strong interval op [_,_}w : Formula Formula -&gt; Formula .</p><p>*** weak interval</p><p>We have used a curly bracket to close the intervals because for some technical parsing-related reasons, Maude does not allow unbalanced parentheses in its terms. The syntax above can now be used by users to write monitoring requirements as formulae. These formulae are loaded by JPaXat initialization and then sent to Maude for parsing and processing. When the first event from the instrumented program is received by JPaX, it sends this event to Maude to initialize its monitoring data structures associated with its formulae (remember that the recursive definition of ptLTL in Sect. 3.3 treats the first event of the trace differently). This is done by launching the reduction mkDS(F, As) in Maude, where F is the formula to monitor and As is the atom state abstracting the first event generated by the monitored program; mkDS is an abbreviation for "make data structure" and is defined below.</p><p>Before we define the operation mkDS we first discuss the formula data structures storing not only the formulae but also their current satisfaction status. It is worth noting that the strong and weak temporal operators have exactly the same recursive semantics starting with the second event. This suggests that we do not need nodes of different types (strong and weak) in the formula data structure once the monitoring process is initialized: the difference between strong and weak versions of an operator are rather represented by the initial values passed as arguments to a single common version of the operator. The following operation declarations therefore define the constructors for these data structures: The first operation defines a cell storing an atomic proposition together with its observed boolean value, while the next two store conjunction and exclusive disjunction nodes. According to the propositional calculus procedure defined in module PROP-CALC in Sect. 4.3, these are the only propositional operators that can occur in reduced formulae. The remaining operators are the seven past-time temporal operators introduced so far.</p><p>An operator that extracts the boolean value associated with a temporal formula is needed in the sequel, so we define it next. The syntax of this operator is [_] : FormulaDS -&gt; Bool and is defined in the module FORMULA together with its obvious equations The operation mkDS can be defined now. It basically follows the recursive semantics in Sect. 3.3, when the length of the trace is 1: vars X Y : Formula . op mkDS : Formula AtomState -&gt; FormulaDS . eq mkDS(true, As) = true . eq mkDS(false, As) = false . eq mkDS(A, As) = atom(A, (A{As} == true)) . eq mkDS(X /\ Y, As) = and(mkDS(X,As), mkDS(Y,As), [mkDS(X,As)] and [mkDS(X,As)]) . eq mkDS(X ++ Y, As) = xor(mkDS(X,As), mkDS(Y,As), [mkDS(X,As)] xor [mkDS(X,As)]) . eq mkDS( (*)X, As) = previously(mkDS(X, As), [mkDS(X, As)]) . eq mkDS( &lt;*&gt;X, As) = eventuallyPast(mkDS(X, As), [mkDS(X, As)]) . eq mkDS( [*]X, As) = alwaysPast(mkDS(X, As), [mkDS(X, As)]) . eq mkDS(X Ss Y, As) = since(mkDS(X,As), mkDS(Y,As), [mkDS(Y,As)]) . eq mkDS(X Sw Y, As) = since(mkDS(X,As), mkDS(Y,As), [mkDS(X,As)] or [mkDS(Y,As)]) . eq mkDS(start(X), As) = start(mkDS(X,As),false) . eq mkDS(end(X), As) = end(mkDS(X,As), false) . eq mkDS([X,Y}s, As) = interval(mkDS(X,As), mkDS(Y,As), [mkDS(Y,As)] and not [mkDS(Y,As)]) . eq mkDS([X,Y}w, As) = interval(mkDS(X,As), mkDS(Y,As), not [mkDS(Y,As)]) .</p><p>The data structure associated with a past-time formula is essentially its syntax tree augmented with a boolean bit for each node. Each boolean bit will store the result of the satisfaction relation between the current execution trace and the corresponding subformula. The only thing left is to define how the formula data structures, or more precisely their bits, change when a new event is received. This is defined below, using the operator _{_} : FormulaDS AtomState -&gt; FormulaDS provided by the module Formula: eq atom(A, B){As} = atom(A, (A{As} == true)) . The operator _==_ is built in and takes two terms of the same sort, reduces them to their normal forms, and returns true if they are equal, and false otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Monitoring with Maude</head><p>In this subsection, we give more details on how the actual rewriting-based monitoring process works. When the JPaX system is started, the user is supposed to have already specified several formulae in a file containing monitoring requirements. The first thing JPaX does is to start a Maude process, load the ptLTL semantics described above, and then set Maude to run in its loop mode, which is an execution mode in which Maude maintains a state term that the user (potentially another process such as JPaX) can modify interactively. Then JPaX sends Maude all the formulae that the user wants to monitor. Maude stores them in its loop state and waits for JPaX to send events. Note that the above is general and applies to any logic.</p><p>When JPaX receives the first event from the instrumented program that is relevant for the ptLTL analysis module, it just sends it to Maude. On receiving the first event, say, As, Maude needs to generate the formula data structures for all the formulae to be monitored. It does so by replacing each formula F in the loop state by the normal form of the term mkDS(F, As). Then it waits for JPaX to submit further events. Each time a new relevant event As is received by JPaX from the instrumented program, it just forwards it to Maude. Then Maude replaces each formula data structure D in its loop state by D{As} and waits for further events. If at any moment <ref type="bibr">[D]</ref> is false for the data structure D associated with a formula F, then Maude sends an error message to JPaX, which further warns the user appropriately.</p><p>It should be obvious that the runtime complexity of the rewriting monitoring algorithm is O(m) to process an event, where m is the size of the ptLTL formula to monitor. That is, the algorithm only needs to traverse the data structure representing the formula bottom up for each new event and update one bit in each node. So the overall runtime complexity is O(n • m), where n is the number of events to be monitored. This is the best one can asymptotically hope for from a runtime monitoring algorithm, but of course there is room for even faster algorithms in practical situations, as the one presented in the next section demonstrates. The main benefit of the rewriting algorithm presented in this section is that it falls under the general frame-work by which one can easily add or experiment with new monitoring logics within the JPaX system.</p><p>The Maude code performing the above steps is relatively straightforward but rather ugly, so we prefer not to present it here. Additionally, Maude's support for interprocess communication is slated to be changed soon, so this code would soon become obsolete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Synthesizing monitors for safety properties</head><p>The rewriting algorithm above is a very good choice in the context of the current version of JPaX because it gives us flexibility and is efficient enough to process events at a faster rate than they can actually be sent by JPaX. However, there might be situations in which a full-scale AC rewriting engine like Maude is not available, such as within an embedded system, or in which as little runtime overhead as possible is allowed, such as in realtime applications. In this section, we present a dynamic programming-based algorithm, also based on the recursive semantics of past-time LTL in Sect. 3.3, that takes as input a formula and generates source code that can further be compiled into an efficient executable monitor for that formula. This algorithm can be used in two different ways. On the one hand, it can be used as an efficient external monitor to take an action when a formula is violated, such as to report an error to a user, to reboot the system, to send a message, or even to generate a correcting task. On the other hand, it can be used in a context in which one allows past-time LTL annotations in the source code of a program, where the logical annotations can be expanded into source code that is further compiled together with the original program. These two use modes, offline vs. inline, are further explained in Sect. 5.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The algorithm illustrated by an example</head><p>In this section, we show via an example how to generate dynamic programming code for a concrete ptLTL formula. We think that this example would be sufficient in practical terms for the reader to foresee our general algorithm presented in the next subsection. Let ↑ p → [q, ↓ (r ∨ s)) s be the ptLTL formula that we want to generate code for. The formula states: "whenever p becomes true, then q has been true in the past, and since then we have not yet seen the end of r or s". The code translation depends on an enumeration of the subformulae of the formula that satisfies the enumeration invariant: any formula has an enumeration number smaller than the numbers of all its subformulae. Let ϕ 0 , ϕ 1 , . . . , ϕ 8 be such an enumeration:</p><formula xml:id="formula_10">ϕ 0 =↑ p → [q, ↓ (r ∨ s)) s , ϕ 1 =↑ p, ϕ 2 =p, ϕ 3 =[q, ↓ (r ∨ s)) s , ϕ 4 =q, ϕ 5 =↓ (r ∨ s), ϕ 6 =r ∨ s, ϕ 7 =r, ϕ 8 =s.</formula><p>Note that the formulae have been enumerated here in a postorder fashion. One could have chosen a breadthfirst order, or any other enumeration, as long as the enumeration invariant was true.</p><p>The input to the generated program will be a finite trace t = s 1 s 2 . . . s n of n events. The generated program will maintain a state via a function update : State × Event → State, which updates the state with a given event.</p><p>To illustrate the dynamic programming aspect of the solution, one can imagine recursively defining a matrix s[1..n, 0..8] of boolean values {0, 1}, with the meaning that s[i, j] = 1 iff t i |= ϕ j . Then one can fill the table according to the recursive semantics of ptLTL as described in Sect. 3.3. This would be the standard way of regarding the above satisfaction problem as a dynamic programming problem. An important observation is, however, that, as in many other dynamic programming algorithms, one does not have to store the entire  <ref type="bibr" target="#b5">[6]</ref> ← pre <ref type="bibr" target="#b6">[7]</ref> or pre <ref type="bibr" target="#b7">[8]</ref>; pre <ref type="bibr" target="#b4">[5]</ref> ← false; pre <ref type="bibr" target="#b3">[4]</ref> ← q(state); pre <ref type="bibr" target="#b2">[3]</ref> ← pre <ref type="bibr" target="#b3">[4]</ref> and not pre <ref type="bibr" target="#b4">[5]</ref>; pre <ref type="bibr" target="#b1">[2]</ref> ← p(state); pre <ref type="bibr" target="#b0">[1]</ref> ← false; pre[0] ← not pre <ref type="bibr" target="#b0">[1]</ref> or pre <ref type="bibr" target="#b2">[3]</ref>; /* Event interpretation loop */ for i = 2 to n do { state ← update(state, s i ); now <ref type="bibr" target="#b7">[8]</ref> ← s(state); now <ref type="bibr" target="#b6">[7]</ref> ← r(state); now <ref type="bibr" target="#b5">[6]</ref> ← now <ref type="bibr" target="#b6">[7]</ref> or now <ref type="bibr" target="#b7">[8]</ref>; now <ref type="bibr" target="#b4">[5]</ref> ← not now <ref type="bibr" target="#b5">[6]</ref> and pre <ref type="bibr" target="#b5">[6]</ref>; now <ref type="bibr" target="#b3">[4]</ref> ← q(state); now <ref type="bibr" target="#b2">[3]</ref> ← (pre <ref type="bibr" target="#b2">[3]</ref> or now <ref type="bibr" target="#b3">[4]</ref>) and not now <ref type="bibr" target="#b4">[5]</ref>; now <ref type="bibr" target="#b1">[2]</ref> ← p(state); now <ref type="bibr" target="#b0">[1]</ref> ← now <ref type="bibr" target="#b1">[2]</ref> and not pre <ref type="bibr" target="#b1">[2]</ref>; now[0] ← not now <ref type="bibr" target="#b0">[1]</ref> or now <ref type="bibr" target="#b2">[3]</ref>;</p><p>if now[0] = 0 then output(''property violated''); pre ← now;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>};</head><p>In what follows, we explain the generated program.</p><p>Declarations. Initially a state is declared. This will be updated as the input event list is processed. Next, the two arrays pre and now are declared. The pre array will contain values of all subformulae in the previous state, while now will contain the value of all subformulae in the current state. Initialization. The initialization phase consists of initializing the state variable and the pre array. The first event s 1 of the event list is used to initialize the state variable. The pre array is initialized by evaluating all subformulae bottom up, starting with the highest formula numbers, and assigning these values to the corresponding elements of the pre array; hence, for any i ∈ {0 . . . 8}, pre[i] is assigned the initial value of formula ϕ i . The pre array is initialized in such a way as to maintain the view that the initial state is assumed to be stationary before monitoring is started. This in particular means that ↑ p is false, as is ↓ (r ∨ s), since there is no change in state (indices 1 and 5). The interval operator has the obvious initial interpretation: the first argument must be true and the second false for the formula to be true (index 3). Propositions are true if they hold in the initial state (indices 2, 4, 7, and 8) and boolean operators are interpreted in the standard way (indices 0, 6). Event loop. The main evaluation loop goes through the event trace, starting from the second event. For each such event, the state is updated, followed by assignments to the now array in a bottom-up fashion similar to the initialization of the pre array: the array elements are assigned values from higher index values to lower index values, corresponding to the values of the corresponding subformulae. Propositional boolean operators are interpreted in the standard way (indices 0 and 6). The formula ↑ p is true if p is true now and not true in the previous state (index 1). Similar reasoning can be applied to the formula ↓ (r ∨ s) (index 5). The formula [q, ↓ (r ∨ s)) s is true if either the formula was true in the previous state or q is true in the current state and in addition ↓ (r ∨ s) is not true in the current state (index 3). At the end of the loop an error message is issued if now[0], the value of the whole formula, has the value 0 in the current state. Finally, the entire now array is copied into pre.</p><p>Given a fixed ptLTL formula, the analysis of this algorithm is straightforward. Its time complexity is Θ(n), where n is the length of the input trace, the constant being given by the size of the ptLTL formula. The memory required is constant since the length of the two arrays is the size of the ptLTL formula. However, one may want to also include the size of the formula, say, m, into the analy-sis; then the time complexity is obviously Θ(n • m) while memory required is 2 • (m + 1) bits. The authors conjecture that in practical situations it is hard to find an algorithm running faster than the above algorithm, though some slight optimizations are possible (see Sect. 5.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The algorithm formalized</head><p>We now formally describe our algorithm, which synthesizes a dynamic programming algorithm from a ptLTL formula. It takes as input a formula and generates a program like the one above, containing a "for" loop that traverses the trace of events while validating or invalidating the formula. The generated program is printed using the function output, which takes one or more string or integer parameters that are concatenated in the output. This algorithm is designed to generate pseudocode, but it can easily be adapted to generate code in any imperative programming language: output(" now [", j, "] ← "); if ϕ j is a variable then output(ϕ j , "(state);"); if ϕ j is true then output("true;"); if ϕ j is false then output("false;"); if ϕ j = ¬ϕ j then output("not now [",j , "];"); if ϕ j = ϕ j 1 op ϕ j 2 then output("now [",j 1 , "] op now [", j 2 , "];"); if ϕ j = • • ϕ j 1 then output("pre[", j 1 , "];"); if ϕ j = • ϕ j 1 then output("pre[", j, "] or now [",j 1 , "]"); if ϕ j = • ϕ j 1 then output("pre[", j, "] and now [",j 1 , "]"); if ϕ j = ϕ j 1 S s ϕ j 2 then output("(pre[", j, "] and now [",j 1 , "]) or now [", j 2 , "];"); if ϕ j = ϕ j 1 S w ϕ j 2 then output("(pre[", j, "] and now [",j 1 , "]) or now [", j 2 , "];"); if ϕ j = [ϕ j 1 , ϕ j 2 ) s then output("(pre[", j, "] or now [",j 1 , "]) and not now [", j 2 , "];"); if ϕ j = [ϕ j 1 , ϕ j 2 ) w then output("(pre[", j, "] or now [",j 1 , "]) and not now [", j 2 , "];"); if ϕ j =↑ ϕ j then output("now [", j , "] and not pre[", j , "];"); if ϕ j =↓ ϕ j then output("not now [", j , "] and pre[", j , "];"); }; output(" if now[0] = 0 then output(''property violated'');"); output(" pre ← now ;"); output("}"); op is any binary propositional connective. Since we have already given a detailed explanation of the example in the previous section, we shall only give a very brief description of this algorithm.</p><p>The formula should be first visited top down to assign increasing numbers to subformulae as they are visited. Let ϕ 0 , ϕ 1 , ..., ϕ m be the list of all subformulae. Because of the recursive nature of ptLTL, this step ensures us that the truth value of t i |= ϕ j can be completely determined from the truth values of t i |= ϕ j for all j &lt; j ≤ m and the truth values of t i-1 |= ϕ j for all j ≤ j ≤ m.</p><p>Before we generate the main loop, we should first generate code for initializing the array pre[0..m], basically giving it the truth values of the subformulae on the initial state, which is conceptually an infinite trace with repeated occurrences of the initial state. After that, the generated main event loop will process the events. The loop body will update/calculate the now array and in the end will move it into the pre array to serve as the basis for the next iteration. After each iteration i, now[0] tells whether the formula is validated by the trace s 1 s 2 ...s i .</p><p>Since the formula enumeration procedure is linear, the algorithm synthesizes a dynamic programming algorithm from a ptLTL formula in linear time with the size of the formula. The boolean operations used above are usually very efficiently implemented on any microprocessor, and the arrays of bits pre and now are small enough to be kept in cache. Moreover, the dependencies between instructions in the generated "for" loop are simple to analyze, so a reasonable compiler can easily unfold and/or parallelize it to take advantage of a machine's resources. Consequently, the generated code is expected to run very fast. We shall next illustrate how such optimizations can be part of the translation algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Optimizing the generated code</head><p>The generated code presented in Sect. 5.1 is not optimal. Even though a smart compiler can in principle generate good machine code from it, it is still worth exploring ways to synthesize directly optimized code especially because there are some attributes specific to the runtime observer that a compiler cannot take into consideration.</p><p>A first observation is that not all the bits in pre are needed but only those that are used at the next iteration, namely 2, 3, and 6. Therefore, only a bit per temporal operator is needed, which reduces significantly the memory required by the generated algorithm. Then the body of the generated "for" loop becomes after (blind) substitution (we do not consider the initialization code here):</p><p>state ← update(state, s i ) now <ref type="bibr" target="#b2">[3]</ref> ← r(state) or s(state) now[2] ← (pre <ref type="bibr" target="#b1">[2]</ref> or q(state)) and not (not now <ref type="bibr" target="#b2">[3]</ref> and pre <ref type="bibr" target="#b2">[3]</ref>) now <ref type="bibr" target="#b0">[1]</ref> ← p(state) if ((not (now <ref type="bibr" target="#b0">[1]</ref> and not pre <ref type="bibr" target="#b0">[1]</ref>) or now <ref type="bibr" target="#b1">[2]</ref>) = 0) then output(''property violated''); that can be further optimized by boolean simplifications: state ← update(state, s i ) now <ref type="bibr" target="#b2">[3]</ref> ← r(state) or s(state) now[2] ← (pre <ref type="bibr" target="#b1">[2]</ref> or q(state)) and (now <ref type="bibr" target="#b2">[3]</ref> or not pre <ref type="bibr" target="#b2">[3]</ref>) now <ref type="bibr" target="#b0">[1]</ref> ← p(state) if (now <ref type="bibr" target="#b0">[1]</ref> and not pre <ref type="bibr" target="#b0">[1]</ref> and not now <ref type="bibr" target="#b1">[2]</ref>) then output(''property violated''); The most expensive part of the code above is the function calls, namely, p(state), q(state), r(state), and s(state). Depending on the runtime requirements, the execution time of these functions may vary significantly. However, since one of the major concerns of monitoring is to affect the normal execution of the monitored program as little as possible, especially in the inline monitoring approach, one would of course want to evaluate the atomic predicates on states only if really needed, or rather to evaluate only those that, probabilistically, add a minimum cost. Since we do not want to count on an optimizing compiler, we prefer to store the boolean formula even throw exceptions when a safety property is violated, as in Temporal Rover <ref type="bibr" target="#b9">[10]</ref>, so the running program has the possibility to recover from an erroneous execution or to guide its execution to avoid undesired behaviors.</p><p>To provide support for inline monitoring, we developed some simple scripts that replace temporal annotations in Java source code by actual monitoring code, which throws an exception when the formula is violated. In <ref type="bibr" target="#b13">[14]</ref>, we show an example of expanded code for futuretime LTL. The "for" loop and the update of the state in the generic algorithm in Sect. 5.1 are not needed anymore because the atomic predicates use directly the current state of the program when the expanded code is reached during the execution. In <ref type="bibr" target="#b3">[4]</ref>, the tool Java-MoP is described, which implements the presented algorithm as a logic plug-in for inline monitoring (as well as for offline monitoring).</p><p>The following code snippets illustrate the inline approach. Assume a class A that defines four integer variables and a method m that contains the past-time temporal logic formula from above. Now the propositions p, q, r, and s are defined to refer to the four variables. The intention is that whenever the program point of the comment is reached, the formula will be evaluated. void m(){ ... now <ref type="bibr" target="#b7">[8]</ref> = d&gt;0; now <ref type="bibr" target="#b6">[7]</ref> = c&gt;0; now <ref type="bibr" target="#b5">[6]</ref> = now <ref type="bibr" target="#b6">[7]</ref> || now <ref type="bibr" target="#b7">[8]</ref>; now <ref type="bibr" target="#b4">[5]</ref> = !now <ref type="bibr" target="#b5">[6]</ref> &amp;&amp; pre <ref type="bibr" target="#b5">[6]</ref>; now <ref type="bibr" target="#b3">[4]</ref> = b&gt;0; now <ref type="bibr" target="#b2">[3]</ref> = (pre <ref type="bibr" target="#b2">[3]</ref> || now <ref type="bibr" target="#b3">[4]</ref>) &amp;&amp; !now <ref type="bibr" target="#b4">[5]</ref>; now <ref type="bibr" target="#b1">[2]</ref> = a&gt;0; now <ref type="bibr" target="#b0">[1]</ref> = now <ref type="bibr" target="#b1">[2]</ref> &amp;&amp; !pre <ref type="bibr" target="#b1">[2]</ref>; now[0] = !now <ref type="bibr" target="#b0">[1]</ref> || now <ref type="bibr" target="#b2">[3]</ref>; System.arraycopy(now,0,pre,0,9); if(!now[0])throw Violated("P"); ... } } It is essentially the same code as in the offline case except that the looping constructs have been removed.</p><p>It is inline monitoring that motivated us to optimize the generated code as much as possible as in Sect. 5.3. Since the running program and the monitor are a single process now, the time needed to execute the monitoring code can significantly influence the otherwise normal execution of the monitored program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Two efficient algorithms for monitoring safety requirements expressed using past-time linear temporal logic were presented, one based on rewriting and implemented in Maude and the other based on dynamic programming, synthesizing specialized monitors from formulae. They both check that a finite sequence of events emitted by a running program satisfies a formula. Operators convenient for monitoring were considered and shown to be equivalent to standard past-time temporal operators.</p><p>These algorithms have been implemented in PathExplorer, a runtime verification tool currently under development. The synthesis algorithm has also been implemented (as a plug-in) in the Java-MoP tool <ref type="bibr" target="#b3">[4]</ref>, which is a general framework for supporting program monitoring for user-provided logics; and in the JMPaX tool <ref type="bibr" target="#b34">[35]</ref>, which extends part of this work to partial-order models instead of simple traces.</p><p>It is our intention to investigate how the presented algorithms can be refined to work for a logic that combines past-and future-time temporal logic and that can refer to real-time and data values. Other kinds of runtime verification are also investigated such as, for example, techniques for detecting error potentials in multithreaded programs. Recent work on detecting high-level data races is described in <ref type="bibr" target="#b1">[2]</ref>.</p><p>A number of experiments have been carried out with PathExplorer on a planetary rover application written in 35,000 lines of C++. The experiments range from concurrency analysis (deadlock and data race analysis) to mon-itoring of temporal logic formulae combined with testcase generation, as described in <ref type="bibr" target="#b0">[1]</ref>. A model checker is used to generate test cases, where a test case consists of input to the application plus a set of temporal formulae that the execution of the application on that input must satisfy. When running this testing environment, hundreds of test cases are generated, and the execution of these are monitored against the generated formulae. Initial experiments have been made with a logic that combines past-and future-time temporal logic and supports real-time and data reasoning. A bug was detected in the rover application in the very first such experiment we made. A thread did not detect a premature termination of a certain task in a timely manner. The programmer had forgotten to insert this termination check and was reminded by a single run of the testing environment. It is planned to have this testing environment become part of the rover application programmer's testing toolbox.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Recursive semantics of finite trace past time LTL</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>[true] = true and [false] = false. Its definition on temporal and propositional and temporal operators follows: var A : Atom . var B : Bool . vars D Dx Dy : FormulaDS . eq [and(Dx,Dy,B)] = B . eq [xor(Dx,Dy,B)] = B . eq [atom(A,B)] = B . eq [previously(D,B)] = B . eq [eventuallyPast(D,B)] = B . eq [alwaysPast(D,B)] = B . eq [since(Dx,Dy,B)] = B . eq [interval(Dx,Dy,B)] = B . eq [start(Dx,B)] = B . eq [end(Dx,B)] = B .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>eq and(Dx, Dy, B){As} = and(Dx{As}, Dy{As},[Dx{As}] and [Dy{As}]) . eq xor(Dx, Dy, B){As} = xor(Dx{As}, Dy{As},[Dx{As}] xor [Dy{As}]) . eq previously(D,B){As} = previously(D{As},[D]) . eq eventuallyPast(D, B){As} = eventuallyPast(D{As}, [D{As}] or B) . eq alwaysPast(D, B){As} = alwaysPast(D{As}, [D{As}] and B) . eq since(Dx, Dy, B){As} = since(Dx{As}, Dy{As}, [Dy{As}] or [Dx{As}] and B) . eq start(Dx,B){As} = start(Dx{As}, [Dx{As}] and not B) . eq end(Dx,B){As} = end(Dx{As}, not [Dx{As}] and B) . eq interval(Dx, Dy, B){As} = interval(Dx{As}, Dy{As}, not [Dy{As}] and ([Dx{As}] or B)) . endfm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>table s[1..n, 0..8], which would be quite large in practice; in this case, one needs only s[i, 0..8] and s[i -1, 0..8], which we will henceforth write as now [0..8] and pre[0..8], respectively. It is now only a relatively simple exercise to write up the following algorithm for checking the above formula on a finite trace: Input: trace t = s 1 s 2 ...s n ; /* Initialization of state and pre */ state ← update(state, s 1 );</figDesc><table><row><cell>State state ← {};</cell></row><row><cell>bit pre[0..8];</cell></row><row><cell>bit now[0..8];</cell></row><row><cell>pre[8] ← s(state);</cell></row><row><cell>pre[7] ← r(state);</cell></row><row><cell>pre</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The implementation details of TR are not available to the general public.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>These declarations are artificial and intended to explain some of Maude's features; they will not be needed later in the paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>An abstract class is a class where some methods are abstract because they have no body. Implementations for these methods will be provided in extending subclasses.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Input: past-time LTL formula ϕ let ϕ 0 , ϕ 1 , ..., ϕ m be the subformulae of ϕ; output("State state ← {};"); output("bit pre[0..m];"); output("bit now[0..m];"); output("Input: trace t = s 1 s 2 ...s n ;"); output("/* Initialization of state and pre */"); output("state ← update(state, s 1 );"); for j = m downto 0 do { output(" pre[", j, "] ← "); if ϕ j is a variable then output(ϕ j , "(state);"); if ϕ j is true then output("true;"); if ϕ j is false then output("false;"); if ϕ j = ¬ϕ j then output("not pre[",j , "];"); if ϕ j = ϕ j 1 op ϕ j 2 then output("pre[",j 1 , "] op pre[",j 2 , "];"); if ϕ j = • • ϕ j 1 then output("pre[", j 1 , "];"); if ϕ j = • ϕ j 1 then output("pre[", j 1 , "];"); if ϕ j = • ϕ j 1 then output("pre[", j 1 , "];"); if ϕ j = ϕ j 1 S s ϕ j 2 then output("pre[", j 2 , "];"); if ϕ j = ϕ j 1 S w ϕ j 2 then output("pre[",j 1 , "] or pre[", j 2 , "];"); if ϕ j = [ϕ j 1 , ϕ j 2 ) s then output("pre[",j 1 , "] and not pre[", j 2 , "];"); if ϕ j = [ϕ j 1 , ϕ j 2 ) w then output("not pre[", j 2 , "];"); if ϕ j =↑ ϕ j then output("false;"); if ϕ j =↓ ϕ j then output("false;"); }; output("/* Event interpretation loop */"); output("for i = 2 to n do {"); for j = m downto 0 do { as some kind of binary decision diagram, more precisely as a term over the conditional operation _?_ : _, where "e 1 ?e 2 : e 3 " means: "if e 1 then e 2 else e 3 ". For example, pre <ref type="bibr" target="#b2">[3]</ref> ? pre <ref type="bibr" target="#b1">[2]</ref> ? now <ref type="bibr" target="#b2">[3]</ref> : q(state) : pre <ref type="bibr" target="#b1">[2]</ref> ? 1 : q(state) (see <ref type="bibr" target="#b17">[18]</ref> for a formal definition). Therefore, one is faced with the following optimization problem:</p><p>Given a boolean formula ϕ using propositions a 1 , a 2 , ..., a n of costs c 1 , c 2 , ..., c n , respectively, find a (_?_ : _)-expression that optimally implements ϕ. We have implemented a procedure in Maude, on top of propositional calculus, that generates all correct (_?_ : _) expressions for ϕ, admittedly a potentially exponential number in the number of distinct atomic propositions in ϕ, and then chooses the shortest in size, ignoring the costs. Applied on the code above, it yields:</p><p>state ← update(state, s i ) now <ref type="bibr" target="#b2">[3]</ref> ← r(state) ? 1 : s(state) now <ref type="bibr" target="#b1">[2]</ref> ← pre <ref type="bibr" target="#b2">[3]</ref> ? pre <ref type="bibr" target="#b1">[2]</ref> ? now <ref type="bibr" target="#b2">[3]</ref> : q(state) : pre[2] ? 1 : q(state) now <ref type="bibr" target="#b0">[1]</ref> ← p(state) if (pre <ref type="bibr" target="#b0">[1]</ref> ? 0 : now <ref type="bibr" target="#b1">[2]</ref> ? 0 : now <ref type="bibr" target="#b0">[1]</ref>) then output(''property violated''); We would like to extend our procedure to take the evaluation costs of predicates into consideration. These costs can be provided by the user of the system, calculated automatically by a static analysis of predicates' code, or even estimated by executing the predicates on a sample of states. However, based on our examples so far, we conjecture at this incipient stage that, given a boolean formula ϕ in which all the atomic propositions have the same cost, the probabilistically runtime optimal (_?_ : _)-expression implementing ϕ is exactly the one that is smallest in size.</p><p>A further optimization would be to generate machine code directly instead of using a compiler. Then the arrays of bits now and pre can be stored in two registers, which would be all the memory needed. Since all the operations executed are bit operations, the generated code is expected to be very fast. One could even imagine hardware implementations of past-time monitors, using the same ideas, to enforce safety requirements on physical devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Implementation of offline and inline monitoring</head><p>In this section, we briefly describe our efforts to implement the above-described algorithm to create monitors for observing the execution of Java programs in PaX. We present two approaches that we have pursued. In the offline approach, we create a monitor that runs in parallel with the executing program, potentially on a different computer, receiving events from the running program and checking on the fly that the formulae are satisfied. In this approach, the formulae to be checked are given in a separate specification. In the inline approach, formulae are written as comments in the program text and then expanded into Java code inserted after the comments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1">Offline monitoring</head><p>The code generator for offline monitoring has been written in Java, using JavaCC <ref type="bibr" target="#b23">[24]</ref>, an environment for writing parsers and for generating and manipulating abstract syntax trees. The input to the code generator is a specification given in a file separate from the program. The specification for our example looks as follows (the default interpretation of intervals is "strong"):</p><p>specification Example is P = start(p) -&gt; [q,end(r|s)); end Several named formulae can be listed; here we have only included one, named P. The translator reads this specification and generates a single Java class, called Formulae, which contains all the machinery for evaluating all the formulae (in this case one) in the specification. This class must then be compiled and instantiated as part of the monitor. The class contains an evaluate() method that is applied after each state change and that will evaluate all the formulae. The class constructor takes as parameter a reference to the object that represents the state such that any updates to the state by the monitor, based on received events, can be seen by the evaluate() method. The generated Formulae class for the above specification looks as follows:  <ref type="bibr" target="#b7">[8]</ref> = state.holds("s"); now <ref type="bibr" target="#b6">[7]</ref> = state.holds("r"); now <ref type="bibr" target="#b5">[6]</ref> = now <ref type="bibr" target="#b6">[7]</ref> || now <ref type="bibr" target="#b7">[8]</ref>; now <ref type="bibr" target="#b4">[5]</ref> = !now <ref type="bibr" target="#b5">[6]</ref> &amp;&amp; pre <ref type="bibr" target="#b5">[6]</ref>; now <ref type="bibr" target="#b3">[4]</ref> = state.holds("q"); now <ref type="bibr" target="#b2">[3]</ref> = (pre <ref type="bibr" target="#b2">[3]</ref> || now <ref type="bibr" target="#b3">[4]</ref>) &amp;&amp; !now <ref type="bibr" target="#b4">[5]</ref>; now <ref type="bibr" target="#b1">[2]</ref> = state.holds("p"); now <ref type="bibr" target="#b0">[1]</ref> = now <ref type="bibr" target="#b1">[2]</ref> &amp;&amp; !pre <ref type="bibr" target="#b1">[2]</ref>; now[0] = !now <ref type="bibr" target="#b0">[1]</ref> || now <ref type="bibr" target="#b2">[3]</ref>; System.arraycopy(now,0,pre,0,9); return now[0]; } public Formula_P(State state){ super("P",state); pre = new boolean <ref type="bibr" target="#b8">[9]</ref>; now = new boolean <ref type="bibr" target="#b8">[9]</ref>; pre <ref type="bibr" target="#b7">[8]</ref> = state.holds("s"); pre <ref type="bibr" target="#b6">[7]</ref> = state.holds("r"); pre <ref type="bibr" target="#b5">[6]</ref> = pre <ref type="bibr" target="#b6">[7]</ref> || pre <ref type="bibr" target="#b7">[8]</ref>; pre <ref type="bibr" target="#b4">[5]</ref> = false; pre <ref type="bibr" target="#b3">[4]</ref> = state.holds("q"); pre <ref type="bibr" target="#b2">[3]</ref> = pre <ref type="bibr" target="#b3">[4]</ref> &amp;&amp; !pre <ref type="bibr" target="#b4">[5]</ref>; pre <ref type="bibr" target="#b1">[2]</ref> = state.holds("p"); pre <ref type="bibr" target="#b0">[1]</ref> = false; pre[0] = !pre <ref type="bibr" target="#b0">[1]</ref> || pre <ref type="bibr" target="#b2">[3]</ref>; } } public Formulae(State state){ formulae.add(new Formula_P(state)); } }</p><p>The class contains an inner abstract 3 class Formula and, in the general case, an inner class Formula_X extending the Formula class for each formula in the specification, where X is the formula's name. In our case, there is one such Formula_P class. The abstract Formula class declares the pre and now arrays, without giving them any size, since this is formula specific. An abstract evaluate method is also declared. The class Formula_P contains the real definition of this evaluate() method. The constructor for this class in addition initializes the sizes of pre and now depending on the size of the formula and also initializes the pre array.</p><p>To handle the general case where several formulae occur in the specification, and hence many Formula_X classes are defined, we need to create instances for all these classes and store them in some data structure where they can be accessed by the outermost evaluate() method. The formulae list variable is initialized to contain all these instances when the constructor of the Formulae class is called. On each invocation, the outermost evaluate() method goes through this list and calls evaluate() on each single formula object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.2">Inline monitoring</head><p>The general architecture of PaX was mainly designed for offline monitoring to accommodate applications where the source code is not available or where the monitored process is not even a program but some kind of physical device. However, it is often the case that the source code of an application is available and that one is willing to accept extra code for testing purposes. Inline monitoring actually has higher precision because one knows exactly where an event was emitted in the execution of the program. Moreover, one can public A(){ pre <ref type="bibr" target="#b7">[8]</ref> = d&gt;0; pre <ref type="bibr" target="#b6">[7]</ref> = c&gt;0; pre <ref type="bibr" target="#b5">[6]</ref> = pre <ref type="bibr" target="#b6">[7]</ref> || pre <ref type="bibr" target="#b7">[8]</ref>; pre <ref type="bibr" target="#b4">[5]</ref> = false; pre <ref type="bibr" target="#b3">[4]</ref> = b&gt;0; pre <ref type="bibr" target="#b2">[3]</ref> = pre <ref type="bibr" target="#b3">[4]</ref> &amp;&amp; !pre <ref type="bibr" target="#b4">[5]</ref>; pre <ref type="bibr" target="#b1">[2]</ref> = a&gt;0; pre <ref type="bibr" target="#b0">[1]</ref> = false; pre[0] = !pre <ref type="bibr" target="#b0">[1]</ref> || pre <ref type="bibr" target="#b2">[3]</ref>; }</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Experiments with test case generation and runtime analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Drusinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lowry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Abstract State Machines</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Börger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</editor>
		<meeting>Abstract State Machines<address><addrLine>Taormina, Italy; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003-03">2003. 2003. March 2003</date>
			<biblScope unit="page" from="87" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">High-level data races</title>
		<author>
			<persName><forename type="first">C</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st international workshop on verification and validation of enterprise information systems (VVEIS&apos;03)</title>
		<meeting>the 1st international workshop on verification and validation of enterprise information systems (VVEIS&apos;03)<address><addrLine>Angers, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-04">2003. April 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Boolean and Cartesian abstractions for model checking C programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of tools and algorithms for the construction and analysis of systems (TACAS&apos;01)</title>
		<title level="s">Lecture notes in computer science</title>
		<meeting>tools and algorithms for the construction and analysis of systems (TACAS&apos;01)<address><addrLine>Genoa, Italy; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001-04">2001. April 2001</date>
			<biblScope unit="page" from="268" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Towards monitoring-oriented programming: a paradigm combining specification and implementation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd workshop on runtime verification (RV&apos;03)</title>
		<meeting>the 3rd workshop on runtime verification (RV&apos;03)<address><addrLine>Boulder, CO; Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2003-07">2003. July 2003</date>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="106" to="125" />
		</imprint>
	</monogr>
	<note>Electronic notes in theoretical computer science</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Maude: specification and programming in rewriting logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Durán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Quesada</surname></persName>
		</author>
		<ptr target="http://maude.csl.sri.com/papers" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Maude system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Durán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Quesada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th international conference on rewriting techniques and applications (RTA-99)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Narendran</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</editor>
		<meeting>the 10th international conference on rewriting techniques and applications (RTA-99)<address><addrLine>Trento, Italy; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999-07">1999. July 1999</date>
			<biblScope unit="page" from="240" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Durán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Quesada</surname></persName>
		</author>
		<ptr target="http://maude.csl.sri.com/papers" />
		<title level="m">A Maude tutorial</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bandera: extracting finite-state models from Java source code</title>
		<author>
			<persName><forename type="first">J</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robby</forename><surname>Laubach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd international conference on software engineering</title>
		<meeting>the 22nd international conference on software engineering<address><addrLine>Limerick, Ireland; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000-06">2000. June 2000</date>
			<biblScope unit="page" from="439" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A deadlock detection tool for concurrent Java programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Demartini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Iosif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sisto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Pract Exper</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="577" to="603" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Temporal Rover and the ATG Rover</title>
		<author>
			<persName><forename type="first">D</forename><surname>Drusinsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN model checking and software verification. Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Penix</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The declarative past and imperative future: executable temporal logic for interactive systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st conference on temporal logic in specification</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Banieqbal</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</editor>
		<meeting>the 1st conference on temporal logic in specification<address><addrLine>Altrincham, UK; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989-04">1989. April 1989</date>
			<biblScope unit="volume">398</biblScope>
			<biblScope unit="page" from="409" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Model checking for programming languages using VeriSoft</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM symposium on principles of programming languages</title>
		<meeting>the 24th ACM symposium on principles of programming languages<address><addrLine>Paris, France; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997-01">1997. January 1997</date>
			<biblScope unit="page" from="174" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Electronic notes in theoretical computer science</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of runtime verification (RV&apos;02)</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</editor>
		<meeting>runtime verification (RV&apos;02)<address><addrLine>Copenhagen; Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2002-07">2002. July 2002</date>
			<biblScope unit="volume">70</biblScope>
		</imprint>
	</monogr>
	<note>Tracing the executions of concurrent programs</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Specification and error pattern based program monitoring</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Space Agency workshop on on-board autonomy</title>
		<meeting>the European Space Agency workshop on on-board autonomy<address><addrLine>Noordwijk, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-10">2001. October 2001</date>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Formal analysis of a space craft controller using SPIN</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lowry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Penix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Software Eng</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="749" to="765" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Model checking Java programs using Java PathFinder</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pressburger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special issue of STTT containing selected submissions to the 4th SPIN workshop</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998. 1998</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="366" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Java PathExplorer -a runtime verification tool</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th international symposium on artificial intelligence, robotics and automation in space: a new space odyssey</title>
		<meeting>the 6th international symposium on artificial intelligence, robotics and automation in space: a new space odyssey</meeting>
		<imprint>
			<publisher>Montreal</publisher>
			<date type="published" when="2001-06">2001. June 2001</date>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="page" from="18" to="21" />
		</imprint>
		<respStmt>
			<orgName>CD-ROM</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Electronic notes in theoretical computer science</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Runtime Verification (RV&apos;01)</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</editor>
		<meeting>Runtime Verification (RV&apos;01)<address><addrLine>Paris; Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001-07">2001. July 2001</date>
			<biblScope unit="volume">55</biblScope>
		</imprint>
	</monogr>
	<note>Monitoring Java programs with Java PathExplorer</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Institute of Electrical and Electronics Engineers</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international conference on automated software engineering (ASE&apos;01)</title>
		<meeting>the international conference on automated software engineering (ASE&apos;01)<address><addrLine>Coronado Island, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="135" to="143" />
		</imprint>
	</monogr>
	<note>Monitoring programs using rewriting</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Experiments in theorem proving and model checking for protocol verification</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FME&apos;96: Industrial Benefit and Advances in Formal Methods</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Gaudel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Woodcock</surname></persName>
		</editor>
		<meeting>FME&apos;96: Industrial Benefit and Advances in Formal Methods<address><addrLine>Oxford, UK; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996-03">1996. March 1996</date>
			<biblScope unit="page" from="662" to="681" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The model checker SPIN</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special issue on formal methods in software practice</title>
		<imprint>
			<date type="published" when="1997">1997. 1997</date>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="279" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A practical method for verifying event-driven software</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international conference on software engineering (ICSE&apos;99), Los Angeles</title>
		<meeting>the international conference on software engineering (ICSE&apos;99), Los Angeles<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE/ACM Press</publisher>
			<date type="published" when="1999-05">1999. May 1999</date>
			<biblScope unit="page" from="597" to="607" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Refutational theorem proving using term rewriting systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hsiang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>University of Illinois at Champaign-Urbana</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><surname>Javacc</surname></persName>
		</author>
		<ptr target="http://www.webgain.com/products/java_cc" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><surname>Jtrek</surname></persName>
		</author>
		<ptr target="http://www.compaq.com/java/download" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Runtime assurance based on formal specifications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sokolsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international conference on parallel and distributed processing techniques and applications</title>
		<meeting>the international conference on parallel and distributed processing techniques and applications<address><addrLine>Las Vegas, USA</addrLine></address></meeting>
		<imprint>
			<publisher>CSREA Press</publisher>
			<date type="published" when="1999-06">1999. June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">The temporal logic of reactive and concurrent systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin Heidelberg New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Temporal verification of reactive systems: safety</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin Heidelberg New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Temporal logic with past is exponentially more succinct</title>
		<author>
			<persName><forename type="first">N</forename><surname>Markey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EATCS Bull</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="122" to="128" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Conditional rewriting logic as a unified model of concurrency</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor Comput Sci</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="73" to="155" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Membership algebra as a logical framework for equational specification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the workshop on algebraic development techniques (WADT&apos;97)</title>
		<title level="s">Lecture notes in computer science</title>
		<meeting>the workshop on algebraic development techniques (WADT&apos;97)<address><addrLine>Tarquinia, Italy; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-06">1997. June 1998</date>
			<biblScope unit="page" from="18" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Java model checking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Y</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">U</forename><surname>Skakkebaek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the automated software engineering conference</title>
		<meeting>the automated software engineering conference<address><addrLine>Grenoble, France; New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2000-09">2000. September 2000</date>
			<biblScope unit="page" from="253" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The temporal logic of programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th IEEE symposium on foundations of computer science</title>
		<meeting>the 18th IEEE symposium on foundations of computer science<address><addrLine>Providence, RI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977-10">1977. October 1977</date>
			<biblScope unit="page" from="46" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Synthesizing dynamic programming algorithms from linear temporal logic formulae</title>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<idno>TR 01-08</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>Moffett Field, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>NASA -RIACS</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Runtime safety analysis of multithreaded programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Roşu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th joint European software engineering conference and ACM SIG-SOFT symposium on the foundations of software engineering (ESEC/FSE&apos;03)</title>
		<meeting>the 4th joint European software engineering conference and ACM SIG-SOFT symposium on the foundations of software engineering (ESEC/FSE&apos;03)<address><addrLine>Helsinki; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003-09">2003. September 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Model-checking multi-threaded distributed Java programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN model checking and software verification. Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Penix</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="224" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Model checking programs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th IEEE international conference on automated software engineering (ASE&apos;2000)</title>
		<meeting>the 15th IEEE international conference on automated software engineering (ASE&apos;2000)<address><addrLine>Grenoble, France; New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2000-09">2000. September 2000</date>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
