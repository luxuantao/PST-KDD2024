<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Statistically Significant Pattern Mining with Ordinal Utility</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thien</forename><forename type="middle">Q</forename><surname>Tran</surname></persName>
							<email>thientquang@mdl.cs.tsukuba.ac.jp</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Tsukuba</orgName>
								<address>
									<settlement>Riken AIP</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kazuto</forename><surname>Fukuchi</surname></persName>
							<email>fukuchi@cs.tsukuba.ac.jp</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Tsukuba</orgName>
								<address>
									<settlement>Riken AIP</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Youhei</forename><surname>Akimoto</surname></persName>
							<email>akimoto@cs.tsukuba.ac.jp</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Tsukuba</orgName>
								<address>
									<settlement>Riken AIP</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jun</forename><surname>Sakuma</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">University of Tsukuba</orgName>
								<address>
									<settlement>Riken AIP</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Statistically Significant Pattern Mining with Ordinal Utility</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3394486.3403215</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Significant pattern mining</term>
					<term>multiple testing</term>
					<term>high-utility pattern</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Statistically significant patterns mining (SSPM) is an essential and challenging data mining task in the field of knowledge discovery in databases (KDD), in which each pattern is evaluated via a hypothesis test. Our study aims to introduce a preference relation into patterns and to discover the most preferred patterns under the constraint of statistical significance, which has never been considered in existing SSPM problems. We propose an iterative multiple testing procedure that can alternately reject a hypothesis and safely ignore the hypotheses that are less useful than the rejected hypothesis. One advantage of filtering out patterns with low utility is that it avoids consumption of the significance budget by rejection of useless (that is, uninteresting) patterns. This allows the significance budget to be focused on useful patterns, leading to more useful discoveries.</p><p>We show that the proposed method can control the familywise error rate (FWER) under certain assumptions, that can be satisfied by a realistic problem class in SSPM.We also show that the proposed method always discovers a set of patterns that is at least equally or more useful than those discovered using the standard Tarone-Bonferroni method SSPM.Finally, we conducted several experiments with both synthetic and real-world data to evaluate the performance of our method. As a result, in the experiments with real-world datasets, the proposed method discovered a larger number of more useful patterns than the existing method for all five conducted tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS Concepts</head><p>• Information systems → Association rules; • Mathematics of computing → Hypothesis testing and confidence interval computation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Statistically significant pattern mining (SSPM) is the task of finding patterns that statistically occur more often in the data for one class than for another. Different from other pattern mining frameworks, in SSPM, the discovery of each pattern is evaluated via a statistical hypothesis test: a process to obtain a p-value which quantifies the probability that the association observed in the data is due to chance. The goal of SSPM is to maximize the number of true discoveries, i.e., minimize type-II error while controlling the number of false discoveries, i.e., controlling type-I error. With its statistical guarantee, SSPM is important and widely applied in fields such as genetics, healthcare, and market analysis. For example, in healthcare, discoveries of treatment combinations that are significantly efficacious could improve healthcare service quality. Similarly, medical scientists are interested in finding significant patterns of gene alleles associated with the onset of disease.</p><p>In this study, we focus on the utility of patterns, an aspect that is not considered in existing SSPM works. Pattern utility is essential in many applications spanning medicine, finance, and e-commerce, among others <ref type="bibr" target="#b3">[4]</ref>. For example, assume that we have the Adult dataset in which each transaction contains several demographic attribute values as explanatory variables and a binary target class (if income &gt; 50K or not). In general, SSPM aims to find patterns of demographic attributes (e.g., "university graduate" and "works 60 hours/week") that are significantly associated with "income &gt; 50K". Herein, we further introduce a preference relation between patterns and aim to find out the most useful patterns under the constraint of statistical significance. Continuing with the same example, assume that we are more interested in patterns that realize "higher income with less education" than "higher income with higher education"; we can define patterns with "less education" as being more preferred than patterns with "higher education".</p><p>This paper serves to propose SPUR (Significant Pattern mining with Utility Relationship), a method that aims to discover statistically significant patterns with the highest utility. There are three main challenges that must be solved to achieve this goal.</p><p>First, our goal is different from the standard goal of SSPM. Generally, SSPM aims to discover as many patterns as possible, while controlling type-I error. Our goal is to discover the patterns that have the highest utility while still controlling type-I error. Therefore, existing SSPM methods, such as Tarone-Bonferroni (T-Bonferroni), are not necessarily practical for our setting. Since these methods do not consider preferences for different patterns, they may waste the significance budget for controlling the type-I error of patterns which are not useful. Here, we propose that after discovering a pattern, we can ignore all the patterns that are less useful than the discovered pattern. We expect that by ignoring less useful patterns, we can discover more useful patterns without violating the type-I error constraint.</p><p>Fig. <ref type="figure" target="#fig_0">1</ref> demonstrates the statistically significant patterns in the Adult dataset found by the existing T-Bonferroni method (top) and our SPUR method (bottom). Specifically, we show the discovered patterns of "education level" and "work hour" while fixing other demographic features. We defined "less education" and "less hoursper-week" as being more preferred than "higher education" and "more hours-per-week". As we see from the figure, in two different demographic conditions, our method can find more preferred (i.e., "less education and less hours-per-week" but "higher income") patterns than the existing method with fewer rejections.</p><p>Second, since each discovery in SSPM is evaluated via a statistical test, the proposed approach is only valid if we can develop an iterative multiple-testing procedure that can safely ignore less useful hypotheses after rejecting a hypothesis. By "safely", we mean that it does not violate the type-I error constraint. To the best of our knowledge, no existing multiple-testing procedure can fulfill this requirement. We discovered that this is achievable for a specific SSPM problem class. We propose a method that can control the FWER under a particular assumption about the independence of p-values, in that the p-values of false null hypotheses and true null hypotheses are mutually independent. In the SSPM context, this assumption can be satisfied when Fisher's exact test is used, and the setup of patterns guarantees that there is no overlap of samples between distinct patterns (see Section 3.3 for more details). We note that such a setting fits well for most of our intended applications.</p><p>Finally, because we often have to consider numerous patterns in the SSPM task, the number of hypotheses in the multiple-testing problem is also large. Generally, when the number of tests is large, simple multiple-testing adjustments, such as the Bonferroni correction, become too conservative for discovering significant patterns. Recently, many studies focus on the Tarone's trick <ref type="bibr" target="#b19">[19]</ref>, which takes account of "untestable" hypotheses, resulting in more discoveries while still controlling the FWER. Thus, to be practical in the SSPM setting, our method must also be able to leverage the Tarone's trick.</p><p>Our contributions in this work are as follows:</p><p>• We introduce the problem of discovering statistically significant patterns with the highest utility, given the ordinal utility between patterns. Then, we propose an iterative multipletesting method that can reject more useful hypotheses and carefully ignore less useful hypotheses at each iteration. • We prove that the proposed method can control the FWER under a particular assumption (independence of p-values between true and false hypotheses), which can be satisfied in a realistic SSPM problem class. • We prove that the proposed method can always achieve a result that has a higher utility compared to T-Bonferroni, a standard SSPM method. • We conduct several experiments using both synthetic and real-world datasets. For the real-world experiment, our method achieves a discovery result with higher utility for all five conducted tasks.</p><p>The remainder of the paper is organized as follows. We introduce some related works and fundamental concepts in Section 2 and 3. Then, we formally define our problem setting in Section 4. Details concerning the proposed method are provided in Section 5. We prove the theoretical guarantee for FWER and improvement of utility in Section 6. Next, we demonstrate that the proposed method outperforms other methods in discovering useful patterns in Section 7, using both synthetic and real-world data. Finally, brief conclusions are put forward in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>The most fundamental challenge in SSPM is the explosion in the number of patterns due to the number of factors. Some methods have been proposed to overcome this challenge in terms of improving discovery power and navigating complexity. Early works in this respect were proceeded in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">22]</ref>. Then, Limitless Arity Multipletesting Procedure (LAMP) -a method which can efficiently discover significant patterns in the higher-order were proposed in <ref type="bibr" target="#b20">[20]</ref>. LAMP is designed with a combination of the Tarone's trick <ref type="bibr" target="#b19">[19]</ref> and the association rule mining algorithm Apriori <ref type="bibr" target="#b0">[1]</ref>. Other studies have attempted to improve or extend LAMP to other settings <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b21">21]</ref>.</p><p>There is also a body of literature focused on other types of tests or other aspects of the problem. For example, <ref type="bibr" target="#b11">[11]</ref> studied the Westfall-Young permutation test for the purpose of dealing with the dependence between patterns. <ref type="bibr" target="#b9">[10]</ref> worked on Cochran-Mantel-Haenszel and <ref type="bibr" target="#b13">[13]</ref> focused on Barnard's exact test. Moreover, <ref type="bibr" target="#b7">[8]</ref> focused in the statistical emerging pattern mining problem, <ref type="bibr" target="#b23">[23]</ref> considered the hypotheses stream problem, while <ref type="bibr" target="#b18">[18]</ref> focused on finding significant interactions between continuous features. However, to the best of our knowledge, no SSPM studies have hitherto focused on the utility of patterns.</p><p>In pattern mining, many studies have focused on the utility of patterns, namely utility-oriented pattern mining (UPM). UPM is an essential task with numerous applications in finance, medicine, and e-commerce, among others <ref type="bibr" target="#b3">[4]</ref>. Many UPM approaches have been proposed, expanding to various subfields, including high-utility </p><formula xml:id="formula_0">𝑦 𝑖 = 1 𝑎 𝑠 𝑛 1 − 𝑎 𝑠 𝑛 1 𝑦 𝑖 = 0 𝑛 𝑠 − 𝑎 𝑠 𝑛 𝐷 − 𝑛 𝑠 − (𝑛 1 − 𝑎 𝑠 ) 𝑛 𝐷 − 𝑛 1 Total 𝑛 𝑠 𝑛 𝐷 − 𝑛 𝑠 𝑛 𝐷</formula><p>item sets <ref type="bibr" target="#b24">[24]</ref>, high-utility rules <ref type="bibr" target="#b8">[9]</ref>, and maximal high utility <ref type="bibr" target="#b17">[17]</ref>. However, no studies on UPM have offered a statistical guarantee for discovered patterns.</p><p>3 Preliminaries</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Statistical association testing</head><p>Statistical association testing is a procedure for testing whether two random variables are statistically dependent, or in other words, associated. In the context of pattern mining, this is a procedure to test whether the presence of a pattern is related with the occurrence of a specific event, represented by a class label. Suppose that we have a dataset 𝐷 = {𝑡 1 , 𝑡  <ref type="table" target="#tab_0">1</ref>. Here, 𝑛 𝐷 is the total number of transactions, and 𝑛 1 is the number of transactions with label 𝑦 = 1. Moreover, 𝑛 𝑠 is the support for pattern 𝑠; i.e., the number of transactions that contain pattern 𝑠 and 𝑎 𝑠 is the support for pattern 𝑠 among class 𝑦 = 1. A widely used independence test in SSPM is Fisher's exact test, which is a conditioned test in which 𝑛 𝐷 , 𝑛 1 , 𝑛 𝑠 are assumed to be fixed <ref type="bibr" target="#b2">[3]</ref>. Under the null hypothesis of no association between 𝑋 𝑠 and 𝑦, the count cell 𝑎 𝑠 follows a hypergeometric distribution 𝑃 (. | 𝑛 𝐷 , 𝑛 1 , 𝑛 𝑠 ). Thus, the probability of observing the current table can be calculated as follows:</p><formula xml:id="formula_1">𝑃 (𝑎 𝑠 | 𝑛 𝐷 , 𝑛 1 , 𝑛 𝑠 ) = 𝑛 𝐷 𝑎 𝑠 𝑛 𝐷 −𝑛 1 𝑛 𝑇 −𝑥 𝑇 𝑛 𝐷 𝑛 𝑇 .</formula><p>Consequently, the p-value, i.e., the probability of observing a contingency table that is equally or more extreme as the observed table under the null hypotheses, can be obtained as</p><formula xml:id="formula_2">𝑝 (𝑠) val = min{𝑛 𝐷 ,𝑛 𝑠 } 𝑘=𝑎 𝑠 𝑃 (𝑘 |𝑛 𝐷 , 𝑛 1 , 𝑛 𝑠 ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>If the p-value 𝑝 (𝑠)</head><p>val ≤ 𝛼 holds for some significance level 𝛼, we can reject the null hypothesis of no association, and conclude that pattern 𝑠 is associated with outcome 𝑦 under the significance level 𝛼. Through the significance testing procedure, the probability of falsely rejecting a true null hypothesis, i.e., the probability of falsely discovering a false pattern, is controlled under the desired significance level 𝛼.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Multiple testing</head><p>In the previous section, we described an individual test for a pattern. However, in association mining, we have to consider many patterns, which means that multiple hypotheses have to be tested at the same time. If each test is conducted independently with a significance level of 𝛼, the probability that at least one false discovery occurs would be much larger than 𝛼. Typically, in such a case, it is necessary to control the overall error of all tested hypotheses. Two criteria are widely used in this respect: the familywise error rate (FWER) and false discovery rate (FDR). In what follows, we focus on controlling the FWER, which is defined as the probability of making at least one false rejection. Assume that we want to test a hypotheses set 𝐻 = {ℎ 1 , . . . , ℎ |𝐻 | }. Letting 𝑇 ⊆ 𝐻 be the subset of true null hypotheses and 𝑅 ⊆ 𝐻 be the set of hypotheses that were rejected by the multiple-testing procedure, FWER is defined as follows: Definition 3.1 (Familywise error rate (FWER)):</p><formula xml:id="formula_3">FWER = Pr 𝑅 ∩ 𝑇 ≠ ∅</formula><p>The most straightforward method to control the FWER is the Bonferroni correction, which uses a corrected rejection threshold 𝛿 = 𝛼/𝑚 for each test. However, when the number of hypotheses is large, the Bonferroni correction can become too conservative. Recently, in the context of SSPM, many methods starting with LAMP <ref type="bibr" target="#b20">[20]</ref> have leveraged the Tarone's trick <ref type="bibr" target="#b19">[19]</ref> to exclude untestable hypotheses that will never be significant. To be specific, for tests in which the test statistics are discrete, we can evaluate the minimal attainable p-value for that test. When 𝜓 (ℎ) is the minimal attainable p-value, hypothesis ℎ will never be rejected by a threshold 𝜎 if 𝜓 (ℎ) &gt; 𝜎. In the case of Fisher's exact test, the minimal attainable p-value for a pattern 𝑠 is obtained as</p><formula xml:id="formula_4">𝜓 (𝑠) = 𝑝 (𝑘 | 𝑛 𝐷 , 𝑛 1 , 𝑛 𝑠 ) where 𝑘 = min{𝑛 1 , 𝑛 𝑠 }.</formula><p>Using 𝜓 (𝑠), regardless of the count cell 𝑎 𝑠 , if 𝜓 (𝑠) &gt; 𝛿, the hypothesis related to pattern 𝑠 will never be significant for significance level 𝛿. In SSPM, 𝑛 1 can be considered as fixed because the data are commonly given beforehand. Moreover, since 𝑛 𝑠 = 𝑖 𝑋 𝑖,𝑠 , pattern 𝑠 can be ignored if there are too few transactions that contain pattern 𝑠, i.e., if the support for that pattern is too small. Since the number of hypotheses to be considered decreases with Tarone's trick, a larger rejection threshold can be used and results in more discoveries. Formally, the T-Bonferroni method leverages the Tarone's trick by setting the rejection threshold 𝜎 Tarone as follows:</p><formula xml:id="formula_5">𝜎 Tarone = max{𝜎 | 𝜎 |𝜅 (𝜎)| ≤ 𝛼 }.</formula><p>where 𝜅 (𝜎) = {ℎ | 𝜓 (ℎ) ≤ 𝜎 } is the testable hypothesis set regarding the rejection threshold 𝜎.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Assumption and the target problem class</head><p>Next, we introduce the key assumption that is necessary for our method followed by the target problem class of the proposed method. In other words, we assume that the p-values obtained from the true patterns and the false patterns are mutually independent<ref type="foot" target="#foot_0">1</ref> . We next claim that Assumption 3.1 holds for certain types of SSPM problems by the following proposition. As a counter-example, Assumption 3.1 does not hold for a set 𝑆 which contains both pattern {𝑎} and pattern {𝑎, 𝑏}, since a transaction that contains {𝑎, 𝑏} will also contain {𝑎}. It is noted that the categorical dataset setup fits well for most of our intended applications and is adopted for our real-world experiment in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Problem setting</head><p>To formally define our problem setting, we first introduce the concept of ordinal utility and clarify our goal of finding significant patterns with the highest utility. Next, we define a criterion for evaluating the goodness of the discovered result and discuss the limitation of existing approaches in our setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Ordinal utility and the dominating subset</head><p>We focus on the ordinal utility between patterns, i.e., which of two options is better. This differs from cardinal utility, which would consider how good the two options are and thus how much better one option is compared to the other. We chose ordinal utility for our setting because, in SSPM, assigning a utility score for each pattern is not always practical for patterns with multiple items. By contrast, using (partial) ordinal utility, we can easily define a flexible utility relationship between patterns, possibly using their items. We use 𝑠 1 ≻ 𝑠 2 and 𝑠 1 ≈ 𝑠 2 to denote that "pattern 𝑠 1 is useful to pattern 𝑠 2 " and "pattern 𝑠 1 is equally useful as pattern 𝑠 2 ", respectively. Moreover, since each pattern 𝑠 is evaluated via a hypothesis test ℎ 𝑠 in SSPM, we similarly use ℎ 𝑠 1 ≻ ℎ 𝑠 2 and ℎ 𝑠 1 ≈ ℎ 𝑠 2 to denote the ordinal utility between hypotheses. A preference order of utility for a pattern set 𝑆 is defined in the following. Such a preference order can be predefined based on the background knowledge or preferences of the user. For example, suppose that we are considering a dataset on medication usage in which each transaction includes a combination of drugs used by a patient and a binary class cured or not-cured. Moreover, we assume that we can define the total cost 𝑐𝑜𝑠𝑡 (𝑠) and the adverse effect level 𝑎𝑑𝑣 (𝑠) for each drug combination pattern 𝑠 as ordinal levels. A user who prefers patterns with a lower cost and less adverse effects can define the ordinal utility between patterns as We show an example of a pattern set 𝑅 = {𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓 } in Figure <ref type="figure" target="#fig_4">2</ref> where each point 𝑎, . . . , 𝑓 represents the utility of that pattern, i.e., the cost and the adverse effect levels. The colored rectangle next to each point represents the area that is less useful than that pattern. From the foregoing definition, we have that ℎ 𝑏 ≺ ℎ 𝑑 , ℎ 𝑒 ≺ ℎ 𝑐 , etc. We notice that there are pairs of patterns such as ℎ 𝑐 and ℎ 𝑑 in Figure <ref type="figure" target="#fig_4">2</ref> that are not comparable. In other words, we do not require the preference order ≺ to be complete. This design choice is especially useful for the pattern mining setting, where each pattern contains multiple items, and multiple aspects of the pattern can be considered.</p><formula xml:id="formula_6">𝑐𝑜𝑠𝑡 (𝑠 1 ) = 𝑐𝑜𝑠𝑡 (𝑠 2 ) ∧ 𝑎𝑑𝑣 (𝑠 1 ) = 𝑎𝑑𝑣 (𝑠 2 ) ⇐⇒ ℎ 𝑠 1 ≈ ℎ 𝑠 2 𝑐𝑜𝑠𝑡 (𝑠 1 ) &lt; 𝑐𝑜𝑠𝑡 (𝑠 2 ) ∧ 𝑎𝑑𝑣 (𝑠 1 ) ≤ 𝑎𝑑𝑣 (𝑠 2 ) =⇒ ℎ 𝑠 1 ≻ ℎ 𝑠 2 𝑐𝑜𝑠𝑡 (𝑠 1 ) ≤ 𝑐𝑜𝑠𝑡 (𝑠 2 ) ∧ 𝑎𝑑𝑣 (𝑠 1 ) &lt; 𝑎𝑑𝑣 (𝑠 2 ) =⇒ ℎ 𝑠 1 ≻ ℎ 𝑠 2 .</formula><p>In SSPM, the utility of a pattern can be defined using the items included in that pattern. For example, in the medication example, let 𝑐𝑜𝑠𝑡 (𝑡) and 𝑎𝑑𝑣 (𝑡) be the ordinal level of the cost and the adverse effect level for a drug 𝑡. We can define a utility function 𝑈 : 𝑆 → 𝑁 𝑑 as</p><formula xml:id="formula_7">𝑈 (𝑠) = 𝑐𝑜𝑠𝑡 (𝑠) 𝑎𝑑𝑣 (𝑠) = 𝑡 ∈𝑠 𝑐𝑜𝑠𝑡 (𝑡) max 𝑡 ∈𝑠 𝑎𝑑𝑣 (𝑠)</formula><p>.</p><p>Next, we recall that our goal is to discover significant patterns with the highest utility. Hence, the goodness of a discovered pattern set is determined only by the patterns with the highest utility in that set. We call such a subset the (utility) dominating subset. </p><formula xml:id="formula_8">(𝐾) = {𝑠 ∈ 𝐾 | 𝑠 ′ ∈𝐾 , 𝑠 ≺ 𝑠 ′ }</formula><p>We also illustrate this concept by showing the dominating set 𝑑𝑜𝑚(𝑅) for 𝑅 = {𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓 } in Figure <ref type="figure" target="#fig_4">2</ref> (right). We see that since 𝑏 ≺ ℎ (and also 𝑐, 𝑑), we have 𝑏 ∉ 𝑑𝑜𝑚(𝑅). Similarly, we also have that 𝑒 ∉ 𝑑𝑜𝑚(𝑅) and 𝑑 ∉ 𝑑𝑜𝑚(𝑅) and we can obtain the dominating subset 𝑑𝑜𝑚(𝑅) = {𝑎, 𝑐, 𝑑 }.</p><p>Our setting also requires that the discovered patterns must be true patterns. That is, letting the set of true patterns (the set of false null hypotheses) be 𝐹 , the best discovery result that can be achieved is 𝑑𝑜𝑚(𝐹 ). However, in the SSPM setting, the number of discoveries is often limited because we have to control the number of false discoveries. Hence, it is often not possible to achieve 𝑑𝑜𝑚(𝐹 ), especially when the number of true patterns is large. Thus, the practical goal in our setting is to discover a pattern set whose utility is as close as 𝑑𝑜𝑚(𝐹 ) as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Criterion for utility evaluation</head><p>Here, we introduce a metric to compare the goodness of two pattern sets, or in other words, two rejected hypothesis sets. This is then used to compare the utilities between discovered set 𝑑𝑜𝑚(𝑅) and optimal set 𝑑𝑜𝑚(𝐹 ). We also use this criterion to compare the results of different methods, which is required in the real-world setting, with unknown 𝐹 . Definition 4.3 (Utility measure): Given two pattern sets 𝐾 and 𝐾 ′ , the utility measure from 𝐾 ′ to 𝐾 is denoted by 𝐷 𝑢 (𝐾 ∥𝐾 ′ ).</p><formula xml:id="formula_9">𝐷 𝑢 (𝐾 ∥𝐾 ′ ) = |{ℎ ∈ 𝑑𝑜𝑚(𝐾) | ℎ ′ ∈𝑑𝑜𝑚 (𝐾 ′ ) , ℎ ⪯ ℎ ′ }|.</formula><p>Intuitively, 𝐷 𝑢 (𝐾 ∥𝐾 ′ ) is the number of more useful patterns in 𝑑𝑜𝑚(𝐾) that are not included in 𝑑𝑜𝑚(𝐾 ′ ). We note that 𝐷 𝑢 (𝐾 ∥𝐾 ′ ) can be asymmetric, that is, can be different from 𝐷 𝑢 (𝐾 ′ ∥𝐾). In Figure <ref type="figure" target="#fig_1">3</ref>, we illustrate this utility measure for two sets 𝐾 = {𝑎, 𝑏, 𝑐, 𝑑 } and 𝐾 ′ = {𝑏, 𝑐, 𝑒, 𝑓 }. In this case, 𝑑𝑜𝑚(𝐾) = {𝑎, 𝑐, 𝑑 } and 𝑑𝑜𝑚(𝐾 ′ ) = {𝑐, 𝑓 }. Thus, 𝐷 𝑢 (𝐾 ∥𝐾 ′ ) = 2 and 𝐷 𝑢 (𝐾 ′ ∥𝐾) = 0. Definition 4.4 (Utility comparison): Given two pattern sets, 𝐾 and 𝐾 ′ , we use 𝐾 ≻ 𝐾 ′ to denote that 𝐾 is more useful than 𝐾 ′ , while 𝐾 ≈ 𝐾 ′ denotes that 𝐾 is equally as useful as 𝐾 ′ . Here, the utility comparison is defined as follows: It should be noted that there are cases such that two pattern sets are not comparable. Specifically, two pattern sets 𝐾 and 𝐾 ′ are not comparable if 𝐷 𝑢 (𝐾 ∥𝐾 ′ ) ≠ ∅ and 𝐷 𝑢 (𝐾 ′ ∥𝐾) ≠ ∅. This is the case that 𝐾 includes some more useful patterns that are not included in 𝐾 ′ while at the same time 𝐾 ′ also includes some more useful patterns that are not included in 𝐾. Since our goal is to discover as many useful patterns as possible, we consider both 𝐾 and 𝐾 ′ as profitable results, even when 𝐷 𝑢 (𝐾 ∥𝐾 ′ ) &gt; 𝐷 𝑢 (𝐾 ′ ∥𝐾).</p><formula xml:id="formula_10">𝐷 𝑢 (𝐾 ∥𝐾 ′ ) = 0 ∧ 𝐷 𝑢 (𝐾 ′ ∥𝐾) = 0 ⇐⇒ 𝐾 ≈ 𝐾 ′ 𝐷 𝑢 (𝐾 ∥𝐾 ′ ) &gt; 0 ∧ 𝐷 𝑢 (𝐾 ′ ∥𝐾) = 0 ⇐⇒ 𝐾 ≻ 𝐾 ′ 𝐷 𝑢 (𝐾 ∥𝐾 ′ ) &gt; 0 ∧ 𝐷 𝑢 (𝐾 ′ ∥𝐾) &gt; 0 ⇐⇒ not comparable.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Existing approaches and their limitations</head><p>The most simple approach to our problem is to use standard multipletesting procedures such as Bonferroni or Holm <ref type="bibr" target="#b5">[6]</ref> to obtain significant patterns, then filter out less useful patterns. The limitation of this approach is obvious: these procedures treat all hypotheses equally regardless of their utility. These methods are only developed to maximize the number of rejections |𝑅| under the constraint of FWER, i.e., to minimize type-II error while controlling type-I error. By contrast, our setting directly focuses on the dominating subset 𝑑𝑜𝑚(𝑅), only. Consequently, from a utility perspective, many rejections of less useful patterns in 𝑅 is meaningless, resulting in a waste of the significance budget for controlling the type-I error of hypotheses which are not useful.</p><p>A better way forward may be a weighted approach, such as the weighted Bonferroni procedure <ref type="bibr" target="#b14">[14]</ref>. In this procedure, a weight is assigned to each hypothesis based on its importance. Hence, more important hypotheses have a higher chance of being rejected. However, if small weights are unfortunately assigned to false null hypotheses, many false null hypotheses will not be rejected, because the rejection thresholds are too strict. In the worst case, the weighted procedure might falsely accept all the hypotheses, i.e., miss all the true patterns. Considering that the weights must be assigned before conducting statistical tests to properly control FWER and no one knows which hypotheses are true null hypotheses, the weighted approach does not necessarily work well in practice.</p><p>5 Proposed method</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The proposed method: SPUR</head><p>In our setting, after discovering a pattern set 𝑅, discovering any pattern 𝑠 that is less useful than a pattern in 𝑅, i.e., ∃𝑠 ′ ∈ 𝑅, 𝑠 ′ ≻ 𝑠, does not increase the result's utility. Thus, once a hypothesis ℎ 𝑠 is rejected, we can ignore all less useful hypotheses ℎ 𝑠 ′ ≺ ℎ 𝑠 . Here, "ignoring a hypothesis" means "accepting the hypothesis". Because we have to guarantee the type-I error when rejecting a hypothesis, we can save the significance budget by rejecting more useful hypotheses and, at the same time, accepting less useful ones.</p><p>We propose an iterative multiple-hypotheses procedure that can conduct such an adaptive rejection process while controlling the FWER under Assumption 3.1. In particular, our method repeatedly (1) rejects the most significant hypothesis in the candidate hypothesis set and (2) ignores all hypotheses in the candidate set that are less useful than the rejected hypothesis in the last step. Next, we explain our algorithm along with the pseudocode provided in Algorithm 1. We also note that FWER control by our adaptive procedure is not obvious and we will discuss this in detail in Section 6.2.</p><p>Initialization and notation: First, we initialize the significance budget and the rejection set as 𝛿 1 = 𝛼, 𝑅 0 = ∅. Here, 𝛿 𝑡 is used to control the FWER of the procedure at iteration 𝑡. We define 𝐻 𝑡 as the set of the remaining candidate hypotheses at iteration 𝑡 and let 𝐻 1 = 𝐻 . Furthermore, we also define 𝜅 𝑡 (𝜎) = {ℎ ∈ 𝐻 𝑡 | 𝜓 (ℎ) ≤ 𝜎 } as the set of testable hypotheses at the 𝑡-th iteration for a rejection threshold 𝜎.</p><p>Rejection procedure: At each iteration 𝑡, we decide whether to reject a hypothesis in the candidate set 𝐻 𝑡 as follows. (1) We obtain the smallest p-value 𝑝 𝑟 𝑡 = min ℎ ∈𝐻 𝑡 𝑝 ℎ and the corresponding hypothesis ℎ 𝑟 𝑡 = argmin ℎ ∈𝐻 𝑡 𝑝 ℎ . We also assume that ℎ 𝑟 𝑡 can be decided by a predefined rule if there is more than one hypothesis realizing the smallest p-value. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">An intuitive explanation</head><p>In SPUR, the rejection threshold 𝜎 𝑡 and significance budget 𝛿 𝑡 are managed in a way that is not so intuitive. We will prove that such updates are necessary to control the FWER properly in Section 6. Before providing the formal proof, we give a more intuitive account of our rejection rule by considering a simple case: the case without the Tarone's trick. In other words, we assume that ∀ℎ ∈ 𝐻 : 𝜓 (ℎ) = 0. We have the following proposition.</p><p>Proposition 5.1 (SPUR in limited case): Assume for any ℎ ∈ 𝐻 , 𝜓 (ℎ) = 0, then the rejection rule of SPUR at step 7 can be rewritten as</p><formula xml:id="formula_11">𝑝 𝑟 𝑡 ≤ 𝛼 − 𝑡 −1 𝑖=1 𝑝 𝑟 𝑖 (|𝐻 𝑖 | − |𝐻 𝑖+1 | − 1) |𝐻 𝑡 | =⇒ reject ℎ 𝑟 𝑡 𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒 =⇒ stop.</formula><p>Proof. Appendix B. □</p><p>In our simple case, after ignoring less useful hypotheses, we decrease the significance budget by an amount of 𝑝 𝑟 𝑖 (|𝐻 𝑖 | − |𝐻 𝑖+1 | − 1). We note that |𝐻 𝑖 | − |𝐻 𝑖+1 | − 1 is exactly the number of ignored hypotheses due to the rejection of ℎ 𝑟 𝑖 . This term came from the modification of 𝛿 𝑡 after each rejection, i.e., step 11 in Algorithm 1. Moreover, in Section 7, we demonstrate that this modification is necessary to properly control FWER by showing that the rejection threshold 𝜎 𝑡 = 𝛼 |𝐻 𝑡 | fails to control the FWER. We also remark that when no hypotheses can be ignored, i.e., ∀𝑖, 𝑝 𝑟 𝑖 (|𝐻 𝑖 |−|𝐻 𝑖+1 −1|) = 0, our method reduces to the step-down Holm method <ref type="bibr" target="#b5">[6]</ref>. The full SPUR procedure is obtained by leveraging the Tarone's trick to additionally consider the testability of the candidate hypotheses set at each iteration.</p><p>6 Theoretical analysis</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">FWER guarantee</head><p>First, we show that the proposed method can control the FWER properly under Assumption 3.1 by Theorem 6.1. A more detailed proof is relegated to Appendix A. <ref type="foot" target="#foot_1">2</ref>Theorem 6.1 (FWER controlling): Under Assumption 3.1, the proposed SPUR procedure conducted with significance level 𝛼 controls the familywise error rate at 𝛼. Here, we discuss why Assumption 3.1 is needed. We first remark that we reject the hypothesis ℎ 𝑟 𝑡 at iteration 𝑡 if 𝑝 𝑟 𝑡 ≤ 𝜎 𝑡 . In SPUR, because 𝜎 𝑡 relies on the p-values of the rejected hypotheses in the previous steps, it is burdensome to directly evaluate the probability of rejecting a true hypothesis, due to the complicated dependence of p-values between hypotheses. This characteristic makes the evaluation of FWER challenging for our procedure. We overcame this challenge using the following observations. First, we remark that our testing framework is an iterative procedure. Thus, we can evaluate FWER by considering the probability of SPUR firstly rejecting a true hypothesis at an iteration. Actually, we show that FWER is equivalent to the sum of such a probability for all possible iterations. By viewing FWER this way, when evaluating the probability that SPUR firstly rejects a true hypothesis at iteration 𝑇 𝐸 , we can regard that all rejected hypotheses in previous steps 𝑡 &lt; 𝑇 𝐸 are false hypotheses. Moreover, any variables at any iteration 𝑡 &lt; 𝑇 𝐸 , including 𝛿 𝑡 , 𝜎 𝑡 , 𝐻 𝑡 , ℎ 𝑟 𝑡 , 𝑝 𝑟 𝑡 , are determined only by the p-values of false hypotheses {𝑝 ℎ } ℎ ∈𝐹 . Furthermore, 𝐻 𝑇 𝐸 , 𝛿 𝑇 𝐸 , and 𝜎 𝑇 𝐸 are also determined only by {𝑝 ℎ } ℎ ∈𝐹 since these variables are obtained using only the variables of iteration 𝑇 𝐸 − 1. Hence, the only variable that relies on both the p-values of true and false hypotheses is ℎ 𝑟 𝑇 𝐸 . Then, using Assumption 3.1, we can apply the Tarone's trick to control the probability of rejecting a true hypothesis in 𝐻 𝑇 𝐸 with due regard to the threshold 𝜎 𝑇 𝐸 and show that FWER is upper-bounded by significant level 𝛼.</p><p>Finally, it should be noted that our method can also be used as a general multiple testing framework for any problem that satisfies Assumption 3.1, such as multi-center studies or subset analysis in which the statistics between hypotheses are independent <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Utility guarantee</head><p>Next, we give a guarantee on the utility of the proposed method compared to the T-Bonferroni method in Theorem 6.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 6.2 (Comparison with T-Bonferroni):</head><p>For arbitrary preference order ≺, let 𝑅 be rejected by SPUR and 𝑅 Tarone be the rejection set by T-Bonferroni; then 𝑅 ⪰ 𝑅 Tarone .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Appendix B. □</head><p>To show this theorem, we first claim that in SPUR, we always obtain a rejection threshold 𝜎 𝑡 that is not smaller than the rejection threshold of the last step 𝜎 𝑡 −1 . Lemma 6.1 (Monotonically increasing 𝜎 𝑡 ): Let 𝜎 0 = 0, for any iteration 𝑡 ≤ 𝑇 SPUR of the SPUR process: 𝜎 𝑡 −1 ≤ 𝜎 𝑡 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Appendix B. □</head><p>Recall that the proposed method always rejects the most significant hypothesis ℎ 𝑟 𝑡 then ignores other less useful hypotheses in 𝐻 𝑡 regarding ℎ 𝑟 𝑡 . Thus, the necessary condition for a hypothesis ℎ * ∈ 𝐻 to be ignored is that there exists another hypothesis ℎ ∈ 𝐻 that (1) is more significant than ℎ * , i.e., 𝑝 ℎ &lt; 𝑝 * ℎ , and (2) is at least as useful as ℎ * , i.e., ℎ ⪰ ℎ * . In our proof, we show that this condition does not hold for any hypothesis ℎ * included in the dominating set 𝑑𝑜𝑚(𝑅 Tarone ) discovered by T-Bonferroni. Moreover, using Lemma 6.1 and the fact that the 𝜎 1 = 𝜎 𝑇 𝑎𝑟𝑜𝑛𝑒 , we can show that SPUR always rejects all the hypotheses in 𝑑𝑜𝑚(𝑅 Tarone ). Thus, 𝑅 ⊇ 𝑑𝑜𝑚(𝑅 Tarone ) and Theorem 6.2 can then be shown using the utility comparison between hypotheses sets. This guarantee of utility improvement is the most critical advantage of SPUR compared to the weighted approaches. As discussed in Section 4.3, the discovery result by weighted approaches can be heavily affected if the false hypotheses are assigned small weights. In the worst case, the weighted approach would be inferior to methods that do not consider utility, e.g., T-Bonferroni. In contrast, although SPUR is also expected to achieve better performance when the utility of the false hypotheses is high, it still guarantees a utility that is not less useful than T-Bonferroni even when the utility of false hypotheses is low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experiment</head><p>In this section, we evaluate SPUR using a synthetic experiment and three real-world datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Synthetic experiment</head><p>We conduct the first synthetic experiment with two goals. First, we verify if SPUR can adequately control FWER. Particularly, we demonstrate that adjusting the significance budget by 𝛿 𝑡 +1 = 𝛿 𝑡 − 𝜏 𝑡 (𝑝 𝑟 𝑡 − 𝑝 𝑟 𝑡 −1 ) + 𝑝 𝑟 𝑡 is necessary to control the FWER by showing that obtaining the significance budget as 𝛿 𝑡 +1 = 𝛿 𝑡 would violate the FWER. Second, we verify if SPUR can correctly reject hypotheses with higher utility compared to other methods. We confirm our discussion in Section 6.2 about the limitation of the weighted approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Experiment setting:</head><p>We consider a set of 100 hypotheses 𝐻 = {ℎ 1 , ℎ 2 , . . . , ℎ 100 }, where 20 of them are false null hypotheses. Let 𝐹 be the set of false hypotheses and let the preference be ℎ 𝑖 ≻ ℎ 𝑗 for 𝑖 &lt; 𝑗, i.e., the hypothesis with a smaller index be more useful. We consider the following 𝑗=1 with 20 samples for each hypothesis ℎ 𝑖 , where 𝑥 𝑖 𝑗 ∼ N (𝜇 = 0, 𝜎 = 0.75) if ℎ 𝑖 ∈ 𝑇 and 𝑥 𝑖 𝑗 ∼ N (𝜇 = 0.5, 𝜎 = 0.75) if ℎ 𝑖 ∈ 𝐹 . We remark that the p-values obtained in this setting satisfy Assumption 3.1 although this setting does not employ Fisher's exact test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Comparative methods and criterion</head><p>We compare our method with the following three methods.</p><p>• Bonferroni: the T-Bonferroni method with 𝜎 = 𝛼/|𝐻 | • w-Bonferroni: the weighted Bonferroni method where hypothesis ℎ 𝑖 's weight 𝑤 𝑖 is assigned to be the number of hypotheses that are less useful than ℎ 𝑖 , i.e., 𝑤 𝑖 = 100 − 𝑖 + 1. • invalid-SPUR: the version of SPUR where 𝛿 𝑡 +1 = 𝛿 𝑡 For each setting, we generated 10,000 datasets, applied each generated dataset to the four methods, and then evaluated the FWER and the utility of the rejected set 𝑅 (only for the runs with no type-I error). To evaluate utility, we first define 𝑟𝑎𝑛𝑘 (ℎ) as the utility ranking of a false hypothesis ℎ within the false hypothesis set 𝐹 . For example, in the medium utility setting, we have 𝑟𝑎𝑛𝑘 (ℎ 1 ) = 1, 𝑟𝑎𝑛𝑘 (ℎ 6 ) = 2. Here, the smaller the 𝑟𝑎𝑛𝑘 (.), the more useful that rejected set is. The utility of the rejected set 𝑅 is the ranking of the most useful hypothesis in 𝑅.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.3">Results and discussion</head><p>The FWER and the average number of rejections according to the four methods are given in Table <ref type="table" target="#tab_3">2</ref>. From the table, we observe that Bonferroni, w-Bonferroni, and SPUR succeed in controlling the FWER in all three settings. On the other hand, invalid-SPUR failed to control the FWER for the medium utility setting. This result demonstrates that management of the significance budget 𝛿 𝑡 at line 11 of SPUR is necessary for controlling the FWER. Figure <ref type="figure" target="#fig_8">4</ref> is a cumulative histogram of the utility rank 𝑟𝑎𝑛𝑘 (𝑅) of the rejection set 𝑅 by the three methods: Bonferroni, w-Bonferroni, and SPUR after 10,000 runs. For each possible value 𝑘 ∈ {1, . . . , 20} of 𝑟𝑎𝑛𝑘 (𝑅), we count how many times each method obtained a rejection set 𝑅 so that 𝑟𝑎𝑛𝑘 (𝑅) ≤ 𝑘. For example, considering 𝑘 = 2 in the medium utility setting, we count how many times each method rejected hypothesis ℎ 1 or ℎ 6 correctly. In Figure <ref type="figure" target="#fig_8">4</ref>, the xand y-axes represent 𝑘 and the count of correct rejection at value 𝑘, respectively.</p><p>First, in all the settings, SPUR always achieved a rejection set that is not less useful than the Bonferroni rejection set, as is guaranteed in Theorem 6.2. Moreover, we observed that SPUR could achieve a rejection set with a higher utility if the false hypotheses have high utility. This is because when the utility of false hypotheses is high, once a false hypothesis gets rejected, SPUR can ignore many nonuseful hypotheses, which are both less useful and less significant than the rejected false hypothesis. As a result, SPUR can achieve a rejected set with higher utility.</p><p>On the other side, w-Bonferroni, which assigns larger weights for hypotheses with higher utility, works well in the high and medium utility settings. However, in the low utility setting, this method performs poorly and even worse than the Bonferroni. This can be explained in terms of the dependence between the assigned weight and the p-value in the weighted approach. In particular, if the weights of the false hypotheses are small, their rejection thresholds could become too strict, and these hypotheses could not be rejected. In contrast, SPUR guarantees that the utility of the rejected set is at least useful as the result of Bonferroni even in the low utility setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Real-world datasets</head><p>We conduct real-world data experiments to confirm if SPUR can discover more useful patterns in a real-world situation where the Tarone's trick must be considered. We adopted the three datasets Adult <ref type="bibr" target="#b6">[7]</ref>, Crash Report <ref type="bibr" target="#b16">[16]</ref>, and Crime <ref type="bibr" target="#b15">[15]</ref> for five mining tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Data preprocessing and task setup</head><p>All three datasets consist of some explanatory variables and a target class. To elaborate, the Crash Report dataset <ref type="bibr" target="#b16">[16]</ref> is a dataset of traffic accidents, including information about speed limits, weather, light-conditions, etc., and a class 𝑦 = 1 indicates if someone was injured. The Crime dataset <ref type="bibr" target="#b15">[15]</ref> consists of criminal records with information about the place, street, and time along with a class for the crime category: against a person, property, or society. For this dataset, we set up three tasks using each of these categories as the target class. Finally, the Adult dataset <ref type="bibr" target="#b6">[7]</ref> contains several demographic attributes and a class 𝑦 = 1 of income &gt; 50K for different individuals.</p><p>To set up the candidate pattern set and the null hypotheses in each dataset, we focused on some variables and defined the mining task based on these variables. We translate the values of these variables into items by categorizing them with some predefined rules. For example, the hours-per-week attribute in the Adult dataset is categorized into [&lt; 20], [20 − 29], . . . , [≥ 60]. A valid pattern is a combination of all explanatory variables, with one item for each variable. This setup guarantees that there is no overlap of samples between patterns, and we adopted the Fisher's exact test for all five tasks (one-sided for the Crash and Adult datasets, two-sided for the Crime dataset). Our goal is to discover the combinations of levels that are significantly associated with the target class. Details about the adopted variables are shown in Table <ref type="table">4</ref> of Appendix C.</p><p>To define the ordinal utility between patterns, we first divide the explanatory variables into two groups: utility variables and family variables. Specifically, we state 𝐾 ≻ 𝐾 ′ if their family variables are identical, and the utility variables of 𝐾 is more useful than of 𝐾 ′ . For example, for the Adult dataset, we let (sex, work-class, and occupation) be the family variables and hours-per-week, education be the utility variables. Here, based on prior knowledge that "a higher income correlates with higher education level and more work hours", we oppositely prefer patterns with lower education level and less work hours. That is, we aim to discover patterns that are unexpectedly associated with the class &gt; 50K. Furthermore, the family variables are also effective in finding useful patterns in various situations of (sex, work-class, and occupation). In addition, we prefer sounded safe for the Crash task and occurs in midday patterns for the Crime dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Results and discussion</head><p>In Table <ref type="table" target="#tab_4">3</ref>, we show the number of discoveries |𝑅 S | by SPUR, |𝑅 T | by T-Bonferroni, and the utility measure 𝐷 𝑢 (𝑅 S ∥𝑅 T ), for different significance levels 𝛼. We do not show 𝐷 𝑢 (𝑅 T ∥𝑅 S ), because 𝐷 𝑢 (𝑅 T ∥𝑅 S ) = 0 for all settings, i.e., because SPUR always discovered a pattern set that is not less useful than T-Bonferroni, as is guaranteed by Theorem 6.2. Especially, 𝐷 𝑢 is large for the Crash, Property, and Society tasks, indicating that SPUR discovered a large number of high-utility patterns that cannot be discovered by T-Bonferroni.</p><p>On the other hand, the utility measure 𝐷 𝑢 (𝑅 S ∥𝑅 T ) is comparatively small for the Adult and Person tasks. We explain this by considering the number of discovered patterns |𝑅 𝑇 | by T-Bonferroni. First, in these tasks, |𝑅 𝑇 | is small compared to other tasks. Moreover, even when we increase the significance level 𝛼, only a few additional patterns are discovered. In such a case, since the number of discoverable patterns is small in the first place, even if SPUR can achieve a larger rejection threshold by ignoring less useful hypotheses, the number of newly discovered patterns would not increase. In other words, for cases such as the Crash, Property, and Society tasks, SPUR is especially functional because many useful true patterns were not discovered by T-Bonferroni due to the FWER constraint, while there are many patterns in 𝑅 𝑇 which are not useful.</p><p>Next, we focus on the discovery process of two methods by using the Adult task as an example. In Figure <ref type="figure" target="#fig_0">1</ref>, we show the discoveries by two methods with 𝛼 = 0.05 for two families (Male, Self-emp, Profspecialty) and (Male, Private, Exec-managerial). We also show the sorted indexes of p-values for discovered patterns by each method. As we can see from Figure <ref type="figure" target="#fig_0">1</ref>, by considering both the significance and the utility of discovered patterns, SPUR can efficiently expand its dominance of patterns with fewer members of rejection. By contrast, with no consideration of utility, T-Bonferroni wastes its significance budget in rejecting less useful hypotheses. As a result, SPUR can discover more useful patterns that T-Bonferroni fails to discover. This advantage is not limited to discovering patterns in the same family, but is also helpful in discovering patterns of other families. In fact, we obtained a number of pattern families that only SPUR could discover.</p><p>In Figure <ref type="figure" target="#fig_0">1</ref>, as discovered by SPUR, a male (private) executive/manager who works 40-50 hours a week is likely to have an income &gt; 50K even if he has just graduated from high school, while the required education level found by T-Bonferroni is to graduate from a college. Moreover, a male who graduated from a professional school and is working in a (self-employed) professional specialty is likely to have an income of &gt; 50K even if he only works for 30-40 hours a week, while the requirement discovered by T-Bonferroni is 40-50 hours a week. Other than those patterns, in the Crash dataset, SPUR discovered many patterns that seemed safe but are still associated with an accident and injury, which cannot be discovered by T-Bonferroni. In this way, SPUR can discover patterns that are significant, and at the same time, preferred by the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>In this study, we focused on the utility of patterns in the SSPM context. We introduced the problem of discovering statistically significant patterns with the highest utility, giving the ordinal utility between patterns. We proposed an iterative multiple-testing framework that alternately rejects a hypothesis and safely ignores hypotheses which are less useful than the rejected one. This enables the discovery of more useful patterns. We theoretically showed the FWER guarantee under a particular assumption and the utility guarantee of the proposed method. Finally, we conducted several experiments with both synthetic and real-world datasets to demonstrate that the proposed method is capable of discovering more useful patterns under the constraint of type-I error. To show this theorem, we first define the stochastic process obtained by the proposed method SPUR. </p><formula xml:id="formula_12">{𝑝 ℎ } ℎ ∈𝑇 {𝑝 ℎ } ℎ ∈𝐹 𝑋1 • • • 𝑋𝑡 • • • 𝑋 𝑇𝑘 𝐸1 • • • 𝐸𝑡 • • • 𝐸 𝑇𝑘</formula><formula xml:id="formula_13">{𝑅 ∩ 𝑇 ≠ ∅} = {𝑇 𝐸 ≤ |𝐻 |}.</formula><p>Here, 𝐸 𝑡 = {ℎ 𝑟 𝑡 ∈ 𝑇 , 𝑝 𝑟 𝑡 ≤ 𝜎 𝑡 } is the event of rejecting a true hypothesis at the 𝑡-th iteration and 𝑇 𝐸 = min{𝑡 ∈ [|𝐻 |] : 𝑡 ≤ 𝑇 SPUR ∧ 𝐸 𝑡 } is the first iteration that a true hypotheses got rejected. Lemma A.1 claims that the FWER is actually the probability of the first Type-I error occurs at some step 𝑡 0 ≤ |𝐻 |. To show the FWER controlling, we have to consider the relationship between the p-values of the true hypotheses, the false hypotheses, and the rejection threshold at each iteration. However, such the dependence are complicated in the SPUR process {𝑋 𝑡 } 𝑇 SPUR 𝑡 =1 . Thus, we instead consider an alternative stochastic process that only depends on the false hypotheses and show the FWER controlling by analyzing this process. In addition, we illustrate the relation of entities in the SPUR process using a graph shown in Figure <ref type="figure" target="#fig_9">5</ref> where each 𝑝 𝑇 * 𝑡 is obtained using the value 𝑌 𝑡 of the false hypotheses based process.  </p><formula xml:id="formula_14">} 𝑇 FALSE 𝑡 =1 if {𝑝 ℎ } ℎ ∈𝐹 𝑌1 • • • 𝑌𝑡 • • • 𝑌𝑇 𝑘 𝑝 𝑇 * 1 𝐸 * 1 • • • 𝑝 𝑇 * 1 𝐸 * 𝑡 • • • 𝑝 𝑇 * 𝑘 𝐸 * 𝑇𝑘 {𝑝 ℎ } ℎ ∈𝑇<label>Figure</label></formula><formula xml:id="formula_15">Pr 𝑇 * 𝐸 ≤ |𝐻 | | {𝑝 ℎ } ℎ ∈𝐹 ≤ 𝑡 0 &lt;𝑘 |𝜅 * 𝑡 0 (𝑝 𝑟 * 𝑡 0 ) ∩ 𝑇 |(𝑝 𝑟 * 𝑡 0 − 𝑝 𝑟 * 𝑡 0 −1 ) + |𝜅 * 𝑘 (𝑝 𝑟 * 𝑘 ) ∩ 𝑇 |(𝜎 * 𝑘 − 𝑝 𝑟 * 𝑘−1 ).</formula><p>Actually, the proposed algorithm SPUR is designed to guarantee that the right side in the inequation of Lemma A.3 always less than 𝛼, as stated in Lemma A.4.</p><p>Lemma A.4: Using the same definition of Lemma A.2 and let 𝑘 = 𝑇 False , the following holds: Proof. Since ∀ ℎ ∈𝐻 𝜓 (ℎ) = 0, we have that</p><formula xml:id="formula_16">𝑡 0 &lt;𝑘 |𝜅 * 𝑡 0 (𝑝 𝑟 * 𝑡 0 ) ∩ 𝑇 |(𝑝 𝑟 * 𝑡 0 − 𝑝 𝑟 * 𝑡 0 −1 ) + |𝜅 * 𝑘 (𝜎 * 𝑡 ) ∩ 𝑇 |(𝜎 * 𝑘 − 𝑝 𝑟 * 𝑘−1 ) ≤ 𝛼 .</formula><formula xml:id="formula_17">∀ 𝑡 , ∀ 𝜎 ≥0 , 𝜅 𝑡 (𝜎) = |{ℎ ∈ 𝐻 𝑡 |𝜓 (ℎ) ≤ 𝜎 }| = |𝐻 𝑡 |.</formula><p>We also have</p><formula xml:id="formula_18">𝜎 𝑡 = max{𝜎 : (𝜎 − 𝑝 𝑟 𝑡 −1 )|𝐻 𝑡 | ≤ 𝛿 𝑡 } = 𝛿 𝑡 |𝐻 𝑡 | + 𝑝 𝑟 𝑡 −1 𝜏 𝑡 = 𝛿 𝑡 /(𝜎 𝑡 − 𝑝 𝑟 𝑡 −1 ) = |𝐻 𝑡 | Thus, 𝜎 𝑡 = 𝛿 𝑡 + 𝑝 𝑟 𝑡 −1 |𝐻 𝑡 | |𝐻 𝑡 | = 𝛼 − 𝑡 −1 𝑖=1 (𝑝 𝑟 𝑖 − 𝑝 𝑟 𝑖−1 )|𝐻 𝑖 | − 𝑝 𝑟 𝑖 + |𝐻 𝑡 |𝑝 𝑟 𝑡 −1 |𝐻 𝑡 | = 𝛼 − 𝑡 −1 𝑖=1 𝑝 𝑟 𝑖 (|𝐻 𝑖 | − |𝐻 𝑖+1 | − 1) |𝐻 𝑡 | .</formula><p>In the last line, we rewrite the formula by grouping terms for each 𝑝 𝑟 𝑡 and used the fact that 𝑝 𝑟 0 = 0. This concludes our proof. □ B.2 Proof of Proposition 3.1</p><p>Proof. Without the loss of generality, we consider two patterns 𝑠 and 𝑠 ′ where ℎ 𝑠 ∈ 𝑇 and ℎ ′ 𝑠 ∈ 𝐹 . We adopt the notions in Section 3 and assume that the observed dataset is 𝐷 = {𝑡 𝑖 , 𝑦 𝑖 } 𝑛 𝐷 𝑖=1 ∼ D. We represent this dataset regarding 𝑠 and 𝑠 ′ as 𝐷 = {𝑥 𝑖,𝑠 , 𝑥 Proof. Let 𝑅 be the rejected set by SPUR. Moreover, let 𝜎 Tarone and 𝑅 Tarone be the rejection threshold and the rejected set by T-Bonferroni, respectively. We have that Since 𝑅 𝑐 Tarone ∪ 𝑅 Tarone = 𝐻 , ℎ ∈𝐻 ℎ ⪰ ℎ * ∧ 𝑝 ℎ &lt; 𝑝 ℎ * On the other hand, ∃ ℎ ∈𝐻 ℎ ⪰ ℎ * ∧ 𝑝 ℎ &lt; 𝑝 ℎ * is the necessary condition for the hypothesis ℎ * to be ignored in the procedure SPUR. Thus, no hypotheses in 𝑑𝑜𝑚(𝑅 Tarone ) will be ignored by SPUR. Moreover, we have 𝜎 1 = 𝜎 Tarone since 𝐻 1 = 𝐻 and 𝑝 0 = 0 and 𝜎 𝑘 ≥ 𝜎 1 ≥ 𝜎 Tarone for any iteration 𝑘 by Lemma 6.1. Thus, 𝑝 * 𝑘 ≤ 𝜎 Tarone ≤ 𝜎 𝑘 and it implies that 𝑑𝑜𝑚(𝑅 Tarone ) ⊆ 𝑅. This concludes our proof. □ C Appendix: Reproducibility Table <ref type="table">4</ref>: Adopted variables for each dataset and the number of categorizing levels for each variable (in parentheses).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>family-vars utility-vars target-class</head><p>Crash <ref type="bibr" target="#b16">[16]</ref> street-type (5) traffic-control (2) crash-type (2) time <ref type="bibr" target="#b24">(24)</ref> speed-limit (7) 𝑦 = 1 (injured) weather (3) light-condition (3) Adult <ref type="bibr" target="#b6">[7]</ref> sex (2) hours-per-week (6) income (2) work-class <ref type="bibr" target="#b2">(3)</ref> education (10) 𝑦 = 1 (&gt; 50K) occupation <ref type="bibr" target="#b15">(15)</ref> Crime <ref type="bibr" target="#b15">[15]</ref> place <ref type="bibr" target="#b12">(12)</ref> time <ref type="bibr" target="#b12">(12)</ref> crime-type (3) street ( <ref type="formula">14</ref>) 𝑦 = property/person/society</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Difference in discovered patterns and sorted indexes of p-values for two family A = (Male, Self-emp, Profspecialty) and B = (Male, Private, Exec-managerial) by the existing method T-Bonferroni and our method SPUR.</figDesc><graphic url="image-1.png" coords="1,358.88,202.55,156.16,158.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Assumption 3 .</head><label>3</label><figDesc>1 (p-values independence): For any hypotheses pair ℎ 𝑡 ∈ 𝑇 and ℎ 𝑓 ∈ 𝐹 , their p-values 𝑝 ℎ 𝑡 and 𝑝 ℎ 𝑓 are independent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Proposition 3 . 1 :</head><label>31</label><figDesc>In the setting of Section 3.1 and 3.2, suppose pvalues of Fisher's exact test are considered. Given 𝐷, if for any two distinct patterns 𝑠, 𝑠 ′ ∈ 𝑆, {𝑡 ∈ 𝐷 | 𝑠 ∈ 𝑡 } ∩ {𝑡 ∈ 𝐷 | 𝑠 ′ ∈ 𝑡 } = ∅ holds, Assumption 3.1 holds. Proof. Appendix B. □ Proposition 3.1 claims that Assumption 3.1 can be satisfied by two requirements. First, it requires that Fisher's exact test is used, which is a popular independent test in SSPM contexts. Second, it requires that the pattern set is designed to separate the dataset into non-overlapping subsets. This second requirement can be satisfied in several scenarios, for example • Categorical dataset: consider a dataset with several categorical attributes (𝑥 1 , 𝑥 2 , . . . , 𝑥 𝑚 ) and a target label 𝑦. Assumption 3.1 holds by any pattern set 𝑆 ⊆ 𝐼 1 × • • • × 𝐼 𝑚 , where 𝐼 𝑑 is the set of possible values for variable 𝑥 𝑑 . • Transaction dataset with fixed transaction size: consider a dataset that for any transaction 𝑡 𝑖 ∈ 𝐷, the number of items in 𝑡 𝑖 is 𝑘 for a fixed 𝑘, i.e., 𝑗 ∈𝐼 𝑥 𝑖 𝑗 = 𝑘. Assumption 3.1 holds by any pattern set 𝑆 ⊆ 𝐼 𝑘 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 4 . 1 (</head><label>41</label><figDesc>Preference order of utility): A preference order ≺ on a pattern set 𝑆 = {𝑠 1 , . . . , 𝑠 |𝑆 | } is a transitive binary relation in which (𝑆, ≺) is a partially ordered set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Preference order and the dominating set</figDesc><graphic url="image-2.png" coords="4,376.90,271.20,120.12,70.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Definition 4 . 2 (</head><label>42</label><figDesc>(Utility) dominating subset): For a pattern set 𝐾 = {𝑠 1 , . . . , 𝑠 𝑘 }, we call 𝑑𝑜𝑚(𝐾) ⊆ 𝐾 the (utility) dominating subset of 𝐾 if 𝑑𝑜𝑚</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Utility measure between two pattern sets 𝐾 = {𝑎, 𝑏, 𝑐, 𝑑 } and 𝐾 ′ = {𝑏, 𝑐, 𝑑, 𝑒}</figDesc><graphic url="image-3.png" coords="5,53.80,500.45,240.25,72.07" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>( 2 )</head><label>2</label><figDesc>We obtain 𝜎 𝑡 = max{𝜎 : (𝜎 − 𝑝 𝑟 𝑡 −1 )|𝜅 𝑡 (𝜎)| ≤ 𝛿 𝑡 } as the rejection threshold to decide whether to reject ℎ 𝑟 𝑡 . (3) If 𝑝 𝑟 𝑡 ≤ 𝜎 𝑡 , we reject ℎ 𝑟 𝑡 by adding it to the rejection set, i.e., 𝑅 𝑡 +1 = 𝑅 𝑡 ∩ {ℎ 𝑟 𝑡 }. We also ignore (accept) all less useful hypotheses in 𝐻 𝑡 by setting the next candidate set as 𝐻 𝑡 +1 = {ℎ ∈ 𝐻 𝑡 | ℎ ≻ ℎ 𝑟 𝑡 }. Finally, we modify the significance budget as 𝛿 𝑡 +1 = 𝛿 𝑡 − 𝜏 𝑡 (𝑝 𝑟 𝑡 − 𝑝 𝑟 𝑡 −1 ) + 𝑝 𝑟 𝑡 , where 𝜏 𝑡 = 𝛿 𝑡 /(𝜎 𝑡 − 𝑝 𝑟 𝑡 −1 ). (4) If 𝑝 𝑟 𝑡 &gt; 𝜎 𝑡 , we stop and return the rejection set 𝑅 = 𝑅 𝑡 −1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Cumulative histogram of utility rank.</figDesc><graphic url="image-4.png" coords="7,322.84,608.77,228.23,93.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Relation graph of {𝑋 𝑡 } 𝑇 SPUR 𝑡 =1 (shaded) and event 𝐸 𝑡 (we let 𝑘 = 𝑇 False in the graph) A Appendix: Proof of Theorem 6.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Definition A. 3 (</head><label>3</label><figDesc>Alternative true hypotheses sequence): A set of r.v. {𝑝 𝑇 * 𝑡 } 𝑇 False𝑡 =1 is said to be an alternative true hypotheses sequence obtained from the false hypotheses based process {𝑌 𝑡</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Theorem 6 .</head><label>6</label><figDesc>1 is then shown by combining the above lemmas. B Appendix: Other proofs B.1 Proof of Proposition 5.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>𝜎</head><label></label><figDesc>Tarone = max{𝜎 | 𝜎𝜅 (𝜎) ≤ 𝛼 } 𝑅 Tarone = {𝑝 ℎ ≤ 𝜎 Tarone } ℎ ∈𝐻 .Letting ℎ ∈ 𝑅 𝑐 Tarone = 𝐻 \ 𝑅 Tarone , the following holds for a hypothesis ℎ * ∈ 𝑑𝑜𝑚(𝑅 Tarone ):ℎ ∈𝑅 Tarone , ℎ ⪰ ℎ * (since ℎ * ∈ 𝑑𝑜𝑚(𝑅 Tarone ))and ℎ ∈𝑅 𝑐 Tarone , 𝑝 ℎ &lt; 𝑝 ℎ * (since ℎ * ∈ 𝑅 Tarone ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>2 × 2 contingency table for pattern S 𝑋 𝑖,𝑠 = 1 𝑋 𝑖,𝑠 = 0 Total</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>𝑖 indicates whether the corresponding items present in the transaction; i.e., 𝑥 𝑖 𝑗 = 1 if item 𝑗 appear in transaction 𝑡 𝑖 . We call a set of items 𝑠 ⊆ 𝐼 a pattern and define the indication variable 𝑋 𝑖,𝑠 = 𝑗 ∈𝑠 𝑥 𝑖 𝑗 for pattern 𝑠. Here, 𝑋 𝑖,𝑠 = 1 if pattern 𝑠 appears in transaction 𝑡 𝑖 and 𝑋 𝑖,𝑠 = 0 otherwise.The association of pattern 𝑠 and target class 𝑦 = 1 can be investigated by conducting an independence test with the null hypothesis 𝐻 0 : 𝑋 𝑠 ⊥𝑦 via a 2 × 2 contingency table as in Table</figDesc><table /><note>2 , . . . , 𝑡 𝑛 𝐷 } that contains 𝑛 𝐷 transactions defined in the universe of 𝑚 items 𝐼 = {1, . . . , 𝑚}. Here, a transaction 𝑡 𝑖 can be described by a vector x 𝑖 of length 𝑚 and a binary-class label 𝑦 𝑖 . The vector x</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Algorithm 1 :</head><label>1</label><figDesc>SPUR Data: Hypothesis set 𝐻 , statistical level 𝛼 Result: Reject set 𝑅 1 𝑡 ← 1, 𝑅 0 ← ∅; 2 𝐻 1 ← 𝐻, 𝛿 1 ← 𝛼, 𝑝 𝑟 0 ← 0; 3 while 𝐻 𝑡 ≠ ∅ do 4 𝜎 𝑡 ← max{𝜎 : (𝜎 − 𝑝 𝑟 𝑡 −1 )|𝜅 𝑡 (𝜎)| ≤ 𝛿 𝑡 } ; // threshold 5 𝑝 𝑟 𝑡 ← min ℎ ∈𝐻 𝑡 𝑝 ℎ ; 𝐻 𝑡 +1 ← {ℎ ∈ 𝐻 𝑡 | ℎ ≻ ℎ 𝑟 𝑡 } ; // ignore unuseful 10 𝜏 𝑡 ← 𝛿 𝑡 /(𝜎 𝑡 − 𝑝 𝑟 𝑡 −1 ); 11 𝛿 𝑡 +1 ← 𝛿 𝑡 − 𝜏 𝑡 (𝑝 𝑟 𝑡 − 𝑝 𝑟 𝑡 −1 ) + 𝑝 𝑟 𝑡 ; // modify budget</figDesc><table><row><cell>6</cell><cell>ℎ 𝑟 𝑡 ← argmin ℎ ∈𝐻 𝑡 𝑝 ℎ ;</cell><cell></cell></row><row><cell>7</cell><cell>if 𝑝 𝑟 𝑡 ≤ 𝜎 𝑡 then</cell><cell></cell></row><row><cell>8</cell><cell>𝑅 𝑡 +1 ← 𝑅 𝑡 ∩ {ℎ 𝑟 𝑡 } ;</cell><cell>// reject</cell></row><row><cell>9</cell><cell></cell><cell></cell></row><row><cell>12</cell><cell>else</cell><cell></cell></row><row><cell>13</cell><cell>return 𝑅 𝑡 −1 ;</cell><cell></cell></row><row><cell>14</cell><cell>end</cell><cell></cell></row><row><cell>15</cell><cell>𝑡 ← 𝑡 + 1</cell><cell></cell></row><row><cell cols="2">16 end</cell><cell></cell></row><row><cell cols="2">17 return 𝑅 𝑡 −1 ;</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>FWER and the average number of rejections. 𝐹 has High utility : 𝐹 = {ℎ 1 , ℎ 2 , . . . , ℎ 20 } (2) 𝐹 has Medium utility : 𝐹 = {ℎ 1 , ℎ 6 , . . . , ℎ 96 } (3) 𝐹 has Low utility : 𝐹 = {ℎ 81 , ℎ 82 , . . . ℎ 100 }. Since we do not consider the Tarone's trick in this experiment, we adopt the z-test and set up the null hypothesis 𝐻 0 : 𝜇 = 0 for all hypotheses. Moreover, we generate a dataset 𝐷 𝑖 = {𝑥 𝑖 𝑗 } 20</figDesc><table><row><cell></cell><cell></cell><cell>FWER</cell><cell cols="3">Average number of rejects</cell></row><row><cell></cell><cell cols="4">High Medium Low High Medium</cell><cell>Low</cell></row><row><cell>SPUR</cell><cell>0.006</cell><cell>0.042</cell><cell>0.048 3.157</cell><cell>2.265</cell><cell>1.934</cell></row><row><cell>Bonferroni</cell><cell>0.039</cell><cell>0.041</cell><cell>0.041 3.493</cell><cell>3.488</cell><cell>3.480</cell></row><row><cell cols="2">w-Bonferroni 0.032</cell><cell>0.038</cell><cell>0.049 4.504</cell><cell>3.199</cell><cell>1.803</cell></row><row><cell cols="2">invalid-SPUR 0.006</cell><cell>0.056</cell><cell>0.048 3.268</cell><cell>2.378</cell><cell>1.947</cell></row><row><cell cols="6">three settings where each is named by the usefulness of the false</cell></row><row><cell>hypotheses set.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>(1)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Number of patterns discovered by T-Bonferroni |𝑅 𝑇 | and SPUR |𝑅 𝑆 | along with the utility measure 𝐷 𝑢 = 𝐷 𝑢 (𝑅 𝑆 ∥𝑅 𝑇 ), for different 𝛼 𝛼 = 0.01 𝛼 = 0.05 𝛼 = 0.1 |𝑅 𝑇 | |𝑅 𝑆 | 𝐷 𝑢 |𝑅 𝑇 | |𝑅 𝑆 | 𝐷 𝑢 |𝑅 𝑇 | |𝑅 𝑆 | 𝐷 𝑢</figDesc><table><row><cell>Crash</cell><cell>83</cell><cell cols="3">75 12 120</cell><cell>94</cell><cell cols="4">6 136 106 13</cell></row><row><cell>Adult</cell><cell>45</cell><cell>26</cell><cell>0</cell><cell>57</cell><cell>32</cell><cell>2</cell><cell>63</cell><cell>36</cell><cell>3</cell></row><row><cell cols="6">Property 275 142 10 315 156</cell><cell cols="4">8 336 164 10</cell></row><row><cell>Person</cell><cell>133</cell><cell>73</cell><cell cols="2">2 156</cell><cell>83</cell><cell cols="2">2 163</cell><cell>87</cell><cell>1</cell></row><row><cell>Society</cell><cell cols="2">320 142</cell><cell cols="3">3 348 156</cell><cell cols="3">7 361 164</cell><cell>9</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Definition A.1 (SPUR process): A SPUR (stochastic) process is a stochastic process {𝑋 𝑡 } 𝑇 SPUR 𝑡 =1 stopped at stopping time 𝑇 SPUR where 𝑋 𝑡 = (𝛿 𝑡 , 𝑅 𝑡 , 𝑝 𝑟 𝑡 , ℎ 𝑟 𝑡 , 𝜎 𝑡 , 𝜏 𝑡 ) are obtained from the algorithm SPUR and 𝑇 SPUR = min{𝑡 ∈ [|𝐻 |] : 𝑝 𝑟 𝑡 &gt; 𝜎 𝑡 }. We remark that since we can obtain 𝐻 𝑡 = {ℎ ∈ 𝐻 |∀ ℎ 𝑟 ∈𝑅 𝑡 −1 , ℎ ≻ ℎ 𝑟 }, we do not need to include 𝐻 𝑡 in 𝑋 𝑡 . Using the stochastic process {𝑋 𝑡 } 𝑇 SPUR 𝑡 =1 , we next rewrite the event of rejecting at least one true hypotheses, i.e., the event of occuring a Type-I error. Lemma A.1: Consider a SPUR process {𝑋 𝑡 } 𝑇 SPUR 𝑡 =1 , let 𝐸 𝑡 = {ℎ 𝑟 𝑡 ∈ 𝑇 , 𝑝 𝑟 𝑡 ≤ 𝜎 𝑡 } and 𝑇 𝐸 = min{𝑡 ∈ [|𝐻 |] : 𝑡 ≤ 𝑇 SPUR ∧𝐸 𝑡 }, the following holds:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>.</head><label></label><figDesc>Definition A.2 (False hypotheses based process): A false hypotheses based process is a stochastic process {𝑌 𝑡 } 𝑇 FALSE</figDesc><table><row><cell cols="2">stopped at 𝑡 ) are obtained 𝑡 =1 𝑡 , 𝜏  *  𝑡 , 𝜎  *  𝑡 , ℎ 𝑟  *  𝑡 , 𝑝 𝑟  *  𝑡 , 𝑅  *  stopping time 𝑇 False where 𝑌 𝑡 = (𝛿  *</cell></row><row><cell cols="2">from the algorithm SPUR with the following modification:</cell></row><row><cell>𝑝 𝑟  *  𝑡 = min ℎ ∈𝐻  *  𝑡 ∩𝐹</cell><cell>𝑝 ℎ and ℎ 𝑟  *  𝑡 = argmin ℎ ∈𝐻  *  𝑡 ∩𝐹 𝑝 ℎ .</cell></row><row><cell cols="2">Next, we define a sequence of true hypotheses' p-values {𝑝 𝑇  *  𝑡 } 𝑇 False 𝑡 =1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>6: Relation graph of {𝑌 𝑡 } 𝑡 (we let 𝑘 = 𝑇 False in the graph) for 𝑡 ≤ 𝑇 FALSE : 𝑝 𝑇 * 𝑡 = 𝑓 (𝑌 𝑡 , {𝑝 ℎ } ℎ ∈𝑇 ) = min Since at each step, SPUR rejects the most significant hypothesis ℎ 𝑟 𝑡 = 𝑚𝑖𝑛 ℎ ∈𝐻 𝑡 𝑝 ℎ , the event {ℎ 𝑟 𝑡 ∈ 𝑇 } (and {ℎ 𝑟 𝑡 ∈ 𝐹 }) depends on the comparison of 𝑚𝑖𝑛 ℎ ∈𝐻 𝑡 ∩𝐹 𝑝 ℎ and 𝑚𝑖𝑛 ℎ ∈𝐻 𝑡 ∩𝑅 𝑝 ℎ . We next consider this comparison via the false hypotheses based process and the alternative true hypotheses sequence, while claims its relation to Lemma A.1. 𝑡 ≤ 𝑇 False ∧ 𝐸 * 𝑡 } and 𝑇 𝐸 as defined in Lemma A.1, 𝑇 𝐸 ≥ 𝑇 * 𝐸 almost surely. We also give an illustration on the events 𝐸 * 𝑡 and their relationship with other entities in Figure 6. We have that Pr 𝑅 ∩ 𝑇 ≠ ∅ ≤ Pr 𝑇 𝐸 ≤ |𝐻 | ≤ Pr 𝑇 * 𝐸 ≤ |𝐻 | from Lemma A.2. Moreover, since Pr 𝑇 * 𝐸 ≤ |𝐻 | = E {𝑝 ℎ } ℎ∈𝐹 Pr 𝑇 * 𝐸 ≤ |𝐻 | | {𝑝 ℎ } ℎ ∈𝐹 . we next find the upper bound of Pr 𝑇 * 𝐸 ≤ |𝐻 | | {𝑝 ℎ } ℎ ∈𝐹 . Lemma A.3: Using the same definition of Lemma A.2 and let 𝑘 = 𝑇 False , under Assumption 3.1, the following holds:</figDesc><table><row><cell>event 𝐸  *</cell><cell cols="2">𝑇 False 𝑡 =1 (shaded), {𝑝 𝑇  *  𝑡 } 𝑇 False 𝑡 =1 and</cell></row><row><cell></cell><cell>ℎ ∈𝐻  *  𝑡 ∩𝑇</cell><cell>𝑝 ℎ .</cell></row><row><cell cols="3">Lemma A.2: Consider {𝑌 𝑡 } 𝑇 False 𝑡 =1 and {𝑝 𝑇  *  𝑡 } 𝑇 False 𝑡 =1 as defined in Def-inition A.2 and A.3. Let 𝐸  *  𝑡 = {𝑝 𝑇  *  𝑡 ≤ 𝑝 𝑟  *  𝑡 , 𝑝 𝑇  *  𝑡 ≤ 𝜎  *  𝑡 } and 𝑇  *  𝐸 =</cell></row><row><cell>min{𝑡 ∈ [|𝐻 |] :</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>𝑖,𝑠 ′ , 𝑦 𝑖 } where 𝑥 𝑖,𝑠 = 1 if pattern 𝑠 is included in transaction 𝑖.Since Fisher's exact test assumes that the margin distribution 𝑛 1 , 𝑛 𝐷 and 𝑛 𝑠 , 𝑛 𝑠 ′ are fixed, the only remaining r.v. in obtaining the p-value are 𝑎 𝑠 and 𝑎 𝑠 ′ , where𝑎 𝑠 = 𝑖 ∈ [𝑛 𝐷 ],𝑥 𝑠 𝑖 =1 𝑦 𝑖 and 𝑎 𝑠 ′ = 𝑖 ∈ [𝑛 𝐷 ],𝑥 𝑠 ′ 𝑖 =1 𝑦 𝑖 . Letting 𝐼 𝑠 = {𝑖 ∈ [𝑛 𝐷 ], 𝑥 𝑠 𝑖 = 1}, 𝐼 𝑠 ′ = {𝑖 ∈ [𝑛 𝐷 ], 𝑥 𝑠 ′ 𝑖 = 1}, from the design of 𝑠 and 𝑠 ′ , we have 𝐼 𝑠 ∩ 𝐼 𝑠 ′ = ∅. Hence, 𝑎 𝑠 and 𝑎 𝑠 ′ are obtained using mutually distinguish transactions. We next consider the independence of (𝑥 𝑠 𝑖 , 𝑦 𝑠 𝑖 ) and(𝑥 𝑠 ′ 𝑖 ′ , 𝑦 𝑠 ′ 𝑖 ′ ) for 𝑖 ≠ 𝑖 ′ : Pr 𝑥 𝑠 ′ 𝑖 ′ , 𝑦 𝑠 ′ 𝑖 ′ | 𝑥 𝑠 𝑖 , 𝑦 𝑠 𝑖 = Pr 𝑦 𝑠 ′ 𝑖 ′ | 𝑥 𝑠 ′ 𝑖 ′ , 𝑥𝑠 𝑖 , 𝑦 𝑠 𝑖 Pr 𝑥 𝑠 ′ 𝑖 ′ | 𝑥 𝑠 𝑖 , 𝑦 𝑠 𝑖 = Pr 𝑦 𝑠 ′ 𝑖 ′ , 𝑥 𝑠 ′ On the other hand, since ℎ 𝑠 is a true hypotheses, we have 𝑥 𝑠 𝑖 ⊥𝑦 𝑠 𝑖 . Pr 𝑥 𝑠 𝑖 , 𝑦 𝑠 𝑖 = Pr 𝑥 𝑠 𝑖 Pr 𝑦 𝑠 𝑖 Hence, Pr 𝑥 𝑠 ′ 𝑖 ′ , 𝑦 𝑠 ′ 𝑖 ′ | 𝑥 𝑠 𝑖 , 𝑦 𝑠 𝑖 = Pr 𝑥 𝑠 ′ 𝑖 ′ , 𝑦 𝑠 ′ 𝑖 ′ Pr 𝑥 𝑠 ′ 𝑖 ′ , 𝑥 𝑠 𝑖 Pr 𝑥 𝑠 ′ 𝑖 ′ | 𝑥 𝑠 𝑖 Pr 𝑥 𝑠 𝑖 Pr 𝑥 𝑠 𝑖 = Pr 𝑥 𝑠 ′ 𝑖 ′ , 𝑦 𝑠 ′ 𝑥 𝑠 ′ 𝑖 ′ , 𝑦 𝑠 ′ 𝑖 ′ ⊥𝑦 𝑠 𝑖 | 𝑥 𝑠 𝑖 . Moreover, Fisher's exact test assumes that |{𝑖 : 𝑥 𝑠 𝑖 = 1}| = 𝑛 𝑠 for any dataset 𝐷 = {𝑡 𝑖 , 𝑦 𝑖 } 𝑛 𝐷 𝑖=1 ∼ D. We have {𝑥 𝑠 ′ 𝑖 ′ , 𝑦 𝑠 ′ 𝑖 ′ } 𝑖 ∈𝐼 𝑠 ⊥{𝑥 𝑠 𝑖 , 𝑦 𝑠 𝑖 } 𝑖 ∈𝐼 𝑠 | 𝑛 𝑠 , 𝑛 𝑠 ′ , 𝑛 𝐷 =⇒ 𝑎 𝑠 ⊥𝑎 𝑠 ′ | 𝑛 𝑠 , 𝑛 𝑠 ′ , 𝑛 𝐷 =⇒ {𝑝 ℎ } ℎ ∈𝑇 ⊥{𝑝 ℎ } ℎ ∈𝐹 | 𝑛 𝑠 , 𝑛 𝑠 ′ , 𝑛 𝐷 . Proof. First, we remind that 𝜎 𝑡 and 𝜎 𝑡 +1 are obtained as follows 𝜎 𝑡 = max{𝜎 : (𝜎 − 𝑝 𝑟 𝑡 −1 )|𝜅 𝑡 (𝜎)| ≤ 𝛿 𝑡 } 𝜎 𝑡 +1 = max{𝜎 : (𝜎 − 𝑝 𝑟 𝑡 )|𝜅 𝑡 +1 (𝜎)| ≤ 𝛿 𝑡 +1 }. Because 𝐻 𝑡 +1 ⊂ 𝐻 𝑡 and |𝜅 𝑡 (𝜎 𝑡 )| ≤ 𝛿 𝑡 𝜎 𝑡 −𝑝 𝑟 𝑡 −1 , we have |𝜅 𝑡 +1 (𝜎 𝑡 )| &lt; |𝜅 𝑡 (𝜎 𝑡 )| ≤ 𝛿 𝑡 𝜎 𝑡 − 𝑝 𝑟 𝑡 −1 =⇒ |𝜅 𝑡 +1 (𝜎 𝑡 )|(𝜎 𝑡 − 𝑝 𝑟 𝑡 ) &lt; 𝛿 𝑡 𝛿 𝑡 +1 = 𝛿 𝑡 − 𝜏 𝑡 (𝑝 𝑟 𝑡 − 𝑝 𝑟 𝑡 −1 ) + 𝑝 𝑟 𝑡 = 𝛿 𝑡 𝜎 𝑡 − 𝑝 𝑟 Thus, |𝜅 𝑡 +1 (𝜎 𝑡 )|(𝜎 𝑡 − 𝑝 𝑟 𝑡 ) &lt; 𝛿 𝑡 +1 − 𝑝 𝑟 𝑡 ≤ 𝛿 𝑡 +1 and 𝜎 𝑡 +1 ≥ 𝜎 𝑡 due to the maximal operation.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>B.3 Proof of Lemma6.1</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>𝜎 𝑡 − 𝑝 𝑟 𝑡</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>𝑡 −1 𝜎 𝑡 − 𝑝 𝑟</cell><cell>.</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>On the other hand,</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>𝑡 𝑡 −1 𝜎 𝑡 − 𝑝 𝑟</cell><cell>+ 𝑝 𝑟 𝑡 .</cell></row><row><cell></cell><cell>𝑖 ′</cell><cell cols="2">Pr 𝑥 𝑠 ′ 𝑖 ′ , 𝑥 𝑠 𝑖</cell></row><row><cell></cell><cell>Pr 𝑥 𝑠 ′ 𝑖 ′ | 𝑥 𝑠 𝑖 , 𝑦 𝑠 𝑖</cell><cell cols="2">Pr 𝑥 𝑠 𝑖 | 𝑦 𝑠 𝑖</cell></row><row><cell>=</cell><cell cols="2">Pr 𝑦 𝑠 ′ 𝑖 ′ , 𝑥 𝑠 ′ 𝑖 ′ 𝑖 ′ | 𝑥 𝑠 𝑖 Pr 𝑥 𝑠 𝑖 | 𝑦 𝑠 𝑖 Pr 𝑥 𝑠 ′</cell><cell>Pr 𝑥 𝑠 ′ 𝑖 ′ , 𝑥 𝑠 𝑖 Pr 𝑥 𝑠 𝑖 | 𝑦 𝑠 𝑖</cell><cell>.</cell></row><row><cell></cell><cell></cell><cell>𝑖 ′</cell><cell></cell></row><row><cell></cell><cell></cell><cell>.</cell><cell></cell></row><row><cell></cell><cell cols="2">Pr 𝑥 𝑠</cell><cell></cell></row><row><cell></cell><cell></cell><cell>𝑖</cell><cell></cell></row><row><cell cols="2">Thus, This concludes our proof.</cell><cell></cell><cell></cell><cell>□</cell></row></table><note>□ B.4 Proof of Theorem 6.2</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">Stated differently, we assume that the test statistics obtained from the true patterns and the false patterns are mutually independent and the p-values are determined using these test statistics.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">The completed proof is available at https://github.com/dizzyvn/SPUR/ Research Track Paper KDD '20, August 23-27, 2020, Virtual Event, USA</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was partly supported by KAKENHI (Grants-in-Aid for Scientific Research) Grant Numbers JP19H04164 and JP18H04099. We are also grateful to Professor Takeuchi for providing useful discussions and advices.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fast algorithms for mining association rules</title>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramakrishnan</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th int. conf. very large data bases, VLDB</title>
				<meeting>20th int. conf. very large data bases, VLDB</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">1215</biblScope>
			<biblScope unit="page" from="487" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the adaptive control of the false discovery rate in multiple testing with independent statistics</title>
		<author>
			<persName><forename type="first">Yoav</forename><surname>Benjamini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yosef</forename><surname>Hochberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of educational and Behavioral Statistics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="60" to="83" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">Aylmer</forename><surname>Ronald</surname></persName>
		</author>
		<author>
			<persName><surname>Fisher</surname></persName>
		</author>
		<title level="m">Statistical methods for research workers. Statistical methods for research workers</title>
				<imprint>
			<date type="published" when="1950">1950. 1950</date>
		</imprint>
	</monogr>
	<note>llth ed. revised</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">Wensheng</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerry</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Chun-Wei</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Fournier-Viger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Han-Chieh</forename><surname>Chao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><forename type="middle">S</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1805.10511</idno>
		<title level="m">A survey of utility-oriented pattern mining</title>
				<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Kingfisher: an efficient algorithm for searching for both positive and negative dependency rules with statistical significance measures</title>
		<author>
			<persName><forename type="first">Wilhelmiina</forename><surname>Hämäläinen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge and information systems</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="383" to="414" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A simple sequentially rejective multiple test procedure</title>
		<author>
			<persName><forename type="first">Sture</forename><surname>Holm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scandinavian journal of statistics</title>
		<imprint>
			<biblScope unit="page" from="65" to="70" />
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">Ronny</forename><surname>Kohavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barry</forename><surname>Becker</surname></persName>
		</author>
		<title level="m">Adult Data Set</title>
				<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Statistical emerging pattern mining with multiple testing correction</title>
		<author>
			<persName><forename type="first">Junpei</forename><surname>Komiyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masakazu</forename><surname>Ishihata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hiroki</forename><surname>Arimura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takashi</forename><surname>Nishibayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shin-Ichi</forename><surname>Minato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
				<meeting>the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="897" to="906" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Utilitybased association rule mining: A marketing solution for cross-selling</title>
		<author>
			<persName><forename type="first">Dongwon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sung-Hyuk</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Songchun</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Systems with applications</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="2715" to="2725" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">Felipe</forename><surname>Llinares-López</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laetitia</forename><surname>Papaxanthos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dean</forename><surname>Bodenham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damian</forename><surname>Roqueiro</surname></persName>
		</author>
		<title level="m">COPDGene Investigators, and Karsten Borgwardt</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Genome-wide genetic heterogeneity discovery with categorical covariates</title>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="1820" to="1828" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast and memory-efficient significant pattern mining via permutation testing</title>
		<author>
			<persName><forename type="first">Felipe</forename><surname>Llinares-López</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mahito</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laetitia</forename><surname>Papaxanthos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karsten</forename><surname>Borgwardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21th ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 21th ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="725" to="734" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A fast method of statistical assessment for combinatorial hypotheses based on frequent itemset enumeration</title>
		<author>
			<persName><forename type="first">Shin-Ichi</forename><surname>Minato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takeaki</forename><surname>Uno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koji</forename><surname>Tsuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aika</forename><surname>Terada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Sese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Joint European Conference on Machine Learning and Knowledge Discovery in Databases</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="422" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">Leonardo</forename><surname>Pellegrina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matteo</forename><surname>Riondato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabio</forename><surname>Vandin</surname></persName>
		</author>
		<title level="m">SPuManTE: Significant Pattern Mining with Unconditional Testing</title>
				<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Ensemble-adjusted p values</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Rosenthal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">B</forename><surname>Rubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychological Bulletin</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page">540</biblScope>
			<date type="published" when="1983">1983. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><surname>Mcg Esb Service</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Crash Reporting -Drivers Data</title>
		<author>
			<persName><surname>Mcg Esb Service</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient algorithms for mining maximal high utility itemsets from data streams with different models</title>
		<author>
			<persName><forename type="first">Yu</forename><surname>Bai-En Shie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><forename type="middle">S</forename><surname>Philip</surname></persName>
		</author>
		<author>
			<persName><surname>Tseng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Systems with Applications</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="12947" to="12960" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Finding statistically significant interactions between continuous features</title>
		<author>
			<persName><forename type="first">Mahito</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karsten</forename><surname>Borgwardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Joint Conference on Artificial Intelligence</title>
				<meeting>the 28th International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="3490" to="3498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A modified Bonferroni method for discrete data</title>
		<author>
			<persName><surname>Robert E Tarone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrics</title>
		<imprint>
			<biblScope unit="page" from="515" to="522" />
			<date type="published" when="1990">1990. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Statistical significance of combinatorial regulations</title>
		<author>
			<persName><forename type="first">Aika</forename><surname>Terada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariko</forename><surname>Okada-Hatakeyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koji</forename><surname>Tsuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Sese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the National Academy of Sciences</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="page" from="12996" to="13001" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Significant pattern mining with confounding variables</title>
		<author>
			<persName><forename type="first">Aika</forename><surname>Terada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koji</forename><surname>Tsuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific-Asia Conference on Knowledge Discovery and Data Mining</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="277" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Discovering significant patterns</title>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">I</forename><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine learning</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A multiple test correction for streams and cascades of statistical hypothesis tests</title>
		<author>
			<persName><forename type="first">I</forename><surname>Geoffrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Webb</surname></persName>
		</author>
		<author>
			<persName><surname>Petitjean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
				<meeting>the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1255" to="1264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Mining itemset utilities from transaction databases</title>
		<author>
			<persName><forename type="first">Hong</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data &amp; Knowledge Engineering</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
