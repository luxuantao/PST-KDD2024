<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Concepts and Realization of a Diagram Editor Generator Based on Hypergraph Transformation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Mark</forename><surname>Minas</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lehrstuhl für Programmiersprachen</orgName>
								<orgName type="institution">Universität Erlangen-Nürnberg</orgName>
								<address>
									<addrLine>Martensstr. 3</addrLine>
									<postCode>91058</postCode>
									<settlement>Erlangen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Concepts and Realization of a Diagram Editor Generator Based on Hypergraph Transformation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A845172515CF68A937C00043F01134EA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:10+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Diagram editors</term>
					<term>rapid prototyping</term>
					<term>hypergraph grammar</term>
					<term>hypergraph transformation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Diagram editors which are tailored to a specific diagram language typically support either syntax-directed editing or free-hand editing, i.e., the user is either restricted to a collection of predefined editing operations, or he is not restricted at all, but misses the convenience of such complex editing operations. This paper describes DiaGen, a rapid prototyping tool for creating diagram editors which support both modes in order to get their combined advantages. Created editors use hypergraphs as an internal diagram model and hypergraph parsers for syntactic analysis whereas syntax-directed editing is realized by programmed hypergraph transformation of these internal hypergraphs. This approach has proven to be powerful and general in the sense that it supports quick prototyping of diagram editors and does not restrict the class of diagram languages which it can be applied to.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Diagram editors are graphical editors which are tailored to a specific diagram language; they can be distinguished from pure drawing tools by their capability of "understanding" edited diagrams to some extent. Furthermore, diagram editors do not allow to create arbitrary drawings, but are restricted to visual components which occur in the diagram language. For instance, an editor for UML class diagrams typically does not allow to draw a transistor symbol which would be possible in a circuit diagram editor. Current diagram editors support either syntax-directed editing or free-hand editing.</p><p>Syntax-directed editors provide a set of editing operations. Each of these operations is geared to modify the meaning of the diagram. This editing mode requires an internal diagram model that is primarily modified by the operations; diagrams are then updated according to their modified model. These models are most commonly described by some kind of graph; editing operations are then represented by graph transformations (e.g. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>).</p><p>Diagram editors providing free-hand editing are low-level graphics editors which allow the user to directly manipulate the diagram. The graphics editor becomes a diagram editor by offering only pictorial objects which are used by the visual language and by combining it with a parser. A parser is necessary for checking the correctness of diagrams and analyzing the syntactic structure of the diagram. There are grammar formalisms and parsers that do not require an internal diagram model as an intermediate diagram representation, but operate directly on the diagram (e.g., constraint multiset grammars <ref type="bibr" target="#b2">[3]</ref>). Other approaches use an internal model which is analyzed by the parser (e.g., VisPro <ref type="bibr" target="#b3">[4]</ref>). Again, graphs are the most common means for describing such a model.</p><p>The advantage of free-hand editing over syntax-directed editing is that a diagram language can be defined by a concise (graph) grammar only; editing operations can be omitted. The editor does not force the user to edit diagrams in a certain way since there is no restriction to predefined editing operations. However, this may turn out to be a disadvantage since editors permit to create any diagram; they do not offer explicit guidance to the user. Furthermore, freehand editing requires a parser and is thus restricted to diagrams and (graph) grammars which offer efficient parsers. So far, diagram editors either support syntax-directed editing or free-hand editing. An editor that supports both editing modes at the same time would combine the positive aspects of both editing modes and reduce their negative ones. Despite this observation, there is only one such proposal which has not yet been realized known to us: Rekers and Schürr propose to use two kinds of graphs as internal representations of diagrams <ref type="bibr" target="#b4">[5]</ref>: the spatial relationship graph (SRG) abstracts from the physical diagram layout and represents higher level spatial relations. Additionally, an abstract syntax graph (ASG) that represents the logical structure of the diagram is kept up-to-date with the SRG. Contextsensitive graph grammars are used to define the syntax of both graphs. Freehand editing of diagrams is planned to modify the first graph, syntax-directed editing is going to modify the second. In each case, the other graph is modified accordingly. Therefore, a kind of diagram semantics is available by the ASG. However, this approach requires almost a one-to-one relationship between SRG and ASG. This is not required in the approach of this paper. We will come back to this approach in the conclusions (cf. Section 6). This paper describes DiaGen, a rapid-prototyping tool for creating diagram editors that support both editing modes at the same time. DiaGen (Diagram editor Generator) supports free-hand editing based on an internal hypergraph model which is parsed according to some hypergraph grammar. Attribute evaluation which is directed by the syntactic structure of the diagram is then used for creating a user-specified semantic representation of the diagram. This freehand editing mode is seamlessly extended by a syntax-directed editing mode, which also requires an automatic layout mechanism for diagrams. Support for automatic diagram layout which is used for both syntax-directed editing and free-hand editing is briefly outlined, too.</p><p>The next section gives an overview of the DiaGen tool and the common architecture of editors being created with DiaGen. Section 3 then explains the free-hand editing mode of these editors and the diagram analysis steps which are necessary for translating freely edited diagrams into some semantic representation. The integration of additional syntax-directed editing operations into such editors is explained in Section 4. An automatic layout mechanism, which is required by syntax-directed editing, is outlined in Section 5. Section 6 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DiaGen</head><p>DiaGen provides an environment for rapidly developing diagram editors. This section first outlines this environment and how it is used for creating a diagram editor that is tailored to a specific diagram language. Each of such DiaGen editors is based on the same editor architecture which is adjusted to the specific diagram language. This architecture is described afterwards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The DiaGen environment</head><p>DiaGen is completely implemented in Java and consists of an editor framework and a program generator. DiaGen is free software and can be downloaded from the DiaGen web site <ref type="bibr" target="#b5">[6]</ref>.</p><p>Fig. <ref type="figure" target="#fig_0">1</ref> shows the structure of DiaGen and the process of using it as a rapidprototyping tool for developing diagram editors. The framework, as a collection of Java classes, provides the generic editor functionality which is necessary for editing and analyzing diagrams. In order to create an editor for a specific diagram language, the editor developer primarily has to supply a specification, which textually describes syntax and semantics of the diagram language.</p><p>Additional program code which is written "manually" can be supplied, too. Manual programming is necessary for the visual representation of diagram components on the screen and for processing specific data structures of the problem domain, e.g., for semantic processing when using the editor as a component of another software system. The specification is then translated into Java classes by the program generator.</p><p>The generated classes, together with the editor framework and the manually written code, implement an editor for the specified diagram language. This editor can run as a stand-alone program. But it can also be used as a software component since the editor framework as well as the generated program code is conformable with the JavaBeans standard, the software component model for Java. Diagram editors which have been developed using DiaGen (such editors are called "DiaGen editors" in the following) provide the following features:</p><p>• DiaGen editors always support free-hand editing. The editor framework contains a generic drawing tool which is adjusted to the specified diagram language by the program generator. The visual representation of diagram components which are used by the drawing tool has to be supplied by the editor developer. The editor framework provides an extensive class library for that purpose. Diagrams that are drawn using the drawing tool are internally modeled by hypergraphs which are analyzed primarily by a hypergraph parser (cf. Section 3). The hypergraph grammar which is used by the hypergraph parser is the core of the diagram language specification. The analysis results are used to provide user feedback on diagram parts which are not correct with respect to the diagram language. • Diagrams which are created using a DiaGen editor are translated into a semantic representation. This process is driven by the syntactic analysis and makes use of program code and data structures which are provided as "editor specific program code" in Fig. <ref type="figure" target="#fig_0">1</ref>. The reverse translation, i.e., creating diagrams from external representations, is also supported by a mechanism that is similar the one of syntax-directed editing operations.</p><p>• DiaGen editors optionally support syntax-directed editing, too, if the editor developer has specified syntax-directed editing operations. These operations are primarily hypergraph transformations which modify the internal hypergraph model of edited diagrams (cf. Section 4). DiaGen editors can be specified and developed in a rapid prototyping fashion without any syntax-directed editing operation. Any diagram of the diagram language can be created by free-hand editing only. Desirable editing operations can be added later.</p><p>• Automatic layout is an optional DiaGen editor feature, too, but which is obligatory when specifying syntax-directed operations. The rest of this paper presents the concepts and realization of these features by means of a formal specification based on hypergraph transformation and generating the editor using such a specification. Each of these editors has the same architecture which is considered next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The DiaGen editor architecture</head><p>Fig. <ref type="figure" target="#fig_1">2</ref> shows the structure which is common to all DiaGen editors and which is described in the following paragraphs. Ovals are data structures, and rectangles represent functional components. Gray rectangles are parts of the editor framework which have been adjusted by the DiaGen program generator based on the specification of the specific diagram language. Flow of information is represented by arrows. If not labeled, information flow means reading resp. creating the corresponding data structures.</p><p>The editor supports free-hand editing by means of the included drawing tool which is part of the editor framework, but which has been adjusted by the program generator. With this drawing tool, the editor user can create, arrange and modify diagram components which are specific to the diagram language.</p><p>Editor specific program code which has been supplied by the editor developer is responsible for the visual representation of these language specific components. Examples are rectangular text boxes or diamond-shaped conditions in flowcharts. Fig. <ref type="figure" target="#fig_2">3</ref> shows a screenshot of such an editor whose visual appearance is characterized by its drawing tool. When components are selected, so-called handles -like in conventional drawing tools -show up which allow to move or modify single or grouped diagram components like with common off-the-shelf drawing tools (cf. Fig. <ref type="figure" target="#fig_10">9a</ref>). The drawing tool creates the data structure of the diagram as a set of diagram components together with their attributes (position, size, etc.).</p><p>The sequence of processing steps which starts with the modeler and ends with attribute evaluation (cf. Fig.  These processing steps, which have been outlined referring to Fig. <ref type="figure" target="#fig_1">2</ref>, are described in more detail in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Free-Hand Editing</head><p>This section describes the processing steps of a DiaGen editor which are used for free-hand editing and which are shown in Fig. <ref type="figure" target="#fig_1">2</ref>. DiaGen has been used for creating editors for many diagram languages (e.g., UML diagrams, ladder diagrams, Petri nets). As a sample diagram language, this paper uses flowcharts although it is an admittedly simple language. However, other languages are less suited for presentation in a paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The hypergraph model</head><p>Each diagram consists of a finite set of diagram components, each of which is determined by its attributes. For flowcharts, there are rectangular text boxes and diamond-shaped conditions whose positions are defined by their x and y coordinates and their size by a width and a height attribute. Vertical as well as horizontal lines and arrows have x and y coordinates of their starting and end points on the canvas. However, attributes describe an arrangement of diagram components only in terms of numbers. The meaning of a diagram is determined by the diagram components and their spatial arrangement. The specific arrangement of flowchart components is made up of boxes and diamonds which are connected by arrows and lines in a very specific way. Arrangements can always be described by spatial relationships between diagram components. For that purpose, each diagram component typically has several distinct attachment areas at which it can be connected to other diagram components.</p><p>A flowchart diamond, e.g., has its top vertex as well as its left and right one where it can be connected to lines and arrows, whereas lines and arrows have their end points as well as their line (please note that arrows can be connected to the middle of another arrow as shown in Fig. <ref type="figure" target="#fig_2">3</ref>) as attachment areas. Connections can be established by spatially related (e.g., overlapping) attachment areas as with flowcharts where an arrow has to end at an exact position in order to be connected to a diamond.</p><p>DiaGen uses hypergraphs to describe a diagram as a set of diagram components and the relationships between attachment areas of "connected" components. Hypergraphs consist of two finite sets of nodes and hyperedges (or simply edges for short). Each hyperedge carries a type and is connected to an ordered sequence of nodes. The sequence has a certain length which is called arity of the hyperedge and which is determined by the type of the edge. Each node of this sequence is called "visited" by the hyperedge. Familiar directed edge-labeled graphs are special hypergraphs where each hyperedge has arity 2.</p><p>Hypergraphs are an obvious means for modeling diagrams: Each diagram component is modeled by a hyperedge. The kind of diagram component is the hyperedge type, the number of attachment areas is its arity. Attachment areas are modeled by nodes which are visited by the hyperedge. The sequence of visited nodes determines which attachment area is modeled by which node. The set of diagram components is thus represented by a set of nodes and a set of hyperedges where each node is visited by exactly one hyperedge. Relationships between attachment areas are modeled by hyperedges of arity 2. They carry a type which describes the kind of relationship between related attachment areas.  Hypergraph models are created by the modeler of DiaGen editors: The modeler first creates component edges for each diagram component and nodes for each of their attachment areas. Afterwards, the modeler checks for each pair of attachment areas whether they are related as defined in the specification. <ref type="foot" target="#foot_1">2</ref>The language specification describes such relationships in terms of relations on attribute values of corresponding attachment areas. E.g., in the flowchart example, the end attachment area of a vertical arrow and the upper attachment area of a rectangular box are flowIn-related if both attachment areas overlap, i.e., have close positions on the canvas. For each relationship which is detected, the modeler adds a corresponding relation edge between corresponding nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The reduced hypergraph model</head><p>Hypergraph models tend to be quite large even for small diagrams. For instance, Fig. <ref type="figure" target="#fig_3">4</ref> shows only a small portion of the hypergraph model of the really small flowchart of Fig. information is contained by the set of boxes and conditions which are interconnected by lines and arrows. The specific path of lines and arrows between connected boxes is irrelevant. DiaGen editors therefore do not analyze the hypergraph model directly, but first identify such groups of components and relationships. Similar to common compiler techniques where lexical analysis is used to group input stream characters to tokens (e.g., identifiers and keywords) and leaving other characters unconsidered (e.g., comments), the reducer searches for all matches of specified patterns and creates a reduced hypergraph model which then represents the diagram structure directly.</p><p>Similar to compiler generators which require a specification of lexical analysis, the reducer has to be specified for a specific diagram language. DiaGen provides reduction rules to this end: Each rule consists of a pair (P, R) of hypergraphs and additional application conditions. P is the pattern whose occurrences are searched in the hypergraph model. The hypergraph R ("result") describes a modification to the reduced hypergraph for each match of P which also satisfies the application conditions. Fig. <ref type="figure">5</ref> shows five reduction rules for flowcharts in the form P ⇒ R. The pattern of the rightmost rule actually consists of the vArrow edge with its three visited nodes only.  • Nodes which are matched by no P -hypergraph of any rule do not have corresponding nodes in the reduced model. • If there are nodes which lie in different pattern occurrences where none of these pattern nodes has a corresponding node in its R graph, these nodes do not have corresponding nodes in the reduced model. • Two or more P -nodes may correspond to a single R-node (e.g., a = b = c in the second and fourth rule). All the nodes of the hypergraph model which match these "identified" P -nodes correspond to a single node of the reduced hypergraph model.</p><p>Fig. <ref type="figure" target="#fig_6">6</ref> shows the reduced hypergraph model of the flowchart of Fig. <ref type="figure" target="#fig_2">3</ref> and which is created by these reduction rules. The structure of this model is similar to the structure of the hypergraph model. Because of the reduction rules which identify nodes, a much cleaner hypergraph model is created. The conn edges are grayed out since they are actually not needed for the following syntactic analysis; the corresponding reduction rules could be omitted for pure free-hand editing editors. Section 4 however shows why they are needed in the context of syntax-directed editing operations.</p><p>The concept of reduction rules is similar to hypergraph transformation rules L ::= R (or L → R) with L (left-hand side, LHS) and R (right-hand side, RHS) being hypergraphs <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. A transformation rule L ::= R is applied to a (host) hypergraph H by finding L as a subgraph of H and replacing this match by R obtaining hypergraph H ′ . We say, H ′ is derived from H in one (derivation) step. A derivation sequence is a sequence of derivation steps where the resulting hypergraph of each step is immediately derived in the next step. The following observations show that specifying the reducer and the reducing process for a specific diagram language would be rather difficult if the reducer had been defined in terms of such derivation sequences from hypergraph models to reduced ones. Instead, the reducer applies all reduction rules to all occurrences of their left-hand sides in some kind of parallel fashion:</p><p>• Patterns frequently overlap. This is so since the meaning of a group of diagram components and relationships -and this "meaning" is tried to be represented by the edges of the reduced hypergraph model -often depends on context which is part of another group. E.g., the last rule of Fig. <ref type="figure">5</ref> uses a flowOut edge as (negative) context which also occurs in the pattern of the third rule. Applying one rule would change the context of the other one if regular hypergraph transformations were used. It would be a difficult task to specify the desired reducing semantics. • There are in general many different derivation sequences starting at a specific hypergraph which would produce different reduced hypergraphs because of these overlapping patterns. The editor developer had to take measures to avoid this nondeterminism. However, it is a nontrivial task to set up such confluent sets of transformations <ref type="bibr" target="#b8">[9]</ref>.</p><p>Instead, reduction rules are applied as follows: All possible matches of all rule patterns are searched first without changing the hypergraph. But only those matches are selected which satisfy the corresponding application conditions. In a second step, the corresponding result hypergraphs are instantiated in parallel for each valid match of the corresponding pattern. All these hypergraphs are connected by common nodes according to the correspondence between nodes of the hypergraph model and the reduced one. 3   The reduced hypergraph model now directly represents the structure of the diagram which is syntactically analyzed by the parser.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Parsing</head><p>The syntactic structure of a diagram is described in terms of its reduced hypergraph model, i.e., a diagram language corresponds to a class of hypergraphs.</p><p>In the literature, there exist two main approaches for specifying graph or hypergraph classes. The first one uses a graph schema which is a kind of Entity-Relationship diagram that describes how edges and nodes of certain types may interconnect (e.g., EER <ref type="bibr" target="#b10">[11]</ref>). The other one uses some kind of graph or hyper- 3 In a formal treatment, each reduction rule (P, R) represents a hypergraph morphism P → P ∪R where P ∪R is the union of the pattern with the result hypergraph.</p><p>Corresponding nodes of P and R as well as identified nodes of R are identified in P ∪R. The reduced hypergraph model is computed by first creating the colimes of all match morphisms of the different patterns into the hypergraph model together with all these morphisms P → P ∪ R, and then removing the edges and "unnecessary" nodes of the hypergraph model from the colimes hypergraph <ref type="bibr" target="#b9">[10]</ref>.</p><p>graph grammar (e.g. <ref type="bibr" target="#b11">[12]</ref>) which generalizes the idea of Chomsky grammars for strings which are also used by standard compiler generators <ref type="bibr" target="#b12">[13]</ref>. Because of the similarity of diagram analysis with program analysis being performed by compilers and the availability of derivation trees and directed acyclic graphs (DAGs, see below) which easily allow to represent the syntactic structure of a diagram, DiaGen uses a hypergraph grammar approach for specifying the class of reduced hypergraph models of the diagram language.</p><p>As already mentioned, hypergraph grammars are similar to string grammars. Each hypergraph grammar consists of two finite sets of terminal and nonterminal hyperedge labels and a starting hypergraph which contains nonterminally labeled hyperedges only. Syntax is described by a set of hypergraph transformation rules which are called productions in this context. The hypergraph class or language of the grammar is defined by the set of terminally labeled hypergraphs which can be derived from the starting hypergraph in a finite derivation sequence.</p><p>There are different types of hypergraph grammars which impose restrictions on the LHS and RHS of each production as well as the allowed sequence of derivation steps. Context-free hypergraph grammars are the simplest ones: each LHS has to consist of a single nonterminally labeled hyperedge together with the appropriate number of nodes. Application of such a production removes the LHS hyperedge and replaces it by the RHS. Matching node labels of LHS and RHS determine how the RHS has to fit in after removing the LHS hyperedge. The productions of Fig. <ref type="figure" target="#fig_8">7</ref>  Actually, Fig. <ref type="figure" target="#fig_8">7</ref> shows the productions of a hypergraph grammar whose language is just the set of all reduced hypergraph models of structured flowcharts, i.e., flowcharts whose blocks have a single entry and a single exit only. The types statement, condition, and conn are terminal hyperedge labels being used in reduced hypergraph models. The set of nonterminal labels consists of Flowchart, BlockSeq, Block, and Conn. Flowchart edges do not connect to any node (arity 0). The starting hypergraph consists of just a single Flowchart edge. Again, conn edges, and now Conn edges, too, are grayed out since they are actually not required for free-hand editing, but for syntax-directed editing (cf. Section 4).</p><p>Context-free hypergraph grammars can describe only very limited hypergraph languages <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b13">14]</ref> and, therefore, are not suited for specifying the syntax of many diagram languages. <ref type="foot" target="#foot_2">4</ref> Context-free hypergraph grammars with embeddings are more expressive than context-free ones. They additionally allow embedding productions L ::= R where the RHS R extends the LHS L ⊆ R by some edges and nodes, which are "embedded" into the context provided by the LHS when applying such a production. This very limited treatment of context has been chosen since it has proven sufficient for all diagram languages which have been treated with DiaGen, but still allows for efficient parsing; context-free hypergraph grammars with embeddings even appear to be suitable for all possible kinds of diagram languages. 5 Parsing algorithms and a more detailed description of both grammar types can be found in <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b9">10]</ref>.</p><p>The most prominent feature of the parsing algorithms being used in DiaGen editors is their capability of dealing with diagram errors: Erroneous diagrams resp. their reduced hypergraph models are not just rejected. Instead, maximal subdiagrams resp. sub-hypergraphs are identified which are correct with respect to the hypergraph grammar. Feedback about these correct subdiagrams is provided to the user by drawing all diagram components with the same color whose representing edges belong to the same correct sub-hypergraph.</p><p>The result of this step of diagram analysis is the derivation structure of the reduced hypergraph which describes the syntactic structure of the diagram.</p><p>The derivation structure -similar to context-free string grammars -is a derivation tree if a context-free hypergraph grammar is used (For context-free hypergraph grammars with embeddings, it is a directed acyclic graph, the derivation DAG <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b9">10]</ref>). The tree root represents the nonterminal edge of the starting hypergraph, and the (terminal) edges of the reduced hypergraph 5 Plain context-free grammars with embeddings may be too restricted for some diagram languages, e.g., UML class diagrams <ref type="bibr" target="#b16">[17]</ref>. However, DiaGen allows to restrict productions by application conditions. With this feature, DiaGen can be applied to real-world languages like Statecharts and UML class diagrams <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b5">6]</ref>. model are represented as leaves of the tree. Fig. <ref type="figure" target="#fig_9">8</ref> shows the derivation tree of the reduced hypergraph model of Fig. <ref type="figure" target="#fig_6">6</ref>. Any conn edge, however, has been omitted for simplicity. Edges are written as their edge labels together with the labels of their visited nodes in parentheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Attribute evaluation</head><p>The task of the final step of diagram analysis is translating the diagram into some data structure which is specific for the application domain where the diagram editor is used. If, e.g., the flowchart editor is used as part of a programming tool, it should probably create some textual representation of the flowchart. For that purpose, DiaGen uses a common syntax-directed translation mechanism based on attribute evaluation similar to those of attribute string grammars <ref type="bibr" target="#b12">[13]</ref>: Each hyperedge carries some attributes. Number and types of these attributes which have to be specified by the editor developer depend on the hyperedge label. Productions of the hypergraph grammar may be augmented by attribute evaluation rules which compute values of some attributes that are accessible through those edges which are referred to by the production.</p><p>After parsing, attribute evaluation works as follows: Each hyperedge which occurs in the derivation tree (or DAG in general) has a distinct number of attributes; grammar productions which have been used for creating the tree impose rules how attribute values are computed as soon the value of others are known. Some (or even all) attribute values of terminal edges are already known; they have been derived from attributes of the diagram components during the reducing step (This feature has been omitted in Section 3.2). The attribute evaluation mechanism of the editor then computes a valid evaluation order. Please note that DiaGen does not require a specific form of attributed definition like S-or L-attributed definitions <ref type="bibr" target="#b12">[13]</ref>. At least when dealing with derivation DAGs these forms would fail. The editor developer, therefore, is allowed to define evaluation rules rather freely for each grammar production, and the evaluation mechanism has to determine an evaluation order for each diagram analysis run anew. Of course, the developer has to be careful in order not to introduce inconsistencies or cyclic attribute dependencies.</p><p>Syntax-directed translation in the context of flowcharts is rather simple. An obvious data structure representing a flowchart is textual program, e.g., in Pascal-like notation which is possible since syntactically flowcharts are well structured (at least when using the hypergraph grammar as shown in Fig. <ref type="figure" target="#fig_8">7</ref>).</p><p>For that purpose, each hyperedge needs a single attribute of type String: the terminal hyperedges contain the text of their corresponding diagram components whereas the nonterminal hyperedges contain the program text of their sub-diagram. Attribute evaluation rules are straight-forward.</p><p>Attribute evaluation is the last step of diagram analysis when editing diagrams by free-hand editing. The following section shows that syntax-directed editing is seamlessly integrated into DiaGen which means that editors make use of the diagram analysis as it has been described above even when editing diagrams in a syntax-directed way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Syntax-directed Editing</head><p>As discussed in the introduction, syntax-directed editing has several important benefits. Other approaches for free-hand editing which do not make use of abstract internal models (e.g., the Penguins system being based on constraint multiset grammars <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b19">20]</ref>) cannot extend free-hand editing by syntax-directed editing, which requires such an abstract model. But since the DiaGen approach is based on such a model (the hypergraph model), it is quite obvious to offer syntax-directed editing, too. However, free-hand editing using a parser requires that the hypergraph grammar remains the only syntax description of the reduced hypergraph model and thus the diagram language. Syntax-directed editing operations must not change the syntax of the diagram language; they can only offer some additional support to the user. This requirement has two immediate consequences:</p><p>• It is possible to specify editing rules that deliberately transform a correct diagram into an incorrect one with respect to the hypergraph grammar. This might appear to be an undesired feature; but consider the process of creating a complex diagram: the intermediate "drawings" need not, and generally do not make up a correct diagram, only the final "drawing". In order to support those intermediate incorrect results, syntax-directed editing operations have to allow for such "disimprovements", too.</p><p>• Editing operations are quite similar to macros in off-the-shelf text and graphics editors; they combine several actions, which can also be performed by free-hand editing, into one complex editing operation. However, syntaxdirected editing rules are actually much more powerful than such macros which offer only recording of editing operations and their playback as a complex operation: syntax-directed editing operations also take care of providing a valid diagram layout where this is possible (incorrect diagrams in general have no valid layout.) Furthermore, editing operations can take into account context information, and they may have rather complex application conditions.</p><p>This makes use of graph transformation an obvious choice for adding syntaxdirected editing to the free-hand editing mode: Editing operations are specified by hypergraph transformations on the hypergraph model as shown in Fig. <ref type="figure" target="#fig_1">2</ref>.</p><p>In the following it is explained why hypergraph transformations may have to use information from the reduced hypergraph model and the derivation structure, too. Whenever the hypergraph model has been changed by some transformation, it has to be parsed again. The results of the parser are then used to indicate correct subdiagrams and to create a valid layout for them (cf. Section 5). Please note that the hypergraph model is directly modified by the transformation rules; the modeling step, which is necessary for free-hand editing, does not take place.</p><p>In the following, two examples of editing operations for a flowchart editor are used for describing specification and realization of syntax-directed editing operations. The first example demonstrates the use of simple hypergraph transformation rules whereas the second one shows why additional information from the reduced hypergraph model as well as the derivation DAG may be necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Example 1: Simple hypergraph transformation rules</head><p>Fig. <ref type="figure" target="#fig_10">9</ref> shows an example of a syntax-directed editing operation which adds a new statement below an existing one in a flowchart editor. The situation just before applying the editing operation is depicted in Fig. <ref type="figure" target="#fig_10">9a</ref>. The topmost statement has been selected which is indicated by a thick border and gray handles; the editing operation whose hypergraph transformation rule is shown in Fig. <ref type="figure" target="#fig_10">9b</ref> adds a new statement just below this selected one. The result is shown in Fig. <ref type="figure" target="#fig_10">9c</ref>.</p><p>The hypergraph transformation rule in Fig. <ref type="figure" target="#fig_10">9b</ref> is depicted as before: LHS and RHS are separated by "⇒", corresponding edges and nodes of LHS and RHS carry the same labels. Host nodes and edges which match the LHS without Fig. <ref type="figure" target="#fig_11">10</ref> shows the concrete specification of this simple editing operation together with its transformation rule. In DiaGen, syntax-directed editing operations are specified in terms of simple rules and complex operations quite similar to rules and transformation units in GRACE <ref type="bibr" target="#b20">[21]</ref> as shown in the following.</p><p>A rule (add rule in Fig. <ref type="figure" target="#fig_11">10</ref>) is specified as its LHS (as a list of edges) and how its RHS "differs" from its LHS, i.e., which edges are removed (indicated by -) and which ones are added (indicated by +) by the rule. Each hyperedge is again written as its edge type together with its visited nodes in parentheses. The node hyperedges are special: they are actually pseudo edges which allow to refer to nodes with the same notation as edges. The LHS in Fig. <ref type="figure" target="#fig_11">10</ref> consists of a box edge, a flowOut edge, some nodes and a node pseudo edge which is used to refer to node a. Applying the rule removes the flowOut edge (indicated by -f where f is the edge reference introduced in the LHS). Furthermore, a vArrow instance etc. are added to the hypergraph model. The Java methods in curly braces are responsible for creating the corresponding diagram components, i.e., a vertical arrow and a statement box.</p><p>Each syntax-directed editing operation is specified by a complex operation defined in terms of rules; a control program describes how the operation is defined by a sequence of rules or more complex control structures. Control programs in DiaGen have been inspired by <ref type="bibr" target="#b20">[21]</ref> and <ref type="bibr" target="#b21">[22]</ref>, but their semantics is much simpler because backtracking is not performed <ref type="bibr" target="#b9">[10]</ref>. Fig. <ref type="figure" target="#fig_11">10</ref> shows the operation add stmt after stmt which uses the trivial control program that simply calls a single rule. The operation of Fig. <ref type="figure" target="#fig_11">10</ref> requires a statement box as parameter b (indicated by specify box b. . . ) and which simply calls add rule rule that has been described above. The parameter b that is passed to this rule simply defines a partial match when applying this rule. The corresponding formal parameters are the first edges which are specified in the LHS of the "invoked" rule.</p><p>An important issue of syntax-directed editing is the question how to select those parts of the diagram that are affected by the application of an editing operation. In DiaGen, this has been solved by adding parameters to complex operations (indicated by specify box b. . . in Fig. <ref type="figure" target="#fig_11">10</ref>). When the user selects an editing operation for application, the editor requests the user to specify a single diagram component for each of the parameters of the operation. The hyperedges that internally represent these components specify a partial match which is then used to select where the operation and its rules have to be applied. DiaGen simplifies this user interaction process: When a diagram component is selected, the editor offers those editing operations to the user which require a diagram component of the selected type as a first parameter. When the user selects one of those operations, the editor asks for the missing parameters. However, many operations, e.g., the add stmt after stmt operation, require just a single parameter, i.e., no further user interaction is necessary after selecting the operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Example 2: Utilizing additional information</head><p>The former example has been rather simple in the sense that its operation can be described with just a single transformation rule. Furthermore, it uses only information which is readily available in the hypergraph model. This subsection outlines that editing operations are in general more complicated and have to use additional information beyond the plain hypergraph model. Fig. <ref type="figure" target="#fig_12">11</ref> shows such an operation in action with screenshots just before and after applying it. <ref type="foot" target="#foot_3">6</ref> Its task is removing a conditional block which the user has chosen by selecting its condition diamond. Unlike the former example, the number of edges which have to be removed is unknown when the operation is being specified. It is, moreover, difficult to decide whether a diagram component and its hyperedge belong to the conditional block when solely considering the hypergraph model. However, since this is a problem of diagram syntax, it is quite an easy task when also using syntactic information from the last parsing step: The operation has to remove all leaves of the Block(d, h)-subtree of the derivation tree in Fig. <ref type="figure" target="#fig_9">8</ref>.</p><p>The crucial task of the editing operation is thus to find the Block(d, h)-node of the derivation tree and -from there -all terminal hyperedges which can be reached by paths from this tree node. Finally, their corresponding component edges as well as diagram components have to be identified. Apparently, editing operations have to take into account information which has been collected during diagram analysis, i.e., information from the reduced hypergraph model and from the derivation structure (cf. Fig. <ref type="figure" target="#fig_1">2</ref>). DiaGen editors make this information available by so-called cross-model links which connect corresponding nodes and edges of hypergraph model, reduced hypergraph model, and derivation DAG. Path expressions allow to specify how to navigate in and between models using these cross-model links. For our sample operation, this is shown in Fig. <ref type="figure" target="#fig_1">12</ref> which, because of lack of space, does neither show these path expressions nor the hypergraph model, but only the diagram, its reduced hypergraph model, and its (simplified) derivation tree (cf. Figures <ref type="figure" target="#fig_12">11a,</ref><ref type="figure" target="#fig_6">6</ref>, and 8). Thick arrows indicate how models are used to find, starting from the selected condition diamond, those terminal statement hyperedges which belong to the conditional block. Dashed edges show how they correspond to the diagram components (resp. their component hyperedges which are omitted here) which have to be removed from the diagram. Please note that not only statement boxes and condition diamonds have to be removed by this operation, but also lines and arrows. In order to also match them by path expressions, these components must have been represented in the reduced hypergraph model as well as in the derivation tree. This was the  Fig. <ref type="figure" target="#fig_1">12</ref>. Using cross-model information for editing operations reason for using the conn and Conn edges which, for clarity, have been omitted in Section 3 and also in the derivation tree of Fig. <ref type="figure" target="#fig_1">12</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Automatic Layout</head><p>As it has become clear in the previous section, transformations on the hypergraph model modify the structure of the internal model, but they do not describe their effects on the position or the size of the diagram components; an automatic layout mechanism which considers the diagram syntax is needed.</p><p>DiaGen offers two kinds of automatic layout support:</p><p>Tailored layout modules can be programmed by hand. Such a layout is connected to diagram analysis by a generic Java interface to attribute evaluation (cf. Fig. <ref type="figure" target="#fig_1">2</ref>). Information about the syntactic structure of the diagram has to be prepared by syntax-directed attribute evaluation first. The layout module then uses this information to compute a diagram layout. Some generic layout modules have been realized already, e.g., a force-directed layout algorithm (cf. <ref type="bibr" target="#b22">[23]</ref>) which is used in a Statechart as well a UML class diagram editor <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>Programming such a layout module by hand is quite complicated. For reducing this effort, DiaGen offers constraint-based specification of diagram layout and computing diagram layout by a constraint solver as in earlier work of ours <ref type="bibr" target="#b23">[24]</ref>:</p><p>The main idea is to describe a diagram layout in terms of values which are assigned to the attributes of the diagram components (e.g., their position). A valid diagram layout is specified by a set of constraints on these attributes; the constraint set is determined by the syntactic structure of the diagram similar to the syntax-directed translation by attribute evaluation: Hyperedges of the hypergraph model and terminal as well as nonterminal hyperedges of the reduced hypergraph model carry additional layout attributes, and reduction step rules as well as grammar productions are augmented by constraints on their accessible attributes. These constraints are added to the set of constraints which specify a diagram layout whenever the corresponding rule or production is instantiated during the reduction step or parsing process.</p><p>It is important to define layout constraints not only in the hypergraph grammar which is used during the parsing step, but also in the rule set which specifies the reduction step (cf. Fig. <ref type="figure" target="#fig_1">2</ref>). This is so because the reduction step may "reduce away" the explicit representation of some specific diagram components (e.g., lines in our flowchart example). If we had restricted specification of layout constraints to the hypergraph grammar, we would not be able to describe the layout of those diagram components. For flowcharts, e.g., constraints have to require a minimum length of lines and arrows.</p><p>Automatic layout is not restricted to syntax-directed editing. The same information is also available during free-hand editing. Editors being specified and generated by DiaGen therefore offer an intelligent diagram mode where diagram components may be modified arbitrarily, but the other components, especially their position, may be affected by these modifications, too. The layouter takes care of modifying the overall appearance of the diagram such that its syntax is preserved and the layout beautified. This work on intelligent diagrams is similar to the approach by Chok, Marriott, and Paton <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>This paper has presented DiaGen, a rapid-prototyping tool based on hypergraph transformation for creating diagram editors that support free-hand editing as well as syntax-directed editing. By supporting both editing modes in one editor, it combines the positive aspects of both modes, i.e., unrestricted editing capabilities and convenient syntax-directed editing. The approach has proven to be powerful and general in the sense that it supports quick prototyping of diagram editors and does not restrict the class of diagram languages which it can be applied to. This has been demonstrated by several diagram languages for which diagram editors have already been generated, e.g., flowcharts, Nassi-Shneiderman diagrams <ref type="bibr" target="#b18">[19]</ref>, syntax diagrams <ref type="bibr" target="#b15">[16]</ref>, a visual λ-calculus <ref type="bibr" target="#b24">[25]</ref>, ladder diagrams <ref type="bibr" target="#b25">[26]</ref>, MSC <ref type="bibr" target="#b16">[17]</ref>, UML class diagrams, signal interpreted Petri nets and SFC diagrams <ref type="bibr" target="#b26">[27]</ref>.</p><p>The approach which has been presented in this paper appears to be quite similar to the approach of Rekers and Schürr <ref type="bibr" target="#b4">[5]</ref> which has already been outlined in Section 1. Both approaches make use of two hypergraphs resp. graphs. The spatial relationship graph (SRG) in Reker's and Schürr's approach is quite similar to the hypergraph model of DiaGen. But their abstract syntax graph (ASG), which represents the abstract meaning of the diagram, has been introduced for a different reason than the reduced hypergraph model of Dia-Gen: hypergraph models (and also SRGs) are generally quite complicated such that there is no hypergraph parser which can analyze an hypergraph model. Therefore, DiaGen reduces the hypergraph model and parses the much simpler reduced hypergraph model instead of the hypergraph model. As we have demonstrated, parsing of the reduced hypergraph model can be performed efficiently <ref type="bibr" target="#b9">[10]</ref>. However in Reker's and Schürr's approach, SRG and ASG are always strongly coupled since they use triple graph grammars for defining the syntax of the SRG and the ASG with one formalism; the ASG has not been introduced for reducing complexity. Instead, a graph grammar parser has to analyze the SRG directly; the ASG (i.e., the abstract meaning of the diagram) is not parsed, it is created as a "side-effect" of the parsing of the SRG during free-hand editing. The requirement for a graph parser for the SRG imposes a strong restriction on this approach.</p><p>The concepts of this paper have been implemented with constraint-based automatic layout based on the constraint solver QOCA by Chok and Marriott <ref type="bibr" target="#b19">[20]</ref>.</p><p>Their Penguins system also allows to generate free-hand editors, however they do not generate an internal model, but use constraint multiset grammars (CMGs) <ref type="bibr" target="#b2">[3]</ref>. The hypergraph grammar approach of DiaGen appears to be better suited to the problem since they report a performance that is about two orders of magnitude worse than the performance of DiaGen editors on comparable computers. Furthermore, their system cannot support syntax-directed editing since they do not use an intermediate internal model.</p><p>As the examples of syntax-directed editing operations suggest, it appears to be unsatisfactory to some extent to specify syntax-directed editing operations on the less abstract hypergraph model instead of the reduced one which appears to be better suited for syntax-directed editing (cf. Reker's and Schürr's approach <ref type="bibr" target="#b4">[5]</ref>). However, since the mapping from the hypergraph model to the reduced one is non-injective, the approach which has been presented in this paper does not leave much choice if expressiveness should not be sacrificed. However, future work will investigate where specifying syntax-directed editing operations on the more abstract hypergraph model is sufficient.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Generating diagram editors with DiaGen.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Architecture of a diagram editor based on DiaGen.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Screenshot of a diagram editor for flowcharts. The layouter modifies attributes of diagram components and thus the diagram layout by using information which has been gathered by the reducer and the parser or by attribute evaluation (cf. Section 5). The layouter is necessary for realizing syntax-directed editing: Syntax-directed editing operations modify the hypergraph model by means of the hypergraph transformer and add or remove components to resp. from the diagram. The visual representation of the diagram and its layout is then computed by the layouter.</figDesc><graphic coords="7,220.44,72.27,137.51,153.41" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4</head><label>4</label><figDesc>Fig. 4 shows the hypergraph model of a subdiagram of the one shown in Fig. 3. Nodes are depicted by black dots. Component edges which represent diagram components are shown as gray rectangles that are connected to visited nodes by thin lines. Line numbers represent the sequence of visited nodes. Relation edges which represent relationships between attachment areas are depicted as arrows between connected nodes. The arrow direction indicates the node sequence. Fig. 4 shows the hypergraph in a similar way as the represented subdiagram. Rectangular boxes and diamond-shaped conditions are represented by box edges resp. cond edges with arity 2 resp. 3. Vertical and horizontal arrows resp. lines are shown as vArrow, hArrow, vLine, and hLine edges, resp.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. A part of the flowchart which is shown in Fig. 3 and its corresponding hypergraph model. Relationship edge types are flowIn, flowOut, and join. The relationship of a vertical arrow which ends at the upper attachment area of a box or a diamond is represented by a flowIn relation between the "end node" of the arrow and the "upper node" of the corresponding vArrow and box edges. A flowOut relationship is used in a similar way for leaving arrows. A join relation connects an arrow end with lines or arrows.</figDesc><graphic coords="9,117.94,122.16,118.26,75.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>3 . 1 Fig. 5 .</head><label>315</label><figDesc>Fig. 5. Some reduction rules for flowcharts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. The reduced hypergraph model of the flowchart of Fig. 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>are context-free ones. Productions L ::= R 1 , L ::= R 2 , . . . with the same LHS are drawn as L ::= R 1 |R 2 | . . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Productions of a grammar for the reduced hypergraph models of flowcharts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>FlowchartFig. 8 .</head><label>8</label><figDesc>Fig. 8. Derivation tree of the reduced hypergraph model of Fig. 6 according to the grammar of Fig. 7 when omitting any conn edge.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. A syntax-directed editing operation which inserts a new statement below a selected one. an identically labeled counterpart in the RHS are removed when applying the rule. The marked box hyperedge of the LHS indicates that this edge has to match the hypergraph model edge of the diagram component which has been selected by the editor user. When applied, this rule removes the flowOut relation edge which connects the selected statement box with an outgoing line or arrow (which is not specified here); a new vertical arrow and a new statement box together with some relation edges are added. After applying the rule, the resulting hypergraph is reduced and parsed (cf. Fig. 2). The layouter can then properly layout the resulting diagram which now contains a new statement box (this box carries the default text "Action" in Fig. 9c.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. DiaGen specification of adding a statement below another statement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. A syntax-directed editing operation which removes a conditional block.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>The gray, crossed out sub-hypergraphs are negative application conditions: A match for the vArrow edge is used for rule application if and only if none of the three crossed out sub-hypergraphs can be matched as well, i.e., the match is valid if there is no additional flowIn, continue, or connect edge which is connected to the start node of the vArrow edge (continue edges are not further considered here). The hypergraph R of each rule shows the hypergraph which is added to the reduced hypergraph model for each valid match of the P -hypergraph. Same node labels indicate corresponding nodes of the hypergraph model and the reduced one. Hypergraph model nodes which lie in different pattern occurrences (not necessarily of different patterns) always correspond to the same node of the reduced model. Three special cases have to be mentioned here:</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>E-mail: minas@informatik.uni-erlangen.dePreprint submitted to Elsevier Science</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For efficiency reasons, only pairs of attachment areas with overlapping bounding boxes are actually considered.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Actually, the only diagram languages that we know about and which can be described by context-free grammars are Nassi-Shneiderman diagrams<ref type="bibr" target="#b14">[15]</ref>, syntax diagrams<ref type="bibr" target="#b15">[16]</ref> and flowcharts as used in this paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>Actually, Fig.11ashows the same diagram as Fig.3, but with a condition selected.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">GenGEd: A generic graphical editor for visual languages based on algebraic graph grammars</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bardohl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VL&apos;98</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="48" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Graph grammars and diagram editing, in: Graph Grammars and Their Application to</title>
		<author>
			<persName><forename type="first">H</forename><surname>Göttler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science</title>
		<imprint>
			<biblScope unit="volume">291</biblScope>
			<biblScope unit="page" from="216" to="231" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automatic construction of user interfaces from constraint multiset grammars</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Chok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1995 IEEE Symp. on Visual Languages</title>
		<meeting>1995 IEEE Symp. on Visual Languages<address><addrLine>Darmstadt, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="242" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">VisPro: A visual language generation toolset</title>
		<author>
			<persName><forename type="first">D.-Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VL&apos;98</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="195" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A graph based framework for the implementation of visual environments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rekers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1996 IEEE Symp. on Visual Languages</title>
		<meeting>1996 IEEE Symp. on Visual Languages<address><addrLine>Boulder, Colorado</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="148" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="http://www2.informatik.uni-erlangen.de/DiaGen" />
		<title level="m">DiaGen web site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Algebraic approaches to graph transformation -part I: Basic concepts and double pushout approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Corradini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Löwe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rossi</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="163" to="246" />
		</imprint>
	</monogr>
	<note>Rozenberg [29</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Algebraic approaches to graph transformation -part II: Single pushout approach and comparison with double pushout approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Corradini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Korff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Löwe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wagner</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="247" to="312" />
		</imprint>
	</monogr>
	<note>Rozenberg [29</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Computing by graph rewriting, Habilitationsschrift</title>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Universität Bremen</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Specifying and generating diagram editors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
		<imprint>
			<pubPlace>Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Habilitationsschrift, Universität Erlangen</orgName>
		</respStmt>
	</monogr>
	<note>In German] (To appear 2001</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Graph based modeling and implementation with EER/GRAL</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dahm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Franzke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Süttenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th International Conference on Conceptual Modeling (ER&apos;96)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Thalheim</surname></persName>
		</editor>
		<meeting>15th International Conference on Conceptual Modeling (ER&apos;96)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1157</biblScope>
			<biblScope unit="page" from="163" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hyperedge Replacement: Grammars and Languages</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">643</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers -Principles, Techniques, and Tools</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Hyperedge replacement graph grammars</title>
		<author>
			<persName><forename type="first">F</forename><surname>Drewes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="95" to="162" />
		</imprint>
	</monogr>
	<note>Rozenberg [29</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Flowchart techniques for structured programming</title>
		<author>
			<persName><forename type="first">I</forename><surname>Nassi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="12" to="26" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
		<title level="m">Pascal User Manual and Report</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
	<note>2nd Edition</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bardohl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applications, Languages and Tools</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="105" to="180" />
		</imprint>
	</monogr>
	<note>Application of graph transformation to visual languages</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Specifying and implementing visual process modeling languages with diagen</title>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Satellite Workshop to ETAPS&apos;2001, on Uniform Approaches to Graphical Process Specification Techniques (UniGra&apos;2001)</title>
		<meeting><address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-04-01">March 31/April 1, 2001. 2001</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Diagram editing with hypergraph parser support</title>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1997 IEEE Symp. on Visual Languages</title>
		<meeting>1997 IEEE Symp. on Visual Languages<address><addrLine>Capri, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="230" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Constraint-based diagram beautification</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Chok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Paton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1999 IEEE Symp. on Visual Languages</title>
		<meeting>1999 IEEE Symp. on Visual Languages<address><addrLine>Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Graph transformation for specification and programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuske</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="1" to="54" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Programmed graph replacement systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="479" to="546" />
		</imprint>
	</monogr>
	<note>Rozenberg [29</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An experimental comparison of forcedirected and randomized graph drawing algorithms</title>
		<author>
			<persName><forename type="first">F</forename><surname>Brandenburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Himsolt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rohrer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing 1995 (GD&apos;95)</title>
		<meeting>Graph Drawing 1995 (GD&apos;95)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1027</biblScope>
			<biblScope unit="page" from="76" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Specification of diagram editors providing layout adjustment with minimal change</title>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Viehstaedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1993 IEEE Symp. on Visual Languages</title>
		<meeting>1993 IEEE Symp. on Visual Languages<address><addrLine>Bergen, Norway</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Automatically generating environments for dynamic diagram languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VL&apos;98</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="70" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Creating semantic representations of diagrams</title>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Workshop on Applications of Graph Transformations with Industrial Relevance (Agtive&apos;99)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Nagl</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1779</biblScope>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">International Standard 61131 A: Programmable Logic Controllers</title>
		<imprint>
			<publisher>Languages</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m">Proc. 1998 IEEE Symp. on Visual Languages</title>
		<meeting>1998 IEEE Symp. on Visual Languages<address><addrLine>Halifax, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<editor>G. Rozenberg</editor>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="volume">I: Foundations</biblScope>
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
