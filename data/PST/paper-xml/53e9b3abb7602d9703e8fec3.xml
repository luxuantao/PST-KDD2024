<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Machine Learning for Android Malware Detection Using Permission and API Calls</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Naser</forename><surname>Peiravian</surname></persName>
							<email>npeiravi@fau.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer &amp; Electrical Eng. and Computer Science</orgName>
								<orgName type="institution">Florida Atlantic University</orgName>
								<address>
									<postCode>33431</postCode>
									<settlement>Boca Raton</settlement>
									<region>FL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xingquan</forename><surname>Zhu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer &amp; Electrical Eng. and Computer Science</orgName>
								<orgName type="institution">Florida Atlantic University</orgName>
								<address>
									<postCode>33431</postCode>
									<settlement>Boca Raton</settlement>
									<region>FL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Machine Learning for Android Malware Detection Using Permission and API Calls</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9083962F7B9E437F1C772273304F5941</idno>
					<idno type="DOI">10.1109/ICTAI.2013.53</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Malware detection</term>
					<term>Android</term>
					<term>Permissions</term>
					<term>API calls</term>
					<term>Smartphone Security</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The Google Android mobile phone platform is one of the most anticipated smartphone operating systems on the market. The open source Android platform allows developers to take full advantage of the mobile operation system, but also raises significant issues related to malicious applications (Apps) 1 . On one hand, the popularity of Android absorbs attention of most developers for producing their applications on this platform. The increased numbers of applications, on the other hand, prepares a suitable prone for some users to develop different kinds of malware and insert them in Google Android market or other third party markets as safe applications. In this paper, we propose to combine permission and API (Application Program Interface) calls and use machine learning methods to detect malicious Android Apps. In our design, the permission is extracted from each App's profile information and the APIs are extracted from the packed App file by using packages and classes to represent API calls. By using permissions and API calls as features to characterize each Apps, we can learn a classifier to identify whether an App is potentially malicious or not. An inherent advantage of our method is that it does not need to involve any dynamical tracing of the system calls but only uses simple static analysis to find system functions involved in each App. In addition, because permission settings and APIs are always available for each App, our method can be generalized to all mobile applications. Experiments on real-world Apps with more than 1200 malware and 1200 benign samples validate the algorithm performance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Malware, short for malicious software, is a general term used to refer to a variety of forms of hostile or intrusive software such as viruses, worms, spyware, Trojan horses, rootkits, and backdoors <ref type="bibr" target="#b1">[2]</ref>. A common feature of Malware is that they are specifically designed to damage, disrupt, steal, or in general inflict some other bad or illegitimate actions. Malware can literally infect any computing machines running user programs (or applications), and the propagation and prevention of the malware have been well studied for personal computers <ref type="bibr" target="#b4">[5]</ref>. But for smartphone devices, our solutions for finding malware in the mobile platform are far behind the pace of the increasing popularity of the mobile applications.</p><p>A recent report has shown that there are about 700,000 Android Apps currently available on the market <ref type="bibr" target="#b20">[21]</ref>. This popularity of the Android system has led to a huge increase in the spreading of Android malware. These malware are mainly distributed in markets operated by third parties, but even the Google Android Market cannot guarantee that all of its listed applications are threat free. The threats for Android include Phishing, Banking-Trojans, Spyware, Bots, Root Exploits, SMS Fraud, Premium Dialers and Fake Installers. There have also been reports about Download-Trojans Apps that download their malicious code after installation which means that these Apps cannot be easily detected by Google's technology during publication in the Google Android Market.</p><p>In summary, malware applications commonly use following three types of penetration techniques for installation, activation, and running on the Android system:</p><p>Repackaging is one of the most common techniques for malware developers to install malicious applications on an Android platform. These types of approaches normally start from popular legitimate Apps and misuse them as malware. The developers normally download popular Apps, disassemble them, add their own malicious codes, and then re-assemble and upload the new App to official or alternative markets.</p><p>Updating technique is more difficult for detection. Malware developer may still use repackaging but instead of enclosing the inflict code to the App, they include an update component that will download malicious code at runtime. Downloading is the traditional attack technique, malware developer need enticing users to download interesting and attractive Apps.</p><p>Characterization of existing Android malware and their different penetration technique reveal serious technical challenges we are facing. Unfortunately the recent research shows that existing popular mobile security software is still lag behind. Most malware detection methods are based on traditional content signatures, such as a list of malware signature definitions, and compare each application against the database of known malware signatures. The disadvantage of this detection method is that users are only protected from malware that are detected by most recently updated signatures, but not protected from new malware (i.e. zero-day attack). A previous study of the malicious patterns has concluded that "Signature-based approaches never keep up with the speed at which malware is created and evolved" <ref type="bibr" target="#b16">[17]</ref>. With attention to the rapid growth of malicious Apps and the disappointing results of current security software <ref type="bibr" target="#b2">[3]</ref>, there is a pressing need to develop effective solutions to detect malware on the smartphone platform.</p><p>Instead of using static signatures, an effective alternative solution is to use characteristic and behavioral-based methods which try to detect malware by observing the statistic and/or dynamic behavior and features of mobile applications. One of the most popular behavioral methods is malware detection based on static requested permissions, which check what types of resources, such as Wi-Fi network, user location, and user contact information, an App is requesting for installation (Android provides over 130 permissions for developers to control the resources that an App can request <ref type="bibr" target="#b15">[16]</ref>). Although pure permission based method is simple and have moderate good results but its performance is not reliable. This is mainly because developers can freely request any permission they want, so they can mock the requested permissions of benign applications. On the other hand, observing dynamic behavior of Apps, such as dynamic API calls, is more accurate than permission based methods in capturing runtime activities of the App. But analyzing Apps' runtime dynamic behaviors is not simple and requires sophisticated skills and platforms which cause cost overhead and time consuming process.</p><p>Motivated by the above observations, we propose a framework for analyzing and classifying Android applications based on machine learning techniques. The framework rests on a combination of requested permission and static API call behaviors, and extracts features from these behaviors and builds classifiers to detect malicious applications. We obtain 96.39% accuracy which exposes a reliable method to protect against malicious destructive activities.</p><p>The remainder of the paper is structured as follows. Related works are described in Section 2. Section 3 briefly describes Android application structure and its security approach. Our methodology is introduced in Section 4. Experiments and comparisons are reported in Section 5, and we conclude the paper in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>Signature based methods <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12]</ref>, introduced in mid 90s, are commonly used in malware detection. The major weakness of this type of approaches is its weakness in detecting metamorphic and unseen malware.</p><p>Instead of using predefined signatures for malware detection, data mining and machine learning techniques provide an effective way to dynamically extract malware patterns <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18]</ref>. One existing work <ref type="bibr" target="#b4">[5]</ref> has used data mining and features generated from windows executable API calls. They achieved good results in a very large scale dataset with about 35,000 portable executable files. Another behavioral footprinting method <ref type="bibr" target="#b21">[22]</ref> also provides a dynamic approach to detect self-propagating malware.</p><p>For smartphone based mobile computing platform, recent years have witnessed an increasing number of more complicated malware attacks such as repackaging. A recent research by Zhou et al. <ref type="bibr" target="#b2">[3]</ref> systematically characterizes existing Android malware from various aspects, including their installation methods, activation mechanism as well as the nature of carried malicious payloads. Based on the evaluation with four representative mobile security software over more than 1200 collected malware, their experiments show the weakness of current malware detection solutions and call for the need to develop next generation anti-mobile-malware solutions.</p><p>Motivated by the increasing number of Apps and the lack of effective malware detection tools, some research <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b19">20]</ref> try to detect malware by observing the statistic and/or dynamic behavior and characters of applications. Zhou et al. <ref type="bibr" target="#b0">[1]</ref> first proposes to use permission behavior to detect new Android malware and then applies heuristic filtering for detecting unknown Android malware. This hybrid method, called DroidRanger, resolves the disadvantage of lacking ability to detect unknown malware. All these existing methods have essentially advanced the Android malware detection, but the misuse detection is not adaptive to the novel Android malware and always requires frequent updating of the signatures.</p><p>In comparisons, our work is motivated by some of the above techniques and approaches, but with focus on developing simple and effective malware detection approaches, without relying on complex dynamic runtime analysis and any static predefined malware signatures. We combine permissions and API calls as features to characterize malware, and use machine learning techniques to automatically extract patterns to differentiate benign and malicious Apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. ANDROID APPLICATION STRUCTURE</head><p>In this section, we briefly describe Android application structure with focus on the important files. This description will serve as preliminary knowledge for understanding Apps in Android based mobile platform, through which our algorithm can extract useful patterns for malware detection. We briefly describe the structure as follows:</p><p>APK: Android Application Package file. Each Android application is compiled and packaged in a single file that includes all of the application code (.dex files), resources, assets, and manifest file. The application package file can have any name but must use the .apk extension.</p><p>Android Manifest file: AndroidManifest.xml is one of the most important files in the Android project structure. It contains all necessary information about the App. Once an application is launched, the first file the Android system seeks is the Manifest file. It actually works as a roadmap to ensure that each application can function properly in the Android system.</p><p>It is worth noting that Android system will not allow an App to access resources, permissions, and features not specified in the AndroidManiefest file. So AndroidManifest.xml provides firsthand information to understand the characteristics and security settings of the Apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Android Security Approach</head><p>Android security model highly relies on permission-based mechanism. There are about 130 permissions that govern access to different resources. An Android application requires several permissions to work. Consequently, an essential step to install an Android application into a mobile device is to allow all permissions requested by the application. Before an application is being installed, the system prompts a list of permissions requested by the application and asks the user to confirm the settings for installation (An example is shown in Figure <ref type="figure">1</ref>). Although permission requests are useful for users to prevent possible misusage of resources by Apps, users often have rare knowledge to determine if permissions might be harmful or not. For examples, requesting network access, including Wifi and short message service (SMS), are pretty normal for generic Apps, whereas some malware misuse the services to steal bandwidth or other useful information. So it's very difficult for users to determine, at the first place, whether an App is a malware by using the permission request only. Fig. <ref type="figure">1</ref>. An example of android premission requested screenshot. Users are required to confirm the settings before an application can be installed.</p><p>At the system level, Google announced that a security checking mechanism is applied to each application uploaded to their market. The open design of the Android operating system allows a user to install any applications downloaded from an untrusted source. Nevertheless, the permission list is still the minimal defense for a user to detect whether an application could be harmful. That way, users can choose to not install an App if they see the App unnecessarily requests permission to user's personal contact (e.g. phone book).</p><p>Google also categorizes Android permissions into four threat level:</p><p>Normal permission: include lower-risk permissions which control access to API calls that are not particularly harmful. The system automatically grants this type of permission to a requesting application at installation, without asking for the user's explicit approval like SET ALARM.</p><p>Dangerous permission: regulate access to the potential harmful API calls that would give access to private user data. For example, permissions to read the location of a user ACCESS FINE LOCATION or WRITE CONTACTS are classified as dangerous.</p><p>Signature permission: protect access to the most dangerous privilege. The system grants the permission only if the requesting application is signed with the same certificate as the application that declared the permission.</p><p>Signature/System permission: A permission that the system grants only to applications that are in the Android system.</p><p>A straightforward idea to determine a harmful App is to check whether the App requests for permissions in the dangerous or higher level. Although Android adopts an authorized permission model to control access to its components, there is no clear evidence demonstrating how good or bad it is to detect a malicious App based on permissions or combinations of permissions. It should be noticed that the permissions shown to a user during an installation process are requested permissions instead of required permissions. The requested permissions are declared by an App developer manually. However, not all declared permissions are required by the App.</p><p>In addition to Google's methods to protect Android from malicious application, many security software companies have launched their own security Apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Android Permission Settings</head><p>Every Android application package (APK) has an Android-Manifest.xml file in its root directory. The manifest.xml file includes essential information about the application to the Android system and application user. Android system must have and process this information before it can run any of the application's code. Among other things, the manifest file does the following which are closely relevant for the behaviors and security settings of the App.</p><p>Manifest file declares which permissions the application must have in order to access protected parts of the API and interact with other applications. It also declares the permissions that others are required to have in order to interact with the application's components. These permissions are raw data for any experiments, so one needs to have AndroidMainfest.xml file and use Apktool <ref type="bibr" target="#b12">[13]</ref>, which is a tool for reverse engineering on APK files, and generate the AndroidMainfest.xml from an APK file. Once having the AndroidMainfest.xml, it is possible to parse the file and extract requested permissions from it for each APK.</p><p>To demonstrate that permission settings are indeed relevant to the behaviors of benign and malware, we compare top permissions requested by these malicious Apps in the dataset with top permissions requested by benign Apps. The results are shown in Figure <ref type="figure" target="#fig_0">2</ref>. ACCESS NETWORK STATE, and WRITE EXTERNAL STORAGE permissions are frequently requested in both malicious and benign Apps. The first two are typically needed to allow for the embedded and libraries to function properly. But malicious apps clearly tend to request more frequently on the SMS-related permissions, such as READ SMS, SEND SMS, RECEIVE SMS, and WRITE SMS. Specifically, there are 553 (52.22%) samples in our dataset that request the READ SMS permission, while less than 41 (3.28%) benign apps request this permission. Also, we notice that malicious Apps tend to request more permissions than benign Apps. In our dataset, the average number of permissions requested by malicious Apps is 13.7 while the average number requested by benign Apps is 9.1. These results are consistent with the fact that the pattern of using permission in the malware applications is noticeably different from benign applications.</p><p>Given a set of permissions obtained for each App, a simple way to characterize the App is to use each permission as a feature. As a result, every App can be represented as a binary vector, namely P , where P i =1 if and only if the Mainfest.xml file has the i th permission and P i =0 if corresponding Mainfest.xml does not indicate the permission. As will be shown in experiments section, these features can be used to differentiate benign and malware with moderate detection accuracy. In this paper, we intend to advance the detection accuracy by combining permissions and Android APIs calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Android API Calls</head><p>The Android platform provides a framework API that Apps can use to interact with the underlying Android system. The framework API consists of a core set of packages and classes.</p><p>Because most Apps use a large number of APIs, it motivates us to use API calls of each application as feature to characterize and differentiate malware from benign Apps. To achieve the goal, one can create a framework to reverse engineer APK file and extract API calls of each application. After that, one can follow the same technique as the above permission based representation. Each application is represented as a binary vector of API calls, namely A, where A i = 1 if and only if the i th API is used in the application and A i = 0 if corresponding application does not use the API.</p><p>To demonstrate that API calls are indeed helpful for differentiating benign and malware applications, we report the top 20 API calls used in malicious and benign applications in Figure <ref type="figure" target="#fig_2">3</ref>. The results clearly show that benign applications use more API calls than malware applications, where the average number of API calls used by malicious Apps is 454.5 while the average number used by benign Apps is 1595.9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. METHODOLOGY</head><p>In this section, we propose a feature-based learning framework for Android malware detection. The framework considers the application features, including permissions and API calls, to characterize Android applications behaviors.</p><p>The proposed framework, as shown in Figure <ref type="figure" target="#fig_3">4</ref>  extraction, which includes permission features extracted from AndroidManifest and API call features extracted from class files. As a result of this this process, each App is represented as a single instance with binary permission and API call features, and a class label indicates whether the App is a benign or a malware (Detailed information about benchmark data is reported in Section V). The last part includes the training of the classification models from the collected data. Because the framework has converted Apps into generic instancefeature format, one can simply use any learning algorithm to derive classification models from the training data. In our experiments, we examine several classification methods, including Support Vector Machines (SVM) <ref type="bibr" target="#b18">[19]</ref>, Decision tree <ref type="bibr" target="#b5">[6]</ref> and Bagging <ref type="bibr" target="#b9">[10]</ref>, and report their detailed performance in the next section. The proposed permission and API call feature-based malware detection framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTS</head><p>In this section, we report the algorithm performance with respect to the feature sets extracted from the permissions and API classes. Our objective is to demonstrate that combining permissions and API calls can indeed achieve improved accuracy gain. For this purpose, we build three benchmark datasets, each has the same number of instances (i.e. Apps), but different number of features. In other words, the datasets only differ in their feature sets, and have exactly the same number of instances: 'Permission" dataset is created by using the requested permissions, as defined in section 3.B, as features. The total number of features is 130, which is equal to the standard permissions used in Android system <ref type="bibr" target="#b15">[16]</ref>.</p><p>"API call" dataset is created by using the API call names as the features. The total number of API we used is 1326, which is equal to the standard Android APIs at level 17 <ref type="bibr" target="#b15">[16]</ref>.</p><p>"Com+" dataset is created by concatenating the permission and API call features for each App. So each instance contains 1456 features.</p><p>In our experiments, malicious Apps are labeled as positive and benign Apps are considered as negative samples. The detailed information about malware and benign App collection is described in the next subsection. All experiments are carried out on a 2.4GHz Intel Core 2 Duo PC with 2GB physical memory, using WEKA <ref type="bibr" target="#b3">[4]</ref> and MS Windows 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Data Collection</head><p>To collect benchmark data, we have gathered 2510 APK files where 1260 are malicious Apps which have been validated in a previous study <ref type="bibr" target="#b2">[3]</ref> and the remaining 1250 are benign Android APK files. After the feature extraction, we found that many malware have identical feature values (this often happens for malware belonging to the same family, such as different version of one malware application). So we eliminate malware with exactly the same vector features and only keep one copy in the dataset. As a result of this process, we end up with 610 malware samples in 49 different malware families (as shown in Table <ref type="table">1</ref>), indicating a very complete coverage of existing Android malware.</p><p>For each malware family we also report in the table the number of samples and the sources which discovered the malware, i.e., from either the official or alternative Android market. Malicious APKs include all varieties of the threats for Android include Phishing and Banking-Trojans, Spyware, Bots, Root Exploits, SMS Fraud, Premium Dialers, Fake Installers, etc. gathered from various sources, including Android Malware Genome Project<ref type="foot" target="#foot_1">2</ref>  <ref type="bibr" target="#b2">[3]</ref>.</p><p>The benign applications are downloaded from Google Android market from various categories. Currently there are 25 different categories on Google play and we chose almost 50 top free applications in each category.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Evaluation Measurements</head><p>As described in the above subsection, our benchmark data is imbalanced in the sense that the number of malicious applications (610) is much less than the number of benign applications (1250). So traditional accuracy measure is not very suitable for evaluating the algorithm performance. Following the pervious studies in validating the algorithms for imbalanced data <ref type="bibr" target="#b14">[15]</ref>, we chose precision and detection rate (Recall), in addition to AUC and accuracy, to evaluate our experiments.</p><p>Recall is defined as the portion of the total malicious applications that are classified as malware. Precision refers  to the probability that an App is classified as a malicious App correctly. Though precision and detection rate are usually contrary to each other, our results show that the proposed method achieves good detection rate while holding precision up to 94.9% (as shown in Table <ref type="table">2</ref>).</p><p>All results are based on 10-fold cross validation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Classification Methods</head><p>We analyze the algorithm performance by using different classifiers, including support vector machines, decision tress, and bagging predictor. The objective is to determine whether combining permission and API calls can provide additional knowledge in characterizing the behaviors of Apps. In addition, we also expect to determine the best classification method mostly suitable for malware detection.</p><p>SVM algorithms divides the n-dimensional space representation of the data into two regions by using a hyperplane, which intends to maximize the margin between the two regions separating two classes of samples. The margin is defined by the distance between the examples of the two classes and is computed based on the distance between the closest instances of both classes, which are called support vectors <ref type="bibr" target="#b18">[19]</ref>.</p><p>Decision Tree classifiers are a type of machine-learning methods using a tree structure for making predictions. The internal nodes of the tree represent conditions regarding the variables of a problem, whereas final nodes or leaves of the tree represent the ultimate decision of the algorithm <ref type="bibr" target="#b5">[6]</ref>. In our experiments, we use J48, a WEKA <ref type="bibr" target="#b3">[4]</ref> implementation of the C4.5 algorithm <ref type="bibr" target="#b6">[7]</ref>, as the decision tree algorithm.</p><p>Bagging <ref type="bibr" target="#b9">[10]</ref> is a "bootstrap" <ref type="bibr" target="#b10">[11]</ref> based ensemble method that creates a number of base classifiers for its ensemble by training each base classifier using random redistribution of the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Experimental Results</head><p>Due to the imbalanced class distribution nature of our data, we expect that Bagging classifier may outperform other classifiers because of its characteristics including ensembling to overcome the data imbalance problems. We do not include classifiers or methods particularly designed for imbalanced data, because our objective is not to tackle the data imbalance issue but to validate whether combining permission and API calls can improve the malware detection accuracy.</p><p>In Table <ref type="table">2</ref>, we report the classification results related to different classifiers on all three benchmark datasets (Permission, API, and Com+). The results show that the decision tree method (J48) has the lowest detection rate and the highest detection rate in each case belongs to the Bagging predictor. Bagging has good performance on data with skewed class distributions. Also it is shown that Bagging has the best performance in classifying all created data sets with respect to AUC, as shown in Figure <ref type="figure" target="#fig_4">5</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION</head><p>In this paper, we proposed to use permissions and API calls of Android applications to detect malware and malicious codes in Android based mobile platform. The proposed framework extracts permissions from Android applications and further combines the API calls to characterize each application as a high dimension feature vector. By applying learning methods to the collected datasets, we can derive classification models to classify Apps as benign or malware. Experiments on realworld data demonstrate the good performance of the framework for malware detection. The contribution of the proposed framework, compared to the existing solutions, is threefold:</p><p>(1) we validate that combining permissions and API calls is effective for malware detection; (2) our framework does not involve any dynamical tracing of the Android applications; and (3) our framework can be generalized to all mobile applications for malware detection.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Comparison of top most requested permission by malware and benign application, where x-axis lists the name of the permissions and the y-axis lists the number of Apps. The results show that, on average, malware Apps intend to request more permissions than benign Apps. Based on the comparison, INTERNET, READ PHONE STATE, ACCESS NETWORK STATE, and WRITE EXTERNAL STORAGE permissions are frequently requested in both malicious and benign Apps. The first two are typically needed to allow for the embedded and libraries to function properly. But malicious apps clearly tend to request more frequently on the SMS-related permissions,</figDesc><graphic coords="3,346.14,463.94,171.91,101.71" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>, consists of four major parts. The first component is an App analyzer that decompresses the APK file of an App and extracts AndroidManifest.xml and class files, which are necessary for characterizing Apps. The second component aims to characterize each App based on its requested permissions and API calls. The third component, feature generator, carries out feature</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Comparison of top most frequently used API calls in malware and benign applications. x-axis lists the name of the API calls and the y-axis lists the number of Apps. The results show clear patterns/differences of API call usages: benign Apps tend to use more API classes than malware Apps.</figDesc><graphic coords="4,345.93,73.00,172.25,107.69" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4.The proposed permission and API call feature-based malware detection framework.</figDesc><graphic coords="4,339.16,427.04,185.79,106.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Android malicious application detection rate based on AUC. The results show that combining permission and API calls as features (Com+) results in noticeable performance gain. The results also show that bagging has the best performance for malware detection.</figDesc><graphic coords="6,95.83,500.11,165.48,69.77" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I OVERVIEW</head><label>I</label><figDesc>OF 49 DIFFERENT MALWARE FAMILIES AND THEIR NUMBER OF MEMBERS</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>API:API CALLS; COM+:PERMISSION+API CALLS} training set. Each base classifier's training set is generated by randomly drawing training samples, with replacement, from the original training set. The final prediction of an instance is based on the majority vote of all base classifiers' predictions.</figDesc><table><row><cell>Dataset</cell><cell>classifier</cell><cell>Accuracy</cell><cell>Precision</cell><cell>Recall</cell><cell>AUC</cell></row><row><cell>Perm</cell><cell>SVM</cell><cell>93.54</cell><cell>92.4</cell><cell>87.5</cell><cell>0.92</cell></row><row><cell>API</cell><cell>SVM</cell><cell>95.75</cell><cell>91.7</cell><cell>95.7</cell><cell>0.957</cell></row><row><cell>Com+</cell><cell>SVM</cell><cell>96.88</cell><cell>95.7</cell><cell>94.8</cell><cell>0.963</cell></row><row><cell>Perm</cell><cell>J48</cell><cell>92.36</cell><cell>89.8</cell><cell>86.6</cell><cell>0.917</cell></row><row><cell>API</cell><cell>J48</cell><cell>93.33</cell><cell>89.4</cell><cell>90.3</cell><cell>0.918</cell></row><row><cell>Com+</cell><cell>J48</cell><cell>94.46</cell><cell>90.6</cell><cell>92.8</cell><cell>0.936</cell></row><row><cell>Perm</cell><cell>Bagging</cell><cell>93.60</cell><cell>92.0</cell><cell>88.2</cell><cell>0.956</cell></row><row><cell>API</cell><cell>Bagging</cell><cell>94.89</cell><cell>93.6</cell><cell>90.7</cell><cell>0.986</cell></row><row><cell>Com+</cell><cell>Bagging</cell><cell>96.39</cell><cell>94.9</cell><cell>94.1</cell><cell>0.991</cell></row><row><cell></cell><cell></cell><cell cols="2">TABLE II</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">BENIGN VS. MALICIOUS DETECTION</cell><cell></cell><cell></cell></row><row><cell cols="2">{PERM:PERMISSION;</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In this paper, applications, user programs, and Apps are equivalent terms</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.malgenomeproject.org/</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Hey, you, get off of my market: Detecting malicious apps in official and alternative Android markets</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Annual Network &amp; Distributed System Security Symposium</title>
		<meeting>the 19th Annual Network &amp; Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2012-02">Feb. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://en.wikipedia.org/wiki/Malware#citenote-2" />
		<title level="m">Malware Definition by Wikipedia the free Encyclopedia</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dissecting android malware: Characterization and evolution Security and Privacy (SP)</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Weka: The Waikato environment for knowledge analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Garner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 New Zealand Computer Science Research</title>
		<meeting>the 1995 New Zealand Computer Science Research</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Sami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yadegar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Peiravian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hamze</surname></persName>
		</author>
		<title level="m">Malware Detection Based On Mining API Calls The 25th ACM Symposium on Applied Computing-Data Mining Track</title>
		<imprint>
			<date type="published" when="2010-03">March 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Induction of decision trees</title>
		<author>
			<persName><forename type="first">J</forename><surname>Quinlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine learning</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">81106</biblScope>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">C4.5 programs for machine learning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Quinlan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Morgan Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A behavioral malware detection framework for android devices</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shabtai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Kanonov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Elovici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Glezer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Intell. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">161190</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Crowdroid: Behavior-Based Malware Detection System for Android</title>
		<author>
			<persName><forename type="first">I</forename><surname>Burguera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Zurutuza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nadjm-Tehrani</surname></persName>
		</author>
		<idno>SPSM 11</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM workshop on Security and privacy in smartphones and mobile devices Pages</title>
		<meeting>the 1st ACM workshop on Security and privacy in smartphones and mobile devices Pages</meeting>
		<imprint>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">Bagging</forename><surname>Breiman</surname></persName>
		</author>
		<author>
			<persName><surname>Predictors</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">An Introduction to the Bootstrap</title>
		<author>
			<persName><forename type="first">B</forename><surname>Efron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tibshirani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Chapman and Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Automatic extraction of computer virus signatures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kephart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Arnold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th Virus Bulletin International Conference</title>
		<meeting>4th Virus Bulletin International Conference</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="178" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><surname>Android-Apktool</surname></persName>
		</author>
		<ptr target="https://code.google.com/p/android-apktool/" />
		<title level="m">A tool for reverse engineering Android apk files</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Data mining methods for detection of new malicious executables</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schultz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Eskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Zadok</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy Proceedings IEEE Symposium</title>
		<imprint>
			<date type="published" when="2001-05">May 2001</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page">49</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A study of the behavior of several methods for balancing machine learning training data</title>
		<author>
			<persName><forename type="first">G</forename><surname>Batista</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Prati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGKDD Explorations Newsletter</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Android developer page for Android Manifest Permission group</title>
		<ptr target="http://developer.android.com/reference/packages.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Static analysis of executables to detect malicious patterns</title>
		<author>
			<persName><forename type="first">M</forename><surname>Christodorescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Virus detection using data mining techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Data Mining</title>
		<meeting>IEEE International Conference on Data Mining</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The nature of statistical learning theory</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vapnik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">RobotDroid: A lightweight Malware Detection Framework on Smartphones</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName><surname>Yuan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Netwroks</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2012-04">April 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<ptr target="http://news.cnet.com/8301-10353-57521252-94/can-apples-app-store-maintain-its-lead-over-google-play/" />
		<title level="m">CNet report, Google Android application number</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">vEye: behavioral footprinting for self-propagating worm detection and profiling</title>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge and Information Systems</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="231" to="262" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
