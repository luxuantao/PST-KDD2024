<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Model-Checking LTL with Regular Valuations for Pushdown Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2001-08-20">August 20, 2001</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stefan</forename><surname>Schwoon</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Antonin</forename><surname>Kucera</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Antonín</forename><surname>Ku³</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Informatics Research Report EDI-INF-RR-0044 DIVISION of INFORMATICS Laboratory for Foundations of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Division of Informatics</orgName>
								<orgName type="institution">The University of Edinburgh</orgName>
								<address>
									<addrLine>80 South Bridge</addrLine>
									<postCode>EH1 1HN</postCode>
									<settlement>Edinburgh</settlement>
									<country key="GB">Scotland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Division of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
								<address>
									<postCode>EH9 3JZ</postCode>
									<settlement>Edinburgh</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Faculty of Informatics MU Botanická</orgName>
								<address>
									<postCode>68a 60200</postCode>
									<settlement>Brno</settlement>
									<country key="CZ">Czech Republic</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Institute for Informatics TUM Arcisstr</orgName>
								<address>
									<postCode>21 80290</postCode>
									<settlement>Munich</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="department">Division of Informatics</orgName>
								<orgName type="institution" key="instit1">LFCS</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Model-Checking LTL with Regular Valuations for Pushdown Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2001-08-20">August 20, 2001</date>
						</imprint>
					</monogr>
					<idno type="MD5">EA816466B5D63F83AAFBF997FEC9E5DA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Model-checking</term>
					<term>pushdown systems</term>
					<term>LTL</term>
					<term>CTL*</term>
					<term>data-flow analysis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Recent works have proposed pushdown systems as a tool for analyzing programs with (recursive) procedures. In particular, the model-checking problem for LTL has been studied. In this paper we examine an extension of this, namely model-checking with regular valuations. The problem is solved via two different techniques, with an eye on efficiency -both techniques can be shown to be essentially optimal. Our methods are applicable to problems in different areas, e.g., data-flow analysis, analysis of systems with checkpoints, etc., and provide a general, unifying and efficient framework for solving these problems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Pushdown systems can be seen as a natural abstraction of programs written in procedural, sequential languages such as C. They generate in£nite-state transition systems whose states are pairs consisting of a control location (which stores global information about the program) and stack content (which keeps the track of activation records, i.e., previously called procedures and their local variables).</p><p>Previous research has established applications of pushdown systems for the analysis of Boolean Programs <ref type="bibr">[1,</ref><ref type="bibr">8]</ref> and certain data-¤ow analysis problems <ref type="bibr" target="#b13">[7]</ref>. The model-checking problem has been considered for various logics, and quite ef£cient algorithms have emerged for linear time logics <ref type="bibr" target="#b8">[2,</ref><ref type="bibr">6,</ref><ref type="bibr" target="#b15">9]</ref>.</p><p>In this paper we revisit the model-checking problem for LTL and pushdown systems. Generally speaking, the problem is undecidable for arbitrary valuations, i.e., the functions that map the atomic propositions of a formula to the respective sets of pushdown con£gurations that satisfy them. However, it remains decidable for some restricted classes of valuations. In <ref type="bibr" target="#b8">[2,</ref><ref type="bibr">6,</ref><ref type="bibr" target="#b15">9]</ref> valuations were completely determined by the control location and/or the topmost stack symbol (we call these valuations 'simple' in the following). Here we propose (and solve) the problem for valuations depending on regular predicates over the complete stack content. We argue that this solution provides a general, ef£cient, and unifying framework for problems from different areas (e.g., data-¤ow analysis, analysis of systems with checkpoints, etc.)</p><p>We proceed as follows: Section 2 contains basic de£nitions. Most technical content is in Section 3 where we formally de£ne simple and regular valuations and propose our solutions to the model-checking problem with regular 6</p><p>This work was partially supported by the project "Advanced Validation Techniques for Telecommunication Protocols" of the Information Societies Technology Programme of the European Union. valuations, based on a reduction to the case of simple valuations. We can thus re-use most of the theory from <ref type="bibr">[6]</ref>.</p><p>While the reduction itself is based on a standard method, we pay special attention to ensure its ef£ciency, modifying the algorithm of <ref type="bibr">[6]</ref> to take advantage of speci£c properties of our constructions. We propose two different techniques -one for regular valuations in general and another for a restricted subclass -both of which increase the complexity by only a linear factor (in the size of an automaton for the atomic regular predicates). By contrast, a blunt reduction and analysis would yield up to a quadric ('9 §@ ') blowup. Even though one technique is more powerful than the other at the same asymptotic complexity, we present them both since it is not clear how they might perform in practice.</p><p>In Section 4 we consider applicability of our abstract results. The £rst area (Section 4.1) are problems of interprocedural data-¤ow analysis. Here, regular valuations can be used to 'gather' pieces of information which dynamically depend on the history of procedure calls. LTL can express quite complex relationships among those dynamic properties and allows to solve relatively complicated problems using our model-checking algorithm. To give a concrete example, we indicate how to decide whether a given variable A is dead at a given point of a recursive program with dynamic scoping. Another application (Section 4.2) is connected to systems with checkpoints. First, we introduce a formal model for such systems, called pushdown systems with checkpoints. The idea is that the computation is interrupted at certain points and some property of the stack content is checked. Further computational steps depend on the result of this inspection. This part of our work is motivated by the advent of programming languages which can enforce security requirements. Newer versions of Java, for instance, enable programs to perform local security checks in which the methods on the stack are checked for correct permissions. Jensen et al <ref type="bibr">[10]</ref> £rst proposed a formal framework for such systems. With their techniques one can prove the validity of control ¤ow based global security properties as well as to detect (and remove) redundant checkpoints. Our methods are more general, however; for instance, we are not restricted to safety properties, and our model can represent data-¤ow as well. Properties of pushdown systems with checkpoints can be expressed in LTL for which we provide an ef£cient model-checking algorithm. In Section 4.3 we present and analyze a model-checking algorithm for CTLB . In the context of £nite-state systems it is well-known that model-checking the more powerful logic CTLB can be reduced to checking LTL <ref type="bibr" target="#b11">[5]</ref>. This technique can be transferred to pushdown systems using model-checking with regular valuations.</p><p>The complexity of all of the previously developed algorithms is measured in certain parameters of the problem which are usually small, and our complexity bounds are polynomials in those parameters. In general, those parameters can be exponential in the size of a problem instance. Therefore, it is natural to ask whether it is possible to solve some of the studied problems more ef£ciently by other (possibly quite different) techniques. This question is answered (negatively) in Section 5 where we establish EXPTIME lower bounds for those problems (even for rather restricted forms of them). Hence, all of our algorithms are essentially optimal. Complexity measures are discussed in more detail in Remark 3.1 and in Section 5. We draw our conclusions in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Transition Systems</head><p>A transition system is a triple C ED GF IH ©P Q RP TS VU where H is a set of states, Q XW YH abH is a transition relation, and S dc eH is a distinguished state called root.</p><p>As usual, we write f gQ ih instead of F If pP Th U (c RQ . The re¤exive and transitive closure of Q is denoted by Q qB . We say that a state h is reachable from a state f if f rQ sB th . A state h is reachable if it is reachable from the root.</p><p>A run of C is an in£nite sequence of states u vD wf px yf f such that f Q f £ for each Y . Observe that an arbitrary suf£x of a run is again a run -for every c a x we de£ne the d fe suf£x of u , denoted u dF g U , to be the run f f ( f h ©</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Logic LTL</head><p>Let i j (D Yk l rP m P n oP gp be a (countable) set of atomic propositions. LTL formulae are built according to the following abstract syntax equation (where l ranges over i gj ):</p><p>q r hr D s ¥s ut vl st ¥w q t q yx q t ¥z q t q |{ q Let C }D wF IH ©P Q ~P TS VU be a transition system. A valuation of atomic propositions is a function r i j Q | . The validity of an LTL formula q for a run u vD wf x w.r.t. a valuation , denoted u Et D q , is de£ned inductively on the structure of q as follows:</p><p>u t D s |s u t D l u f x c e F Il U u t D uw q d u } t D o q u t D q yx q u u t D o q and u t D o q u t D uz q u u dF yU yt D q u t D q |{ q u r F gu dF U t D q ¥U x F f 2 u r u uF g U t D q U</p><p>We also de£ne q a s |s { q and q w F w q U . An LTL formula q is valid in a state f w.r.t. , written f t D q , iff u t D q for each run u which starts in the state f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Pushdown systems</head><p>A pushdown system is a tuple ¡ ¢D iF I£ P ¤ P ¥ P ¦ x P T § U where £ is a £nite set of control locations, ¤ is a £nite stack alphabet, ¥ ¨W F I£ ©` ¤ £U èF I£ ©` ¤ £B U is a £nite set of transition rules, ¦ x c e£ is an initial control location, and § ªc b¤ is a bottom stack symbol.</p><p>We use Greek letters « ¬P T £P to denote elements of ¤ , and small letters P Tu P from the end of the alphabet to denote elements of ¤ B . We also adopt a more intuitive notation for transition rules, writing ® fVP « y°± Q ²® I¦ ³P Tu u°instead of F ´F μP « yU IP F T¦ ³P Iu dU U yc ¶¥ .</p><p>A con£guration of ¡ is an element of £ •¤ £B . To ¡ we associate a unique transition system C ¹¸whose states are con£gurations of ¡ , the root is ® ¦ x yP I § º°, and the transition relation is the least relation Q satisfying the following:</p><formula xml:id="formula_0">® fVP « °y± Q X® ¦ ³P T ©°»D ® fVP « u °Q X® ¦ ³P T |u u°for every u c ¶¤ B</formula><p>Without loss of generality we require that § is never removed from the stack, i.e., whenever ® fVP T § r°± Q ¼® ¦ ³P Tu u°then u is of the form | § .</p><p>Pushdown systems can be conveniently used as a model of recursive sequential programs. In this setting, the (abstracted) stack of activation records increases if a new procedure is invoked, and decreases if the current procedure terminates. In particular, it means that the height of the stack can increase at most by one in a single transition. Therefore, from now on we assume that all pushdown systems we work with have this property. This assumption does not in¤uence the expressive power of pushdown systems, but it has some impact on the complexity analysis carried out in Section 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">LTL on pushdown systems</head><p>Let ¡ iD ½F I£ yP ¤ (P ¥ P ¦ ´x vP T § rU be a pushdown system, q an LTL formula, and r i gj rQ ² v¾ ¿ 2À |Á a valuation. We deal with the following variants of the model checking problem:</p><p>(I) The model checking problem for the initial con£guration: does ® ¦ x vP T § r°yt D o q ? (II) The global model checking problem: compute (a £nite description of) the set of all con£gurations, reachable or not, that violate q .</p><p>(III) The global model checking problem for reachable con£gurations: compute (a £nite description of) the set of all reachable con£gurations that violate q . In this paper we use so-called ¡ -automata to encode in£nite sets of con£gurations of a pushdown system ¡ . As we shall see, in some cases we can solve the problems (II) and (III) by computing ¡ -automata recognizing the above de£ned sets of con£gurations. De£nition 3.1 Let ¡ ÂD qF I£ P ¤ P ¥ P ¦ x vP I § rU be a pushdown system. A ¡ -automaton is a tuple Ã vD qF IÄ gP ¤ P Å P £ P AE U where Ä is a £nite set of states, ¤ (i.e., the stack alphabet of ¡ ) is the input alphabet, Å r Ä v»¤ ÂQ Ç |È is the transition function, £ (i.e., the set of control locations of ¡ ) is the set of initial states, and AE EW ÉÄ is a £nite set of accepting states. We extend Å to elements of Ä ÉỀ¤ £B in the standard way. A con£guration ® gVP Iu u°of ¡ is recognized by Ã iff Å yF gVP Tu dU Ë bAE É D YÌ .</p><p>In general, all of the above mentioned variants of the model checking problem are undecidable -if there are no 'effectivity assumptions' about valuations (i.e., if a valuation is an arbitrary function r i j Q Í |¾ ¿ 2À |Á ), one can easily express undecidable properties of pushdown con£gurations just by atomic propositions. Therefore, we search for 'reasonable' restrictions which do not limit the expressive power too much but allow to construct ef£cient modelchecking algorithms at the same time. For example, we can restrict ourselves to those valuations which are completely determined by associating atomic propositions with subsets of £ ©d¤ (see, e.g., <ref type="bibr" target="#b8">[2,</ref><ref type="bibr">6]</ref>). De£nition 3.2 Let ¡ ÂD qF T£ P ¤ (P ¥ ÎU be a pushdown system, Ï r F i j Î£ U yQ Ð À a function. A simple valuation r i gj (Q |¾ ¿ ¹À |Á (speci£ed by Ï ) is de£ned as follows: VF Tl U yD Gk ® fVP « u u°tt |« ec eÏ ©F Il rP TU IP Tu c ¶¤ £B p .</p><p>In other words, (in)validity of an atomic proposition in a given con£guration depends only on its control location and the topmost stack symbol (in our framework, we are mainly interested in reachable con£gurations where the stack is always nonempty). Consequently, if we are given a pushdown system ¡ , an LTL formula q , and a simple valuation , we can easily synchronize ¡ with a Büchi automaton which recognizes exactly the models of w q , reducing the model-checking problem to the problem whether a given Büchi pushdown system has an accepting run <ref type="bibr" target="#b8">[2,</ref><ref type="bibr">6]</ref>. Here, it is crucial that atomic propositions are evaluated in a completely 'static' way because otherwise we could not perform the aforementioned synchronization.</p><p>In our paper, we propose a more general kind of valuations which are encoded by £nite-state automata. We advocate this approach in the next sections by providing several examples of its applicability to practical problems; moreover, we show that this technique often results in rather ef£cient (or, at least, essentially optimal) algorithms by presenting relevant complexity results. De£nition 3.3 Let ¡ ¢D iF I£ yP ´¤ P ¥ P ¦ x vP T § U be a pushdown system, Ï a function which assigns to each pair F Il ºP IU of i j Ñ£ a deterministic £nite-state automaton Ò Ó Ô over the alphabet ¤ with a total transition function; we also assume that the initial state of Ò Ó Ô is not accepting. A regular valuation r i gj (Q Í |¾ ¿ 2À ¥Á (speci£ed by Ï ) is de£ned as follows: VF Tl U yD Gk ® fVP Tu u°¬t u )Õ Rc eÖ £F gÒ Ó Ô U p where u )Õ denotes the reverse of u .</p><p>Hence, an atomic proposition l is valid in a con£guration ® fVP Tu u°iff the automaton Ò ²Ó Ô enters a £nal state after reading the stack contents bottom-up. As we shall see, the requirement that Ò iÓ Ô is deterministic is rather natural and has an important impact on complexity analysis. The assumption that the initial state of Ò Ó Ô is not accepting simpli£es our next constructions -as we already mentioned, we are only interested in reachable con£gurations where it is impossible to empty the stack. Hence, this assumption does not bring any 'real' restrictions from a practical point of view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Model-Checking with Regular Valuations</head><p>The variants of the model checking problem de£ned in the previous section have been considered in <ref type="bibr">[6]</ref> for simple valuations. The following theorems are taken from there: Theorem 3.1 Let ¡ ÉD GF I£ yP ´¤ P ¥ P ¦ ´x vP T § rU be a pushdown system, q an LTL formula, and a simple valuation. Let × be a Büchi automaton for w q . Then one can compute a ¡ -automaton Ø with Ù uF t h£ )t Ú Ît ¥ Êt gU states and Ù uF It h£ gt ÜÛ Üt ¥ Êt ÜÛ F It h£ gt Ú Ît ¥ ÎU ´U transitions in Ù uF t h£ gt ÜÛ Üt ¥ Êt ÜÛ F t h£ gt Ú Ît ¥ ÎU ´U time and space such that Ø recognizes exactly the reachable con£gurations of ¡ ; a ¡ -automaton Ã of size Ù uF t £ gt Û t ¥ Êt Û t × t U in Ù uF t £ gt Û t ¥ Êt Û t × t Ý ¥U time using Ù uF t h£ gt Û t ¥ Êt Û t × t U space such that Ã recognizes exactly those con£gurations ® fVP Tu u°of ¡ (reachable or not) such that ® fVP Tu u°º t D q ; a ¡ -automaton Ã Þ of size Ù uF t £ gt ßÛ ¹t ¥ Êt ¹Û F It h£ gt ßÚ Gt ¥ Êt gU Û ßt × t U in Ù dF It h£ gt ¹Û ßt ¥ Êt ßÛ ßF t h£ gt ßÚ Yt ¥ Êt gU Û ¹t × t Ý ¥U time using Ù uF t £ gt Û t ¥ Êt Û F t h£ )t pÚ àt ¥ Êt gU Û t × t U space such that Ã Þ recognizes exactly those reachable con£gurations ® fVP Tu u°of ¡ such that ® fVP Tu u°r t D o q . Theorem 3.2 Let ¡ ÉD GF I£ yP ´¤ P ¥ P ¦ ´x vP T § rU be a pushdown system, q an LTL formula, and a simple valuation. Let × be a Büchi automaton which corresponds to w q . Problems (I) and (II) can be solved in Ù uF t h£ gt Û yt ¥ Êt Û yt × t Ý ¥U Our aim here is to design ef£cient model checking algorithms for regular valuations. We show that one can actually build on top of Theorem 3.1.</p><p>For the rest of this section we £x a pushdown system ¡ áD âF I£ yP ´¤ P ¥ P ¦ x vP T § U , an LTL formula q , and a regular valuation . The Büchi automaton which corresponds to w q is denoted by × qD qF Iã P ´ ä å IP Tae ©P TS px vP ç èU . Let k ³l P P l é µp be the subset of atomic propositions which appear in q , and let Ò iÓ Ô ¬ê D GF TÄ rÓ P ¤ (P ë pÓ P f Ó P AE ºÓ U be the deterministic £nite- state automaton associated to F Il £ P TU for all ¶c à£ and ì a ì a9 . Observe that we do not require the Ò iÓ Ô ¬ê automata to be pairwise different; as we shall see in Section 4.2, there are several 'safety' problems which can be reduced to the model-checking problem for pushdown systems and the LTL logic with regular valuations. In this case, many of the Ò Ó Ô ¬ê automata are identical and this fact substantially in¤uences the complexity. For simplicity, we assume that whenever D G or Ḡ D í¦ , then the Ò iÓ Ô ¬ê and Ò î Ô §ï automata are either identical or have disjoint sets of states. Let k ÜÒ ² P P IÒ ð èp be the set of all Ò Ó Ô ¬ê automata where ì s rì Ñ9 and Îc £ , and let Ä ºñ be the set of states of Ò ñ for each ì G eì Gò . The Cartesian product ´ó ñ ó ßð Ä rñ is denoted by ô ßj öõ vj ö÷ ø . For given ù S ec qô ßj öõ vj ö÷ ø , āc ú£ , and ì oì 9 , we denote by ù S |Ó the element of Ä rÓ which appears in ù S (observe that we can have ù S |Ó D ©ù S vî ñ even if D a or ¯ D w¦ ). The vector of initial states (i.e., the only element of ô ßj öõ vj ö÷ ø where each component is an initial state of some Ò Ó Ô ¬ê ) is denoted by ù f . Furthermore, we write ù h ºD ½ù ë ¥F Üù S ßP « yU if ù h Ó D ªë pÓ F Üù S |Ó P « yU for all ì ì a9 , ¶c e£ . Now we present and evaluate two techniques for solving the model checking problems with ¡ , q , and .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 3.1 (On the complexity measures) The size of an instance of the model-checking problem for pushdown</head><p>systems and LTL with regular valuations is given by t ¡ t ©Ú ©t h ßt ©Ú ©t q t , where t t is the total size of all employed automata. However, in practice we usually work with small formulae and a small number of rather simple automata (see Section 4); therefore, we measure the complexity of our algorithms in t × t and t gô ßj öõ vj ö÷ ø pt rather than in t q t and t h ßt (in general, × and ô ßj öõ vj ö÷ ø can be exponentially larger than q and ). This allows for a detailed complexity analysis whose results better match the reality because t × t and t fô ßj öõ vj ö÷ ø pt stay usually 'small'. This issue is discussed in greater detail in Section 5 where we provide some lower bounds showing that all algorithms developed in this paper are also essentially optimal from the point of view of worst-case analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Technique 1 -extending the £nite control</head><p>The idea behind this technique is to evaluate the atomic propositions l P P l é 'on the ¤y' by storing the (product of) Ò Ó Ô ¬ê automata in the £nite control of ¡ and updating the vector of states after each transition according to the (local) change of stack contents. Note that here we conveniently use the assumptions that the Ò Ó Ô tê automata are deterministic, have total transition functions, and read the stack bottom-up. However, we also need one additional assumption to make this construction work: Each automaton Ò Ó Ô ¬ê is also backward deterministic, i.e., for every û Ñc ~Ä rÓ and « ~c e¤ there is at most one state h üc eÄ rÓ such that ë pÓ F gh P « yU D û .</p><p>Note that this assumption is truly restrictive -there are quite simple regular languages which cannot be recognized by £nite-state automata which are both deterministic and backward deterministic (as an example we can take the language k ý t £þ ~ p ).</p><p>We de£ne a pushdown system ¡ dÞ ÊD F T£ oÞ ÿP ¤ (P ¥ uÞ ÿP ¦ ÜÞ x P I § rU where £ oÞ ÊD £ ÍỲô ßj öõ vj ö÷ ø , ¦ ÜÞ x D GF I¦ x vP 2ù ë 2F ù f pP T § U ´U , and the transition rules ¥ uÞ are determined as follows: ® F gVP ù S VU IP « °± Q eÞ t® ´F I¦ ³P vùû U TP Tu u°iff the following conditions hold:</p><p>® fVP « °y± Q X® ¦ ³P Tu u°, there is ù h üc aô ßj öõ vj ö÷ ø such that ù ë ¥F ù h P « yU D wù S and ù ë 2F ù h P Tu Õ U D •ùû .</p><p>Observe that due to the backward determinism of Ò iÓ Ô ¬ê there is at most one ù h with the above stated properties; and thanks to determinism of Ò Ó Ô ¬ê we further obtain that for given ® gμP « °± Q á® I¦ ³P Iu u°and ù S Êc úô ßj öõ vj ö÷ ø there is at most one ùû àc aô ßj öõ vj ö÷ ø such that ® F gVP ù S VU IP « °y± Q »Þ t® F T¦ ³P vù û U TP Iu u°. From this it follows that t ¥ uÞ ÿt D Yt ¥ Êt yÛ t fô ßj öõ vj ö÷ ø pt .</p><p>A con£guration ® F T¦ P ù S VU TP Tu u°of ¡ dÞ is consistent iff ù S ªD ¢ù ë ¥F ù f pP Tu Õ U (remember that ù f is the vector of initial states of Ò iÓ Ô ¬ê automata). In other words, ® F I¦ ³P ù S VU TP Iu u°is consistent iff ù S 're¤ects' the stack contents u . Let ® fVP Tu u°be a con£guration of ¡ and ® F gVP ù S VU IP Tu u°be the (unique) associated consistent con£guration of ¡ ÊÞ . Now we can readily con£rm that (A) if ® gμP Tu u°yQ ²® I¦ P T ©°, then ® ´F gVP ù S VU IP Tu u°Q X® F T¦ ³P vùû U IP T ©°where ® ´F I¦ ³P vùû U IP T ©°is consistent; (B) if ® ´F gVP ù S U IP Tu u°Q X® F I¦ ³P vùû U IP T ©°, then ® F T¦ ³P vùû U TP I ©°is consistent and ® fVP Tu u°yQ ²® I¦ ³P I ©°is a transition of C ¹¸.</p><p>As the initial con£guration of ¡ dÞ is consistent, we see (due to (B)) that each reachable con£guration of ¡ dÞ is consistent (but not each consistent con£guration is necessarily reachable). Furthermore, due to (A) and (B) we also have the following:</p><p>(C) let ® fVP Tu u°be a con£guration of ¡ (not necessarily reachable) and let ® F gVP ù S VU IP Tu u°be its associated consistent con£guration of ¡ Þ In other words, all problems take only linear (!) time and space in t gô ßj öõ vj ö÷ ø pt . Proof: We say that a ¡ )Þ -automaton is well- formed iff its set of states is of the form Ä agô ßj öõ vj ö÷ ø where Ä is a set such that £ W YÄ . A transition F ´F VP ù h U IP « ¬P F g|Þ ÿP vùû U ´U of a well-formed ¡ gÞ -automaton is consistent (w.r.t. ù ë ) iff ù ë 2F ù û P « yU D ù h . A ¡ )Þ -automaton is consistent iff it is well-formed and contains only consistent transitions.</p><p>For the proof we revisit the algorithms presented in <ref type="bibr">[6]</ref>. Algorithm 1 shows the computation of ¢ ¤£ ÷ |B from <ref type="bibr">[6]</ref>, restated for the special case of consistent ¡ Þ -automata. We £rst show that computation of ¢ ¤£ ÷ B upholds the consistency of a ¡ gÞ -automaton. Lemma 3.1 When receiving a consistent ¡ )Þ -automaton as input, Algorithm 1 will output a consistent ¡ gÞ -automaton.</p><p>Proof: Recall that Algorithm 1 implements the saturation procedure of <ref type="bibr" target="#b8">[2]</ref>, i.e., all additions to the automaton correspond to the following situation:</p><formula xml:id="formula_1">If ® F μP yùû U IP « °y± Q X® F ¯Þ P vùû Þ U TP Iu u°in ¥ Þ and F g¯Þ P vùû Þ U ¥ ¦ §¦ Q sF I¦ ³P vùû Þ Þ U in the current automaton, then add a transition F ´F μP yùû U IP « ¬P F I¦ ³P vùû µÞ Þ TU ´U .</formula><p>From the existence of the transition rule in ¥ uÞ we know that there exists ù h ac Íô ßj öõ vj ÿ÷ ø such that ù ë ¥F ù h P « yU ÊD ùû and ù ë ¥F ù h P Tu Õ U D Íùû µÞ . Provided that the automaton is consistent, we know that ù ë 2F ùû µÞ Þ ÿP Tu Õ U D Íùû µÞ . Exploiting the backward determinism we get ù h üD •ùû µÞ Þ , and hence the added transition is consistent.</p><p>The fact that the algorithm only has to deal with consistent transitions in¤uences the complexity analysis: 13 return rel Proof: A complete proof for the general case, discussing data structures and other details is given in <ref type="bibr">[6]</ref>. Here we just point out the important differences for the special case of consistent automata.</p><formula xml:id="formula_2">Lemma 3.</formula><p>Line 10 will be executed once for every combination of a rule ® ´F g¯ P vùû U IP « °y± Q X® F I¦ ³P vùû U IP « ¬« °and a (consistent) transition F ´F T¦ ³P vùû U TP « ¬P F I¦ ÜÞ ÿP vùû µÞ TU ´U . Since ùû µÞ is the single state for which ù ë ¥F ùû µÞ ÿP « U yD •ùû holds, there are Ù uF t ¥ uÞ Tt Û t hÄ gt gU D Ù uF t Ä t yÛ yt ¥ Êt yÛ t fô ßj öõ vj ö÷ ø pt gU such combinations. Thus, the size of ¥ Þ Þ is also Ù uF t hÄ t Û yt ¥ Êt yÛ yt gô ßj öõ vj ÿ÷ ø pt gU . For the loop starting at line 11, F I¦ ÜÞ ÿP vùû µÞ TU and « V (and hence ùû µÞ Þ ) are £xed, so line 12 is executed Ù uF t hÄ gt Û ¥t ¥ Êt ¥Û t fô ßj öõ vj ö÷ ø pt U times. Line 8 is executed once for every combination of rules ® F © ÜP vùû U IP « y °± Q ® ´F I¦ ³P vùû U TP « °in ¥ uÞ 0% u¥ Þ Þ and transitions F ´F T¦ ³P vù û U IP « ¬P F I¦ ÜÞ ÿP vùû µÞ TU ´U . Since the size of ¥ uÞ Þ is Ù uF t Ä t Û t ¥ Êt Û t fô ßj öõ vj ö÷ ø pt gU and ùû µÞ is unique, we have Ù uF t hÄ gt Û t ¥ Êt Û t fô ßj öõ vj ö÷ ø pt U such combinations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.3</head><p>The repeating heads of the product of ¡ )Þ and × can be computed in Ù uF t h£ )t Û |t ¥ Êt |Û |t fô ßj öõ vj ö÷ ø t |Û ¥t × t Ý ¥U time and Ù uF t h£ gt Û yt ¥ Êt yÛ yt gô ßj öõ vj ö÷ ø pt yÛ yt × t U space. Proof: (analogous to <ref type="bibr">[6]</ref>) The algorithm £rst computes the set ¢ ¤£ ÷ VB F k y® f|Þ ÿP 3# ß°»t ü|Þ c }£ oÞ rsã àp vU . Since this set can be represented by a consistent automaton with t h£ )t tàt hã t tàt fô ßj öõ vj ö÷ ø pt many states and no transitions, this step is bounded by the aforementioned limitations on time and space. From the results a head reachability graph of size Ù uF t £ gt ´Û ´t ¥ Êt ´Û ´t gô ßj öõ vj ö÷ ø pt ´Û ´t × t U is constructed. To £nd the repeating heads, we identify the strongly connected components of that graph which takes time linear in its size.</p><p>We can now conclude the proof of Theorem 3.3. The steps required to solve the model-checking problems are as follows:</p><p>Compute the set of repeating heads 4 65 of the product of ¡ gÞ and × . According to Lemma 3.3, this takes Ù uF t £ gt Û gt ¥ Êt gÛ ft fô ßj öõ vj ö÷ ø pt gÛ ft × t Ý U time and Ù uF t £ gt fÛ gt ¥ Êt fÛ gt fô ßj öõ vj ö÷ ø pt gÛ ft × t U space, and we have t 4 65 t ßD YÙ uF t ¥ Êt gÛ ft gô ßj ÿõ vj ö÷ ø ³t gÛ ft × t U . Construct an automaton Ã accepting exactly the consistent subset of 4 75 Ê¤ £B . Take Ã D ÉF F ´F I£ ½àã gU 2% »k f pp vU oồ ßj öõ vj ö÷ ø P ¤ P Å ÜP £ Y ¶k S px |p rbô ßj öõ vj ö÷ ø P k vF If P ù f U Ip vU . For every repeating head ® F gVP TS yP vùû U IP « °, add to Å the unique transition F ´F μP TS yP vùû U IP « ¬P pF Tf pP vùû µÞ IU U with ù ë 2F ùû Þ öP « yU D ù û . For every triple F ùû P « P yù û µÞ TU such that ù ë 2F ù û µÞ ÿP « yU D ù û add to Å the transition F ´F Tf pP vùû U TP « P F Tf pP vùû µÞ IU U . There are at most Ù uF t gô ßj ÿõ yj ÿ÷ ø pt Û t ¤ (t gU uW Ù uF It ¥ Êt Û t fô ßj öõ vj ö÷ ø pt U such triples. This automaton is consistent and has Ù uF t £ gt yÛ yt fô ßj öõ vj ö÷ ø t yÛ yt × t gU states and Ù uF It ¥ Êt yÛ yt gô ßj ÿõ yj ÿ÷ ø pt yÛ yt × t gU transitions. Compute the automaton Ã Þ ¬D GF ´F F I£ Gã )U 8% dk f ³p yU ¬ô ßj öõ vj ö÷ ø P ´¤ P Å ÜÞ ÿP £ G ¶k S x |p ô ßj öõ vj ö÷ ø P k yF If pP ³ù f U p yU corresponding to ¢ ¤£ ÷ |B F IÖ £F gÃ U U . According to Lemma 3.2, this takes Ù uF t £ gt Û t ¥ Êt Û ft fô ßj öõ vj ö÷ ø pt fÛ t × t Ý ¥U time and Ù uF t £ gt fÛ t ¥ Êt Û ft fô ßj öõ vj ö÷ ø pt fÛ t × t U space. (Recall that the size of × is also a factor in the size of the product transition rules.)</p><p>Due to Lemma 3.1, Ã Þ is consistent and accepts only consistent con£gurations. According to Proposition 3.1 in <ref type="bibr">[6]</ref> we have 9 G t D ¡ q for every con£guration in Ö (F fÃ Þ TU . According to (1), we then have ® fVP Tu u° t D ¡ q for every 9 D Í® F VP vùû U IP Tu u°in Ö £F fÃ Þ TU . Hence, we can solve the problem (II) by modifying Ã Þ slightly; let Ã èÞ Þ be the automaton Ã Þ Þ D F F ´F I£ v`ã )U @% k f ³p vU úô ßj öõ vj ö÷ ø A% a£ P ¤ P Å ÜÞ Þ ÿP £ yP k yF If pP ³ù f U p yU where Å ÜÞ Þ dD âÅ ÜÞ B% k F VP « ¬P ¦ yU t F ´F μP TS yP vùû U IP « ¬P ¦ yU c YÅ Þ vp . Problem (I) is solved by checking whether ® I¦ ´x vP T § º°)c GÖ £F fÃ Þ Þ TU . Since none of the steps required to compute Ã èÞ Þ takes more than Ù uF It h£ gt Û ¥t ¥ Êt ¥Û ¥t gô ßj öõ vj ö÷ ø pt ¥Û ¥t × t Ý ¥U time and Ù dF It h£ gt ¥Û |t ¥ Êt ¥Û ¥t gô ßj öõ vj ÿ÷ ø pt ¥Û ¥t × t U space, the £rst part of our theorem is proven.</p><p>To prove the second part we simply need to synchronise Ã Þ Þ with the automaton Ø which recognizes all reach- able con£gurations. Computing Ø takes Ù uF It h£ gt |Û ¥t ¥ Êt ¥Û ¥F t £ gt ¥Ú st ¥ Êt gU U time and space according to Theorem 3.1. The synchronization is performed as follows: For all transitions F gVP « ¬P I|Þ TU of Ã èÞ Þ and F I¦ ³P « ¬P ¦ ÜÞ TU of Ø we add a transition F ´F gVP ¦ yU IP « ¬P F g|Þ P ¦ ÜÞ TU ´U to the product. A straightforward procedure however would give us a higher result than necessary. We can do better by employing the following trick from <ref type="bibr">[6]</ref>: £rst all transitions F I¦ ³P « ¬P ¦ ³Þ TU of Ø are sorted into buckets labelled by « . Then each transition of Ã èÞ Þ which is needed to construct Ã èÞ Þ and Ø , we get the results stated in the second part of Theorem 3.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C D Technique 2 -extending the stack</head><p>An alternative approach to model-checking with regular valuations is to store the vectors of ô ßj ÿõ yj ÿ÷ ø in the stack of ¡ .</p><p>This technique works without any additional limitations, i.e., we do not need the assumption of backward determinism of Ò Ó Ô tê automata. We de£ne a pushdown system ¡ Þ D wF I£ yP ´¤ §Þ ÿP ¥ uÞ ÿP ¦ ´x vP T § Þ TU where ¤ §Þ yD ~¤ sàô ßj öõ vj ö÷ ø , § Þ yD F g § ºP ³ù f U where ù f is the vector of initial states of Ò Ó Ô ¬ê automata, and the set of transition rules ¥ uÞ is determined as follows:</p><formula xml:id="formula_3">® fVP F I« ¬P ù S VU °± Q eÞ t® I¦ ³P 3# ß°à u ® fVP « °y± Q X® ¦ ³P 3# ß° ® fVP F I« ¬P ù S VU °± Q eÞ t® I¦ ³P F g £P ù S VU °à u ® gμP « °± Q X® ¦ ³P T £° ® fVP F I« ¬P ù S VU °± Q Þ ® I¦ ³P F g £P vùû U ´F FE P ù S VU °à u ® gμP « °± Q ²® I¦ ³P I E y°©x ùû D ½ù ë ¥F Üù S ßP 3E U</formula><p>Intuitively, the reason why we do not need the assumption of backward determinism in our second approach is that the stack carries complete information about the computational history of the Ò Ó Ô ¬ê automata.</p><p>A Proof: Since t ¥ Þ t rD t ¥ Êt VÛ t fô ßj öõ vj ö÷ ø pt (here we use the fact that each Ò iÓ Ô ¬ê is deterministic), we can compute a ¡ - automaton Q ÇD F 3R P ¤ §Þ ÿP 3E P £ yP ç U of size Ù uF t £ gt µÛ µt ¥ Êt µÛ µt fô ßj öõ vj ö÷ ø pt µÛ µt × t U in Ù uF t h£ gt Û t ¥ Êt µÛ µt fô ßj öõ vj ö÷ ø pt µÛ µt × t Ý |U time and Ù uF t £ gt pÛ t ¥ Êt Û pt gô ßj öõ vj ö÷ ø pt Û pt × t U space such that Q recognizes all con£gurations of ¡ dÞ which violate q (see Theorem 3.1); then, to solve problem (I), we just look if Q accepts ® ¦ x vP T § Þ °. The problem with Q is that it can also accept inconsistent con£gurations of ¡ Þ . Fortunately, it is possible to perform a kind of 'synchronization' with the reversed Ò Ó Ô tê automata. We de£ne Ã ¢D ÍF TÄ gP ¤ P Å ÜP £ P AE U where Ä iD F $R Eàô ßj öõ vj ö÷ ø ³U ¤% b£ , AE D ªç •Îk 2ù f ³p , and Å is de£ned as follows:</p><p>if From this we immediately obtain that Ã indeed accepts exactly those con£gurations of ¡ which violate q . Moreover, the size of Ã and the time and space bounds to compute it are the same as for Q which proves the £rst part of the theorem.</p><formula xml:id="formula_4">S UT WV PX Y $a ¦ Q cb is a transition of E , then Å contains a transition F FS µP ù h U V ¦ Q F 3b VP ù S</formula><p>To solve problem (III), one can try out the same strategies as in Theorem 3.3. Again, it turns out that the most ef£cient way is to synchronize Ã with the ¡ -automaton Ø which recognizes all reachable con£gurations of ¡ . Employing the same trick as in Theorem 3.3 (i.e., sorting transitions of Ø into buckets according to their labels C D</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Applications</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Interprocedural Data-Flow Analysis</head><p>Pushdown systems provide a very natural formal model for programs with recursive procedures. Hence, it should not be surprising that ef£cient analysis techniques for pushdown automata can be applied to some problems of interprocedural data-¤ow analysis (see, e.g., <ref type="bibr" target="#b13">[7,</ref><ref type="bibr" target="#b17">11]</ref>). Here we brie¤y discuss the convenience of regular valuations in this application area. We do not present any detailed results about the complexity of concrete problems, because this would necessarily lead to a quite complicated and lengthy development which is beyond the scope of our work (though the associated questions are very interesting on their own). Our aim is just to provide convincing arguments demonstrating the importance of the technical results achieved in Section 3.</p><p>A standard way of abstracting recursive programs for purposes of interprocedural data-¤ow analysis it to represent each procedure £ by its associated ¤ow graph. Intuitively, the ¤ow graph of £ is a labelled binary graph whose nodes correspond to 'program points', and an arc 9 f ¦ Q 9 §Þ indicates that the control ¤ow is shifted from the point 9 to 9 Þ by performing the instruction 9 . The entry and exit points of £ are modeled by distinguished nodes. To avoid undecidabilities, the g ih qp ¥s qr qs ut qp qs uv Pw is command (and related instructions) are modeled by nondeterminism, i.e., there can be several arcs from the same node. Moreover, there are special arcs with labels of the form x õ Py F õ £ F ø pU which model procedure calls (where õ £ F ø is a vector of terms which are passed as parameters). Flow graphs can be easily translated to pushdown systems; as transitions of pushdown systems are not labelled, we £rst perform a 'technical' modi£cation of the ¤ow graph, replacing each arc 9 f ¦ Q ¨9 §Þ where 9 is a nondeterministic node (i.e., a node with more than one successor) by two arcs 9</p><p>¦ Q ¨9 §Þ Þ f ¦ Q ¨9 §Þ where 9 §Þ Þ is a new node and # is a 'dummy' instruction without any effect. This allows to associate the instruction of each arc 9 f ¦ Q 9 ©Þ directly to 9 (some nodes are associated to the dummy instruction). Now suppose there is a recursive system of procedures £ y P P £ é µP H , where H is a distinguished starting procedure which cannot be called recursively. Their associated ¤ow graphs can be translated to a pushdown automaton in the following way:</p><p>for each node 9 of each ¤owgraph we introduce a fresh stack symbol eé ; for each arc of the form 9 f ¦ Q ¨9 §Þ we add a rule ® ´Û hP 3 é °± Q ²® Û hP 3 ¶é ¡ °, where Û is the (only) control location; for each arc of the form 9 &amp;T a ¦ ¦ )¦ 8¦ 8¦ )¦ 8¦ Q w9 Þ we add the rule ® ´Û P $ é °ü± Q ® Û hP Ä © å é ¡ °where Ä å is the stack symbol for the entry node of (the ¤ow graph of) Ä . Observe that one can also push special symbols correspond- ing to arguments if needed; for each procedure £ different from H we add the rule ® ´Û P £ e § d å °o± Q ® ´Û P $# ¹°, where £ e § d å corresponds to the exit node of £ . For the starting procedure H we add the rule ® Û hP H 2 § d å °y± Q X® ´Û P H 2 § d å °.</p><p>In other words, the top stack symbol corresponds to the current program point (and to the instruction which is to be executed), and the stack carries the information about the history of activation calls. Now, many of the well-known properties of data-¤ow analysis (e.g., liveness, reachability, very business, availability) can be expressed in LTL and veri£ed by a model-checking algorithm (in some cases the above presented construction of a pushdown automaton must be modi£ed so that all necessary information is properly re¤ected -but the principle is still the same). For example, if we want to check that a given variable A is dead at a given program point 9 (i.e., whenever the program point 9 is executed, in each possible continuation we have that A is either not used or it is rede£ned before it is used), we can model-check the formula rF ´j e ¢ é D ²F ´F Iw &amp;f ¥ø ÷ g 0h g{ ig v÷ §j uh oU lk ÂF ´ üw @f 2ø ÷ mg nh U ´U ´U in the con£guration ® Û hP H &amp; å y°, where f 2ø ÷ mg nh , f 2ø ÷ g nh , and g v÷ Fj oh are atomic propositions which are valid in exactly those con£gurations where the topmost stack symbol corresponds to the program point 9 , to an instruction which uses the variable A , or to an instruction which de£nes A , respectively. Even in this simple example, we can see that regular valuations are indeed useful -if we have a language with dynamic scoping (e.g., LISP), we cannot resolve to which A the instruction A r D qp at a program point 9 refers to without examining the stack of activation records (the A refers to a local variable A of the topmost procedure in the stack of activation records which declares it). So, f 2ø ÷ g nh and g y÷ §j oh would be interpreted by regular valuations in this case. The example above is quite simple. The 'real' power of regular valuations would become apparent in a context of more complicated problems where we need to examine complex relationships among dynamically gathered pieces of information. This is one of the subjects of intended future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Pushdown Systems with Checkpoints</head><p>Another area where the results of Section 3.1 £nd a natural application is the analysis of recursive computations with local security checks. Modern programming languages contain methods for performing run-time inspections of the stack of activation records, and processes can thus take dynamic decisions based on the gathered information. An example is the class r Ps qs is w qw it uu qt |s qv uu qv qv us qv implemented in Java Development Kit 1.2 offering the method s ir us Ps iw qx us qv qy g qw qw qg zu qt which checks whether all methods stored in the stack are granted a given permission. If not, the method rises an exception.</p><p>We propose a (rather general) formal model of such systems called pushdown system with checkpoints. Our work was inspired by the paper <ref type="bibr">[10]</ref> which deals with the same problem. Our model is more general, however. The model of <ref type="bibr">[10]</ref> is suitable only for checking safety properties, does not model data-¤ow, and forbids mutually recursive procedure calls whereas our model has none of these restrictions. Properties of pushdown systems with checkpoints can be expressed in LTL and we provide an ef£cient model-checking algorithm for LTL with regular valuations. De£nition 4.1 A pushdown system with checkpoints is a triple { àD qF g¡ P 3| ßP Tae tU where ¡ ÉD GF I£ P ¤ P ´¥ P ¦ x vP T § U is a pushdown system, | is a function with domain Q áW i£ vÎ¤ which assigns to each pair F μP « yU dc Q a deterministic £nite-state automaton Ò Ó V D ÉF IÄ Ó V P ¤ P Å Ó</p><formula xml:id="formula_5">V P f Ó V P AE Ó V U . For technical convenience, we assume that Å Ó V is total, f Ó V c úAE Ó V , and Ö £F gÒ Ó V U W qk u « Êt u c ¶¤ £B p . Elements of Q are called checkpoints.</formula><p>Ï Þ F 2 v÷ x 2P F gVP U U D aÒ for c àk vÚ P ¦ P p , where Ò is the product automaton accepting</p><p>V n z Ö £F gÒ Ó V U where D Yk « Êt 2F μP « yU is a checkpoint p Ï 2Þ TF ÷ P F gVP ¦ U ´U D ªÏ ¥Þ TF e vø P F μP Ú U ´U D aÒ , where Ò is a one-state automaton accepting ¤ B . Ï Þ F ÷ P F gVP VU U D ªÏ Þ F u÷ P F gVP Ú )U U D ªÏ Þ F e vø P F gVP ¦ U ´U D ªÏ Þ F e vø P F μP VU U D aÒ , where Ò is a one-state automa- ton accepting Ì . Now we can readily con£rm the following: Theorem 4.1 Let ® fVP Tu u°be a con£guration of { . We have that ® fVP Tu u°t D q u ® F gVP VU IP ensures that all transitions in the latter path are 'consistent' with possible checkpoints in the former path. As all atomic propositions which appear in q are evaluated identically for pairs ® f2 P Tu r °, ® ´F g2 IP ´U TP Iu r °( see the de£nition of Ï µÞ above), we can conclude that both paths either satisfy or do not satisfy q .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C D</head><p>The previous theorem in fact says that the model-checking problem for LTL and pushdown systems with checkpoints can be reduced to the model-checking problem for LTL and 'ordinary' pushdown systems. As the formula is £xed and the atomic propositions v÷ mx , ÷ , and e vø are regular, we can evaluate the complexity bounds for the resulting model-checking algorithm using the results of Section 3.1. Let k l P P l é p be the set of all atomic propositions which appear in q , and let D }k ~ ÜP P Ò ið èp be the set of all Ò Ó Ô ¬ê automata. Let ô ßj öõ vj ö÷ ø be the Cartesian product of the sets of states of all Ò Ó V automata and the automata of . Let × be a Büchi automaton which corresponds to w q . Now we can state our theorem (remember that £ is the set of control states and ¥ the set of rules of the underlying pushdown system ¡ of { Proof: We apply Theorem 4.1, which says that we can equivalently consider the model-checking problem for the pushdown system ¡ )Þ , formula D q , and valuation yÞ . First, let us realize that the Büchi automaton which corresponds to w F D q U can be actually obtained by 'synchronizing' × with the Büchi automaton for , because w F D q U x w q . As the formula is £xed, the synchronization increases the size of × just by a constant factor. Hence, the automaton for w F D q U is asymptotically of the same size of × . The same can be said about the sizes of £ oÞ and £ , and about the sizes of ¥ uÞ and ¥ . Moreover, if we collect all automata in the range of Ï ¥Þ (see above) and consider the state space of their product, we see that it has exactly the size of ô ßj öõ vj ö÷ ø because the automata associated to e vø and u÷ have only one state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C D</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Model-checking CTL</head><p>In this section, we apply the model-checking algorithm to the logic CTLB which extends LTL with existential path quanti£cation <ref type="bibr">[4]</ref>. More precisely, CTL B formulae are built according to the following abstract syntax equation: q r hr D s |s dt vl st |w q t q yx q t i q t ¥z q t q |{ q where l ranges over the atomic propositions (interpreted, say, by a regular valuation represented by a £nite automaton of size t gô ßj öõ vj ÿ÷ ø pt ). For £nite-state systems, model-checking CTL B can be reduced to checking LTL as follows <ref type="bibr" target="#b11">[5]</ref>: For a CTLB formula q , call the path depth of q the maximal nesting depth of existential path quanti£ers within q . Subformulae of q can be checked in ascending order of path depth; subformulae of the form q Þ where q Þ is -free are checked with an LTL algorithm which returns the set of states H 0 ¡ satisfying q Þ . Then q Þ is replaced by a fresh atomic proposition whose valuation yields true exactly on H 0 ¡ , and the procedure is repeated for subformulae of higher path depth. The method can be transferred to the case of pushdown systems; running the LTL algorithm on q Þ returns an automaton Ò ¡ . We can then replace q Þ by a fresh atomic proposition whose valuation is given by Ò ¡ . This method was already proposed in <ref type="bibr" target="#b15">[9]</ref>, but without any complexity analysis.</p><p>Let us review the complexity of this procedure. For the rest of this subsection £x a pushdown system ¡ D F I£ yP ´¤ P ¥ P ¦ ´x vP T § U . Given an -free formula q , let × GD GF Iã P ä å P Tae ©P IS px yP ç U be a Büchi automaton corresponding to q , and let t gô ßj öõ vj ö÷ ø pt be the size of the Ò iÓ Ô ¬ê automata encoding the regular valuations of propositions in i gj .</p><p>The algorithms from section 3.1 (in general we can only use Technique 2) yield an automaton Ò which accepts exactly the con£gurations satisfying q . Observe that Ò is non-deterministic, reads the stack top-down, and has Ù uF t £ gt 2Û ¥t × t 2Û ¥t fô ßj öõ vj ö÷ ø pt U states. We need to modify the automaton before we can use it as an encoding for the regular valuation of q . More precisely, we need to reverse the automaton (i.e. make it read the stack bottom-up) and then determinise it. Reversal does not increase the size, and due to the determinism of Ò iÓ Ô ¬ê (in bottom-up direction) the determinisation explodes only the '£ Êòã part' of the states, i.e. we get an automaton Ò ÐÞ of size èF It fô ßj öõ vj ö÷ ø pt yÛ Ü n ¾ Õ U .</p><p>To check subformulae of higher path depth we replace q by a fresh atomic proposition l . With F Tl ¡ §P TU we associate the automaton Ò Ó Ô e¢ which is a copy of Ò ÐÞ where the set AE Ó of accepting states is taken as k F I¦ ³P f U t ¦ c ¶ |¾ ¿ Õ P ¦ ¤£ qF gVP TS px ¥U IP f ¶c ô ßj öõ vj ö÷ ø tp . The cross product of these new automata with the 'old' Ò Ó Ô ¬ê automata takes only èF t gô ßj öõ vj ö÷ ø pt yÛ 0 ¾ @ Õ gU states again; we need just one copy of the new automaton, and all reachable states are of the form F ´F I¦ ³P f U TP f U where ¦ c ¶ |¾ ¿ Õ and f rc aô ßj öõ vj ö÷ ø .</p><p>As we go up in path depth, we can repeat this procedure: First we produce a deterministic valuation automaton by taking the cross product of the automata corresponding the atomic propositions and those derived from modelchecking formulae of lower path depth. Then we model-check the subformula currently under consideration, and reverse and determinise the resulting automaton. By the previous arguments, each determinisation only blows up the non-deterministic part of the automaton, i.e. after each stage the size of the valuation automaton increases by a factor of ¾ @ ¥ ê where × is a Büchi automaton for the subformula currently under consideration.</p><p>With this in mind, we can compute the complexity for formulae of arbitrary path depth. Let × º P P I× (é be the Büchi automata corresponding to the individual subformulae of a formula q . Adding the times for checking the subformulas and using Theorem 3.4 we get that the model-checking procedure takes at most Ù t £ gt Û yt ¥ Êt yÛ yt fô ßj öõ vj ö÷ ø pt Û ¾ @ ¦ 2 § ê ¤© ¥ ê Û é ª ( t × ( t Ý time and Ù t h£ gt Û yt ¥ Êt yÛ yt gô ßj öõ vj ö÷ ø pt yÛ ¾ @ ¦ 2 § ê P© ¥ ê Û é ª £ t × ´t space. The algorithm hence remains linear in both t ¥ Êt and t gô ßj ÿõ yj ÿ÷ ø pt . The algorithm of Burkart and Steffen [3], applied to CTLB formulae which are in the second level of the alternation hierarchy, would yield an algorithm which is cubic in t ¥ Êt . On the other hand, the performance of our algorithm in terms of the formula is less clear. In practice, it would depend strongly on the size of the Büchi automata for the subformulae, and on the result of the determinisation procedures.</p><p>4. ® §S µP 3E ß °± Q X® §S µP 3E ¹ h ( °for every ì a ì a9 ¦</p><formula xml:id="formula_6">5. ® §S µP 3E ßé µ°y± Q X® §S µP 3# ¹°6 . ® §S µP l °± Q i® ý |P 3# ß°, ® §S µP ã )°± Q i® gS vP 3# ¹°, ® §S µP µ • ¶ °± Q i® FS µP I y $µ • ¶ °, ® §S µP µ • °± Q i® §S µP T y $µ • °7. ® ý ¥P ë |°y± Q X® ý ¥P 3# ¹°for every ë c ¹« s»F IÄ ´% k ¦ p vU 8. ® ý ¥P µ • °± Q ²® §S µP T y $µ • °, ® Iý ¥P µ • °y± Q X® ý ¥P 3# ¹°, ® ý |P µ • ¶ °y± Q X® ý |P $# ¹°, ® ý |P µ • ¶ °y± Q X® ý |P $# ¹°9</formula><p>. ® fS yP ë ¥°± Q ²® gS vP 3# ¹°for every ë c ¹« s»F IÄ ´% k ¦ p vU 10. ® fS yP µ • ¶ °y± Q X® §S µP T y $µ • ¶ °, ® fS yP µ • ¶ °y± Q X® fS yP 3# ß°, ® fS yP µ • °± Q X® fS yP 3# ß°, ® gS yP µ • °± Q ²® gS vP 3# ¹°I ntuitively, the execution of ¡ starts by entering the state ® FS µP I y § º°(rule 1). Then, exactly 9 ÎÚ Î symbols of « Ñ»F IÄ ~% k ¦ p vU are pushed to the stack; the compound symbol F F »P Ih U c º« RF IÄ »% àk ¦ p vU indicates that the tape contains the symbol and, if h üc eÄ , that the head is at this position and the control state of Ò is h ; if h üD ¦ it means that the head is elsewhere. During this process, the family of symbols is used as a 'counter' (rules 2). Realize that the word u of length 9 is surrounded by the '¬ ' and ' ' markers, so the total length of the con£guration is 9 àÚ à . The last symbol é ³ Ý is then rewritten to E © ë , where ë is one of µ • ¶ P µ • P l rP ã (rules 3). The purpose of ë is to keep information about the just stored con£guration (whether it is existential, universal, accepting, or rejecting) and the index of a rule which is to be used to obtain the next con£guration (always the £rst one; remember that accepting and rejecting con£gurations are terminal). After that, E is successively rewritten to all of the E ¹ symbols and disappears (rules 4,5). Their only purpose is to invoke several consistency checks -as we shall see, each pair F FS µP 3E ß ´U is a checkpoint and all rules of 4,5 are positive. Depending on the previously stored ë (i.e., on the type of the just pushed con£guration), we either continue with guessing the next one, or change the control state to ý or S (if the con£guration is accepting or rejecting, resp.) Hence, the guessing goes on until we end up with an accepting or rejecting con£guration. This must happen eventually, because Ò always halts. If we £nd an accepting con£guration, we successively remove all existential con£gurations and those universal con£guration for which we have already checked both successors. If we £nd a universal con£guration with only one successor checked -it is recognized by the 'µ ¹ ' symbol -we change 'µ • ' to ' 3µ • ' and check the other successor (rules 7 and 8). Similar things are done when a rejecting con£guration is found. The control state is switched to S and then we remove all con£gurations until we (possibly) £nd an existential con£guration for which we can try out the other successor (rules 9 and 10). We see that u is accepted by Ò iff we eventually pop the initial con£guration when the control state is 'ý ', i.e., iff the state ® ý ¥P T § r°is reachable.</p><p>To make all that work we must ensure that ¡ cannot gain anything by 'cheating', i.e., by pushing inconsistent sequences of symbols which do not model a computation of Ò in the described way. This is achieved by declaring all pairs F FS µP 3E ß ´U for ¶ì èì 9 aÚ Y as checkpoints. The automaton Ò ¼ ½ ê for ¶ì èì 9 accepts those words of the form § y V ë ¥ y vë (Û Û Û T |ð gë ³ð 6E ¹ , where ÷ j VF g |ñ ³U gD 9 Ú a , ë pñ ¶c iµ • ¶ P µ • ¶ P µ • P µ • P l rP ã for every ì w aì wò , such that the triples of symbols at positions P T yÚ Ñ ³P T yÚ » in each pair of successive substrings uG ¥P T qG Ü ( are consistent with the symbol ë G w.r.t. the transition function Å of Ò (if some con£guration has only one immediate successor, then Ò ¾¼ ½ ê 'ignores' the rule index stored in ë G ). Furthermore, the £rst con£guration must be the initial one, and the last con£guration Vð must be consistent with ë pð . Observe that Ò ¾¼ ½ ê needs just Ù uF t Ò ²t ¿ |U states to store the two triples (after checking subwords qG ¥P ë G ¥P T uG Ü ( , the triple of uG is 'forgotten') the initial con£guration, a 'counter' of capacity 9 Ú R , and some auxiliary information. Moreover, Ò ¾¼ ½ ê is deterministic and we can also assume that its transition function is total. As all rules associated with checkpoints are positive, any cheating move eventually results in entering a con£guration where the system 'gets stuck', i.e., cheating cannot help to reach the con£guration ® Iý ¥P T § r°. Proof: Let us consider the pushdown system with checkpoints { D GF f¡ dP 3| P Tae tU constructed in the proof of Theorem 5.1. To ensure that each £nite path in C P is a pre£x of some run, we extend the set of transition rules of ¥ by a family of independent rules of the form ® f pP « °± Q ® f pP « °for each control state f and each stack symbol « . Now it suf£ces to realize that the initial con£guration ® §S µP T § r°cannot reach the state ® ý ¥P T § º°iff it cannot reach any state of the form ® ý |P I § ©°(where Îc Ê¤ £B ) iff ® §S µP T § r°(t D o rF Iw £nU where is a simple valuation with the underlying function Ï such that Ï ©F £nU yD Yk vF Iý ¥P T § rU p .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C D 6 Conclusion</head><p>We have presented two different techniques for checking LTL with regular valuations on pushdown systems. Both techniques rely on a reduction to (and slight modi£cation of) the problem for simple valuations discussed in <ref type="bibr">[6]</ref>. Both techniques take linear time and space in t fô ßj öõ vj ö÷ ø pt where ô ßj öõ vj ö÷ ø is the set of states of an automaton representing the regular predicates used in the formula. Since both take the same asymptotic time it would be interesting to compare their ef£ciency in practice (for cases where both techniques can be used).</p><p>The solution can be seamlessly combined with the concept of symbolic pushdown systems in <ref type="bibr">[8]</ref>. These are used to achieve a succinct representation of Boolean Programs, i.e., programs with (recursive) procedures in which all variables are boolean.</p><p>The ability to represent data is a distinct advantage over the approaches hitherto made in our areas of application, namely data-¤ow analysis <ref type="bibr" target="#b13">[7]</ref> and security properties <ref type="bibr">[10]</ref>. For the latter, we have indicated that our model is more general. Our approach provides a unifying framework for these applications without losing ef£ciency. Both techniques take linear time in t fô ßj öõ vj ö÷ ø pt whereas the methods used in <ref type="bibr" target="#b13">[7]</ref> were cubic (though erroneously reported as linear there, too). In <ref type="bibr">[10]</ref> no complexity analysis was conducted.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>7</head><label></label><figDesc>On leave at the Institute for Informatics, TU Munich. Supported by a Research Fellowship granted by the Alexander von Humboldt Foundation and by a grant GA ³ CR No. 201/00/1023.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 5 . 2</head><label>52</label><figDesc>From the (technical) proof of Theorem 5.1 we can easily deduce the following: The model-checking problem (I) for pushdown systems with checkpoints (even for those with just three control states and no negative rules) is EXPTIME-complete even for a £xed LTL formula rF Iw £nU where £n is an atomic predicate interpreted by a simple valuation .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>. Then the parts of C ¸and C ¸¡ which are reachable from ® fVP Tu u°and ® F gVP ù S VU IP Tu u°, respectively, F gVP ù S VU c e£ oÞ . Now it is easy to see (due to (C)) that for all ¶c e£ and u •c ¶¤ B we have ® fVP Tu u°t D q u ® F VP ù S U IP Tu u°t D ¡ q where ù S D íù ë ¥F ù f pP Tu Õ UDuring the construction of ¡ gÞ we observed that t h£ oÞ t uD ¼t £ gt ©Û t fô ßj öõ vj ö÷ ø pt and t ¥ uÞ t uD ¼t ¥ Êt ©Û ©t gô ßj ÿõ yj ÿ÷ ø pt . Applying Theorem 3.2 naïvely, we obtain that using Technique 1, the model-checking problems (I) and (II) can be solved in</figDesc><table><row><cell>are isomorphic.</cell><cell></cell></row><row><cell cols="2">The underlying function Ï of the simple valuation yÞ is de£ned by</cell></row><row><cell>Ï ©F Il P F gVP ù S VU ´U yD</cell><cell>¤ if ù S vÓ c eAE ºÓ Ì otherwise</cell></row><row><cell cols="2">for all ì a ì a9 , (1)</cell></row></table><note><p><p><p>cubic time and quadratic space (w.r.t. t gô ßj öõ vj ö÷ ø pt ), and that model-checking problem (III) takes even quadric time and space. However, closer analysis reveals that we can do much better.</p>Theorem 3.3 Technique 1 (extending the £nite control) gives us the following bounds on the model checking problems with regular valuations: 1. Problems (I) and (II) can be solved in Ù uF</p>It h£ gt Û t ¥ Êt Û t gô ßj öõ vj ö÷ ø pt Û t × t Ý U time and Ù uF t h£ gt Û t ¥ Êt Û t gô ßj öõ vj ö÷ ø ³t Û t × t U space. 2. Problem (III) can be solved in either Ù uF t £ gt TÛ Tt ¥ Êt TÛ IF It h£ gt IÚ t ¥ Êt gU Û Tt gô ßj öõ vj ö÷ ø pt TÛ Tt × t Ý ¥U time and Ù uF It h£ gt TÛ Tt ¥ Êt TÛ IF t h£ gt TÚ t ¥ Êt U Û t fô ßj öõ vj ö÷ ø pt Û t × t U space, or Ù uF t £ gt Ý ¹Û t ¥ Êt Û F t h£ )t öÚ t ¥ Êt U ÜÛ t fô ßj öõ vj ö÷ ø pt Û t × t Ý ¥U time and Ù uF t £ gt Ý ¹Û t ¥ Êt Û F t h£ )t öÚ t ¥ Êt U ÜÛ t fô ßj öõ vj ö÷ ø pt Û t × t U space.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>2</head><label></label><figDesc>Given a consistent ¡ gÞ -automaton Ã vD F IÄ •ô ßj öõ vj ö÷ ø P ´¤ P Å P £ •àô ßj öõ vj ö÷ ø P AE U , we can compute ¢ ¤£ ÷ |B F TÖ £F fÃ bU ´U in Ù uF t hÄ t Û yt ¥ Êt yÛ t fô ßj öõ vj ö÷ ø pt gU time and Ù uF t hÄ gt yÛ yt ¥ Êt yÛ t fô ßj öõ vj ö÷ ø pt vÚ Rt hÅ t gU space.Input: a pushdown system ¡ )Þ ¬D GF I£ ©èô ßj ÿõ vj ö÷ ø P ´¤ P ¥ uÞ ÿP ¦ ´x vP T § rU ; a consistent ¡ gÞ -automaton Ã ED GF IÄ •èô ßj öõ vj ö÷ ø P ¤ (P Å ÜP £ •èô ßj öõ vj ö÷ ø P AE U Output: the set of transitions of Ã © Á 1 £ ÷ ²Ì £j £ õ ßø ! XÅ ©¥ uÞ Þ " ²Ì 2 for all ® F μP yù û U IP « °± Q ²® F |Þ ÿP vùû µÞ TU TP $# ¹°c ¶¥ uÞ do j £ õ ßø ! j £ õ ßø &amp;% k vF F gVP vùû U TP « ¬P F g|Þ ÿP vùû µÞ TU ´U p ; 3 while j £ õ ßø u D YÌ do 4 pop h ºD GF ´F T¦ P yùû U IP « ¬P F I¦ ÜÞ ÿP vùû µÞ TU ´U from trans; ´F T¦ ÜÞ ÿP vù û µÞ TU TP « vP F I¦ ÜÞ Þ ÿP vùû µÞ Þ TU ´U c £ ÷ do 12 j £ õ ßø ! ¢j £ õ ßø &amp;% bk vF ´F P vùû U IP « y P F I¦ ÜÞ Þ ÿP vùû µÞ Þ TU ´U Ip ;</figDesc><table><row><cell cols="2">Algorithm 1</cell></row><row><cell>5 6 7 8 9 10</cell><cell>if h (' c £ ÷ then £ ÷ " £ ÷ )% bk h p ; for all ® F g P vùû U TP « y °± Q ²® F T¦ ³P vùû U TP « °yc F ¥ uÞ 0% ¥ uÞ Þ TU do j £ õ ßø 1 j £ õ ßø &amp;% k yF ´F g P vùû U TP « P F I¦ Þ P vùû Þ U ´U p ; for all ® F g P vùû U TP « y °± Q ²® F T¦ ³P vùû U TP « ¬« |°c  ¶¥ uÞ do ¥ uÞ Þ 2 Í¥ uÞ Þ 0% k ® F g P vùû U TP « °y± Q X® F T¦ ÜÞ ÿP vùû µÞ TU IP « |°p ;</cell></row></table><note><p><p>11</p>for all F</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>is multiplied with the transitions in the respective bucket. As Ø has Ù uF It h£ gt VÚ Gt ¥ Êt U states, each bucket contains Ù uF ´F t £ gt VÚ Gt ¥ Êt U U items. Hence, the product can be computed in Ù uF t h£ gt vÛ |t ¥ Êt |Û ¥F It h£ gt ¥Ú Ñt ¥ Êt gU Û |t fô ßj öõ vj ö÷ ø pt vÛ |t × t U time and space. Alternatively, we can sort the transitions of Ã Þ Þ into buckets of size Ù uF t £ gt Û vt × t Û vt fô ßj öõ vj ö÷ ø pt U (exploiting the consistency of t Ã Þ Þ t ) and construct the product in Ù dF It h£ gt Ý (Û t ¥ Êt Û F t £ gt Ú et ¥ Êt gU 2Û t fô ßj öõ vj ö÷ ø pt Û t × t U time and space. If we add the time and space</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>VU where ù h üD íù ë 2F Üù S ¹P « yU ; if F gVP ù S VU VQ ²F FS µP ù h U , ¶c e£ , is a transition of Å , then ¯VQ F dS µP ù h U is also a transition of Å .</figDesc><table><row><cell cols="2">Notice that Ã is the same size as Q since in every transition ù h is uniquely determined by ù S and « . Now, for every con£guration ® gVP pF T« eG ¥P ù S VF 3H U ´U ¹Û Û Û F T« y P ù S VF yU ´U °, one can easily prove (by induction on H ) that</cell></row><row><cell></cell><cell>E F gVP F I« PG ¥P ù S VF $H U ´U 2Û Û Û F I« P ù S VF yU ´U ´U yD Y¦ where ù S F g gÚ Ñ U D íù ë 2F ù S VF g ßU IP « ñ ³U for all ì a u IH</cell></row><row><cell>iff</cell><cell>Å yF ´F gVP ù S VU IP « PG £Û Û Û « y U yD GF I¦ ³P ù S VF ´ U ´U where ù S D ½ù ë ¥F ù S VF 3H U IP « PG ¹U I</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>), we obtain that the size of Ã èÞ is Ù uF It h£ gt ÿÛ ÿt ¥ Êt ÿÛ F t £ gt Ú ut ¥ Êt gU Û ÿt fô ¹j ÿõ vj ö÷ ø pt Û ÿt × t U and it can be computed in Ù uF It h£ gt ÿÛ ÿt ¥ Êt ÿÛ F t £ gt Ú ut ¥ Êt gU Û ÿt fô ßj öõ vj ö÷ ø pt ÿÛ ÿt × t Ý ¥U</figDesc><table /><note><p>time using Ù uF t h£ gt Û Üt ¥ Êt ÜÛ ÜF t h£ gt ÜÚ Êt ¥ Êt gU Û Üt fô ßj öõ vj ö÷ ø t ÜÛ Üt × t U space. Using the alternative method (sorting transitions of Ã into buckets instead and exploiting determinism) we get an automaton of size Ù uF It h£ gt Ý Û vt ¥ Êt vÛ |F t h£ )t |Ú Ñt ¥ Êt U §Û vt gô ßj öõ vj ö÷ ø pt vÛ vt × t U in Ù uF t h£ gt Ý ºÛ yt ¥ Êt yÛ yF t h£ gt vÚ Rt ¥ Êt U Û yt fô ßj öõ vj ö÷ ø pt yÛ yt × t Ý ¥U in time and Ù uF It h£ gt Ý ºÛ yt ¥ Êt yÛ vF It h£ gt vÚ Rt ¥ Êt gU Û t fô ßj öõ vj ö÷ ø pt yÛ yt × t U space.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Tu u°t D ¡ o D q where ºF ´F 2 v÷ x uD Xz ¶F Iw ÷ U ´U x ÊF Iw A 2 v÷ x z dD Xz ¶F Iw 1e vø ³U ´U U . It suf£ces to realize that ® fVP Tu u° ® f|x vP Tu üx |°yQ ²® g© ÜP Tu °yQ X® f| vP Tu ü |°yQ ²® f¯Ý P Iu Ý °yQ XÛ Û Û is an in£nite path in C iff ® F gVP VU TP Iu u° ® ´F g|x vP x ¥U IP Tu üx |°yQ ²® ´F g P U TP Iu è °yQ X® F g| vP ¥U TP Iu ü |°yQ XÛ Û Û is an in£nite path in C ©¸¡ satisfying (where each for rþ ª is either Ú , ¦ , or ; realize that all are determined uniquely). Indeed,</figDesc><table><row><cell>Proof:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>). We have the following bounds on the model checking problems for LTL with regular valuations and pushdown systems with checkpoints: 1. Problems (I) and (II) can be solved in Ù uF It h£ gt Û t ¥ Êt Û t gô ßj öõ vj ö÷ ø pt Û t × t Ý ¥U time and Ù uF t h£ gt Û t ¥ Êt Û t gô ßj öõ vj ö÷ ø ³t Û t × t U space. 2. Problem (III) can be solved in either Ù uF t £ gt TÛ Tt ¥ Êt TÛ IF It h£ gt IÚ t ¥ Êt gU Û Tt gô ßj öõ vj ö÷ ø pt TÛ Tt × t Ý ¥U time and Ù uF It h£ gt TÛ Tt ¥ Êt TÛ IF t h£ gt TÚ t ¥ Êt U Û t fô ßj öõ vj ö÷ ø pt Û t × t U space, or Ù uF t £ gt Ý ¹Û t ¥ Êt Û F t h£ )t öÚ t ¥ Êt U ÜÛ t fô ßj öõ vj ö÷ ø pt Û t × t Ý ¥U time and Ù uF t £ gt Ý ¹Û t ¥ Êt Û F t h£ )t öÚ t ¥ Êt U ÜÛ t fô ßj öõ vj ö÷ ø pt Û t × t U</figDesc><table><row><cell>Theorem 4.2 space.</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ae r ¥ Q k vÚ rP ¦ P p is a function which partitions the set of transition rules into positive, negative, and inde- pendent ones. We require that if F gVP « yU is not a checkpoint, then all rules of the form ® fVP « °b± Q ® ¦ ³P T ©°are independent.</p><p>The function ae determines whether a rule can be applied when an inspection of the stack at a checkpoint yields a positive or negative result, or whether it is independent of such tests. Using positive and negative rules, we can model systems which perform g ih qp ¥s qr qs ut qp qs qv w is commands where the condition is based on dynamic checks; hence, these checks can be nested to an arbitrary level. The fact that a rule ® fVP « °(± Q ¢® ¦ ³P T ©°is positive, negative, or independent is denoted by ® fVP « °y± Q ® ¦ ³P T ©°, ® gVP « °± Q ~} à® ¦ ³P T ©°, or ® fVP « °y± Q x ® ¦ ³P T ©°, respectively.</p><p>To { we associate a unique transition system C 8 where the set of states is the set of all con£gurations of ¡ , ® ¦ x yP I § º°i s the root, and the transition relation is the least relation Q satisfying the following:</p><p>Some natural problems for pushdown processes with checkpoints are listed below.</p><p>The reachability problem: given a pushdown system with checkpoints, is a given con£guration reachable? The checkpoint-redundancy problem: given a pushdown system with checkpoints and a checkpoint F gVP « yU , is there a reachable con£guration where the checkpoint F gVP « yU is (or is not) satis£ed?</p><p>This problem is important because redundant checkpoints can be safely removed together with all negative (or positive) rules, declaring all remaining rules as independent. Thus, one can decrease the runtime overhead.</p><p>The global safety problem: given a pushdown system with checkpoints and a formula q of LTL, do all reachable con£gurations satisfy q ? An ef£cient solution to this problem allows to make 'experiments' with checkpoints with the aim of £nding a solution with a minimal runtime overhead.</p><p>Actually, it is quite easy to see that all these problems (and many others) can be encoded by LTL formulae and regular valuations. For example, to solve the reachability problem, we take a predicate l which is satis£ed only by the con£guration ® fVP Tu u°whose reachability is in question (the associated automaton Ò ²Ó Ô has ÷ j VF gu dU states) and then we check the formula ºF w l U . Observe that this formula in fact says that ® fVP Tu u°is unreachable; the reachability itself is not directly expressible in LTL (we can only say that ® fVP Tu u°is reachable in every run). However, it does not matter because we can simply negate the answer of the model-checking algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Model-Checking LTL for Pushdown Systems with Checkpoints</head><p>Let { ED F f¡ dP 3| P Tae tU be a pushdown system with checkpoints, where ¡ D F I£ P ¤ P ¥ P ¦ ´x vP T § U . We de£ne a pushdown system ¡ )Þ D ¨F I£ Ék yÚ P ¦ P ´ ßp P ¤ (P ¥ uÞ ÿP F I¦ ´x yP ´ U IP T § U where ¥ uÞ is the least set of rules satisfying the following (for each c àk vÚ rP ¦ P p</p><p>Intuitively, ¡ )Þ behaves in the same way as the underlying pushdown system ¡ of { , but it also 'remembers' what kind of rule (positive, negative, independent) was used to enter the current con£guration.</p><p>Let be a regular valuation for con£gurations of { with an underlying function Ï (see De£nition 3.3), and let q be an LTL formula. Let 2 v÷ mx , ÷ , and e vø be fresh atomic propositions which do not appear in q . We de£ne a function Ï Þ , which is the underlying function for a regular valuation Þ for con£gurations of ¡ Þ , as follows:</p><p>if l ªc bi j 2 k P y÷ x 2P ÷ P m 1e vø pp , then Ï 2Þ TF Tl rP F gVP U ´U D ªÏ ©F Il rP TU for c k yÚ P ¦ P ´ ßp</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Lower Bounds</head><p>In previous sections we established reasonably-looking upper bounds for the model-checking problem for pushdown systems (£rst without and then also with checkpoints) and LTL with regular valuations. However, the algorithms are polynomial in t ¡ t Ú Gt fô ßj öõ vj ö÷ ø pt Ú Gt × t , and not in the size of problem instance which is (as we already mentioned in Remark 3.1) t ¡ t Ú Gt h ßt Ú Gt q t . In Remark 3.1 we also explained why we use these parameters -it has been argued that typical formulae (and their associated Büchi automata) are small, hence the size of × is actually more relevant (a model-checking algorithm whose complexity is exponential just due to the blowup caused by the transformation of q into × is usually ef£cient in practice). The same can be actually said about t gô ßj öõ vj ö÷ ø pt -in Section 4 we have seen that there are interesting practical problems where the size of t gô ßj öõ vj ö÷ ø pt does not explode. Nevertheless, from the point of view of worst-case analysis (where we measure the complexity in the size of problem instance) our algorithms are exponential. A natural question is whether this exponential blowup is indeed necessary, i.e., whether we could (in principle) solve the model-checking problems more ef£ciently by some 'better' technique. In this section we show it is not the case, because all of the considered problems are EXPTIME-hard (even in rather restricted forms).</p><p>We start with the natural problems for pushdown systems with checkpoints mentioned in the previous section (the reachability problem, the checkpoint redundancy problem, etc.) All of them can be (polynomially) reduced to the model-checking problem for pushdown systems with checkpoints and LTL with regular valuations and therefore are solvable in EXPTIME. The next theorem says that this strategy is essentially optimal, because even the reachability problem provably requires exponential time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5.1 The reachability problem for pushdown systems with checkpoints (even for those with just three control states and no negative rules) is EXPTIME-complete.</head><p>Proof: The membership to EXPTIME follows from Theorem 4.2. We show EXPTIME-hardness by reduction from the acceptance problem for alternating LBA (which is known to be EXPTIME-complete). An alternating LBA is a tuple Ò D GF IÄ gP « £P Å P ¦ x vP ¬ µP µP IU where Ä gP « £P Å ÜP ¦ x vP z¬ P and are de£ned as for ordinary non-deterministic LBA (¬ and are the left-end and right-end markers, resp.), and ¯r Ä ÉQ k tP 2P ³õ x x P £ ÷ §® µp is a function which partitions the states of Ä into universal, existential, accepting, and rejecting, respectively. We assume (w.l.o.g.) that Å is de£ned so that 'terminated' con£gurations (i.e., the ones from which there are no further computational steps) are exactly accepting and rejecting con£gurations. Moreover, we also assume that Ò always halts and that its branching degree is (i.e., each con£guration has at most two immediate successors). A computational tree for Ò on a word u c ¯« B is any (£nite) tree °satisfying the following: the root of °is (labeled by) the initial con£guration ¦ x q¬ |u ± of Ò , and if ² is a node of Ò labelled by a con£guration û ¦ where û P T c ³« B and ¦ c eÄ , then the following holds: if ¦ is accepting or rejecting, then ² is a leaf; if ¦ is existential, then ² has one successor whose label is some con£guration which can be reached from û ¦ in one computational step (according to Å ); if ¦ is universal, then ² has ò successors where ò ²ì ú is the number of con£gurations which can be reached from û ¦ in one step; those con£gurations are used as labels of the successors in one-to-one fashion. Ò accepts u iff there is a computational tree °such that all leaves of °are accepting con£gurations. Now we describe a polynomial algorithm which for a given alternating LBA Ò D qF TÄ gP « £P Å P ¦ x |P z¬ P z P TU and a word u ¨c ´« oB of length 9 constructs a pushdown system with checkpoints { ªD ½F f¡ dP $| ßP Tae tU and its con£guration ® ý |P I § º°such that ® ý |P T § r°is reachable from the initial con£guration of { iff Ò accepts u . Intuitively, the underlying system ¡ of { simulates the execution of Ò and checkpoints are used to verify that there is no cheating during the process. We start with the de£nition of ¡ , putting ¡ ÂD GF Ik S µP ý |P TS p P ¤ P ´¥ P 3S µP T § U where ¤ RD I« sèF IÄ ´% bk ¦ p vU P% k y P Û Û Û P T é p Ý p 6% k E © P Û Û Û P 3E ßé µp 6% k µ • ¶ P µ • ¶ P µ • P µ • P l rP ã P T § ºp ¥ contains the following (families of) rules:</p><p>1. ® §S µP T § r°± Q ²® FS P T y § r°2 . ® §S µP T © °± Q ²® FS µP I ( ë ¥°for all ì ì a9 »Ú Î and ë c ³« sèF TÄ ´% k ¦ p vU 3. ® §S µP T ©é p Ý °± Q ²® FS µP $E © ë |°for every ë èc àk µ • ¶ P µ • P l rP ã p Hence, model-checking LTL for pushdown systems with checkpoints is EXPTIME-complete even when we have only simple valuations.</p><p>Now we analyze the complexity of model-checking with (ordinary) pushdown systems and LTL formulae with regular valuations. First, realize that if we take any £xed formula and a subclass of pushdown systems where the number of control states is bounded by some constant, the model-checking problem is decidable in polynomial time. Now we prove that if the number of control states is not bounded, the model-checking problem becomes EXPTIMEcomplete even for a £xed formula. At this point, one is tempted to apply Theorem 4.1 to the formula rF w £nU of Theorem 5.2. Indeed, it allows to reduce the model-checking problem for pushdown systems with checkpoints and ºF w £nU to the model-checking problem for ordinary pushdown systems and another £xed formula D ºF w £nU .</p><p>Unfortunately, this reduction is not polynomial because the atomic proposition 2 v÷ mx occurring in is interpreted with the help of several product automata constructed out of the original automata which implement checkpoints (see the previous section). Therefore we need one more technical proof. Proof: This proof is similar to the proof of Theorem 5.1. Again, we construct a pushdown system ¡ which simulates the execution of an alternating LBA Ò D GF IÄ gP « £P Å ÜP ¦ x vP z¬ P z P TU on an input word u c ³« oB of length 9 . The difference is that, since there are no checkpoints, we must £nd a new way of 'cheating-detection', i.e., we must be able to recognize situations when the next con£guration of Ò has not been guessed correctly. It is achieved by adding a family of control states 9 P P i9 ´é ; after guessing a new con£guration, ¡ successively switches its control state to 9 y P P i9 ´é without modifying its stack. The underlying function Ï of the constructed regular valuation assigns to each pair F correctP i9 ´ U a deterministic automaton Ò f ê À å which checks that the triples of symbols at positions ÜP T (Ú ú ³P T Ú à in each pair of successive con£gurations previously pushed to the stack are 'consistent' (Ò f ê À å is almost the same automaton as the Ò ¾¼ ½ ê of the proof of Theorem 5.1). All other pairs of the form F correctP TU are assigned an automaton accepting ¤ B . The ¡ is formally de£ned as follows: ¡ ÉD GF k S µP ý ¥P TS yP i9 v P P i9 ´é p ³P ´¤ P ¥ P 3S µP I § rU where ¤ RD I« sèF IÄ ´% bk ¦ p vU P% k y P Û Û Û P T é p Ý p 6% k Áµ • ¶ P µ • ¶ P µ • P µ • P l rP ã P T § ºp ¥ contains the following (families of) rules:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Ý</forename><surname>°±</surname></persName>
		</author>
		<author>
			<persName><surname>²®</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">® 9 P ë ¥°± Q X® $9</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">§S µP l °± Q i® ý |P 3# ß°, ® §S µP ã )°± Q i® gS vP 3# ¹°, ® §S µP µ • ¶ °± Q i® FS µP I y $µ • ¶ °, ® §S µP µ • °± Q i® §S µP T y $µ • °7</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">•</forename><surname>°±</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>²® §s Μp T Y $µ • °</surname></persName>
		</author>
		<title level="m">® Iý ¥P µ • °y± Q X® ý ¥P 3# ¹°, ® ý |P µ • ¶ °y± Q X® ý |P $# ¹°, ® ý |P µ • ¶ °y± Q X® ý |P $# ¹°9</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m">® fS yP µ • ¶ °y± Q X® §S µP T y $µ • ¶ °, ® fS yP µ • ¶ °y± Q X® fS yP 3# ß°, ® fS yP µ • °± Q X® fS yP 3# ß°, ® gS yP µ • °± Q ²® gS vP 3# ¹°1</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">¥°± Q ²® P ë ¥°for every control state and every ë èc ¶¤</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">the rules are almost the same as in the proof of Theorem 5.1, except for some changes in 3.,4.,5., and 11. The underlying function Ï of the constructed regular valuation assigns to F £nP ý 2U an automaton recognizing all strings of ¤ £B where the last symbol is §</title>
		<author>
			<persName><surname>Hence</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>and to all other pairs of the form F £nP TU an automaton recognizing the empty language</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bebop: A symbolic model checker for boolean programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN 00: SPIN Workshop</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1885</biblScope>
			<biblScope unit="page" from="113" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Reachability analysis of pushdown automata: Application to model checking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bouajjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CONCUR&apos;97</title>
		<meeting>CONCUR&apos;97</meeting>
		<imprint>
			<biblScope unit="volume">1243</biblScope>
			<biblScope unit="page" from="135" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Model checking the full modal mu-calculus for in£nite sequential processes</title>
		<author>
			<persName><forename type="first">O</forename><surname>Burkart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP&apos;97</title>
		<meeting>ICALP&apos;97</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1256</biblScope>
			<biblScope unit="page" from="419" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Temporal and modal logic</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Theoretical Comp. Sci., B</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Modalities for model checking: Branching time logic strikes back</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="275" to="306" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Ef£cient algorithms for model checking pushdown systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hansel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rossmanith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schwoon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAV&apos;00</title>
		<meeting>CAV&apos;00</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1855</biblScope>
			<biblScope unit="page" from="232" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An automata-theoretic approach to interprocedural data-¤ow analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Knoop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FoSSaCS&apos;99</title>
		<meeting>FoSSaCS&apos;99</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1578</biblScope>
			<biblScope unit="page" from="14" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A BDD-based model checker for recursive programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schwoon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAV&apos;01</title>
		<meeting>CAV&apos;01</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2102</biblScope>
			<biblScope unit="page" from="324" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A direct symbolic approach to model checking pushdown systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Finkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Willems</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Veri£cation of control ¤ow based security properties</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>Métayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Thorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="89" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The £xpoint-analysis machine</title>
		<author>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Claßen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Knoop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Margaria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CONCUR&apos;95</title>
		<meeting>CONCUR&apos;95</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">962</biblScope>
			<biblScope unit="page" from="72" to="87" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
