<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Simulator Independent Coverage for RTL Hardware Languages</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Vighnesh</forename><surname>Iyer</surname></persName>
							<email>vighnesh.iyer@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
							<idno type="ORCID">0000-0002-0533-2712</idno>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
							<email>laeufer@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Biancolin</surname></persName>
							<email>biancolin@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Borivoje</forename><surname>Nikoli?</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
							<email>ksen@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Simulator Independent Coverage for RTL Hardware Languages</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3582016.3582019</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:56+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>RTL</term>
					<term>FPGA</term>
					<term>FSM Coverage</term>
					<term>Line Coverage</term>
					<term>Toggle Coverage</term>
					<term>Hardware Compiler</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We demonstrate a new approach to implementing automated coverage metrics including line, toggle, and finite state machine coverage. Each metric is implemented through a compiler pass with a report generator. They are decoupled from the backend simulation, emulation, or formal verification tool through a simple API designed around a single new cover primitive. Our prototype for the Chisel hardware construction language demonstrates support across three software simulators, the FPGA-accelerated FireSim simulator and a formal tool. We demonstrate collecting line coverage while booting Linux with FireSim at a target frequency of 65 MHz. By construction, coverage can be trivially merged across backends.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS CONCEPTS</head><p>? Hardware ? Simulation and emulation; Coverage metrics.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Dynamic verification is the major workhorse for pre-silicon verification of digital circuit designs. As soon as the register transfer level (RTL) description of a circuit is written, it can be simulated with one of many open-source or commercial simulators. In order to simulate the environment in which the circuit is supposed to operate, designers write testbenches either in their design language or in a variety of unit testing frameworks like fault <ref type="bibr" target="#b27">[28]</ref>, cocotb <ref type="bibr" target="#b9">[10]</ref> or chiseltest <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b15">16]</ref>. Besides testing individual modules, dynamic verification is also used for system-level or integration tests in which a complete System on Chip (SoC) is simulated. Since the execution speed of software simulators degrades with larger designs, emulation or FPGA-accelerated simulation platforms are often used <ref type="bibr" target="#b12">[13]</ref>.</p><p>Dynamic verification is most effective when it has exercised the full functionality of the design. Coverage metrics <ref type="bibr" target="#b19">[20]</ref> are an approximation of the input stimuli' effectiveness in exercising the targeted design. Verification engineers craft stimuli to hit an increasing number of coverpoints in the design and thus gain confidence in the thoroughness of their test suite. We instead implement every coverage metric as a single instrumentation pass in the firrtl compiler and a simulatorindependent report generator. Only support for our proposed cover primitive needs to be added to a new simulator to take advantage of all our coverage metrics.</p><p>There are several issues with the status quo of coverage instrumentation and collection that we aim to address: <ref type="bibr" target="#b0">(1)</ref> Most open-source or innovative research simulators lack support for collecting and reporting automated coverage metrics <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b24">25]</ref>. <ref type="bibr" target="#b1">(2)</ref> For tools that do support these metrics, their custom implementation makes merging coverage across various software or FPGA-accelerated simulators and formal tools difficult. (3) New hardware languages generally lack support for sourcelevel coverage metrics. While we can get coverage metrics for the generated Verilog, there is no automated way to map the coverage results back to the original Chisel code.</p><p>In this paper, we present a new approach that relies on a compiler to lower common automated coverage metrics to a single cover primitive that can be easily implemented for a wide range of different simulators. Each metric is implemented as a compiler pass that generates only cover primitives in addition to synthesizable constructs which are already supported by all simulators. It also collects metadata that allows a report generator to map the coverage counts back to the high-level information, such as which lines were covered. The simulator implements the cover primitive as a counter which is incremented every time the input signal is true at a clock event and reports back the counts at the end of the simulation. A simulator-independent report generator then consumes the metadata from the compiler pass as well as the cover counts from the simulator and thus creates a user-readable report. Since the coverage counts reported by simulators are all in the same format, we can trivially merge results from different simulators before extracting the high-level coverage reports. Figure <ref type="figure" target="#fig_0">1</ref> provides an overview of our system.</p><p>We implemented our approach for the Chisel hardware construction language and the FIRRTL compiler <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b11">12]</ref>. Over a short period of time, we were able to implement line, toggle, and finite state machine coverage, thus exceeding the number of automated coverage metrics offered by any open-source RTL simulator today. For the coverage metrics that are natively supported by the open-source Verilator simulator, we found no slowdown for our simulator-independent solution. While the implementation of new coverage metrics can be challenging we found that adding support for new simulators was fairly simple. Besides Verilator, we also provide support for a FIRRTL simulator called treadle, for the ESSENT simulator <ref type="bibr" target="#b5">[6]</ref>, the FPGA-accelerated FireSim simulator <ref type="bibr" target="#b12">[13]</ref> as well as a formal tool for trace generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND 2.1 Coverage</head><p>Tests of RTL designs generally involve test stimuli that exercise the design as well as checks that catch when the design is behaving incorrectly, e.g., assertions or comparison of outputs to a golden model. In order to measure whether the inputs cover all interesting behaviors of the design, various coverage metrics have been proposed <ref type="bibr" target="#b19">[20]</ref>.</p><p>Simple structural or code coverage is based on the idea that if the designer writes a statement in the RTL language it has to serve a purpose and thus should be executed at least once. Toggle coverage follows a similar thought pattern: If a wire in the circuit is always stuck at one or zero, then either it should not be there or the design has not been thoroughly tested.</p><p>In order to gain insight into more high-level design functionality engineers often manually annotate functional coverage that describes the different scenarios that a circuit was designed for, e.g., one wants to see a processor pipeline resolve a read-after-write hazard. While most functional coverpoints are user-defined, some can also be automatically generated through knowledge of the design patterns that RTL engineers use. The prime example of this is the finite state machine (FSM) coverage for which a simulator extracts all states and possible transitions and counts how often each is covered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Hardware Construction Languages</head><p>With ever-increasing SoC complexity, many designers aim to write RTL generators that can be extensively parameterized and therefore reused. A prime example of this is the RocketChip SoC generator which essentially takes in a list of devices to instantiate (e.g. cores, peripherals, accelerators) and automatically creates device and interconnect RTL <ref type="bibr" target="#b3">[4]</ref>.</p><p>Hardware construction languages (HCLs) implement the generator concept in a general-purpose programming language such as Scala <ref type="bibr" target="#b4">[5]</ref> or Python <ref type="bibr" target="#b26">[27,</ref><ref type="bibr">29]</ref>. They provide RTL primitives as a library of objects and allow the designer to write Scala or Python programs that connect the RTL constructs into a final design.</p><p>The main contrast to previous approaches of generating, e.g., Verilog from a Perl script is that the RTL constructs are not just strings, but native objects in the host language, leading to better type safety and maintainability. Many HCLs are designed to make non-parameterized circuits look as if they were written in a regular hardware description language. Chisel, for example, provides a when branch construct and assignment operators that work similarly to non-blocking assignments in Verilog.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">RTL Intermediate Representations</head><p>Many of the new hardware construction languages define an intermediate representation (IR) that is used to lower higher-level language constructs to structural Verilog <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr">29]</ref>. Besides translating the custom constructs to a small subset of structural Verilog that is compatible with commercial and open-source backend tools, the compiler infrastructure can also be used to add additional features to the circuit.</p><p>In this paper, we write FIRRTL compiler passes to instrument the IR with automated coverage metrics. There has been recent work on new open-source compilers and intermediate representations for high-level synthesis <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24]</ref>, as well as for established industry languages like Verilog <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b29">31]</ref>, and the circt project which tries to be a unifying compiler framework for hardware construction <ref type="bibr" target="#b7">[8]</ref>. Most of these compilers also emit structural Verilog which can then be simulated. Our approach to automated coverage and the simulator interface we propose is also applicable to these new languages and frameworks. constructs that are mostly used for testing. While all of these features can be very convenient for testing circuits, they come with high implementation complexity. So far there is not a single opensource simulator for SystemVerilog that is fully standard compliant <ref type="foot" target="#foot_1">1</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Lowering to Structural Verilog</head><p>Most new hardware construction languages thus try to emit much simpler, structural Verilog that can be understood by a wide range of tools. More complex features are instead integrated into the frontend language and lowered by the compiler into simpler Verilog features that result in the same behavior. The common subset that is generally well supported by a wide range of tools is the synthesizable subset of the Verilog standard <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Automated Coverage on the Structural Verilog</head><p>Since new hardware construction and high-level synthesis (HLS) languages generate structural Verilog in order to target existing backend tools, one may think that the easiest way to get automated coverage would be to just use the coverage collection flags that are already built into the existing Verilog simulators. However, automated coverage generally relies on patterns in the code that are written by the designer. For example, if we create a mux with a branch statement (if in Verilog, when in Chisel), the condition will be taken into account when calculating line or branch coverage. However, if we create a mux through a conditional assignment or through an explicit exclusive-or gate it does not show up in the line coverage report. Figure <ref type="figure">3</ref> shows an example where a branch in Chisel gets lowered into a conditional assignment by the FIRRTL compiler in order to simplify the structural Verilog generation. This is perfectly valid, as it preserves the semantics of the original Chisel code<ref type="foot" target="#foot_2">2</ref> , however, it means that achieving 100% line coverage on the generated Verilog may not always result in complete line coverage for the original code written by the designer.</p><p>Another example is finite state machine (FSM) coverage: While the pattern, which designers use for FSMs, is clear in the original Chisel, it is not recognized by Verilog simulators that only have access to the generated structural Verilog.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chisel to structural Verilog when(in) {</head><p>out := 1.U } .otherwise { out := 2.U } assign out = in ? 2'h1 : 2'h2 ;</p><p>Figure <ref type="figure">3</ref>: In this example, the translation to structural Verilog replaces a branch with a conditional assignment. Therefore, 100% line coverage on the generated Verilog does not necessarily imply complete line coverage of the Chisel source.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SIMULATOR INDEPENDENT COVERAGE INTERFACE</head><p>A typical Chisel testing flow can involve different simulators, depending on the desired start-up speed, throughput, and debugging features. In order to support coverage on all of them, we developed a simple interface that takes advantage of existing coverage features in Verilog simulators and can easily be implemented for the five very different verification tools that we worked with. All our simulators support simulating any synchronous RTL circuit that can be generated from Chisel. The one IR primitive we add is a cover statement which samples a signal on the rising edge of a clock and increments a counter if and only if the covered signal is true. Each cover statement also carries a name that uniquely identifies it inside the module that it is declared in. This way simulators can report coverage results as a simple map from the name of the cover statement (including its path in the module instance hierarchy) to a non-negative integer that represents the count. Different simulators may use counters with different bit-widths as long as the count is saturating. This allows important optimizations in FPGA-accelerated simulators. We implemented support for the cover statement in five different backends.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Treadle</head><p>Treadle <ref type="bibr" target="#b17">[18]</ref> is a Java Virtual Machine based simulator for circuits represented in the FIRRTL IR. While it does not achieve the simulation speeds possible with a compilation-based approach, it features quick spin-up times and integrates well into the Scala-based Chisel ecosystem, and is thus the preferred simulator for shorter simulation runs and smaller-to medium-sized designs. Adding support for the cover statement took less than one work week and around 200 lines of Scala code. Treadle had existing support for a stop statement which also samples a condition at a positive edge. This code was easy to adapt for the cover statement -we just needed to increment a counter when the condition is true instead of stopping the simulation. At the end of the simulation run, all counts are transferred into a map from a cover point name to a count.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Verilator</head><p>Verilator <ref type="bibr" target="#b24">[25]</ref> is a popular open-source Verilog simulator. It analyzes and optimizes the input Verilog and generates C++ source code for a simulation which is then compiled to a binary with a standard C++ compiler. This approach generally leads to higher simulation speeds, but it does increase the time spent building the simulation, which is why it lends itself to longer simulation runs where the startup cost can be amortized. In order to simulate a Chisel design, it needs to be compiled into structural Verilog which will then be turned into a simulation by Verilator. Our cover statement can be mapped to a concurrent or an immediate assertion in the Verilog generated by the FIRRTL compiler as shown in Figure <ref type="figure">2</ref>. By default, we generate immediate cover statements <ref type="bibr" target="#b1">[2]</ref> as those are the only form supported by the open-source Yosys <ref type="bibr" target="#b29">[31]</ref> synthesis tool covered in Section 3.4.</p><p>This way we make use of the built-in support for user-defined coverage in Verilator. We do not re-use any of the Verilog line or toggle coverage provided by Verilator. At the end of the simulation run, Verilator generates a coverage data file that contains the counts associated with each SystemVerilog cover statement. We also implemented a converter that parses the custom coverage format used by Verilator and re-associates the counts with the cover statements in the FIRRTL source. Our interface code thus generates the exact same map from cover statement names to counts as provided by our native implementation for Treadle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">FireSim</head><p>FireSim <ref type="bibr" target="#b12">[13]</ref> is an open-source, cycle-accurate FPGA-accelerated RTL simulator, which at its core, uses a custom compiler based on FIRRTL <ref type="bibr" target="#b16">[17]</ref> to decouple the clock of the simulated RTL from the FPGA clock. This allows for deterministic, cycle-accurate composition with software simulations of components like network switches, as well as FPGA-optimized multi-cycle simulation models, e.g., of multi-ported register files or DRAM models with realistic access latencies. While FireSim's compiler supports some conventionally nonsynthesizable debug primitives, like assertions and prints, it currently has no means to implement cover statements, which cannot directly be mapped onto an FPGA. We added a new compiler pass to FireSim which replaces each cover statement with a saturating counter that is then connected to a per-clock-domain scan chain (Figure <ref type="figure" target="#fig_1">4</ref>). The bit-width of the counter is a parameter set by the user in order to trade off FPGA resources and cover count accuracy. The pass also generates a list with the names of all cover statements in the order in which they are connected throughout the scan chain. The scan chain is controlled by an FPGA-hosted simulation module and C++ driver program which can pause the simulation, freezing all coverage counts, and then clock out all coverage counts. Using the metadata generated by the newly added coverage scan-chain insertion pass for FireSim, we can then map the counts to the cover statement names. We thus get the exact same coverage information </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Formal Verification with SymbiYosys</head><p>The most common use of formal verification tools is to verify assertions. The tool will either find a series of inputs that lead to an assertion violation or come up with a proof that the assertion can never be violated. In addition to that, the open-source SymbiYosys tool (like many commercial tools) also supports coverage trace generation <ref type="bibr" target="#b28">[30]</ref>. Given a design annotated with cover points, it will try to find sequences of inputs that will lead to each of the cover points.</p><p>Since we already emit our cover primitive as a standard immediate assertion for the Verilator simulator, the same generated Verilog can be used by SymbiYosys to automatically find inputs that will maximize any of our automated coverage metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">ESSENT</head><p>ESSENT is a high-performance simulator prototype <ref type="bibr" target="#b5">[6]</ref> with little debugging support. In order to gain a sense of how hard it would be to add support for a fifth tool, after the basic idea had been validated with the other four backends, we recorded the time spent. Overall, it took us around 5 hours and 60 lines of code to add support for our cover primitive and thus allow ESSENT users to make use of all our coverage metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">COVERAGE INSTRUMENTATION AND REPORT GENERATORS</head><p>In this section, we describe how we implemented a number of automated coverage metrics. Our methodology relies on the assumption that most automated coverage metrics can be implemented using the cover statement introduced in Section 3. To demonstrate this, we implemented line coverage, toggle coverage, and FSM coverage as well as a custom Ready/Valid coverage metric. Each metric is implemented as an instrumentation pass that analyzes the circuit represented in the FIRRTL IR, adds cover statements and emits metadata as well as a report generator that consumes the simulator output and turns it into a high-level coverage report. To provide a sense of implementation complexity, Table <ref type="table" target="#tab_1">1</ref> contains an overview of all coverage metrics implemented for this paper, along with the number of lines of Scala code for the associated instrumentation and report generator. All our report generators are bare-bones and generate simple ASCII reports only. There are many potential improvements that could be made in order to generate interactive HTML reports, or similar, which would significantly increase the amount of code in the report generators.</p><p>coverage counts remember mapping </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Coverage Report</head><p>Figure <ref type="figure">5</ref>: The line coverage pass instruments every when statement in the FIRRTL circuit. The mapping from lines to branches is used to generate the coverage report from the counts reported by the simulator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Branch and Line Coverage</head><p>Branch coverage counts how often a branch is taken in the HDL or HCL source code. From this information line and statement coverage can be derived by counting the number of lines or statements that are executed when a particular branch is taken. In order to implement a branch coverage instrumentation pass we rely on the fact that the FIRRTL compiler automatically turns the dominating branch condition of a statement into an enable signal for the statement. This is done during lowering to structural RTL as shown in Figure <ref type="figure">2</ref>. Thus we place our instrumentation pass before that lowering happens and just add a cover statement right after every branch. This is shown in Figure <ref type="figure">5</ref>.</p><p>In order to turn the branch coverage information into actual line coverage, additional information is needed. We scan all statements that are directly inside a given branch and extract their line numbers and source file information. Thus we build up a map from a cover point to the lines that are covered by it. After the simulation finishes, the map is used by our report generator to turn coverage counts from the simulator into a textual report that annotates the Scala source file with counts of how often each line was executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Toggle Coverage</head><p>We implemented our toggle coverage as a compiler pass that runs on the structural RTL after optimizations such as constant propagation and dead code elimination have been performed. We distinguish between I/O signals, registers, memories, and wires and allow the user to choose which category they want to instrument. For every selected signal, we add a register in order to record its value in the previous clock cycle. A xor gate allows us to detect whether a bit in the signal changed. Counting rising and falling edges, i.e., toggles from zero to one or one to zero, separately would be a simple extension that would use two instead of one cover statement per bit. We also add a register that is zero in the first cycle of the simulation and one after in order to disable all toggle cover statements during the first cycle when the previous value has not been updated yet.</p><p>We implemented a global alias analysis which analyzes the design hierarchy and reports groups of signals that are guaranteed to always carry the same value. For example, in Figure <ref type="figure" target="#fig_2">6</ref> the "signal" wire in the top module always carries the same value as the "in" ports of the two child modules. The alias information is used by our toggle coverage pass to only instrument a single signal from each alias group. An important example is the global reset signal, which only gets instrumented once in the top-level module instead of once in every module in the hierarchy. The global alias analysis pass is necessary to make toggle coverage perform well.  (2) add cover statements (simplified example) enum annotation for S: A=0, B=1, C =2  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Finite State Machine Coverage</head><p>Finite State Machines (FSMs) are commonly used to implement the controls for RTL modules. In modern Chisel, designers generally create a ChiselEnum that contains all the states and a state register of their custom enum type. To implement our instrumentation pass, we take full advantage of the annotation system which allows Chisel libraries, like the ChiselEnum library, to annotate circuit elements in Scala. We use the annotation to find registers that contain values from a ChiselEnum. The annotation also tells us all legal states that were defined as part of the enum. Figure <ref type="figure" target="#fig_4">7</ref> shows an example where the enum S contains the three possible values A, B, and C.</p><p>With this information, we analyze the next expression of the register. In our example, there are four cases that we need to analyze: One case when the system is in reset, and one case for each possible state. In each case, we apply constant propagation, replacing the reset and state symbols with their assignments. Thus we collect all possible next-state assignments and derive all possible transitions. In cases where -after simplification -we end up with an expression that is not a constant or a mux, we over-approximate, assuming all states are possible next states. Thus our analysis is conservative in that it will only over-report possible transitions and never miss any transitions. One example where our analysis fails is an FSM in RocketChip <ref type="bibr" target="#b3">[4]</ref> where the next state signal goes through a submodule that is invisible to our (module scoped) analysis. After analyzing the possible transitions, we add cover points for every state and transition in a second step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Ready/Valid Coverage</head><p>One of the most commonly used interfaces from the Chisel standard library is a DecoupledIO bundle. A data transfer happens during cycles in which the ready and valid wires are both asserted. We developed a custom coverage pass that analyzes the ports of all modules in the design and adds a cover statement for every decoupled interface it finds in order to count how often data is transferred. Thanks to all the code we had previously developed, we were able to implement and test this new coverage metric in around 3h. This shows how new metrics that may be specific to a design ecosystem can easily be added by using our simulator-independent approach. Traditionally RTL designers might have manually added cover statements as part of the functional coverage, however, our pass is more economical since it works across a wide range of designs using DecoupledIO without manual annotations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EVALUATION</head><p>Prior sections already discussed how our approach allowed us to quickly implement four different coverage metrics for five different backends. In this section, we investigate the run time and/or area overhead of our simulator-independent coverage solution. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Software Simulator Coverage Overhead</head><p>Making use of generic cover statements instead of hard-coding line coverage into the simulator allows us to support new simulators with little effort. However, one might suspect that using a more generic coverage collection mechanism compared to built-in line coverage might create additional overheads. We measure the overhead of our coverage metrics on simulation speed and compare it to the built-in Verilog coverage of the open-source Verilator simulator. Our benchmarks come from various open-source projects written in Chisel. Table <ref type="table" target="#tab_4">2</ref> provides an overview. We picked long-running tests, recorded a waveform VCD and then generated a minimal testbench that only replays the top-level inputs from the VCD. This way we can isolate the simulator run time from the time it takes to generate stimuli and any overhead in the verification environment. This careful isolation means that the reported overhead may be less noticeable in practice <ref type="foot" target="#foot_3">3</ref> .</p><p>Figure <ref type="figure" target="#fig_5">8</ref> shows the run time overhead of various coverage instrumentation over the baseline. We find that in general, our instrumentation causes the same or slightly less overhead compared to Verilator's built-in coverage. This can be attributed to the fact that Verilator appears to internally follow an approach similar to ours.</p><p>While we are prohibited from reporting data for commercial simulators in a meaningful way, we observed that our generic approach does negatively impact the performance of event-driven simulators. However, Verilator with our coverage is generally significantly faster than any commercial tool with its native coverage. By providing extensive coverage support for open-source simulators, we remove one of the common reasons that prevent users from switching to faster simulators like Verilator. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">FireSim Coverage Overhead</head><p>We applied our line coverage instrumentation to two different SoC designs from the Chipyard framework <ref type="bibr" target="#b2">[3]</ref>. The first includes four, in-order scalar Rocket <ref type="bibr" target="#b3">[4]</ref> cores and the second uses a single outof-order BOOM <ref type="bibr" target="#b31">[33]</ref> core. This results in 8060 cover statements in the RocketChip design and 12059 cover statements for the BOOM SoC. We then ran our scan chain insertion pass and transformed the designs into a cycle-accurate FPGA-accelerated simulation with FireSim <ref type="bibr" target="#b12">[13]</ref>. Both simulators target a Xilinx Ultrascale+ VU9P device, the FPGA supplied by Amazon EC2 F1 instances, and were compiled using Xilinx Vivado 2018.3. Figure <ref type="figure">9</ref> shows the resource usage for different counter sizes and compares them to a baseline without any coverage instrumentation. We include numbers for up to 48 bit of resolution which would be sufficient to prevent counter-saturation in practically all applications. Wide coverage counters lead to significant increases in resource usage, but as long as we are only interested in finding lines that have never been covered, small counters offer minimal area overhead. Figure <ref type="figure" target="#fig_6">10</ref> illustrates the ? ??? scaling trends versus increasing counter widths. For counter widths up to 8 bit for the Rocket and 2 bit for the BOOM-based design, the overhead from our coverage support falls within the noise introduced by differing placements.</p><p>We used our instrumented SoCs with 16 bit coverage counters to boot Linux and obtain line coverage results. For the RocketChip design the simulation executed 3.3 B cycles in 50.4 s (65 MHz). Scanning out the 8060 cover counts at the end of the simulation took 12 ms. For the BOOM design the simulation executed 1.7 B cycles in 42.6 s (40 MHz). Scanning out the 12059 cover counts at the end of the simulation took 17 ms. In the future, we might be able to trade off simulation time and FPGA resource usage by using smaller counters that are sampled more frequently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Coverage Merging and Removal</head><p>Adding full line coverage to a large SoC design can have a significant area impact if we want to obtain high-resolution coverage counts. Also, note that mapping a FireSim simulation to the FPGA can take multiple hours. We can take advantage of the fact that we use the same coverage instrumentation for both FPGA and software-based simulation to filter out coverage points already caught in software simulation.</p><p>After merging the coverage results from running a RISC-V test suite with Verilator, we were able to reduce the number of coverage counters by 42 % by excluding the ones that were covered at least 10 times by the tests. As shown in Figure <ref type="figure">9</ref>, resource consumption is dominated by coverage hardware for wide counters, with LUT utilization increasing by 2.8? in the 32 bit case. Once redundant points are removed, this falls to 2.0?, a tremendous saving that could be further improved with a more comprehensive suite of initial tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Coverage as Fuzzing Feedback</head><p>We demonstrate how our approach to coverage can be useful -not only for human developers -but also as automated feedback in a fuzz testing setup. Mutational coverage-directed fuzz testing has recently been applied to RTL designs <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b25">26]</ref>. However, it is still unclear which feedback metric should be used to drive the input generation. In the past, it has been difficult to switch feedback metrics since they are tied to a particular simulator. However, with the cover statement-based approach suggested in this paper, any metric that we implemented an instrumentation pass for can be used. To demonstrate, we created a simple fuzzing setup, connecting the AFL fuzzer <ref type="bibr" target="#b30">[32]</ref> to a rfuzz-style harness <ref type="bibr" target="#b14">[15]</ref> using the RTL Fuzz Lab infrastructure <ref type="bibr" target="#b8">[9]</ref>. The coverage counts serve as direct feedback to AFL instead of going to a report generator. This way, we can mix and match various metrics easily. We implemented the mux toggle coverage metric from rfuzz in our framework and compared it to using our line coverage as feedback when fuzzing an I2C peripheral. Figure <ref type="figure" target="#fig_7">11</ref> shows cumulative line coverage for different feedback metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Formal Trace Generation</head><p>As explained in Section 3.4 we can use our automated coverage instrumentation together with a formal tool to automatically generate traces that exercise our cover statements. We instrumented the open-source RISC-V Mini processor core and used bounded model checking to find cover points that cannot be reached in 40 cycles. RISC-V Mini was not a design that we were previously familiar with. Using formal trace generation with our line coverage instrumentation, we discovered that the RTL for the instruction and data caches are the same, but the instruction cache is read-only, and thus, the code blocks for write accesses are never exercised. When we used finite state machine coverage, we discovered a bug in our FSM analysis pass that resulted in an overestimate of transitions in the FSM. Formal verification revealed that these transitions could never be covered.</p><p>Thus by moving the coverage instrumentation out of the simulator and into the FIRRTL compiler we are able to expand it to new use cases, such as automated coverage generation with a simple formal tool. This allows designers to explore their design easily and can also be very convenient for finding bugs in coverage instrumentation passes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">LIMITATIONS</head><p>We show that the most common types of coverage can be represented using synthesizable constructs and a cover statement. However, while working on this project, we uncovered one limitation which we would like to share: In the special case where we have a large number of events that we know are mutually exclusive, i.e., only one of them can occur in any given cycle, the use of multiple cover statements is sub-optimal since we cannot exploit the fact that only one of the counters will need to be incremented each cycle. A good example is that we might like to count how often a signal's value falls into certain cover bins. Implementing these cases efficiently requires a new cover-values primitive which counts how often a signal takes on each possible value. cover-values can be implemented in software by indexing into an array of counters or using a block RAM on the FPGA. This optimization becomes important when we want to cover a wide range of values, like in some fuzz testing applications <ref type="bibr" target="#b10">[11]</ref>. Figure <ref type="figure" target="#fig_9">12</ref> demonstrates the exponential blowup when trying to use our cover statement and sketches efficient software and hardware implementations of cover-values inspired by prior work <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>Modern hardware verification flows rely on a variety of different simulators, emulators, and formal verification tools. In this paper,  we demonstrate how a compiler-centered approach that lowers automated coverage metrics to a single primitive allows for uniform coverage support across backends. Adding support to a new simulator can be done in as little as a single day of work and -by design -every coverage metric will be available from the start. We demonstrate coverage support for the Verilator and ESSENT simulators which are significantly faster than many commercial tools <ref type="bibr" target="#b24">[25]</ref> as well as the FPGA accelerated FireSim simulator which simulates a four-core SoC at 65 MHz effective target frequency, while commercial emulators are generally known to be significantly slower.</p><p>Besides broad support for all coverage metrics, our technique enables features that would be difficult to support with a monolithic design where every coverage metric is hard-coded into the simulator: We are able to use a formal tool to generate coverage traces for all automatic metrics, including custom user-defined metrics like our ready/valid coverage. We can use coverage from a software simulation of a design to remove easily reachable cover points before instrumenting an FPGA-accelerated simulation with coverage counters. We are able to re-use any combination of our automated metrics to serve as feedback to a fuzzer for automated input generation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Traditionally, automated coverage collection is part of a monolithic simulator. Users are limited to the coverage metrics that the simulator authors have chosen to provide.We instead implement every coverage metric as a single instrumentation pass in the firrtl compiler and a simulatorindependent report generator. Only support for our proposed cover primitive needs to be added to a new simulator to take advantage of all our coverage metrics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: We generate saturating counters and a scan chain for all cover statements for FPGA-accelerated simulation with FireSim.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The toggle coverage pass adds a register and a xor gate. It avoids redundant instrumentation for signals that always have the same value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>object S ? { val A, B, C = Value } val state = RegInit(S.A) switch(state) { is(S.A) { state := Mux(in, S.A, S.B) } is(S.B) { when(in) { state := S.B } .otherwise { state := S.C } } } node n0 = mux(in, UInt(1), UInt(2)) node n1 = mux(eq(UInt(1), state), n0, state) node n2 = mux(in, UInt(0), UInt(1)) node n3 = mux(eq(UInt(0), state), n2, n1) state &lt;= mux(reset, UInt(0), n3) input Chisel circuit lowered Firrtl (simplified) Start (reset = 1): UInt(0) ? A A (state = 0 &amp;&amp; reset = 0): mux(in, UInt(0), UInt(1)) ? {A, B} B (state = 1 &amp;&amp; reset = 0): mux(in, UInt(1), UInt(2)) ? {B, C} C (state = 2 &amp;&amp; reset = 0): state ? UInt(2) ? {C}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Finite state machine (FSM) coverage assumes that the state register uses a We first analyze all possible next states by simplifying the state update expression for each possible current state. We then add cover statements for all states and possible transitions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Coverage instrumentation overhead on Verilator v4.034. For TLRAM, the measured overhead of our FIRRTL line coverage is close to zero.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: FireSim simulator ? ??? versus counter width. A bit width of zero represents the baseline with no coverage support. Note, the 48 bit BOOM configuration did not place due to resource limitations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Cumulative line coverage of inputs discovered through fuzzing with various feedback metrics. Averaged over five runs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>C++ simulation (simplified) Read lowering to cover (? exponential blowup ?) direct lowering to a C++ simulation direct lowering to hardware (e.g., for FireSim) -sketch UInt&lt;4&gt; cover-values(clk, signal, enabled) cover(clk, eq(signal, UInt( 0)), enabled) cover(clk, eq(signal, UInt( 1)), enabled) ; 2 ... 14 omitted cover(clk, eq(signal, UInt(15)), enabled) if(enabled &amp;&amp; signal == 0) cnt_0 += 1; if(enabled &amp;&amp; signal == 1) cnt_1 += 1; // 2 ... 14 omitted if(enabled &amp;&amp; signal == 15) cnt_15 += 1; if(enabled) cnt[signal] += 1;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Covering all signal values with the cover statement leads to an exponential blowup. A cover-values statement could be lowered directly to significantly more efficient software and hardware implementations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Lines of code (LoC) for coverage passes and report generators. Lines of new library code in parenthesis.</figDesc><table><row><cell cols="3">LoC Instrum. LoC Report</cell></row><row><cell>Common Library</cell><cell>106</cell><cell>290</cell></row><row><cell>Line Coverage</cell><cell>89</cell><cell>64</cell></row><row><cell>Toggle Coverage</cell><cell>279 (+131)</cell><cell>51+</cell></row><row><cell>FSM Coverage</cell><cell>144 (+228)</cell><cell>34</cell></row><row><cell>Ready/Valid Coverage</cell><cell>78</cell><cell>26</cell></row><row><cell cols="3">from the FPGA-accelerated simulation as provided by the software</cell></row><row><cell>simulators Treadle and Verilator.</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Software simulation benchmarks and the number cover points generated by the line and toggle coverage instrumentation passes.</figDesc><table><row><cell cols="5">Design Cycles Executed Run Time # Line # Toggle</cell></row><row><cell>riscv-mini [14]</cell><cell>126,550</cell><cell>3.34 s</cell><cell>157</cell><cell>4,042</cell></row><row><cell>TLRAM [4]</cell><cell>816,473</cell><cell>1.45 s</cell><cell>8</cell><cell>2,532</cell></row><row><cell>serv-chisel</cell><cell>828,931</cell><cell>1.05 s</cell><cell>79</cell><cell>725</cell></row><row><cell>NeuroProc [21]</cell><cell>53,455,204</cell><cell>40.38 s</cell><cell>809</cell><cell>4,786</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>The results of a SystemVerilog compliance test for many open-source tools can be found at https://symbiflow.github.io/sv-tests-results</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>In Verilog, changing a branch into a conditional assignment changes the semantics of the code due to X-propagation. In Chisel, there is no X-propagation, and thus the semantics are preserved.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>Chisel testbenches normally slow down the simulation by 2x-1000x. Industry insiders tell us that well-optimized commercial SystemVerilog testbenches often present a 50% overhead leading to a 2x slowdown compared to raw simulation speed. Thus the raw simulation overhead that we measured will be less noticeable with a real testbench.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We would like to express our gratitude to several members of the Chisel and greater hardware open-source community: <rs type="person">Deborah Soung</rs> helped us understand how Chisel coverage is obtained in a commercial setting. <rs type="person">Chick Markley</rs> was instrumental in adding cover support to the treadle simulator. Tom Alcorn originally suggested adding a cover statement to FIRRTL which ultimately lead us to the idea behind this paper. <rs type="person">Wilson Snyder</rs> wrote the patch to add a "per-instance" coverage feature to Verilator.</p></div>
			</div>			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by Semiconductor Research Corporation, by NSF grants CCF-1900968, CCF-1908870, and CNS-1817122 and by SLICE Lab industrial sponsors and affiliates Amazon, Apple, Google, Intel, Qualcomm, and Western Digital, as well as by SKY lab industrial sponsors and affiliates Astronomer, Google, IBM, Intel, Lacework, Microsoft, Mohamed Bin Zayed University of Artificial Intelligence, Nexla, Samsung SDS, Uber, and VMware. Any opinions, findings, conclusions, or recommendations in this paper are solely those of the authors and do not necessarily reflect the position or the policy of the sponsors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A ARTIFACT APPENDIX A.1 Abstract</head><p>Our artifact includes the implementation of our coverage passes and report generators, our modifications to FireSim as well as a simple circuit fuzzer. Most results from our paper can be reproduced on a standard x86 Linux computer, however, for the FireSim performance and area/frequency results, a more complicated setup on AWS cloud FPGAs is necessary.</p><p>A.2 Artifact check-list (meta-information) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Installation</head><p>Please follow the instructions in the Readme.md provided as part of the artifact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.5 Evaluation and expected results</head><p>The artifact contains scripts to reproduce the following:</p><p>? Benchmark statistics in Table <ref type="table">2</ref> (local, 20min)</p><p>? Verilator overhead in Figure <ref type="figure">8</ref> (local, 2h)</p><p>? Fuzzing coverage over time in Figure <ref type="figure">11</ref> (local, 2h)</p><p>? FireSim resource overhead in Figure <ref type="figure">9</ref> and 10 (AWS, 5h) ? Section 5.2 Linux boot times for RocketChip (AWS, 10min)</p><p>The Readme.md provided with the artifact contains detailed instructions on how to reproduce each item.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.6 Experiment customization</head><p>New coverage passes can be added by extending the Scala SBT project in the coverage folder. The provided passes and report generators can serve as a starting point.</p><p>New circuits and testbenches to measure overhead on Verilator can be added by modifying the Makefile in the benchmarks folder and copying over the FIRRTL circuit and a C++ testbench.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.7 Note</head><p>The support for the cover statement is part of upstream Treadle since v1.5.0: https://github.com/chipsalliance/treadle</p><p>The code to interface with Verilator and convert its custom coverage format into our standard map from cover statement name to count is part of upstream ChiselTest since v0.5.0: https://github. com/ucb-bar/chiseltest Our artifact depends on binary JARs of both Treadle and Chisel-Test from the Maven package repository.</p><p>Experimental support for cover statements in ESSENT can be found on a public fork: https://github.com/ekiwi/essent/tree/coverage A.8 Methodology Submission, reviewing and badging methodology.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">IEC/IEEE International Standard -Verilog(R) Register Transfer Level Synthesis</title>
	</analytic>
	<monogr>
		<title level="j">IEEE/IEC</title>
		<imprint>
			<biblScope unit="page">62142</biblScope>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">IEEE Standard for SystemVerilog -Unified Hardware Design, Specification, and Verification Language</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Std</title>
		<imprint>
			<biblScope unit="page">1800</biblScope>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Chipyard: Integrated Design, Simulation, and Implementation Framework for Custom SoCs</title>
		<author>
			<persName><forename type="first">Alon</forename><surname>Amid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Biancolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Grubb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sagar</forename><surname>Karandikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harrison</forename><surname>Liew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Magyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Ou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Pemberton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Rigge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerry</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yakun</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Sophia</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Borivoje</forename><surname>Nikoli?</surname></persName>
		</author>
		<idno type="DOI">10.1109/mm.2020.2996616</idno>
		<ptr target="https://doi.org/10.1109/mm.2020.2996616" />
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The Rocket Chip Generator</title>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rimas</forename><surname>Avi?ienis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Biancolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Celio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Palmer</forename><surname>Dabbelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sagar</forename><surname>Karandikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donggyu</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunsup</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Love</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Magyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miquel</forename><surname>Moreto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Ou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Twigg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huy</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Waterman</surname></persName>
		</author>
		<idno>UCB/EECS-2016-17</idno>
		<ptr target="http://www.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-17.html" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Chisel: Constructing Hardware in a Scala Embedded Language</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huy</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunsup</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rimas</forename><surname>Avi?ienis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Wawrzynek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovi?</surname></persName>
		</author>
		<idno type="DOI">10.1145/2228360.2228584</idno>
		<ptr target="https://doi.org/10.1145/2228360.2228584" />
	</analytic>
	<monogr>
		<title level="m">DAC Design Automation Conference</title>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficiently Exploiting Low Activity Factors to Accelerate RTL Simulation</title>
		<author>
			<persName><forename type="first">Scott</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Donofrio</surname></persName>
		</author>
		<idno type="DOI">10.1109/DAC18072.2020.9218632</idno>
		<ptr target="https://doi.org/10.1109/DAC18072.2020.9218632" />
	</analytic>
	<monogr>
		<title level="m">57th ACM/IEEE Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Verification of Chisel Hardware Designs with ChiselVerify</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Dobis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Hans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tjark</forename><surname>Damsgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kasper</forename><surname>Petersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enrico</forename><surname>Juul Hesse Rasmussen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Tolotto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Thye Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><surname>Schoeberl</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.micpro.2022.104737</idno>
		<ptr target="https://doi.org/10.1016/j.micpro.2022.104737" />
	</analytic>
	<monogr>
		<title level="j">Microprocessors and Microsystems</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<date type="published" when="2023">2023. 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">MLIR as Hardware Compiler Infrastructure</title>
		<author>
			<persName><forename type="first">Schuyler</forename><surname>Eldridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prithayan</forename><surname>Barua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aliaksei</forename><surname>Chapyzhenka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Leontiev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Schuiki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ram</forename><surname>Sunder</surname></persName>
		</author>
		<ptr target="https://woset-workshop.github.io/WOSET2021.html#article-6" />
	</analytic>
	<monogr>
		<title level="m">Workshop on Open-Source EDA Technology (WOSET)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">RTLFUZZLAB: Building A Modular Open-Source Hardware Fuzzing Framework</title>
		<author>
			<persName><forename type="first">Brandon</forename><surname>Fajardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<ptr target="https://woset-workshop.github.io/WOSET2021.html#article-10" />
	</analytic>
	<monogr>
		<title level="m">Workshop on Open-Source EDA Technology (WOSET)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Chris</forename><surname>Higgs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Hodgson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Wieser</surname></persName>
		</author>
		<ptr target="https://github.com/cocotb/cocotb" />
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">DIFUZZRTL: Differential Fuzz Testing to Find CPU Bugs</title>
		<author>
			<persName><forename type="first">Jaewon</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suhwan</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongup</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eunjin</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jangwoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<idno type="DOI">10.1109/SP40001.2021.00103</idno>
		<ptr target="https://doi.org/10.1109/SP40001.2021.00103" />
	</analytic>
	<monogr>
		<title level="m">2021 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Reusability is FIRRTL Ground: Hardware Construction Languages, Compiler Frameworks, and Transformations</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angie</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Magyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donggyu</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chick</forename><surname>Markley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Lawson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICCAD.2017.8203780</idno>
		<ptr target="https://doi.org/10.1109/ICCAD.2017.8203780" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Computer-Aided Design (ICCAD &apos;17</title>
		<meeting>the 36th International Conference on Computer-Aided Design (ICCAD &apos;17</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">FireSim: FPGA-Accelerated Cycle-Exact Scale-Out System Simulation in the Public Cloud</title>
		<author>
			<persName><forename type="first">Sagar</forename><surname>Karandikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donggyu</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Biancolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><surname>Amid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dayeol</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Pemberton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emmanuel</forename><surname>Amaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qijing</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyle</forename><surname>Kovacs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Borivoje</forename><surname>Nikoli?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Randy</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovi?</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISCA.2018.00014</idno>
		<ptr target="https://doi.org/10.1109/ISCA.2018.00014" />
	</analytic>
	<monogr>
		<title level="m">2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">Donggyu</forename><surname>Kim</surname></persName>
		</author>
		<ptr target="https://github.com/ucb-bar/riscv-mini" />
		<title level="m">risc-v mini</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">RFUZZ: Coverage-Directed Fuzz Testing of RTL on FPGAs</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donggyu</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<idno type="DOI">10.1145/3240765.3240842</idno>
		<ptr target="https://doi.org/10.1145/3240765.3240842" />
	</analytic>
	<monogr>
		<title level="m">2018 IEEE/ACM International Conference on Computer-Aided Design (ICCAD&apos;18)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Richard</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
		</author>
		<ptr target="https://github.com/ucb-bar/chiseltest" />
		<imprint>
			<date type="published" when="2018">2018 -2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Golden Gate: Bridging The Resource-Efficiency Gap Between ASICs and FPGA Prototypes</title>
		<author>
			<persName><forename type="first">Albert</forename><surname>Magyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Biancolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjit</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovi?</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICCAD45719.2019.8942087</idno>
		<ptr target="https://doi.org/10.1109/ICCAD45719" />
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM International Conference on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page">8942087</biblScope>
			<date type="published" when="2019">2019. 2019. 2019</date>
		</imprint>
	</monogr>
	<note>ICCAD) (ICCAD&apos;19</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Chick</forename><surname>Markley</surname></persName>
		</author>
		<ptr target="https://github.com/chipsalliance/treadle" />
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Compiler Infrastructure for Accelerator Generators</title>
		<author>
			<persName><forename type="first">Rachit</forename><surname>Nigam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhijing</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Sampson</surname></persName>
		</author>
		<idno type="DOI">10.1145/3445814.3446712</idno>
		<ptr target="https://doi.org/10.1145/3445814.3446712" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;21)</title>
		<meeting>the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;21)</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Functional Verification Coverage Measurement and Analysis</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Piziali</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Power-efficient Hardware Platform for Spiking Neural Network. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">Anthon</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riber</forename></persName>
		</author>
		<ptr target="https://github.com/Thonner/NeuromorphicProcessor" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
		<respStmt>
			<orgName>Department of Applied Mathematics and Computer Science, Technical University of Denmark</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">AHIR: A Hardware Intermediate Representation for Hardware Generation from High-level Programs</title>
		<author>
			<persName><forename type="first">Hakim</forename><surname>Sameer D Sahasrabuddhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kavi</forename><surname>Raja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhav P</forename><surname>Arya</surname></persName>
		</author>
		<author>
			<persName><surname>Desai</surname></persName>
		</author>
		<idno type="DOI">10.1109/VLSID.2007.28</idno>
		<ptr target="https://doi.org/10.1109/VLSID.2007.28" />
	</analytic>
	<monogr>
		<title level="m">20th International Conference on VLSI Design held jointly with 6th International Conference on Embedded Systems (VLSID&apos;07)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">LLHD: A Multi-level Intermediate Representation for Hardware Description Languages</title>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Schuiki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Kurth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Grosser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Benini</surname></persName>
		</author>
		<idno type="DOI">10.1145/3385412.3386024</idno>
		<ptr target="https://doi.org/10.1145/3385412.3386024" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;20)</title>
		<meeting>the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">?IR -An intermediate representation for transforming and optimizing the microarchitecture of application accelerators</title>
		<author>
			<persName><forename type="first">Amirali</forename><surname>Sharifian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reza</forename><surname>Hojabr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Navid</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sihao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Apala</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tony</forename><surname>Nowatzki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arrvindh</forename><surname>Shriraman</surname></persName>
		</author>
		<idno type="DOI">10.1145/3352460.3358292</idno>
		<ptr target="https://doi.org/10.1145/3352460.3358292" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO&apos;19</title>
		<meeting>the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO&apos;19</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Wilson</forename><surname>Snyder</surname></persName>
		</author>
		<ptr target="https://www.veripool.org/wiki/verilator" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fuzzing Hardware Like Software</title>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Trippel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Kang G Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Garret</forename><surname>Chernyakhovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dominic</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Rizzo</surname></persName>
		</author>
		<author>
			<persName><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st USENIX Security Symposium</title>
		<imprint>
			<publisher>USENIX Security</publisher>
			<date type="published" when="2022">2022</date>
			<biblScope unit="volume">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Golden Age of Hardware Description Languages: Applying Programming Language Techniques to Improve Design Productivity</title>
		<author>
			<persName><forename type="first">Lenny</forename><surname>Truong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.SNAPL.2019.7</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.SNAPL.2019.7" />
	</analytic>
	<monogr>
		<title level="m">3rd Summit on Advances in Programming Languages</title>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">fault: A Python Embedded Domain-Specific Language for Metaprogramming Portable Hardware Verification Components</title>
		<author>
			<persName><forename type="first">Lenny</forename><surname>Truong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Herbst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajsekhar</forename><surname>Setaluri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Makai</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ross</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keyi</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Caleb</forename><surname>Donovick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Stanley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clark</forename><surname>Barrett</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-53288-8_19</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-53288-8_19" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification (CAV&apos;20)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">Claire</forename><surname>Wolf</surname></persName>
		</author>
		<ptr target="https://github.com/YosysHQ/SymbiYosys" />
		<title level="m">SymbiYosys</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Yosys -A Free Verilog Synthesis Suite</title>
		<author>
			<persName><forename type="first">Claire</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johann</forename><surname>Glaser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Austrian Workshop on Microelectronics (Austrochip)</title>
		<meeting>the 21st Austrian Workshop on Microelectronics (Austrochip)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">American Fuzzy Lop Technical Details</title>
		<author>
			<persName><forename type="first">Micha?</forename><surname>Zalewski</surname></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/afl/technical_details.txt" />
		<imprint>
			<date type="published" when="2014-04">2014. April, 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Sonic-BOOM: The 3rd Generation Berkeley Out-of-Order Machine</title>
		<author>
			<persName><forename type="first">Jerry</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Korpan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovi?</surname></persName>
		</author>
		<idno>2022-10-20; accepted 2023-01-19</idno>
		<ptr target="https://carrv.github.io/2020/papers/CARRV2020_paper_15_Zhao" />
	</analytic>
	<monogr>
		<title level="m">Fourth Workshop on Computer Architecture Research with RISC-V</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
