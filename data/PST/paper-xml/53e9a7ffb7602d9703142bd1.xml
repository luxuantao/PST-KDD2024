<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Generic Ownership for Generic Java</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alex</forename><surname>Potanin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Victoria University of Wellington New Zealand</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">James</forename><surname>Noble</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Victoria University of Wellington New Zealand</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dave</forename><surname>Clarke</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Centrum voor Wiskunde en Informatica</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Robert</forename><surname>Biddle</surname></persName>
							<email>biddle@carleton.ca</email>
							<affiliation key="aff2">
								<orgName type="institution">Carleton University</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Generic Ownership for Generic Java</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A095265A91ED7FDD8D3AAAD3DA062A67</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features-Classes and Objects</term>
					<term>Polymorphism; D.1.5 [Programming Techniques]: Object-Oriented Programming General Terms Design</term>
					<term>Languages</term>
					<term>Theory Java</term>
					<term>generics</term>
					<term>ownership</term>
					<term>type systems</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Ownership types enforce encapsulation in object-oriented programs by ensuring that objects cannot be leaked beyond object(s) that own them. Existing ownership programming languages either do not support parametric polymorphism (type genericity) or attempt to add it on top of ownership restrictions. Generic Ownership provides per-object ownership on top of a sound generic imperative language. The resulting system not only provides ownership guarantees comparable to established systems, but also requires few additional language mechanisms due to full reuse of parametric polymorphism. We formalise the core of Generic Ownership, highlighting that only restriction of this calls and owner subtype preservation are required to achieve deep ownership. Finally we describe how Ownership Generic Java (OGJ) was implemented as a minimal extension to Generic Java in the hope of bringing ownership types into mainstream programming.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Object ownership (instance encapsulation) ensures that objects cannot be leaked beyond an object or collection of objects which own them. There are two main approaches to object ownership in the literature: enforcing coding conventions within an existing programming language, or significantly modifying a language to allow ownership support. The first approach is taken by Islands <ref type="bibr" target="#b24">[25]</ref> and various kinds of Confined Types <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b53">54]</ref>. Programs must be written to follow a set of specific conventions, conformance to which can be checked to see if they provide ownership guarantees <ref type="bibr" target="#b23">[24]</ref>. The soundness of this first approach has been proven only recently <ref type="bibr" target="#b54">[55]</ref>. Support for generics is added on top of such collections of restrictions that enforce encapsulation <ref type="bibr" target="#b54">[55]</ref>. The second approach is taken by languages such as Joe, Universes, AliasJava, and SafeConcur-rentJava <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b38">39]</ref>. Ownership parameterisation is added to the syntax and expressed explicitly within the type systems of these Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA'06 <ref type="bibr">October 22-26, 2006</ref>, Portland, Oregon, USA. Copyright c 2006 ACM 1-59593-348-4/06/0010. . . $5.00 languages. All of these different type systems employ ownership parameterisation, but none has support for type genericity.</p><p>Why would we want to combine ownership and generic types? Consider for example a box as a kind of object. In any objectoriented language we are allowed to say: "this is a box" (meaning a box of any things). In a language with generics, we are allowed to say: "this is a box of books", denoting a box containing books, but not birds. In a language with ownership parameterisation, we are allowed to say: "this is my box" or "these are library books". Combining ownership and generics naturally allows us to say: "this is my box of library books", not a box of birds, and not my personal books. This illustrates the main idea of this paper: combining ownership and genericity. Ownership works exceptionally well with genericity, both in theory, practice, and implementation.</p><p>In this paper, we present Generic Ownership, a language design that uses a single parameter space to carry both generic type and ownership type information. We show that ownership systems can be subsumed completely by parametric polymorphic type systems, and formalise our approach within the context of an imperative extension to Featherweight Generic Java (FGJ) <ref type="bibr" target="#b26">[27]</ref>.</p><p>Contributions. The contributions of this paper are as follows:</p><p>• Generic Ownership -a practical way of integrating ownership and genericity by using a single parameter space to carry both type and ownership information; • Featherweight Generic Ownership (FGO) -a formal model with soundness proofs demonstrating that the following is sufficient to provide ownership and confinement support: (1) disallowing non-this calls on owned objects, (2) preserving owners as part of the type, and (3) preserving owner nesting, as long as the underlying sound type system supports genericity; • Ownership Generic Java (OGJ) -a publicly available extension to Java 5 that supports Generic Ownership -which is the first language implementation that supports ownership, confinement, and generics at the same time, while preserving full syntactic compatibility with Java 5.</p><p>These contributions represent a significant advance over our previous work on Featherweight Generic Confinement <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b46">47]</ref> which focused on confinement within static contexts (e.g. Java packages) and was formalised without heap objects, pointers, or assignment. In this paper we present an imperative, object-oriented formalism including pointers and assignment that supports full, deep per-object ownership within dynamic contexts, and describe a language design and prototype implementation. We build upon a preliminary workshop paper <ref type="bibr" target="#b45">[46]</ref> that provided only shallow ownership and did not discuss a language design. The primary goal of this work is not to develop a higher level abstraction unifying ownership and genericity. Generic Ownership's contribution is a language design, that, by building upon an existing generic type system, can smoothly extend Java-like languages to  <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b41">42]</ref> which investigates new kinds of topologies or restrictions or applications for ownership types. Rather, we hope that Generic Ownership will provide the means by which an ownership system can be incorporated into existing generically typed programming languages.</p><p>Outline. In Section 2 we present a background overview of ownership and genericity. Section 3 presents the fundamentals behind Generic Ownership and introduces our language design OGJ. Section 4 highlights the important aspects of the type system (available in full as a technical report <ref type="bibr" target="#b47">[48]</ref>). Section 5 presents the dynamics of FGO, as well as the type soundness of the type system as a whole. Section 6 discusses the ownership guarantees provided by FGO. Finally, Section 7 discusses related work and Section 8 outlines future work and concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>Genericity and Ownership are two language mechanisms that, in different ways, allow programmers to make the intentions behind their code more explicit. This can provide programmers with more support, typically by detecting errors statically, at compile time, that could otherwise only be detected (or worse, remain undetected) once the program is run.</p><p>In this section, we will illustrate the advantages and impacts of genericity and ownership with reference to a simple example, shown in Figure <ref type="figure">1</ref>. This example is a small part of an implementation of a simple Map class that uses neither genericity nor ownership. The map is implemented using a Vector containing a number of Nodes, each of which stores a key-value pair. The main Map class provides methods to insert a new key-value pair into the map and to return the first value associated with a particular key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Genericity</head><p>Genericity allows us to use type parameters to give a better description of the type of the variable we are dealing with. This allows more sensible collections (e.g. of Nodes rather than anything), better compile-time error detection, and more readable and reusable code. The code in Figure <ref type="figure">1</ref> exhibits a number of well-known weaknesses <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b29">30]</ref>. One prominent weakness is that it relies upon subtyping to store objects of various types within the Map itself and within the Vector implementing the Map.</p><p>This is an old problem, and the solutions are equally old, dating back to the mid-1970s <ref type="bibr" target="#b36">[37]</ref>: the class definitions must be made  generic (or parametrically polymorphic) so that particular instances of the classes can be created for particular argument types. Java now supports generic types <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b49">50]</ref> and Figure <ref type="figure" target="#fig_0">2</ref> presents a version of the Map class written using genericity, in Java 5 syntax.</p><p>Comparing Figures <ref type="figure">1</ref> and<ref type="figure" target="#fig_0">2</ref> illustrates both the advantages and disadvantages of generic types. Regarding the advantages, the types of objects stored in the Vector or Map can now be preserved when they are returned, so there is no need for a typecast when objects are removed from the Vector. Method declarations can also carry more information, using generic type parameters like "Key" or "Value" instead of "Object" or "Comparable". As a result, only objects of the right types can be stored into Maps and Vectors; attempts to store the wrong types of objects will be detected at compile time.</p><p>The main disadvantage is that Figure <ref type="figure" target="#fig_0">2</ref> is more complex than Figure <ref type="figure">1</ref>: in particular, the class definitions in the generic version declare formal generic type parameters, and then class instantiations must provide actual values for those parameters, resulting in types like "Vector&lt;Node &lt;Key, Value&gt;&gt; nodes" rather than "Vector nodes".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Ownership</head><p>An object is aliased whenever there is more than one pointer referring to that object <ref type="bibr" target="#b25">[26]</ref>. Aliasing can cause a range of difficult problems within object-oriented programs, because one referring object can change the state of the aliased object, implicitly affecting all the other referring objects <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b53">54]</ref>.</p><p>To return to our example, considering the basic Map implementation from Figure <ref type="figure">1</ref>, the nodes field containing the Vector in the Map is declared as private, and so Java will ensure that the field can only be accessed from within the Map class. This is done because the Vector is an internal part of the implementation of the Map class and should not be accessed outside. Inserting or removing elements from the Vector, or perhaps acquiring but not releasing its internal lock would break the invariants of the Map class and cause runtime errors.</p><p>Unfortunately, the name based protection used in Java and most other programming languages is not strong enough to keep the Vector truly private to the Map. An erroneous programmer could insert a public method that exposed the Vector, e.g.  the exposeVector method, and thus be difficult to identify and resolve. These kinds of errors have been identified as occurring in many Java libraries <ref type="bibr" target="#b48">[49]</ref> and have caused significant problems for language security mechanisms <ref type="bibr" target="#b53">[54]</ref>.</p><p>Ownership types <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b38">39]</ref> protect against aliasing errors by allowing programmers to restrict access to objects at runtime, rather than just the names or variables used to store them. The key idea is that representation objects (like the Map's Vector) are nested and encapsulated inside the objects to which they belong (the Vector belongs to the Map; the Map owns the Vector). Clarke <ref type="bibr" target="#b15">[16]</ref> formulated an ownership invariant: that there can be no incoming references that bypass owners. This means that one object cannot refer to a second object directly, unless the first object is itself inside the second object's owner. Because this nesting (and thus the protection) is transitive, we call this deep ownership <ref type="bibr" target="#b19">[20]</ref>: if an Array is part of a Vector's representation, the array should be owned by the vector and is thus nested inside both the vector and the map. Enforcing encapsulation via deep ownership has many practical and theoretical applications <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b32">33]</ref>. Figure <ref type="figure" target="#fig_1">3</ref> gives an example of the Map class using ownership types. The syntax used is proposed by Boyapati <ref type="bibr" target="#b6">[7,</ref><ref type="bibr">Figure 2.7]</ref>. Comparing Figure <ref type="figure" target="#fig_1">3</ref> with Figures <ref type="figure">1</ref> and<ref type="figure" target="#fig_0">2</ref> illustrates both the strengths and weaknesses of ownership types. The most obvious difference is the presence of a range of ownership type parameter definitions such as "&lt;mOwner, kOwner, vOwner&gt;" on the class declarations. This declares a parameter, mOwner, to represent the ownership of the instances of the classes being declared, with further ownership parameters "kOwner" and "vOwner" describing the ownership of the keys and values that will be stored in the map. These parameters are then instantiated as the types are used, as when a Node is created within the put method of Map.</p><p>Note also that ownership parameters can be instantiated via the keyword "this", which ensures that the current object (the object usually denoted "this" in Java) owns the object being declared <ref type="bibr" target="#b17">[18]</ref>. The Vector object is marked in this way as being owned by the Map, for example, so any attempt to access or pass the Vector object outside the Map object will be detected and prevented at compile time. Code such as the exposeVector() method will be unable to cause any damage by breaching encapsulation.</p><p>The ownership parameters carry ownership information around the program, so that the ownership status of the keys and values  can be maintained outside the Map. For example, the ownership of the keys and values may be specified by each instantiation of the Map class, but by using the kOwner and vOwner ownership parameters, the fields that will store keys and values inside the subsidiary Node objects will have the correct ownership for these fields.</p><p>The main disadvantage of ownership types is quite similar to that of generic types: additional syntactic complexity as a result of ownership parameters. In fact, this code also has all the typerelated problems of the "straight" Java code: the problems that are addressed by genericity. This code relies on subtyping to store different types of objects, and so requires type casts when objects are removed from the Vector (or subsequently from the Map). Although the code may look generic, all the declared types are simple Java types, such as Object or Comparable, with the problems that entail. While the Vector stored in the nodes field can no longer be exposed outside of the Map instance that owns it, malicious or buggy programming within that class can break this code by directly inserting incorrect types into the Vector.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Combining Genericity and Ownership</head><p>The state of the art, then, is that there are two separate but similar techniques that constrain which objects may be accessed by which types, fields, or expressions. Genericity constrains these accesses by compile-time types, while ownership constrains the accesses by compile-time object structures. These two mechanisms appear to be orthogonal, raising the question: "could they both be included within a single programming language?" Figure <ref type="figure" target="#fig_2">4</ref> repeats the Map example using a hypothetical language separately supporting both genericity with parameters marked with [ and ] and ownership with parameters marked with &lt; and &gt;. The syntax in this Figure is based on Boyapati <ref type="bibr">[7, page 29]</ref> and resembles the original Flexible Alias Protection proposal <ref type="bibr" target="#b39">[40]</ref>.</p><p>Again we can compare Figure <ref type="figure" target="#fig_2">4</ref> with the preceding Figures  As with the generic system, types can be instantiated for keys and values, removing the reliance on subtyping and the associated fragile type casts. As with the ownership system, objects can be tagged as owned by this, ownership can be recorded via owner parameters, and thus any exposing method would be detected and prevented.</p><p>Unfortunately, the syntax required to implement both ownership and genericity separately means that this code is annotated in a significantly more complex way than any of the other examples -with both classes requiring five ownership and type parameters, some of which are not directly utilised by the code. The code is, arguably, so complex that it would be unusable in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Generic Ownership</head><p>Generic Ownership takes a novel approach of providing ownership and genericity in a programming language. As opposed to the hypothetical example of Figure <ref type="figure" target="#fig_2">4</ref> or the previous work on combining confinement and genericity <ref type="bibr" target="#b54">[55]</ref> -Generic Ownership starts with a sound type polymorphic language and adds ownership as an extension to the existing generic type system. Providing genericity before ownership, surprisingly, results in both simpler formalism and a simpler language that provides the benefits of both type and ownership parameterisation: catching all the errors and avoiding all the bugs that the generic and ownership languages do individually. Generic Ownership treats ownership and genericity as one single aspect of language design, and so code using Generic Ownership is no more syntactically complex than code that is either type-parametric or ownership-parametric. The key technical contribution of Generic Ownership is that it treats ownership as an additional kind of generic type information. This means that the existing generic type systems can be extended to carry ownership information with only minimal changes <ref type="bibr" target="#b46">[47]</ref>.</p><p>Figure <ref type="figure" target="#fig_3">5</ref> revisits our Map example for the last time. This time, it is written in our new language design, Ownership Generic Java (OGJ). Note that the code in Figure <ref type="figure" target="#fig_3">5</ref> is type-generic: definitions of fields in Node and methods everywhere use generic types such as Key and Value rather than plain class types such as Object or Comparable. Note also that the code is ownership-generic. Every class has an extra type parameter that represents the object's owner: we place it last, typically name it Owner and call it the owner parameter. When creating an object, we can mark it as owned by the current object this by instantiating the new object's owner parameter with the owner constant This. All OGJ classes descend from a new parameterised root Object&lt;O&gt; that declares an owner parameter, and all subclasses must invariantly preserve their owner parameter. Owners descend from a separate root, World, which also acts as a second owner constant, meaning that access to an object is unrestricted.</p><p>Consider an example exposing a nodes vector private to the Map object considered earlier in Section 2:</p><p>public Vector exposeVector() {return nodes;} This code is not valid in OGJ as is, since every type has an owner parameter and casting to raw types <ref type="bibr" target="#b27">[28]</ref> is prohibited. The type of the field nodes in Figure <ref type="figure" target="#fig_3">5</ref> has an owner parameter This. If we try to give a return type of the exposeVector method an owner parameter This, e.g.:</p><p>public Vector&lt;Node&lt;Key, Value, This&gt;, This&gt; exposeVector() { return nodes; } then this code will be valid OGJ, but the method can only be called if the result can be assigned to something that is a supertype of Vector&lt;..., This&gt;. Since OGJ preserves owners over subtyping, any valid supertype of the return type will have to have an owner This, which will only typecheck if it is called from the same instance of Map. This is enforced by the this function described in Section 4.3. In other words, this exposeVector method cannot expose the vector. If we attempt to declare this method with a return type having any other owner parameter, then the return type and the return value's (nodes) type will not be assignment compatible in OGJ, as their owner parameters will be different.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Expressiveness of Generic Ownership</head><p>Comparing Figure <ref type="figure" target="#fig_3">5</ref> with Figures <ref type="figure">1</ref><ref type="figure" target="#fig_0">2</ref><ref type="figure" target="#fig_1">3</ref><ref type="figure" target="#fig_2">4</ref>shows that it is slightly more complex than the individual type genericity or ownership examples, but rather simpler than the straightforward combination in Figure <ref type="figure" target="#fig_2">4</ref>. In particular, Figure <ref type="figure" target="#fig_3">5</ref>'s declaration of the Map class has only three parameters (the same as in Figures <ref type="figure" target="#fig_0">2</ref> and<ref type="figure" target="#fig_1">3</ref>). Furthermore, the type of field nodes in Figure <ref type="figure" target="#fig_0">2</ref> is more readable: presented in Figure <ref type="figure" target="#fig_2">4</ref>.</p><p>Because every OGJ class has a distinguished owner parameter, the bounds of formal generic parameters (e.g. Key extends Comparable&lt;KOwner&gt;) must be declared with a placeholder owner parameter (KOwner in this case). Apart from this declaration, programmers are not required to supply placeholder parameters: rather they are bound implicitly, with very similar semantics to Java wildcards <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b52">53]</ref>. Within the scope of the type parameter declaration (a generic type or method) the bound type variable (e.g. Key) ranges simultaneously over type and owner. Owners can also be passed explicitly (generally as arguments to formal parameters bound by World) -indeed, the distinguished owner parameter is just a special case of this.</p><p>This implicit binding of owner parameters -and, more importantly, the combination of ownership into types -reduces the number of formal arguments required by generic ownership. Programmers do not need to write code such as: Finally, to live up to the full potential of generics in Java 5, Generic Ownership allows owner parameters to be mixed with generic method parameters. Owners on methods allow more granular control of what access each method has to the other objects, and they can be utilised usefully for more granular alias control with little overhead for the programmer. For example, the following method can create a new Name object even though the class to which addNewName method belongs might not have access to owner NameO: &lt;NameO extends World&gt; addNewName(String name) { this.map.put(new Name&lt;NameO&gt;(name), null); } Owner method parameters come up in practice when implementing OGJ's static methods: since static methods do not belong to any instance of a class, they cannot have generic owner parameters coming from their class declaration. Without owner parameters for methods, creation of new classes with particular owners and implementation of static methods would not be easy.</p><p>To summarise this subsection: these examples show how OGJ can provide independent ownership and type genericity -with separate parameters -and ownership genericity without type genericity -with "naked" owner parameters, or by using parameters instantiated at their type bounds. Programmers can provide type parametricity without ownership parametricity either by supplying ownership constants (e.g. World) at point of use, or by using manifest ownership (described below) to fix an owner for all instances of a class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">OGJ and Confinement</head><p>Building on our previous work, OGJ supports both ownership and static confinement -allowing an object to be owned by a static package, rather than by another dynamically allocated object <ref type="bibr" target="#b46">[47]</ref>. This is expressed by using an owner constant named after the current package -so a package called m would have a matching owner constant M, that is only accessible within its package: as a convention, we will prefix class names by the name of their defining packages where necessary. This means that mMain below refers to class Main inside package m. Whereas objects owned by this can only be accessed from within their owner, objects owned by a package can be accessed by any object within that package.</p><p>The following declaration of a class called Main shows how an OGJ class is declared -with its owner parameter Owner bound to its superclass's owner parameter (Object in this case), and then how a stack class can be instantiated with different ownership. Within the Main class, four methods return different kinds of OwnedStack objects: one of these is public, another is confined to package m, the next one is owned by a particular instance of class Main, and the last one is owned by the owner of mMain class and can be shared with others owned by the same owner. The public stack stores Object&lt;World&gt; instances that are accessible from anywhere (because Object's owner parameter is instantiated by World). The second stack stores mMain instances that are also globally accessible, however the stack itself has owner M, meaning that it is only accessible within package m. The private stack stores instances of mMain accessible inside package m only, while the actual stack is only accessible by objects owned by a particular instance of mMain that created it. The shared stack stores the same sort of instances of mMain as the private stack, except that it is accessible by any other instances who have the same owner as current instance of mMain. In each case, the stack's second parameter describes its owner. Again, these stacks illustrate how OGJ provides both type polymorphism (the stacks hold different item types) and ownership polymorphism (the stacks belong in different protection contexts).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Manifest Ownership</head><p>OGJ supports a form of manifest ownership <ref type="bibr" target="#b15">[16]</ref> to allow classes without explicit owner type parameters. A manifest class does not have an explicit owner parameter, rather the class's owner is fixed, so all the objects of that class have the same owner. This is just the same way that in Generic Java, for example, a non-generic Integer List class can be defined as extending List&lt;Integer&gt;, binding and fixing the list's type parameter. To demonstrate manifest ownership, consider the following alternative formulation of a public stack class: With this definition Object and every class inheriting from it has a default owner parameter World (thus making them publicly accessible). We can write the following familiar declaration of a public Stack object, which is indistinguishable from that of Java:</p><formula xml:id="formula_0">class Stack extends Object { ... }</formula><p>The important difference is that with manifest ownership, every Stack instance has an owner originating from OGJ's root class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">OGJ Language Design</head><p>We conclude this section by bringing together the details of our language design. Ownership Generic Java is designed as a minimal extension to Java 5 <ref type="bibr" target="#b49">[50]</ref>. The key difference is that OGJ allows classes to be declared with a distinguished (last) ownership type parameter (conventionally Owner) extending World. Classes without an ownership parameter ("plain Java" classes descending from java.lang.Object) are treated as if they used manifest ownership.</p><p>OGJ supplies a number of ownership type constants: World, Package, and This. When bound to a class's ownership type parameter, these constants mark the instances as public, as confined within their package, or as owned by the current "this" object, respectively. To ensure deep ownership, OGJ restricts the types which can be formed so that the distinguished ownership type parameter is always inside or equal to (greater or equally encapsulated than) any other parameters' ownership type. In practice, this means that when an actual owner parameter is World, all the other type parameters must have an owner World; if the actual owner parameter is a package or an ownership type variable, then that package (or variable) and World are permissible; if the actual owner parameter is an enclosing class's Owner then World, Owner, and other (placeholder) formal ownership type parameters of that class are permissible; and if an ownership type parameter is bound to This, then the other parameters may be bound to anything. This is sufficient to provide package confinement. To enforce per-object ownership OGJ ensures that types with an actual owner parameter of This can only be accessed via Java's this keyword, either explicitly or implicitly. Assignments such as this.pvtField = other.pvtField between two Node instances are illegal if this.pvtField is owned by this; similarly method or field accesses involving a This owner are only permitted on the current "this" object.</p><p>Finally, to ensure that ownership information cannot be lost, OGJ requires type casts to preserve ownership. This follows Java's existing rules for subtyping parameterised types, except that it prevents casts to raw types <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b27">28]</ref> when such casts would delete an ownership parameter. OGJ must also restrict wildcards for ownership types to type variable bounds, and prevent reflection when it could breach ownership.</p><p>These are the only restrictions imposed by Generic Ownership on top of the vanilla type generic language. This achieves ownership and confinement guarantees comparable to the alternative systems <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b54">55]</ref> with a large burden carried by the underlying sound type polymorphic system. Hence, these restrictions highlight the concepts important to the mechanism of ownership, excluding the rest of the rules required by the alternative type systems as technical details. 1 To avoid class name conflict with Object, OGJ can choose a different name for its root, such as OObject&lt;World&gt;, meaning owned object.</p><p>Our prototype implementation <ref type="bibr" target="#b43">[44]</ref> includes a compiler that can bootstrap itself (albeit with substantial use of standard (manifest) Java classes) and compile a growing test suite. There are a number of implementation-specific issues omitted in this paper, such as distinguishing This between an inner class and the outer class, dealing with generic arrays and static fields and methods. All of these issues are addressed in the thesis referenced in our accompanying technical report <ref type="bibr" target="#b47">[48]</ref>. Our future plans include the development of an ownership-aware version of the Java Collections library to support larger OGJ programs without resorting to manifest ownership.</p><p>To demonstrate the difference between OGJ and the other ownership languages, consider the examples in the Figures <ref type="figure">6</ref> and<ref type="figure">7</ref>. Both of these simple examples were compiled with the latest version of AliasJava<ref type="foot" target="#foot_0">2</ref> and OGJ <ref type="foot" target="#foot_1">3</ref> . Both examples have two private fields protected from erroneous exposure by making them owned by the instance of Rectangle that created them. The constructor is forced to make a private copy of the supplied Point references. The method doIt fails to expose the private fields via exposeUpperLeft() unless the method receiver is explicitly this. It is interesting to observe that a lot of work to do with aliasing protection is performed by Java 5 on behalf of OGJ, as the comments in the figure point out. These have to do with type parameters (which in OGJ can also include owner classes) checked by Java's type system.</p><p>AliasJava adds support for ownership by introducing extra annotations such as owned added on top of Java syntax, while OGJ's syntax is completely Java compatible. OGJ also supports confinement, in addition to ownership, while still keeping Java syntax. This means that it inherits the problems of Generic Java, such as lack of proper generic array support. Most importantly, OGJ is the first working language implementation that supports ownership, confinement, and generic types at the same time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Featherweight Generic Ownership</head><p>In this section, we present Featherweight Generic Ownership (FGO) and its type system. We started the development of FGO by taking Featherweight Generic Java (FGJ) <ref type="bibr" target="#b26">[27]</ref> and adding imperative features <ref type="bibr" target="#b42">[43]</ref> to be able to take into account assignments and field updates in the presence of per-object ownership. As described above, we then added a separate hierarchy of owner classes rooted in World that are used to carry ownership information for each FGO type. In fact, if we only aim to support static confinement, then we need add little other than owner classes to FGJ as we demonstrate elsewhere <ref type="bibr" target="#b46">[47]</ref>. The key formal contribution of this work is that, by adding the imperative features (assignment, object store, etc) we demonstrate object ownership in dynamic contexts.</p><p>To support dynamic deep ownership, in addition to adding owners to types, we prevent non-this access to types owned by particular instances, ensure owner invariance over subtyping, and provide for owner parameter nesting. This lets us prove the deep ownership property known as owners as dominators (objects are nested within their owners). The remainder of this section highlights the important aspects of the FGO type system. πC is assumed to be an implicit lookup function; this, owner, and visible are described in detail in the rest of this section. Finally, we use the following judgements:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Syntax, Functions, and Judgements</head><formula xml:id="formula_1">Δ T OK Type T is OK. Δ T U</formula><p>Type T is a subtype of type U. Δ; P e : T Expression e is well typed. Δ; P visible(e) Expression e is visible with respect to P.</p><formula xml:id="formula_2">Δ S Store (heap) is well-formed. Δ &lt; Y P &gt; T m(T x){return e0; } FGO IN C, C O Method m definition is OK. class C &lt; X N &gt; N {T f; M} FGO Class C definition is OK.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Owner Lookup</head><p>owner</p><formula xml:id="formula_3">Δ(O) = O owner Δ(X) = owner Δ(Δ(X)) owner Δ(C &lt; T, O &gt;) = O owner Δ(C &lt; T &gt;) = owner Δ([T/X]N), where CT (C) = class C &lt; X N &gt; N{T f; M}</formula><p>The owner function gives the owner of a type. A manifest class's owner is found by traversing the class hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">This Function (FGO-THIS)</head><formula xml:id="formula_4">thisC(this) = This this l (l) = This l thisP (. . .) = ⊥</formula><p>The this function is used extensively during the typing of FGO expressions. It helps enforce ownership, as it ensures that types involving This can only be used within the current object, that is, as part of message sends or field accesses upon this. Basically, every occurrence of This in the type of a method call or field access is substituted with the result of calling the this function; if the type involves This, the expression will typecheck only if the target of the call or field access is this. As such, the this function is one of the key extensions we make to FGJ.</p><p>In detail, there are two distinct places where this is used. They are distinguished by the permission P that is present on the left hand side of the expression type rules. The first place is during the validation of FGO class declarations (in the class and method typing rules in Figure <ref type="figure" target="#fig_9">13</ref>, which rely on expression typing in Figure <ref type="figure" target="#fig_8">11</ref>). Here, the permission P is set to the class C currently being validated. When typing a field access or method call inside C, the this function is called upon the expression e0 that is the target of the field access (e0.f) or method call (e0.m()). Then, all occurrences of This in the types of the method or field are substituted by the result of the this function. If the target is this (e.g. this.f), the this function returns This, the substitution will replace This with itself, and so the expression typechecks, even if it involves This types. If the target is other than this, the this function returns an undefined (⊥) result, so This is substituted by ⊥ (leaving other types unaffected), and any expressions with This types will fail to typecheck. In this way, FGO ensures that This types can only be used upon this.</p><p>The second place this appears is during the reduction of FGO expressions (e.g. R-METHOD in Figure <ref type="figure" target="#fig_11">15</ref>). In this case, expression types include locations (l). Every occurrence of a This owner is replaced by a location specific This l . The expression typing rules further ensure that every occurrence of This is made location specific. To achieve this, the T-CONTEXT rule in Figure <ref type="figure" target="#fig_8">11</ref> sets the permission P to the current location l. As the expression typing rules recurse into the structure of the expression e, every occurrence of This is replaced appropriately by this l to be This l . This replacement ensures that FGO expression reduction distinguishes between different instances of the same class, allowing us to prove our ownership system provides per-object ownership guarantees.</p><formula xml:id="formula_5">X ∈ dom(Δ) Δ X OK (WF-VAR) Δ O World Δ Object &lt; O &gt; OK (WF-OBJECT) (WF-TYPE): class C &lt; X N &gt; N {. . .} Δ N Object &lt; O &gt; Δ O World Δ T OK Δ T [T/X]N ∀T ∈ T : owner Δ(C &lt; T &gt;) owner Δ (T) Δ C &lt; T &gt; OK</formula><p>In either case, invalid use of an owner class causes the expression type to become undefined (⊥). FGO type soundness guarantees that any validated FGO class will not incur an invalid access to a location-specific instance (marked by This l owner) during reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Well-formed Types and Subtyping</head><p>FGO's type well-formedness rules shown in Figure <ref type="figure" target="#fig_6">9</ref> are the same as those of FGJ, except that the root of the class hierarchy is parameterised. The grey clause in the type formation rule ensures that FGO supports deep ownership: WF-TYPE enforces the nesting of owner parameters essential to ensure owners as dominators object encapsulation. The owner nesting required of each type is that the last (distinguished) owner parameter of C &lt; T &gt; is inside of every other owner of the rest of the type parameters T.</p><p>Figure <ref type="figure">10</ref> shows FGO's subtyping rules. They are generally taken verbatim from FGJ, except for the addition of subtyping for owner classes. World forms the top of the owner class hierarchy, which any package owner class extends directly. Location-specific version This l extends the owner of the class at location l. The owner hierarchy for location-specific owners is built up in the FGO class rules (Figure <ref type="figure" target="#fig_9">13</ref>) using owner variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Expressions and Visibility</head><p>Figure <ref type="figure" target="#fig_8">11</ref> shows the expression typing rules. These are similar to the FGJ rules with added support for locations, assignment, null, and let expressions <ref type="bibr" target="#b42">[43]</ref>. We also simplify the detection of cast errors by only doing it at reduction time.</p><p>Another important addition that FGO makes to FGJ is a set of visibility rules similar to those used by Featherweight Generic Confinement <ref type="bibr" target="#b46">[47]</ref>. While a subset of our visibility rules for terms is similar to those used by ConfinedFJ <ref type="bibr" target="#b54">[55]</ref>, the owner and type visibility rules are part of the foundation of FGO.</p><p>Figure <ref type="figure" target="#fig_0">12</ref> shows the owner visibility rule that checks if an owner O is visible inside class C. This is the case if the owner is World, belongs to the same package as C, or is an owner of one of the generic parameters used when instantiating C. Supplying an actual owner parameter to a class gives that class permission to access everything owned by that parameter. This, for example, can allow a type polymorphic class to have private access to more than one package.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bound of Type:</head><p>boundΔ(X) = Δ(X) boundΔ(N) = N Subclassing:</p><formula xml:id="formula_6">C C C D D E C E class C &lt; X N &gt; D &lt; T &gt;{. . .} C D</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subtyping:</head><p>(S-REFL):</p><p>(S-TRANS):</p><formula xml:id="formula_7">Δ T T Δ S T Δ T U Δ S U (S-VAR): (S-CLASS): Δ X Δ(X) class C &lt; X N &gt; N {. . .} Δ C &lt; T &gt; [T/X]N (S-OWNER): class C &lt; X N &gt; N {. . .} Δ πC World l ∈ dom(Δ) Δ This l owner Δ(Δ(l)) Valid Method Overriding: mtype(m, N) = &lt; Z Q &gt; U → U0 ⇒ P, T = [Y/Z](Q, U) and Y P T0 [Y/Z]U0 override(m, N, &lt; Y P &gt; T → T0)</formula><p>Figure <ref type="figure">10</ref>. FGO Subtyping Rules Finally, we allow complete visibility of the This owner, and rely on the this function described earlier to stop illegal uses of This. Type visibility simply checks the owner of a given type for visibility. Term visibility (not shown) recursively checks all the types involved in the possible expressions of FGO to make sure that they are visible in a given class C. Since these checks are performed on class declarations, locations are not present in these expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Class and Method</head><p>The class and method declarations are checked to make sure that they contain well-formed, visible types and expressions as shown in Figure <ref type="figure" target="#fig_9">13</ref>. There are rules for pure and manifest FGO classes that are distinguished only by the fact that the owner is either explicit or must be looked up from a superclass. Both of the class rules check that (1) all the types involved (types of fields and type parameters) are visible within the context of the owner of the class being declared or its superclass; (2) all the types are well formed FGO types; and (3) all the methods declarations are valid. The grey clauses ensure that owner nesting (the distinguished owner is inside the owners of the other type parameters) is preserved for the purposes of the deep ownership invariant proven below in Section 6.</p><p>Additionally, FGO allows class declarations to use implicit placeholder owner parameters in formal type parameter bounds, e.g.:</p><p>class List&lt;E extends Foo&lt;FO&gt;, Owner extends World&gt; { ... }</p><p>Here, List's formal parameter E can only be bound by actual type parameters that are subclasses of Foo; the owner of that type parameter (FO) can be different from the owner of the list (Owner). Since FGO (like FGJ) requires every type variable to be bound, we need to make sure that our environment contains an appropriate mapping for implicit placeholder parameters like FO. A function PHowners in Figure <ref type="figure" target="#fig_9">13</ref> does exactly that, by making sure that  </p><formula xml:id="formula_8">∀V ∈ V : (Δ V OK ∨ Δ V World) ∧ ∧ ( owner Δ(T0) owner Δ(V ) ) mtype(m, boundΔ(T0)) = &lt; Y P &gt; U → U Δ; P e : S Δ; P e0 : T0 Δ T OK T = [V/Y, thisP (e0)/This]U Δ V [V/Y, thisP (e0)/This]P Δ S [V/Y, thisP (e0)/This]U Δ; P e0.m &lt; V &gt;(</formula><formula xml:id="formula_9">visibleΔ(T, C) = visibleΔ(owner Δ(T), C) (V-OWNER): visibleΔ(O, C) = O ∈ owners(C) ∪ {This, πC, World} where owners(C) = {owner Δ(N ) | N ∈ N, N}, if CT (C) = class C &lt; X N &gt; N{. . .} {X O } ∪ {owner Δ(N ) | N ∈ N}, if CT (C) = class C &lt; X N, X O N O &gt; N{. . .} Figure 12</formula><p>. FGO Type and Owner Visibility any (placeholder) owner used in the type bounds is recorded in the FGO environment Δ as being a subtype of World. This ensures that every owner present in the class declaration is bound, whether implicitly or explicitly. The method typing rule checks that all the types involved are well formed FGO types that are visible within the class that contains the method. It also recursively checks the method's expression to ensure that all the subexpressions are visible with respect to the Method Typing (FGO-METHOD):</p><p>Δ ∀P ∈ P : (P OK) </p><formula xml:id="formula_10">∨ (P World) Δ = Δ ∪ {Y P} Δ = Δ ∪ PHownersΔ(N) ∀Y ∈ Y : Δ = Δ ∪ {C O owner Δ(Y )} Δ T, T OK class C &lt; X N &gt; N {. . .} visibleΔ(T, C) visibleΔ(T, C) visibleΔ(P, C) Δ, x : T, this : C &lt; X &gt; ; C visible(e0) Δ, x : T, this : C &lt; X &gt; ; C e0 : S Δ S T override(m, N, &lt; Y P &gt; T → T) Δ &lt; Y P &gt; T m(T x){ return e0; } FGO IN C, C O Class Typing (FGO-CLASS-MANIFEST): Δ = {X N, This owner Δ (N)} Δ = Δ ∪ PHowners Δ(N) ∀X ∈ X : Δ = Δ ∪ {owner Δ (N) owner Δ(X )} Δ M FGO IN C, owner Δ (N) Δ N, T, N OK visibleΔ(N, C) visibleΔ(T, C) visibleΔ(N, C) class C &lt; X N &gt; N {T f; M} FGO Class Typing (FGO-CLASS-PURE): N = D &lt; T , X O &gt; ∀N ∈ N : Δ N OK ∨ Δ N World Δ = {X N, X O N O , This X O } Δ = Δ ∪ PHowners Δ(N) ∀X ∈ X : Δ = Δ ∪ {X O owner Δ(X )} Δ M FGO IN C, X O Δ N, T OK visibleΔ(N O , C) visibleΔ(T, C) visibleΔ(N, C) class C &lt; X N, X O N O &gt; N {T f; M} FGO Placeholder Owners Function: PHownersΔ(C &lt; T &gt;) = {owner Δ(C &lt; T &gt;) World} ∪ ∪ PHowners Δ(T) if owner Δ(C &lt; T &gt;) / ∈ dom(Δ) PHownersΔ(C &lt; T &gt;) = PHowners Δ(T) otherwise PHownersΔ(X) = {}</formula><formula xml:id="formula_11">∀l ∈ dom(Δ) : Δ Δ(l) OK Δ OK Store Typing (FGO-STORE): Δ OK dom(Δ) = dom(S) S[l] = N(v) ⇐⇒ Δ(l) = N (S[l, i] = l ) ∧ (fields(Δ(l)) = T f) =⇒ =⇒ Δ Δ(l ) [This l /This]Ti (S[l, i] = l ) =⇒ Δ Δ(l ) OK Δ S Figure 14. FGO Store current class.</formula><p>Finally, in exactly the same manner as FGJ, the validity of method overriding (if applicable) is verified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">FGO Dynamic Semantics</head><p>This section addresses the dynamic aspects of FGO. The store typing rules shown in Figure <ref type="figure" target="#fig_2">14</ref> are standard <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b16">17]</ref>. The mapping Δ contains the types for each location and the FGO-STORE-WF rule in Figure <ref type="figure" target="#fig_2">14</ref> ensures that every one of the types is well-formed. The mapping S contains the type instantiations with locations for each field. The main FGO-STORE rule ensures that not only the types are  well-formed, but also that each field location is valid and is a correct subtype of the declared field type. It is interesting to note that our type system does not have any explicit ownership constraints in the store rule -the benefit of ownership information being part of the type is that subtyping ensures that none of the ownership constraints are broken.</p><formula xml:id="formula_12">S[l] = N(v) fields(N) = T f S = S[l → [v/vi]N(v)] l.fi = v, S → v, S (R-METHOD): S[l] = N(v l ) mbody(m &lt; V &gt;, N) = x.e0 l.m &lt; V &gt;(v), S → l &gt; [v/x,l/this, This l /This]e0, S S[l] = N(v) N P (P)l, S → l, S (R-CAST) S[l] = N(v) N &lt;: P (P)l, S → error, S (R-BAD-CAST) l &gt; v, S → v, S (R-CONTEXT) let x = v in e0, S → [v/x]e0, S (R-LET) (R-*-NULL): null.m &lt; V &gt;(v), S →</formula><p>Figure <ref type="figure" target="#fig_11">15</ref> shows the reduction rules. Again, these are standard given the expressions that FGO supports. The context reduction rules are omitted from this paper for brevity, but are present in the accompanying technical report <ref type="bibr" target="#b47">[48]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Soundness</head><p>In this subsection we present manual proofs of the FGO type soundness. Part of the future work on Generic Ownership is to convert these proofs to a machine-checkable format.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem (Preservation). If Δ; P</head><p>e : T and Δ S and e, S → e , S , then ∃Δ ⊇ Δ and ∃T T such that Δ; P e : T and Δ S . Proof. Use structural induction on reduction rules in Figure <ref type="figure" target="#fig_11">15</ref>. This proof is presented in detail in the accompanying technical report <ref type="bibr" target="#b47">[48]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem (Progress). Suppose e is a closed well-typed expression.</head><p>Then either e is a value or there is a reduction rule that contains e on the left hand side.</p><p>Proof. Based on all the possible expression types, either e is a value (see the last four rules in Figure <ref type="figure" target="#fig_8">11</ref>) or one of the reduction rules applies. It can't be a variable because it is closed. We need to check that each of the reduction rules is satisfied. The only rules that require additional conditions are R-FIELD, R-FIELD-SET, and R-METHOD -in the case of R-BAD-CAST the program reduces to errorif the downcast is impossible.</p><p>In case of R-FIELD and R-FIELD-SET well-typedness of N ensures that fields(N) is well defined and fi appears in it. In case of R-METHOD, the fact the mtype looks up the type for m, ensures that mbody will succeed too and will have the same number of arguments (since MT-CLASS and MB-CLASS are defined in the same way).</p><p>In case of l = null, one of R-FIELD-NULL, R-METHOD-NULL, and R-FIELD-SET-NULL will ensure that we reduce to error. Type soundness is then immediate from preservation and progress theorems. Note that this type soundness result proves only the absence of "ordinary" type errors. The next section discusses the ownership guarantees provided by FGJ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Ownership Guarantees</head><p>Lemma (Ownership Invariance). If Δ S T and Δ T Object &lt; O &gt;, then owner Δ(S) = owner Δ(T) = O. Proof. By induction on the depth of the subtype hierarchy. By FGO class typing rules a FGO class has the same owner parameter as its superclass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Ownership Invariant</head><p>We define inside (≺) relationship on owner classes for objects (e.g. This l ) in the same manner as classic ownership type papers <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b17">18]</ref>. During the execution of any FGO program with deep ownership, if an object at l refers to object at l , then owner class This l corresponding to the object at l is inside (≺) owner class corresponding to l (owner (Δ(l ))).</p><p>At class declaration validation time, the ≺ relationship for the owner classes is as follows: This ≺ Owner ≺ World (note that our owner classes' subtyping relationship is along the same lines: This l &lt;: This &lt;: World). During the reduction, both Owner and This will have appropriate location-specific owners (e.g. This l ) substituted for them. This allows us to prove a deep ownership invariant similar to that of Clarke (and as used by Boyapati): Definition (refers to). Object at location l refers to object at location l if and only if (1) Δ(l) = N(l) and l ∈ l; or (2) for some Δ, P we have Δ; P l &gt; e : T and l occurs as one of the subexpressions of e. Proof. Because the class is a well-formed FGO class, its methods are well-formed FGO methods. This, plus the standard subformula property, implies that, for appropriate Δ; P : both Δ; P e : T and Δ; C visible(e) hold. From this we can derive visibleΔ(T, C), and hence visibleΔ(owner Δ(T), C). By FGO's subject reduction property, there is a T such that Δ; P new D &lt; TD &gt;(e) : T , where Δ T T. Furthermore, we have that Δ; P new D &lt; TD &gt;(e) : The major difference between our generic ownership proofs, and more traditional non-type-generic ownership invariant proofs lies in a much simpler formulation. The key benefit comes from integrating ownership into a parametric polymorphic type system, rather than building an ownership-parametric type system on top of a non-generic typed language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (inside)</head><note type="other">.</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Discussion and Related Work</head><p>Object ownership can address aliasing, security, concurrency, and memory management problems, while smoothly aligning with typical object-oriented program designs. Systems using object ownership range from expressive but weighty explicit systems based on ownership types <ref type="bibr" target="#b17">[18]</ref> to lightweight but limited implicit systems based on confined types <ref type="bibr" target="#b53">[54]</ref>.</p><p>Ownership types make ownership information an integral part of the type. Ownership part cannot be separated or changed through subtyping or casts. Generic Java treats generic part of types in a similar manner, making it an obvious choice for carrying ownership type information in Java. An alternative merger of confinement with genericity <ref type="bibr" target="#b54">[55]</ref> that treats confinement and genericity orthogonally results in more complex proofs and type rules duplicating the job that can be shared between genericity and ownership. This shows additional evidence that merging ownership and genericity is more than a syntactical change to the language.</p><p>Explicit systems such as AliasJava, Universes, and the systems of Boyapati et.al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b38">39]</ref> differ primarily in one characteristic that Clarke and Wrigstad define as shallow vs. deep ownership <ref type="bibr" target="#b19">[20]</ref>. Deep ownership protects transitively nested objects, while shallow ownership does not. Generic Ownership is an explicit deep ownership system: however its key contribution is that it combines type genericity and object ownership into a single system.</p><p>Clarke and Drossopoulou <ref type="bibr" target="#b16">[17]</ref> and Boyapati et.al. <ref type="bibr" target="#b9">[10]</ref> describe how to exploit the strong protection provided by deep ownership. The strong, transitive protection that deep ownership provides is also a liability, because the deep ownership protection prevents programmers from accessing objects' internal structures, and can require inefficient coding idioms to move data across the objects' interfaces. Aldrich and Chambers' AliasJava and Boyapati et.al.'s SafeJava <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10]</ref> show how ownership types can support more flexible object graph topologies -we do not address this issue in this paper.</p><p>Inspired by OGJ, AliasJava adopted Generic Ownership style parameters <ref type="bibr" target="#b1">[2]</ref> to provide both type and ownership genericity, although without a type generic formal system: here we establish that this approach is sound. Krishnaswami and Aldrich have recently formalised an extension to Ownership Domains using System F and permission-based ownership <ref type="bibr" target="#b30">[31]</ref>, illustrating a range of flexible ownership topologies, and supporting strong encapsulation via ML-style abstract types and genericity.</p><p>Other recent research has extended the applicability of ownershipstyle schemes. Lu and Potter have shown how to ensure object references are acyclic <ref type="bibr" target="#b33">[34]</ref>, or to control field updates even when references are unconstrained <ref type="bibr" target="#b35">[36]</ref> -they also employ ownership wildcards. They later extended their work to owner variance <ref type="bibr" target="#b34">[35]</ref>. Boyland and Retert have described how various forms of uniqueness and ownership can be encoded using fractional permissions <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>. None of these proposals are type-generic: however, we expect that, like AliasJava, languages designed with these systems could take advantage of generic ownership to provide both type and owner polymorphism.</p><p>Unlike some other ownership type schemes <ref type="bibr" target="#b8">[9]</ref> FGO does not currently support runtime downcasts. An implication of this is the FGO rule forbidding casts that would lose ownership information. This is primarily for compatibility with existing Java and GJ programs: safe ownership downcasts require runtime information which existing compilers do not supply nor existing libraries expect. Also, we suspect that other ownership type systems require many of these downcasts because they are not type-generic: as with GJ, FGO's genericity should remove the need for many of these downcasts.</p><p>All these explicit systems require additional annotations to use them, raising issues about their role in programming. For this reason, Aldrich et.al. and Boyapati et.al. have described a range of type inference schemes to provide these annotations automatically <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b10">11]</ref>. Generic ownership enables a simpler approach, as many of the owner parameters that have to be inferred by other schemes are already present in type-generic code.</p><p>Implicit confined type systems have achieved their more limited goals while keeping the number of annotations low. Vitek and Bokowski's original system <ref type="bibr" target="#b53">[54]</ref> required classes to be annotated as confined, while Clarke, Richmond and Noble <ref type="bibr" target="#b18">[19]</ref> apply these ideas in the context of Enterprise Java Beans. More recent work by Zhao, Palsberg and Vitek <ref type="bibr" target="#b54">[55]</ref> has formalised confined types based on Featherweight Java. Confined Featherweight Java also includes a notion of generic confined types, allowing a collection to be confined or not depending upon the specifications of the contained elements. Our approach is essentially the opposite. Rather than starting from a language without generic types and then adding a special form of genericity to support confinement, we start from a language with generic types (Generic Java, and its formal core FGJ), and then ensure ownership and confinement directly. Our approach leads to a simpler formal system requiring fewer new concepts and a distinctly simpler and shorter proofs.</p><p>Clarke's thesis was the first account of a system with both parametric polymorphism and ownership <ref type="bibr" target="#b15">[16]</ref>. This system was based on Abadi and Cardelli's object calculus <ref type="bibr" target="#b0">[1]</ref>, rather than a class-based language. Clarke, however, gives an encoding of a class-based language into his formalism. He further discusses how ownership can be combined with a class-based language (with inner classes), but does not provide a generic type system or language design.</p><p>Ownership types are similar to region types and region polymorphism <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b51">52]</ref>, but serve quite different purposes: ownership accounts for encapsulation while regions manage memory allocation. Regions are restricted to stack-based memory allocation while ownership supports long-lived objects and much less restrictive topologies. Just as region polymorphism permits functions to be applied to arguments in different regions, so generic ownership polymorphism allows a class to be instantiated to handle arguments with different ownership -the actual ownership type arguments act as permissions allowing the generic class access the arguments with those types.</p><p>Regions and other systems use Hindley-Milner style type inference to make fine distinctions on potential aliasing <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b40">41]</ref>. Typebased alias analysis uses the class hierarchy to discover non-alias conditions <ref type="bibr" target="#b20">[21]</ref>. More generally, functional programmers use a related technique called "phantom types" <ref type="bibr" target="#b21">[22]</ref> to include a wide range of information within types. Generic ownership is similar to these approaches in that it, too, uses additional type parameters to carry ownership information, while paying a minimal syntactic cost.</p><p>Finally, John Potter 4 has suggested that owners could be modeled orthogonally to class types. In such a scheme, types would be a pair comprising an owner context and a class type (e.g. T ::= C@O, 4 Personal Communication, <ref type="bibr">Dec. 2005</ref> where @ binds a type and an owner context). Cyclone, X10, and Fown <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b30">31]</ref> types have similar structures. This approach has the advantage of keeping owners and types conceptually separate, and, if type variables can range over such pairs, providing much of the polymorphism of generic ownership. Compared with our model these pairs need more language support -a separate kind of owners, and then constructors and accessors to retrieve owners from type pairs. This would be harder to incorporate into a practical programming language than generic ownership (X10 and Cyclone are new designs) and also harder to take advantage of new language features. In particular, our deep ownership type formation constraints are very similar to GADT type constraints <ref type="bibr" target="#b28">[29]</ref> although we require subtyping rather than type equality. Based on our model of generic ownership, we expect that a language with GADT's and subtype constraints may be strong enough to express ownership directly in its type system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Future Work and Conclusion</head><p>In this paper we described and formalised Generic Ownershipa single system that encompasses both generic types and deep, perobject ownership. The primary goal of Generic Ownership is to provide a practical way of integrating ownership into modern objectoriented languages (like Java or C#) that already employ genericity. Rather than purely to provide a unified abstraction combining ownership and genericity. Generic Ownership reuses generic language constructs as much as possible to provide ownership. Our language design and formalism show that ownership and generic type information can be expressed within a single system, and carried around the program as bindings to the same parameters. As a result, programs using Generic Ownership are only slightly more complex than those using just generic types, yet enjoy the full protection provided by ownership types.</p><p>We have demonstrated the practicability of Generic Ownership with Ownership Generic Java, a seamless, syntactically compatible extension to generic-capable Java 5 and we have implemented an OGJ language as an extension to Java 5 <ref type="bibr" target="#b43">[44]</ref>.</p><p>In the future, we plan to utilise the formal foundations provided by FGO to work out proof principles of ownership guarantees, and develop a set of design patterns for OGJ for programmers wishing to make use of ownership in their programs.</p><p>To summarise, our contributions are as follows: Generic Ownership, a seamless integration of genericity and ownership; Featherweight Generic Ownership, a formal model allowing the proof of soundness, confinement, and deep ownership invariants; and Ownership Generic Java combining generic types, ownership, and confinement in a single, straightforward language design.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. A Generic implementation of a Map class</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. An Ownership Types implementation of a Map class</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. A combined generic and ownership types Map class</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Generic Ownership implementation of a Map class</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>class</head><label></label><figDesc>PublicStack extends OwnedStack&lt;World&gt;{ } In this example, the owner of class PublicStack is World, and thus all of its instances are owned by World. Because the owner is bound in the class declaration, uses of PublicStack require no owner type parameter. Manifest ownership allows us to fit existing Java classes into our class hierarchy by simply making Java's root class Object into a manifest class 1 : class Object extends Object&lt;World&gt; { ... }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8</head><label>8</label><figDesc>Figure8shows FGO's syntax. The syntax is derived from FGJ by adding expressions for locations (references), let (local variables), assignment (field update), and null. The figure contains definitions for syntactical terms corresponding to types (T), type variables (X), nonvariable types (N), class declarations (L), method declarations (M), and expressions (e). The environment Δ stores mappings from</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. FGO Type Well-Formedness Rules. WF-TYPE rule enforces ownership with the grey clause checking the nesting among different owners present in the same type.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>(</head><label></label><figDesc>T-FIELD): Δ; P e0 : T0 Δ T OK fields(boundΔ(T0)) = T f T = [thisP (e0)/This]Ti Δ; P e0.fi : T (T-FIELD-SET): Δ; P e0 : T0 Δ; P e : T Δ T OK fields(boundΔ(T0)) = T f T = [thisP (e0)/This]Ti Δ; P e0.fi = e : T (T-METHOD):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. FGO Expression Typing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. FGO Method and Class Typing with Placeholder Owners Function</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>dom(S) S = S[l → null] |null| = |fields(N)| new N(), S → l, S (R-FIELD): S[l] = N(v) fields(N) = T f l.fi, S → vi, S (R-FIELD-SET):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 15 .</head><label>15</label><figDesc>Figure 15. FGO Reduction Rules</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Owner class T is inside (≺) owner class T' if and only if Δ T T World. Theorem (Ownership Invariant). l refers to l' only if This l ≺ owner Δ(l ) or (owner Δ(l ) = πC and visibleΔ(πC, Δ(l))). Proof. Δ(l ) [This/This l ] Ti. If owner is World or This, then we are OK by definition of ≺. If owner is anything else then since well-formedness preserves owner class nesting and This Owner O (where O is the set of owners of type parameters) holds, we have This l This l . The second part of the proof holds due to the confinement invariant (below). Theorem (Confinement Invariant). Let e be a subexpression appearing in the body of a method of a well-formed FGO class C during program execution. Then: If e → * new D &lt; TD &gt;(e), then visibleΔ(D &lt; TD &gt;, C).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>D</head><label></label><figDesc>&lt; TD &gt;, and hence clearly Δ D &lt; TD &gt; T , and Δ D &lt; TD &gt; T. By the Ownership Invariance lemma, owner Δ(D &lt; TD &gt;) = owner Δ(T), from which we deduce visibleΔ(owner Δ(D &lt; TD &gt;), C), and hence visibleΔ(D &lt; TD &gt;, C).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure 1. A Java implementation of a Map class provide ownership types. Our goal is also different to other recent ownership types work</figDesc><table><row><cell>public class Map {</cell></row><row><cell>private Vector nodes;</cell></row><row><cell>void put(Comparable key, Object value) {</cell></row><row><cell>nodes.add(new Node(key, value));</cell></row><row><cell>}</cell></row><row><cell>Object get(Comparable k) {</cell></row><row><cell>Iterator i = nodes.iterator();</cell></row><row><cell>while (i.hasNext()) {</cell></row><row><cell>Node mn = (Node) i.next();</cell></row><row><cell>if (((Comparable) mn.key).equals(k))</cell></row><row><cell>return mn.value;</cell></row><row><cell>}</cell></row><row><cell>return null;</cell></row><row><cell>}</cell></row><row><cell>}</cell></row><row><cell>class Node {</cell></row><row><cell>public Object key; public Object value;</cell></row><row><cell>Node(Object key, Object value) {</cell></row><row><cell>this.key = key; this.value = value;</cell></row><row><cell>}</cell></row><row><cell>}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>1, 2, and 3. This code now has both type and ownership parameters, public class Map&lt;Key extends Comparable&lt;KOwner&gt;, Value extends Object&lt;VOwner&gt;, Owner extends World&gt; { private Vector&lt;Node&lt;Key, Value, This&gt;, This&gt; nodes; public void put(Key key, Value value) { nodes.add((new Node&lt;Key, Value, This&gt;()).</figDesc><table><row><cell>init(key, value));</cell></row><row><cell>}</cell></row><row><cell>public Value get(Key key) {</cell></row><row><cell>Iterator&lt;Node&lt;Key, Value, This&gt;, This&gt; i =</cell></row><row><cell>nodes.iterator();</cell></row><row><cell>while (i.hasNext()) {</cell></row><row><cell>Node&lt;Key, Value, This&gt; mn = i.next();</cell></row><row><cell>if (mn.key.equals(key))</cell></row><row><cell>return mn.value;</cell></row><row><cell>}</cell></row><row><cell>return null;</cell></row><row><cell>}</cell></row><row><cell>}</cell></row><row><cell>class Node&lt;Key extends Comparable&lt;KOwner&gt;,</cell></row><row><cell>Value extends Object&lt;VOwner&gt;,</cell></row><row><cell>Owner extends World&gt; {</cell></row><row><cell>public Key key; public Value value;</cell></row><row><cell>public void init(Key key, Value value) {</cell></row><row><cell>this.key = key; this.value = value;</cell></row><row><cell>}</cell></row><row><cell>}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>public class Map&lt;KO extends World, VO extends World, Key extends Comparable&lt;KO&gt;, Value extends Object&lt;VO&gt;, Owner extends World&gt; { ... }because the owners are bound implicitly. The implicit binding is generally sufficient: we find that ownership and type parameters are hardly ever used independently. For example, if a programmer wished to produce a specialised version of a map class (MyMap) that was not type generic -say it could store only names and addresses -but which needed to be ownership generic, additional type parameters (NameO, AdrO) bound by World can be declared explicitly to carry the ownership for names and addresses.On the other hand, given that the MyMap class requires three parameters anyway, standard OGJ style is to declare two bound generic parameters, and always instantiate those parameters with the same types as their bounds (although, for ownership polymorphism, with different owners):</figDesc><table><row><cell cols="2">class MyMap&lt;NameO extends World,</cell></row><row><cell cols="2">AdrO extends World, Owner extends World&gt; {</cell></row><row><cell>void</cell><cell>put(Name&lt;NameO&gt; n, Address&lt;AdrO&gt; a);</cell></row><row><cell cols="2">Address get(Name&lt;NameO&gt; n);</cell></row><row><cell cols="2">List&lt;Name&lt;NameO&gt;, World&gt;</cell></row><row><cell cols="2">getAllPeopleOnThisStreet(String s);</cell></row><row><cell>}</cell><cell></cell></row><row><cell cols="2">class MyMap&lt;MyName extends Name&lt;NameO&gt;,</cell></row><row><cell></cell><cell>MyAddress extends Address&lt;AdrO&gt;,</cell></row><row><cell></cell><cell>Owner extends World&gt; {</cell></row><row><cell>void</cell><cell>put(MyName n, MyAddress a);</cell></row><row><cell cols="2">Address get(MyName n);</cell></row><row><cell cols="2">List&lt;MyName, World&gt;</cell></row><row><cell cols="2">getAllPeopleOnThisStreet(String s);</cell></row><row><cell>}</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>http://www.archjava.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>http://www.mcs.vuw.ac.nz/ ˜alex/ogj/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Thanks to many anonymous reviewers for their comments, and especially for providing a number of excellent examples. Thanks to Phil Wadler for encouraging us to publish this work. Thanks to Chris Andreae for keeping us on our toes by providing an alternative implementation of Generic Ownership in JavaCOP <ref type="bibr" target="#b3">[4]</ref>. This work is partially supported by the EPSRC grant Practical Ownership Types for Objects and Aspect Programs, EP/D061644/1. This work is also supported by the Royal Society of New Zealand Marsden Fund.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>variables to their types, mappings from type variables to nonvariable types, and the types of the locations. There is no explicit constructor declaration: fields are initialised to null. This is important because the ownership types mean that objects owned by This cannot be constructed outside the object to which they belong.</p><p>FGO's additions to FGJ syntax include the locations (l), the store (S) and adding location types to the environment (Δ). The expression l&gt; e represents the expression e resulting from reducing a method call with the receiver object allocated at the location l in the store S -this allows us to type the occurrences of this expression. We use CT (class table) to denote a mapping from class names C to class declarations L, and (permission) to denote a class or a location. Permissions are used to implement object ownership using this function described in Section 4.3. FGO also adopts the syntactical idiosyncrasies of FGJ, such as T x denoting a list of pairs: T1 x1, . . . , Tn xn, rather than two lists of types and variables.</p><p>FGO ownership types are just types, but we assume that owners are syntactically distinguishable:</p><p>where O ranges over all owners, X O ranges over owner variables, and N O ranges over nonvariable owners such as World and This, as well as the owner classes corresponding to packages. We use capitals (P) for the owner class corresponding to a lower case package name (p). We use subscript (This l ) for the owner class corresponding to the owner of an object at location l. Pure FGO types and classes are written to include an owner class as their last  While the last type parameter is distinguished to make it easy to identify the owner of a particular instance, other type parameters can be "naked" owners as well as type parameters with no syntactic distinction made by the type system. FGO makes use of a number of functions to simplify the presentation:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Theory of Objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin, Heidelberg, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Ownership Domains: Separating Aliasing Policy from Mechanism</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Object-Oriented Programming (ECOOP)</title>
		<meeting>European Conference on Object-Oriented Programming (ECOOP)<address><addrLine>Oslo, Norway; Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-06">June 2004</date>
			<biblScope unit="volume">3086</biblScope>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Alias Annotations for Program Understanding</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kostadinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Seattle, WA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002-11">Nov. 2002</date>
			<biblScope unit="page" from="311" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A framework for implementing pluggable type systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Andreae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Markstrum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Portland, Oregon, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Unify and Conquer (Garbage, Updating, Aliasing) in Functional Languages</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">G</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1990 ACM Conf. on Lisp and Functional Programming</title>
		<meeting>1990 ACM Conf. on Lisp and Functional Programming<address><addrLine>Nice, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="218" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Verification of object-oriented programs with invariants</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fahndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Formal Techniques for Java-like Programs in European Conference on Object-Oriented Programming (FTfJP)</title>
		<meeting>the Workshop on Formal Techniques for Java-like Programs in European Conference on Object-Oriented Programming (FTfJP)<address><addrLine>Darmstadt, Germany; Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003-07">July 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><surname>Safejava</surname></persName>
		</author>
		<title level="m">A Unified Type System for Safe Programming</title>
		<imprint>
			<date type="published" when="2004-02">February 2004</date>
		</imprint>
		<respStmt>
			<orgName>EECS, MIT</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Ownership types for safe programming: Preventing data races and deadlocks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</meeting>
		<imprint>
			<date type="published" when="2002-11">November 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Safe runtime downcasts with ownership types</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Workshop on Aliasing, Confinement, and Ownership (IWACO)</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</editor>
		<meeting>International Workshop on Aliasing, Confinement, and Ownership (IWACO)</meeting>
		<imprint>
			<date type="published" when="2003-07">July 2003</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
		<respStmt>
			<orgName>Ed. Utrecht University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Ownership Types for Object Encapsulation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shrira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Principles of Programming Languages (POPL)</title>
		<meeting>ACM Symposium on Principles of Programming Languages (POPL)<address><addrLine>New Orleans, LA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003-01">Jan. 2003</date>
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
	<note>Invited talk by Barbara Liskov</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Parameterized Type System for Race-Free Java Programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Tampa Bay, FL, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="56" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Checking interference with fractional permissions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boyland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Static Analysis: 10th International Symposium</title>
		<meeting><address><addrLine>Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="55" to="72" />
		</imprint>
	</monogr>
	<note>Computer Science (LNCS)</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Connecting effects and uniqueness with adoption</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Boyland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Reter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Principles of Programming Languages (POPL</title>
		<meeting>ACM Symposium on Principles of Programming Languages (POPL</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Making the future safe for the past: Adding Genericity to the Java programming language</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stoutamire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</meeting>
		<imprint>
			<date type="published" when="1998-10">Oct. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An objectoriented approach to non-uniform cluster computing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Charles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Donawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ebcioglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Grothoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kielstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Praun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Object Ownership and Containment</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">School of CSE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Australia</publisher>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Encapsulation, and the Disjointness of Type and Effect</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><surname>Ownership</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Seattle, WA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002-11">Nov. 2002</date>
			<biblScope unit="page" from="292" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Ownership Types for Flexible Alias Protection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Potter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Vancouver, Canada; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998-10">Oct. 1998</date>
			<biblScope unit="page" from="48" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Saving the World from Bad Beans: Deployment-Time Confinement Checking</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Richmond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Anaheim, CA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="374" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">External Uniqueness is Unique Enough</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wrigstad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Object-Oriented Programming (ECOOP)</title>
		<meeting>European Conference on Object-Oriented Programming (ECOOP)<address><addrLine>Darmstadt, Germany; Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003-07">July 2003</date>
			<biblScope unit="page" from="176" to="200" />
		</imprint>
	</monogr>
	<note>2473 of Lecture Notes in Computer Science (LNCS)</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Type-based alias analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Diwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Phantom Types and Subtyping</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fluet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pucella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theoretical Computer Science (TCS)</title>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
			<biblScope unit="page" from="448" to="460" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Region-based memory management in cyclone</title>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="282" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Encapsulating Objects with Confined Types</title>
		<author>
			<persName><forename type="first">C</forename><surname>Grothoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Tampa Bay, FL, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="241" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Aliasing Protection in Object-Oriented Languages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hogg</surname></persName>
		</author>
		<author>
			<persName><surname>Islands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Phoenix, AZ, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1991-11">Nov. 1991</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="271" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The Geneva convention of the treatment of object aliasing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hogg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wills</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>De Champeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Holt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OOPS Messenger</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="11" to="16" />
			<date type="published" when="1992-04">April 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Featherweight Java: a minimal core calculus for Java and GJ</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="396" to="450" />
			<date type="published" when="2001-05">May 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A recipe for raw types</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Workshop on Foundations of Object-Oriented Languages (FOOL</title>
		<meeting>Workshop on Foundations of Object-Oriented Languages (FOOL</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Generalized algebraic data types and object-oriented programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Russo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The design and implementation of Generics for the .NET Common Language Runtime</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Syme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Permission-based ownership: Encapsulating state in higher-order typed languages</title>
		<author>
			<persName><forename type="first">N</forename><surname>Krishnaswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Aldrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)<address><addrLine>Chicago, UL, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="96" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Constraints: A uniform approach to aliasing and typing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Principles of Programming Languages (POPL)</title>
		<meeting>ACM Symposium on Principles of Programming Languages (POPL)<address><addrLine>New Orleans, Louisiana</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="205" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Object invariants in dynamic contexts</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Object-Oriented Programming</title>
		<meeting>European Conference on Object-Oriented Programming<address><addrLine>Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A type system for reachability and acyclicity</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Object-Oriented Programming (ECOOP) (2005)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>European Conference on Object-Oriented Programming (ECOOP) (2005)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">3586</biblScope>
			<biblScope unit="page" from="479" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Flexible ownership types with owner variance</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Object-Oriented Programming</title>
		<meeting>European Conference on Object-Oriented Programming</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Protecting representation with effect encapsulation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Principles of Programming Languages (POPL</title>
		<meeting>ACM Symposium on Principles of Programming Languages (POPL</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Theory of type polymorphism in programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="348" to="375" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The runtime structure of object ownership</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Object-Oriented Programming (ECOOP)</title>
		<title level="s">Lecture Notes in Computer Science (LNCS</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Thomas</surname></persName>
		</editor>
		<meeting>European Conference on Object-Oriented Programming (ECOOP)<address><addrLine>Nantes, France; Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006-07">July 2006</date>
			<biblScope unit="volume">4067</biblScope>
			<biblScope unit="page" from="74" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Universes: a Type System for Controlling Representation Exposure</title>
		<author>
			<persName><forename type="first">P</forename><surname>Üller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poetzsch-Heffter</surname></persName>
		</author>
		<editor>Poetzsch-Heffter, A. and Meyer, J.</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Fernuniversität Hagen</publisher>
		</imprint>
	</monogr>
	<note>Programming Languages and Fundamentals of Programming</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Flexible Alias Protection</title>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Object-Oriented Programming (ECOOP)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Jul</surname></persName>
		</editor>
		<meeting>European Conference on Object-Oriented Programming (ECOOP)<address><addrLine>Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998-07">July 1998</date>
			<biblScope unit="volume">1445</biblScope>
			<biblScope unit="page" from="158" to="185" />
		</imprint>
	</monogr>
	<note>Lecture Notes in Computer Science (LNCS)</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Lackwit: a program understanding tool based on type inference</title>
		<author>
			<persName><forename type="first">O'</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering (ICSE)</title>
		<meeting>the International Conference on Software Engineering (ICSE)<address><addrLine>Boston, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">A type system for preventing data races and deadlocks in the java virtual machine language</title>
		<author>
			<persName><forename type="first">P</forename><surname>Permandla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>University of Michigan</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Types and Programming Languages</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Ownership Generic Java Download</title>
		<author>
			<persName><forename type="first">A</forename><surname>Potanin</surname></persName>
		</author>
		<ptr target="http://www.mcs.vuw.ac.nz/˜alex/ogj/" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Defaulting Generic Java to Ownership</title>
		<author>
			<persName><forename type="first">A</forename><surname>Potanin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Biddle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Formal Techniques for Java-like Programs in European Conference on Object-Oriented Programming (FTfJP)</title>
		<meeting>the Workshop on Formal Techniques for Java-like Programs in European Conference on Object-Oriented Programming (FTfJP)<address><addrLine>Oslo, Norway; Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Featherweight Generic Ownership</title>
		<author>
			<persName><forename type="first">A</forename><surname>Potanin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Biddle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Formal Techniques for Java-like Programs in European Conference on Object-Oriented Programming (FTfJP)</title>
		<meeting>the Workshop on Formal Techniques for Java-like Programs in European Conference on Object-Oriented Programming (FTfJP)<address><addrLine>Glasgow, Scotland; Berlin, Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005-07">July 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Featherweight Generic Confinement</title>
		<author>
			<persName><forename type="first">A</forename><surname>Potanin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Biddle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>Accepted for publication</note>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Featherweight generic ownership</title>
		<author>
			<persName><forename type="first">A</forename><surname>Potanin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Biddle</surname></persName>
		</author>
		<ptr target="http://www.mcs.vuw.ac.nz/˜alex/FGOTR.pdf" />
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Victoria University of Wellington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Find Bugs -A Bug Pattern Detector for Java</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pugh</surname></persName>
		</author>
		<ptr target="www.cs.umd.edu/˜pugh/jva/bugs/" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Microsystems</forename><forename type="middle">Java</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kit</forename><surname>Development</surname></persName>
		</author>
		<ptr target="http://java.sun.com/j2se/" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Polymorphic type, region, and effect inference</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Talpin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jouvelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="271" />
			<date type="published" when="1992-07">July 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Region-Based Memory Management</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tofte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Talpin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">132</biblScope>
			<biblScope unit="page" from="109" to="176" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Adding wildcards to the Java programming language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Torgerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Von Der Ah É</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gafter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object Technology</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="97" to="116" />
			<date type="published" when="2004-12">Dec. 2004</date>
		</imprint>
	</monogr>
	<note>Special Issue: OOPS track at SAC 2004</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Confined Types in Java</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bokowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Practice &amp; Experience</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="507" to="532" />
			<date type="published" when="2001-05">May 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Type-Based Confinement</title>
		<author>
			<persName><forename type="first">T</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="83" to="128" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
