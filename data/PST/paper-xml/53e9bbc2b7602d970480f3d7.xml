<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Semantics and Evaluation of Top-k Queries in Probabilistic Databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xi</forename><surname>Zhang</surname></persName>
							<email>xizhang@cse.buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution" key="instit1">University at Buffalo</orgName>
								<orgName type="institution" key="instit2">SUNY</orgName>
								<address>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Chomicki</surname></persName>
							<email>chomicki@cse.buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution" key="instit1">University at Buffalo</orgName>
								<orgName type="institution" key="instit2">SUNY</orgName>
								<address>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Semantics and Evaluation of Top-k Queries in Probabilistic Databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">71FA45774D167EF3EC4C732F244C37F5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We formulate three intuitive semantic properties for top-k queries in probabilistic databases, and propose Global-Topk query semantics which satisfies all of them. We provide a dynamic programming algorithm to evaluate top-k queries under Global-Topk semantics in simple probabilistic relations. For general probabilistic relations, we show a polynomial reduction to the simple case. Our analysis shows that the complexity of query evaluation is linear in k and at most quadratic in database size.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The study of incompleteness and uncertainty in databases has long been an interest of the database community <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>. Recently, this interest has been rekindled by an increasing demand for managing rich data, often incomplete and uncertain, emerging from scientific data management, sensor data management, data cleaning, information extraction etc. <ref type="bibr" target="#b7">[8]</ref> focuses on query evaluation in traditional probabilistic databases; ULDB <ref type="bibr" target="#b8">[9]</ref> supports uncertain data and data lineage in Trio <ref type="bibr" target="#b9">[10]</ref>; <ref type="bibr">MayBMS [11]</ref> uses the vertical World-Set representation of uncertain data <ref type="bibr" target="#b10">[12]</ref>. The standard semantics adopted in most works is the possible worlds semantics <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b10">[12]</ref>.</p><p>On the other hand, since the seminal papers of Fagin <ref type="bibr" target="#b11">[13]</ref>, <ref type="bibr" target="#b12">[14]</ref>, the top-k problem has been extensively studied in multimedia databases <ref type="bibr" target="#b13">[15]</ref>, middleware systems <ref type="bibr" target="#b14">[16]</ref>, data cleaning <ref type="bibr" target="#b15">[17]</ref>, core technology in relational databases <ref type="bibr" target="#b16">[18]</ref>, <ref type="bibr" target="#b17">[19]</ref> etc. In the top-k problem, each tuple is given a score, and users are interested in the k tuples with the highest score. More recently, the top-k problem has been studied in probabilistic databases <ref type="bibr" target="#b18">[20]</ref>, <ref type="bibr" target="#b19">[21]</ref>. Those papers, however, are solving two essentially different top-k problems. Soliman et al. <ref type="bibr" target="#b18">[20]</ref> assumes the existence of a scoring function to rank tuples. Probabilities provide information on how likely tuples will appear in the database. In contrast, in <ref type="bibr" target="#b19">[21]</ref>, the ranking criterion for top-k is the probability associated with each query answer. In many applications, it is necessary to deal with tuple probabilities and scores at the same time. Thus, in this paper, we use the model of <ref type="bibr" target="#b18">[20]</ref>. Even in this model, different semantics for top-k queries are possible, so a part of the challenge is to define a reasonable semantics.</p><p>As a motivating example, the following smart environment scenario is inspired by the work in <ref type="bibr" target="#b20">[22]</ref>.</p><p>Example 1: A smart lab has the following data from a Saturday night: Typically, the lab collects two kinds of data: biometric data from sensors and historical statistics. Biometric data comes from the sensors deployed in the lab, for example, face recognition and voice recognition sensors. This data is collected and matched against the profile of each person involved in the lab. It can be further normalized to give us an idea of how well each person fits the sensed data. In addition, the lab also keeps track of the statistics of each person's activities.</p><p>Knowing that we definitely had two visitors that night, we would like to ask the following question: "Who were the two visitors in the lab last Saturday night?" This question can be formulated as a top-k query over the above probabilistic relation, where k = 2.</p><p>In Example 1, each tuple is associated with an event, which is that candidate being in the lab on Saturday nights. The probability of the event is shown next to each tuple. In this example, all the events of tuples are independent, and tuples are therefore said to be independent. Intuitively, for the top-k problem in Example 1, we are not necessarily interested in candidates with high biometric scores if the associated events are very unlikely to happen, e.g. we have strong evidence suggesting that a candidate plays football on Saturday nights and his probability of being in lab is 0.001.</p><p>Example 1 shows a simple probabilistic relation where the tuples are independent. In contrast, Example 2 illustrates a more general case.</p><p>Example 2: In a sensor network deployed in a habitat, each sensor reading comes with a confidence value Prob, which is the probability that the reading is valid. The following table shows the temperature sensor readings at a given sampling time. These data are from two sensors, Sensor 1 and Sensor 2, which correspond to two parts of the relation, marked C 1 and C 2 respectively. Each sensor has only one true reading at a given time, therefore tuples from the same part of the relation correspond to exclusive events. Our question is: "What's the temperature of the warmest spot?"</p><p>The question can be formulated as a top-k query, where k = 1, over a probabilistic relation containing the above data. However, we must take into consideration that the tuples in each part C i , i = 1, 2, are exclusive.</p><p>Our contributions in this paper are the following:</p><p>• We formulate three intuitive semantic properties and use them to compare different top-k semantics in probabilistic databases (Section III-A); • We propose a new semantics for top-k queries in probabilistic databases, called Global-Topk, which satisfies all the properties above (Section III-B); • We exhibit efficient algorithms for evaluating top-k queries under the Global-Topk semantics in simple probabilistic databases (Section IV-A) and general probabilistic databases (Section IV-C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Probabilistic Relations</head><p>To simplify the discussion in this paper, a probabilistic database contains a single probabilistic relation. We refer to a traditional database relation as a deterministic relation. A deterministic relation R is a set of tuples. A partition C of R is a collection of non-empty subsets of R such that every tuple belongs to one and only one of the subsets. That is,</p><formula xml:id="formula_0">C = {C 1 , C 2 , . . . , C m } such that C 1 ∪ C 2 ∪ . . . ∪ C m = R and C i ∩ C j = ∅, 1 ≤ i = j ≤ m. Each subset C i , i = 1, 2, . . . , m</formula><p>is a part of the partition C. A probabilistic relation R p has three components, a support (deterministic) relation R, a probability function p and a partition C of the support relation R. The probability function p maps every tuple in R to a probability value in (0, 1]. The partition C divides R into subsets such that the tuples within each subset are exclusive and therefore their probabilities sum up to at most 1. In the graphical presentation of R, we use horizontal lines to separate tuples from different parts.</p><p>Definition 2.1 (Probabilistic Relation): A probabilistic relation R p is a triplet R, p, C , where R is a support deterministic relation, p is a probability function p : R → (0, 1] and C is a partition of R such that ∀C i ∈ C, t∈Ci p(t) ≤ 1.</p><p>In addition, we make the assumption that tuples from different parts of of C are independent, and tuples within the same part are exclusive. Def. 2.1 is equivalent to the model used in Soliman et al. <ref type="bibr" target="#b18">[20]</ref> with exclusive tuple generation rules. Ré et al. <ref type="bibr" target="#b19">[21]</ref> proposes a more general model, however only a restricted model equivalent to Def. 2.1 is used in top-k query evaluation. Example 2 shows an example of a probabilistic relation whose partition has two parts. Generally, each part corresponds to a real world entity, in this case, a sensor. Since there is only one true state of an entity, tuples from the same part are exclusive. Moreover, the probabilities of all possible states of an entity sum up to at most 1. In Example 2, the sum of probabilities of the tuples from Sensor 1 is 1, while that from Sensor 2 is 0.7. This can happen for various reasons. In the above example, we might encounter a physical difficulty in collecting the sensor data, and end up with partial data.</p><p>Definition 2.2 (Simple Probabilistic Relation): A probabilistic relation R p = R, p, C is simple iff the partition C contains only singleton sets.</p><p>The probablistic relation in Example 1 is simple (individual parts not illustrated). Note that in this case, |R| = |C|.</p><p>We adopt the well-known possible worlds semantics for probabilistic relations <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b10">[12]</ref>.</p><formula xml:id="formula_1">Definition 2.3 (Possible World): Given a probabilistic rela- tion R p = R, p, C , a deterministic relation W is a possible world of R p iff 1)</formula><p>W is a subset of the support relation, i.e. W ⊆ R;</p><p>2) For every part C i in the partition C, at most one tuple</p><formula xml:id="formula_2">from C i is in W , i.e. ∀C i ∈ C, |C i ∩ W | ≤ 1.</formula><p>Denote by pwd(R p ) the set of all possible worlds of R p . Since all the parts in C are independent, we have the following definition of the probability of a possible world.</p><p>Definition 2.4 (Probability of a Possible World): Given a probabilistic relation R p = R, p, C , for any W ∈ pwd(R p ), its probability P r(W ) is defined as</p><formula xml:id="formula_3">P r(W ) = t∈W p(t) Ci∈C (1 - t∈Ci p(t))<label>(1)</label></formula><p>where</p><formula xml:id="formula_4">C = {C i ∈ C|W ∩ C i = ∅}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Scoring Functions</head><p>A scoring function over a deterministic relation R is a function from R to real numbers, i.e. s : R → R. The function s induces a preference relation s and an indifference relation ∼ s on R. For any two distinct tuples t i and t j from R,</p><formula xml:id="formula_5">t i s t j iff s(t i ) &gt; s(t j ); t i ∼ s t j iff s(t i ) = s(t j ).</formula><p>When the scoring function s is injective, s establishes a total order, i.e. an irreflective, transitive, connected binary relation, over R. In such a case, no two tuples from R tie in score.</p><p>A scoring function over a probabilistic relation R p = R, p, C is a scoring function s over its support relation R. </p><formula xml:id="formula_6">T ⊆ R; 2) If |R| &lt; k, T = R, otherwise |T | = k; 3) ∀t ∈ T, ∀t ∈ R -T, t s t or t ∼ s t .</formula><p>According to Def. 2.5, given k and s, there can be more than one top-k answer set in a deterministic relation R. The evaluation of a top-k query over R returns one of them nondeterministically, say S. However, if the scoring function s is injective, S is unique, denoted by top k,s (R).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SEMANTICS OF TOP-K QUERIES A. Semantic Properties of Top-k Answers</head><p>Probability opens the gates for various possible semantics for top-k queries. As the semantics of a probabilistic relation involves a set of worlds, it is to be expected that there may be more than one top-k answer, even under an injective scoring function. The answer to a top-k query over a probabilistic relation R p = R, p, C should clearly be a set of tuples from its support relation R. In order to compare different semantics, we formulate below some properties we would like any reasonable semantics to satisfy.</p><p>In the following discussion, S is any top-k answer set in R p = R, p, C under an injective scoring function s. A tuple from the support relation R is a winner if it belongs to some top-k answer set under that semantics, and a loser otherwise. That is to say, in the case of multiple top-k answer sets, any tuple from any of them is a winner. Properties 1) Exact k: When R p is sufficiently large (|C| ≥ k), the cardinality of S is exactly k; 2) Faithfulness: For any two tuples t 1 , t 2 ∈ R, if both the score and the probability of t 1 are higher than those of t 2 and t 2 ∈ S, then t 1 ∈ S; 3) Stability:</p><p>• Raising the score/probability of a winner will not turn it into a loser; • Lowering the score/probability of a loser will not turn it into a winner. All of those properties reflect basic intuitions about top-k answers. Exact k expresses user expectations about the size of the result. Faithfulness and Stability reflect the significance of score and probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Global-Topk Semantics</head><p>We propose here a new top-k answer semantics in probabilistic relations, namely Global-Topk, which satisfies all the properties formulated in Section III-A:</p><p>• Global-Topk: return k highest-ranked tuples according to their probability of being in the top-k answers in possible worlds. Considering a probabilistic relation R p = R, p, C under an injective scoring function s, any W ∈ pwd(R p ) has a unique top-k answer set top k,s (W ). Each tuple from the support relation R can be in the top-k answer (in the sense of Def. 2.5) in zero, one or more possible worlds of R p . Therefore, the sum of the probabilities of those possible worlds provides a global ranking criterion.</p><p>Definition 3.1 (Global-Topk Probability): Assume a probabilistic relation R p = R, p, C , a non-negative integer k and an injective scoring function s over R p . For any tuple t in R, the Global-Topk probability of t, denoted by P R p k,s (t), is the sum of the probabilities of all possible worlds of R p whose top-k answer contains t.</p><formula xml:id="formula_7">P R p k,s (t) = W ∈pwd(R p ) t∈top k,s (W ) P r(W ).</formula><p>For simplicity, we skip the superscript in P R p k,s (t), i.e. P k,s (t), when the context is unambiguous. Definition 3.2: (Global-Topk Answer Set over Probabilistic Relation): Given a probabilistic relation R p = R, p, C , a non-negative integer k and an injective scoring function s over R p , a top-k answer in R p under s is a set T of tuples such that 1)</p><formula xml:id="formula_8">T ⊆ R; 2) If |R| &lt; k, T = R, otherwise |T | = k; 3) ∀t ∈ T, ∀t ∈ R -T, P k,s (t) ≥ P k,s (t ).</formula><p>Notice the similarity between Def. 3.2 and Def. 2.5. In fact, the probabilistic version only changes the last condition, which restates the preferred relationship between two tuples by taking probability into account. This semantics preserves the nondeterministic nature of Def. 2.5. For example, if two tuples are of the same Global-Topk probability, and there are k -1 tuples with higher Global-Topk probability, Def. 2.5 allows one of the two tuples to be added to the top-k answer nondeterministically. Example 3 gives an example of the Global-Topk semantics.</p><p>Example 3: Consider the top-2 query in Example 1. Clearly, the scoring function here is the biometric scoring function. The following table shows all the possible worlds and their probabilities. For each world, the underlined people are in the top-2 answer set of that world.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Possible World</head><p>Prob</p><formula xml:id="formula_9">W 1 = ∅ 0.042 W 2 = {Aidan} 0.018 W 3 = {Bob} 0.378 W 4 = {Chris} 0.028 W 5 = {Aidan, Bob} 0.162 W 6 = {Aidan, Chris} 0.012 W 7 = {Bob, Chris} 0.252 W 8 = {Aidan, Bob, Chris} 0.108</formula><p>Chris is in the top-2 answer of W 4 , W 6 , W 7 , so its top-2 probability is 0.028 + 0.012 + 0.252 = 0.292. Similarly, the top-2 probability of Aidan and Bob are 0.9 and 0.3 respectively. 0.9 &gt; 0.3 &gt; 0.292, therefore Global-Topk will return {Aidan, Bob}.</p><p>Note that top-k answer sets may be of cardinality less than k for some possible worlds. We refer to such possible worlds as small worlds. In Example 3, W 1...4 are all small worlds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Other Semantics</head><p>Soliman et al. <ref type="bibr" target="#b18">[20]</ref> proposes two semantics for top-k queries in probabilistic relations.</p><p>• U-Topk: return the most probable top-k answer set that belongs to possible world(s);</p><p>• U-kRanks: for i = 1, 2, . . . , k, return the most probable i th -ranked tuples across all possible worlds.</p><p>Example 4: Continuing Example 3, under U-Topk semantics, the probability of top-2 answer set {Bob} is 0.378, and that of {Aidan, Bob} is 0.162 + 0.108 = 0.27. Therefore, {Bob} is more probable than {Aidan, Bob} under U-Topk. In fact, {Bob} is the most probable top-2 answer set in this case, and will be returned by U-Topk.</p><p>Under U-kRanks semantics, Aidan is in 1 st place in the top-2 answer of W 2 , W 5 , W 6 , W 8 , therefore the probability of Aidan being in 1 st place in the top-2 answers in possible worlds is 0.018 + 0.162 + 0.012 + 0.108 = 0.3. However, Aidan is not in 2 nd place in the top-2 answer of any possible world, therefore the probability of Aidan being in 2 nd place is 0. In fact, we can construct the following table.</p><p>Aidan Bob Chris Rank 1 0.3 0.63 0.028 Rank 2 0 0.27 0.264 U-kRanks selects the tuple with the highest probability at each rank (underlined) and takes the union of them. In this example, Bob wins at both Rank 1 and Rank 2. Thus, the top-2 answer returned by U-kRanks is {Bob}.</p><p>The properties introduced in Section III-A lay the ground for comparing different semantics. In Table <ref type="table">I</ref>, a single " " (resp. "×") indicates that property is (resp. is not) satisfied under that semantics. " /×" indicates that, the property is satisfied by that semantics in simple probabilistic relations, but not in the general case. Global-Topk satisfies all the properties while neither of the other two semantics does. For Exact k, Global-Topk is the only one that satisfies this property. Example 4 illustrates the case when both U-Topk and U-kRanks violate this property. It is not satisfied by U-Topk because a small possible world with high probability could dominate other worlds. In that case, the dominating possible world might not have enough tuples. It is also violated by U-kRanks because a single tuple can win at multiple ranks in U-kRanks. For Faithfulness, since U-Topk requires all tuples in a top-k answer set to be compatible, this property can be violated when a high-score/probability tuple could be dragged down arbitrarily by its compatible tuples if they are not very likely to appear. U-kRanks violates both Faithfulness and Stability. Under U-kRanks, instead of a set, a top-k answer is an ordered vector, where ranks are significant. A change in a tuple's probability/score might have unpredictable consequence on ranks, therefore those two properties are not guaranteed to hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. QUERY EVALUATION UNDER GLOBAL-TOPk</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Simple Probabilistic Relations</head><p>We first consider a simple probabilistic relation R p = R, p, C under an injective scoring function s.</p><p>Theorem 4.1: Given a simple probabilistic relation R p = R, p, C and an injective scoring function s over R p , if R = {t 1 , t 2 , . . . , t n } and t 1 s t 2 s . . . s t n , the following recursion on Global-Topk queries holds.</p><formula xml:id="formula_10">q(k, i) =        0 k = 0 p(t i ) 1 ≤ i ≤ k (q(k, i -1) p(ti-1)</formula><p>p(ti-1) + q(k -1, i -1))p(t i ) otherwise (2) where q(k, i) = P k,s (t i ) and p(t i-1 ) = 1 -p(t i-1 ).</p><p>Proof: (Sketch) Recall that top k,s (W ) is the unique topk answer set of a possible world W under s. In the trivial case when k = 0, top 0,s (W ) is an empty set for any W ∈ pwd(R p ). Therefore, q(0, i) = 0 for all t i , i = 1, 2, . . . n.</p><p>For any of the k tuples with the highest score in R, namely t 1 , t 2 , . . . , t k , whenever it appears in a possible world W , it would be in top k,s (W ). In other words, its Global-Topk probability equals to its tuple probability.</p><p>For any other tuple t i , i &gt; k, t i is in top k,s (W ) of a possible world W as long as there are no more than k -1 tuples with higher score in W . Moreover, in a simple probabilistic relation, Eqn. ( <ref type="formula" target="#formula_3">1</ref>) is equivalent to the following equation:</p><formula xml:id="formula_11">P r(W ) = t∈W p(t) t∈R-W p(t)<label>(3)</label></formula><p>Assume we know the Global-Topk probability of t i-1 , i.e. q(k, i -1), if we substitute t i-1 with t i in every world W contributing to q(k, i -1), t i will then be in the top-k answer of the new world. Those new worlds contribute to the first part of the third case in Eqn. <ref type="bibr" target="#b1">(2)</ref>. Assume we know the Global-Top(k -1) probability of t i-1 , i.e. q(k -1, i -1), for any world W contributing to q(k -1, i -1), if W contains t i , t i will also be in top k,s (W ). Those worlds contribute to the second part of the third case in Eqn. <ref type="bibr" target="#b1">(2)</ref>.</p><p>Example 5: Consider a simple probabilistic relation Given the recursion in Thm. 4.1, we can apply the standard dynamic programming (DP) technique, together with a priority queue, to select k tuples with the highest Global-Topk probability, as shown in Alg. 1. It is a one-pass computation on the probabilistic relation, which can be easily implemented even if secondary storage is used. The overhead is the initial sorting cost (not shown in Alg. 1), which would be amortized by the workload of consecutive top-k queries.</p><formula xml:id="formula_12">R p = R, p, C , where R = {t 1 , t 2 , t 3 , t 4 }, p(t i ) = p i , 1 ≤ i ≤ 4, C = {{t 1 }, {t 2 }, {t 3 },</formula><p>Algorithm 1 (Ind Topk) Evaluate Global-Topk queries in a Simple Probabilistic Relation Require: R p = R, p, C , k 1: Initialize a fixed cardinality (k + 1) priority queue Ans of t, prob pairs, which compares pairs on prob; 2: q(0, 1) = 0; 3: for k = 1 to k do 4:</p><p>q(k , 1) = p(t k ); 5: end for 6: for i = 2 to |R| do 7:</p><formula xml:id="formula_13">for k = 0 to k do 8: if k = 0 then 9: q(k , i) = 0; 10: else 11: q(k , i) = p(t i )(q(k , i -1) p(ti-1)</formula><p>p(ti-1) + q(k -1, i -1));</p><p>12:</p><formula xml:id="formula_14">end if 13:</formula><p>end for 14:</p><p>Add t i , q(k, i) to Ans;</p><formula xml:id="formula_15">15: if |Ans| &gt; k then 16:</formula><p>remove the pair with the smallest prob value from Ans;</p><p>17:</p><p>end if 18: end for 19: return {t i | t i , q(k, i) ∈ Ans};</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Threshold Algorithm Optimization</head><p>Fagin <ref type="bibr" target="#b12">[14]</ref> proposes Threshold Algorithm(T A) for processing top-k queries in a middleware scenario. In a middleware system, an object has m attributes. For each attribute, there is a sorted list ranking objects in the decreasing order of its score on that attribute. An aggregation function f combines the individual attribute scores x i , i=1, 2, . . . , m to obtain the overall object score f (x 1 , x 2 , . . . , x m ). An aggregation function is monotonic iff f (x 1 , x 2 , . . . , x m ) ≤ f (x 1 , x 2 , . . . , x m ) whenever x i ≤ x i for every i. Fagin <ref type="bibr" target="#b12">[14]</ref> shows that T A is cost-optimal in finding the top-k objects in such a system.</p><p>T A is guaranteed to work as long as the aggregation function is monotonic. For a simple probabilistic relation, if we regard score and probability as two special attributes, Global-Topk probability P k,s is an aggregation function of score and probability. The Faithfulness property in Section III-A implies the monotonicity of Global-Topk probability. Consequently, assuming that we have an index on probability as well, we can guide the dynamic programming(DP) in Alg. 1 by T A. Now, instead of computing all kn entries for DP, where n = |R|, the algorithm can be stopped as early as possible. A subtlety is that Global-Topk probability P k,s is only well-defined for t ∈ R, unlike in <ref type="bibr" target="#b12">[14]</ref>, where an aggregation function is well-defined over the domain of all possible attribute values. Therefore, compared to the original T A, we need to achieve the same behavior without referring to virtual tuples which are not in R.</p><p>U-Topk satisfies Faithfulness in simple probabilistic relations, but the candidates under U-Topk are sets not tuples and thus there is no counterpart of an aggregation function under U-Topk. Therefore, T A is not applicable. Neither is T A applicable to U-kRanks. Though we can define an aggregation function per rank, rank = 1, 2, . . . , k, for tuples under U-kRanks, the violation of Faithfulness in Table <ref type="table">I</ref> suggests a violation of monotonicity of those k aggregation functions.</p><p>Denote T and P for the list of tuples in the decreasing order of score and probability respectively. Following the convention in <ref type="bibr" target="#b12">[14]</ref>, t and p are the last value seen in T and P respectively.</p><p>Applying TA to Global-Topk Computation.</p><p>(1) Go down T list, and fill in entries in the DP table.</p><p>Specifically, for t = t j , compute the entries in the j th column up to the k th row. Add t j to the top-k answer set Ans, if any of the following conditions holds: (a) Ans has less than k tuples, i.e. |Ans| &lt; k;</p><p>(b) The Global-Topk probability of t j , i.e. q(k, j), is greater than the lower bound of Ans, i.e. LB Ans , where LB Ans = min ti∈Ans q(k, i). In the second case, we also need to drop the tuple with the lowest Global-Topk probability in order to keep the cardinality of Ans.</p><p>(2) After we have seen at least k tuples in T , we go down P list to find the first p whose tuple t has not been seen. Let p = p, and we can use p to estimate the threshold, i.e. upper bound (U P ) of the Global-Topk probability of any unseen tuple. Assume t = t i ,</p><formula xml:id="formula_16">U P = (q(k, i) p(t i ) p(t i ) + q(k -1, i))p.</formula><p>(3) If U P &gt; LB Ans , we can expect Ans will be updated in the future, so go back to <ref type="bibr" target="#b0">(1)</ref>. Otherwise, we can stop safely and report Ans. Theorem 4.2 (Correctness): Given a simple probabilistic relation R p = R, p, C , a non-negative integer k and an injective scoring function s over R p , the above T A-based algorithm correctly finds a top-k answer under Global-Topk semantics.</p><p>Proof: In every iteration of Step (2), say t = t i , for any unseen tuple t, s is an injective scoring function over R p , which only differs from s in the score of t. Under the function s , t i s t s t i+1 . If we evaluate the top-k query in R p under s instead of s, P k,s (t) = p(t) p U P . On the other hand, for any W ∈ pwd(R p ), W contributing to P k,s (t) implies that W contributes to P k,s (t), while the reverse is not necessarily true. So, we have P k,s (t) ≥ P k,s (t). Recall that p ≥ p(t), therefore U P ≥ p(t) p U P = P k,s (t) ≥ P k,s (t). The conclusion follows from the correctness of the original T A algorithm and Alg. 1.</p><p>The optimization above aims at an early stop. Bruno et al. <ref type="bibr" target="#b21">[23]</ref> carries out an extensive experimental study on the effectiveness of applying T A in RDBMS. They consider various aspects of query processing. Note that probability is typically supported as a special attribute in DBMS. One of their conclusions is that if at least one of the indices available for the attributes is a covering index, that is, it is defined over all other attributes and we can get the values of all other attributes directly without performing a primary index lookup, then the improvement by T A can be up to two orders of magnitude. The cost of building a useful set of indices once would be amortized by a large number of top-k queries that subsequently benefit form such indices. Even in the lack of covering indices, if the data is highly correlated, in our case, that means high-score tuples having high probabilities, T A would still be effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Arbitrary Probabilistic Relations</head><p>1) Induced Event Relation: In the general case of probabilistic relation, each part of of the partition C can contain more than one tuple. The crucial independence assumption in Alg. 1 no longer holds. However, even though tuples are not independent, parts of the partition C are. In the following definition , we assume an identifier function id. For any tuple t, id(t) is the identifier of the part where t belongs.</p><p>Definition 4.1 (Induced Event Relation): Given a probabilistic relation R p = R, p, C , an injective scoring function s over R p and a tuple t ∈ C id(t) ∈ C, the event relation induced by t, denoted by E p = E, p E , C E , is a probabilistic relation whose support relation E has only one attribute, Event. E and the probability function p E are defined by the following two generation rules:</p><p>• Rule 1: t et ∈ E and p E (t et ) = p(t);</p><p>• Rule 2:</p><formula xml:id="formula_17">∀C i ∈ C ∧ C i = C id(t) , [(∃t ∈ C i ∧ t s t) ⇒ (t e C i ∈ E) and p E (t e C i ) = t ∈Ci t s t p(t )].</formula><p>No other tuples belong to E. The partition C E is defined as the collection of singleton subsets of E.</p><p>Except for one special tuple generated by Rule 1, each tuple in the induced event relation (generated by Rule 2) represents an event e Ci associated with a part C i ∈ C. The probability of this event, denoted by p(t e C i ), is the probability that e Ci occurs. Given the tuple t, the event e Ci is defined as "some tuple from the part C i has the score higher than the score of t".</p><p>The role of the special tuple t et and its probability p(t) will become clear in Thm. <ref type="bibr" target="#b3">4</ref> For any part C i other than C id(t) (Line 3-8), we compute the probability of the event e Ci according to Def. 4.1. Since all the tuples from the same part are exclusive, this probability is the sum of the probabilities of all tuples that qualify in that part. Note that if no tuple from C i qualifies, this probability is zero. In this case, we do not care whether any tuple from C i will be in the possible world or not, since it does not have any influence on whether t will be in top-k or not. The corresponding event tuple is therefore excluded from E. By default, any probabilistic database assumes that any tuple not in the support relation is with probability zero. Line 9 uses Alg. Alg. 2 uses Alg. 3 as a subroutine and computes P R p k,s (t) for every tuple t ∈ R, then again uses a priority queue to select the final answer set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Complexity</head><p>For simple probabilistic relations, in Alg. 1, the DP computation takes O(kn) time and using a priority queue to maintain the k highest values takes O(nlogk). So altogether, Alg. 1 takes O(kn). The TA optimization will reduce the computation time on average, however the algorithm will still have the same complexity.</p><p>For general probabilistic relations, in Alg. 3, Line 3-8 takes O(n) to build E (we need to scan all tuples within each part). Line 9 uses DP in Alg. 1, which takes O(|E|k), where |E| is no more than the number of parts in partition C, which is in turn no more than n. So Alg. 3 takes O(kn). Alg. 2 repeats Alg. 3 n times, and the priority queue again takes O(n log k). Altogether, the complexity is O(kn 2 + n log k) = O(kn 2 ).</p><p>In <ref type="bibr" target="#b18">[20]</ref>, both U-Topk and U-kRanks take O(kn) in simple probabilistic relations, which is the same as Alg. 1. In the general case, U-Topk takes Θ(kmn k-1 log n) and U-kRanks takes Ω(mn k-1 ), where m is a rule engine factor. Both U-Topk and U-kRanks do not scale well with k, for the time complexity is already at least cubic when k ≥ 4. A detailed analysis is available in <ref type="bibr" target="#b22">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION</head><p>We study the semantic and computational problems for topk queries in probabilistic databases. We propose three desired properties for a top-k semantics, namely Exact k, Faithfulness and Stability. Our Global-Topk semantics satisfies all of them. We study the computational problem of query evaluation under Global-Topk semantics for simple and general probabilistic relations. For the former case, we propose a dynamic programming algorithm and effectively optimize it with Threshold Algorithm. In the latter case, we show a polynomial reduction to the simple case. In contrast to Soliman et al. <ref type="bibr" target="#b18">[20]</ref>, our approach satisfies intuitive semantic properties and can be implemented more efficiently. However, <ref type="bibr" target="#b18">[20]</ref> is of a more general model as it allows arbitrary tuple generation rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. FUTURE WORK</head><p>We note that the two dimensions of top-k queries in probabilistic databases, score and probability, are not treated equally: score is considered in an ordinal sense while probability is considered in a cardinal sense. One of the future directions would be to integrate strength of preference expressed by score into our framework. Another direction is to consider noninjective scoring functions. A preliminary study shows that this case is non-trivial, because it is not clear how to allocate the probability of a single possible world to different top-k answer sets. Other possible directions include top-k evaluation in other uncertain database models proposed in the literature <ref type="bibr" target="#b10">[12]</ref> and more general preference queries in probabilistic databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>Research supported by NSF grant IIS-0307434.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>C</head><label></label><figDesc>. Top-k Queries Definition 2.5: (Top-k Answer Set over Deterministic Relation): Given a deterministic relation R, a non-negative integer k and a scoring function s over R, a top-k answer in R under s is a set T of tuples such that 1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>{t 4 }} and an injective scoring function s such that t 1 s t 2 s t 3 s t 4 . The following table shows the Global-Topk of t i , where 0 ≤ k ≤ 2. Row 2 (bold) is each t i 's Global-Top2 probability. Now, if we are interested in top-2 answer in R p , we only need to pick the two tuples with the highest value in Row 2.</figDesc><table><row><cell>k t 1</cell><cell>t 2</cell><cell>t 3</cell><cell>t 4</cell></row><row><cell>0 0</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell>1 p 1</cell><cell cols="2">p1 p 2 p1 p2 p 3</cell><cell>p1 p2 p3 p 4</cell></row><row><cell cols="2">2 p 1 p 2</cell><cell cols="2">(p 2 + p1 p 2 )p 3 ((p 2 + p1 p 2 )p 3</cell></row><row><cell></cell><cell></cell><cell></cell><cell>+p 1 p2 p 3 )p 4</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>.3. Let us first look at an example of an induced event relation. Example 6: Given R p as in Example 2, we would like to construct the induced event relation E p = E, p E , C E for tuple t=(Temp: 15) from C 2 . By Rule 1, we have t et ∈ E, p E (t et ) = 0.6. By Rule 2, since t ∈ C 2 , we have t e C 1 ∈ E and p E (t e C 1 ) = t ∈C1 Proposition 4.1: Any induced event relation is a simple probabilistic relation.2) Evaluating Global-Topk Queries: With the help of induced event relation, we could reduce Global-Topk in the general case to Global-Topk in simple probabilistic relations.Lemma 4.1: Given a probabilistic relation R p = R, p, C and an injective scoring function s, for anyt ∈ R, E p = E, p E , C E . Let Q p = E -{t et }, p E , C E -{{t et }} .Then, the Global-Topk probability of t satisfies the following: Given a probabilistic relation R p = R, p, C and an injective scoring function s, for any t ∈ R p , the Global-Topk probability of t equals the Global-Topk probability of t et when evaluating top-k in the induced event relationE p = E, p E , C E under the injective scoring function s E : E → R, s E (t et ) = 1 2 and s E (t e C i ) = i: P R p k,s (t) = P E p k,s E (t et ). Proof: (Sketch) When evaluating top-k in E p under s E ,t et is the |E| th tuple. P E p k,s (t et ) is the probability of t et being present in top-k answers in the possible worlds of E p . Since t et has the lowest score, for any world W contributing to P E p k,s (t et ), W contains t et and has at most k -1 tuples besides t et . There is a bijection from such W to the W e in Lemma 4.1. The conclusion follows from Lemma 4.1. R p = R, p, C , k, s 1: Initialize a fixed cardinality k + 1 priority queue Ans of t, prob pairs, which compares pairs on prob; 2: for t ∈ R do In Line 2, we initialize the support relation E of the induced event relation by the tuple generated by Rule 1 in Def. 4.1.</figDesc><table><row><cell></cell><cell>E:</cell><cell>p E :</cell></row><row><cell></cell><cell>Event</cell><cell>Prob</cell></row><row><cell></cell><cell>t et</cell><cell>0.6</cell></row><row><cell></cell><cell>t e C 1</cell><cell>0.6</cell></row><row><cell></cell><cell>P R p k,s (t) = p(t) • (</cell><cell>p(W e )).</cell></row><row><cell></cell><cell cols="2">We∈pwd(Q p )</cell></row><row><cell></cell><cell cols="2">|We|&lt;k</cell></row><row><cell cols="3">Theorem 4.3: Since any induced event relation is simple (Prop. 4.1),</cell></row><row><cell cols="3">Thm. 4.3 illustrates how we can reduce the computation of P R p k,s (t) in the original probabilistic relation to a top-</cell></row><row><cell cols="3">k computation in a simple probabilistic relation, where we</cell></row><row><cell cols="3">can apply the DP technique in Section IV-A. The complete</cell></row><row><cell cols="2">algorithms are shown below.</cell></row><row><cell cols="3">Algorithm 2 (IndEx Topk) Evaluate Global-Topk queries in</cell></row><row><cell cols="2">a General Probabilistic Relation</cell></row><row><cell cols="3">Require: 3: Calculate P R p k,s (t) using Algorithm 3 4: Add t, P R p k,s (t) to Ans;</cell></row><row><cell>5:</cell><cell>if |Ans| &gt; k then</cell></row><row><cell>6:</cell><cell cols="2">remove the pair with the smallest prob value from</cell></row><row><cell></cell><cell>Ans;</cell></row><row><cell>7:</cell><cell>end if</cell></row><row><cell cols="2">8: end for</cell></row><row><cell>p(t ) = p((Temp: 22)) = 0.6. Therefore,</cell><cell></cell></row><row><cell>t s t</cell><cell></cell></row></table><note><p><p>9: return {t| t, P R p k,s (t) ∈ Ans};</p>In Alg. 3, we first find the part C id(t) where t belongs.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>1 to compute P E p k,s (t et ). Consequently, we retain only the DP related codes in Alg. 1. Note that Alg. 1 requires all tuples be sorted on score, but this is not a problem for us. Since we already know the scoring function s E , we simply need to organize tuples based on s E when generating E. No extra sorting is necessary.</figDesc><table><row><cell cols="3">Algorithm 3 (IndEx Topk Sub) Calculate P R p k,s (t)using in-</cell></row><row><cell cols="2">duced event relation</cell></row><row><cell cols="2">Require: R 4:</cell></row><row><cell></cell><cell>p(e Ci ) =</cell><cell>p(t );</cell></row><row><cell></cell><cell>t ∈Ci</cell></row><row><cell></cell><cell>t s t</cell></row><row><cell>7:</cell><cell>end if</cell></row><row><cell cols="3">8: end for 9: Use Line 2 -13 of Algorithm 1 to compute P E p k,s E (t et ); 10: P R p k,s (t) = P E p k,s E (t et ); 11: return P R p k,s (t);</cell></row></table><note><p><p>p = R, p, C , k, s, t ∈ R 1: Find the part C id(t) ∈ C such that t ∈ C id(t) ; 2: Initialize E with tuple t et , where p E (t et ) = p(t) E = {t et }; 3: for C i ∈ C and C i = C id(t) do 5:</p>if p(e Ci ) &gt; 0 then 6: Add a tuple t e C i to E, where p E (t e C i ) = p(e Ci ) E = E ∪ {t e C i };</p></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Incomplete information in relational databases</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The theory of probabilistic databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cavallo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pittarelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An analysis of first-order logics of probability</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="311" to="350" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Foundations of Databases : The Logical Level</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A probabilistic relational algebra for the integration of information retrieval and database systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Fuhr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rölleke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="32" to="66" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Query evaluation in probabilistic relational databases</title>
		<author>
			<persName><forename type="first">E</forename><surname>Zimányi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="179" to="219" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Probview: A flexible probabilistic database system</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="419" to="469" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient query evaluation on probabilistic databases</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">N</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="523" to="544" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Uldbs: Databases with uncertainty and lineage</title>
		<author>
			<persName><forename type="first">O</forename><surname>Benjelloun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Trio: A system for integrated management of data, accuracy, and lineage</title>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">World-set decompositions: Expressiveness and efficient algorithms</title>
		<author>
			<persName><forename type="first">L</forename><surname>Antova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Olteanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDT</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Combining fuzzy information from multiple systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="83" to="99" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Optimal aggregation algorithms for middleware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lotem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Supporting incremental join queries on ranked inputs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Natsev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Evaluating top-queries over web-accessible databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="319" to="362" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Merging the results of approximate match operations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="636" to="647" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Joining ranked inputs in practice</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Supporting top-k join queries in relational databases</title>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Top-k query processing in uncertain databases</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Soliman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDE</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient top-k query evaluation on probabilistic data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">N</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDE</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Biometrics-driven smart environments: Abstract framework and evaluation</title>
		<author>
			<persName><forename type="first">V</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jayaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Govindaraju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CSE Dept., University at Buffalo, SUNY</title>
		<imprint/>
	</monogr>
	<note>Tech. Rep. 2008-01</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The threshold algorithm: From middleware systems to the relational engine</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="523" to="537" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">On the semantics and evaluation of top-k queries in probabilistic databases</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chomicki</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="2007" to="2013" />
		</imprint>
		<respStmt>
			<orgName>CSE Dept., University at Buffalo, SUNY, Tech. Rep</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
