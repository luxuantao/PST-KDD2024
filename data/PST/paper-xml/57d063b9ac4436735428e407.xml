<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Stream Ciphers: A Practical Solution for Efficient Homomorphic-Ciphertext Compression</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">J</forename><surname>Cryptol</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Anne</forename><surname>Canteaut</surname></persName>
							<email>anne.canteaut@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Sergiu</forename><surname>Carpov</surname></persName>
							<email>sergiu.carpov@cea.fr</email>
						</author>
						<author>
							<persName><forename type="first">Caroline</forename><surname>Fontaine</surname></persName>
							<email>caroline.fontaine@imt-atlantique.fr</email>
						</author>
						<author>
							<persName><forename type="first">Tancrède</forename><surname>Lepoint</surname></persName>
							<email>tancrede.lepoint@sri.com</email>
						</author>
						<author>
							<persName><forename type="first">María</forename><surname>Naya-Plasencia</surname></persName>
							<email>maria.naya_plasencia@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Pascal</forename><surname>Paillier</surname></persName>
							<email>pascal.paillier@cryptoexperts.com</email>
						</author>
						<author>
							<persName><forename type="first">Renaud</forename><surname>Sirdey</surname></persName>
							<email>renaud.sirdey@cea.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">CEA LIST</orgName>
								<address>
									<settlement>Saclay</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Lab-STICC</orgName>
								<orgName type="institution">CNRS</orgName>
								<address>
									<settlement>Brest</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">IMT Atlantique</orgName>
								<address>
									<settlement>Brest</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">SRI International</orgName>
								<address>
									<settlement>New York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">CryptoExperts</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution">CEA LIST</orgName>
								<address>
									<settlement>Saclay</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Stream Ciphers: A Practical Solution for Efficient Homomorphic-Ciphertext Compression</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">981F375C60487C243558C028D245C2E0</idno>
					<idno type="DOI">10.1007/s00145-017-9273-9</idno>
					<note type="submission">Received 18 May 2016 / Revised 20 November 2017</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Stream ciphers</term>
					<term>Homomorphic cryptography</term>
					<term>Trivium</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In typical applications of homomorphic encryption, the first step consists for Alice of encrypting some plaintext m under Bob's public key pk and of sending the ciphertext c = HE pk (m) to some third-party evaluator Charlie. This paper specifically considers that first step, i.e., the problem of transmitting c as efficiently as possible from Alice to Charlie. As others suggested before, a form of compression is achieved using hybrid encryption. Given a symmetric encryption scheme E, Alice picks a random key k and sends a much smaller ciphertext c = (HE pk (k), E k (m)) that Charlie decompresses homomorphically into the original c using a decryption circuit C E -1 . In this paper, we revisit that paradigm in light of its concrete implementation constraints, in particular E is chosen to be an additive IV-based stream cipher. We investigate the performances offered in this context by Trivium, which belongs to the eSTREAM portfolio, and we also propose a variant with 128-bit security: Kreyvium. We show that Trivium, whose security has been firmly established for over a decade, and the new variant Kreyvium has excellent performance. We also describe a second construction, based on exponentiation in binary fields, which is impractical but sets the lowest depth record to 8 for 128-bit security.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Since the breakthrough result of Gentry <ref type="bibr" target="#b38">[39]</ref> achieving fully homomorphic encryption (FHE), many works have been published on simpler and more efficient schemes implementing homomorphic encryption. Because they allow arbitrary computations on encrypted data, FHE schemes suddenly opened the way to exciting new applications, in particular cloud-based services in several areas (see e.g. <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b61">62]</ref>).</p><p>Compressed Encryption. In these cloud applications, it is often assumed that some data are sent encrypted under a homomorphic encryption (HE) scheme <ref type="foot" target="#foot_0">1</ref> to the cloud to be processed in a way or another. It is thus typical to consider, in the first step of these applications, that a user (Alice) encrypts some data m under some other user's public key pk (Bob) and sends some homomorphic ciphertext c = HE pk (m) to a third-party evaluator in the cloud (Charlie). The roles of Alice and Bob are clearly distinct, even though they might be played by the same entity in some applications.</p><p>However, all HE schemes proposed so far suffer from a very large ciphertext expansion; the transmission of c between Alice and Charlie is therefore a very significant bottleneck in practice. The problem of reducing the size of c as efficiently as possible has first been considered in <ref type="bibr" target="#b61">[62]</ref> wherein m is encrypted with a symmetric encryption scheme E under some key k randomly chosen by Alice, who then sends a much smaller ciphertext c = (HE pk (k), E k (m)) to Charlie. Given c , Charlie then exploits the homomorphic property of HE and recovers</p><formula xml:id="formula_0">c = HE pk (m) = C E -1 HE pk (k), E k (m)</formula><p>by homomorphically evaluating the decryption circuit C E -1 . This can be assimilated to a compression method for homomorphic ciphertexts, c being the result of applying a compressed encryption scheme to the plaintext m and c being recovered from c using a ciphertext decompression procedure. In that approach obviously, the new encryption rate |c |/|m| becomes asymptotically close to 1 for long messages, which leaves no significant margin for improvement. However, the paradigm of ciphertext compression leaves totally open the question of how to choose E in a way that minimizes the decompression overhead, while preserving the same security level as originally intended.</p><p>Prior Art. The cost of a homomorphic evaluation of several symmetric primitives has been investigated, including optimized implementations of AES <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b39">40]</ref>, and of the lightweight block ciphers Simon <ref type="bibr" target="#b56">[57]</ref> and Prince <ref type="bibr" target="#b30">[31]</ref>. Usually lightweight block ciphers seem natural candidates for efficient evaluations in the encrypted domain. However, they may also lead to much worse performances than a homomorphic evaluation of, say, AES. Indeed, contemporary HE schemes use noisy ciphertexts, where a fresh ciphertext includes a noise component which grows along with homomorphic operations. Usually a homomorphic multiplication increases the noise by much larger proportions than a homomorphic addition. The maximum allowable level of noise (determined by the system parameters) then depends mostly on the multiplicative depth of the circuit. Many lightweight block ciphers balance out their simplicity by a large number of rounds, e.g., KATAN and KTANTAN <ref type="bibr" target="#b24">[25]</ref>, with the effect of considerably increasing their multiplicative depth. This type of design is therefore prohibitive in an HE context. Still Prince appears to be a much more suitable block cipher for homomorphic evaluation than AES (and than Simon), because it specifically targets applications that require a low latency; it is designed to minimize the cost of an unrolled implementation <ref type="bibr" target="#b11">[12]</ref> rather than to optimize, e.g., silicon area.</p><p>At Eurocrypt 2015, Albrecht, Rechberger, Schneider, Tiessen and Zohner observed that the usual criteria that rule the design of lightweight block ciphers are not appropriate when designing a symmetric encryption scheme with a low-cost homomorphic evaluation <ref type="bibr" target="#b1">[2]</ref>. Indeed, both the number of rounds and the number of binary multiplications required to evaluate an Sbox have to be taken into account. Minimizing the number of rounds is a crucial issue for low-latency ciphers like Prince, while minimizing the number of multiplications is a requirement for efficient masked implementations.</p><p>These two criteria have been considered together for the first time by Albrecht et al. in the recent design of a family of block ciphers called LowMC <ref type="bibr" target="#b1">[2]</ref> with very small multiplicative size and depth. <ref type="foot" target="#foot_1">2</ref> However, the originally proposed instances of LowMC, namely LowMC-80 and LowMC-128, have some security issues <ref type="bibr" target="#b27">[28]</ref>, inherent in their low multiplicative complexity. Indeed, the algebraic normal forms (i.e., the multivariate polynomials) describing the encryption and decryption functions are sparse and have a low degree. This type of features is usually exploited in algebraic attacks, cube attacks and their variants, e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b28">29]</ref>. While these attacks are rather general, the improved variant used for breaking the original LowMC <ref type="bibr" target="#b27">[28]</ref>, named interpolation attack <ref type="bibr" target="#b49">[50]</ref>, specifically applies to block ciphers. Indeed, it exploits the sparse algebraic normal form of some intermediate bit within the cipher using that this bit can be evaluated both from the plaintext in the forward direction and from the ciphertext in the backward direction. This technique yields several attacks including a key-recovery attack against LowMC-128 with time complexity 2 118 and data complexity 2 73 , leading the designers to propose a tweaked version <ref type="bibr" target="#b65">[66]</ref>.</p><p>Our Contributions. We emphasize that beyond the task of designing an HE-friendly block cipher, revisiting the whole compressed encryption scheme (in particular its internal mode of operation) is what is really needed in order to take these concrete HE-related implementation constraints into account.</p><p>First, we identify that homomorphic decompression is subject to an offline phase and an online phase. The offline phase is plaintext-independent and therefore can be performed in advance, whereas the online phase completes decompression upon reception of the plaintext-dependent part of the compressed ciphertext. Making the online phase as quick as technically doable leads us to choose an additive IV-based stream cipher to implement E. However, we note that the use of a lightweight block cipher as the building-block of that stream cipher usually provides a security level limited to 2 n/2 where n is the block size <ref type="bibr" target="#b66">[67]</ref>, thus limiting the number of blocks encrypted under the same key to significantly less than 2 32 (i.e., 32 GB for 64-bit blocks).</p><p>As a result, we propose our own candidate for E: the keystream generator Trivium <ref type="bibr" target="#b26">[27]</ref>, which belongs to the eSTREAM portfolio of recommended stream ciphers, and a new proposal called Kreyvium, which shares the same internal structure but allows for bigger keys of 128 bits. The main advantage of Kreyvium over Trivium is that it provides 128-bit security (instead of 80-bit) with the same multiplicative depth, and inherits the same security arguments. It is worth noticing that the design of a variant of Trivium which guarantees a 128-bit security level has been raised as an open problem for the last 10 years <ref type="bibr">[3, p. 30]</ref>. Beside a higher security level, it also accommodates longer IVs, so that it can encrypt up to 46 • 2 128 plaintext bits under the same key, with multiplicative depth only 12. Moreover, both Trivium and Kreyvium are resistant against the interpolation attacks used for breaking the original LowMC since these ciphers do not rely on a permutation which would enable the attacker to compute backwards. We implemented our construction and instantiated it with Trivium, Kreyvium and LowMC in CTR mode. Our results show that the promising performances attained by the HE-dedicated block cipher LowMC can be achieved with well-known primitives whose security has been firmly established for over a decade.</p><p>Our second candidate for E relies on a completely different technique based on the observation that multiplication in binary fields is F 2 -bilinear, making it possible to homomorphically exponentiate field elements with a log-log-depth circuit. We show, however, that this second approach remains disappointingly impractical.</p><p>Organization of the Paper. We introduce a general model and a generic construction to compress homomorphic ciphertexts in Sect. 2. Our construction using Trivium and Kreyvium is described in Sect. 3. Subsequent experimental results are presented in Sect. 4. Section 5 presents and discusses our second construction based on discrete logs on binary fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A Generic Design for Efficient Decompression</head><p>In this section, we describe our model and generic construction to transmit compressed homomorphic ciphertexts between Alice and Charlie. We use the same notation as in the introduction: Alice wants to send some plaintext m, encrypted under Bob's public key pk (of an homomorphic encryption scheme HE) to a third-party evaluator Charlie.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Homomorphic Encryption</head><p>As mentioned in the introduction, in all existing HE schemes a ciphertext c contains a noise r which grows with homomorphic operations. Given the system parameters, the correctness of the decryption is ensured as long as r does not exceed a given bound. When the function to be homomorphically evaluated is known in advance, the system parameters can be chosen accordingly so that the noise remains smaller than its maximum bound (and we obtain a so-called somewhat homomorphic encryption scheme). Otherwise, the only known method of obtaining fully homomorphic encryption (FHE) where the system parameters do not depend on the complexity of the evaluated functions is Gentry's bootstrapping procedure <ref type="bibr" target="#b38">[39]</ref>. This procedure consists in homomorphically evaluating the decryption circuit of the FHE scheme on the ciphertext, and allows to shrink a noise close to its maximum bound to a state after which subsequent homomorphic operations are possible. Unfortunately, this procedure remains significantly more costly than usual homomorphic operations <ref type="bibr" target="#b45">[46]</ref>, even if recent progresses have significantly reduced its cost <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b63">64]</ref>. For example, a recent result by Ducas and Micciancio improved by several orders of magnitude the latency of the bootstrapping procedure <ref type="bibr" target="#b31">[32]</ref>. But, in this new scheme, bootstrapping is required after each (NAND) gate evaluated homomorphically. The limits of this solution have been recently pushed forward: for instance, <ref type="bibr" target="#b63">[64]</ref> provides a way to optimize the bootstrapping management (for any FHE), and <ref type="bibr" target="#b20">[21]</ref> proposes an efficient way to execute bootstrapping (especially for FHE based on <ref type="bibr" target="#b40">[41]</ref>). But, the cost of bootstrapping still remains very high.</p><p>Therefore, an efficient implementation will aim at minimizing the number of call thereof, while ensuring correctness after decryption. Significant improvements over naive evaluations are illustrated, e.g., in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b57">58]</ref>. However, loads of use-cases using homomorphic encryption evaluate functions of a priori bounded complexity. For example statistical tests, machine learning algorithms <ref type="bibr" target="#b42">[43]</ref> or private computation on encrypted genomic data <ref type="bibr" target="#b55">[56]</ref> can be performed using somewhat homomorphic encryption (SWHE) schemes, among which the most recent, secure and efficient ones are <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b52">53]</ref>. The system parameters are, therefore, chosen as small as possible for efficiency. More generally, within the context of real-life applications, SWHE schemes are believed to already offer a number of compelling advantages.</p><p>In the following, we adopt the usual simplified setting as in, e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b57">58]</ref> which fits current most efficient HE schemes. This approximation is often considered in the literature and remains valid as long as the proportion of additions does not become overwhelming in the circuit. Clearly, our simplified model would become invalid outside of this context (see, e.g., <ref type="bibr" target="#b1">[2]</ref>). We refer to the HE schemes based on lattices <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b52">53]</ref> implemented in numerous works <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b61">62]</ref> and on the integers <ref type="bibr" target="#b21">[22]</ref>. Namely, each ciphertext c i is associated with a discretized noise level i = 1, 2, . . . where 1 is the noise level in a fresh ciphertext. Let c 1 (resp. c 2 ) be a ciphertext with noise level 1 (resp. 2 ). Homomorphic additions</p><formula xml:id="formula_1">c 3 = c 1 + c 2 (resp. homomorphic multiplications c 3 = c 1 × c 2 ) yield noise level 3 = max( 2 , 1 ) (resp. 3 = max( 1 , 2 ) + 1)</formula><p>. Note that our definition of noise levels neglects the logarithmic increase of the noise size after a homomorphic addition. The maximal value of the i 's represents the multiplicative depth of the circuit and is what we want to minimize to set the parameters as small as possible.</p><p>Throughout the rest of the paper, we assume the HE scheme HE pk (•) encrypts separately each plaintext bit (possibly in an SIMD fashion <ref type="bibr" target="#b67">[68]</ref>). We say that the latency of a homomorphic evaluation is the time required to perform the entire homomorphic evaluation, while its throughput is the number of blocks processed per unit of time <ref type="bibr" target="#b56">[57]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Offline/Online Phases in Ciphertext Decompression</head><p>Most practical scenarios would likely find it important to distinguish between three distinct phases within the homomorphic evaluation of C E -1 :</p><p>1. An offline key-setup phase which only depends on Bob's public key and can be performed once and for all before Charlie starts receiving compressed ciphertexts encrypted under Bob's key; 2. An offline decompression phase which can be performed only based on some plaintext-independent material found in the compressed ciphertext; 3. An online decompression phase which aggregates the result of the offline phase with the plaintext-dependent part of the compressed ciphertext and (possibly very quickly) recovers the decompressed ciphertext c.</p><p>As such, our general-purpose formulation c = (HE pk (k), E k (m)) does not allow to make a clear distinction between these three phases. In our context, it is much more relevant to reformulate the encryption scheme as an IV-based encryption scheme where the encryption process and decryption process are both deterministic but depend on an IV:</p><formula xml:id="formula_2">E k (m) def = IV, E k,IV (m) .</formula><p>Since the IV has a limited length, it can be either transmitted during an offline preprocessing phase, or may alternately correspond to a state which is maintained by the server. Now, to minimize the latency of homomorphic decompression for Charlie, the online phase should be reduced to a minimum. The most appropriate choice in this respect consists in using an additive IV-based stream cipher Z so that</p><formula xml:id="formula_3">E k,IV (m) = Z (k, IV) ⊕ m.</formula><p>In this reformulation, the decompression process is clearly divided into a offline precomputation stage which only depends on pk, k and IV, and an online phase which is plaintext-dependent. The online phase is thus reduced to a mere XOR between the plaintext-dependent part of the ciphertext E k,IV (m) and the HE-encrypted keystream HE(Z (k, IV)), which comes essentially for free in terms of noise growth in HE ciphertexts. All expensive operations (i.e., homomorphic multiplications) are performed during the offline decompression phase where HE(Z (k, IV)) is computed from HE(k) and IV.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Our Generic Construction</head><p>We devise the generic construction depicted in Fig. <ref type="figure">1</ref>. It is based on a homomorphic encryption scheme HE with plaintext space {0, 1}, an expansion function G mapping IV -bit strings to strings of arbitrary size, and a fixed-size parametrized function F with input size x , parameter size k and output size N .</p><formula xml:id="formula_4">k IV HE pk (•) Z G x1 xt F F F • • • F z1 z2 z3 • • • zt keystream = offline online Alice Charlie m ⊕ m ⊕ keystream HE pk (k) IV G x1 xt C F C F C F • • • C F HE pk (keystream) C⊕ HE pk (m)</formula><p>Fig. <ref type="figure">1</ref>. Our generic construction. The multiplicative depth of the circuit is equal to the depth of C F . This will be the bottleneck in our protocol and we want the multiplicative depth of F to be as small as possible. With current HE schemes, the circuit C ⊕ is usually very fast (addition of ciphertexts) and has a negligible impact on the noise in the ciphertext.</p><p>Compressed Encryption. Given an m -bit plaintext m, Bob's public key pk and IV ∈ {0, 1} IV , the compressed ciphertext c is computed as follows:</p><formula xml:id="formula_5">1. Set t = m /N , 2. Set (x 1 , . . . , x t ) = G(IV; t x ), 3. Randomly pick k ← {0, 1} k , 4. For 1 ≤ i ≤ t, compute z i = F k (x i ), 5. Set keystream to the m leftmost bits of z 1 • • • z t , 6. Output c = (HE pk (k), m ⊕ keystream).</formula><p>Ciphertext Decompression. Given c as above, Bob's public key pk and IV ∈ {0, 1} IV , the ciphertext decompression is performed as follows:</p><formula xml:id="formula_6">1. Set t = m /N , 2. Set (x 1 , . . . , x t ) = G(IV; t x ), 3. For 1 ≤ i ≤ t, compute HE pk (z i ) = C F HE pk (k), x i with some circuit C F , 4.</formula><p>Deduce HE pk (keystream) from HE pk (z 1 ), . . . , HE pk (z t ),</p><formula xml:id="formula_7">5. Compute c = HE pk (m) = C ⊕ HE pk (keystream), m ⊕ keystream .</formula><p>The circuit C ⊕ computes HE(a ⊕ b) given HE(a) and b where a and b are bit strings of the same size. In our construction, the cost of decompression per plaintext block is fixed and roughly equals one single evaluation of the circuit C F ; most importantly, the multiplicative depth of the decompression circuit is also fixed, and set to the depth of C F .</p><p>How Secure are Compressed Ciphertexts? From a high-level perspective, compressed homomorphic encryption is just hybrid encryption and relates to the generic KEM-DEM framework. This formalization introduced by Cramer and Shoup <ref type="bibr" target="#b23">[24]</ref> refers to hybrid encryption schemes consisting of a key encapsulation mechanism (KEM), i.e., an asymmetric part to encrypt a random key, plus a data encapsulation mechanism (DEM) corresponding to the encryption of the data with a symmetric cipher. A complete characterization of the security results attached to the KEM-DEM framework is presented in <ref type="bibr" target="#b46">[47]</ref>. In particular, when both the KEM and the DEM are IND-CPA, the resulting hybrid PKE scheme is at least IND-CPA. This result applies directly here: assuming the semantic security of our homomorphic KEM, <ref type="foot" target="#foot_2">3</ref> and a generalpurpose IND-CPA secure DEM, our compressed encryption scheme is IND-CPA secure.</p><p>Instantiating the Paradigm. The rest of the paper focuses on how to choose the expansion function G and function F so that the homomorphic evaluation of C F is as fast (and its multiplicative depth as low) as possible. In our approach, the value of IV is assumed to be shared between Alice and Charlie and needs not be transmitted along with the compressed ciphertext. For instance, IV is chosen to be an absolute constant such as IV = 0 where = IV = x . Another example is to take for IV ∈ {0, 1} a synchronized state that is updated between transmissions. The expansion function G is chosen to implement a counter in the sense of the NIST description of the CTR mode <ref type="bibr" target="#b62">[63]</ref>, for instance</p><formula xml:id="formula_8">G(IV; t ) = (IV, IV 1, . . . , IV (t -1)) where a b = (a + b) mod 2 .</formula><p>The resulting keystream z 1 • • • z t then corresponds to the sequence formed by the successive images under F k of a counter initialized by the IV. Therefore, F must be chosen to ensure both an appropriate security level and a low multiplicative depth. It is well known that the output of an iterated PRF used in CTR mode is computationally indistinguishable from random <ref type="bibr" target="#b7">[8,</ref><ref type="bibr">Th. 13</ref>]. Hence, under the assumption that F is a PRF, the keystream z 1 • • • z t produced by our construction is indistinguishable. It follows directly from <ref type="bibr" target="#b46">[47]</ref> that the compressed encryption scheme is IND-CPA.</p><p>In Sect. 3, we focus on the special case where F k : IV → F k (IV) is an IV-dependent stream cipher. As concrete proposals, it will be instantiated by Trivium, or by a new variant, called Kreyvium. In this case, F is PRF if and only if the generator instantiated with a random key and mapping the IV's to the keystream is secure <ref type="bibr" target="#b8">[9,</ref><ref type="bibr">Sec. 3.2]</ref>. Although the security of Trivium and Kreyvium is empiric, Sect. 3 provides a strong rationale for their designs and makes them the solutions with the smallest homomorphic evaluation latency known so far.</p><p>Why Not Use a Block Cipher for F? Although not specifically in these terms, the use of lightweight block ciphers like Prince and Simon has been proposed in the context of compressed homomorphic ciphertexts, e.g., <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b56">57]</ref>. However, a complete encryption scheme based on the ciphers has not been defined. This is a major issue since the security provided by all classical modes of operation (including all variants of CBC, CTR, CFB, OFB, OCB…) is inherently limited to 2 n/2 where n is the block size <ref type="bibr" target="#b66">[67]</ref> (see also, e.g., <ref type="bibr">[52, p. 95]</ref>). Only very few modes providing beyond-birthday security have been proposed, e.g., <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b69">70]</ref>, but they induce a higher implementation cost and their security is usually upper-bounded by 2 2n/3 .</p><p>In other words, the use of a block cipher operating on 64-bit blocks like Prince or Simon-32/64 implies that the number of blocks encrypted under the same key should be significantly less than 2 32 (i.e., 32GB for 64-bit blocks). Therefore, only block ciphers with a large enough block size, like the LowMC instantiation with a 256-bit block proposed in <ref type="bibr" target="#b1">[2]</ref>, are suitable in applications which may require the encryption of more than 2 32 bits under the same key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Trivium and Kreyvium, Two Low-Depth Stream Ciphers</head><p>An additive stream cipher is the natural choice to ensure good performance and an appropriate security level. Most notably, since an implementation with a low multiplicative depth is needed, stream ciphers seem to be more promising than other constructions for PRFs. We now focus on keystream generation, and on its homomorphic evaluation. An IV-based keystream generator is decomposed into:</p><p>-A resynchronization function, Sync, which takes as input the IV and the key (possibly expanded by some precomputation phase), and outputs some n-bit initial state;</p><p>-A transition function which computes the next state of the generator; -A filtering function f which computes a keystream segment from the internal state. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Keystream Generators with a Low Multiplicative Depth</head><p>The multiplicative depth of the circuit implementing the keystream generator highly depends on the multiplicative depth of the transition function. If only the encrypted (possibly expanded) key is transmitted, the homomorphic evaluation of Sync must be performed. Then, generating N keystream bits requires a circuit of depth up to</p><formula xml:id="formula_9">(depth(Sync) + N depth( ) + depth( f )) .</formula><p>The best design strategy for minimizing this value then consists in choosing a transition function with a small depth. The extreme option is to choose for a linear function as in the CTR mode where the counter is implemented by an LFSR. Following our work, this option has also been chosen in a recent stream cipher proposal named FLIP <ref type="bibr" target="#b59">[60]</ref>, but some cryptanalytic results <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b32">33]</ref> show that its parameters must be selected very carefully. An alternative strategy consists in choosing a nonlinear transition whose depth does not increase too fast when it is iterated.</p><p>Which Quantity Must be Encrypted Under the HE? In order to limit the multiplicative depth of the decryption circuit, we may prefer to transmit a longer secret k, from which more calculations can be done at a small multiplicative depth. Typically, for a block cipher, the sequence formed by all round-keys can be transmitted to the server. In this case, the key scheduling does not have to be taken into account in the homomorphic evaluation of the decryption function. Similarly, stream ciphers offer several such tradeoffs between the encryption rate and the encryption throughput. The encryption rate, i.e., the ratio between the size of c = (HE pk (k), E k (m)) and the plaintext size m , is defined as</p><formula xml:id="formula_10">ρ = |c | m = |E k (m)| m + | k| × (HE expansion rate) m .</formula><p>The extremal situation obviously corresponds to the case where the message encrypted under the homomorphic scheme is sent directly, i.e., c = HE pk (m). The multiplicative depth here is 0, as no decryption needs to be performed. In this case, ρ corresponds to the HE expansion rate.</p><p>The following alternative scenarios can then be compared.</p><p>1. Only the secret key is encrypted under the homomorphic scheme, i.e., k = k. Then, since we focus on symmetric encryption schemes with rate 1, we get</p><formula xml:id="formula_11">ρ = 1 + k × (HE expansion rate) m</formula><p>which is the smallest encryption rate we can achieve for k -bit security. In a nonce-based stream cipher, m is limited by the IV size IV and by the maximal keystream length N (d) which can be produced for a fixed multiplicative depth d ≥ depth(Sync)+depth( f ). Then, the minimal encryption rate is achieved for messages of any length m ≤ 2 IV N (d).</p><p>2. An intermediate case consists in transmitting the initial state of the generator, i.e., the output of Sync. Then, the number of bits to be encrypted by the HE increases to the size n of the internal state, while the number of keystream bits which can be generated from a given initial state with a circuit of depth d corresponds to N (d + depth(Sync)). Then, we get</p><formula xml:id="formula_12">ρ = 1 + n × (HE expansion rate) N (d + depth(Sync)) ,</formula><p>for any message length. The size of the internal state is at least twice the size of the key. Therefore, this scenario is not interesting, unless the number of plaintext bits m to be encrypted under the same key is smaller than twice N (d + depth(Sync)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Size of the Internal State.</head><p>A major specificity of our context is that a large internal state can be easily handled. Indeed, in most classical stream ciphers, the internal state size usually appears as a bottleneck because the overall size of the quantities to be stored highly influences the number of gates in the implementation. This is not the case in our context. It might seem, a priori, that increasing the size of the internal state automatically increases the number of nonlinear operations (because the number of inputs of increases). But, this is not the case if a part of this larger internal state is used, for instance, for storing the secret key. This strategy can be used for increasing the security at no implementation cost. Indeed, the complexity of all generic attacks aiming at recovering the internal state of the generator is O(2 n/2 ) where n is the size of the secret part of the internal state even if some part is not updated during the keystream generation. For instance, the timememory-data-trade-off attacks in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b41">42]</ref> aim at inverting the function which maps the internal state of the generator to the first keystream bits. But precomputing some values of this function must be feasible by the attacker, which is not the case if the filtering or transition function depends on some secret material. On the other hand, the size n of the non-constant secret part of the internal state determines the data complexity for finding a collision on the internal state: the length of the keystream produced from the same key is limited to 2 n /2 . But, if the transition function or the filtering function depends on the IV, this limitation corresponds to the maximal keystream length produced from the same key/IV pair. It is worth noticing that many attacks require a very long keystream generated from the same key/IV pair and do not apply in our context since the keystream length is strictly limited by the multiplicative depth of the circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Trivium in the HE Setting</head><p>Trivium <ref type="bibr" target="#b26">[27]</ref> is one of the seven stream ciphers recommended by the eSTREAM project after a 5-year international competition <ref type="bibr" target="#b33">[34]</ref>. Due to the small number of nonlinear operations in its transition function, it appears as a natural candidate in our context.</p><p>Description. Trivium is a synchronous stream cipher with a key and an IV of 80 bits each. Its internal state is composed of 3 registers of sizes 93, 84 and 111 bits, corresponding to a size of 288 bits in total. We use the notation introduced by the designers: the leftmost bit of the 93-bit register is s 1 , and its rightmost one is s 93 ; the leftmost bit of the register of size 84 is s 94 and the rightmost s 177 ; the leftmost bit of register of size 111 is s 178 and the rightmost s 288 . The initialization and the generation of an N -bit keystream are described below, and depicted in Fig. <ref type="figure" target="#fig_1">2</ref>. No attack better than an exhaustive key search is known so far on full Trivium. It can then be considered as secure. The family of attacks that seems to provide the best result on round-reduced versions is the cube attack and its variants <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b58">59,</ref><ref type="bibr" target="#b68">69]</ref>. They recover some key bits (resp. provide a distinguisher on the keystream) if the number of initialization rounds is reduced to 799 (resp. 885) rounds out of 1152. The highest number of initialization rounds that can be attacked is 961: in this case, a distinguisher exists for a class of weak keys <ref type="bibr" target="#b54">[55]</ref>. Multiplicative Depth. It is easy to see that the multiplicative depth grows quite slowly with the number of iterations. An important observation is that, in the internal state, only the first 80 bits in Register 1 (the key bits) are initially encrypted under the HE and that, as a consequence, performing hybrid clear and encrypted data calculations is possible (this is done by means of the following simple rules: 0</p><formula xml:id="formula_13">(</formula><formula xml:id="formula_14">• [x] = 0, 1 • [x] = [x], 0 + [x] = [x] and 1 + [x] = [1] + [x],</formula><p>where the square brackets denote encrypted bits and where in all but the latter case, a homomorphic operation is avoided which is specially desirable for multiplications). This optimization allows for instance to increase the number of bits which can be generated (after the 1152 blank rounds) at depth 12 from 42 to 57 (i.e., a 35% increase). Then, the relevant quantity in our context is the multiplicative depth of the circuit which computes N keystream bits from the 80-bit key.</p><p>Proposition 1. In Trivium, the keystream length N (d) which can be produced from the 80-bit key after 1152 initialization rounds with a circuit of multiplicative depth d, d ≥ 4, is given by</p><formula xml:id="formula_15">N (d) = -1152 + 282 × d 3 + ⎧ ⎨ ⎩ 81 if d ≡ 0 mod 3 160 if d ≡ 1 mod 3 269 if d ≡ 2 mod 3 .</formula><p>Proof. We first observe that, within any register in Trivium, the degree of the leftmost bit is greater than or equal to the degrees of the other bits in the register. It is then sufficient to study the evolution of the leftmost bits in the three registers. From d = 3, the differences t i (d + 1)t i (d) are large enough so that the minimum in the three recurrence relation corresponds to the right-hand term. We then deduce that, for d ≥ 4,</p><formula xml:id="formula_16">-if d ≡ 1 mod 3, t 1 (d) = 282 × (d -1) 3 + 119, t 2 (d) = 282 × (d -1) 3 + 14, t 3 (d) = 282 × (d -1) 3 + 53.</formula><p>-if d ≡ 2 mod 3,</p><formula xml:id="formula_17">t 1 (d) = 282 × (d -2) 3 + 162, t 2 (d) = 282 × (d -2) 3 + 210, t 3 (d) = 282 × (d -2) 3 + 96.</formula><p>-if d ≡ 0 mod 3,</p><formula xml:id="formula_18">t 1 (d) = 282 × (d -3) 3 + 205, t 2 (d) = 282 × (d -3) 3 + 253, t 3 (d) = 282 × (d -3) 3 + 292.</formula><p>The degree of the keystream produced at time t corresponds to the maximum between the degrees of the bit at position 66 in Register 1, the bit at position 69 in Register 2 and the bit at position 66 in Register 3. Then, for d &gt; 3,</p><formula xml:id="formula_19">N (d) = min(t 1 (d + 1) + 64, t 2 (d + 1) + 67, t 3 (d + 1) + 64).</formula><p>This leads to, for any d ≥ 4,</p><formula xml:id="formula_20">N (d) = 282 × d 3 + ⎧ ⎨ ⎩ 81 if d ≡ 0 mod 3 160 if d ≡ 1 mod 3 269 if d ≡ 2 mod 3 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Kreyvium</head><p>Our first aim is to offer a variant of Trivium with 128-bit key and IV, without increasing the multiplicative depth of the corresponding circuit. Besides a higher security level, another advantage of this variant is that the number of possible IVs, and then the maximal length of data which can be encrypted under the same key, increases from 2 80 N trivium (d) to 2 128 N kreyvium (d). Increasing the key and IV size in Trivium is a challenging task, mentioned as an open problem in <ref type="bibr">[3, p. 30]</ref> for instance. In particular, Maximov and Biryukov <ref type="bibr" target="#b60">[61]</ref> pointed out that increasing the key-size in Trivium without any additional modification cannot be secure due to some attack with complexity less than 2 128 . A first attempt in this direction has been made in <ref type="bibr" target="#b60">[61]</ref>, but the resulting cipher accommodates 80-bit IV only, and its multiplicative complexity is higher than in Trivium since the number of AND gates is multiplied by 2. Also, independently from our results, another variant of Trivium named Trivi-A has been proposed <ref type="bibr" target="#b17">[18]</ref>. It handles larger keys but uses longer registers and then needs more rounds for mixing the internal state. This means that it is much less adapted to our setting than Kreyvium.</p><p>Description. Our proposal, Kreyvium, accommodates a key and an IV of 128 bits each.</p><p>The only difference with the original Trivium is that we have added to the 288-bit internal state a 256-bit part corresponding to the secret key and the IV. This part of the state aims at making both the filtering and transition functions key-and IV-dependent. More precisely, these two functions f and depend on the key bits and IV bits, through the successive outputs of two shift-registers K * and IV * initialized by the key and by the IV, respectively. The internal state is then composed of five registers of sizes 93, 84, 111, 128 and 128 bits, having an internal state size of 544 bits in total, among which 416 become unknown to the attacker after initialization. We will use the same notation as the description of Trivium, and for the additional registers we use the usual shift-register notation: the leftmost bit is denoted by K * 127 (or IV * 127 ), and the rightmost bit (i.e., the output) is denoted by K * 0 (or IV * 0 ). Each one of these two registers is rotated independently from the rest of the cipher. The generator is described below and is depicted in Fig. <ref type="figure" target="#fig_2">3</ref>.  <ref type="bibr" target="#b24">[25]</ref> is a lightweight block cipher with a lot in common with Trivium. It is composed of two registers, whose feedback functions are very sparse, and have a single nonlinear term. The key, instead of being used for initializing the state, is introduced by XORing two key bits per round to the feedback bits. The recently proposed stream cipher Sprout <ref type="bibr" target="#b3">[4]</ref>, inspired by Grain but with much smaller registers, also inserts the key in a similar way: instead of using the key for initializing the state, one key bit is XORed at each clock to the feedback function. We can see the parallelism between these two ciphers and our newly proposed variant. In particular, the previous security analysis on KATAN shows that this type of design does not introduce any clear weakness. Indeed, the best attacks on round-reduced versions of KATAN so far <ref type="bibr" target="#b37">[38]</ref> are meet-in-the-middle attacks, that exploit the knowledge of the values of the first and the last internal states (due to the block cipher setting). As this is not the case here, such attacks, as well as the interpolation attacks against the original LowMC [28], do not apply. The best attacks against KATAN, when excluding MitM techniques, are conditional differential attacks <ref type="bibr" target="#b53">[54,</ref><ref type="bibr" target="#b54">55]</ref>.</p><formula xml:id="formula_21">(</formula><p>Design Rationale. We have decided to XOR the key bit K * 0 to the feedback function of the register that interacts with the content of (s 1 , . . . , s 63 ) the later, since (s 1 , . . . , s 63 ) is initialized with some key bits. The same goes for the IVn * register. Moreover, as the key bits that start entering the state are the ones that were not in the initial state, all the key bits affect the state at the earliest.</p><p>We also decided to initialize the state with some key bits and with all the IV bits, and not with a constant value, as this way the mixing will be performed quicker. Then, we can expect that the internal state bits after initialization are expressed as more complex and less sparse functions in the key and IV bits.</p><p>Our change of constant is motivated by the conditional differential attacks from <ref type="bibr" target="#b54">[55]</ref>: the conditions needed for a successful attack are that 106 bits from the IV or the key are equal to "0" and a single one needs to be "1." This suggests that values set to zero "encourage" non-random behaviors, leading to our new constant. In other words, in Trivium, an all-zero internal state is always updated in an all-zero state, while an all-one state will change through time. The 0 at the end of the constant is added for preventing slide attacks.</p><p>Multiplicative Depth. Exactly as for Trivium, we can compute the number of keystream bits which can be generated from the key at a given depth. The only difference with Trivium is that the first register now contains 93 key bits instead of 80. For this reason, the optimization using hybrid plaintext/ciphertext calculations is a bit less interesting: for any fixed depth d ≥ 4, we can generate 11 bits less than with Trivium. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2. In Kreyvium, the keystream length N (d) which can be produced</head><formula xml:id="formula_22">-if d ≡ 1 mod 3, t 1 (d) = 282 × (d -1) 3 + 108, t 2 (d) = 282 × (d -1) 3 + 3, t 3 (d) = 282 × (d -1) 3 + 42.</formula><p>-if d ≡ 2 mod 3,</p><formula xml:id="formula_23">t 1 (d) = 282 × (d -2) 3 + 151, t 2 (d) = 282 × (d -2) 3 + 199, t 3 (d) = 282 × (d -2) 3 + 85.</formula><p>-if d ≡ 0 mod 3,</p><formula xml:id="formula_24">t 1 (d) = 282 × (d -3) 3 + 194, t 2 (d) = 282 × (d -3) 3 + 242, t 3 (d) = 282 × (d -3) 3 + 281.</formula><p>We eventually derive that, for Kreyvium, for any d ≥ 4,</p><formula xml:id="formula_25">N (d) = 282 × d 3 + ⎧ ⎨ ⎩ 70 if d ≡ 0 mod 3 149 if d ≡ 1 mod 3 258 if d ≡ 2 mod 3 .</formula><p>Security Analysis. We investigate how all the known attacks on Trivium can apply to Kreyvium.</p><p>TMDTO. Time-Memory-Data-Trade-Off (TMDTO) attacks aiming at recovering the initial state of the cipher do not apply since the size of the secret part of the internal state (416 bits) is much larger than twice the key-size: the size of the whole secret internal state has to be taken into account, even if the additional 128-bit part corresponding to K * is independent from the rest of the state. On the other hand, TMDTO attacks aiming at recovering the key have complexities larger than exhaustive key search since the key and the IV have the same size <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b47">48]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Internal State Collision.</head><p>A distinguisher may be built if the attacker is able to find two colliding internal states, since the two keystreams produced from colliding states are identical. Finding such a collision requires around 2 144 keystream bits generated from the same key/IV pair, which is much longer than the maximal keystream length allowed by the multiplicative depth of the circuit. But, for a given key, two internal states colliding on all bits except on IV * lead to two keystreams which have the same first 69 bits since IV * affects the keystream only 69 clocks later. Moreover, if the difference between the two values of IV * when the rest of the state collides lies in the leftmost bit, then this difference will affect the keystream bits (69 + 128) = 197 clocks later. This implies that, within around 2 144 keystream bits generated from the same key, we can find two identical runs of 197 consecutive bits which are equal. However, this property does not provide a valid distinguisher because a random sequence of 2 144 blocks is expected to contain much more collisions on 197-bit runs. Therefore, the birthday-bound of 2 144 bits provides a limit on the number of bits produced from the same key/IV pair, not on the bits produced from the same key.</p><p>Cube Attacks <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b36">37]</ref> and Cube Testers <ref type="bibr" target="#b4">[5]</ref>. They provide the best attacks for roundreduced Trivium. In our case, as we keep the same main function, but we have two additional XORs per round, thus a better mixing of the variables, we can expect the relations to get more involved and hamper the application of previously defined roundreduced distinguishers. One might wonder if the fact that more variables are involved could ease the attacker's task, but we point out here that the limitation in the previous attacks was not the IV size, but the size of the cubes themselves. Therefore, having more variables available is of no help with respect to this point. We can conclude that the resistance of Kreyvium to these types of attacks is at least the resistance of Trivium, and even better.</p><p>Conditional Differential Cryptanalysis. Because of its applicability to Trivium and KATAN, the attack from <ref type="bibr" target="#b54">[55]</ref> is definitely of interest in our case. In particular, the highest number of blank rounds is reached if some conditions on two registers are satisfied at the same time (and not only conditions on the register controlled by the IV bits in the original Trivium). In our case, as we have IV bits in two registers, it is important to elucidate whether an attacker can take advantage of introducing differences in two registers simultaneously. First, let us recall that we have changed the constant to one containing mostly 1. We previously saw that the conditions that favor the attacks are values set to zero in the initial state. In Trivium, we have (108 + 4 + 13) = 125 bits already fixed to zero in the initial state, 3 are fixed to one and the others can be controlled by the attacker in the weak-key setting (and the attacker will force them to be zero most of the time). Now, instead, we have 64 bits forced to be 1, 1 equal to zero, and (128 + 93) = 221 bits of the initial state controlled by the attacker in the weak-key setting, plus potentially 21 additional bits from the key still not used, that will be inserted during the first rounds. We can conclude that, while in Trivium it is possible in the weak-key setting, to introduce zeros in the whole initial state but in 3 bits, in Kreyvium, we will never be able to set to zero 64 bits, implying that applying the techniques from <ref type="bibr" target="#b54">[55]</ref> becomes much harder.</p><p>Algebraic Attacks. Several algebraic attacks have been proposed against Trivium, aiming at recovering the 288-bit internal state at the beginning of the keystream generation (i.e., at time t = 1153) from the knowledge of the keystream bits. The most efficient attack of this type is due to Maximov and Biryukov <ref type="bibr" target="#b60">[61]</ref>. It exploits the fact that the 22 keystream bits at time 3t , 0 ≤ t &lt; 22, are determined by all bits of the initial state at indexes divisible by 3 (starting from the leftmost bit in each register). Moreover, once all bits at positions 3i are known, then guessing that the outputs of the three AND gates at time 3t are zero provides 3 linear relations between the bits of the internal state and the keystream bits. The attack then consists of an exhaustive search for some bits at indexes divisible by 3. The other bits in such positions are then deduced by solving the linear system derived from the keystream bits at positions 3t . Once all these bits have been determined, the other 192 bits of the initial state are deduced from the other keystream equations. This process must be iterated until the guess for the outputs of the AND gates is correct. In the case of Trivium, the outputs of at least 125 AND gates must be guessed in order to get 192 linear relations involving the 192 bits at indexes 3i + 1 and 3i + 2. This implies that the attack has to be repeated (4/3) 125 = 2 52 times. From these guesses, we get many linear relations involving the bits at positions 3i only, implying that only an exhaustive search with complexity 2 32 for the other bits at positions 3i is needed. Therefore, the overall complexity of the attack is around 2 32 × 2 52 = 2 84 . A similar algorithm can be applied to Kreyvium, but the main difference is that every linear equation corresponding to a keystream bit also involves one key bit. Moreover, the key bits involved in the generation of any 128 consecutive output bits are independent.</p><p>It follows that each of the first 128 linear equations introduces a new unknown in the system to solve. For this reason, it is not possible to determine all bits at positions 3i by an exhaustive search on less than 96 bits like for Trivium. Moreover, the outputs of more than 135 AND gates must be guessed for obtaining enough equations on the remaining bits of the initial state. Therefore, the overall complexity of the attack exceeds 2 96 × 2 52 = 2 148 and is much higher that the cost of the exhaustive key search. It is worth noticing that the attack would have been more efficient if only the feedback bits, and not the keystream bits, would have been dependent on the key. In this case, 22 linear relations independent from the key would have been available to the attacker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experimental Results</head><p>We now discuss and compare the practicality of our generic construction when instantiated with Trivium, Kreyvium and LowMC. The expansion function G implements a mere counter, and the aforementioned algorithms are used to instantiate the function F that produces N bits of keystream per iteration as defined by Propositions 1 and 2.</p><p>Note that these propositions only hold when hybrid clear and encrypted data calculations are possible between IV and HE ciphertexts. This explains the slight differences in the number of keystream bits per iteration (column "N ") between Tables <ref type="table" target="#tab_4">1</ref> and<ref type="table" target="#tab_5">2</ref>.</p><p>We would like to recall that for the original LowMC-128 a key-recovery attack with time complexity 2 118 and data complexity 2 73 was proposed in <ref type="bibr" target="#b27">[28]</ref>. In order to thwart this attack, the designers of LowMC proposed to increase the number of rounds to 12 for the LowMC-80 version and to 14 for the LowMC-128 version <ref type="bibr" target="#b65">[66]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HE Framework.</head><p>In our experiments, we considered two HE schemes: the BGV scheme <ref type="bibr" target="#b14">[15]</ref> and the FV scheme <ref type="bibr" target="#b34">[35]</ref> (a scale-invariant version of BGV). The BGV scheme is implemented in the library HElib <ref type="bibr" target="#b44">[45]</ref> and has become de facto a standard benchmarking library for HE applications. Similarly, the FV scheme was previously used in several HE benchmarkings <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b56">57]</ref>, is conceptually simpler than the BGV scheme, and is one of the most efficient HE schemes. We used the Armadillo compiler implementation of FV <ref type="bibr" target="#b16">[17]</ref>. This source-to-source compiler turns a C++ algorithm into a Boolean circuit, optimizes it, and generates an OpenMP parallel code which can then be combined with an HE scheme.</p><p>Additionally, for the BGV scheme, batching was used <ref type="bibr" target="#b67">[68]</ref>, i.e., the HE schemes were set up to encrypt vectors in an SIMD fashion (componentwise operations, and rota-tions via the Frobenius endomorphism). The number of elements that can be encrypted depends on the number of terms in the factorization modulo 2 of the cyclotomic polynomial used in the implementation. This batching allowed us to perform several Trivium/Kreyvium/LowMC in parallel in order to increase the throughput.</p><p>Parameter Selection for Subsequent Homomorphic Processing. In most previous works on the homomorphic evaluation of symmetric encryption schemes, the parameters of the underlying HE scheme were selected for the exact multiplicative depth required and not beyond <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b56">57]</ref>. This means that once the ciphertext is decompressed, no further homomorphic computation can actually be performed by Charlie-this makes the claimed timings considerably less meaningful in a real-world context.</p><p>We benchmarked both parameters for the exact multiplicative depth and parameters able to handle circuits of the minimal multiplicative depth plus 6 to allow further homomorphic processing by Charlie (which is obviously what is expected in applications of homomorphic encryption). We chose this number of additional levels because, in practice and from our experience, numerous applications use algorithms of multiplicative depth smaller than 7 (see e.g., <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b55">56]</ref>). In what follows we compare the results we obtain using Trivium, Kreyvium and also the two versions of LowMC cipher. For the original LowMC, we benchmarked not only our own implementation but also the LowMC implementation of <ref type="bibr" target="#b1">[2]</ref> available at https://bitbucket.org/malb/lowmc-helib. Minor changes to this implementation were made in order to obtain an equivalent parametrization of HElib. The main difference is that the implementation from <ref type="bibr" target="#b1">[2]</ref> uses an optimized method for multiplying a Boolean vector and a Boolean matrix, namely the "Method of Four Russians." This explains why our implementation is approximately 6% slower, as it performs 2-3 times more ciphertext additions.</p><p>Experimental Results Using HElib. For sake of comparison with <ref type="bibr" target="#b1">[2]</ref>, we ran our implementations and their implementation of LowMC on a single core using HElib. The results are provided in Table <ref type="table" target="#tab_4">1</ref>. We recall that the latency refers to the time required to perform the entire homomorphic evaluation, whereas the throughput is the number of blocks processed per time unit.</p><p>We shall note that HElib has two possible specializations: either the multiplicative depths can be set to consecutive values or only to even values. We have observed that the second specialization (supporting even multiplicative depths) is more efficient in terms of computation times. In our experiments we have used this implementation of HElib. This implies that, in some cases for LowMC, the multiplicative depths we used in Table <ref type="table" target="#tab_4">1</ref> are slightly higher than the needed multiplicative depths.</p><p>It should be emphasized that, in most cases, the values of N reported in Table <ref type="table" target="#tab_4">1</ref> are slightly smaller than the theoretical values provided by Propositions 1 and 2. For instance, with a circuit of depth 12, Trivium (resp. Kreyvium) is expected to generate 57 keystream bits (resp. 46). Instead, our experiments using HElib allow us to generate 45 (resp. 42) bits only. The reason for this is that HElib is used in batched mode. The batch mode allows to encrypt several plaintexts in a single ciphertext (roughly speaking factorization of the cyclotomic polynomial modulo the plaintext space is used). Homomorphic operations are then performed independently on all the slots (a slot corresponds to a cyclotomic polynomial factor in which a plaintext is encoded). The IVs, in the case of HElib, are plaintext polynomials encoding in each slot the bits of the multiple IV values evaluated in parallel, while in the case of FV the (single) IV bits belong to F 2 . Then, with HElib a homomorphic multiplication between a clear and an encrypted data corresponds to a multiplication with a plaintext polynomial, while with FV, no homomorphic operation needs to be executed (since ct • 0 = 0 and ct • 1 = ct). This explains why the values of N obtained with FV and reported in Table <ref type="table" target="#tab_5">2</ref> coincide with the theoretical values and are slightly larger than the values obtained with HElib.</p><p>Another reason why the effective value of N (d) may differ from the theoretical value, especially in the LowMC case, is that the multiplication depth is only an approximation of the homomorphic depth required to absorb the noise generated by the execution of an algorithm. It neglects the noise induced by additions or homomorphic operations with a plaintext input. A difference may then appear for addition-intensive algorithms like LowMC. For instance, the theoretical multiplicative depth is 12 for LowMC-80, but valid ciphertexts could be obtained for an equivalent multiplicative depth 14 only for the FV scheme and 13 for the BGV scheme.</p><p>Experimental Results Using FV. In Table <ref type="table" target="#tab_5">2</ref>, we present the benchmarks when using the FV scheme. The experiments were performed using either a single core (in order to compare with BGV) or on all the cores of the machine the tests were performed on. The execution time acceleration factor between 48-core parallel and sequential executions is given in the column "Speed gain." While good accelerations (at least 25 times) were obtained for Trivium and Kreyvium algorithms, the acceleration when using LowMC is significantly smaller (∼ 10 times). This is due to the huge number of operations in LowMC that created memory contention and huge slowdown in memory allocation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Number of AND and XOR Gates in Trivium and Kreyvium.</head><p>A more thorough analysis of the number of AND and XOR gates in the different circuits is provided in Table <ref type="table" target="#tab_6">3</ref>. The keystream length is the maximum possible for a given multiplicative depth. It is lower for the BGV scheme (batched) because the IV is no more a Boolean string so less circuit optimization is possible. For the FV scheme (non-batched) the table gives the number of executed gates in the worst case. The actual number of executed gates can be lower as it depends on the employed IV.</p><p>Interpretation. Our results using the BGV scheme show that, for 128 bits of security, Kreyvium and LowMC-128 have comparable performance in terms of latency although Kreyvium achieves a higher throughput. The latter fact is explained by a larger number of keystream bits generated per iteration (406 compared to 256) and a small cost in terms of multiplicative gates per keystream bit in Kreyvium (only 3 AND gates). In case of FV scheme Kreyvium has better performance in terms of latency, throughput and speed gain from the use of multiple computational cores. We have observed that the HE scheme parameters in HElib are difficult to tune and are less fine grained than in the Armadillo implementation. We suppose that the observed performance bias between the BGV and the FV experiments we have performed are due to this.</p><p>Also Trivium and Kreyvium are more parallelizable than LowMC is. Therefore, our work shows that the promising performances obtained by the recently proposed HEdedicated cipher LowMC can also be achieved with Trivium, a well-analyzed stream cipher, and a variant aiming at achieving 128 bits of security. Last but not least, we recall that our construction was aiming at compressing the size of transmissions between Alice and Charlie. We support an encryption rate |c |/|m| that becomes asymptotically close to 1 for long messages, e.g., for m = 1GB message length, our construction instantiated with Trivium (resp. Kreyvium), yields an expansion rate of 1.08 (resp. 1.16).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Another Approach: Using Discrete Logs on Binary Fields</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Overview</head><p>We now introduce a second, discrete-log based instantiation of the generic compressed encryption scheme of Sect. 2.3 that relies on exponentiation over binary fields. This approach aims at answering the following question: How many multiplicative levels are strictly necessary to achieve a secure compressed encryption scheme, irrespective of any performance metric such as the number of homomorphic bit multiplications to perform in the decompression circuit?</p><p>In this section, we propose a construction that achieves a multiplicative depth of log κ + 1 for κ-bit security. Recent research shows that our construction is only secure against quasi-polynomial-time adversaries <ref type="bibr" target="#b6">[7]</ref> and, as a consequence, is disappointedly impractical when setting concrete parameters. However, we believe this other approach to be of particular interest due to the fact that it admits a formal security proof.</p><p>We recall that the homomorphic encryption scheme HE pk (•) is assumed to encrypt separately each plaintext bit. For h ∈ F 2 n , we identify h with the vector of its coefficients and therefore by HE pk (h), we mean the vector composed of the encrypted coefficients of h. Our construction has provable security while ensuring a low-depth circuit C F . To achieve this, what we require is essentially that G be a PRNG and IV be chosen at random at encryption time and transmitted within c . This allows us to prove that c is semantically secure under a well-defined complexity assumption. Simultaneously, we use exponentiation in a binary field to instantiate F, which yields a circuit C F of minimal depth log k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Description of the Compressed Encryption Scheme</head><p>For a parameter n, we consider a prime-order subgroup G ⊆ F 2 n and pose f = (2 n -1)/q where q is the order of G. Also, we set</p><formula xml:id="formula_26">x = N = n.</formula><p>The encryption operation picks a fresh IV ← {0, 1} IV for each compressed ciphertext. The expansion function G(IV) makes use of some PRNG to generate n-bit blocks x 1 , . . . , x t as follows:</p><p>1. Initialize the PRNG with IV as seed. 2. For i = 1 to t: (a) Run the PRNG to generate an n-bit</p><formula xml:id="formula_27">vector u ∈ F 2 n . (b) Compute v = u f (so that v ∈ G). (c) If v = 1 goto 5.2. (d) Set x i = v.</formula><p>Overall, G generates pseudorandom sequences of elements of G * = G \ {1} (and is treated as a random oracle over G * in the security proof). Finally, F maps n-bit inputs to n-bit outputs under k -bit parameters as follows. Given k ∈ {0,</p><formula xml:id="formula_28">1} k and x ∈ F 2 n , F k (x) returns z = x k ∈ F 2 n . Obviously, if x ∈ G * then F k (x) ∈ G *</formula><p>as well. This completes the description of the compressed encryption scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">A Log-Log-Depth Exponentiation Circuit over F 2 n</head><p>We now describe a circuit C exp which, given a field element h ∈ F 2 n and an encrypted exponent HE pk (k) with k ∈ {0, 1} k , computes HE pk (h k ) and has multiplicative depth at most log k . Stricto sensu, C exp is not just a Boolean circuit evaluated homomorphically, as it combines computations in the clear, homomorphic F 2 -arithmetic on encrypted bits, and F 2 -arithmetic on mixed cleartext/encrypted bits.</p><p>C exp uses implicitly some irreducible polynomial p to represent F 2 n , and we denote by ⊕ and ⊗ p the field operators. The basic idea here is that for any a, b ∈ F 2 n , computing HE(a ⊗ p b) from HE(a), HE(b) requires only 1 multiplicative level, simply because ⊗ p is F 2 -bilinear. Therefore, knowing p and the characteristics of HE, we can efficiently implement a bilinear operator on encrypted binary vectors to compute</p><formula xml:id="formula_29">HE(a ⊗ p b) = HE(a) ⊗ HE p HE(b).</formula><p>A second useful observation is that for any a ∈ F 2 n and β ∈ {0, 1}, there is a multiplication-free way to deduce HE(a β ) from a and HE(β). When β = 1, a β is just a and a β = 1 F 2 n = (1, 0, . . . , 0) otherwise. Therefore to construct a vector v = (v 0 , . . . , v n-1 ) = HE(a β ), it is enough to set</p><formula xml:id="formula_30">v i := HE(0) if a i = 0 HE(β) if a i = 1 for i = 1, . . . , n -1 and v 0 := HE(β ⊕ 1) if a 0 = 0 HE(1) if a 0 = 1</formula><p>where it does not matter that the same encryption of 0 be used multiple times. Let us denote this procedure as HE(a β ) = L a (HE(β)) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now, given as input</head><formula xml:id="formula_31">h ∈ F 2 n , C exp first computes in the clear h i = h 2 i for i = 0, . . . , k - 1. Since h k = h k 0 0 ⊗ p h k 1 1 ⊗ p • • • ⊗ p h k k -1 k -1 , one<label>gets</label></formula><formula xml:id="formula_32">HE(h k ) = HE h k 0 0 ⊗ HE p HE h k 1 1 ⊗ HE p • • • ⊗ HE p HE h k k -1 k -1 = L h 0 (HE (k 0 )) ⊗ HE p L h 1 (HE (k 1 )) ⊗ HE p • • • ⊗ HE p L h k -1 HE k k -1 .</formula><p>Viewing the k variables as the leaves of a binary tree, C exp therefore requires at most log k levels of homomorphic multiplications to compute and return HE pk (h k ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Security Results</head><p>Given some homomorphic encryption scheme HE and security parameters κ, n, k , we define a family of decision problems {DP t } t&gt;0 as follows. We rely on the real-or-random flavor of the IND-CPA security game and build a reduction algorithm R that uses an adversary A G against the scheme to break DP t as follows. R is given as input some pk, HE pk (k), g 1 , . . . , g t , g1 , . . . , gt sampled from D t,b and has to guess the bit b. R runs A G (pk) and behaves as follows.</p><p>-Queries to G. At any moment, R responds to A's queries to G using fresh random strings for each new query or to extend a past query to a larger size.</p><p>-Answer to challenge. When R receives some challenge plaintext m ∈ {0, 1} m where (t -1)n &lt; m ≤ tn from A, it builds a compressed ciphertext c as follows:</p><p>1. Set keystream to the m leftmost bits of g1 All the statistical distributions comply with their specifications. Consequently, c is an encryption of m if the input instance comes from D t,1 and is an encryption of some perfectly uniform plaintext if the instance follows D t,0 . The reduction is tight as long as the abortion probability q2 -IV remains negligible, q being the number of oracle queries (to G) made by A.</p><p>Interestingly, we note the following fact about our family of decision problems. Theorem 2. For any t ≥ 2, DP t is equivalent to DP 2 .</p><p>Proof. A problem instance pk, HE pk (k), g 1 , . . . , g t , g1 , . . . , gt sampled from D t,b can be converted into an instance of D 2,b for the same b, by just removing g 3 , . . . , g t and g3 , . . . , gt . This operation preserves the distributions of all inner variables. Therefore DP t can be reduced to DP 2 . Now, we describe a reduction R which, given an instance pk, HE pk (k), g 1 , g 2 , g1 , g2 sampled from D 2,b , makes use of an adversary A against DP t to successfully guess b. R converts its instance of D 2,b into an instance of D t,b as follows:</p><p>1. For i = 3 to t:</p><formula xml:id="formula_33">a. Randomly select α i , β i ← Z q . b. Set g i = g α i 1 g β i 2 and gi = gα i 1 gβ i 2 . c. If g i = 1 or gi = 1 goto 1.a.</formula><p>It is easily seen that, if g1 = g k 1 and g2 = g k 2 then gi = g k i for every i, meaning that the resulting distribution is DP t,1 . If, however, g1 , g2 are uniformly and independently distributed over G * , then so are g3 , . . . , gt and the resulting distribution is exactly DP t,0 . Our reduction runs A over the resulting instance and outputs the guess b returned by A. Obviously R is tight.</p><p>Overall, the security of our compressed encryption scheme relies on breaking DP 1 for messages of bit-size at most n and on breaking DP 2 for larger messages. Beyond the fact that DP 2 reduces to DP 1 , we note that these two problems are unlikely to be equivalent since DP 2 is easily broken using a DDH oracle over G * (when considering the tuple (g := g 1 , g a := g k 1 , g b := g 2 , g ab := g k 2 )), while DP 1 seems to remain unaffected by it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Performance Issues</head><p>Concrete Security Parameters. Note that our decisional security assumptions DP exp t for all t ≥ 1 reduce to the discrete logarithm problem in the finite field F 2 n (or a subgroup thereof). Solving discrete logarithms in finite fields of small characteristics is currently a very active research area, marked notably by the quasi-polynomial algorithm of Barbulescu et al. <ref type="bibr" target="#b6">[7]</ref>. In particular, the expected security one can hope for has been recently completely redefined <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b43">44]</ref>. In our setting, we will select a prime n so that computing discrete logarithms in F 2 n has complexity 2 κ for κ-bit security. The first step of Barbulescu et al. algorithm runs in polynomial time. This step has been extensively studied and its complexity has been brought down to O((2 log 2 n ) 6 ) using a very complex and tight analysis by Joux and Pierrot <ref type="bibr" target="#b50">[51]</ref>. As for the quasi-polynomial step of the algorithm, its complexity can be upper-bounded, but in practice numerous trade-offs can be used and it is difficult to lower bound it <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref>. To remain conservative in our choice of parameters, we will base our security on the first step. To ensure a 80-bit (resp. 128-bit) security level, one should therefore choose a prime n of log 2 n ≈ 14 bits (resp. 23 bits), i.e., work in a finite field F 2 n where n is about 16, 000 (resp. 4 million).</p><p>How Impractical is this Approach? We now briefly see why our discrete-log based construction on binary fields is impractical. We focus more specifically on the exponentiation circuit C exp whose most critical subroutine is a general-purpose field multiplication in the encrypted domain. Taking homomorphic bit multiplication as the complexity unit and neglecting everything else, how fast can we expect to multiply encrypted field elements in F 2 n ? When working in the cleartext domain, several families of techniques exist with attractive asymptotic complexities for large n, such as algorithms derived from Toom-Cook <ref type="bibr" target="#b10">[11]</ref> or Schönhage-Strassen <ref type="bibr" target="#b64">[65]</ref>. It is unclear how these different strategies can be adapted to our case and with what complexities. <ref type="foot" target="#foot_3">4</ref> However, let us optimistically assume that they could be adapted somehow and that one of these adaptations would just take n homomorphic bit multiplications.</p><p>A straightforward implementation of C exp consists in viewing all circuit inputs L h i (HE(k i )) as generic encrypted field elements and in performing generic field multiplications along the binary tree, which would require k •n homomorphic bit multiplications. Taking k = 160, n = 16000 and 0.5 s for each bit multiplication (as a rough estimate of the timings of Sect. 4), this accounts for more than 14 days of computation.</p><p>This can be improved because the circuit inputs are precisely not generic encrypted field elements; each one of the n ciphertexts in L h i (HE(k i )) is known to equal either HE(k i ), HE(k i ⊕ 1), HE(0) or HE <ref type="bibr" target="#b0">(1)</ref>. Similarly, a circuit variable of depth 1, i.e.,</p><formula xml:id="formula_34">L h i (HE(k i )) ⊗ HE p L h i+1 (HE(k i+1 )),</formula><p>contains n ciphertexts that are all an encryption of one of the 16 quadratic polynomials ak i k i+1 + bk i + ck i+1 + d for a, b, c, d ∈ {0, 1}. This leads us to a strategy where one simulates the τ first levels of field multiplications at once, by computing the 2 log k -τ dictionaries of the form</p><formula xml:id="formula_35">HE k b 0 i k b 1 i+1 • • • k b 2 τ -1 i+2 τ -1 b 0 ,...,b 2 τ -1 ∈{0,1}</formula><p>and computing the binary coefficients (in clear) to be used to reconstruct each bit of the 2 log k -τ intermediate variables of depth τ from the dictionaries through linear (homomorphic) combinations. By assumption, this accounts for nothing in the total computation time. The rest of the binary tree is then performed using generic encrypted field multiplications as before, until the circuit output is fully aggregated. This approach is always more efficient than the straightforward implementation and optimal when the total number</p><formula xml:id="formula_36">2 2 τ -2 τ -1 • 2 log k -τ + 2 log k -τ -1 -1 • n</formula><p>of required homomorphic bit multiplications is minimal. With k = 160 and n = 16000 again, the best choice is for τ = 4. Assuming 0.5 s for each bit multiplication, this still gives a prohibitive 6.71 days of computation for a single evaluation of C exp .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>Our work shows that the promising performances obtained by the recent HE-dedicated cipher LowMC can also be achieved with Trivium, a well-known primitive whose security has been thoroughly analyzed, e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b60">61]</ref>. The 10-year analysis effort from the community, initiated by the eSTREAM competition, enables us to gain confidence in its security. Also our variant Kreyvium benefits from this analysis since the core of the cipher is essentially the same. From a more fundamental perspective, one may wonder how many multiplicative levels are strictly necessary to achieve a secure compressed encryption scheme, irrespective of any performance metric such as the number of homomorphic bit multiplications to perform in the decompression circuit. We have shown in Sect. 5 that a multiplicative depth of log κ + 1 is achievable for κ-bit security. However, this second approach remains disappointingly impractical. Can one do better or prove that this is a lower bound?</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Trivium.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Kreyvium. The three registers in the middle correspond to Trivium. The modifications defining Kreyvium correspond to the two registers at the top and at the bottom.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>3 end if t</head><label></label><figDesc>1 ← t 1 + s 91 • s 92 + s 171 t 2 ← t 2 + s 175 • s 176 + s 264 t 3 ← t 3 + s 286 • s 287 + s 69 (s 1 , s 2 , . . . , s 93 ) ← (t 3 , s 1 , . . . , s 92 ) (s 94 , s 95 , . . . , s 177 ) ← (t 1 , s 94 , . . . , s 176 ) (s 178 , s 179 , . . . , s 288 ) ← (t 2 , s 178 , . . . , s 287 ) end for</figDesc><table /><note><p>s 1 , s 2 , . . . , s 93 ) ← (K 0 , . . . , K 79 , 0, . . . , 0) (s 94 , s 95 , . . . , s 177 ) ← (I V 0 , . . . , I V 79 , 0, . . . , 0) (s 178 , s 179 , . . . , s 288 ) ← (0, . . . , 0, 1, 1, 1) for i = 1 to 1152 + N do t 1 ← s 66 + s 93 t 2 ← s 162 + s 177 t 3 ← s 243 + s 288 if i &gt; 1152 do output z i-1152 ← t 1 + t 2 + t</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Let t i (d) denote the first time instant (starting from t = 1) where the leftmost bit in Register i is computed by a circuit of depth d. The depth of the feedback bit in Register i can increase from d to (d + 1) if either a bit of depth (d + 1) reaches an XOR gate in the feedback function, or a bit of depth d reaches one of the inputs of the AND gate. From the distance between the leftmost bit and the first bit involved in the feedback (resp. and the first entry of the AND gate) in each register, we derive that The first key bits K 78 and K 79 enter the AND gate in Register 1 at time t = 13 (starting from t = 1), implying t 2 (1) = 14. Then, t 3 (1) = 83 and t 1 (1) = 149. This leads to t 1 (4) = 401, t 2 (4) = 296 and t 3 (4) = 335.</figDesc><table /><note><p>t 1 (d + 1) = min(t 3 (d + 1) + 66, t 3 (d) + 109) t 2 (d + 1) = min(t 1 (d + 1) + 66, t 1 (d) + 91) t 3 (d + 1) = min(t 2 (d + 1) + 69, t 2 (d) + 82)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>s 1 , s 2 , . . . , s 93 ) ← (K 0 , . . . , K 92 ) (s 94 , s 95 , . . . , s 177 ) ← (I V 0 , . . . , I V 83 ) (s 178 , s 179 , . . . , s 288 ) ← (I V 84 , . . . , I V 127 , 1, . . . , 1, 0)(K * 127 , K * 126 , . . . , K * 0 ) ← (K 0 , . . . , K 127 ) (I V * 127 , I V * 126 , . . . , I V * 0 ) ← (I V 0 , . . . , I V 127 ) for i = 1 to 1152 + Ndo t 1 ← s 66 + s 93 t 2 ← s 162 + s 177 t 3 ← s 243 + s 288 + K + t 2 + t 3 end if t 1 ← t 1 + s 91 • s 92 + s 171 + IV * 0 t 2 ← t 2 + s 175 • s 176 + s 264 t 3 ← t 3 + s 286 • s 287 + s 69 t 4 ← K * , s 2 , . . . , s 93 ) ← (t 3 , s 1 , . . . , s 92 ) (s 94 , s 95 , . . . , s 177 ) ← (t 1 , s 94 , . . . , s 176 ) (s 178 , s 179 , . . . , s 288 ) ← (t 2 , s 178 , . . . , s 287 ) (K</figDesc><table><row><cell>0 t 5 ← I V  *  0 (s 1</cell></row></table><note><p>* 0 if i &gt; 1152 do output z i-1152 ← t 1 * 127 , K * 126 , . . . , K * 0 ) ← (t 4 , K * 127 , . . . , K * 1 ) (I V * 127 , I V * 126 , . . . , I V * 0 ) ← (t 5 , I V * 127 , . . . , I V * 1 ) end for Related Ciphers. KATAN</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 .</head><label>1</label><figDesc>Latency and throughput using HElib on a single core of a mid-end 48-core server (4× AMD Opteron 6172 processors with 64 GB of RAM).</figDesc><table><row><cell>Algorithm</cell><cell cols="2">Security level κ N</cell><cell cols="4">Used × depth #Slots Latency (s) Throughput (bits/min)</cell></row><row><cell>Trivium-12</cell><cell>80</cell><cell cols="2">45 12</cell><cell>600</cell><cell>1414.9</cell><cell>1145.0</cell></row><row><cell></cell><cell></cell><cell></cell><cell>18</cell><cell>720</cell><cell>4328.0</cell><cell>449.2</cell></row><row><cell>Trivium-14</cell><cell>80</cell><cell cols="2">245 14</cell><cell>504</cell><cell>1985.2</cell><cell>3732.0</cell></row><row><cell></cell><cell></cell><cell></cell><cell>20</cell><cell>720</cell><cell>5276.5</cell><cell>2005.9</cell></row><row><cell>LowMC-80</cell><cell>80</cell><cell cols="2">256 14</cell><cell>504</cell><cell>1483.9</cell><cell>5217.0</cell></row><row><cell></cell><cell></cell><cell></cell><cell>20</cell><cell>720</cell><cell>3690.9</cell><cell>2996.4</cell></row><row><cell>LowMC-80 [2]</cell><cell>80</cell><cell cols="2">256 14</cell><cell>504</cell><cell>1366.9</cell><cell>5663.5</cell></row><row><cell></cell><cell></cell><cell></cell><cell>20</cell><cell>720</cell><cell>3332.6</cell><cell>3318.5</cell></row><row><cell>Kreyvium-12</cell><cell>128</cell><cell cols="2">42 12</cell><cell>504</cell><cell>1547.0</cell><cell>821.0</cell></row><row><cell></cell><cell></cell><cell></cell><cell>18</cell><cell>756</cell><cell>4805.1</cell><cell>396.5</cell></row><row><cell>Kreyvium-16</cell><cell>128</cell><cell cols="2">406 16</cell><cell>720</cell><cell>5464.6</cell><cell>3209.6</cell></row><row><cell></cell><cell></cell><cell></cell><cell>22</cell><cell>518</cell><cell>6667.7</cell><cell>1892.5</cell></row><row><cell>LowMC-128</cell><cell>128</cell><cell cols="2">256 16</cell><cell>720</cell><cell>4508.7</cell><cell>2452.9</cell></row><row><cell></cell><cell></cell><cell></cell><cell>22</cell><cell>518</cell><cell>6024.7</cell><cell>1320.6</cell></row><row><cell cols="2">LowMC-128 [2] 128</cell><cell cols="2">256 16</cell><cell>720</cell><cell>4316.0</cell><cell>2562.4</cell></row><row><cell></cell><cell></cell><cell></cell><cell>22</cell><cell>518</cell><cell>5632.6</cell><cell>1412.6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 .</head><label>2</label><figDesc>Latency and throughput of our construction when using the FV scheme on a mid-end 48-core server (4× AMD Opteron 6172 processors with 64 GB of RAM).</figDesc><table><row><cell>Algorithm</cell><cell>Security</cell><cell>N</cell><cell cols="3">Used × depth Latency (s)</cell><cell cols="2">Speed gain Throughput (bits/min)</cell></row><row><cell></cell><cell>level κ</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">1 core 48 cores</cell><cell></cell><cell>48 cores</cell></row><row><cell>Trivium-12</cell><cell>80</cell><cell cols="2">57 12</cell><cell>681.5</cell><cell>26.8</cell><cell>× 25.4</cell><cell>127.6</cell></row><row><cell></cell><cell></cell><cell></cell><cell>18</cell><cell>1910.3</cell><cell>63.0</cell><cell>× 30.3</cell><cell>54.3</cell></row><row><cell>Trivium-14</cell><cell>80</cell><cell cols="2">245 14</cell><cell>1153.6</cell><cell>42.2</cell><cell>× 27.3</cell><cell>348.3</cell></row><row><cell></cell><cell></cell><cell></cell><cell>20</cell><cell>2635.5</cell><cell>83.6</cell><cell>× 31.5</cell><cell>175.8</cell></row><row><cell>LowMC-80</cell><cell>80</cell><cell cols="2">256 14</cell><cell cols="2">898.0 106.5</cell><cell>× 8.</cell><cell>144.2</cell></row><row><cell></cell><cell></cell><cell></cell><cell>20</cell><cell cols="2">1787.4 179.7</cell><cell>× 10.0</cell><cell>85.5</cell></row><row><cell cols="2">Kreyvium-12 128</cell><cell cols="2">46 12</cell><cell>904.4</cell><cell>35.3</cell><cell>× 25.6</cell><cell>78.2</cell></row><row><cell></cell><cell></cell><cell></cell><cell>18</cell><cell>2531.4</cell><cell>80.1</cell><cell>× 31.6</cell><cell>34.5</cell></row><row><cell cols="2">Kreyvium-16 128</cell><cell cols="2">407 16</cell><cell>2630.8</cell><cell>84.4</cell><cell>× 31.2</cell><cell>289.3</cell></row><row><cell></cell><cell></cell><cell></cell><cell>22</cell><cell cols="2">5231.6 139.6</cell><cell>× 37.5</cell><cell>174.9</cell></row><row><cell cols="2">LowMC-128 128</cell><cell cols="2">256 16</cell><cell cols="2">2196.0 218.0</cell><cell>× 10.0</cell><cell>70.5</cell></row><row><cell></cell><cell></cell><cell></cell><cell>22</cell><cell cols="2">4275.1 324.3</cell><cell>× 13.2</cell><cell>47.4</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3 .</head><label>3</label><figDesc>Number of AND and XOR gates to homomorphically evaluate in Trivium, Kreyvium and LowMC for FV and BGV schemes. For LowMC the number of gates obtained using implementation<ref type="bibr" target="#b1">[2]</ref> is shown.</figDesc><table><row><cell>Algorithm</cell><cell>Security level κ</cell><cell>FV</cell><cell></cell><cell></cell><cell>BGV</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>#ANDs</cell><cell>#XORs</cell><cell>N</cell><cell>#ANDs</cell><cell>#XORs</cell><cell>N</cell></row><row><cell>Trivium-12</cell><cell>80</cell><cell>3237</cell><cell>15019</cell><cell>57</cell><cell>3183</cell><cell>14728</cell><cell>45</cell></row><row><cell>Trivium-14</cell><cell>80</cell><cell>3801</cell><cell>18356</cell><cell>245</cell><cell>3801</cell><cell>18356</cell><cell>245</cell></row><row><cell>LowMC-80</cell><cell>80</cell><cell>1764</cell><cell>254364</cell><cell>256</cell><cell>1764</cell><cell>238016</cell><cell>256</cell></row><row><cell>Kreyvium-12</cell><cell>128</cell><cell>3311</cell><cell>18081</cell><cell>46</cell><cell>3288</cell><cell>17934</cell><cell>42</cell></row><row><cell>Kreyvium-16</cell><cell>128</cell><cell>4410</cell><cell>25207</cell><cell>407</cell><cell>4407</cell><cell>25193</cell><cell>406</cell></row><row><cell>LowMC-128</cell><cell>128</cell><cell>2646</cell><cell>311573</cell><cell>256</cell><cell>2646</cell><cell>308228</cell><cell>256</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Proof. A random oracle version of function G is an oracle that takes as input a pair (IV, ) where IV ∈ {0, 1} IV and ∈ N * , and returns an -bit random string. It is also imposed to the oracle that G(IV; 1 ) be a prefix of G(IV; 2 ) for any IV and 1 ≤ 2 .</figDesc><table /><note><p>Definition 1. (Decision Problem DP t ) Let pk ← HE.KeyGen(1 κ ) be a random public key, k ← {0, 1} k a random k -bit integer and g 1 , . . . , g t , g 1 , . . . , g t ← G * . Distinguish the distributions D t,1 = pk, HE pk (k), g 1 , . . . , g t , g k 1 , . . . , g k t and D t,0 = pk, HE pk (k), g 1 , . . . , g t , g 1 , . . . , g t . Theorem 1. Viewing G as a random oracle over G * , the compressed encryption scheme described above is semantically secure (IND-CPA), unless breaking DP t is efficient, for messages of bit-size m with (t -1)n &lt; m ≤ tn.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>• • • gt , 2. Pick a random IV ← {0, 1} IV , 3. Abort if G(IV ; ) is already defined for some (when A queried G), 4. Set G(IV ; tn) to g 1 • • • g t . 5. Set c = HE pk (k), IV , m ⊕ keystream ,R then returns c to A. When R eventually receives A's guess b, it forwards it to its own challenger.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This terminology includes both FHE schemes and somewhat homomorphic encryption.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>It is worth noting that in an HE context, reducing the multiplicative size of a symmetric primitive might not be the first concern (while it is critical in a multiparty computation context, which also motivated the work of Albrecht et al.<ref type="bibr" target="#b1">[2]</ref>), whereas minimizing the multiplicative depth is of prime importance.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Note that it is usual that HE schemes succeed in achieving CPA security, but often grossly fail to realize any form of CCA1 security, to the point of admitting simple key-recovery attacks<ref type="bibr" target="#b18">[19]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>One could expect these techniques to become the most efficient ones here since their prohibitive overhead would disappear in the context of homomorphic circuits.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Yannick Seurin for informing us about the complete characterization of secure hybrid encryption.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This work has been supported in part by the European Union's H2020 Programme under Project Number 645622 PQCRYPTO. † This work has been supported in part by the European Institute of Technology under project EIT DIGITAL HC@WORKS. ‡ This work has received a French governmental support granted to the COMIN Labs excellence laboratory and managed by the National Research Agency in the "Investing for the Future" program under Reference ANR-10-LABX-07-01. § Part of this work has been performed while employed at CryptoExperts, France. This material is based upon work supported by the Defense Advanced Research Projects Agency (DARPA) and Space and Naval Warfare Systems Center, Pacific (SSC Pacific) under Contract No. N66001-15-C-4071. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of DARPA or SSC Pacific. This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA). The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the Department of Defense or the US Government. ¶ This work has been supported in part by the European Union's H2020 Programme under Grant Agreement Number ICT-644209.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Computing discrete logarithms in F 3 6 * 137 using Magma</title>
		<author>
			<persName><forename type="first">G</forename><surname>Adj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rodríguez-Henríquez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="page">57</biblScope>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><surname>Albrecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tiessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zohner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Ciphers for MPC and FHE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="430" to="454" />
		</imprint>
	</monogr>
	<note>EURO-CRYPT, Part I</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Algorithms, key size and parameters report</title>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
	<note>ENISA</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On lightweight stream ciphers with shorter internal states</title>
		<author>
			<persName><forename type="first">F</forename><surname>Armknecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mikhalev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9054</biblScope>
			<biblScope unit="page" from="451" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Cube testers and key recovery attacks on reduced-round MD6 and Trivium</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aumasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5665</biblScope>
			<biblScope unit="page" from="1" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A space/time trade-off in exhaustive search attacks on stream ciphers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Babbage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Convention on Security and Detection</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">408</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Barbulescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gaudry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Thomé</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8441</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A concrete security treatment of symmetric encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Jokipii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="394" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the security of IV dependent stream ciphers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Berbain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4593</biblScope>
			<biblScope unit="page" from="254" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cryptanalytic time/memory/data tradeoffs for stream ciphers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biryukov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1976">1976. 2000</date>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Towards optimal toom-cook multiplication for univariate and multivariate polynomials in characteristic 2 and 0, in WAIFI</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bodrato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">4547</biblScope>
			<biblScope unit="page" from="116" to="133" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">PRINCE-a low-latency block cipher for pervasive computing applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Borghoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Canteaut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Güneysu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Kavun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Knezevic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Leander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Paar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rombouts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Thomsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yalçin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7658</biblScope>
			<biblScope unit="page" from="208" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Improved security for a ring-based fully homomorphic encryption scheme</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Loftus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IMACC</title>
		<imprint>
			<biblScope unit="volume">8308</biblScope>
			<biblScope unit="page" from="45" to="64" />
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption without modulus switching from classical GapSVP, in CRYPTO</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">7417</biblScope>
			<biblScope unit="page" from="868" to="886" />
			<date type="published" when="2012">2012</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Leveled) fully homomorphic encryption without bootstrapping</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOCT</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Boolean functions with restricted input and their robustness; application to the FLIP cipher</title>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Méaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Rotella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Trans. Symmetric Cryptol</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="192" to="227" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Armadillo: a compilation chain for privacy preserving applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Carpov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dubrulle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sirdey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCSW</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">TriviA: a fast and secure authenticated encryption scheme</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chakraborti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chattopadhyay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9293</biblScope>
			<biblScope unit="page" from="330" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On key recovery attacks against existing somewhat homomorphic encryption schemes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chenal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LATINCRYPT</title>
		<imprint>
			<biblScope unit="volume">8895</biblScope>
			<biblScope unit="page" from="239" to="258" />
			<date type="published" when="2015">2015</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Batch fully homomorphic encryption over the integers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Cheon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tibouchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7881</biblScope>
			<biblScope unit="page" from="315" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Faster fully homomorphic encryption: bootstrapping in less than 0.1 seconds</title>
		<author>
			<persName><forename type="first">I</forename><surname>Chillotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgieva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Izabachène</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">10031</biblScope>
			<biblScope unit="page" from="3" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scale-invariant fully homomorphic encryption over the integers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tibouchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8383</biblScope>
			<biblScope unit="page" from="311" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Algebraic attacks on stream ciphers with linear feedback</title>
		<author>
			<persName><forename type="first">N</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="345" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="167" to="226" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">KATAN and KTANTAN-a family of small and efficient hardware-oriented block ciphers</title>
		<author>
			<persName><forename type="first">C</forename><surname>De Cannière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Dunkelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Knezevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5747</biblScope>
			<biblScope unit="page" from="272" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Comments on the rediscovery of time memory data tradeoffs</title>
		<author>
			<persName><forename type="first">C</forename><surname>De Cannière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
		<ptr target="www.ecrypt.eu.org/stream/papersdir/040.pdf" />
	</analytic>
	<monogr>
		<title level="m">eSTREAM-ECRYPT Stream Cipher Project</title>
		<imprint>
			<date type="published" when="2005-12-21">2005. 21 Dec 2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><surname>De Cannière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trivium</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Stream Cipher Designs-The eSTREAM Finalists</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4986</biblScope>
			<biblScope unit="page" from="244" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optimized Interpolation Attacks on LowMC. IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="page">418</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Cube attacks on tweakable black box polynomials</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="278" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Homomorphic AES evaluation using the modified LTV scheme</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Doröz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Des. Codes Cryptogr</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="333" to="358" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Toward practical homomorphic evaluation of block ciphers using Prince</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Doröz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shahverdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WAHC</title>
		<imprint>
			<biblScope unit="volume">8438</biblScope>
			<biblScope unit="page" from="208" to="220" />
			<date type="published" when="2014">2014</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">FHEW: bootstrapping homomorphic encryption in less than a second</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ducas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="617" to="640" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Cryptanalysis of the FLIP family of stream ciphers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Duval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lallemand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Rotella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="volume">9814</biblScope>
			<biblScope unit="page" from="457" to="475" />
			<date type="published" when="2016">2016</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<ptr target="http://www.ecrypt.eu.org/stream/" />
		<title level="m">cryptology: the eSTREAM stream cipher project</title>
		<imprint>
			<date type="published" when="2005-12-21">2005. 21 Dec 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Somewhat practical fully homomorphic encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="page">144</biblScope>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Towards practical program execution over fully homomorphic encryption schemes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sirdey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fontaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aguilar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gogniat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on P2P, Parallel, Grid, Cloud and Internet Computing</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="284" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Improving key recovery to 784 and 799 rounds of Trivium using optimized cube attacks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Vannet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8424</biblScope>
			<biblScope unit="page" from="502" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Match box meet-in-the-middle attack against KATAN</title>
		<author>
			<persName><forename type="first">T</forename><surname>Fuhr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Minaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8540</biblScope>
			<biblScope unit="page" from="61" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption using ideal lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Homomorphic evaluation of the AES circuit</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="volume">7417</biblScope>
			<biblScope unit="page" from="850" to="867" />
			<date type="published" when="2012">2012</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Homomorphic encryption from learning with errors: conceptuallysimpler, asymptotically-faster, attribute-based</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="volume">8042</biblScope>
			<biblScope unit="page" from="75" to="92" />
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Cryptanalysis of alleged A5 stream cipher</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Golic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="239" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<author>
			<persName><forename type="first">T</forename><surname>Graepel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ML confidential: machine learning on encrypted data, in ICISC</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7839</biblScope>
			<biblScope unit="page" from="1" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Breaking &apos;128-bit secure&apos; supersingular binary curves-(or how to solve discrete logarithms in F 2 4•1223 and F 2 12•367 )</title>
		<author>
			<persName><forename type="first">R</forename><surname>Granger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kleinjung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zumbrägel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO, Part II</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8617</biblScope>
			<biblScope unit="page" from="126" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Algorithms in HElib</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO, Part I</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8616</biblScope>
			<biblScope unit="page" from="554" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Bootstrapping for HElib</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="641" to="670" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Some (in)sufficient conditions for secure hybrid encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Herranz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">208</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1243" to="1257" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New applications of time memory data tradeoffs, in ASIACRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3788</biblScope>
			<biblScope unit="page" from="353" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">New block cipher modes of operation with beyond the birthday bound security</title>
		<author>
			<persName><forename type="first">T</forename><surname>Iwata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4047</biblScope>
			<biblScope unit="page" from="310" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">The interpolation attack on block ciphers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jakobsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1267</biblScope>
			<biblScope unit="page" from="28" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Improving the polynomial time precomputation of Frobenius representation discrete logarithm algorithms-simplified setting for small characteristic finite fields</title>
		<author>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pierrot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT, Part I</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8873</biblScope>
			<biblScope unit="page" from="378" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<title level="m">Introduction to Modern Cryptography, 2nd edition</title>
		<meeting><address><addrLine>Boca Raton</addrLine></address></meeting>
		<imprint>
			<publisher>Chapman and Hall/CRC Press</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">SHIELD: scalable homomorphic implementation of encrypted data-classifiers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khedr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gulak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2848" to="2858" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Naya-Plasencia, conditional differential cryptanalysis of NLFSR-based cryptosystems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Knellwolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6477</biblScope>
			<biblScope unit="page" from="130" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Knellwolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naya-Plasencia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conditional differential cryptanalysis of Trivium and KATAN, in SAC</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">7118</biblScope>
			<biblScope unit="page" from="200" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Private computation on encrypted genomic data</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>López-Alt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LATINCRYPT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A comparison of the homomorphic encryption schemes FV and YASHE</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AFRICACRYPT</title>
		<imprint>
			<biblScope unit="volume">8469</biblScope>
			<biblScope unit="page" from="318" to="335" />
			<date type="published" when="2014">2014</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">On the minimal number of bootstrappings in homomorphic circuits</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WAHC</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7862</biblScope>
			<biblScope unit="page" from="189" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Degree evaluation of NFSR-based cryptosystems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="volume">10402</biblScope>
			<date type="published" when="2017">2017</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Towards stream ciphers for efficient FHE with lownoise ciphertexts</title>
		<author>
			<persName><forename type="first">P</forename><surname>Méaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Journault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">X</forename><surname>Standaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9665</biblScope>
			<biblScope unit="page" from="311" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Two trivial attacks on Trivium</title>
		<author>
			<persName><forename type="first">A</forename><surname>Maximov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Biryukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SAC</title>
		<imprint>
			<biblScope unit="volume">4876</biblScope>
			<biblScope unit="page" from="36" to="55" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Can homomorphic encryption be practical?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCSW</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="113" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Recommendation for block cipher modes of operation</title>
	</analytic>
	<monogr>
		<title level="j">NIST Special Publication</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Minimizing the number of bootstrappings in fully homomorphic encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Paindavoine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Vialla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2015</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9566</biblScope>
			<biblScope unit="page" from="25" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A new algorithm for multiplication in finite fields</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pincin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1045" to="1049" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">The FHEMPCZK-cipher zoo</title>
		<author>
			<persName><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</author>
		<ptr target="http://fse.2016.rump.cr.yp.to/" />
	</analytic>
	<monogr>
		<title level="m">FSE 2016 rump session</title>
		<imprint>
			<date type="published" when="2016-12-21">2016. 21 Dec 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Evaluation of some block cipher modes of operation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<ptr target="http://web.cs.ucdavis.edu/~rogaway/papers/modes.pdf" />
	</analytic>
	<monogr>
		<title level="j">Cryptrec</title>
		<imprint>
			<date type="published" when="2011-12-21">2011. 21 Dec 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Fully homomorphic SIMD operations</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Des. Codes Cryptogr</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="81" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Cube attacks on non-blackbox polynomials based on division property, in CRYPTO</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Todo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Isobe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">10402</biblScope>
			<date type="published" when="2017">2017</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<author>
			<persName><forename type="first">K</forename><surname>Yasuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A new variant of PMAC: beyond the birthday bound, in CRYPTO</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6841</biblScope>
			<biblScope unit="page" from="596" to="609" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
