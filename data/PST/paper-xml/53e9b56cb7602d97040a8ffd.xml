<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">THE LOGIC OF BUNCHED IMPLICATIONS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Peter</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
							<email>ohearn@dcs.qmw.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">DEPARTMENT OF COMPUTER SCIENCE QUEEN MARY &amp; WESTFIELD COLLEGE UNIVERSITY OF LONDON</orgName>
								<address>
									<postCode>E1 4NS</postCode>
									<settlement>LONDON</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Pym</surname></persName>
							<email>pym@dcs.qmw.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">DEPARTMENT OF COMPUTER SCIENCE QUEEN MARY &amp; WESTFIELD COLLEGE UNIVERSITY OF LONDON</orgName>
								<address>
									<postCode>E1 4NS</postCode>
									<settlement>LONDON</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">THE LOGIC OF BUNCHED IMPLICATIONS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2C701C49A78F4F4CA8FC64A88CBEC265</idno>
					<note type="submission">Received August 21, 1998; revised December 9, 1998.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce a logic BI in which a multiplicative (or linear) and an additive (or intuitionistic) implication live side-by-side. The propositional version of BI arises from an analysis of the proof-theoretic relationship between conjunction and implication; it can be viewed as a merging of intuitionistic logic and multiplicative intuitionistic linear logic. The naturality of BI can be seen categorically: models of propositional BI's proofs are given by bicartesian doubly closed categories, i.e., categories which freely combine the semantics of propositional intuitionistic logic and propositional multiplicative intuitionistic linear logic. The predicate version of BI includes, in addition to standard additive quantifiers, multiplicative (or intensional) quantifiers ∀ new and ∃ new which arise from observing restrictions on structural rules on the level of terms as well as propositions. We discuss computational interpretations, based on sharing, at both the propositional and predicate levels. §1. Introduction.</p><p>then these rules for ⊗ and &amp; define the same connective, but without them the connectives are distinct.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This splitting of connectives has a long history <ref type="bibr" target="#b10">[12]</ref>, but the possibilities opened up by restricting structural rules were given a new perspective by vivid "resource interpretations" of linear logic. The leading example is perhaps the number-of-uses reading in which a proof of a linear implication ϕ ⊸ determines a function that uses its argument exactly once. Like ⊗, the linear implication is "multiplicative", which is to say that it combines separate contexts in its elimination, i.e., binary, rule.</p><formula xml:id="formula_0">Γ, ϕ ⊢ Γ ⊢ ϕ ⊸ ⊸ I Γ ⊢ ϕ ⊸ ∆ ⊢ ϕ Γ, ∆ ⊢ ⊸ E</formula><p>However, an important message of linear logic is that, in order to obtain an expressive system, one cannot stay in a pretty-but-weak system: it appears to be crucial to allow access to structurals in some manner. This is done in linear logic in a very specific way, via the "!" modality, which admits a recovery of conventional intuitionistic (or additive) implication ϕ → as !ϕ ⊸ . The number-of-uses reading of implication is extended to this modality by reading !ϕ as "as many ϕs as required".</p><p>But notice a curious asymmetry here. Removal of the structural rules enables conjunction to be split straightaway into additive and multiplicative parts, while the treatment of additive implication uses an additional notion, a modality. It seems natural to ask: could a direct decomposition of implication be given, as was done for conjunction?</p><p>The answer is yes. In particular, access to the structurals can be recovered in another, rather different way, not involving a modality. The technical cost of this conceptual symmetry is that we must work with a more richly structured notion of sequent, entailing a more delicate analysis of the prooftheoretic relationship between implication and conjunction.</p><p>Our purpose in this paper is to explore this alternative route to combining multiplicative and additive implication. We introduce a logic BI, the logic of bunched implications, by giving a proof theory, a semantics of the proof theory, and a semantics of truth. We also consider "resource interpretations" which begin to expose the computational consequences of some of the choices made.</p><p>In presenting this material, we will proceed at a high level: we concentrate on ideas rather than formal results; indeed, there are no proofs at all given in this paper. We have two reasons for adopting this approach. Firstly, that the material covered is too broad to be reasonably given, in full detail, in a short article such as this. Secondly, we hope that this style of presentation will help to expose some of BI's main features and properties in a direct fashion; many of these features can, we feel, be appreciated without becoming embroiled in too many formal details and proofs. Companion papers by each of us <ref type="bibr" target="#b25">[28,</ref><ref type="bibr">34,</ref><ref type="bibr">33]</ref> explore technical aspects of BI's semantics, proof theory and applications in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">A proof-theoretic introduction.</head><p>Recall that implication is inextricably bound up with conjunction, or at least with antecedent-forming operations used to formulate sequents. This connection goes so far that it is sometimes said that an introduction rule Γ, ϕ ⊢ Γ ⊢ ϕ → can be regarded, proof-theoretically, as defining the meaning of →. However far we may wish to take this point, it is clear that the character of the implication in a logic is married to, and in a sense determined by, that of the comma or conjunction. If, as is the case in BI, we have two forms of implication then we are faced with the question of which of them to use in the introduction rule, Γ, ϕ ⊢ Γ ⊢ ϕ ? .</p><p>That is, should the conclusion ϕ ? in this rule be a multiplicative or additive implication?</p><p>The connection between introduction rules and implications suggests a way out of this impasse: If an antecedent-forming operation determines the behaviour of an implication, and we have two implications, then we should have two antecedent-forming operations. So, we postulate an additional context-forming operation ";", and stipulate that Contraction and Weakening are possible for ";" but not for ",". The introduction rules then become Γ, ϕ ⊢ Γ ⊢ ϕ - * and Γ; ϕ ⊢ Γ ⊢ ϕ → .</p><p>In this scheme, the antecedents are no longer sequences, but are trees with propositions as leaves and internal nodes labelled by "," or ";", or in short, bunches <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b31">36]</ref>.</p><p>(Aside: We have chosen to use a different symbol, - * , for the multiplicative implication, in order to avoid confusion with ⊸. Although many of the formal properties in the multiplicative connectives are the same, the way that they mesh with additive connectives gives rise to different behaviour. In particular, some of the common readings of ⊸, such as the number-of-uses reading, do not directly carry over to - * .)</p><p>It is all very well to postulate proof rules in this way, but what meaning or significance, if any, does the resulting logic have? We argue herein that BI possesses two very natural semantics. The first, a semantics of the proof theory, arises from doubly closed categories (DCCs), in which a single category admits two closed structures or function spaces. It shows clearly the difference between BI and linear logic, where two closed categories are usually used. We shall return to this point in § §3.2 and 8.</p><p>The second semantics is a Kripke-style semantics of formulae, which combines Kripke's semantics of intuitionistic logic and Urquhart's semantics of multiplicative, intuitionistic linear logic. This second semantics gives BI more of a genuine status as a logic. That is, it gives us a way to read the formulae as propositions that are true or false, relative to a given world.</p><p>The resource interpretations of BI are stated in terms of a notion of sharing. We explain this in two areas: imperative programming, where the "resource" is a portion of the computer's store; and logic programming, where the "resource" refers to variables occurring in answer substitutions, and their locations on the paths followed during proof-search.</p><p>We also consider the vexed question of multiplicative quantifiers. In BI, the quantifiers come in two varieties:</p><formula xml:id="formula_1">Additive quantifiers ∀ ∃ Multiplicative quantifiers ∀ new ∃ new .</formula><p>The additive ones are exactly the quantifiers found in classical, intuitionistic and linear logic. The multiplicative ones are new, being intensional quantifiers of the kind long-sought in relevant logic. Throughout the course of the paper we concentrate, for the most part, on propositional BI; quantifiers are considered briefly in § §6 and 7. The general point, however, is that structural restrictions make just as much sense on level of terms in predicate logic as they do on the level of propositions. The quantifiers reflect this, giving rise to a form of "resource sensitivity" over individuals or term denotations in a predicate logic. In fact, predicate BI is a rich, subtle and, we claim, elegant logic which makes many more distinctions between connectives than propositional BI. However, this theory is beyond the scope of this introductory article; the details of predicate BI can be found in <ref type="bibr">[33]</ref>.</p><p>1.3. The significance of BI. We must emphasize that the tools used to define and analyze BI have been available for some time. For one, bunches have been used in sequent calculi for relevant logics <ref type="bibr" target="#b11">[13]</ref>; the mere fact of existence of a logic like BI would come as no surprise to relevantists. For another, many of the categorical fundamentals of BI had, with the benefit of hindsight, already been laid down even earlier, in a classic paper of Day <ref type="bibr" target="#b8">[10]</ref>. One of our main aims here is to stress the semantic link-up, as providing a theoretical justification for the informal derivation of bunched structure from proof-theoretic considerations, as sketched in this section.</p><p>The logical significance of BI can be seen to reside in the clarity of its semantics. DCCs directly combine cartesian closed categories and symmetric monoidal closed categories, i.e., of models of intuitionistic logic and multiplicative intuitionistic linear logic <ref type="bibr" target="#b21">[24,</ref><ref type="bibr" target="#b20">23,</ref><ref type="bibr" target="#b37">42]</ref>, structures which exist independently of logic, in mathematics. Indeed, DCCs also arise naturally; see § §3 and 3.1. Similarly, BI's Kripke semantics is a direct combination of Kripke's semantics for intuitionistic logic and Urquhart's semantics for multiplicative intuitionistic linear logic. This latter semantics provides a link to BI's computational significance. An elementary examination of the nature of resources, at both the propositional and predicate levels, leads one to consider a semantics of this type. This point of view is discussed in <ref type="bibr">[34,</ref><ref type="bibr">33,</ref><ref type="bibr" target="#b29">32]</ref>.</p><p>We say more on the connection to relevant logic at the end of the paper in §8, where we also give a detailed comparison to linear logic, and discuss BI's place in the general context of logics that limit use of the structural rules. §2. Propositional BI. In this section, we give a presentation of BI in sequential natural deduction form, i.e., a sequent presentation based on introduction and elimination rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Connectives.</head><p>Additive connectives</p><formula xml:id="formula_2">1 ∧ → ⊥ ∨ Multiplicative connectives I * - *</formula><p>The additive connectives correspond to those of intuitionistic logic, IL, whereas the multiplicative connectives correspond to those of multiplicative, intuitionistic linear logic, or MILL (we refer to <ref type="bibr" target="#b38">[43]</ref> for background information on the two systems). Bunches.</p><formula xml:id="formula_3">Γ ::= ϕ propositional assumption | {} m multiplicative unit | Γ, Γ multiplicative combination | {} a additive unit | Γ; Γ additive combination.</formula><p>We write Γ(∆) to indicate a bunch in which ∆ appears as a subtree. We write Γ(∆ ′ ) for the similar tree where ∆ ′ replaces ∆. (So Γ(-) is a kind of positional notation indicating an incomplete tree that can be completed by placing various trees in its hole.) We don't present a more compact representation of bunches using, say, nested multisets or sequences instead of binary operators; the real point of bunches is to let us get the implications right. We use an equivalence on trees instead of worrying about representation.</p><p>Coherent equivalence: Γ ≡ Γ ′ . ≡ is the least equivalence relation on bunches satisfying 1. Commutative monoid equations for {} a and ; 2. Commutative monoid equations for {} m and , 3. Congruence: if ∆ ≡ ∆ ′ then Γ(∆) ≡ Γ(∆ ′ ). Note that ";" and "," do not distribute over one another.</p><p>Judgements. Logical consequences are of the form</p><formula xml:id="formula_4">Γ ⊢ ϕ</formula><p>where Γ is a bunch and ϕ a formula. The rules for deriving judgements now follow.</p><p>Identity and structure.</p><formula xml:id="formula_5">ϕ ⊢ ϕ Id Γ ⊢ ϕ ∆ ⊢ ϕ ≡ (where ∆ ≡ Γ) Γ(∆) ⊢ ϕ Γ(∆; ∆ ′ ) ⊢ ϕ W Γ(∆; ∆) ⊢ ϕ Γ(∆) ⊢ ϕ C Multiplicatives. {} m ⊢ I II Γ({} m ) ⊢ ∆ ⊢ I Γ(∆) ⊢ IE Γ, ϕ ⊢ Γ ⊢ ϕ - * - * I Γ ⊢ ϕ - * ∆ ⊢ ϕ Γ, ∆ ⊢ - * E Γ ⊢ ϕ ∆ ⊢ Γ, ∆ ⊢ ϕ * * I Γ(ϕ, ) ⊢ ∆ ⊢ ϕ * Γ(∆) ⊢ * E Additives. {} a ⊢ 1 1I Γ({} a ) ⊢ ∆ ⊢ 1 Γ(∆) ⊢ 1E Γ; ϕ ⊢ Γ ⊢ ϕ → →I Γ ⊢ ϕ → ∆ ⊢ ϕ Γ; ∆ ⊢ →E Γ ⊢ ϕ ∆ ⊢ Γ; ∆ ⊢ ϕ ∧ ∧I Γ(ϕ; ) ⊢ ∆ ⊢ ϕ ∧ Γ(∆) ⊢ ∧E Γ ⊢ ϕ i Γ ⊢ ϕ 1 ∨ ϕ 2 (i = 1, 2) ∨I Γ ⊢ ϕ ∨ ∆(ϕ) ⊢ ∆( ) ⊢ ∆(Γ) ⊢ ∨E Γ ⊢ ⊥ Γ ⊢ ϕ ⊥E</formula><p>We do not include a multiplicative disjunction (such as fission, or par) in BI, not because it is straightforward, but because it is not. Such a disjunction would come along naturally with a calculus which has bunched multiple conclusions.</p><p>Notice that the introduction and elimination rules for additive and multiplicative implications, conjunctions and their units are identical in form. The difference between them is the antecedent-combining operations they use. Because ";" admits Weakening and Contraction, rules where additive maintenance is explicit are admissible:</p><formula xml:id="formula_6">Γ ⊢ ϕ → Γ ⊢ ϕ Γ ⊢ Γ ⊢ ϕ Γ ⊢ Γ ⊢ ϕ ∧ .</formula><p>The question of whether these rules can replace the more explicit ones above is delicate <ref type="bibr" target="#b25">[28,</ref><ref type="bibr">34]</ref>.</p><p>Lemma 1. The Cut rule is admissible:</p><formula xml:id="formula_7">Γ(ϕ) ⊢ ∆ ⊢ ϕ Γ(∆) ⊢ Cut</formula><p>Notice that this formulation of cut covers both the ";" and "," cases in the construction of bunches. A presentation of BI as a sequent calculus, in which elimination rules are replaced by left-rules, can be found in <ref type="bibr">[34,</ref><ref type="bibr">33]</ref>, in which are detailed the connection to the sequential natural deduction formulation, including its presentation as the α -calculus, cut-elimination and normalization. For now, the following essential result suffices: Proposition 2. BI's natural deduction system is, with respect to the evident reductions and commuting conversions, strongly normalizing. It has also the subject reduction property.</p><p>BI contains MILL and IL as sublanguages; the precise connection to them can be stated as follows:</p><formula xml:id="formula_8">Proposition 3. 1. BI is conservative over IL. That is, ϕ 1 ; . . . ; ϕ n ⊢ ϕ is provable in BI if</formula><p>and only if ϕ 1 , . . . , ϕ n ⊢ ϕ is provable in IL, where each ϕ i and ϕ is a formula built up using additive connectives only.</p><formula xml:id="formula_9">2. BI is conservative over MILL. That is, ϕ 1 , . . . , ϕ n ⊢ ϕ is provable in BI if and only if ϕ * 1 , . . . , ϕ * n ⊢ ϕ * is provable in MILL,</formula><p>where each ϕ i and ϕ is a formula built up using multiplicative connectives only and (-) * replaces * by ⊗ and - * by ⊸. An important point is that conservativity does not extend to MAILL, which is MILL extended with additive conjunction and disjunction. The reason is that BI admits distribution of additive conjunction over disjunction, by which we mean ϕ ∧ ( ∨ ) ⊢ (ϕ ∧ ) ∨ (ϕ ∧ ) and its converse. To prove distribution in BI one can simply use the usual intuitionistic proof, which refers to ";" but not ",". MAILL, on the other hand, does not admit distribution. We will return to this point in §8.</p><p>That the conservativity properties in the proposition hold can be seen straightforwardly from a semantics of BI's proof theory. §3. Doubly closed categories. In order to explain the structure of a proof theory, it is usually useful to give a categorical description of it, in which the connectives enjoy universal properties and satisfy naturality conditions. To do this for BI, note that the semantics of proofs for IL is given using cartesian closed categories and that for MILL using symmetric monoidal closed categories <ref type="bibr" target="#b21">[24,</ref><ref type="bibr" target="#b20">23,</ref><ref type="bibr" target="#b37">42]</ref>. In each case, the introduction rule for implication corresponds to an adjunction where the internal hom is a right adjoint: to a cartesian product, for IL, and a tensor product, for MILL.</p><p>To model BI we simply ask for a category that has all the structure necessary to model both MILL and IL.</p><p>A doubly closed category, or DCC for short, is a category equipped with two monoidal closed structures. A DCC is called cartesian if one of the closed structures is cartesian and the other symmetric monoidal and bicartesian if, in addition, it has finite coproducts. In brief, models of proofs for BI are given using bicartesian DCCs.</p><p>To see how DCC structure gives rise to bunches, consider the two adjunctions</p><formula xml:id="formula_10">[H * E, F ] ∼ = [H, E - * F ] [H ∧ E, F ] ∼ = [H, E → F ]</formula><p>where * is a symmetric monoidal product and ∧ a cartesian (or categorical) product.</p><p>To mimic these adjunctions in the proof theory one would like to have a context extension corresponding to * and another to ∧. This leads directly to the rules</p><formula xml:id="formula_11">Γ, ϕ ⊢ Γ ⊢ ϕ - * Γ; ϕ ⊢ Γ ⊢ ϕ →</formula><p>and to the tree-like structure of antecedents. Suppose, for a given DCC, we have an assignment of an object [[p]] to each propositional letter. We call this an interpretation. Any interpretation extends in the obvious way to each formula [[ϕ]], and we can assign an object [[Γ]] to each bunch by mapping "," to * and ";" to ∧ in the DCC. (In our notation we are using letters E, F H to refer directly to the objects of a DCC, with <ref type="bibr">[[ϕ]</ref>] indicating an object determined by a formula.)</p><p>A form of soundness and completeness for these interpretations can be stated as follows <ref type="bibr">[34,</ref><ref type="bibr">33]</ref>:</p><formula xml:id="formula_12">Proposition 4. Γ ⊢ ϕ is provable in BI if and only if, for every DCC, D, and interpretation [[-]] in D, the hom set D[[[Γ]], [[ϕ]]] is non-empty.</formula><p>A stronger notion of soundness and completeness is also possible <ref type="bibr">[34,</ref><ref type="bibr">33]</ref>. Given interpretations for propositional letters, any</p><formula xml:id="formula_13">BI proof of a judgement Γ ⊢ ϕ determines a morphism [[Γ]] → [[ϕ]</formula><p>] in a DCC. The stronger form connects the equality induced by this DCC semantics to an equational theory for proofs.</p><p>(Note: The assignment of morphisms to derivations should be evident, except that the interpretation of the elimination rule for ∨ we need to use distributivity of both * and ∧ over ∨. We get that because E * (-) and E ∧ (-) are both left adjoints, and so they preserve coproducts.)</p><p>The conservativity of BI over IL can now be seen immediately in terms of DCCs. For suppose C is a categorical model of IL, i.e., a bicartesian closed category. Then we can regard it as a bicartesian DCC, in which the two closed structures are the same. When we restrict to the additive fragment of BI, this shows that the denotations of BI proofs are exactly the same as those in the model of IL.</p><p>The DCC semantics suggests some, at first sight, unusual properties. In particular, a morphism from E to F can variously be viewed as a map I → E - * F or 1 → E → F using the adjunctions and, indeed, we have the following isomorphisms of hom sets:</p><formula xml:id="formula_14">[1, E → F ] ∼ = [E, F ] ∼ = [I, E - * F ].</formula><p>In BI, these isomorphisms are realized by the following deductions:</p><formula xml:id="formula_15">ϕ ⊢ {} a ; ϕ ⊢ {} a ⊢ ϕ → ϕ ⊢ {} m , ϕ ⊢ {} m ⊢ ϕ - * {} a ⊢ ϕ → ϕ ⊢ ϕ {} a ; ϕ ⊢ ϕ ⊢ {} m ⊢ ϕ - * ϕ ⊢ ϕ {} m , ϕ ⊢ ϕ ⊢ .</formula><p>Although these observations may make the difference between - * and → appear rather thin, the two implications are not interconvertible:</p><formula xml:id="formula_16">ϕ - * ϕ → and ϕ → ϕ - * .</formula><p>An example of a model will help to confirm these remarks.</p><p>Example 5. Set × Set is bicartesian closed, with coproducts and cartesian closed structure defined pointwise from their corresponding versions in Set. A symmetric monoidal closed structure is given by</p><formula xml:id="formula_17">I = (1, 0) (E 0 , E 1 ) * (F 0 , F 1 ) = ((E 0 × F 0 ) + (E 1 × F 1 ), (E 0 × F 1 ) + (E 1 × F 0 ) (E 0 , E 1 ) - * (F 0 , F 1 ) = ((E 0 → F 0 ) × (E 1 → F 1 ), (E 0 → F 1 ) × (E 1 → F 0 )).</formula><p>More generally, if M is a commutative monoid, considered as a discrete monoidal category, then Set M is a bicartesian DCC; in this example, M is the two-element commutative monoid {0, 1} with addition modulo two.</p><p>Example 5 does not appear to convey any particularly useful computational ideas but we can use it to make a few remarks.</p><p>1. It is a non-degenerate model, in that I is not a terminal object and * is not cartesian product. So the definition of DCCs does not somehow induce a collapse of the specified structure.</p><p>2. There are no maps in the model from 1 to I . 3. ((0, 1) → (1, 0)) = (1, 0) and ((0, 1) - * (1, 0)) = (0, 1). This, combined with the fact that there are no maps between (0, 1) and (1, 0) in either direction, implies that there are no maps from ((0, 1) → (1, 0)) to ((0, 1) - * (1, 0)) or back, confirming the remark above that → and - * are not convertable to one another in the linear version of the bunched language.</p><p>4. There is no functor ! : Set × Set → Set × Set admitting an isomorphism !E - * F ∼ = E → F , thus indicating that a DCC is not simply a model of linear logic in disguise. To see the remark, consider that (1, 0) → (2, 2) = (2, 1) but that, for any C is, C - * (2, 2) = (X, Y ) for sets X and Y of the same cardinality. Therefore, for any "!" we try to pick, !E - * (2, 2) cannot be (2, 1).</p><p>3.1. Day's construction. We can generate a rich class of models of BI using a general construction due to Brian Day <ref type="bibr" target="#b8">[10]</ref>. He shows that any monoidal (not necessarily closed) category (C, * , I ) induces a monoidal closed structure on the functor category Set C op , and that when (C, * ,</p><formula xml:id="formula_18">I ) is symmetric monoidal so is Set C op .</formula><p>The construction is as follows. The unit I of the monoidal structure is C[-, I ]. Given functors E and F , the formula for the tensor product is written using co-ends:</p><formula xml:id="formula_19">(E * F )Z = X,Y EX × FY × C[Z, X * Y ].</formula><p>The formula for - * uses an end:</p><formula xml:id="formula_20">(E - * F )Z = X Set C op [EX, F (Z * X )] ∼ = Set C op [E, F (Z * -)].</formula><p>The formulae for (E * F )Z and (E - * F )Z are both contravariant in Z, giving the morphism parts of the functors. It is often possible to give an explicit description of the tensor product without using co-ends at all. In fact, we already did this with the Set × Set example above.</p><p>Two observations are useful for working with the tensor product. The first is that we have a form of pairing operation: given a ∈ EX and b ∈ BY we can form an element [a, b] ∈ (E * F )(X * Y ). To see how this element is defined, consider that the co-end E * F (Z) can be described as a quotient of quintuples (X, Y, f :</p><formula xml:id="formula_21">Z → C X * Y, a ∈ EX, b ∈ FY ). The pair [a, b] is then the equivalence class of (X, Y, id X * Y , a, b).</formula><p>The second is a representation result which characterizes maps out of a tensor products: natural transformations E * F → H are in bijection with families of functions</p><formula xml:id="formula_22">EX × FY → H (X * Y )</formula><p>natural in X and Y . To see why this is true, consider the definition of - * , and the isomorphism [E * F, H ] ∼ = [E, F - * H ]: the multi-map characterization is, essentially, forced by - * .</p><p>To obtain models of BI, we can combine this structure for multiplicatives with the standard fact that Set C op is bicartesian <ref type="bibr" target="#b21">[24]</ref>. Finite products are determined pointwise, from those in Set, and the additive exponent can be represented as</p><formula xml:id="formula_23">(A → B)Z = Set C op [C[-, Z] ∧ A, B]. Proposition 6 ([10]). If C is a symmetric monoidal category, then Set C op is a bicartesian DCC.</formula><p>It is worth remarking that Day describes his results in much greater generality, in the context of enriched categories, so this gives us many more models than those mentioned in the proposition.</p><p>In a separate paper <ref type="bibr" target="#b9">[11]</ref>, Day also shows that the Yoneda embedding preserves closed structure; this is an analogue of the standard fact that Yoneda preserves CCC structure. From this we may conclude that BI is conservative over MILL, again not only on the level of provability but also on the semantics of proofs.</p><p>3.2. Non-interpretations. We have seen how DCCs expose some of the workings of BI's proof theory: They can equally be used to indicate how the theory does not work by considering some non-examples of models.</p><p>First, CPOs (pointed, -complete partial orders) admit constructions that are reminiscent of BI. If E and F are CPOs then the strict function space E ⊸ F , continuous function space E → F , smash product E ⊗ F and cartesian product E × F are all CPOs. However, this does not give us a DCC, because (→, ×, 1) is the cartesian closed structure in the category of continuous functions, while (⊸, ⊗, I ) gives monoidal closed structure in the category of strict continuous functions. A DCC requires that a single category admit both closed structures.</p><p>The situation with CPOs, where two closed categories are involved, is typical of linear logic. For example, in the coherence space model <ref type="bibr" target="#b13">[15]</ref> we have a monoidal exponent ⊸ and a cartesian exponent →, but the former is closed for the category of linear maps and the latter for the category of stable maps.</p><p>That, for example, the coherence space model does not work for BI may seem just a technical curiosity, but the reasons for why it does not run rather deep and relate to "resource interpretations" of the connectives <ref type="bibr" target="#b25">[28]</ref>. For example, the judgement</p><formula xml:id="formula_24">{} m ⊢ ϕ - * ((ϕ → ϕ → ) → )</formula><p>has a proof that uses the ϕ premiss twice:</p><p>. . .</p><formula xml:id="formula_25">x : ϕ; f: ϕ → ϕ → ⊢ f x : ϕ → . . . x : ϕ; f: ϕ → ϕ → ⊢ x : ϕ x : ϕ; f: ϕ → ϕ → ⊢ (f x) x : C, →E x : ϕ ⊢ αf . (f x) x : ((ϕ → ϕ → ) → ) →I {} m , x : ϕ ⊢ αf . (f x) x : ((ϕ → ϕ → ) → ) ≡ {} m ⊢ x . αf . (f x) x : ϕ - * ((ϕ → ϕ → ) → ) - * I</formula><p>Here we have used a -calculus-like notation for proof-terms, where α stands for additive abstraction and for multiplicative (or inear). In the key, toppictured, step we use the admissible rule for → elimination (or equivalently we use → E followed by Contraction). It is at this step that the way that → admits sharing between (f x) and its argument x appears. The point of this example is the two occurrences in the body (f x) x of the argument x to a - * -typed function. This serves to illustrate that the idea that a multiplicative, or "linear", function uses its argument exactly once does not directly carry over to BI. For this reason, we have chosen not to adopt the symbol ⊸, with the associated readings it tends to carry, for BI's multiplicative implication.</p><p>If the number-of-uses reading-which is often considered to be characteristic for a logic, like linear logic, which restricts Contraction-does not carry over, then what meaning do the BI connectives have? And what is the justification for this judgement?</p><p>We can answer these questions in two ways. First, we claim that the Kripke resource semantics, given later, provides a natural truth-based semantics for BI. We do not have to appeal to -calculus to make sense of it (although we certainly can do so). Secondly, although BI can be understood in terms of its truth semantics, we can also offer a resource-based interpretation of proofs which does justify these judgements. We call this the (propositional) sharing interpretation. §4. The sharing interpretation, I. To set the stage, the background idea is of functional programming data such as pairs, functions and so on, but with an additional, intensional, notion of resource which can be accessed during a computation. The resources are distributed, in the sense that a value may have access to some, to none or to all of them.</p><p>We concentrate on the two implications.</p><p>• ϕ - * : functions that may not share resources with their arguments.</p><p>• ϕ → : functions that may share resources with their arguments.</p><p>To illustrate how this informal reading of connectives works, recall the "unusual" example of a proof-term x . αf . (f x) x, in which a multiplicative assumption is used twice. From the point of view of the sharing interpretation, the subterm (f x) in the proof-term is allowed to share with its argument x, because f x is of additive function type ϕ → . That is why (f x) x is reasonable: There is no requirement that an argument to a - * -typed function be used just once, only that it does not share with other variables in the proof-term. The kind of thing that would be disallowed by the sharing interpretation is an application (f x) x, where f has type ϕ - * ϕ - * .</p><p>The reading extends to other connectives in a straightforward way. For example, ϕ * is the type of non-sharing pairs, and ϕ ∧ is the type of pairs that might share.</p><p>The sharing interpretation is inspired by John Reynolds's work on syntactic control of interference and Idealized Algol ( <ref type="bibr" target="#b32">[37,</ref><ref type="bibr" target="#b33">38]</ref>, and also the relevant <ref type="bibr" target="#b26">[29]</ref>). These are programming languages that use affine and intuitionistic -calculus respectively, together with imperative features such as the assignment statement x := e. The calculi give the "functional data" of the sharing interpretation, and the computer's store gives the "intensional" component; see <ref type="bibr" target="#b25">[28]</ref>.</p><p>A concrete model that corresponds to the informal reading can be obtained as an instance of Day's construction. Let I be the category of finite sets and injective functions. We think of an object X here as a possible world which identifies a finite set of cells in the computer memory. These worlds are used to capture the intensional part of the sharing interpretation, that part which refers to resource instead of merely to values.</p><p>The (object parts of the) functors for implication display the basic character of the semantics: Given E, F : I → Set,</p><formula xml:id="formula_26">(E - * F )(X ) = Set I [E(-), F (X + -)] (E → F )(X ) = Set I [E(X + -), F (X + -)]</formula><p>where + is the evident functor on I given by disjoint union in Set. Notice how these clauses correspond directly to the sharing interpretation. For - * , the absence of X in E(-) indicates how a function (which lives in world X ) and argument must access disjoint resources. For →, the presence of X in E(X + -) indicates how a procedure may share store with its argument. The other connectives are defined as in Day's construction.</p><p>We can relate these definitions further to the informal reading by defining a functor cell, which plays the role of the type of storage cells: It is the inclusion functor from I to Set. The value cell X = X of cell at world X is thought of as the set of cells associated with that world. Now, consider any element p ∈ cell - * (cell - * E)X . The definition of - * says that, for an arbitrary Y and a ∈ cell Y , p[Y ]a is an element of (cell - * E)(X + Y ). Unpacking further, this says that, for an arbitrary Z and b</p><formula xml:id="formula_27">∈ cell Z, (p[Y ]a)[Z]b ∈ E(X + Y + Z).</formula><p>The crucial point is that a is in the X -component and b in the Z-component: so, from the point of view of the summed-up world X + Y + Z, they must be different cells.</p><p>(An aside: Strictly speaking, the sharing interpretation presented in this section works as well for the affine variant of BI, where "," admits Weakening.</p><p>In terms of the model, Set I is an affine DCC, in that the unit I = I[{}, -] is a terminal object. A linear variant of this model can be obtained by replacing I by the category of finite sets and bijections. The informal reading of connectives is then adjusted by saying that an additive function accesses the same resources as its argument.)</p><p>Our intention in this section has been to explain how there is a resource interpretation of BI proofs that is consistent with the fact that - * -typed functions in BI (or its calculus of proof-terms) can use their arguments multiple times. We have seen that such an interpretation is possible, and given a specific model corresponding to it. We have also hinted at a connection to imperative programming, but a full study of that connection would take us too far afield here; we refer to the companion paper <ref type="bibr" target="#b25">[28]</ref> for more information. §5. Kripke resource semantics. Thus far we have considered BI from proof-or type-theoretic perspectives, with a semantic focus on the interpretation of proofs. However, BI can also be understood from a model-theoretic point of view, in which we consider a notion of truth for formulae, which are thus seen to denote propositions in the established sense. We are not looking for an algebraic semantics here, where one takes (say) a Heyting algebra with enough structure to model the multiplicatives; this would just be a collapsed version of the DCC semantics, and would not be very informative.</p><p>A more penetrating semantics of MILL was given by Urquhart <ref type="bibr" target="#b39">[44]</ref>. The semantics uses possible worlds, arranged as a commutative monoid, which Urquhart justifies in terms of a philosophical analysis of a notion of "piece of information". Recall also that Kripke gave a possible world semantics of IL, which can be understood as using functor categories Set P , where P is a preorder <ref type="bibr" target="#b19">[22]</ref>. We can obtain a semantics of BI, which combines these two semantics directly, by working in categories Set C op , where C is a symmetric monoidal category. For simplicity, we describe this for the special case that C op = M is a partially-ordered commutative monoid. (This means that the multiplication of the monoid must be monotone, but note that it need not be given by meet or join, and the unit need not be a least or greatest element.) Given such a monoid M = (M, •, e, ⊑), the semantics of BI is defined via a forcing relation m |= ϕ, for a world m ∈ M and formula ϕ. All propositions will satisfy the familiar monotonicity property from intuitionistic logic: We can read the clauses informally in terms of resources. For example, the formula for * says, roughly, that a world forces a multiplicative conjunction if and only if there is a partition of that world into components which force the constituents of the formula. This narrative about partitioning suggests a sense in which multiplicative (or intensional, in the relevant terminology) connectives depend on the internal structure of worlds. On top of this, one can understand the formula for - * as follows: if m is the cost of the function and if n is the cost of (any) argument, then the cost of obtaining the result of applying the function to the argument is m • n. The clauses for additives should be understood in terms of conservation, rather than splitting, of information. For example, to establish an additive conjunction one can make use of the same information when showing each conjunct.</p><p>The reader might have recognized a similarity to Day's construction in the treatment of the multiplicatives. This can be made precise as follows: Given an interpretation of propositional letters, we can define an object <ref type="bibr">[[p]</ref>] in Set M , where</p><formula xml:id="formula_28">[[p]]m = { * } if m |= p {} if m |= p</formula><p>with the morphism part being evident. <ref type="bibr">[[-]</ref>] extends to all formulae inductively, using the DCC structure of Set M . The connection between the two semantics can then be stated as follows:</p><p>Proposition 7. For all formulae ϕ and worlds m,</p><formula xml:id="formula_29">[[ϕ]]m is non-empty if and only if m |= ϕ. An important point is that [[ϕ * ]]m can have more than one element if M is not connected; not every [[ϕ]</formula><p>] is a subobject of 1. Thus, Urquhart's form of semantics is not exactly the same as Day's, but it is closely related to it and can be recovered from it <ref type="bibr">[34,</ref><ref type="bibr">33]</ref>. We regard the DCC and Kripke resource semantics as complementary. DCCs provide a proof-theoretic view, emphasizing adjoint relationships between implications and conjunctions. The Kripke semantics exists independently, and emphasizes a notion of truth, parameterized by worlds. The world structure can be understood as axiomatizing some minimal assumptions about resources, in a way similar to the considerations of Urquhart, but with some key points of divergence [34]. Day's construction provides the link between the two views.</p><p>One last comment. In his work Urquhart was aiming to model relevant logics which admit Contraction, and for this he included an equation m • m = m. This lead to a mismatch with the relevant logic R, where (ϕ - * ∨ ) ∧ ( - * ) - * (ϕ - * ) holds in Urquhart's semantics but is not provable in R. We do not have such a mismatch here for two reasons. First, we do not accept the equation, because BI does not admit Contraction for ",". Second, even if we were to add Contraction to BI we would not insist on m • m being equal to m, but only greater or equal. In this respect, our semantics is related to the ternary relation semantics of Routley and Meyer <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b31">36]</ref>; but taking a commutative monoid, along the lines of Urquhart, as primitive seems a natural choice in the light of Day's construction. §6. Quantifiers. The predicate version of BI has the familiar intuitionistic quantifiers ∀ and ∃. It also has intensional quantifiers, obtained by observing structural restrictions on the level of terms as well as propositions. This is formulated using a notion of bunch of variables, which is separate from bunches of propositions. We describe this here using a single-sorted version of predicate BI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bunches of variables.</head><p>x is used to range over variables, and X over bunches of variables.</p><formula xml:id="formula_30">X ::= x | X ; X | X, X | {} m | {} a .</formula><p>Bunches of variables are subject to the linearity restriction: any variable appears at most once in a bunch.</p><p>Judgements. We consider terms-and propositions-in-context, with a syntax of the form X ⊢ t : Term and X ⊢ ϕ : Prop which assert that a term or proposition is well-formed in context X <ref type="bibr" target="#b22">[25]</ref>.</p><p>Constants and predicate letters are given by schematic judgements and, as in the bunched logic itself, Contraction and Weakening are allowed for ";" but not for ",". We omit a formal definition and move on to consider the quantifiers.</p><p>Logical judgements have the form (X ) Γ ⊢ ϕ asserting that ϕ is a consequence of Γ, where the terms and atomic predicates in the sequent are well-formed according to X .</p><p>Multiplicatives.</p><formula xml:id="formula_31">(X, x) Γ ⊢ ϕ (X ) Γ ⊢ ∀ new x.ϕ ∀ new I (X ) Γ ⊢ ∀ new x.ϕ Y ⊢ t : Term (X, Y ) Γ ⊢ ϕ[t/x] ∀ new E (X, Y ) Γ ⊢ ϕ[t/x] Y ⊢ t : Term (X ) Γ ⊢ ∃ new x.ϕ ∃ new I (X ) Γ ⊢ ∃ new x.ϕ (Y, x) ∆, ϕ ⊢ (X, Y ) Γ, ∆ ⊢ ∃ new E Additives. (X ; x) Γ ⊢ ϕ (X ) Γ ⊢ ∀x.ϕ ∀I (X ) Γ ⊢ ∀x.ϕ X ⊢ t : Term (X ) Γ ⊢ ϕ[t/x] ∀E (X ) Γ ⊢ ϕ[t/x] X ⊢ t : Term (X ) Γ ⊢ ∃x.ϕ ∃I (X ) Γ ⊢ ∃x.ϕ (X ; x) ∆; ϕ ⊢ (X ) Γ; ∆ ⊢ ∃E</formula><p>The idea of the introduction rule for ∀ new is that we may infer ∀ new x.ϕ in the usual way for universal quantification, except that the variable x must sit in multiplicative combination with all of the other variables. In the elimination rule we must be careful not to substitute an arbitrary term for x, but only one that is respective of the multiplicative relationship between x and other variables in X . In particular, t cannot contain any of these other variables appearing in X ; this requirement is implemented by the linearity restriction. The universal introduction rules have the usual restriction that x must not occur in Γ; similarly, the existential elimination rules have the restriction that x must not occur in ∆ or .</p><p>A consequence of these observations is that it is not exactly reasonable to read ∀ new literally as "for all". Rather, we must take into account that in ∀ new x.ϕ the multiplicative relationship between x and other variables must be observed. In terms of the sharing interpretation, we would read it as "for all x that don't share resources with other variables in ϕ", or more briefly, for all new x. The nomenclature for ∀ new can be considered to come from the relationship it has with new storage variables in Idealized Algol. Similar considerations apply to ∃ new .</p><p>It is important to avoid the trap of thinking of ∀ new as an infinite multiplicative conjunction; this idea is sometimes mentioned, by analogy with the view of additive quantification as an infinite additive conjunction. Rather, ∀ new is closely allied to the multiplicative implication - * , although a version allied We now move on to give the semantics of the quantifiers. The semantics of the additive quantifiers is standard, and the multiplicative quantifiers use the monoid structure, as follows:</p><formula xml:id="formula_32">(X ) u | m |= ∀x . ϕ if and only if ∀n ⊑ m . ∀d ∈ Dn . (X ; x) ([[X ]](n ⊑ m)u, d ) | n |= ϕ (X ) u | m |= ∃x . ϕ if and only if ∃d ∈ Dm . (X ; x) (u, d ) | m |= ϕ (X ) u | m |= ∀ new x . ϕ if and only if ∀n . ∀d ∈ Dn . (X, x) [u, d ] | n • m |= ϕ (X ) u | m |= ∃ new x . ϕ if and only if ∃n . ∃d ∈ Dn . (X, x) [u, d ] | n • m |= ϕ.</formula><p>In the multiplicative cases, we have used the pairing operation [u, d ] for Day's tensor product ( §3.1). In each case, it takes an environment u ∈ The difference between ∀ and ∀ new is that the former considers elements d ∈ Dn only in accessible worlds where n ⊑ m, where for the latter we look to a completely separate world n, and then use the monoid operation • to combine it with m.</p><p>The multiplicative existential is different in another respect from its additive counterpart. The additive ∃, from intuitionistic logic, is often described as being "local", in that the definition stays at the same world, where for ∀ you travel to accessible worlds to find elements. The multiplicative ∃ new does not stay at the same world when it looks for an element that exists, but nor does it travel along accessible lines; it hops to an arbitrary world, accessible or not, to find an element, and then considers the resulting formula in an environment formed by multiplicative combination.</p><p>The connection of multiplicative quantifiers to "newness" is clear if we go back to §4, and the sharing interpretation. Hopping to a world multiplicatively apart from the current one guarantees, in the sharing model, that the element obtained doesn't interfere with any identifiers evaluated at the current world. This non-interference property is one of the characteristic properties of local state in imperative languages.</p><p>We conclude this section with one further point, first mentioned in the introduction. The inclusion of bunched structure on the level of individuals raises the question of how this information will be incorporated in the rules for propositional connectives. For each connective, we must choose whether to follow multiplicative or additive maintenance on the level of individuals. The most common cases for multiplicative connectives are in fact cross cases, in which a multiplicative connective allows the same variable to be shared between its components (this approach is taken, for example, in predicate versions of linear logic). In BI, we also have the more radical possibility of multiplicative maintenance. A full discussion of predicate BI is beyond the scope of the present article: the details of predicate BI, including its proof theory, Kripke and categorical semantics, in both presheaves and fibred (indexed) categories, can be found in <ref type="bibr">[33]</ref>. However, we illustrate some of the main points in the next section, under the heading of logic programming. §7. The sharing interpretation, II. The background idea is now of logic programming, with proof-search as the primitive concept. Again, we have an intensional notion of resource. The resources here are variables occurring in answer substitutions. These will be distributed in the sense that access to variables will be localized to specific branches in the process of proof-search. On the level of the formulae themselves, this gives rise to a new form modularity in logic programs.</p><p>The proof-theoretic account of logic programming is simple and elegant. A program is expressed as an antecedent (or context), P, of a sequent and a goal is expressed as a succedent, typically existentially quantified. A goal ∃x.G is often written in the Prolog style as G(X ), with X described as a "logical variable". The whole sequent, P ?-∃x.G, is interpreted as a request to calculate a pair (Φ, ) in which is an answer substitution for X and Φ is a proof of the sequent P ⊢ G .</p><p>Operationally, we must describe how to execute a program when it is supplied with a goal. Recall first that inference rules can be read as reduction operators, from conclusion to premisses. (Kleene <ref type="bibr" target="#b18">[21]</ref> explains this in the case of the classical predicate calculus.) Such operators are the basic units of proof-search, or backward chaining, just as inference rules are the basic units of deduction, or forward chaining.</p><p>A semantics based on goal-directed proof-search is computationally appealing. Fix a program, P, and proceed, informally, as follows:</p><p>• Given a complex goal, G, we first reduce G by applying, as a reduction operator, the introduction rule which corresponds to the outermost connective of G. This reduction process is repeated until all remaining goal formulae are atomic. For example, given the goal G 1 ∧ (G 2 → G 3 ), we construct the tree . . .</p><formula xml:id="formula_33">P ?-G 1 . . . P; G 2 ?-G 3 P ?-G 2 → G 3 →I P ?-G 1 ∧ (G 2 → G 3 ) ∧I .</formula><p>Note that upper rightmost step adds G 2 to the program;</p><p>• Given an atomic goal, A, we invoke the program, using a resolution step. Suppose the program includes a proposition of the form ∀x.G → B, in which B is atomic, such that there is a substitution for x such that B = A.</p><p>Then we can immediately proceed to the sub-goal G :</p><formula xml:id="formula_34">P ?-G P ?-A (∀x.G → B in P, B = A).</formula><p>This operational semantics has several desirable features. Most importantly, it is not very non-deterministic, thereby reducing the need for backtracking to an acceptable level. More details of this model of computation can be found in <ref type="bibr" target="#b24">[27,</ref><ref type="bibr" target="#b30">35,</ref><ref type="bibr" target="#b23">26,</ref><ref type="bibr" target="#b14">17]</ref>.</p><p>Proofs constructed according to this goal-directed strategy are called uniform proofs <ref type="bibr" target="#b24">[27,</ref><ref type="bibr" target="#b30">35]</ref>. Uniform proofs are not complete for all of BI (or indeed for all of intuitionistic logic). For example, consider the following, trivially provable, sequent:</p><formula xml:id="formula_35">G ∨ H ⊢ G ∨ H.</formula><p>To see that there is no uniform proof of this sequent, consider the ∨I rule:</p><formula xml:id="formula_36">Γ ⊢ G Γ ⊢ G ∨ H Γ ⊢ H Γ ⊢ G ∨ H .</formula><p>Any attempt to reduce the right-hand side of G ∨ H ⊢ G ∨ H first forces a premature choice between G and H leading, for example, to</p><formula xml:id="formula_37">G ∨ H ⊢ G</formula><p>which is clearly not provable. However, uniform proofs are complete for a clausal hereditary Harrop fragment of BI. The basic idea is to restrict the classes of propositions permitted to occur in each side of a sequent, program clauses, P, on the left and goals, G, on the right. These two classes (here, for simplicity, we make do with a simplified form and suppress some operational issues) are defined by mutual induction as follows, where A ranges over atomic propositions:</p><formula xml:id="formula_38">Program clauses P ::= A | ∀x.G → A | ∀ new x.G - * A Goals G ::= A | G ∧ G | G * G | G ∨ G | P → G | P - * G | | ∃x.G | ∃ new x.G.</formula><p>A sequent is said to be hereditary Harrop if it is of the form P ⊢ G, where P is a bunch of program clauses and G is a goal. We get a version of the resolution step for each of ∀x.G → A and ∀ new x.G - * A. In fact, there are also the cross cases, one in which ∀ new is paired with → and one in which ∀ is paired with - * . The latter case is the one taken in linear logic and so in Lolli <ref type="bibr" target="#b15">[18]</ref> and Lygon <ref type="bibr" target="#b14">[17,</ref><ref type="bibr" target="#b30">35]</ref>.</p><p>The proof that uniform proofs are complete for hereditary Harrop sequents relies most naturally on a presentation of BI as a sequent calculus <ref type="bibr">[34]</ref>, in which the elimination rules are replaced by "left rules" which introduce connective to the left-hand side of a sequent. Provided we restrict our attention to normal proofs, such a presentation is equivalent to the natural deduction one. The details of these arguments are beyond the scope of our present purposes. However, it will be helpful to consider the resolution rule itself in a bit more detail. Recall that our treatment of quantifiers required the introduction of a collection of variables to sequents, (X ) Γ ⊢ G denoting that X is the set of first-order variables occurring in Γ and G. Resolution makes explicit use of these variables.</p><p>In predicate BI, the elimination rule for - * [33] can be replaced with the left rule</p><formula xml:id="formula_39">(X ) Γ ⊢ E (Y ) ∆, F ⊢ G (X, Y )Γ, E - * F ⊢ G - * L.</formula><p>Similarly, the ∀ new E rule can be replaced with the left rule</p><formula xml:id="formula_40">(X, x) Γ, E(x) ⊢ F (X ) Γ, ∀ new x.E ⊢ F ∀ new L.</formula><p>Taking these two together, and adding a substitution, the resolution rule for the multiplicative clause ∀ new x.G - * A can be expressed as the following derived rule:</p><formula xml:id="formula_41">(X ) Γ ⊢ G (Y ) A ⊢ B Id (A = B ) (X, Y ) Γ, ∀ new y.G - * A ⊢ B Resolution.<label>(1)</label></formula><p>A similar argument describes the case for the additive clause.</p><p>Whilst the behaviour of the additive clauses is familiar from Prolog-like languages, the multiplicative clauses provided by BI have a different interpretation which provides an account of local variables and interference in logic programming. An example will illustrate these ideas.</p><p>Consider a simple version of the famous "blocks world" <ref type="bibr" target="#b35">[40]</ref>, in which a robotic arm is supposed to manipulate blocks, here labelled x, y and z. Suppose further that we wish to remove from the computation-imagine perhaps that it is a construction process-any components that may be defective. A sketch of a possible program P follows the diagram: </p><formula xml:id="formula_42">∀ new x.G - * A(x) and ∀ new x.G ′ - * A ′ (x)</formula><p>the use of ∀ new can be interpreted as enforcing their non-interference, i.e., the fragments of the answer substitution generated by their invocations are disjoint. This behaviour arises partly from the form of - * L, in which the bunch of variables (X, Y ) is distributed to the left and right branches of the proof-search. Semantically, for models in Set M , this behaviour can be seen in (a case of) the forcing relation for implication in predicate BI:</p><formula xml:id="formula_43">(X, Y ) [u X , u Y ] | m X • m Y |= G - * A if and only if ∀n ∀Z ∀v ∈ [[Z]]n (Z, Y )[v, u Y ] | n • m Y |= G implies (X, Z) [u X , v] | m X • n |= A.</formula><p>Here, we require that Y ⊢ G : Prop and X ⊢ A : Prop, and we are using the pairing operation of Day's tensor product. The arbitrary nature of the environment v ∈ [[Z]]n, used in the clause for G, reflects the fact that the answer substitution on G's branch of the computation remains to be calculated. The contribution of the quantifiers is thus to regulate the scope of the variables. Again, this is reflected in the semantic clause for the quantifier:</p><formula xml:id="formula_44">(X ) u | m |= ∀ new x . A if and only if ∀n . ∀d ∈ Fn . (X, x) [u, d ] | n • m |= A.</formula><p>Here the environment for the instantiated clause is formed by taking Day's product of an environment for the whole clause with the interpretation of the substitution determined by the resolution step. These topics will be developed further in <ref type="bibr" target="#b29">[32]</ref>. §8. BI in context. Relation to relevant logic. BI should be considered a relevant logic, where we follow Stephen Read <ref type="bibr" target="#b31">[36]</ref> in considering "relevant logic" broadly, as referring to a variety of logics which control the use of structural rules, and not necessarily to ones that possess Contraction. In this context, the problem that originally gave rise to bunches involved not implication per se, but distribution of additive conjunction over disjunction (see <ref type="bibr" target="#b12">[14]</ref>); that is,</p><formula xml:id="formula_45">ϕ ∧ ( ∨ ) ⊢ (ϕ ∧ ) ∨ (ϕ ∧ )</formula><p>and its converse. The difficulty is that distribution fails in standard sequent calculi for logics that omit structural rules, whereas it is present in the main relevant logic R. Bunches were used to give a more delicate treatment of structural rules, which was crucial in accounting for distribution. Distribution of ∧ over ∨ has been a source of debate within and without the relevant logic community (see <ref type="bibr">[7]</ref> for a lively account). But for our purposes the debate is not a serious issue. Simply, distribution is valid in Kripke resource semantics, which we regard as a natural semantics, and we must accept it when working in a situation justified by the semantics. Similarly, distribution follows at once in the semantics of proofs, using the fact that E ∧ (-) is a left adjoint. This is not to suggest that one wants distribution in all circumstances; the use of linear typing to provide a type structure for domain theory <ref type="bibr" target="#b28">[31]</ref> is a prime example of where one does not.</p><p>From this historical perspective, the relationship of (propositional) BI to R can be stated as follows: to get to BI from Dunn's sequent calculus NR + for positive R first remove multiplicative Contraction, then add the unit I of multiplicative conjunction (fusion), and finally the intuitionistic falsity ⊥ and implication →. BI is also, we believe, closely related to Belnap's scheme of display logic, which gives a method of mixing several logics together <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b3">4]</ref>.</p><p>While we acknowledge this historical debt to relevant logic, the fact that BI could have been obtained in this way says nothing about its significance. That is, why would one ever consider modifying a presentation of R in this way? Our account of BI has, therefore, had somewhat of a revisionist bent. In a sense, the aim has been to show where BI, and bunches themselves, could have come from.</p><p>To recap, we began by noting a curious asymmetry. The decomposition of conjunction (and even disjunction, with the relevantists fission or linear logic's par) into multiplicative and additive components is decades old, but a similarly direct decomposition of implication had not been emphasized. It seemed natural to ask, then, whether such a decomposition could be given; implication, after all, lies at the very heart of logic. We then argued how this question, together with proof-theoretic considerations on implication, leads to the use of two forms of context extension. Evidence that the original question was worth asking was then provided by the semantics, particularly the semantics in terms of doubly closed categories, which display BI as a naturally occurring logic.</p><p>In contrast, it seems fair to say that (with some exceptions <ref type="bibr" target="#b31">[36,</ref><ref type="bibr" target="#b36">41]</ref>) bunches have appeared mainly as a technical device in the work of relevantists. And from the outside the view is often less charitable. For example, in his history of substructural logics <ref type="bibr" target="#b10">[12]</ref>, Došen mentions "complications of nonstandard Gentzen systems" and "technically unwholesome properties", comments that bear directly on bunched formalisms, or on features (such as distribution) that necessitate them. A certain regret is even evident in <ref type="bibr" target="#b3">[4]</ref>, when extra constants or connectives are entered into a Gentzen formalism in order to account for a particular logic.</p><p>We would argue, however, that bunches do have a good conceptual status. One may arrive at them from a consideration of the proof-theoretic relationship between conjunction and implication. And an alternative, perhaps more forceful, route is obtained from doubly closed categories, where the adjoint relationship between conjunction and implication leads inexorably to bunched structure. From this point of view bunches are not purely technical, and neither are they particularly unwholesome; rather, bunched structure is, in certain situations, semantically inevitable.</p><p>We have also sketched how BI admits "resource interpretations", based on sharing. Our results here are more tentative, and it will take time to evaluate their consequences. But we do believe that there are good possibilities for applications, some of which are described in more detail in companion papers and other papers under development. Apart from the specifics of BI, the bunch-based approach to controlling structural rules opens up further possibilities for controlling the scope and dynamic extent of information dependencies, in both programs and specifications.</p><p>We conclude this part with two general points about relevant logics and bunches. First, we would suggest that useful analyses of existing relevant logics, or identification of interesting variants, might be obtained from attention to categorical proof theory, particularly by focusing on structural relationships between antecedents and logical connectives. And second, other relevant logics might benefit from convincing resource interpretations of proofs (as opposed to just formulae). Such interpretations are not easy to find, but there is reason to believe that they should be different from those for substructural logics not based on bunches (because of the different semantic properties, exemplified by the distribution).</p><p>Relation to linear logic. We have already acknowledged the leading influence of linear logic in the Introduction; here we would like to discuss in detail several of the differences. The point is to aid comprehension by comparison to a well known system, and particularly to go past the surface similarity (where both logics combine multiplicative and additive implications) between them. The comparison is made to intuitionistic linear logic, with "!", and not to smaller fragments.</p><p>First, the informal readings given to the connectives are different. Where the linear implication ϕ ⊸ is often considered to be about using an argument once, the multiplicative implication ϕ - * does not readily admit such a reading. The sharing interpretation, however, provides a reading of connectives consistent with the existence of - * -typed functions which use their arguments multiple times.</p><p>Second, bunches are not similar to the zoned contexts used in some presentations of linear logic (e.g., <ref type="bibr">[16,</ref><ref type="bibr" target="#b4">5]</ref>). In particular, ";" and "," can be nested in a bunch, and ";" (just like ",") is internalized as a connective in the logic, while the zone marker ";" does not internalize in this way. (Uses of bunches in linear logic, such as <ref type="bibr" target="#b34">[39]</ref>, do not appear to be aimed at providing any analysis of implication. Moreover, the relationship of such uses to prior work in relevant logic is unclear.) Third, linear logic admits a decomposition of → as !ϕ ⊸ , while BI admits no similar decomposition of → in terms of - * .</p><p>Fourth, in common with R, BI is a distributive logic, where additive conjunction distributes over additive disjunction. Linear logic does not admit distribution.</p><p>Fifth, categorical models of linear logic are based on two closed categories, where for BI we use a semantics of proofs based on a single category with two closed structures on it. In fact, from a categorical point of view, BI appears as a natural progression (which isn't to say the only one). Models of linear logic were first described in terms of a single closed category, and a comonad "!" <ref type="bibr" target="#b37">[42]</ref>. Later, the intuitionistic and linear structures were given equal status, in the form of two separate closed categories, one symmetric monoidal and the other cartesian, with functors between them <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b4">5]</ref>. BI also accepts the linear and intuitionistic aspects on an equal footing, but takes the further step of asking that the two closed structures reside in the same category.</p><p>Sixth, the Tarski-style models of BI, which explain formulae in terms of a notion of truth, are obtained by combining existing semantics of intuitionistic and relevant logics. We know of no comparable semantics of linear logic, where one combines standard semantics for the multiplicatives and additives.</p><p>Seventh, linear logic has a number of vivid computational readings, including: the number-of-uses reading, based on the original coherence space model; an eager and lazy evaluation reading, based on a strict function model; a concurrency reading of proofs <ref type="bibr" target="#b0">[1]</ref>; and a logic programming interpretation <ref type="bibr" target="#b30">[35,</ref><ref type="bibr" target="#b15">18]</ref>. In these comparitively early days for BI, we have just two related computational readings: one based on imperative programming and the other on logic programming.</p><p>Eighth, BI has multiplicative quantifiers ∀ new and ∃ new , alongside the usual additive quantifiers. Despite many rumblings on this topic over the years, we have not been able to locate a worked-out predicate logic which has multiplicative quantifiers. That is, apart from Ambler's system for the existential only <ref type="bibr" target="#b1">[2]</ref>, the formulation of which is somewhat more complex than ours. Also relevant is the theory of multiplicative dependent function types in <ref type="bibr" target="#b17">[20]</ref>, together with its fibrational semantics <ref type="bibr" target="#b16">[19]</ref>; incidentally, it can be regarded as relying on a version of bunches appropriate to dependent type theory.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>[[X ]]m and an element d ∈ Dn and forms the element [u, d ] ∈ ([[X ]] * D)m • n. (Notice from the definition of environment functors that this functor [[X ]] * D is in fact equal to [[X, x]], so the definitions are type correct.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(fragments of) answer substitutions are global and can be shared. More generally, given two clauses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>If the order on the monoid M is discrete then the clauses for * and I reduce to Urquhart's semantics for MILL. The clause for - * is precisely the one used by him. Given this definition, formulated in the category Set M , we can proceed to establish soundness and completeness theorems, with a modelexistence result being established via a term model constructed using normal natural deductions[34, 33].</figDesc><table><row><cell cols="2">In more detail, an interpretation must specify the forcing relation m |= p</cell></row><row><cell cols="2">for propositional variables p in a way compatible with Kripke Monotonicity.</cell></row><row><cell cols="2">The clauses for the additive connectives are then</cell></row><row><cell>m |= 1</cell><cell>always</cell></row><row><cell>m |= ϕ ∧</cell><cell>if and only if m |= ϕ and m |=</cell></row><row><cell>m |= 0</cell><cell>never</cell></row><row><cell>m |= ϕ ∨</cell><cell>if and only if m |= ϕ or m |=</cell></row><row><cell>m |= ϕ →</cell><cell>if and only if ∀n ⊑ m (n |= ϕ implies n |= ).</cell></row><row><cell cols="2">The multiplicatives follow Urquhart's semantics of MILL.</cell></row><row><cell>m |= I</cell><cell>if and only if m ⊑ e</cell></row><row><cell>m |= ϕ  *</cell><cell>if and only if ∃n, n</cell></row></table><note><p>Kripke Monotonicity: n |= ϕ and m ⊑ n implies m |= ϕ. ′ ∈ M (m ⊑ n • n ′ and n |= ϕ and n ′ |= ) m |= ϕ - * if and only if ∀n ∈ M (n |= ϕ implies n • m |= ).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>1.1. On restricting the structural rules. Perhaps the most lasting impression of linear logic, much more than the formal system itself, will be its revealing of the computational significance of the structural rules of Weakening and Contraction<ref type="bibr" target="#b13">[15]</ref>. Logically, their absence leads to the decomposition of conjunction into additive (&amp;) and multiplicative (⊗) forms, which can be given a sequential natural deduction presentation as follows:</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="216" xml:id="foot_1"><p>PETER W. O'HEARN AND DAVID J. PYM</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>PETER W. O'HEARN AND DAVID J. PYM</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We are grateful to Pablo Armelin, Guy McCusker, Peter Schroeder-Heister and Edmund Robinson for useful discussions about this work. The partial support of the UK EPSRC is gratefully acknowledged.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>to multiplicative conjunction is possible under restricted circumstances. It would be interesting to formulate a dependent function type, along the lines of <ref type="bibr" target="#b17">[20]</ref>, which generalizes both of them.</p><p>For the additive universal quantifier one might have expected here that the elimination rule would be formulated as (X ) Γ ⊢ ∀x.ϕ X ⊢ t : Term (X ) Γ ⊢ ϕ[t/x] ∀E Such a rule is admissible if we have Contraction for ";" on the level of terms. Similar considerations apply to the additive existential quantifier. We now extend the Kripke Resource Semantics to quantifiers. To do this, we must first define a notion of environment, which specifies a binding of variables to individuals. For this, we suppose that we are given a functor D in Set M ; this functor is the "domain of individuals". As in the possible worlds semantics of intuitionistic logic, the use of a functor instead of a constant set allows different collections of individuals to exist at different worlds.</p><p>Example 8. Consider the monoid M = (N, 0, +, ≤) of natural numbers, under addition. Then D might be taken to be the functor sending n to the set {0, . . . , n -1}, with the morphism part being inclusion. Here, we may regard the set D(n) as specifying the collection of memory locations active at world n, borrowing from the sharing interpretation in terms of imperative programming.</p><p>Continuing with the definitions, given such a functor D we may define the environment functor [[X ]], for X a bunch of variables, as follows:</p><p>Here, the * on the right is Day's tensor product, and ∧ is cartesian product of functors. As a result, each [[X ]] is a functor, so that when n ⊑ m and a</p><p>The forcing relation for predicate BI is of the form</p><p>where m ∈ M is a world as before, ϕ is a formula, possibly involving quantifiers and predicate letters, and u ∈ [[X ]]m is an environment appropriate to a bunch of variables X , at world m. (We emphasise here that an environment is an element of a set, and not a map in Set M .)</p><p>The functorial action of environments enables us to formulate an extension of Kripke Monotonicity:</p><p>empty. % the robot's arm is empty clear(X). % X supports nothing else support(X). % X is supported by the ground on(Y,X).</p><p>% Y is on top of X defect(X). % X is defective ... ready *-... % the robot's arm is in position and % other conditions hold defect(X) &lt;-remove(X) &amp; clear(X). % we write &amp; for % additive conjunction remove(X) *-empty * ready.</p><p>...</p><p>Here we intend the logical variable X in the program clause for "remove" to be quantified not by ∀, as it would be in a Prolog-like language, but by ∀ new . Suppose that quantification in the clause for defect is the usual, Prolog-like ∀.</p><p>Suppose the block x is possibly defective, i.e., that we have reached the sub-goal defect(x). By invoking the clause "defect", in the Prolog-like style, we obtain the sub-goal remove(x). Now we are ready to invoke the clause for "remove", as described by the resolution rule in <ref type="bibr" target="#b0">(1)</ref>. The substitution , a fragment of the ultimate answer substitution for the computation, replaces the bound variable X with x, thereby creating a match with the sub-goal remove(x). As there are no other variables required, the bunch Y is empty. Thus we get the following instance of resolution:</p><p>where G = empty * ready.</p><p>Here it follows immediately that x, the possibly defective block, can take no further part in the computation, which proceeds up the left-hand branch. Had we taken a version of "remove" in the Prolog-like style, x could have persisted on the left-hand branch, thereby requiring additional code to enforce its absence from further constructions.</p><p>Thus the use of x in this setting is local to the invocation of the clause for "remove" and x cannot be shared by "remove" and other clauses. This is in contrast to the situation arising from additive resolutions, in which the</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Computational interpretations of linear logic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="3" to="57" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">First order linear logic in symmetric monoidal closed categories</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ambler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Belnap</surname></persName>
		</author>
		<title level="m">Entailment: the logic of relevance and necessity</title>
		<imprint>
			<publisher>Princeton University Press</publisher>
			<date type="published" when="1975">1975</date>
			<biblScope unit="volume">I</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Dunn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Belnap</surname></persName>
		</author>
		<title level="m">Entailment: the logic of relevance and necessity</title>
		<imprint>
			<publisher>Princeton University Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">II</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Dual intuitionistic linear logic, submitted</title>
		<author>
			<persName><forename type="first">A</forename><surname>Barber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Display logic</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Belnap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Life in the undistributed middle, Substructural logics</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Došen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Schroeder-Heister</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1982">1982. 1993</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="31" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A mixed linear and non-linear logic: proofs, terms and models</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Benton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of computer science logic &apos;94</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>computer science logic &apos;94<address><addrLine>Kazimierz, Poland; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Mathematical foundations of programming semantics, eleventh annual conference</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brookes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Main</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Melton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mislove</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1995">1995</date>
			<publisher>Elsevier Science</publisher>
			<pubPlace>New Orleans, Louisiana</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Tulane University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On closed categories of functors, Reports of the midwest category seminar</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Day</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Mathematics</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">Mac</forename><surname>Lane</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">137</biblScope>
			<biblScope unit="page" from="1" to="38" />
			<date type="published" when="1970">1970</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin-New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An embedding theorem for closed categories, Category seminar</title>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Mathematics</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Sydney</surname></persName>
		</editor>
		<editor>
			<persName><surname>Kelly</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="issue">420</biblScope>
			<biblScope unit="page" from="55" to="64" />
			<date type="published" when="1974">1974</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin-New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Došen</surname></persName>
		</author>
		<title level="m">A historical introduction to substructural logics, Substructural logics</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Došen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Schroeder-Heister</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="1" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Dunn</surname></persName>
		</author>
		<title level="m">Conseqution formulation of positive R with co-tenability and t</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Relevant logic and entailment, Handbook of philosophical logic</title>
	</analytic>
	<monogr>
		<title level="m">Alternatives in Classical Logic</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Guenthner</surname></persName>
		</editor>
		<meeting><address><addrLine>Dordrecht, Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">III</biblScope>
			<biblScope unit="page" from="117" to="224" />
		</imprint>
		<respStmt>
			<orgName>D. Reidel</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Linear logic</title>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">On the unity of logic</title>
		<imprint>
			<date type="published" when="1987">1987. 1993</date>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="201" to="217" />
		</imprint>
	</monogr>
	<note>Theoretical Computer Science</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Programming in Lygon: an overview</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Harland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Pym</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winikoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AMAST &apos;96</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nivat</surname></persName>
		</editor>
		<meeting>AMAST &apos;96<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="391" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Logic programming in a fragment of intuitionistic linear logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Hodas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="327" to="365" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Kripke resource models of a dependently-typed, bunched -calculus</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Ishtiaq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Pym</surname></persName>
		</author>
		<ptr target="http://www.dcs.qmw.ac.uk/~pym" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A relevant analysis of natural deduction</title>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="809" to="838" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Mathematical logic</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Kleene</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968">1968</date>
			<publisher>Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Semantical analysis of intuitionistic logic I, Formal systems and recursive functions</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Kripke</surname></persName>
		</author>
		<editor>J. N. Crossley and M. A. E. Dummett</editor>
		<imprint>
			<date type="published" when="1965">1965</date>
			<biblScope unit="page" from="92" to="130" />
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The linear abstract machine</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lafont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="157" to="180" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Introduction to higher-order categorical logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lambek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Scott</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, England</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the meanings of the logical constants and the justifications of the logical laws</title>
		<author>
			<persName><forename type="first">P</forename><surname>Martin-L Öf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scuola di Specializziazione in Logica Matematica</title>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
		<respStmt>
			<orgName>Università di Siena</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report 2</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A logical analysis of modules in logic programming</title>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="79" to="108" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Uniform proofs as a foundation for logic programming</title>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nadathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Š</forename><surname>Čedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="125" to="157" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Resource interpretations, bunched implications and the α -calculus, in preparation, preliminary version to appear in Typed -calculus and applications</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Syntactic control of interference revisited</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Takeyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Tennent</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to appear in Theoretical Computer Science, preliminary version in [9] and in [30</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Algol-like languages</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Tennent</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Birkhäuser, Boston</pubPlace>
		</imprint>
	</monogr>
	<note>two volumes</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Type theory and recursion, slides for Scottfest talk</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The semantics and proof theory of the logic of bunched implications</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Pym</surname></persName>
		</author>
		<ptr target="http://www.dcs.qmw.ac.uk/~pym" />
	</analytic>
	<monogr>
		<title level="m">The semantics and proof theory of the logic of bunched implications, I: Propositional BI</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="1998">1998. 1998. 1998</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page">24</biblScope>
		</imprint>
	</monogr>
	<note>Logic programming with bunched implications. II: predicate BI, available on the</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A uniform proof-theoretic investigation of linear logic programming</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Pym</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Harland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="175" to="207" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Relevant logic: a philosophical examination of inference</title>
		<author>
			<persName><forename type="first">S</forename><surname>Read</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<pubPlace>Basil Blackwell</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Syntactic control of interference</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference record of the fifth annual acm symposium on principles of programming languages</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1978-01">January 1978</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="39" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The essence of Algol</title>
	</analytic>
	<monogr>
		<title level="m">Algorithmic languages: Proceedings of the international symposium on algorithmic languages</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Van Vliet</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam; North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981-10">October 1981</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="345" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Concurrent constraint programming and mixed non-commutative linear logic</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ruet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fages</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CSL &apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>CSL &apos;97<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Sacerdoti</surname></persName>
		</author>
		<title level="m">A structure for plans and behaviour</title>
		<imprint>
			<publisher>Elsevier North Holland</publisher>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Structural frameworks, substructural logics and the role of elimination inferences, Logical frameworks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Schroeder-Heister</surname></persName>
		</author>
		<editor>G. Huet and G. Plotkin</editor>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Cambridge University Press</publisher>
			<biblScope unit="page" from="385" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Linear logic, * -autonomous categories and cofree coalgebras, Categories in computer science and logic</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A G</forename><surname>Seely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Contemporary Mathematics</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Gray</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="issue">92</biblScope>
			<biblScope unit="page" from="371" to="382" />
			<date type="published" when="1989">1989</date>
			<publisher>American Mathematical Society</publisher>
			<pubPlace>Providence, Rhode Island</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Tutorial on linear logic, Substructural logics</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Troelstra</surname></persName>
		</author>
		<editor>K. Došen and P. Schroeder-Heister</editor>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Oxford University Press</publisher>
			<biblScope unit="page" from="327" to="355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Semantics for relevant logics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Urquhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DEPARTMENT OF COMPUTER SCIENCE QUEEN MARY &amp; WESTFIELD COLLEGE UNIVERSITY OF LONDON LONDON E1 4NS</title>
		<meeting><address><addrLine>UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1972">1972</date>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="1059" to="1073" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
