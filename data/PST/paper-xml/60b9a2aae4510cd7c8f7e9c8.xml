<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DIFUZZRTL: Differential Fuzz Testing to Find CPU Bugs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jaewon</forename><surname>Hur</surname></persName>
							<email>hurjaewon@snu.ac.kr</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Suhwan</forename><surname>Song</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dongup</forename><surname>Kwon</surname></persName>
							<email>dongup@snu.ac.kr</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eunjin</forename><surname>Baek</surname></persName>
							<email>ebaek@snu.ac.kr</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jangwoo</forename><surname>Kim</surname></persName>
							<email>jangwoo@snu.ac.kr</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
							<email>byoungyoung@snu.ac.kr</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">DIFUZZRTL: Differential Fuzz Testing to Find CPU Bugs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Security bugs in CPUs have critical security impacts to all the computation related hardware and software components as it is the core of the computation. In spite of the fact that architecture and security communities have explored a vast number of static or dynamic analysis techniques to automatically identify such bugs, the problem remains unsolved and challenging largely due to the complex nature of CPU RTL designs.</p><p>This paper proposes DIFUZZRTL, an RTL fuzzer to automatically discover unknown bugs in CPU RTLs. DIFUZZRTL develops a register-coverage guided fuzzing technique, which efficiently yet correctly identifies a state transition in the finite state machine of RTL designs. DIFUZZRTL also develops several new techniques in consideration of unique RTL design characteristics, including cycle-sensitive register coverage guiding, asynchronous interrupt events handling, a unified CPU input format with Tilelink protocols, and drop-in-replacement designs to support various CPU RTLs. We implemented DIFUZZRTL, and performed the evaluation with three real-world open source CPU RTLs: OpenRISC Mor1kx Cappuccino, RISC-V Rocket Core, and RISC-V Boom Core. During the evaluation, DIFUZZRTL identified 16 new bugs from these CPU RTLs, all of which were confirmed by the respective development communities and vendors. Six of those are assigned with CVE numbers, and to the best of our knowledge, we reported the first and the only CVE of RISC-V cores, demonstrating its strong practical impacts to the security community.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>CPU security bugs critically damage all the computationrelated hardware and software units. Due to the bug, CPUs may produce a wrong computational result, freeze the execution, reboot the computer, or allow unprivileged users to access privileged data. One unique and critical challenge of CPU bugs is that unlike software security bugs, it is extremely difficult to deploy the patch as CPUs are hard-wired circuits which cannot be re-wired once manufactured.</p><p>By far, many serious CPU bugs have been discovered. Focusing on the cases in open source CPUs, it is reported that OpenSparc had 296 bugs <ref type="bibr" target="#b0">[1]</ref>. Proprietary CPUs such as Intel CPUs also suffered from the CPU security bugs. The Pentium FDIV bug <ref type="bibr" target="#b1">[2]</ref> returned incorrect binary floating point results when dividing a number, which costed Intel 475 million dollars to replace the flawed processors <ref type="bibr" target="#b2">[3]</ref>. More recently, a group of security researchers discovered multiple security vulnerabilities related to CPU's speculative execution-Spectre, Meltdown, SPOILER, Foreshadow, MDS <ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref>. We note there have been many more CPU security bugs other than those: Pentium F00F bug, which rebooted the computer upon executing a certain instruction; Intel SGX Bomb, which rebooted the computer upon intentionally violating memory integrity; and Intel TSX-NI bug, in which a detail of the bug is unknown but Intel disabled TSX through the microcode update <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>.</p><p>There have been tremendous efforts in automatically identifying CPU RTL bugs through static or dynamic analysis techniques <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref>, but the problem remains unsolved and still challenging largely due to the complex nature of CPU RTL designs. In particular, RTL designs implement complex sequential and combinational logics of hardware circuits, which in fact materializes the finite state machines (FSM). Thus, the general goal of RTL bug finding is to exhaustively explore as many states in FSM as possible. However, such an exploration either through static or dynamic techniques is challenging mostly because there are too many states to be covered. This paper proposes DIFUZZRTL, an RTL fuzzer specifically designed to discover CPU RTL vulnerabilities. The core ideas behind DIFUZZRTL can be summarized with following two approaches: a dynamic testing approach and a differential testing approach, both of which help DIFUZZRTL to efficiently find RTL bugs. First, DIFUZZRTL takes a dynamic testing approach, particularly the coverage-guided fuzzing, so as to comprehensively explore hardware logics embodied in the RTL design. Second, DIFUZZRTL takes a differential-testing approach to clearly identify an RTL vulnerability. In other words, DIFUZZRTL keeps comparing an execution result of an RTL design with that of a golden model (i.e., an ISA-level simulation result), thus detecting the bugs at ISA level.</p><p>We find that realizing aforementioned ideas involve several challenges, particularly related to inherent characteristics of RTL designs. The first challenge is that DIFUZZRTL needs a new execution coverage metric tailored for RTL designs. A multiplexer in RTL designs may seem to be a good choice for coverage metrics, because it is similar to branches in software code. However, we find that the multiplexer-based coverage proposed by the state-of-the-art RTL fuzzer <ref type="bibr" target="#b13">[14]</ref>, has critical limitations due to following two reasons: 1) cycleaccurate natures of RTL circuit designs and 2) a vast number of multiplexers in a circuit. We also confirmed through our evaluation ¬ßVI that the above reasons clearly impose two limitations on the fuzzer: 1) it was not able to correctly capture the states due to cycle-insensitivity; and 2) it has scalability limitations due to complex multiplexer wiring.</p><p>The second challenge is that DIFUZZRTL needs a systematic way to explore all possible input spaces of RTL designs. Conventional software fuzzing typically assumes the onedimensional input space (i.e., file input space to fuzz user programs, or system call input space to fuzz kernels). However, CPU RTLs accept multi-dimensional inputs in the form of raw bus packets, so called stimuli, which is sent from various controllers-memory controllers (as a response to memory read/write requests), interrupt controllers (raising an interrupt request), etc. Worse yet, these packets are delivered to CPU RTLs in every clock cycle, further complicating the input space that CPU RTLs take.</p><p>DIFUZZRTL addresses above two challenges with following design features. First, DIFUZZRTL's coverage measurement is based on a control register, which is a register whose value can be used for any muxes' control signal. Then DIFUZZRTL measures the control register value every clock cycle, thereby making it clock-sensitive and correctly capture the explored states by RTL designs. Moreover, since a single control register is connected to multiple muxes' control signals, the number of control registers is far less than the number of wires connected to the mux's control signals, addressing the scalability limitation of mux-based coverage as well. We highlight that DIFUZZRTL was able to fuzz even a complex out-of-order machine which has about twenty thousands of lines of implementation complexity. Second, DIFUZZRTL provides systematic mechanisms to test a newly designed input format for CPU RTLs, SimInput. SimInput includes full-fledged information to run CPU RTLs, from memory address and value pairs to interrupt signals, and it is automatically translated into bus protocols that CPU RTLs are accepting. In order to execute CPU RTLs as specified by SimInput, DIFUZZRTL works as a pseudo SoC for the CPU, which includes a memory unit and an interrupt controller inside.</p><p>We implemented DIFUZZRTL as a full-fledged fuzzing framework for CPU RTLs. DIFUZZRTL automatically instruments a given CPU RTL to measure the register coverage, then keeps running two simulators, ISA and RTL simulators, while providing an identical input to both simulators. After each run, DIFUZZRTL cross-checks the architectural states, and if it identifies the difference, DIFUZZRTL automatically reports such an input as a potential bug. In order to demonstrate its strong practical aspect, we implemented DIFUZZRTL to support three real-world CPU RTLs: OpenRISC Mor1kx Cappuccino, RISC-V Rocket Core, and RISC-V Boom Core, which are widely used for academic researches as well as industry production. We note these CPU RTLs include not only simple in-order pipelined cores but also complex out-oforder superscalar cores.</p><p>During the evaluation, DIFUZZRTL identified total of 16 new bugs in those CPU RTLs, all of those are confirmed by the respective development communities or vendors. More importantly, six bugs of those are assigned with CVE numbers, signifying its practical impacts to the security community. To the best of our knowledge, DIFUZZRTL reported the first and only CVE vulnerabilities of any RISC-V cores. DIFUZZRTL has demonstrated the wide testing coverage with respect to the bug types in CPU RTLs, including atomic operation, instruction decoding, and even the performance bugs. In particular, DIFUZZRTL identified the vulnerability from the RISC-V boom core, which is similar to the notorious Pentium FDIV vulnerability, thereby helping to avoid unfortunate CPU recall cases that Intel experienced before. Particularly comparing the fuzzing performance of DIFUZZRTL against RFuzz <ref type="bibr" target="#b13">[14]</ref> (i.e., the state of the art RTL fuzzer), DIFUZZRTL showed significantly better performances. In terms of execution speed, DIFUZZRTL is 40 times faster than RFuzz to run CPU, and in terms of states exploration efficiency, DIFUZZRTL is 6.4 times faster than RFuzz to identify a vulnerable state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND</head><p>In this section, we provide a brief background of RTL verification and the concept of coverage-guided fuzzing, which has largely succeeded in software testing. Finally we introduce and argue the benefits of adopting coverage-guided fuzzing to RTL verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. CPU Development and Testing</head><p>CPU Development. In general, modern CPUs are developed with the following two phases: 1) modeling a CPU architecture, called Instruction Set Architecture (ISA); and 2) implementing a microarchitecture with Register-Transfer level (RTL) abstraction, which follows the ISA. In the first phase, Instruction Set Architecture (ISA) is defined, which dictates an architectural level of inputs and outputs, as well as describing desired operational behaviors to generate an output from a given input. In particular, ISA defines how the programmer-visible states (e.g., registers and memory states) are updated in response to executing a well-formatted instruction.</p><p>Based on the ISA, a microarchitecture is designed in Register-Transfer level (RTL) abstraction, materializing the conceptual ISA model into a real hardware design. RTL can be expressed with various hardware description languages such as Verilog or VHDL <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, which can be synthesized into a hardware circuit. Since ISA does not dictate the implementation details (e.g., the pipeline depth, cache size), there can be various microarchitectures for the same ISA, each of which has its own unique RTL implementation characteristics. For instance, although both Rocket and Boom cores implement the same RISC-V ISA, the former is an in-order and the latter is an out-of-order core with different pipeline stages.</p><p>During the development cycle, CPU should be thoroughly tested from many different aspects, including functionality, performance, security, etc. Particularly focusing on the dynamic testing techniques (we discuss static testing techniques in ¬ßVIII), such a testing can be performed with either an ISA simulation or an RTL simulation, as we describe next in turn. Testing with ISA Simulation. An ISA simulator is a software-only implementation, which simulates all the ISA-  level operational behaviors (illustrated in Figure <ref type="figure" target="#fig_0">1-(a)</ref>). To be more specific, ISA simulators mimic the behavior of the CPU and it maintains all the architectural registers and memory states as its internal value while executing instructions. Thus ISA simulator has its own memory unit, interrupt controller and other components as well as the CPU implementation. Using this ISA simulator, developers can test if the new ISA can well support various software stacks running on it without any issues. Moreover, the simulator can be used as a reference model for the architecture, manifesting how programmer-visible states should be updated if running a specific instruction. Testing with RTL Simulation. RTL simulation is used to simulate the real-time behaviors of the design implemented in RTL. The major difference between RTL and ISA simulation is that the RTL simulation is aware of a cycle concept, representing a clock cycle of the synchronous circuit. Thus the cycle accurate behaviors of the design including microarchitectural states are tested during the simulation, which cannot be performed with the ISA simulation.</p><p>However, the RTL design alone cannot be simulated since the design is just a representation of a circuit for the CPU. To operate the RTL design, input stimuli should be provided to the ports of the design while the simulation. Thus, an SoC including memory units and interrupt controller is implemented to feed input stimuli on the CPU design. Thus, the SoC completes the CPU design for RTL simulation to run a meaningful software code on it. Figure <ref type="figure" target="#fig_0">1-(b</ref>) shows a simple SoC to test CPU designs. Before the simulation, an input executable file is loaded to the emulated memory in host and the CPU in RTL simulation runs the executable. In the simulation, SoC continuously receives data including instructions from the emulated memory and generates input stimuli for the CPU design. Upon receiving the input, the CPU RTL design runs the intended instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Fuzzing</head><p>Coverage-Guided Fuzzing. Fuzzing is a software testing technique, which keeps running a target program with randomly generated (or mutated) inputs so as to discover previously unknown vulnerabilities. In particular, coverageguided fuzzing <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18]</ref> is arguably the most popular fuzzing technique, which focuses on extending the execution coverage. In each run of the target program, it measures the execution coverage at runtime, and leverage the measured coverage as feedback to generate (or mutate) the next input to be tested.</p><p>In order to measure the coverage, it is assumed that the target program is instrumented beforehand such that the fuzzer can collect certain coverage information at runtime (including a basic block coverage, edge coverage, etc.)</p><p>For instance, Figure <ref type="figure" target="#fig_1">2</ref> shows a typical workflow of coverageguided fuzzers. The fuzzer starts by randomly choosing one of the input from the input corpus, which maintains a set of interesting inputs. Then this chosen input is randomly mutated (such as a random bit flip, merging two bytes in random offsets, replacing with a specific value, etc.). Next, the fuzzer runs the target program with the mutated input, while measuring the execution coverage of the mutated input. If this mutated input covers the new execution coverage that were not explored before, it is saved back to the input corpus so that it can get another chance to be fuzzed in the future running. If not, the mutated input is thrown away. The fuzzer repeats aforementioned steps indefinitely, which results in coverageguided fuzzing because it is more likely to fuzz the input that is more likely extending the coverage. Differential Fuzz Testing. Most fuzzers have focused on identifying memory corruption bugs <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr">[25]</ref><ref type="bibr" target="#b24">[26]</ref><ref type="bibr" target="#b25">[27]</ref><ref type="bibr" target="#b26">[28]</ref><ref type="bibr" target="#b27">[29]</ref><ref type="bibr" target="#b28">[30]</ref><ref type="bibr" target="#b29">[31]</ref><ref type="bibr" target="#b30">[32]</ref><ref type="bibr" target="#b31">[33]</ref><ref type="bibr" target="#b32">[34]</ref>, mostly because 1) it has strong security implications; 2) memory violation conditions are relatively easy to define and thus relatively easy to detect. On the other hand, fuzzing to find semantics bugs, which identifies logical vulnerabilities deviating from developerintended program behaviors, are not well explored compared to finding memory corruption bugs. In general, semantic bugs are known to be difficult to find because it is difficult to express semantic violation cases into well-formed safety violation conditions, because many of those require specific domain knowledge of target programs. To tackle this problem, previous works introduced differential fuzzing techniques, where the fuzzer identifies a bug by comparing the output of multiple programs of the same purpose <ref type="bibr" target="#b33">[35,</ref><ref type="bibr" target="#b34">36]</ref>. In fact, such differential testing techniques are also used for RTL verification as well, particularly comparing one RTL's execution results with a golden model's execution results <ref type="bibr" target="#b35">[37]</ref>, which inspired the design of DIFUZZRTL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MOTIVATION</head><p>The major motivation for DIFUZZRTL is to design a fuzzing framework considering unique characteristics of RTL designs. To this end, this section discusses two issues to design the RTL fuzzer, coverage definitions for RTL fuzzing ( ¬ßIII-A) and input space for RTL Fuzzing ( ¬ßIII-B).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Coverage Definition for RTL fuzzing</head><p>Example: A Memory Controller. Suppose a developer wants to develop a simple memory controller, which connects CPU with SDRAM and flash memory. Considering the unique hardware characteristics, the memory controller takes 8-bits from the flash at once. However, it takes 4-bits from the SDRAM since SDRAM transfers only 4-bits per cycle. Thus, the memory controller should assemble two data packets from SDRAM to forward the entire 8-bits <ref type="bibr" target="#b36">[38]</ref>.</p><p>To this end, the developer designs following two independent FSMs as shown in Figure <ref type="figure" target="#fig_3">3-(a)</ref>. First, the FSM for the flash begins with the ready state (R F ). If the valid signal is one, it transitions to the busy state (B F ) while taking the 8-bits from the flash. Then it goes back to the ready state. Second, the FSM for the SDRAM is similar to that of the flash, but the key difference is that it has one more state in the middle, the pending state (P S ). This is because since SDRAM sends 8-bits of data with two consecutive 4-bits of transmissions, the controller should maintain two states (i.e., P S and B S ) to represent the completion of the first-and second-half transmission, respectively.</p><p>Based on these two FSMs, the sequential circuits using RTL can be implemented for the memory controller as in Figure <ref type="figure" target="#fig_3">3-(b</ref>). For simplicity, we omitted the data flow in this illustration. When implemented with RTL, the current states are maintained with state register variables (i.e., state F and state S ), because the state is later used for determining the next state. Moreover, a state transition is implemented with a multiplexer (i.e., mux), because mux outputs an appropriate input according to the select signal (i.e., the state transition condition in the FSM can be represented with the select signal of mux).</p><p>The sequential circuit for the flash has 1-bit register, state F , where 1'b0 (i.e., the bit value 0) represents R F and 1'b1 (i.e., the bit value 1) does B F , respectively. It is assumed that state F is first initialized with R F . When validF is asserted (represented with 1 ), the mux M F 0 forwards B F from the two inputs (i.e., state F and <ref type="formula">3</ref>), completing the first clock cycle. In the next clock cycle, the circuit is processed when state F is B F , updating state F with R F in the end of the clock cycle.</p><formula xml:id="formula_0">B F ). Next, M F 1 forwards the output of M F 0 , which is B F ( 2 ), since the select signal of M F 1 is R F . Then state F is updated with B F (</formula><p>The sequential circuit for the SDRAM has 2-bit register, state S , because it has three states to be represented: 2'b00 for R F , 2'b01 for P S , and 2'b11 for B S . Thus, it has one extra mux to implement an extra state transition, but it is largely similar to the sequential circuit for the flash. Vulnerability in the Memory Controller. This memory controller has a vulnerability breaking the memory consistency, which is related to the constraint that the memory controller can only forward 8-bits (sent from either flash and SDRAM) to CPU per cycle. If both flash and SDRAM completes the 8-bit transmission at the same clock cycle (i.e., reaching B F and B S at the same clock cycle), the memory controller cannot handle both. In other words, it can only forward one 8-bits transmission, and should drop the reset transmission. As a result, one of the data (transmitted by either flash or SDRAM) will be lost, thus breaking the memory consistency.</p><p>This vulnerability cannot be captured with two individual FSMs that we presented before (Figure <ref type="figure" target="#fig_3">3-(a)</ref>), which assumes that the flash and SDRAM operations are independent to each other. However, since these two are in fact dependent with respect to the memory controller, two individual FSMs should be merged into a single FSM where its states are a product of all states (Figure <ref type="figure" target="#fig_3">3-(c)</ref>). As shown in the figure, once the memory controller reaches the state (B F , B S ), then data loss or corruption occurs.</p><p>In order to fix this vulnerability, the memory controller should handle only one of two transmissions during the vulnerable clock cycle, and the other should be handled in the next clock cycle. Thus, the developer should patch with an extra state transition, from (B F , B S ) to (R F , B S ) or (B F , R S ) Limitation of Previous Fuzzing Approaches. In order to identify this vulnerability, various approaches can be used, but each approach has its own limitation.</p><p>Focusing the discussion on fuzzing techniques, RFuzz <ref type="bibr" target="#b13">[14]</ref> proposed the mux-coverage guided fuzzing technique. The core idea behind this technique is that the mux's select signal leads to a state transition, so guiding the fuzzing based on the mux's select signal would lead to exploring more FSM states. To be more specific, this technique runs the sequential circuit while monitoring all the select signals of the muxes, identifying which of those were toggled in the end of running. If any mux were newly toggled, the provided input to the circuit (i.e., a series of per-cycle validF and validS signals) is considered as a valuable input and thus added to the corpus. This is because such a new toggling indicates that the new state transition has been explored by the input. If no muxes were newly toggled, the provided input is simply thrown away.</p><p>We observe two critical limitations of RFuzz's mux-coverage technique. The first limitation is that since mux-coverage metric is clock-insensitive, it cannot precisely capture FSM state transitions. In other words, it does not recognize interplay and inter-dependency between mux toggling events across clocks, so semantically different mux toggling events are considered as the same, failing to correctly identify state transitions.</p><p>For instance, Figure <ref type="figure">4</ref> illustrates two different cases of running the memory controller, where the left case runs with the benign input (i.e.,(R F , R S ) to (B F , P S ) and reaching (R F , B S )) and the right case runs with the vulnerability-triggering input (i.e., the input leads to reaching the state, (B F ,B S ), at clk3). For each case, all muxes' select signals are shown per cycle, where the mux toggling is highlighted with the red-colored box. In the end of running, the coverage map is generated which sums up all the observed toggling events. Then this coverage map is used to identify if new mux toggling is triggered by the</p><formula xml:id="formula_1">R F B F (*) (0) (1) R S B S P S (1) (0) (*) (1) (0) FSM of flash (state F ) FSM of SDRAM (state D ) R F B F (*) (0) (1) R S B S P S (1) (0) (*) (1) (0) FSM of flash (state F ) FSM of SDRAM (state D )</formula><p>(a) Two independent FSMs designed for the example memory controller, where each FSM is for state F and state S .</p><formula xml:id="formula_2">B S P S state S [0] R S state S 1 0 1 0 1 0 valid S (from SDRAM) state S [1] B F state F R F B F 1'b0 1'b1 state S R S P S B S 2'b00 2'b01 2'b10 ùêå ùüé ùêÖ ùêå ùüè ùêÖ ùêå ùüê ùêí ùêå ùüè ùêí ùêå ùüé ùêí 1 0 state F 1 0 R F valid F (from flash) 2 1</formula><p>state F [0] 3 (b) Schematics of the example memory controller. For simplicity, the data flow is abstracted out.   </p><formula xml:id="formula_3">0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 Bug 0 0 0 0 1 0 1 0 1 0 2 5 0 1 5 0 1 2 4 Mux Coverage M 0 F M 1 ùêπ M 0 ùëÜ M 1 ùëÜ M 2 ùëÜ 0 0 1 1 1 1 0 0 1 0 1 1 1 1 0 0 1 2 4 clk0 clk1 clk2 Mux cov map Benign M 0 F M 1 ùêπ M 0 ùëÜ M 1 ùëÜ M 2 ùëÜ 0 1 2 4 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 clk0 clk1 clk2 Mux cov map Bug State {R F , R S } {B F , P S } {R F , B S } {R F , R S } {R F , P S } {B F , B S } State M 0 F M 1 ùêπ M 0 ùëÜ M 1 ùëÜ M 2 ùëÜ 0 0 1 1 1 1 0 0 1 0 1 1 1 1 0 0 1 2 4 clk0 clk1 clk2 Mux cov map Benign M 0 F M 1 ùêπ M 0 ùëÜ M 1 ùëÜ M 2 ùëÜ 0 1 2 4 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 clk0 clk1 clk2 Mux cov map Bug 3 3</formula><p>Fig. <ref type="figure">4</ref>: The workflow of RFuzz's mux coverage schemes for benign (left) and bug triggering inputs (right) provided input. However, although benign and vulnerabilitytriggering cases are clearly reaching different states, coverage maps of those are the same. This is because although the mux toggling of M F 0 and M F 1 takes place at different clock cycles, RFuzz's mux-coverage metric cannot capture such differences. As a result, RFuzz would not be able to properly guide the fuzzing procedure towards exploring more states as its metric collapses multiple states into one state.</p><p>The second limitation is related to instrumentation overhead of monitoring all muxes' select signal. From the implementation perspective of the RFuzz's mux-coverage approach, the required resources (e.g, wires and registers) for instrumentation quadratically increases as the number of muxes increases, critically limiting its runtime performance as well as scalability. Our Approach: Register Coverage for RTL. In order to overcome the limitation, DIFUZZRTL proposes the registercoverage approach for RTL. While we provide details in ¬ßIV-C, register coverage can be summarized with two key features. First, it supports clock-sensitive coverage, so it can precisely capture FSM state transitions. Second, its measurement is based on control registers, not based on muxes' control signals, making it efficient and scalable. As we evaluate further in ¬ßVI, DIFUZZRTL's register-coverage has shown 40 times better execution speed, and 6.4 times faster vulnerable state exploration time compared to RFuzz's mux-coverage. More importantly, DIFUZZRTL was able to fuzz all three real-world RTLs including out-of-order Boom Core, while RFuzz was not able to fuzz the Boom Core due to the scalability issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Input Space for RTL Fuzzing</head><p>Limitations of CPU Testing using Entire SoC. As mentioned in ¬ßII-A, CPU designers have used SoC to simulate and test the CPU RTL designs. Leveraging entire SoC enables the comparison between ISA simulation and RTL simulation, i.e., end-to-end test, by making them take the same executable as an input. In this sense, fuzzing entire SoC can simplify the fuzzer by concerning only executable generation, but there are some fundamental limitations. First of all, the fuzzer cannot test the entire input space of the CPU design. CPU RTL designs have several input ports including ports for data transfer, interrupt and debug interface. SoC wraps this interface by converting input from outer world (e.g., executable) into a formatted input stimuli the CPU can interpret. However, it also means limiting the input space into the space that SoC can only generate. To test various functioning of CPU such as responses to stressful cache coherence transactions or arbitrary interrupts, the intended SoC should be redesigned each time. In contrast, fuzzer which directly channels the CPU input space can generate input adaptively.</p><p>Furthermore, as the open source hardware <ref type="bibr" target="#b37">[39]</ref> becomes popular, it is no longer true that the CPU and SoC are designed and implemented by a single vendor. The open sourced CPU RTL design can be used in various SoC designs, e.g., using Boom core in Rocket SoC <ref type="bibr" target="#b38">[40,</ref><ref type="bibr">41]</ref>. Thus, the CPU and SoC should be verified separately and we need a unified platform to test CPU designs only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DESIGN</head><p>Now we present the design of DIFUZZRTL. We first introduce how DIFUZZRTL performs the mutation, which generates a new CPU input format, SimInput ( ¬ßIV-A). Then we describe ISA simulation ¬ßIV-B, which accepts SimInput as input. Next, we illustrate how DIFUZZRTL compiles RTL designs to support register coverage ( ¬ßIV-C), and then explain Fig. <ref type="figure">5</ref>: An overall framework of DIFUZZRTL. It runs both ISA and RTL simulations using the same SimInput, and crosschecks the both execution results' after each run. The entire workflow leverages the register-coverage guiding, so the RTL simulation measures the register-coverage which is provided for the mutator.</p><p>RTL simulation ( ¬ßIV-D). This RTL simulation also accepts the identical SimInput as the ISA simulation. Lastly, we describe how DIFUZZRTL cross-checks the execution results from ISA and RTL simulations to finally identify bugs ( ¬ßIV-E). Overall Workflow. The overall framework of DIFUZZRTL is shown in Figure <ref type="figure">5</ref>. First, mutator randomly generates input ( 1 ), and DIFUZZRTL runs both ISA simulation and RTL simulation using the input ( 2 , 3 ). After the simulations end, DIFUZZRTL takes a snapshot of the final memory states and architectural registers of both designs to cross-check ( 4 ). Thus, DIFUZZRTL finds a potential bug if execution results are different. Above four steps make one fuzz iteration, and such an iteration keeps repeated indefinitely while the input mutation and selection is guided to increase register-coverage <ref type="bibr" target="#b4">( 5 )</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. SimInput Mutation</head><p>In order to provide a consistent and identical input to both SW and RTL designs, DIFUZZRTL defines a new input format for CPU, SimInput. SimInput thoroughly includes all input space that CPU takes, ranging from all address and value (both code and data) to associated interrupt events. Figure <ref type="figure">6</ref> shows a simple example of SimInput.</p><p>For a given SimInput, DIFUZZRTL randomly mutates it with following two phases: 1) DIFUZZRTL enumerates all instructions in SimInput and performs per-instruction mutation, which determines opcode and operands of the instruction; After mutating all instructions, DIFUZZRTL starts interpreting instruction by instruction, which populates all remaining information of SimInput (including an address of an instruction, address and value of data, and a list of interrupts). Fig. <ref type="figure">6</ref>: Input generated by mutator. Each address is associated with an instruction and a list of interrupt events It is worth noting that, ISA and RTL simulation runs CPU according to SimInput as follows: 1) The map of address and value pair is used as an initial memory state for both SW and RTL designs. 2) The associated interrupt event is also accordingly raised when designs execute the corresponding instruction. Since CPU is operating based on the initial memory layout and interrupt events, SimInput ensures the deterministic execution on both designs. Per-Instruction Mutation. In general, DIFUZZRTL's perinstruction mutation is a grammar-aware and structured mutation approach while allowing some randomness, such that a mutated instruction is likely a valid instruction (but an invalid instruction with a low probability). This ensures that when the instruction is executed by SW or RTL design, it would not always be rejected due to the invalid instruction format. More specifically, per-instruction mutation determines following two fields: opcode and operands. First, the opcode of the instruction is determined at random from the list of valid opcodes in the ISA specification.</p><p>Next, the operands (including register indices and immediate/address values) are determined at random. Note that DIFUZZRTL's mutator keeps track of which register indices and immediate/address values were assigned before, and attempt to reuse such indices and values. Thus, this would increase the data dependency between instructions, thereby allowing DIFUZZRTL to stress test the design. (e.g., on a corner implementation case of SW design or data/control hazard detection or resolution logics in RTL design).</p><p>Regarding the space complexity, DIFUZZRTL requires two pools of variables (i.e., used registers and immediates) per mutation. Each pool can have variables up to the length of generated instructions, thus the space complexity is O(N ) where N is the number of instructions. DIFUZZRTL requires a predefined set of opcodes and register indices but they are statically determined before the fuzzing. Interrupt Mutation. After the instruction mutation, the sequence of interrupts is mutated. As in the instruction case, mutator randomly appends or deletes interrupts in the given sequence. Then, the generated interrupt sequence is paired with the instruction sequence. In the simulation, the paired interrupt values are injected every execution of the corresponding instructions. Population through Instruction Interpretation. After mutating all instructions and interrupts, DIFUZZRTL populates all remaining information, i.e., map of initial address to instructions, data and interrupts, to SimInput. However, directly placing all the instructions sequentially in a defined memory region would end in meaningless executions since the prepared instructions will not be executed after control flow changes. Thus, the population is performed through instruction interpretation, as it necessarily requires to understand how the instruction would be executed at runtime.</p><p>To be more specific, DIFUZZRTL first determines the address of the first instruction to be a given entry symbol, and interprets the instruction (i.e., executes the instruction). During the interpretation, if the instruction attempts to load the data from addr where addr is not specified in SimInput, DIFUZZRTL provides a random value v while populating SimInput with (addr, v). Note that, if the instruction attempts to store data, DIFUZZRTL would not update SimInput as it is not part of the input to the CPU. Moreover, an interrupt event is pushed to the interrupt event list of the current PC. Each interrupt event can be either None (i.e., the interrupt signal should not be asserted) or the interrupt signal value (i.e., the interrupt signal should be asserted with the specified IRQ number).</p><p>After finishing the interpretation of the first instruction, the next PC value will be determined (i.e., a target address if it is a branch instruction, or PC+4 otherwise). Then DIFUZZRTL updates SimInput so that the next instruction (i.e., a next mutated instruction) has the next PC address, and start interpreting this new instruction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. ISA Simulation</head><p>DIFUZZRTL's ISA simulator runs CPU SW design as instructed by SimInput. To this end, DIFUZZRTL tailors how CPU SW design takes input from other components including a memory unit and an interrupt controller. In the case of the memory unit, DIFUZZRTL populates the initial memory layout by embedding SimInput in the base memory template. Then, DIFUZZRTL loads the initial memory layout to the ISA simulation.</p><p>In the case of the interrupt, DIFUZZRTL implements a pseudo interrupt controller in the ISA simulator, which raises an interrupt when CPU SW design executes a specific PC. More specifically, the controller raises the interrupt value which is paired to the instruction pointed by PC.</p><p>The simulation continues until the CPU SW design reaches a specific address (i.e. the end of the execution) which is embedded in the base memory template. The SimInput population ensures that the control flow always converges to the end of the execution. The base memory template also contains instructions to save achitectural register-files to the specific memory address so that DIFUZZRTL can take the snapshot of programmer-visible states (i.e. memory and registers) by reading specified memory addresses. The snapshot is later used to cross-check with the RTL simulation generated one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. RTL Compilation with Register Coverage</head><p>As described in ¬ßIII-A, a mux-coverage technique has two limitations: 1) it is clock-insensitive, it cannot precisely capture FSM state transitions; and 2) it imposes huge instrumentation for each (m ‚Ä≤ , m) ‚àà E do 12:</p><p>S ‚Üê S ‚à™ f indSrcRegs(m ‚Ä≤ , œï, T )</p><p>13:</p><p>return S costs, critically slowing down the runtime performance of simulation as well as limiting its scalability.</p><p>In order to overcome such limitations, DIFUZZRTL proposes a new coverage metric: register-coverage. DIFUZZRTL's register-coverage metric has two key features: 1) it is based on control registers, not based on muxes' control signals, making it performance efficient and scalable; and 2) it is clocksensitive coverage (i.e., measures the coverage every clock cycle), so it can precisely capture FSM state transitions. In the following, we first describe how DIFUZZRTL identifies control registers in RTL through a static analysis, and then describe how DIFUZZRTL measures clock-sensitive register-coverage at runtime. Identifying Control Registers. DIFUZZRTL's coverage measurement focuses on monitoring value changes in a control register-a register where its value is used as any muxes' control signal. In other words, since value changes of control registers would lead to the FSM state transition, it can also be used to explore more FSM states for fuzzing. Since a single control register is often connected to multiple muxes' control signals, the number of control registers is far less than the number of wires connected to the mux's control signals.</p><p>The problem arising here is that RTL design has a vast number of registers, and only a small set of registers are control registers. Hence, DIFUZZRTL performs a static analysis to identify control registers. In particular, the analysis first builds a graph representing the connections between all elements (e.g., registers, wires, and muxes) in the module. Then, we recursively perform a backward data-flow analysis for each mux's control signal as shown in Algorithm 1. If the backward data-flow tracing reaches a register, then we conclude such a register is the control register. This is because this register's value will be directly or indirectly (i.e., through a combinational logic) used to control the mux's behavior. If the backward tracing either goes beyond the module boundary or reaches the already traced point (because a circuit is circular), the analysis stops.</p><p>In terms of analyzing the algorithmic complexity, DIFUZZRTL finds all the control registers with O(V 2 ‚Ä¢ E) of time complexity where V is the number of elements and E is the number of connections between them. The space complexity is O(V ‚Ä¢ E) for managing the graph representing the connections between all the elements. Clock-Sensitive Register Coverage. DIFUZZRTL measures the register-coverage every clock cycle. Note that this clockby-clock coverage measurement is nearly infeasible using muxcoverage due to its performance and scalability issues. In the case of DIFUZZRTL, however, such clock-by-clock measurement became feasible with DIFUZZRTL's register-coverage technique, which we demonstrate more details in ( ¬ßVI).</p><p>For each RTL module, DIFUZZRTL inserts three new registers, regstate, covmap, and covsum (shown in Figure <ref type="figure">7</ref>). DIFUZZRTL instruments the module such that all the values in control registers are hashed into regstate. In order to implement the hash function, we used a series of XOR operations while each control register's value is left-shifted with a deterministic random offset. We note that this hash function design is inspired by AFL's edge-coverage metric using XOR operations <ref type="bibr" target="#b16">[17]</ref>. Then the instrumented logic attempts to write 1 to the covmap's slot, where the slot index is determined by the value of regstate. This write operation marks that the corresponding FSM state (i.e., a hash of control register values) has been explored by the instrumented module.</p><p>When this write operation to covmap takes place, DIFUZZRTL increments covsum only if the value in the corresponding covmap slot was zero. If it were already 1, it implies that the RTL module has already explored such an FSM state in the previous clock cycles. If it were zero, it implies that it has just explored the new FSM state during the current clock cycle. Since such covmap and covsum updates are carried out every clock cycle, DIFUZZRTL's register-coverage mechanism is clock-sensitive. Then this covsum is wired out to the parent RTL module, which sums up covsum values from all child RTL modules. This tree structure-like covsum summation is performed until reaching the top level RTL module.</p><p>The covsum value in the top level RTL module is used as a final coverage value throughout DIFUZZRTL's fuzzing. It is worth noting that the values in covmap and covsum are maintained during the fuzz iterations, thus the states once covered are not recognized as new in the later iterations.</p><p>Revisiting the Memory Controller Example. Using the register-coverage, DIFUZZRTL can correctly distinguish states in the memory controller example, which were not detected by RFuzz's mux coverage (previously shown in Figure <ref type="figure">4</ref>). Figure <ref type="figure" target="#fig_7">8</ref> illustrates how DIFUZZRTL handles the same example case. In each clock cycle, DIFUZZRTL computes the hash of all control registers (i.e., state F and state S ), which updates covmap every clock cycle. Since the hash of control registers is computed every clock cycle, DIFUZZRTL can correctly identify the state difference between benign and bug-triggering cases, thereby enabling DIFUZZRTL to correctly guide the fuzzing procedure towards the buggy states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. RTL Simulation</head><p>DIFUZZRTL's RTL simulator runs CPU RTL design as specified by SimInput. While overall simulation mechanism is similar to how DIFUZZRTL runs ISA simulator, DIFUZZRTL's RTL simulation has following two key differences. First, since CPU RTL design takes input stimuli following the specific protocol, DIFUZZRTL accordingly generates the input stimuli after interpreting SimInput. Second, an interrupt processing mechanism in RTL design is different from SW design for the following two reasons: 1) RTL design runs at a CPU cycle level while SW design runs at an instruction level; and 2) RTL design may defer when to process an asynchronous interrupt but SW design does not defer. Stimuli Generation. In order to handle the first difference, DIFUZZRTL generates formatted stimuli based on the protocol. As in the ISA simulation, DIFUZZRTL runs as a pseudo memory unit in RTL simulation, which is initialized with the memory layout generated from SimInput. DIFUZZRTL monitors the data bus interface of RTL design and generates input stimuli which contains the data mapped to the requested address. Interrupt Generation. In order to generate an interrupt, DIFUZZRTL designs a pseudo interrupt controller for RTL design. According to SimInput, DIFUZZRTL monitors executed PC every cycle so as to assert interrupt signal at a specific PC. One challenging issue here is unlike in the case of ISA simulation, it is difficult to control when the raised interrupt would be processed by the RTL design. Specifically, a majority of ISAs dictates that processing of an asynchronous interrupt can be deferred <ref type="bibr" target="#b39">[42,</ref><ref type="bibr" target="#b40">43]</ref>, meaning that each microarchitecture can make their own decision on when to process the asynchronous interrupt. Thus, even if DIFUZZRTL raises an interrupt when RTL design's PC has a specific address value, RTL design may not process the interrupt when executing that address value-it may process the interrupt much later. In order to address this challenge, DIFUZZRTL exhaustively attempts to find the correct cycle by re-running the RTL simulation while advancing the interrupt assertion cycle one by one from the cycle when corresponding PC is committed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Checking Execution Results</head><p>Once the running of both ISA and RTL simulation for a given SimInput ends, DIFUZZRTL starts the cross-checking process. First, DIFUZZRTL checks if the control-flows of ISA and RTL simulations are the same. If both simulations correctly reach the end of execution, DIFUZZRTL reads programmer visible states of RTL design as we have done for the ISA case, and then compares it with ISA one's. If the architectural states do not match, DIFUZZRTL saves the corresponding SimInput as a potential bug since both designs should be in the same state after the same execution.</p><p>Note that the design of DIFUZZRTL relies on the ISA simulator, which implies two functional limitations: 1) The target CPU RTL design should have the ISA simulator; and 2) While DIFUZZRTL can detect ISA level bugs, it cannot detect non-ISA level bugs. The first limitation can be mitigated if two different RTL designs implement the same ISA. In this case, DIFUZZRTL can be extended to perform the differential testing between those two (e.g., Rocket and Boom cores are two different RTL designs implementing the same ISA). The second issue can be partially addressed if the designer implements manual hardware assertions checking micro-architectural contexts, which can be retrofitted by DIFUZZRTL to detect non-ISA level bugs.</p><p>Then, if new register-coverage is discovered, the corresponding SimInput is saved to the corpus so that it can get another chance to be fuzzed later, thereby DIFUZZRTL's fuzzing procedure is register-coverage guided. DIFUZZRTL repeats above steps while resetting the design every iteration.</p><p>V. IMPLEMENTATION For DIFUZZRTL, we implemented both RTL compiler pass for register-coverage instrumentation and CPU fuzzing framework. DIFUZZRTL is open-source and available at https://github.com/compsec-snu/difuzz-rtl.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. RTL compiler pass for register-coverage Instrumentation</head><p>We modified two different HDL processing tools: 1) Pyverilog, for codes written in Verilog <ref type="bibr" target="#b41">[44]</ref>; and 2) FIRRTL compiler, for FIRRTL codes which is the intermediate language of Chisel <ref type="bibr" target="#b42">[45]</ref>. These tools thus automatically find control registers, instrument register-coverage, then produce instrumented Verilog code as a final output. Our implementation includes 1.5 k lines of python code (in Pyverilog) and 2 k lines of Scala code (in FIRRTL compiler).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. CPU fuzzing framework</head><p>CPU fuzzing framework of DIFUZZRTL runs as a testbench for the CPU RTL designs while running SimInput mutation, ISA simulation and bug checking. For SimInput mutation and other functionalities outside the RTL simulation, DIFUZZRTL consists of 4 k lines of Python, which include manually determined opcodes and registers for instruction generation. We also added 800 lines to the ISA simulator for instruction emulation and a pseudo interrupt controller. The framework also relies on gnu toolchains (i.e. gcc, nm) to generate simulation inputs. Then, we implemented the prototype of DIFUZZRTL on two different RTL testing environments, the software simulation and the FPGA emulation. Prototyping for Software Simulation. We used cocotb <ref type="bibr" target="#b43">[46]</ref>, a python based test bench tool for RTL codes, to implement the prototype on RTL software simulation. The designs are then simulated using an RTL simulator (i.e., Verilator <ref type="bibr" target="#b44">[47]</ref> or icarus Verilog <ref type="bibr" target="#b45">[48]</ref>). This prototype includes 1.5 k lines of python codes for stimuli generation and monitoring the simulation. Prototyping for FPGA emulation.</p><p>In order to test DIFUZZRTL using FPGA emulation, we incorporated the fuzzing framework into FireSim, which is an FPGAaccelerated simulation platform developed by BAR <ref type="bibr">[49]</ref>. Thus, DIFUZZRTL's implementation on FireSim automatically instruments register-coverage when building an FPGA image, thereby enabling the fuzzing framework. To this end, we modified 200 lines of Scala and 500 lines of C++ codes in FireSim.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EVALUATION This section evaluates DIFUZZRTL on various aspects. We first describe the evaluation setup of DIFUZZRTL ( ¬ßVI-A).</head><p>Then we evaluate the effectiveness of register-coverage with synthetic RTL designs ( ¬ßVI-B). Next, we analyze the performance of DIFUZZRTL with real-world CPU designs in two different testing environments: 1) software simulation ( ¬ßVI-C); and 2) FPGA emulation ( ¬ßVI-D). Then we describe the list of new bugs that DIFUZZRTL found ( ¬ßVI-E), and introduce case studies of finding real-world bugs through DIFUZZRTL and other approaches ( ¬ßVI-F).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Evaluation Setup 1) RTL Designs:</head><p>In order to evaluate DIFUZZRTL, we performed the fuzz testing with various RTL designs, from synthetic RTL designs to real-world OpenRISC and RISC-V CPU cores. Synthetic RTL. In order to clearly understand DIFUZZRTL, we developed a synthetic RTL design based on the code example shown in Figure <ref type="figure" target="#fig_1">22</ref>. We added one more register variable from the example so that the bug is triggered when the registers reach a specific state. We also tested synthetic RTL design while varying the number of states by adding more states per each register (i.e., adding more bits to each register). In total, four different versions of RTL designs with the different number of finite states were tested: 27 , 64 , 125, and 216 states.</p><p>Real-World OpenRISC Mor1kx Cappuccino. This is a five stage pipelined core which implements the OpenRISC ISA <ref type="bibr" target="#b40">[43]</ref>. Modules such as MMU, cache, and FPU are included in this design, building a full-fledged core. Thus, this core supports basic and floating point instruction set in OpenRISC ISA and is able to boot Linux. In order to perform the differential testing while fuzzing, DIFUZZRTL used OpenRISC Or1ksim as a golden model, which is an OpenRISC ISA simulator. Real-World RISC-V Rocket Core. Rocket core is an in-order pipelined core which is included in RISC-V Rocket <ref type="bibr">Chip [41]</ref>. This core is supported by industry for the chip prototyping. We note that Rocket core is extensively verified by the steering research group. In order to perform the differential testing while fuzzing the Rocket core, we used a RISC-V reference ISA simulator, Spike, as a golden model. Spike is commonly used to verify the correctness of new hardware designs. Real-World RISC-V Boom Core. Boom Core is an outof-order superscalar core which can also be used in RISC-V Rocket Chip SoC. Features for out-of-order cores such as issue queue or ROB are implemented in Boom core thus its micro architecture is much more complex than in-order cores. Boom core is also able to boot linux and widely verified by the steering research group. To perform the differential testing, we used Spike as we have done for the Rocket core.</p><p>2) Fuzz Testing Environment: We evaluated DIFUZZRTL in two different environments for testing RTL designs, i.e. software simulation and FPGA emulation. Software Simulation. All our experiments based on software simulation were carried out on a machine of Intel Xeon Gold 6140 with 72 CPU cores and 512GB RAM, which runs Ubuntu 18.04 LTS. For synthetic RTL designs, we fuzzed each version 1,000 times and plotted a graph representing the distributions so as to come up with a more robust statistical conclusion. For real-world RTL designs, we fuzzed each RTL design with the corresponding ISA simulator for three times and plotted a graph showing an average value as well as minimum and maximum values along with an error bar. FPGA Emulation. We ran DIFUZZRTL using FPGA emulation on an Amazon EC2 F1 instance <ref type="bibr" target="#b46">[50]</ref>, which offers a customizable hardware acceleration feature through FPGA. Similar to the case of the software simulation, we fuzzed Rocket core and Boom core three times and plotted a graph showing an average value and error bar.</p><p>3) Coverage Guiding Setup for Fuzzing: To compare the effectiveness DIFUZZRTL's register-coverage guided fuzzing, we ran DIFUZZRTL while changing the coverage guiding feature: 1) no-cov, which does not leverage any coverageguided feature; 2) mux-cov, which utilizes the mux-coverage guided fuzzing as proposed by RFuzz <ref type="bibr" target="#b13">[14]</ref>; and 3) reg-cov, which utilizes the register-coverage guided fuzzing that we propose with DIFUZZRTL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Fuzzing Synthetic RTL</head><p>Static Instrumentation Overhead. To compare the efficiency of DIFUZZRTL's register-coverage and RFuzz's mux- In the evaluation, the fuzzer randomly generates input which is defined as a concatenation of bit vectors fed to the design every cycle. We use a simple random bit flip algorithm for mutation so that the only difference is the coverage for input guidance, i.e., 1) no-coverage guided, 2) mux-coverage guided, and 3) register-coverage guided.</p><p>As illustrated in Figure <ref type="figure" target="#fig_0">10</ref>, register-coverage guided fuzzer shows a remarkable improvement over other two coverageguiding methods thanks to the judicious guidance. On the other hand, mux-coverage was even worse than the no-coverage due to the limitations of the mux-coverage. This is because the</p><formula xml:id="formula_4">no-cov mux-cov reg-cov no-cov N.A. - - mux-cov 9.46e -13 N.A. - reg-cov 2.64e -33 1.25e -34 N.A.</formula><p>Fig. <ref type="figure" target="#fig_0">11</ref>: p-values of the Mann-Whitney U test between distributions, where each distribution is populated with each coverage-guiding method. Two distributions are considered significantly different if p-value is less than 0.05 <ref type="bibr" target="#b47">[51]</ref>.</p><p>no-cov mux-cov reg-cov no-cov</p><formula xml:id="formula_5">N.A. - - mux-cov no-cov N.A. - reg-cov reg-cov reg-cov N.A.</formula><p>Fig. <ref type="figure" target="#fig_5">12</ref>: The results of Vargha Delaney's A12 measure between the distributions. The coverage-guiding method name in a cell is the result of the VDA measure <ref type="bibr" target="#b48">[52]</ref>, which is expected to show the higher performance between the methods in the corresponding row and column (i.e., exploring a more number of states in a given number of iterations).</p><p>mux-coverage guided fuzzer not only failed to recognize the valid input but also mis-recognized the invalid input as a valid one. As a result, it inserted such invalid inputs to the fuzzing corpus and wasted the cycles to mutate the invalid inputs which do not help to explore the new state space. This tendency becomes clarified as the number of finite states increases, meaning that the register-coverage becomes more efficient. Compared to mux-coverage guided fuzzer, register-coverage guided fuzzer reached the bug state almost 6.4 times faster.</p><p>In terms of the average number of reached states during the fuzzing iterations, register-coverage has shown the best performance-i.e., register-coverage guided fuzzer explored the highest number of states as shown in Figure <ref type="figure" target="#fig_0">10-(b</ref>). To come up with a more robust statistical conclusion, we performed two statistical testings, the Mann-Whitney U test <ref type="bibr" target="#b49">[53]</ref> and the Vargha Delaney's A12 (VDA) measure <ref type="bibr" target="#b48">[52]</ref>, on the distributions obtained from the number of reached states during 5,000 iterations.</p><p>According to the Mann-Whitney U test, p-value between each distribution (i.e., a distribution populated with no-coverage, mux-coverage, and register-coverage guiding method) was always less than 0.05 as shown in Figure <ref type="figure" target="#fig_0">11</ref>, suggesting that all three distributions show clear statistical differences. The VDA measure also demonstrated that the register-coverage always showed higher improvement over the other two coverageguiding methods (shown in Figure <ref type="figure" target="#fig_5">12</ref>)-the VDA score was always larger than 0.71. One thing to note is that the muxcoverage clearly decreased the performance even more than the no-coverage case as we described before. ‚úó RFuzz failed to instrument Mor1kx cappuccino and Boom core Fig. <ref type="figure" target="#fig_0">14</ref>: Runtime overheads of register-coverage and mux-coverage for real-world CPU RTLs.</p><p>C. Fuzzing Real-World Designs (Software Simulation)</p><p>Static Instrumentation Overhead. Secondly, we evaluated the efficiency of register-coverage on real world designs. The statistics of designs and overhead of mux-coverage and registercoverage instrumentations are shown in Figure <ref type="figure" target="#fig_3">13</ref>. As in the second column, the total number of registers ranges from two hundreds to five thousands depending on the complexity of a design. However, DIFUZZRTL classified a few hundred of registers into control registers regardless of the design. Approximately, 10% of registers were classified as control registers, and the total bit width has decreased about 97%.</p><p>When it comes to the line of Verilog, register-coverage instrumentation showed the minimal increase, which is about 17% as in the last column. Even with Boom core which has almost 200, 000 Verilog code lines, the overhead was moderate (14.8%) due to the efficient instrumentation. On the other hand, mux-coverage instrumentation on Rocket core increased the number of line almost twice because of the wiring cost of monitoring per each mux. Moreover, RFuzz <ref type="bibr" target="#b13">[14]</ref> was not able to instrument Boom core due to the resource constraint.</p><p>Regarding the instrumentation detail, DIFUZZRTL allocates more space for each variables (i..e, regstate, covmap and covsum) as the number of control registers increases in a module. While the maximum size of variables is a configurable parameter, we set the maximum size of regstate to be 20-bits for this evaluation, which covers up to 2 20 bits (i.e. 1 Mb). In the case of Boom core, five out of 151 modules were instrumented using the maximum size variables, and LSU was the module which had the most control registers with 156 total bit width. The regstate in such a large module can have hash collisions, which is also an important factor for fuzzing, but we leave the detailed result of hash collision in ¬ßXI due to the space limit. Runtime Instrumentation Overhead. The run time overheads of the coverage instrumentations are shown in Figure <ref type="figure" target="#fig_0">14</ref>. As expected, the simulation speed has decreased as the design complexity increases. Mor1kx is slow because it can only be simulated using slow Icarus Verilog simulator <ref type="bibr" target="#b45">[48]</ref>. The decreased simulation speed due to the register-coverage instrumentation was about 7% thanks to the simple operation Efficiency of Register Coverage-Guided Fuzzing. To compare the efficiencies of the coverage, we measure the registercoverage and mux-coverage while running same inputs on the instrumented designs. The inputs were collected while running the fuzzer with only mux-coverage for 52 hours. The coverage results are shown in Figure <ref type="figure" target="#fig_0">15</ref>-(a) using the iteration number as the x-axis to eliminate the effect of runtime overhead. Muxcoverage quickly saturated as the iteration proceeds, but the fuzzer using register-coverage continuously found new seeds and increased the coverage. This is because register-coverage captures fine-grained behaviors of the design by capturing the state every cycle as illustrated in Figure <ref type="figure" target="#fig_0">15-(</ref> ‚úó RFuzz failed to instrument Boom core due to the out-of-resource issue. To discriminate the impact of interrupt assertion, we repeated running Rocket core with two SimInput which are only different in that the latter one contains non-zero interrupt values. Thus the latter SimInput explores the new states introduced by the interrupt assertions. For each run, we collected the values of control registers as a bit vector whenever a new state is explored, which represents a control state of the module.</p><p>Then, we summarized the bit vectors as a histogram which is shown in Figure <ref type="figure" target="#fig_6">17</ref>, thereby each bar represents the frequency of the bit when a new state is explored. Among the bars, we found that only the bit in index three shows increased frequency when the interrupt is used. After manually auditing the source code, we confirm that the bit in index three was belonging to the wb reg xcpt register in Rocket core, which is used for exception handling. Therefore, we conclude that raising interrupts enables DIFUZZRTL to explore unknown states, which is otherwise not possible to be reached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Fuzzing Real-World Designs (FPGA Emulation)</head><p>Since the performance of fuzzing is highly depending on the speed of running each iteration, FPGA emulation can significantly improve the performance of fuzzing-FPGA runs on a synthesized hardware circuit. In this sense, we attempted to evaluate DIFUZZRTL and RFuzz with the FPGA emulation, particularly focusing on following two aspects: the runtime instrumentation overheads and the fuzzing performance. To shortly summarize the results, DIFUZZRTL successfully instrumented both Rocket core and Boom core, and showed improved runtime instrumentation overheads and fuzzing performance as expected. In the case of RFuzz, it was able to instrument Rocket core and showed the improved performance as expected. However, it was not able to instrument Boom core, because mux-coverage of RFuzz requires more resources than available, leading to the instrumentation failure. Runtime Instrumentation Overhead. As shown in Figure <ref type="figure" target="#fig_9">18</ref>, DIFUZZRTL instrumented and compiled both Rocket core and Boom core at 90 MHz clock frequency using Vivado 2018.3. In each iteration, the synthesized core runs at 5.73 MHz. This clock slowdown is as expected because DIFUZZRTL should perform following fuzzing operations: 1) monitoring and scheduling the running instance; and 2) fuzzing management. Also, operations outside FPGA (i.e., fuzzing corpus management and SimInput mutation) becomes a bottleneck since DIFUZZRTL alternatively runs the mutation and FPGA emulation. This clock slowdown can be mitigated by employing general optimization techniques, such as running the mutation and FPGA emulation in parallel, but we leave those as future work.</p><p>RFuzz was also able to run mux-coverage instrumented Rocket core at 5.73 MHz with 90 MHz clock frequency. However, RFuzz failed to build Boom core, so we were not able to perform the evaluation for RFuzz's case on Boom core. Fuzzing Performance. The register-coverage guided fuzzer using FPGA emulation showed much better performance compared to the random testing without coverage guiding as shown in Figure <ref type="figure" target="#fig_10">19</ref>. Specifically, register-coverage guided fuzzing reached the two times more number of register-coverage than without coverage guiding after fuzzing 9 hours. It is worth noting that, as we have shown before, the difference was only about 20 % given the same 9 hours fuzzing time in software simulation. This clear improvement compared to the software simulation (i.e., from 20 % to 2 X for the given 9 hours) is thanks to the fact that the FPGA emulation runs almost 30 times faster than the simulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Newly Discovered Bugs in Real-World RTL Designs</head><p>During the evaluation, DIFUZZRTL found 16 new bugs in total (listed in Figure <ref type="figure" target="#fig_1">20</ref>), all of which were confirmed by the respective development communities or vendors and some of those are already being patched. More importantly, five of those were assigned with CVE numbers, signifying its strong impacts to the security community. These discovered bugs can be classified into four categories: atomic operation related bugs, instruction decoding bugs, memory related bugs, and performance bugs, demonstrating the wide coverage of DIFUZZRTL with respect to bug types in CPU RTLs.</p><p>First, incorrect behaviors in atomic memory operations (loadreserve store-conditional instructions) were frequently found. According to the OpenRISC ISA <ref type="bibr" target="#b40">[43]</ref>, reservation set by loadreserve instruction should be unset when the snooping hit occurs. However, Mor1kx cappuccino did not follow the ISA, causing memory consistency problems when the bug occurs (CVE-2020-13455).</p><p>Similar to OpenRISC, RISC-V does not allow a load-reserve instruction on a misaligned address to set the reservation. However, Boom core did not follow the specification, causing the following store-conditional instruction to succeed. Especially the bug was only triggered when the related address is cached in the core, since the reservation signal reaches the cache line before the exception signal abort the reservation (CVE-2020-29561).</p><p>Bugs related to instruction decoding were found as DIFUZZRTL randomly provides illegal opcode to RTLs. Especially in Boom core, floating point instructions with unallowed rounding bits successfully updated the floating point registers. This bug may incur an incorrect results of floating point instructions, which is critical in a scientific computing, as we have observed from the notorious Pentium FDIV bug <ref type="bibr" target="#b1">[2]</ref> (Issue #458). Mor1kx cappuccino also has a decoding bug related to bit processing instructions (Issue #114).</p><p>DIFUZZRTL was also able to discover bugs related to memory bus. Boom core was incorrectly setting the source field in ProbeAckData which is used for cache coherence memory protocol (CVE-2020-13251). However, the bug was not found even with several verification including running large programs on the chip. We assume the SoC used for Boom core test is tolerant to the bug, but the results will be critical if the Boom core is used with other intolerant (correctly designed) SoC.</p><p>Other bugs related to the performance were also found, such as setting FS bits in mstatus register (Boom core), which is used to decide whether save or not the floating point registers during the context switching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Case Study with Real-World Bugs</head><p>In order to clearly showcase the effectiveness of DIFUZZRTL's coverage guiding, we performed a case study with two bugs which we discovered with DIFUZZRTL (i.e., Issue #492 and CVE-2020-29561 in Figure <ref type="figure" target="#fig_1">20</ref>, both of which were found on Boom core). In particular, we compare the results of DIFUZZRTL with following two approaches: 1) riscv-torture <ref type="bibr" target="#b35">[37]</ref>, which randomly generates instructions using a pool of handcrafted instruction sequences without any coverage guided feature. This riscv-torture is widely used to verify various RISC-V cores by the development community; and 2) mux-coverage guided fuzzer, which generates  instructions on DIFUZZRTL fuzzing framework with RFuzz's mux-coverage guiding. Since RFuzz compiler pass was not able to instrument all the muxes in Boom core due to the resource constraints, we modified the pass to randomly and selectively instrument muxes. Case Study on Issue #492. The Issue #492 bug (i.e., dynamic rm bug) can be found with the following three steps: 1) Starting from the initial state, the FS bit in mstatus register should be set; 2) frm bits in fcsr register should be set with a specific value; and 3) A floating point instruction with a DYN-enabled rm field should be executed <ref type="bibr" target="#b50">[54]</ref>.</p><p>For each fuzzing iteration, we configured each approach to generate (or mutate) a sequence of instructions and tested designs. The first row of Figure <ref type="figure" target="#fig_11">21</ref> shows an average elapsed time to find the bug using each approach. DIFUZZRTL with register-coverage guidance was almost 6 times faster than riscvtorture in finding the bug since it captures each step above as a new coverage and guides input efficiently. However, the fuzzer which used mux-coverage was not able to find the bug due to the slow fuzzing speed and inefficient guidance. Case Study on CVE-2020-29561. The CVE-2020-29561 bug (i.e., misaligned lr bug) can be found with the following three steps: 1) A special memory instruction which fetches the accessed cache line (e.g., amoand) should be executed; 2) Load-reserve instruction (i.e., lr) should be executed on the same cache line but with a misaligned address. Such an instruction raises a misaligned load exception, and the program counter jumps to the address of exception vector <ref type="bibr" target="#b50">[54]</ref>; and 3) After exception, additional store-conditional instruction (i.e., sc) which accesses the same cache line should be performed, but this time, with a correct address alignment.</p><p>Due to the complex nature of the bug, it took approximately 30 hours for DIFUZZRTL to find the bug as shown in Figure <ref type="figure" target="#fig_11">21</ref>. Meanwhile, none of other techniques were able to find the bug even after running ten times of elapsed time for DIFUZZRTL (i.e., 300 hours). When reasoning about the bug reproducing, the first step (i.e., fetching a specific cache line) does not have any architectural effect on the second step (i.e., loading and reserving the same cache line). However, DIFUZZRTL captures the new coherency state of the cache line explored by the two steps, and successfully guides inputs to the next step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. LIMITATIONS</head><p>Confirming the Semantic Bugs. Since DIFUZZRTL detects semantic bugs by comparing the execution results of ISA and RTL simulation, the system alone cannot confirm which one is responsible for the found bug. Thus DIFUZZRTL requires manual inspection of the specification to confirm the bug. DIFUZZRTL may leverage the results of different implementations of the same specification (e.g. Rocket and Boom core) to at least confine the suspicious design as proposed in <ref type="bibr" target="#b34">[36]</ref>. While these are an interesting research direction, we leave them as future work. Applying Register Coverage on General RTL Designs. The design of DIFUZZRTL has several design points that can only be used for the RTL designs that have golden models. However, DIFUZZRTL's idea on register coverage is generic enough such that it can be applied to various RTL designs in the future, such as cache, ALU, rob, etc. It is also possible to run a targeted fuzzing on a module such as D-cache while simulating entire CPU because DIFUZZRTL leverages the module by module approach. Identifying Side-Channel CPU Bugs. Since DIFUZZRTL relies on differential testing to discover bugs, DIFUZZRTL alone cannot identify side-channel CPU issues such as Spectre, Meltdown, Foreshadow, MDS. In order to discover these bugs, DIFUZZRTL's compilation framework can be extended to monitor the microarchitectural states of modules to check the state changes depending on a secret value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. RELATED WORK</head><p>Dynamic RTL Verification. Dynamic RTL verification is an old verification methodology which is still widely used. In <ref type="bibr" target="#b51">[55]</ref>, authors introduce pseudo random test generation for verifying DECchip and challenges for defining coverage and test generation. Shai et al. <ref type="bibr" target="#b52">[56]</ref> designs a neural network to generate input stimuli using coverage but they require deep knowledge on the design. MicroGP <ref type="bibr" target="#b53">[57]</ref> is similar to DIFUZZRTL in that it verifies a processor using coverage for input generation. However, the work requires external tools for coverage evaluation thus increasing manual work.</p><p>Recently, various open-source tools for CPU verification <ref type="bibr" target="#b35">[37,</ref><ref type="bibr" target="#b54">58]</ref> have been introduced with the rise of RISC-V, which randomly generate instructions to test the processors. While random instruction generation is efficient for testing a wide range of processor functionalities, such tools do not have a coverage-guiding feature to rigorously test the processors. DIFUZZRTL, on the other hand, employs the coverage-guiding with carefully designed coverage metrics to further verify the processors in deeper aspects.</p><p>Other CPU fuzzing works <ref type="bibr" target="#b55">[59,</ref><ref type="bibr" target="#b56">60]</ref> aim at finding hardware flaws as well as undocumented instructions through exhaustively searching the instruction space of the x86 architecture. Instead of testing a sequence of instructions, these works focus on generating a single potentially harmful instruction opcode because the x86 architecture has a huge instruction space with a variable instruction length. While DIFUZZRTL is designed for testing a sequence of instructions, DIFUZZRTL can also help these approaches if the RTL source code is available-i.e., DIFUZZRTL can provide the coverage metric for the instruction decode unit. Coverage Definition. On the other hand, researchers have continued to find good coverage definition. Coverage metrics are classified into code coverage and functional coverage, where code coverage relies on the analysis of the code while functional coverage relies on design specific information <ref type="bibr" target="#b57">[61]</ref>. Code coverages including statement, or toggle coverage are easy to obtain but insufficient to guide input. Functional coverage requires designers manual setup.</p><p>Moudanos et al. <ref type="bibr" target="#b9">[10]</ref> introduce state coverage and transition coverage which are directly defined on the FSM. However, the metrics is not scalable because of the state explosion problem. HYBRO <ref type="bibr" target="#b58">[62]</ref> tries to reach hard to reach states while maximizing branch coverage. As mentioned, branch coverage on RTL code has fundamental limitation. Recently, RFUZZ <ref type="bibr" target="#b13">[14]</ref>, proposes mux coverage which can be synthesized into FPGA accelerated simulation. Nevertheless, the most widely used coverage is the functional coverage which is manually defined by the designers <ref type="bibr" target="#b13">[14]</ref>. Static RTL Verification. Along with dynamic verification, methods to verify RTL using static analysis have been developed. Symbolic execution mathematically verifies all the design space of the RTL code. STAR <ref type="bibr" target="#b12">[13]</ref> employs hybrid approach, using random input generation and symbolic execution but the method has limitations on the sequential depth of a variable.</p><p>Zhang et al. <ref type="bibr" target="#b59">[63]</ref> introduces backward symbolic execution to reach assertion violation. Coverage-guided Fuzzing. Many recent studies leverage coverage-guided fuzzing approach and try to achieve higher coverage and vulnerabilities in user programs and kernels <ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr">[25]</ref><ref type="bibr" target="#b24">[26]</ref><ref type="bibr" target="#b25">[27]</ref><ref type="bibr" target="#b26">[28]</ref><ref type="bibr" target="#b27">[29]</ref><ref type="bibr" target="#b28">[30]</ref><ref type="bibr" target="#b29">[31]</ref><ref type="bibr" target="#b30">[32]</ref>. For example, taint-analysis <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24]</ref> and symbolic execution <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b22">23]</ref> techniques have been proposed to overcome the limitations of coverage-guided fuzzing such as magic bytes and nested branches. Differential Fuzzing. Differential fuzzing is designed to discover semantic bugs by observing inconsistent behaviors across similar applications. For example, <ref type="bibr" target="#b60">[64,</ref><ref type="bibr" target="#b61">65]</ref> leverages differential fuzzing to find the inconsistent behaviors across Java Virtual Machines (JVMs). Nezha <ref type="bibr" target="#b33">[35]</ref> defined the notion of Œ¥-diversity, which represents the asymmetric behaviors between testing programs, to guide the fuzzer to disclose semantic bugs in softwares such as SSL/TLS libraries and PDF viewers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION</head><p>This paper proposed DIFUZZRTL, an RTL fuzzer to discover CPU bugs in RTL designs. The key design features of DIFUZZRTL includes register-coverage guided fuzzing techniques, which can be used as a drop-in-replacement fuzzer to test various CPU RTLs. DIFUZZRTL is implemented to perform the fuzz testing for three open-source CPUs, OpenRISC Mor1kx Cappuccino, RISC-V Rocket Core, and RISC-V Boom Core. During the evaluation, DIFUZZRTL identified 16 new bugs from these CPUs, demonstrating its strong practical prospects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. ACKNOWLEDGMENT</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Framework of ISA simulation and RTL simulation. RTL simulation requires SoC to run CPU RTL design with an executable file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: A general workflow of coverage-guided fuzzing techniques</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>The combined FSM of the example memory controller. The red colored state, (BF, BS) denotes a vulnerable state.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 :</head><label>3</label><figDesc>Fig.3: FSMs and schematic for example memory controller design.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>cycle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 1 2 :</head><label>12</label><figDesc>Algorithm of DIFUZZRTL's control register identificationInput: G = (V, E), graph of nodes (muxes, wires, registers, ports) parsed from HDL source code Output: C, set of all control registers 1: for each m : M ux ‚àà V do CM ‚Üê f indSrcRegs(m, œï, œï)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1 Fig. 7 :</head><label>17</label><figDesc>Fig. 7: A register-coverage instrumentation of DIFUZZRTL, which adds following three registers: regstate represents the state of the module, covmap remembers the reached states, and covsum summarize the number of reached states.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: The workflow of DIFUZZRTL's clock-sensitive register-coverage schemes for benign (left) and bug triggering inputs (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 15 :Fig. 16 :</head><label>1516</label><figDesc>Fig. 15: Efficiency of register-coverage for real world RTL designs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 18 :</head><label>18</label><figDesc>Fig. 18: Runtime overheads of register-coverage and mux-coverage for FPGA emulation. The numbers in the brackets are timing constraints for the FPGA bitstream.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 19 :</head><label>19</label><figDesc>Fig. 19: FPGA emulation results of register-coverage guided fuzzing and no-coverage guided fuzzing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 21 :</head><label>21</label><figDesc>Fig.21: Average time to find real-world bugs using each approach.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Figure 9  shows the statistics of each synthetic RTL design and the overheads of coverage instrumentations. The design has total six registers and 18 muxes, where only three registers are identified as control registers by DIFUZZRTL. The number of muxes that muxcoverage has to monitor linearly increases as the number of states increases, but the bits in control registers that register coverage should monitor marginally increases. Efficiency of Register Coverage-Guided Fuzzing. Coverage metrics during the RTL fuzzing should efficiently guide an input stimuli to unexplored states. To this end, we measured the average cycles to reach the vulnerable state in each version of synthetic RTL design with different coverage guidances.</figDesc><table><row><cell></cell><cell>Project</cell><cell></cell><cell cols="5">Num. reg. (Bits) Num. muxes Verilog</cell><cell>Overhead (%)</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Total</cell><cell>Control</cell><cell cols="2">Total</cell><cell>Original mux-cov reg-cov</cell></row><row><cell cols="3">Synthetic RTL (27)</cell><cell>6 (18)</cell><cell>3 (6)</cell><cell></cell><cell>9</cell><cell>123</cell><cell>118</cell><cell>24</cell></row><row><cell cols="3">Synthetic RTL (64)</cell><cell>6 (18)</cell><cell>3 (6)</cell><cell cols="2">12</cell><cell>145</cell><cell>121</cell><cell>20</cell></row><row><cell cols="4">Synthetic RTL (125) 6 (21)</cell><cell>3 (9)</cell><cell cols="2">15</cell><cell>167</cell><cell>121</cell><cell>17</cell></row><row><cell cols="4">Synthetic RTL (216) 6 (21)</cell><cell>3 (9)</cell><cell cols="2">18</cell><cell>187</cell><cell>121</cell><cell>15</cell></row><row><cell cols="8">Fig. 9: Coverage instrumentation overheads for synthetic RTL</cell></row><row><cell cols="2">designs</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Elapsed time (s) to find bug</cell><cell>0.0001 0.001 0.01 0.1 1 10</cell><cell>no-cov mux-cov reg-cov</cell><cell></cell><cell></cell><cell>Number of states covered</cell><cell>0 50 100 150 200</cell><cell>no-cov mux-cov reg-cov</cell></row><row><cell></cell><cell>27</cell><cell cols="3">64 Number of finite states 125 216</cell><cell></cell><cell></cell><cell>0 1000 2000 3000 4000 5000 Number of fuzzing iterations</cell></row><row><cell cols="5">(a) Average time (s) to find bug</cell><cell></cell><cell></cell><cell>(b) Reached states</cell></row><row><cell cols="8">Fig. 10: Efficiency of coverage guided fuzzing for synthetic</cell></row><row><cell cols="3">RTL designs</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="8">coverage scheme, we instrumented each coverage scheme on</cell></row><row><cell cols="8">the synthetic RTL designs. Runtime Instrumentation Overhead. In the case of runtime</cell></row><row><cell cols="8">overhead due to the instrumentation, simulation speeds were</cell></row><row><cell cols="8">not largely different by each other. More specifically, the</cell></row><row><cell cols="8">original performance before the coverage instrumentation</cell></row><row><cell cols="8">showed 2.36 MHz, and after the coverage instrumentation,</cell></row><row><cell cols="8">DIFUZZRTL's register-coverage showed 2.29 MHz (i.e., 4.2%</cell></row><row><cell cols="8">slowdown) and RFuzz's mux-coverage showed 2.02 MHz (i.e.,</cell></row><row><cell cols="8">15.4% slowdown). As we will show later with real-world RTL</cell></row><row><cell cols="8">designs, if the target RTL designs are complicated enough,</cell></row><row><cell cols="8">DIFUZZRTL's performance improvement over RFuzz becomes</cell></row><row><cell cols="8">significant-up to 40 times for the RISC-V Rocket core.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>RFuzz failed to instrument Mor1kx cappuccino and Boom core Fig. 13: Instrumentation overhead for real-world CPU RTLs</figDesc><table><row><cell>Project</cell><cell cols="3">Num. reg (Bits)</cell><cell cols="3">Num. muxes Verilog</cell><cell cols="2">Overhead (%)</cell></row><row><cell></cell><cell>All</cell><cell></cell><cell>Control</cell><cell>Total</cell><cell cols="4">Original mux-cov reg-cov</cell></row><row><cell>mor1kx</cell><cell cols="2">258 (780)</cell><cell>90 (106)</cell><cell>1.33 k</cell><cell>8.31 k</cell><cell></cell><cell>‚úó</cell><cell>21</cell></row><row><cell>Rocket</cell><cell cols="3">1,3 k (15.3 k) 207 (661)</cell><cell>5.3 k</cell><cell>69.2 k</cell><cell></cell><cell>112</cell><cell>18</cell></row><row><cell>Boom</cell><cell cols="3">4.90 k (36.6 k) 330 (990)</cell><cell>21 k</cell><cell>168 k</cell><cell></cell><cell>‚úó</cell><cell>15</cell></row><row><cell>‚úó Project</cell><cell cols="3">Simulation speed (Hz)</cell><cell cols="2">Slowdown (%)</cell><cell cols="3">Fuzzing speed * (Hz)</cell></row><row><cell></cell><cell cols="7">no-cov mux-cov reg-cov mux-cov reg-cov mux-cov</cell><cell>reg-cov</cell></row><row><cell cols="2">mor1kx 2.94 k</cell><cell>‚úó</cell><cell>2.76 k</cell><cell>‚úó</cell><cell>6.1</cell><cell></cell><cell>‚úó</cell><cell>0.41</cell></row><row><cell>Rocket</cell><cell>2.44 k</cell><cell>56.5</cell><cell>2.27 k</cell><cell>97</cell><cell>6.9</cell><cell></cell><cell>0.006</cell><cell>0.23</cell></row><row><cell>Boom</cell><cell>1.71 k</cell><cell>‚úó</cell><cell>1.60 k</cell><cell>‚úó</cell><cell>6.4</cell><cell></cell><cell>‚úó</cell><cell>0.15</cell></row></table><note>* Fuzzing speed is defined as the number of fuzzing iterations per second.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>b). Fuzzing speed is defined as the number of fuzzing iterations per second.</figDesc><table><row><cell>Frequency as a new coverage</cell><cell>100 200 300 400 500</cell><cell>updates w/o intr updates w/ intr</cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>10</cell><cell>20</cell><cell>30</cell></row><row><cell></cell><cell></cell><cell cols="2">Bit index</cell></row><row><cell cols="5">Fig. 17: Frequency of registers bit values in Rocket core when</cell></row><row><cell cols="3">new coverage is explored</cell><cell></cell></row><row><cell>Project</cell><cell cols="2">FPGA emulation (Hz)</cell><cell></cell><cell>Fuzzing speed * (Hz)</cell></row><row><cell></cell><cell>mux-cov</cell><cell>reg-cov</cell><cell></cell><cell>mux-cov</cell><cell>reg-cov</cell></row><row><cell cols="4">Rocket 5.73 M (90 M) 5.74 M (90 M)</cell><cell>4.13</cell><cell>4.13</cell></row><row><cell>Boom</cell><cell></cell><cell cols="2">‚úó 5.73 M (90 M)</cell><cell>‚úó</cell><cell>4.13</cell></row><row><cell>Fuzzing Performance. To evaluate the performance of fuzzer,</cell><cell></cell><cell></cell><cell></cell></row><row><cell>we compared random testing without coverage guiding (no-cov)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>and DIFUZZRTL (reg-cov), where the random testing only</cell><cell></cell><cell></cell><cell></cell></row><row><cell>generates formatted instructions without guidance. The results</cell><cell></cell><cell></cell><cell></cell></row><row><cell>are illustrated in Figure 16. Looking at the results, DIFUZZRTL</cell><cell></cell><cell></cell><cell></cell></row><row><cell>reached higher coverage as the design complexity increases.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Especially in Boom core, the fuzzer achieves remarkable gain</cell><cell></cell><cell></cell><cell></cell></row><row><cell>over random testing.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Effectiveness of Interrupt Mutation. One of the reason</cell><cell></cell><cell></cell><cell></cell></row><row><cell>DIFUZZRTL has chosen to fuzz CPU directly is that large</cell><cell></cell><cell></cell><cell></cell></row><row><cell>input space leads to an extensive exploration. We wonder</cell><cell></cell><cell></cell><cell></cell></row><row><cell>how DIFUZZRTL can leverage such opportunity by generating</cell><cell></cell><cell></cell><cell></cell></row></table><note>*</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>ProbeAckData does not match the sink field of ProbeRequest When frm is set DYN, floating point instruction with DYN rm field should raise exception Fig.20:A list of newly discovered bugs by DIFUZZRTL. DIFUZZRTL identified 16 bugs in total, all of those were confirmed by respective vendors. Five of those were assigned with CVE numbers.</figDesc><table><row><cell>Project</cell><cell>ISA</cell><cell>Bug ID</cell><cell cols="2">Description</cell><cell>Confirmed</cell><cell>Fixed</cell></row><row><cell>Mork1x</cell><cell cols="2">OpenRISC CVE-2020-13455</cell><cell cols="2">Reservation is not cancelled when there is snooping hit between lwa and swa</cell><cell>‚úì</cell><cell>pending</cell></row><row><cell></cell><cell></cell><cell>CVE-2020-13454</cell><cell cols="2">Jump to link register does not assert illegal instruction exception</cell><cell>‚úì</cell><cell>pending</cell></row><row><cell></cell><cell></cell><cell>CVE-2020-13453</cell><cell cols="2">Misaligned swa raise exception when reservation is not set</cell><cell>‚úì</cell><cell>pending</cell></row><row><cell></cell><cell></cell><cell>Issue #114</cell><cell cols="2">l.fl1, l.ff1 instruction decoding bug</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>Issue #99</cell><cell cols="2">eear register not saving instruction virtual address when illegal instruction exception</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell cols="2">Rocket chip RISCV</cell><cell>Issue #2345</cell><cell cols="2">Instruction retired count not increased when ebreak</cell><cell>‚úì</cell><cell>pending</cell></row><row><cell>Boom</cell><cell>RISCV</cell><cell>CVE-2020-13251</cell><cell cols="3">Source field in ‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>Issue #458</cell><cell cols="2">Floating point instruction which has invalid rm field does not raise exception</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>Issue #454</cell><cell cols="2">FS bits in mstatus register is set after fle.d instruction</cell><cell>‚úì</cell><cell>pending</cell></row><row><cell></cell><cell></cell><cell>Issue #492</cell><cell></cell><cell></cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>Issue #493</cell><cell cols="2">Rounding mode in fsqrt instruction does not work</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>Issue #503</cell><cell cols="2">invalid operation flag is not set after invalid fdiv instruction</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>CVE-2020-29561</cell><cell cols="2">Misaligned lr instruction on a cached line set the reservation</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell>Spike</cell><cell>RISCV</cell><cell>CVE-2020-13456</cell><cell cols="2">Misaligned lr.d should not set load reservation</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>Issue #2390</cell><cell cols="2">Reading dpc register should raise exception in machine mode</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell></cell><cell>Issue #426</cell><cell cols="2">Faulting virtual address should not be written to mtval when ebreak</cell><cell>‚úì</cell><cell>‚úì</cell></row><row><cell></cell><cell>Bug ID</cell><cell cols="2">Elapsed time (h)</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="3">riscv-torture mux-cov reg-cov</cell><cell></cell></row><row><cell></cell><cell>Issue #492</cell><cell>118</cell><cell>‚úó</cell><cell>20.3</cell><cell></cell></row><row><cell></cell><cell>CVE-2020-29561</cell><cell>‚úó</cell><cell>‚úó</cell><cell>31.7</cell><cell></cell></row><row><cell></cell><cell cols="2">‚úóNot able to reproduce bug</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">0x100 : (0130071b | addiw a4, zero, 0x13 INT.: 0000-&gt;0000)</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">0x104 : (01c0036f | jal t1, pc + 0x1cINT.: 0000-&gt;0100-&gt;0000)</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2">0x120 : (02e32823 | sw t4, 0x30(t1)INT.: 0100-&gt;0100-&gt;0000)</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3">0x300 : (3943648f | unknown INT.: 0000)</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4">0x310 : (064ff13b | unknown INT.: 0000)</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We would like to thank Matthew Hicks and anonymous reviewers for their insightful comments, which significantly improved the final version of this paper. We also thank the developers of the open-source CPUs for their helpful feedback and responses. This work was partially supported by National Research Foundation (NRF) of Korea grant funded by the Korean government (NRF-2021R1A2C3014131, NRF-2019R1C1C1006095), Institute for Information &amp; communications Technology Promotion (IITP) grant funded by the Korea government (MSIP) (No.2020-0-01840, Analysis on technique of accessing and acquiring user data in smartphone). The Institute of Engineering Research (IOER) and Automation and Systems Research Institute (ASRI) at Seoul National University provided research facilities for this work. The Institute of Engineering Research at Seoul National University provided research facilities for this work.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XI. APPENDIX</head><p>This appendix section provides supplementary information regarding this paper. Listing of Motivation Example. Figure <ref type="figure">24</ref> shows the appended Verilog code to the original code (shown in Figure <ref type="figure">22</ref>) for the instrumentation. Only state S and state F registers are used because they are wired into the mux control signal. The registers are hashed into regstate through random offset ({ }) and xor operation (ÀÜ). Then, the logic for covmap and covsum is instrumented. Calculation on Collision Probability. Since DIFUZZRTL hashes control register value into the regstate, collision could happen where different control register values are hashed into the same regstate value. To this end, DIFUZZRTL allocates more space for each variables (i.e. regstate, covmap and covsum) as the number of control registers increases. However, the collision is unavoidable if the total bit width of control registers is larger than the maximum size of regstate.</p><p>In order to understand the collision probability, we measured the register-coverage instrumentation details. While the maximum size of variables is a configurable parameter, we set the Fig. <ref type="figure">22</ref>: Verilog code example of a simple memory controller which connects sdram and flash memory to the outer world. Bug is triggered when both state S and state F at BUSY. maximum size of regstate to be 20-bits for this evaluation, which covers up to 2 20 bits (i.e. 1 Mb). In the case of Boom core, five out of 151 modules were instrumented using the maximum size variables, and LSU was the module which had the most control registers. The total bit width of control registers in LSU was 156 bits. When all the control registers are hashed into 20 bits regstate, the collision probability becomes 1 ‚àí (1 ‚àí p) kC2 where p is a probability of two different states being hashed to the same regstate value and k is the number of simulated cycles. Thus, the total collision probability converges to 1 as the simulated cycle increases, reaching 99.9 % at 5,384 simulated cycles. Since the number of collisions follows a Poisson distribution, we conclude that average 6 collisions occur in one iteration <ref type="bibr" target="#b62">[66]</ref>.</p><p>While this collision probability suggests that the collision is unavoidable given the large state space of RTL modules, we believe a loss would be minimal. This is because an input which discovers a new state further reaches multiple new states in one iteration, and DIFUZZRTL will save the input as a new seed if at least one new non-colliding state is discovered. Also, a carefully designed hashing algorithm for coverage-guided fuzzing would be able to reduce the collision probability as proposed by collAFL <ref type="bibr" target="#b24">[26]</ref>. Fundamental Differences between Register-coverage and Mux-coverage.</p><p>To shortly summarize, register-coverage of DIFUZZRTL has three fundamental differences from muxcoverage of RFuzz <ref type="bibr" target="#b13">[14]</ref>, making DIFUZZRTL's simulation more efficient. First, instrumenting control registers is more efficient than instrumenting all the muxes. Second, DIFUZZRTL summarizes the coverage in each module and wires only the sum of coverage until the top level module, but RFuzz needs to propagate all the mux control signals upto the top level module. Third, DIFUZZRTL employs simple hashing for the coverage computation while RFuzz requires a saturating counter for each mux.</p><p>As a result, assuming the number of modules in a design is M and the number of elements (i.e., control registers for DIFUZZRTL, muxes for RFuzz) in a module is N , DIFUZZRTL requires O(M ‚Ä¢N +M ) of computation resources for hashing control registers and connecting the sum of coverage to the top level module. On the other hand, RFuzz requires O(M 2 ‚Ä¢ N + M ‚Ä¢ N ) resources for connecting all the mux control signals to the top level module and attaching a saturating monitor for each mux. Potential Security Impacts of Hardware Flaws. Abnormal behaviors of the processors failing to follow the ISA could result in critical security damages. DIFUZZRTL found several hardware flaws that can be potentially destructive, thus assigned with CVE reference numbers.</p><p>Among those, CVE-2020-13455, CVE-2020-13453, CVE-2020-13251, and CVE-2020-29561 directly harm the memory consistency of the processors, thus can result in potential race bugs. It is widely known that the race bugs are harmful to the security of the entire system and the attackers can abuse such bugs to compromise the system. More critically, it would take long time to identify that the root causes of such bugs are hardware flaws since the race bugs are already too subtle and non-deterministic to be detected. CVE-2020-13454 and CVE-2020-13453 can be abused by the attackers to bypass ROP defense schemes. Conventional defense tools against ROP attacks would not assume those instructions as a potential gadgets because the instructions should result in an exception in correct semantics. However, attackers with the knowledge of these hardware flaws could rely on the fact that the victim instructions do not trap, avoiding the expected exceptions and thus completing the ROP attacks.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Online design bug detection: Rtl analysis, flexible mechanisms, and evaluation</title>
		<author>
			<persName><forename type="first">Kypros</forename><surname>Constantinides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Austin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<meeting>the 41st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-11">November 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Pentium</forename><surname>Fdiv</surname></persName>
		</author>
		<ptr target="https://www.techradar.com/news/computing-components/processors/pentium-fdiv-the-processor-bug-that-shook-the-world-1270773" />
		<title level="m">The processor bug that shook the world</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Intel&apos;s fdiv bug: Empty cells at empty tables</title>
		<ptr target="https://www.olenick.com/blog/articles/infamous-software-bugs-fdiv-bug/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Spectre attacks: Exploiting speculative execution</title>
		<author>
			<persName><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th IEEE Symposium on Security and Privacy (Oakland)</title>
				<meeting>the 40th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-05">May 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Meltdown: Reading kernel memory from user space</title>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Hamburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium (Security)</title>
				<meeting>the 27th USENIX Security Symposium (Security)<address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08">August 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">SPOILER: Speculative load hazards boost rowhammer and cache attacks</title>
		<author>
			<persName><forename type="first">Saad</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmad</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ida</forename><surname>Bruhns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Krebbel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Berk</forename><surname>Gulmezoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Security Symposium (Security)</title>
				<meeting>the 28th USENIX Security Symposium (Security)<address><addrLine>SANTA CLARA, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08">August 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Foreshadow: Extracting the keys to the intel SGX kingdom with transient out-of-order execution</title>
		<author>
			<persName><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marina</forename><surname>Minkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ofir</forename><surname>Weisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium (Security)</title>
				<meeting>the 27th USENIX Security Symposium (Security)<address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08">August 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="https://www.pcworld.com/article/2464880/intel-finds-specialized-tsx-enterprise-bug-on-haswell-broadwell-cpus.html" />
		<title level="m">Intel finds tsx enterprise bug on haswell, broadwll cpus</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="https://access.redhat.com/solutions/2019-microcode-nov" />
		<title level="m">Intel november 2019 microcode update</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Abstraction techniques for validation coverage analysis and test generation</title>
		<author>
			<persName><forename type="first">Dinos</forename><surname>Moundanos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacob</forename><forename type="middle">A</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yatin</forename><surname>Vasant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hoskote</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2" to="14" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Functional test generation for hard-to-reach states using path constraint solving</title>
		<author>
			<persName><forename type="first">Yanhong</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tiancheng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huawei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tao</forename><surname>Lv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="999" to="1011" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Abstraction-guided simulation using markov analysis for functional verification</title>
		<author>
			<persName><forename type="first">Jian</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huawei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tao</forename><surname>Lv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tiancheng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandip</forename><surname>Kundu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="285" to="297" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Star: Generating input vectors for design validation by static analysis of rtl</title>
		<author>
			<persName><forename type="first">Lingyi</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shabha</forename><surname>Vasudevan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 IEEE International High Level Design Validation and Test Workshop</title>
				<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-11">November 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Rfuzz: coverage-directed fuzz testing of rtl on fpgas</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donggyu</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th IEEE/ACM International Conference on Computer-Aided Design (ICCAD)</title>
				<meeting>the 37th IEEE/ACM International Conference on Computer-Aided Design (ICCAD)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-11">November 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The Verilog¬Æ Hardware Description Language</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Moorby</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The designer&apos;s guide to VHDL</title>
		<author>
			<persName><surname>Peter J Ashenden</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">American fuzzy lop</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zalewski</surname></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/afl/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Coveragebased greybox fuzzing as markov chain</title>
		<author>
			<persName><forename type="first">Marcel</forename><surname>B√∂hme</surname></persName>
		</author>
		<author>
			<persName><surname>Van-Thuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhik</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS)</title>
				<meeting>the 23rd ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-10">October 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Razzer: Finding kernel race bugs through fuzzing</title>
		<author>
			<persName><forename type="first">Kyungtae</forename><surname>Dae R Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Basavesh</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byoungyoung</forename><surname>Shivakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Insik</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th IEEE Symposium on Security and Privacy (Oakland)</title>
				<meeting>the 40th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-05">May 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Angora: Efficient fuzzing by principled search</title>
		<author>
			<persName><forename type="first">Peng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th IEEE Symposium on Security and Privacy (Oakland)</title>
				<meeting>the 39th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-05">May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">{QSYM}: A practical concolic execution engine tailored for hybrid fuzzing</title>
		<author>
			<persName><forename type="first">Insu</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meng</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yeongjin</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium (Security)</title>
				<meeting>the 27th USENIX Security Symposium (Security)<address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08">August 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Fairfuzz: A targeted mutation strategy for increasing greybox fuzz testing coverage</title>
		<author>
			<persName><forename type="first">Caroline</forename><surname>Lemieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd IEEE/ACM International Conference on Automated Software Engineering (ASE)</title>
				<meeting>the 33rd IEEE/ACM International Conference on Automated Software Engineering (ASE)<address><addrLine>Montpellier, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-09">September 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Driller: Augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName><forename type="first">Nick</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruoyu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Corbetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yan</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Annual Network and Distributed System Security Symposium (NDSS)</title>
				<meeting>the 2016 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-02">February 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Vuzzer: Application-aware evolutionary fuzzing</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vivek</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucian</forename><surname>Cojocar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristiano</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Herbert</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)</title>
				<meeting>the 2017 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-02">February 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Collafl: Path sensitive fuzzing</title>
		<author>
			<persName><forename type="first">Shuitao</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaojun</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuwen</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhongyu</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zuoning</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th IEEE Symposium on Security and Privacy</title>
				<meeting>the 39th IEEE Symposium on Security and Privacy<address><addrLine>Oakland), San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-05">May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Nautilus: Fishing for deep bugs with grammars</title>
		<author>
			<persName><forename type="first">Cornelius</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tommaso</forename><surname>Frassetto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Jauernig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Teuchert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 Annual Network and Distributed System Security Symposium (NDSS)</title>
				<meeting>the 2019 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-02">February 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Redqueen: Fuzzing with input-to-state correspondence</title>
		<author>
			<persName><forename type="first">Cornelius</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergej</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Blazytko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 Annual Network and Distributed System Security Symposium (NDSS)</title>
				<meeting>the 2019 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-02">February 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">{MOPT}: Optimized mutation scheduling for fuzzers</title>
		<author>
			<persName><forename type="first">Chenyang</forename><surname>Lyu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shouling</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuwei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei-Han</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raheem</forename><surname>Beyah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Security Symposium (Security)</title>
				<meeting>the 28th USENIX Security Symposium (Security)<address><addrLine>SANTA CLARA, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08">August 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Profuzzer: On-the-fly input type probing for better zero-day vulnerability discovery</title>
		<author>
			<persName><forename type="first">Wei</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xueqiang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shiqing</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianjun</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaofeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th IEEE Symposium on Security and Privacy (Oakland)</title>
				<meeting>the 40th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-05">May 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Imf: Inferred model-based fuzzer</title>
		<author>
			<persName><forename type="first">Hyungseok</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sang</forename><surname>Kil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cha</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Conference on Computer and Communications Security (CCS)</title>
				<meeting>the 24th ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-10">October 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Moonshine: Optimizing {OS} fuzzer seed selection with trace distillation</title>
		<author>
			<persName><forename type="first">Shankara</forename><surname>Pailoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Aday</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suman</forename><surname>Jana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium (Security)</title>
				<meeting>the 27th USENIX Security Symposium (Security)<address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08">August 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Fuzzing file systems via two-dimensional input space exploration</title>
		<author>
			<persName><forename type="first">Wen</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyungon</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanidhya</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Po-Ning</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th IEEE Symposium on Security and Privacy (Oakland)</title>
				<meeting>the 40th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-05">May 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Neuzz: Efficient fuzzing with neural program smoothing</title>
		<author>
			<persName><forename type="first">Dongdong</forename><surname>She</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kexin</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baishakhi</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suman</forename><surname>Jana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th IEEE Symposium on Security and Privacy (Oakland)</title>
				<meeting>the 40th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-05">May 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Nezha: Efficient domain-independent differential testing</title>
		<author>
			<persName><forename type="first">Theofilos</forename><surname>Petsios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Salvatore</forename><surname>Stolfo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelos</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suman</forename><surname>Jana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th IEEE Symposium on Security and Privacy (Oakland)</title>
				<meeting>the 38th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-05">May 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Cross-checking semantic correctness: The case of finding file system bugs</title>
		<author>
			<persName><forename type="first">Changwoo</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanidhya</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th ACM Symposium on Operating Systems Principles (SOSP)</title>
				<meeting>the 25th ACM Symposium on Operating Systems Principles (SOSP)<address><addrLine>Monterey, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-10">October 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<ptr target="https://github.com/ucb-bar/riscv-torture" />
		<title level="m">Risc-v torture test</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<ptr target="https://opencores.org/projects/memctrl" />
		<title level="m">Memory controller ip core</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<ptr target="https://www.oshwa.org/" />
		<title level="m">Open source hardware association</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Berkeley out-of-order machine</title>
		<ptr target="https://github.com/riscv-boom/riscv-boom" />
		<imprint>
			<pubPlace>Boom</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName><surname>Risc</surname></persName>
		</author>
		<ptr target="https://riscv.org/specifications/privileged-isa/" />
		<imprint/>
	</monogr>
	<note>v isa manual (privileged</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<ptr target="https://openrisc.io/or1k.html" />
		<title level="m">Openrisc isa manual</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Pyverilog: Python-based hardware design processing toolkit for verilog hdl</title>
		<ptr target="https://github.com/PyHDI/Pyverilog" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Chisel 3: A modern hardware design language</title>
		<ptr target="https://github.com/freechipsproject/chisel3" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title/>
		<author>
			<persName><surname>Cocotb</surname></persName>
		</author>
		<ptr target="https://github.com/cocotb/cocotb" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Verilator open-source systemverilog simulator and lint system</title>
		<ptr target="https://github.com/verilator/verilator" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title/>
		<ptr target="http://iverilog.icarus.com/" />
	</analytic>
	<monogr>
		<title level="j">Icarus</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<ptr target="https://github.com/aws/aws-fpga" />
		<title level="m">Aws ec2 fpga development kit</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Evaluating fuzz testing</title>
		<author>
			<persName><forename type="first">George</forename><surname>Klees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Ruef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benji</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shiyi</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th ACM Conference on Computer and Communications Security (CCS)</title>
				<meeting>the 25th ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-10">October 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A critique and improvement of the cl common language effect size statistics of mcgraw and wong</title>
		<author>
			<persName><forename type="first">Andr√°s</forename><surname>Vargha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harold</forename><forename type="middle">D</forename><surname>Delaney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Educational and Behavioral Statistics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="101" to="132" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Mann-whitney u test. The Corsini encyclopedia of psychology</title>
		<author>
			<persName><forename type="first">E</forename><surname>Patrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julius</forename><surname>Mcknight</surname></persName>
		</author>
		<author>
			<persName><surname>Najab</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="1" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title/>
		<author>
			<persName><surname>Risc</surname></persName>
		</author>
		<ptr target="https://riscv.org/specifications/unprivileged-isa/" />
		<imprint/>
	</monogr>
	<note>v isa manual (unprivileged</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">I&apos;m done simulating; now what? verification coverage analysis and correctness checking of the decchip 21164 alpha microprocessor</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kantrowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lisa</forename><forename type="middle">M</forename><surname>Noack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd annual Design Automation Conference (DAC)</title>
				<meeting>the 33rd annual Design Automation Conference (DAC)<address><addrLine>Las Vegas, NV</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Coverage directed test generation for functional verification using bayesian networks</title>
		<author>
			<persName><forename type="first">Shai</forename><surname>Fine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Ziv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th annual Design Automation Conference (DAC)</title>
				<meeting>the 40th annual Design Automation Conference (DAC)<address><addrLine>Anaheim, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Microgp-an evolutionary assembly program generator. Genetic Programming and Evolvable Machines</title>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Squillero</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-09">09 2005</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="247" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Sv/uvm based open-source instruction generator for risc</title>
		<ptr target="https://github.com/google/riscv-dv" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<ptr target="https://github.com/xoreaxeaxeax/sandsifter" />
		<title level="m">Sandsifter: the x86 processor fuzzer</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Uisfuzz: An efficient fuzzing method for cpu undocumented instruction searching</title>
		<author>
			<persName><forename type="first">Xixing</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zehui</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haolan</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="149224" to="149236" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Coverage metrics for functional validation of hardware designs</title>
		<author>
			<persName><forename type="first">Serdar</forename><surname>Tasiran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Keutzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Design &amp; Test of Computers</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Branch guided functional test generation at the rtl</title>
		<author>
			<persName><forename type="first">Sharad</forename><surname>Vineeth V Acharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">S</forename><surname>Bagri</surname></persName>
		</author>
		<author>
			<persName><surname>Hsiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 20th IEEE European Test Symposium (ETS)</title>
				<meeting><address><addrLine>Cluj-Napoca, Romania</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">End-to-end automated exploit generation for validating the security of processor designs</title>
		<author>
			<persName><forename type="first">Rui</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Calvin</forename><surname>Deutschbein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peng</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cynthia</forename><surname>Sturton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<meeting>the 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)<address><addrLine>Fukuoka, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-10">October 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Deep differential testing of jvm implementations</title>
		<author>
			<persName><forename type="first">Yuting</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhendong</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st International Conference on Software Engineering (ICSE)</title>
				<meeting>the 41st International Conference on Software Engineering (ICSE)<address><addrLine>Minneapolis, MN</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05">May 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Coverage-directed differential testing of jvm implementations</title>
		<author>
			<persName><forename type="first">Yuting</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengnian</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhendong</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianjun</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
				<meeting>the 2016 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06">June 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">A generalization of the poisson distribution</title>
		<author>
			<persName><forename type="first">C</forename><surname>Prem</surname></persName>
		</author>
		<author>
			<persName><surname>Consul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gaurav</surname></persName>
		</author>
		<author>
			<persName><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Technometrics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="791" to="799" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
