<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Consistent Query Answers in Inconsistent Databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1998-11-16">16th November 1998</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
							<email>marenas@ing.puc.cl</email>
							<affiliation key="aff0">
								<orgName type="department">Pontificia Universidad Católica de Chile Escuela de Ingeniería Departamento de Ciencia de Computación</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
							<email>bertossi@ing.puc.cl</email>
							<affiliation key="aff1">
								<orgName type="department">Pontificia Universidad Católica de Chile Escuela de Ingeniería Departamento de Ciencia de Computación</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Chomicki</surname></persName>
							<email>chomicki@moncol.monmouth.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Monmouth University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Consistent Query Answers in Inconsistent Databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1998-11-16">16th November 1998</date>
						</imprint>
					</monogr>
					<idno type="MD5">9F4BC2D1A3C45DFD5C6050BFE12515C8</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we consider the problem of the logical characterization of the notion of consistent answer in a relational database that may violate given integrity constraints. This notion is captured in terms of the possible repaired versions of the database. A method for computing consistent answers is given and its soundness and completeness (for some classes of constraints and queries) proved. The method is based on an iterative procedure whose termination for several classes of constraints is proved as well.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Integrity constraints capture an important normative aspect of every database application. However, it is often the case that their satisfaction cannot be guaranteed, allowing for the existence of inconsistent database instances. In that case, it is important to know which query answers are consistent with the integrity constraints and which are not. In this paper, we provide a logical characterization of consistent query answers in relational databases that Contact author. Phone: (732) 571-4457. Fax: (732) 263-5202. may be inconsistent with the given integrity constraints.</p><p>Intuitively, an answer to a query posed to a database that violates the integrity constraints will be consistent in a precise sense: It should be the same as the answer obtained from any minimally repaired version of the original database. We also provide a method for computing such answers and prove its properties. On the basis of a query Q, the method computes, using an iterative procedure, a new query T ω (Q) whose evaluation in an arbitrary, consistent or inconsistent, database returns the set of consistent answers to the original query Q. We envision the application of our results in a number of areas: Data warehousing. A data warehouse contains data coming from many different sources. Some of it typically does not satisfy the given integrity constraints. The usual approach is thus to clean the data by removing inconsistencies before the data is stored in the warehouse <ref type="bibr" target="#b3">[4]</ref>. Our results make it possible to determine which data is already clean and proceed to safely remove unclean data. Moreover, a different scenario becomes possible, in which the inconsistencies are not removed but rather query answers are marked as "consistent" or "inconsistent". In this way, information loss due to data cleaning may be prevented.</p><p>Database integration. Often many different databases are integrated together to provide a single unified view for the users. Database integration is difficult since it requires the resolution of many different kinds of discrepancies of the integrated databases. One possible discrepancy is due to different sets of integrity constraints. Moreover, even if every integrated database locally satisfies the same integrity constraint, the constraint may be globally violated. For example, different databases may assign different addresses to the same student. Such conflicts may fail to be resolved at all and inconsistent data cannot be "cleaned" because of the autonomy of different databases. Therefore, it is important to be able to find out, given a set of local integrity constraints, which query answers returned from the integrated database are consistent with the constraints and which are not.</p><p>Active and reactive databases. A violation of integrity constraints may be acceptable under the provision that it will be repaired in the near future. For example, the stock level in a warehouse may be allowed to fall below the required minimum if the necessary replenishments have been ordered. During this temporary inconsistency, however, query answers should give an indication whether they are consistent with the constraints or not. This problem is particularly acute in active databases that allow such consistency lapses. The result of evaluating a trigger condition that is consistent with the integrity constraints should be treated differently from the one that isn't.</p><p>The following example presents the basic intuitions behind the notion of consistent query answer.</p><p>Example 1. Consider a database subject to the following IC: 8x(P(x) Q(x)):</p><p>The instance fP(a);P(b);Q(a);Q(c)g violates this constraint. Now if the query asks for all x such that Q(x), only a is returned as an answer consistent with the integrity constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>The plan of this paper is as follows. In section 2 we introduce the basic notions of our approach, including those of repair and consistent query answer. In section 3 we show a method how to compute the query T ω (Q) for a given first-order query Q. In subsequent sections, the properties of this method are analyzed: soundness in section 4, completeness in section 5, and termination in section 6. In section 7 we discuss related work. In section 8 we conclude and outline some of the prospects for future work in this area. The proofs are given in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Basic Notions</head><p>In this paper we assume we have a fixed database schema and a fixed infinite database domain D. We also have a first order language based on this schema with names for the elements of D. We assume that elements of the domain with different names are different. The instances of the schema are finite structures for interpreting the first order language. As such they all share the given domain D, nevertheless, since relations are finite, every instance has a finite active domain which is a subset of D. As usual, we allow built-in predicates that have infinite extensions, identical for all database instances. There is also a set of integrity constraints IC, expressed in that language, which the database instances are expected to satisfy. We will assume that IC is consistent in the sense that there is a database instance that makes it true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1. (Consistency)</head><p>A database instance r is consistent if r satisfies IC in the standard model-theoretic sense, that is, r IC; r is inconsistent otherwise.</p><p>This paper addresses the issue of obtaining meaningful and useful query answers in any, consistent or inconsistent, database. It is well known how to obtain query answers in consistent databases. Therefore, the challenging part is how to deal with the inconsistent ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Repairs</head><p>Given a database instance r, we denote by Σ(r) the set of formulas fP(ā)jr P( ā)g, where the Ps are relation names and ā is ground tuple.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. (Distance)</head><p>The distance ∆(r; r 0 ) between databases instances r and r 0 is the symmetric difference: ∆(r; r 0 ) = (Σ(r) ?Σ(r 0 )) (Σ(r 0 ) ?Σ(r)): Definition 3. For the instances r; r 0 ; r 00 , r 0 r r 00 if ∆(r; r 0 ) ∆(r; r 00 ), i.e., if the distance between r and r 0 is less than or equal to the distance between r and r 00 .</p><p>Notice that built-in predicates do not contribute to the ∆s because they have fixed extensions, identical in every database instance. Definition 4. (Repair) Given database instances r and r 0 , we say that r 0 is a repair of r if r 0 IC and r 0 is r -minimal in the class of database instances that satisfy the ICs. 2</p><p>Clearly, what constitutes a repair depends on the given set of integrity constraints. In the following we assume that this set is fixed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.</head><p>Let us consider a database schema with two unary relations P and Q and domain D = fa;b;cg. Assume that for an instance r, Σ(r) = fP(a);P(b);Q(a);Q(c)g, and let IC = f8x(P(x)</p><formula xml:id="formula_0">Q(x))g. Clearly, r does not satisfy IC because r P(b) :Q(b).</formula><p>In this case we have two possibles repairs for r. First, we can falsify P(b), obtaining an instance r 0 with Σ(r 0 ) = fP(a);Q(a);Q(c)g. As a second alternative, we can make Q(b) true, obtaining an instance r 00 with Σ(r 00 ) = fP(a);P</p><formula xml:id="formula_1">(b);Q(a);Q(b);Q(c)g. 2</formula><p>The definition of a repair satisfies certain desirable and expected properties. Firstly, a consistent database does not need to be repaired, because if r satisfies IC, then, by the minimality condition wrt the relation r , r is the only repair of itself (since ∆(r; r) is empty). Secondly, any database r can always be repaired because there is a database r 0 that satisfies IC, and ∆(r; r 0 ) is finite.</p><p>Example 3. (motivated by <ref type="bibr" target="#b12">[13]</ref>) Consider the IC saying that C is the only supplier of items of class T 4 : 8(x;y;z)(Supply(x;y;z)^Class(z;T 4 ) x = C): <ref type="bibr" target="#b0">(1)</ref> The following database instance r 1 violates the IC:</p><formula xml:id="formula_2">Supply Class C D 1 I 1 I 1 T 4 D D 2 I 2 I 2 T 4</formula><p>The only repairs of this database are</p><formula xml:id="formula_3">Supply Class C D 1 I 1 I 1 T 4 I 2 T 4</formula><p>and</p><formula xml:id="formula_4">Supply Class C D 1 I 1 I 1 T 4 D D 2 I 2</formula><p>Example 4. (motivated by <ref type="bibr" target="#b12">[13]</ref>) Consider the IC: 8(x;y)(Supply(x;y;I 1 ) Supply(x; y; I 2 )); <ref type="bibr" target="#b1">(2)</ref> saying that item I 2 is supplied whenever item I 1 is supplied; and the following inconsistent instance, r 2 , of the database</p><formula xml:id="formula_5">Supply C D 1 I 1 C D 1 I 3</formula><p>This instance has two repairs:</p><formula xml:id="formula_6">Supply C D 1 I 1 C D 1 I 2 C D 1 I 3 and Supply C D 1 I 3</formula><p>Example 5. Consider a student database. Student(x; y; z) means that x is the student number, y is the student's name, and z is the student's address. The two following ICs state that the first argument is a key of the relation 8(x;y;z;u;v)(Student(x;y;z)^Student(x;u;v) y = u); 8(x;y;z;u;v)(Student(x;y;z)^Student(x;u;v) z = v):</p><p>The inconsistent database instance r 3</p><formula xml:id="formula_7">Student Course S 1 N 1 D 1 S 1 C 1 G 1 S 1 N 2 D 1 S 1 C 2 G 2</formula><p>has two repairs: </p><formula xml:id="formula_8">Student Course S 1 N 1 D 1 S 1 C 1 G 1 S 1 C 2 G 2 and Student Course S 1 N 2 D 1 S 1 C 1 G 1 S 1 C 2 G 2</formula><formula xml:id="formula_9">j = c Q(t) (or r j = c Q( x) t]), if for every repair r 0 of r, r 0 Q(t). If Q is a sentence, then true (false) is a</formula><p>consistent answer to Q in r, and we write r j = c Q (r 6 j = c Q), if for every repair r 0 of r, r 0 Q (r 0 2 Q). as the consistent answers to the query 9zCourse(S 1 ; y; z), posed to r 3 . For the query 9(u;v)(Student(u;N 1 ; v) Ĉourse(u;x;y)),</p><p>we obtain no (consistent) answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The General Approach</head><p>We present here a method to compute consistent answers to queries. Given a query Q, the query T ω (Q) is defined based on the notion of residue developed in the context of semantic query optimization (SQO) <ref type="bibr" target="#b2">[3]</ref>. In the context of deductive databases, SQO is used to optimize the process of answering queries using the semantic knowledge about the domain that is contained in the ICs. In this case, the basic assumption is that the ICs are satisfied by the database. In our case, since we allow inconsistent databases, we do not assume the satisfaction of the ICs while answering queries. A first attempt to obtain consistent answers to a query Q( x) may be to use query modification, i.e., ask the query Q( x) ^IC. However, this does not work, as we obtain false as the answer if the DB is inconsistent. Instead, we iteratively modify the query Q using the residues. As a result, we obtain the query T ω (Q) with the property that the set of all answers to T ω (Q) is the same as as the set of consistent answers to Q. (As shown later, the property holds only for restricted classes of queries and constraints.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Generating residues in relational DBs</head><p>We begin by transforming every integrity constraint to the standard format (expansion step).</p><formula xml:id="formula_10">Definition 7. An integrity constraint is in standard format if it has the form 8( m _ i=1 P i ( xi ) _ n _ i=1 :Q i ( ȳi ) _ψ);</formula><p>where 8 represents the universal closure of the formula, xi , ȳi are tuples of variables and ψ is a formula that mentions only built-in predicates, in particular, equality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Notice that in such an IC there are no constants in the P i ; Q i ; if they are needed they can be pushed into ψ.</p><p>Many usual ICs that appear in DBs can be transformed to the standard format, e.g. functional dependencies, set inclusion dependencies of the form 8x(P(x) Q( x)), transitivity constraints of the form 8x;y;z(P(x;y)P (y; z) P(x; z)). The usual ICs that appear in SQO in deductive databases as rules <ref type="bibr" target="#b2">[3]</ref> can be also accommodated in this format, including rules with disjunction and logical negation in their heads. An inclusion dependency of the form 8xP(x) 9y Q( x; y) cannot be transformed to the standard format.</p><p>After the expansion of IC, rules associated with the database schema are generated. This could be seen as considering an instance of the database as an extensional database expanded with new rules, and so obtaining an associated deductive database where semantical query optimization can be used.</p><p>For each predicate, its negative and positive occurrences in the ICs (in standard format) will be treated separately with the purpose of generating corresponding residues and rules. First, a motivating example.</p><p>Example 9. Consider the IC 8x (:P(x) _ Q(x)). If Q(x) is false, then :P(x) must be true. Then, when asking about :Q(x), we make sure that :P(x) becomes true.</p><p>That is, we generate the query :Q(x) ^:P(x) where :P(x) is the residue attached to the query.</p><p>2</p><p>For each IC in standard format</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8(</head><p>m</p><formula xml:id="formula_11">_ i=1 P i ( xi ) _ n _ i=1 :Q i ( ȳi ) _ψ);<label>(3)</label></formula><p>and each positive occurrence of a predicate P j ( x j ) in it, the following residue for :P j ( x j ) is generated</p><formula xml:id="formula_12">Q( j?1 _ i=1 P i ( xi ) _ m _ i= j+1 P i ( xi ) _ n _ i=1 :Q i ( ȳi ) _ψ); (<label>4</label></formula><formula xml:id="formula_13">)</formula><p>where Q is a sequence of universal quantifiers over all the variables in the formula not appearing in x j .</p><p>If R 1 ; : : : ; R r are all the residues for :P j , then the following rule is generated:</p><p>:P j ( w) 7 ?! :P j ( w)fR 1 ( w); : : : ; R r ( w)g;</p><p>where w are new variables. If there are no residues for :P j , then the rule :P j ( w) 7 ?! :P j ( w) is generated.</p><p>For each negative occurrence of a predicate Q j ( ȳ j ) in (3), the following residue for</p><formula xml:id="formula_14">Q j ( ȳ j ) is generated Q( m _ i=1 P i ( xi ) _ j?1 _ i=1 :Q i ( ȳi ) _ n _ i= j+1 :Q i ( ȳi ) _ψ);</formula><p>where Q is a sequence of universal quantifiers over all the variables in the formula not appearing in ȳ j .</p><p>If R 0 1 ; : : : ; R 0 s are all the residues for Q j ( ȳ j ), the following rule is generated:</p><formula xml:id="formula_15">Q j ( ū) 7 ?! Q j ( ū)fR 0 1 ( ū); : : : ; R 0 s ( ū)g:</formula><p>If there are no residues for Q j ( ȳ j ), then the rule</p><formula xml:id="formula_16">Q j ( ū) 7 ?! Q j ( ū) is generated.</formula><p>Notice that there is exactly one new rule for each positive predicate, and exactly one rule for each negative predicate.</p><p>If there are more than one positive (negative) occurrences of a predicate, say P, in an IC, then more then one residue is computed for :P. In some cases, e.g., for functional dependencies, the subsequent residues will be redundant. In other cases cases, e.g.,for transitivity constraints, multiple residues are not redundant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 10. If we have the following ICs in standard format</head><formula xml:id="formula_17">IC = f8x(R(x)_:P(x)_:Q(x));8x(P(x)_:Q(x))g;</formula><p>the following rules are generated:</p><formula xml:id="formula_18">P(x) 7 ?! P(x)fR(x) _:Q(x)g Q(x) 7 ?! Q(x)fR(x) _:P(x);P(x)g R(x) 7 ?! R(x) :P(x) 7 ?! :P(x)f:Q(x)g :Q(x) 7 ?! :Q(x)</formula><p>:R(x) 7 ?! :R(x)f:P(x)_:Q(x)g: 2</p><p>Notice that no rules are generated for built-in predicates, but such predicates may appear in the residues. They have fixed extensions and thus cannot contribute to the violation of an IC or be modified to make an IC true.</p><p>For example, if we have the IC 8x;y;z(:P(x;y)_:P(x;z)_y = z), and the database satisfies P(1; 2); P(1; 3), the IC cannot be made true by making 2 = 3.</p><p>Once the rules have been generated, it is possible to simplify the associated residues. In every new rule of the form P( ū) 7 ?! P( ū)fR 1 ( ū); : : : ; R r ( ū)g the auxiliary quantifications introduced in the expansion step are eliminated (both the quantifier and the associated variable in the formula) from the residues by the process inverse to the one applied in the expansion. The same is done with rules of the form :P 7 ?! :Pf g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Computing T ω (Q)</head><p>We assume all queries are in prefix disjunctive normal form.</p><formula xml:id="formula_19">Definition 8. A formula Q is a query if it has the following syntactical form: Q s _ i=1 ( m i ĵ=1 P i; j ( ūi; j ) ^ni ĵ=1 :Q i; j ( vi; j ) ^ψi );</formula><p>where Q is a sequence of quantifiers and ψ contains only built-in predicates. If Q contains only universal quantifiers, then we say that Q is a universal query. If Q contains existential (and possibly universal) quantifiers, we say that Q is non-universal query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>In order to determine consistent answers to queries in arbitrary databases, we will make use of a family of operators consisting of T n , n 0, and T ω . Definition 9. The application of an operator T n to a query is defined inductively by means of the following rules 1. T n (2) := 2, T n (:2) := :2, for every n 0 (2 is the empty clause).</p><p>2. T 0 (ϕ) := ϕ.</p><p>3. For each predicate P( ū), if there is a rule P( ū) 7 ?! P( ū)fR 1 ( ū); : : : ; R r ( ū)g, then T n+1 (P( ū)) := P( ū) ^r î=1</p><p>T n (R i ( ū)):</p><p>If P( ū) does not have residues, then T n+1 (P( ū)) := P( ū).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">For each negated predicate</head><formula xml:id="formula_20">:Q(v), if there is a rule :Q(v) 7 ?! :Q(v)fR 0 1 ( v); : : : ; R 0 s ( v)g, then T n+1 (:Q( v)) := :Q(v)^s î =1 T n (R 0 i ( v)):</formula><p>If :Q(v) does not have any residues, then T n+1 (:Q( ū)) := :Q(ū).</p><p>5. If ϕ is a formula in prenex disjunctive normal form, that is,</p><formula xml:id="formula_21">ϕ = Q s _ i=1 ( m i ĵ=1 P i; j ( ūi; j ) ^ni ĵ=1 :Q i; j ( vi; j ) ^ψi );</formula><p>where Q is a sequence of quantifiers and ψ i is a formula that includes only built-in predicates, then for every n 0: </p><formula xml:id="formula_22">T n (ϕ) := Q s _ i=1 ( m i ĵ=1 T n (P i; j ( ūi; j )) ni ĵ=1 T n (:Q i; j ( vi; j )) ^ψi ):</formula><formula xml:id="formula_23">(x))_:Q(x))g. 2</formula><p>We show first that the operator T ω conservatively extends standard query evaluation on consistent databases. Proposition 1. Given a database instance r and a set of integrity constraints IC, such that r IC, then for every query Q( x) and every natural number n: r 8x(Q(x)</p><formula xml:id="formula_24">T n (Q( x))).</formula><p>Corollary 1. Given a database instance r and a set of integrity constraints IC, such that r IC, then for every query Q( x) and every tuple t: r Q(t) if and only if r T ω (Q(t)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">4 Soundness</head><p>Now we will show the relationship between consistent answers to a query Q in a database instance r (definition 6) and answers to the query T ω (Q) (definition 5). We show that T ω (Q) returns only consistent answers to Q. Theorem 1. (Soundness) Let r be a database instance, IC a set of integrity constraints and Q( x) a query (see definition 8) such that r T ω (Q( x)) t]. If Q is universal or non-universal and domain independent <ref type="bibr" target="#b13">[14]</ref>, then t is a consistent answer to Q in r (in the sense of definition 6), that is, r j = c Q(t) .</p><p>The second condition in the theorem excludes nonuniversal, but domain dependent queries like 9x:P(x). The following rule is generated:</p><p>Class(z; w) 7 ?! Class(z; w) f8(x;y)(:Supply(x;y;z)_w 6 = T 4 _x = C)g:</p><p>Given the database instance r 1 that violates the IC as before, if we pose the query Class(z; T T ω (9zCourse(S 1 ; y; z)) = f9zCourse(S 1 ; y; z)g we obviously obtain the same answers which, in this case, are the consistent answers. Intuitively, in this case the T ω operator helps us to establish that even when the name of the student with number S 1 is undetermined, it is still possible to obtain the list of courses in which he/she is registered. On the other hand, if we pose the query 9(u;v)(Student(u;N 1 ; v) ^Course(u;x;y)),</p><p>about the courses and grades for a student with name N 1 , to r 3 , we obtain (C 1 ; G 1 ) and (C 2 ; G 2 ). Nevertheless, if we ask T ω (9(u; v)(Student(u; N 1 ; v) ^Course(u;x;y))),</p><p>we obtain, in conjunction with the original query, the formula:</p><p>9(u;v)(Student(u;N 1 ; v) 8(y 0 ; z 0 )(:Student(u; y 0 ; z 0 ) _y 0 = N 1 ) 8(y 0 ; z 0 )(:Student(u; y 0 ; z 0 ) _z 0 = v) ^Course(u;x;y)); from this we obtain the empty set of tuples. This answer is intuitively consistent, because the number of the student with name N 1 is uncertain, and in consequence it is not possible to find out in which courses he/she is registered. The set of answers obtained with the T ω operator coincides with the set of consistent answers which is empty. where l 1 and l 2 are literals, and ψ is a formula that only contains built-in predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Examples of BICs include: functional dependencies, symmetry constraints, set inclusions dependencies of the form 8x(P(x) Q( x)). Definition 12. Given a set of sentences Σ in the language of the database schema DB, and a sentence ϕ, we denote by Σ DB ϕ the fact that, for every instance r of the database, if r Σ, then r ϕ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Theorem 2. (Completeness for BICs) Given a set IC of binary integrity constraints, if for every literal l 0 ( ā), IC 2 DB l 0 ( ā), then the operator T ω is complete, that is, for every ground literal l(t), if r c l(t) then r T ω (l(t)). 2</p><p>The theorem says that every consistent answer to a query of the form l( x) is captured by the T ω operator. Actually, proposition 2 in the appendix and the completeness theorem can be easily extended to the case of queries that are conjunctions of literals. Notice that the finiteness T ω (l( x)) is not a part of the hypothesis in this theorem.</p><p>Example 14. We can see in the example 12 where BICs and queries which are conjunctions of literals appear, that the operator T ω gave us all the consistent answers, as implied by the theorem. then the operator T ω is complete for consistent answers to queries that are conjunctions of literals. Example 15. In example 13 we had FDs that are also BICs. Thus the operator T ω found all the consistent answers, even for some queries that are not conjunctions of literals, showing that this is not a necessary condition.</p><p>Example 16. Here we will show that in general completeness is not obtained for queries that are not conjunctions of literals. Consider the IC: 8x;y;z(P(x;y) P(x;z) y = z) and the inconsistent instance r with Σ(r) = fP(a;b);P(a;c)g. This database has two repairs: r 0 with Σ(r 0 ) = fP(a;b)g; and r 00 with Σ(r 00 ) = fP(a;c)g.</p><p>We have that r j = c 9xP(a;x), because the query is true in the two repairs. Now, it is easy to see that T ω (9uP(a; u)) is logically equivalent to 9u(P(a;u) ^8z(:P(a;z) _ z = u)). So, we have r 6 j = T ω (9xP(a; x)). Thus, the consistent answer true is not captured by the operator T ω .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Other Constraints</head><p>The following theorem applies to arbitrary ICs.</p><p>Theorem 3. (Completeness) Let IC be a set of integrity constraints, l( x) a literal, and T n (l( x)) of the form</p><formula xml:id="formula_25">l( x) ^m î =1 8(x i ; ȳi )(C i ( x; xi ) _ψ i ( x; ȳi )):</formula><p>If for every n 0, there is S f1;::: ; mg such that (1) for every j 2 S and every tuple ā: IC 2 C j ( ā), and (2) </p><formula xml:id="formula_26">f8(x i ; ȳi )(C i ( x; xi ) _ ψ i ( x; ȳi ))ji 2 Sg f8(x i ; ȳi )(C i ( x; xi ) _ ψ i ( x; ȳi ))j1 i mg; then r c l(t) implies r T ω (l(t )).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>This theorem can be extended to conjunctions of literals. Notice that the theorem requires a condition for every n 2 N. Its application is obviously simplified if we know that the iteration terminates. This is an issue to be analyzed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Termination</head><p>Termination means that the operator T ω returns a finite set of formulas. It is clearly important because then the set of consistent answers can be computed by evaluating a single, finite query. We distinguish between three different notions of termination. Definition 13. Given a set of ICs and a query Q( x), we say that T ω (Q( x)) is 1. syntactically finite if there is an an n such that T n (Q( x)) and T n+1 (Q( x)) are syntactically the same.</p><p>2. semantically finite if there is an n such that for all m n, 8x(T n (Q( x) T m (Q( x)) is valid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">semantically finite in an instance r, if there is an n</head><p>such that for all m n, r j = 8x (T n (Q( x) T m (Q( x)). 2</p><p>The number n in cases 2 and 3 is called a point of finiteness. It is clear that 1 implies 2 and 2 implies 3. In the full version we will show that all these implications are proper. In all these cases, evaluating T ω (Q( x) gives the same result as evaluating T n (Q( x) for some n (in the instance r in case 3). If T ω (Q( x) is semantically finite, sound and complete, then the set of consistent answers to Q is first-order definable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Syntactical finiteness</head><p>The notion of syntactical finiteness is important because then for some n and all m &gt; n, T m (Q( x)) will be exactly the same. In consequence, T ω (Q) will be a finite set of formulas. In addition, a point of finiteness n can be detected (if it exists) by syntactically comparing every two consecutive steps in the iteration. No simplification rules need to be considered, because the iterative procedure is fully deterministic.</p><p>Here we introduce a necessary and sufficient condition for syntactical finiteness. Definition 14. A set of integrity constraints IC is acyclic if there exists a function f from predicate names plus negations of predicate names in the database to the natural numbers, that is, f : fp 1 ; : : : ; p n ; :p 1 ; : : : ; :p n g ?! N, such that for every integrity constraint 8( W k i=1 l i ( xi ) _ ψ( x)) 2 IC as in (3), and every i and j (1 i; j k), if i 6 = j, then f (:l i ) &gt; f (l j ). (Here :l i is the literal complementary to l i .)</p><p>Example 17. The set of ICs IC = f8x(:P(x)_:Q(x)_S(x)); 8(x;y)(:Q(x)_:S(y)_T(x;y))g:</p><p>is acyclic, because the function f defined by</p><formula xml:id="formula_27">f (P) = 2 f (Q) = 2 f (:P) = 0 f (:Q) = 0 f (S) = 1 f (T ) = 0 f (:S) = 1 f (:T ) = 2</formula><p>, satisfies the condition of definition 14.</p><p>Example 18. The set of ICs IC = f8x(:P(x)_:Q(x)_S(x)); 8(x;y)(Q(x)_:S(y)_T(x;y))g:</p><p>is not acyclic, because for any function f that we may attempt to use to satisfy the condition in definition 14, from the first integrity constraint we obtain f (Q) &gt; f (S), and from the second, we would obtain f (S) &gt; f (Q); a contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.</head><p>A set of integrity constraints IC is acyclic iff for every literal name l in the database schema, T ω (l( x)) is syntactically finite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>The theorem can be extended to any class of queries satisfying Definition 8.</p><p>Example 19. The set of integrity constraints in example 18 is not acyclic. In that case T ω (Q(x)) is infinite.</p><p>Example 20. The ICs in example 17 are acyclic. There we have T ω (P(u)) = fP(u); P(u) ^(:Q(u)_S(u));</p><formula xml:id="formula_28">P(u) ^(:Q(u)_S(u)^8v(:Q(v)_T(v;u)))g T ω (Q(u)) = fQ(u); Q(u) ^(:P(u)_S(u))^8v(:S(v)_T(u;v)); Q(u) ^(:P(u)_S(u)^8w(:Q(w)_T(w;u)))8 v(:S(v) ^(:P(v)_:Q(v))_T(u;v))g T ω (S(u)) = fS(u);S(u)^8(:Q(v)_T(v;u))g T ω (T (u; v)) = fT(u;v)g</formula><p>T ω (:P(u)) = f:P(u)g</p><p>T ω (:Q(u)) = f:Q(u)g</p><p>T ω (:S(u)) = f:S(u);:S(u)^(:P(u)_:Q(u))g</p><formula xml:id="formula_29">T ω (:T (u; v)) = f:T(u;v); :T(u;v)^(:Q(u)_:S(v)); :T(u;v)^(:Q(u)_:S(v)^(:P(v)_:Q(v)))g: Corollary 3.</formula><p>For functional dependencies and a query Q( x), T ω (Q( x)) is always syntactically finite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Semantical finiteness</head><p>Definition 15. A constraint C in clausal form is uniform if for every literal l( x) in it, the set of variables in l( x) is the same as the set of variables in C ?l(x). A set of constraints is uniform if all the constraints in it are uniform.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Examples of uniform constraints include set inclusion dependencies of the form 8x(P(x) Q( x)), e.g., Example 4.</p><p>Theorem 5. If a set of integrity constraints IC is uniform, then for every literal name l in the database schema, T ω (l( x)) is semantically finite. Furthermore, a point of finiteness n can be bounded from above by a function of the number of variables in the query, and the number of predicates (and their arities) in the query and IC.</p><p>2 Theorem 6. Let l be a literal name. If for some n, 8x(T n (l( x)) T n+1 (l( x)) is valid, then for all m n, 8x(T n (l( x)) T m (l( x)) is valid. 2</p><p>According to Theorem 6, we can detect a point of finiteness by comparing every two consecutive steps wrt logical implication. Although this is undecidable in general, we might try to apply semidecision procedures, for example, automated theorem proving. We have successfully made use of OTTER <ref type="bibr" target="#b10">[11]</ref> in some cases that involve sets of constraints that are neither acyclic nor uniform. Examples include multivalued dependencies, and functional dependencies together with set inclusion dependencies. For multivalued dependencies, Theorem 6 together with Theorem 3 gives completeness of T ω (l( x)). The criterion from Theorem 6 is also applicable to uniform constraints by providing potentially faster termination detection than the proof of Theorem 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Instance based semantical finiteness</head><p>Theorem 7. If Q( x) is a domain independent query, then for every database instance r there is an n, such that for</p><formula xml:id="formula_30">all m n, r j = 8x(T n (Q( x)) T m (Q( x))).</formula><p>2</p><p>Notice that this theorem does not include the case of negative literals, as in the case of theorem 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>Bry <ref type="bibr" target="#b1">[2]</ref> was, to our knowledge, the first author to consider the notion of consistent query answer in inconsistent databases. His definition is very general and applies not only to relational but also to deductive and object-oriented databases. However, Bry's approach is entirely prooftheoretic and does not address the issues of semantics, soundness and completeness. No computational mechanism to obtain consistent answers is given, not even a proof procedure.</p><p>The issue of inconsistent data arising in data integration has been widely recognized. A typical (theoretical) solution is to augment the data model to represent disjunctive information. For example, <ref type="bibr" target="#b0">[1]</ref> introduce the notion of flexible relation, a non-1NF relation that contains tuples with sets of non-key values. This approach is limited to key functional dependencies. In the same context, <ref type="bibr" target="#b6">[7]</ref> propose to use disjunctive Datalog and <ref type="bibr" target="#b9">[10]</ref> tables with OR-objects.</p><p>Reasoning in the presence of inconsistency has been an important research problem in the area of knowledge representation. The goal is to design logical formalisms that limit what can be inferred from an inconsistent set of formulas. One does not want to infer all formulas (as required by the classical two-valued logic). Moreover, one prefers not to infer a formula together with its negation. The formalisms satisfying the above properties, e.g., <ref type="bibr" target="#b8">[9]</ref>, are usually propositional. Moreover, they do not distinguish between integrity constraints and database facts. Thus, if the data in the database violates an integrity constraint, the constraint itself can no longer be inferred (which is not acceptable in the database context).</p><p>Example 21. Assume the integrity constraint is :(p q)</p><p>and the database contains the facts p and q. In the approach of <ref type="bibr" target="#b8">[9]</ref>, p _q can be inferred (minimal change is captured correctly) but p, q and :(p^q) can no longer be inferred (they are all involved in an inconsistency). Because of the above-mentioned limitations, such methods are not directly applicable to the problem of computing consistent query answers. Deontic logic <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b7">8]</ref>, a modal logic with operators capturing permission and obligation, has been used for the specification of integrity constraints. <ref type="bibr" target="#b7">[8]</ref> uses the obligation operator O to distinguish integrity constraints that have to hold always from database facts that just happen to hold. <ref type="bibr" target="#b11">[12]</ref> use deontic operators to describe policies whose violations can then be caught and handled. The issues of possible repairs of constraint violations, their minimality and consistent query answers are not adressed.</p><p>Gertz <ref type="bibr" target="#b5">[6]</ref> describes techniques and algorithms for computing repairs of constraint violations. The issue of query answering in the presence of an inconsistency is not addressed in his work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions and Further Work</head><p>This paper represents a first step in the development of a new research area dealing with the theory and applications of consistent query answers in arbitrary, consistent or inconsistent, databases.</p><p>The theoretical results presented here are preliminary. While we have proved a general soundness result, the results about completeness and termination are still partial. Also, one needs to look beyond purely universal constraints to include general inclusion dependencies. In a forthcoming paper we will also describe our methodology for using automated theorem proving, in particular, OTTER, for proving termination.</p><p>It appears that in order to obtain completeness for disjunctive and existentially quantified queries one needs to move beyond the T ω operator on queries. Also, the upper bounds on the size of T ω and the lower bounds on the complexity of computing consistent answers for different classes of queries and constraints need to be studied.</p><p>There is an interesting connection to modal logic. Consider the definition 6. We could write r j = 2Q(t), meaning that Q(t) is true in all repairs of r, the database instances that are "accessible" from r. This is even more evident from example 16, where, in essence, it is shown that 29xQ(x) is not logically equivalent to 9x2Q(x), which is what usually happens in modal logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proofs of Results</head><p>Lemma 1. If r T ω (l( ā)), where l( ā) is a ground literal, then for every repair r 0 of r, it holds r 0 l( ā).</p><p>Proof: By contradiction, assume that there is a repair r 0 of r such that r 0 2 l( ā).</p><p>Define a sequence of sets of ground literals: This structure has the following properties:</p><formula xml:id="formula_31">Σ 0 := fl( ā)g, Σ n+1 := fl 0 ( b)jr T ω (l 0 ( b))</formula><p>(I) r is a database instance. For this we only need to prove that r satisfies only a finite number of positive ground literals. By its definition, r can be obtained adding to r 0 the positives literals in Σ ω and removing from r 0 the negatives literals in Σ ω . But r Σ ω , thus in Σ ω there is a finite number of positive literals. Therefore, we added to r 0 a finite number of positives literals to obtain r , thus r is a database instance.</p><p>(II) ∆(r; r ) &amp; ∆(r; r 0 ) 1. First, we prove that ∆(r; r ) ∆(r; r 0 ). Let p( ā) 2 ∆(r; r ). We have to consider two cases.</p><p>(a) If r p( ā) and r :p(ā), then p( ā) = 2 Σ ω (since if p( ā) 2 Σ ω , then r p( ā)) and :p( ā) = 2 Σ ω (since r Σ ω ). Therefore, r p( ā) if and only if r 0 p( ā). Thus r 0 :p(ā) and p( ā) 2 ∆(r; r 0 ). (b) If r :p( ā) and r p( ā), then as in the previous case, we conclude that p( ā) 2 ∆(r; r 0 ).</p><p>2. If l( ā) is p( ā) or l( ā) is :p( ā), we have that p( ā) = 2 ∆(r; r ) and p( ā) 2 ∆(r; r 0 ), therefore using 1 we conclude that ∆(r; r ) &amp; ∆(r; r 0 ).</p><p>(III) r IC. Let IC D be the set constructed as follows:</p><p>for every integrity constraint 8( W m i=1 l i ( xi ) _ ψ( x)) in IC, instantiate it on the domain of a database obtaining</p><formula xml:id="formula_32">formulas of the form W m i=1 l i ( āi ) _ ψ( ā). If r :ψ(ā), then include W m i=1 l i ( āi ) in IC D . (III.I) If l 0 ( b) 2 Σ ω , then for every element in IC D of the form :l 0 ( b) _ W m i=1 l i ( b; āi ), it</formula><p>holds m 1 and l j ( ā j ) 2 Σ ω , for some 1 j m. This is saying that m cannot be 0, in other words, :l 0 ( b) cannot appear isolated.</p><p>1. First we prove that m 1. Assume that m = 0. Then, :l 0 ( b) 2 IC D . One of the following cases must be true:</p><p>(a) 8x:l 0 ( x) 2 IC. In this case T 1 (l 0 ( x)) = l 0 ( x)</p><p>2.</p><formula xml:id="formula_33">Thus T 1 (l 0 ( b)) = l 0 ( b) ^2. Therefore, r 2 T 1 (l 0 ( b)). A contradiction, because r T ω (l 0 ( b)).</formula><p>(b) 8(x; ȳ)(:l 0 ( x) _ψ(x; ȳ)) 2 IC, where ψ( x; ȳ) is a formula that only mentions built-in predicates. Thus T 1 (l 0 ( x)) = l 0 ( x) ^8ȳψ(x; ȳ). 2. Now, we prove that there exists l j ( b; ā j ) 2 Σ ω . First, notice that for k 1, T k (l 0 ( x)) is of the form: In consequence, for all k ?1 0,</p><formula xml:id="formula_34">l 0 ( x) ^8( m _ i=1 l i ( x; xi ) ^Tk?1 (l i ( x; xi )) _ ψ( x; ȳ)) ^θ(x):</formula><formula xml:id="formula_35">r m _ i=1 l i ( b; āi ) ^Tk?1 (l i ( b; āi ));<label>(6)</label></formula><p>But, we know that, for every sentence α, if r 2 T s (α), then r 2 T s+1 (α). Thus, by <ref type="bibr" target="#b5">(6)</ref>, there exists j (1 j m) such that r T k?1 (l j ( b; ā j )) for all k ?1 0. Therefore r T ω (l j ( b; ā j )). We conclude that l j ( b; ā j ) 2 Σ ω because l j ( b; ā j ) 2 Σ n+1 . Now, we prove that r IC D . Let θ be the formula W k i=1 l i ( āi ) 2 IC D . We need to consider three cases:</p><p>1. If l j ( ā j ) 2 Σ ω for some j (1 j k), then r l j ( ā j ).</p><p>Thus, r θ.</p><p>2. If :l j ( ā j ) 2 Σ ω , then by (III.I) there exists l i ( āi ) 2</p><p>Σ ω , for some 1 i k. Thus r θ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">If for every</head><formula xml:id="formula_36">i (1 i m), l i ( āi ) = 2 Σ ω and :l i ( āi ) = 2</formula><p>Σ ω , then for every m (1 i m), r 0 l i ( āi ) iff r l i ( āi ). Therefore, r 0 θ iff r θ. But r 0 IC and θ 2 IC D , so we have that r 0 θ. We conclude that r θ.</p><p>Finally, we obtain that r IC, because r IC D . We have a contradiction, because by (I), (II) and (III), we conclude that r 0 is not a repair of r, because r j = IC and ∆(r; r ) (</p><formula xml:id="formula_37">∆(r; r 0 ). Lemma 2. If r T ω ( V n i=1 l i ( āi ))</formula><p>, where l i ( āi ) is a ground literal, then for every repair r 0 of r, it holds r 0 V n i=1 l i ( āi ).</p><p>Proof:</p><formula xml:id="formula_38">If r T ω ( V n i=1 l i ( āi )), then, for every k 0, r T k ( V n i=1 l i ( āi )). But T k ( V n i=1 l i ( āi )) = V n i=1 T k (l i ( āi )).</formula><p>Therefore, for every i and k 0, r T k (l i ( āi )). Thus, for every i, r T ω (l i ( āi )). By lemma 1, for every repair r 0 of r, r 0 l i ( āi ). Then, we conclude that r 0 V n i=1 l i ( āi ). Lemma 3. If r T ω ( W n i=1 C i ( āi )), with C i ( āi ) a conjunction of literals, then for every repair r 0 of r, r 0</p><formula xml:id="formula_39">W n i=1 C i ( āi ). Proof: If r T ω ( W n i=1 C i ( āi )), then for every k 0, r T k ( W n i=1 C i ( āi )). We know that T k ( W n i=1 C i ( āi )) = W n i=1 T k (C i ( āi ))</formula><p>, and that for every sentence α, if r 6 T s (α), then r 6 T s+1 (α). In consequence, there exists j (0 j k), such that, for all k 0, r T k (C j ( ā j )). Therefore r T ω (C j ( ā j )). By lemma 2 we have that for every repair r 0 of r, r 0 C j ( ā j ). We conclude that</p><formula xml:id="formula_40">r 0 W n i=1 C j ( ā j ). Lemma 4. Let Q( x) a universal query. If r T ω (Q(t)),</formula><p>for a ground tuple t, then for every repair r 0 of r, r 0 Q(t).</p><p>Proof: By induction on the number of universal quantifiers in Q( x). If Q( x) has zero quantifiers, then by lemma 3, r 0 Q(t). Assume that the property is valid for ev- ery universal query with n quantifiers, and suppose that Q( x) has n + 1 universal quantifiers. Then, Q( x) is of the form 8xQ 0 (x; x). If r T ω (Q(t)), then, for every k 0, r T k (8xQ 0 (x; t)). But T k (8xQ 0 (x; t)) = 8xT k (Q 0 (x; t)), thus r 8xT k (Q 0 (x; t)). In consequence, for every element a in the domain of the database, r T k (Q 0 (a; t)), for every k 0. Thus, for every element a in the database domain, r T ω (Q 0 (a; t)). By induction hypothesis we ob- tain that, for every repair r 0 of r and every element a in the database domain, r 0 Q 0 (a; t). Therefore, for every repair r 0 of r, r 0 Q(t). Lemma 5. Let Q( x) a domain independent query. If r T ω (Q(t)), for a ground tuple t, then for every repair r 0 of r, r 0 Q(t).</p><p>Proof: By induction on the number of quantifiers in Q( x).</p><p>If Q( x) has zero quantifiers, then by lemma 3, r 0 Q(t).</p><p>Assume that the property is valid for every domain independent query with n quantifiers, and assume that Q( x) has n + 1 quantifiers. We need to consider two cases:</p><formula xml:id="formula_41">1. Q( x) is of the form 8xQ 0 (x; x). If r T ω (Q(t)),</formula><p>then, for every k 0, r T k (8xQ 0 (x; t)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>But</head><p>T k (8xQ 0 (x; t)) = 8xT k (Q 0 (x; t)), then r 8xT k (Q 0 (x; t)). Therefore, for every element a in the domain of the database, r T k (Q 0 (a; t)), for every k 0. Thus for every element a in the database domain, r T ω (Q 0 (a; t)). By induction hypothesis we conclude that for every repair r 0 of r and every element a in the database domain, r 0 Q 0 (a; t). In consequence, for every repair r 0 of r, r 0 Q(t).</p><p>2. Q( x) is of the form 9xQ 0 (x; x). If Q( x) is a domain independent query then is possible to replace the existential quantifier by a finite disjunction of the form W a2dom(Q) . Thus, we have that r T ω ( W a2dom(Q) Q 0 (a; t)). Then, for every k 0, r</p><formula xml:id="formula_42">T k ( W a2dom(Q) Q 0 (a; t)). But T k ( W a2dom(Q) Q 0 (a; t)) = W a2dom(Q) T k (Q 0 (a; t)</formula><p>), and we know that for every sentence α, if r 2 T s (α), then r 2 T s+1 (α). We conclude that there exists b 2 dom(Q), such that, for every k 0, r T k (Q 0 (b; t)). Therefore, r T ω (Q 0 (b; t)). By induction hypothesis, for every re- pair r 0 of r, we obtain that r 0 Q 0 (b; t). Thus, for every repair r 0 of r, r 0 9xQ 0 (x; t).</p><p>Proof of Theorem 1: Lemmas 4 and 5.</p><p>Proposition 2. Given a set IC of integrity constraints, a ground clause W m i=1 l i (t i ), if IC 2 DB W m i=1 l i (t i ) and, for every repair r 0 of r, r 0 W m i=1 l i (t i ), then r W m i=1 l i (t i ). 2 Proof of Proposition 2: Assume that r : W m i=1 l i (t i ). By hypothesis IC 2 DB W m i=1 l i (t i ), thus there exists an instance of the database r 0 such that r 0 IC f: W m i=1 l i (t i )g. Let us consider the set of database instances R = fr jr IC and ∆(r; r ) ∆(r; r 0 )g: We know that ∆(r; r 0 ) is finite, therefore there exists r 0 2 R such that ∆(r; r 0 ) is minimal. Then, r 0 is a repair of r.</p><p>For every 1 i m, if l i (t i ) is p(t) or :p(t), then p(t) = 2 ∆(r; r 0 ). Using this fact we conclude that p(t) = 2 ∆(r; r 0 ), Therefore, r W m i=1 l i (t i ) if and only if r 0 W m i=1 l i (t i ). But we assumed that r : W m i=1 l i (t i ), then r 0 : W m i=1 l i (t i ); a contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 2:</head><p>From the theorem 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Corollary 2:</head><p>In this case it holds:</p><p>1. For every tuple ā, IC 2 DB P i ( ā), because the empty database instance (which has only empty base relations) satisfies IC, but not P( ā).</p><p>2. For every tuple ā, IC 2 DB :P i ( ā), since the database instance r i ā, where the relation P i contains only the tuple ā and the other relations are empty, satisfies IC, but not :P i ( ā).</p><p>Proof of Theorem 3: Suppose that r c l(t). Let r 0 a repair of r, we have that r 0 l(t). By proposition 1 we have that r 0 T n (l(t)), that is</p><formula xml:id="formula_43">r 0 l(t) ^m î=1 8( m i _ j=1 l i; j (t; xi; j ) _ψ i (t; xi ));<label>(7)</label></formula><p>We want to prove that for every i and for every sequence of ground tuples a i , a i;1 , : : : , a i;m i : r m i _ j=1 l i; j (t; āi; j ) _ψ i (t; āi ); <ref type="bibr" target="#b7">(8)</ref> To do this, first we are going to prove that for every i 2 S and for every sequence of ground tuples a i , a i;1 , : : : , a i;m i : r m i _ j=1 l i; j (t; āi; j ) _ψ i (t; āi ); <ref type="bibr" target="#b8">(9)</ref> This is immediately obtained when r ψ i (t; āi ). Assume that r :ψ i (t; āi ). We know that ψ i only mentions built-in predicates, thus for every repair r 0 of r we have that r 0 :ψ i (t; āi ). Therefore, by <ref type="bibr" target="#b6">(7)</ref> we conclude that for every repair r 0 of r: r 0 m i _ j=1 l i; j (t; āi; j ) _ψ i (t; āi ); By proposition 2 we conclude <ref type="bibr" target="#b8">(9)</ref> Proof of Theorem 4: (=)) Suppose that IC is acyclic, then there exists f as in the definition 14. We are going to prove by induction on k that for every literal name l, if</p><formula xml:id="formula_44">f (l) = k, then T k+1 (l( x)) = T k+2 (l( x)) (I) If k = 0.</formula><p>We know that that for every literal name l 0 , f (l 0 ) 0. Therefore, every integrity constraint containing :l is of the form 8(:l(x) _ ψ( ȳ)), where ψ only mentions built-in predicates. This is because if there were any other literal l 0 in the integrity constraint, we would have f (l 0 ) &lt; f (l) = 0. Then T 1 (l( x)) = T 2 (l( x)).</p><p>(II) Suppose that the property is true for every m &lt; k. We know that T k+2 (l( x)) is of the form:</p><formula xml:id="formula_45">l( x) ^m î =1 Qi ( m i _ j=1</formula><p>T k+1 (l i; j ( xi; j )) _ψ i ( xi ));</p><p>where Qi is a sequence of quantifiers over all the variables xi;1 , : : : , xi;m i , xi not appearing in x, and T k+1 (l( x)) is of the form:</p><formula xml:id="formula_46">l( x) ^m î =1 Qi ( m i _ j=1</formula><p>T k (l i; j ( xi; j )) _ψ i ( xi )):</p><p>By definition of f , we know that for every literal name l i; j in the previous formulas, f (l i; j ) &lt; k. Then by induction hypothesis T k (l( xi; j )) = T k+1 (l i; j ( xi; j ))</p><p>(since if T m (l 0 ( x)) = T m+1 (l 0 ( x)), then for every n m, T n (l 0 ( x)) = T n+1 (l 0 ( x))).</p><p>((=) Suppose that for every literal name l, T ω (l( x)) is finite. The for every literal name l there exists a first natural number k such that T k (l( x)) = T k+1 (l( x)). Let us define a function f , from the literal names into the natural number, by f (l) = k (k as before). We can show that this is a well defined function that behaves as in definition T f (:l s )?1 (l i ( xi )) _ψ(ȳ))^θ(x s ); <ref type="bibr" target="#b9">(10)</ref> where Q is a sequence of quantifiers over all the variables x1 , : : : , xm , ȳ, not appearing in xs , and T f (:l s )+1 (:l s ( xs )) is of the form :l s ( xs ) ^Q(</p><formula xml:id="formula_47">s?1 _ i=1 T f (:l s ) (l i ( xi )) _ m _ i=s+1</formula><p>T f (:l s ) (l i ( xi )) _ψ(ȳ))^θ 0 ( xs ): <ref type="bibr" target="#b10">(11)</ref> By definition of f , T f (:l s ) (:l s ( xs )) = T f (:l s )+1 (:l s ( xs )).</p><p>Then, by the form of ( <ref type="formula">10</ref>) and ( <ref type="formula">11</ref>), we conclude that for every i 6 = s, T f (:l s )?1 (l i ( xi )) = T :f(l s ) (l i ( xi )), and then, again by definition of f , f (l i ) &lt; f (:l s ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Corollary 3:</head><p>The following stratification function from literals to N can be defined: f (:P i ) = 0 and Proof: From the definition of T n+1 .</p><formula xml:id="formula_48">f (P j ) =</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7.</head><p>If for a ground tuple ā, T n (l( ā)) 8( W k j=1 l 0 j ( ā; z j )), then T n+1 (l( ā))</p><p>8( W k j=1 T 1 (l 0 j ( ā; z j ))).</p><p>Proof of Theorem 6: Suppose that for a natural number n, 8x(T n (l( x)) T n+1 (l( x))) is a valid sentence. We are going to prove that for every m n, 8x(T m (l( x)) T m+1 (l( x))) is a valid sentence, by induction on m.</p><p>(I) If m = n, by hypothesis.</p><p>(II) Suppose that 8x(T m (l( x)) T m+1 (l( x))) is a valid sentence. Then for every clause W k j=1 l 0 j ( x; z j ) _ ψ( x; z) in T m+1 (l( x)) and for every ground tuple ā we have that T m (l( ā)) 8( W k j=1 l 0 j ( ā; z j ) _ ψ( ā; z)). By lemma 7 and considering that ψ only mentions built-in predicates we have that T m+1 (l( ā)) 8( W k j=1 T 1 (l 0 j ( ā; z j )) _ ψ( ā; z)), and from this and lemma 6 we conclude that 8x(T m+1 (l( x)) T m+2 (l( x))) is a valid sentence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 5:</head><p>For uniform constraints the residues do not contain quantifiers. Therefore T n (l( x)) for every n 0 is quantifier-free and contains only the variables that occur in x. There are only finitely many inequivalent formulas with this property, and thus T ω (l( x)) is finite.</p><p>Proof of Theorem 7: Let Q( x) be a domain independent query and r a database instance. Define A n = ft j r T n (Q(t))g. We know that for every n: A n+1 A n , therefore A = fA i j i &lt; ωg is a family of subsets of A 0 . But A 0 is finite because Q( x) is a domain independent query. Thus, there exists a minimal element A m in A. For this element, it holds that for every k m: A m = A k , since A k A m .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 6 .Example 7 .Example 8 .</head><label>678</label><figDesc>(example 3 continued) The only consistent answer to the query Class(z; T 4 ), posed to the database instance r 1 , is I 1 because r 1 j = c Class(z; T 4 ) I 1 ]. (example 4 continued) The only consistent answer to the query Supply(C; D 1 ; z), posed to the database instance r 2 , is I 3 because r 2 j = c Supply(C; D 1 ; z) I 3 ]. (example 5 continued) By considering all the repairs of the database instance r 3 , we obtain C 1 and C 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 Definition 10 . 2 Example 11 .</head><label>210211</label><figDesc>The application of operator T ω on a query is defined as T ω (ϕ) = n&lt;ω fT n (ϕ)g. (example 10 continued) For the query :R(x) we have T 1 (:R(x)) = :R(x) ^(:P(x) _ :Q(x)), T 2 (:R(x)) = :R(x) ^((:P(x) ^:Q(x)) _ :Q(x)) and T 3 (:R(x)) = T 2 (:R(x)). We have reached a fixed point and then T ω (:R(x)) = f:R(x);:R(x) ^(:P(x) _ :Q(x));:R(x)^((:P(x)^:Q</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 12 .</head><label>12</label><figDesc>(example 6 continued) The IC (1) transformed into the standard format becomes 8(x;y;z;w)(:Supply(x;y;z)_ :Class(z;w)_w 6 = T 4 _x = C):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>11 .</head><label>11</label><figDesc>A binary integrity constraint (BIC) is a sentence of the form 8(l 1 ( x1 ) _l 2 ( x2 ) _ψ(x));</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Corollary 2 .</head><label>2</label><figDesc>If IC is a set of functional dependencies (FDs) IC = f8(:P 1 ( x1 ; y 1 ) _:P 1 ( x1 ; z 1 ) _y 1 = z 1 ); (5) : : : ; 8(:P n ( xn ; y n ) _:P n ( xn ; z n ) _y n = z n )g;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>and there exists a literal l ( c) 2 Σ n , such that l 0 ( b) appears in one of the residues of l ( c) when they are instantiated on the domain of the databaseg, and finally Σ ω := n&lt;ω Σ n . Now define a new structure r as follows: For a base predicate p, if p( c) 2 Σ ω or :p(c) 2 Σ ω , then r p( c) iff r p( c). If p( c) = 2 Σ ω and :p(c) = 2 Σ ω , then r p( c) iff r 0 p( c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Therefore, T 1 (l 0 ( b)) = l 0 ( b) ^8ȳψ( b; ȳ). But r T 1 (l 0 ( b)), thus r 8ȳψ( b; ȳ). Then, we have that, for every tuple c, r ψ( b; c). Thus, for every formula :l 0 ( b) _ψ( b; c) we have that ψ( b; c) is true in r; in consequence, by (a) and the definition of IC D , :l 0 ( b) = 2 IC D ; a contradiction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Therefore, T k (l 0 ( b)) is of the form l 0 ( b) ^8( m _ i=1 l i ( b; xi ) ^Tk?1 (l i ( b; xi )) _ ψ( b; ȳ)) ^θ( b):But r T ω (l 0 ( b)), and then r T k (l 0 ( b)) for all k 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>14 :</head><label>14</label><figDesc>since if 8( W m i=1 l i ( xi ) _ ψ( ȳ)) 2 IC, then for every 1 s m, T f (:l s ) (:l s ( xs )) is of the form :l s ( xs ) ^Q( s?1 _ i=1 T f (:l s )?1 (l i ( xi )) _ m _ i=s+1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>2.2 Consistent query answers</head><label></label><figDesc></figDesc><table><row><cell>Definition 5. (Query answer) A (ground) tuple t is an answer to a query Q( x) in a database instance r if r j =</cell></row><row><cell>Q(t). A (ground) tuple t is an answer to a set of queries fQ 1 ; : : : ; Q n g if r j = Q 1 ^ ^Qn .</cell></row><row><cell>Definition 6. (Consistent answer) Given a set of integrity</cell></row><row><cell>constraints, we say that a (ground) tuple t is a consistent</cell></row><row><cell>answer to a query Q( x) in a database instance r, and we</cell></row><row><cell>write r</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc><ref type="bibr" target="#b3">4 )</ref>, asking for the items of class T 4 , directly to r 1 , we obtain I 1 and I 2 . Nevertheless, if we pose the query T ω (Class(z; T 4 )), that is</figDesc><table><row><cell>fClass(z;T 4 ); Class(z; T 4 ) ^8(x;y)(:Supply(x;y;z)_x</cell></row></table><note><p><p><p>= C)g we obtain only I 1 , eliminating I 2 . I 1 is the only consistent answer. Example 13. (example 8 continued) In the standard format, the ICs take the form 8(x;y;z;u;v)(:Student(x;y;z)_ :Student(x;u;v)_y = u); 8(x;y;z;u;v)(:Student(x;y;z)_ :Student(x;u;v)_z = v):</p>The following rule is generated Student(x; y; z) 7 ?! Student(x; y; z) f8(u;v)(:Student(x;u;v)_y = u); 8(u;v)(:Student(x;u;v)_z = v)g:</p>Given the inconsistent database instance r 3 , if we pose the query 9zCourse(S 1 ; y; z), asking for the names of the courses of the student with number S 1 , we obtain C 1 and C 2 . If we pose the query</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1, where P i ; P j are relation names.</figDesc><table><row><cell cols="3">Lemma 6. If T n (l( x)) is of the form:</cell></row><row><cell cols="3">l( x) 8(x i then T n+1 (l( x)) is of the form: ^m î =1</cell></row><row><cell>l( x)</cell><cell>^m î =1</cell><cell>8(x i</cell></row></table><note><p>; ȳi )(C i ( x; xi ) _ψ i ( x; ȳi )); ; ȳi )(T 1 (C i ( x; xi )) _ψ i ( x; ȳi ));</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This research has been partially supported by FONDE-CYT Grants (1971304 &amp; 1980945)  and a NSF Grant (IRI-9632870). Part of this research was done when the second author was on sabbatical at the Technical University of Berlin (CIS Group) with the financial support from DAAD and DIPUC.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Flexible Relation: An Approach for Integrating Data from Multiple, Possibly Inconsistent Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wiederhold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Saraswat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Data Engineering</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Query Answering in Information Systems with Integrity Constraints</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFIP WG 11.5 Working Conference on Integrity and Control in Information Systems. Chapman &amp;Hall</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Logic-Based Approach to Semantic Query Optimization</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">S</forename><surname>Chakravarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="162" to="207" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An Overview of Data Warehousing and OLAP Technology</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<date type="published" when="1997-03">March 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Chomicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
		<title level="m">Logics for Databases and Information Systems</title>
		<meeting><address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Diagnosis and Repair of Constraint Violations in Database Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gertz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Universität Hannover</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Integrity Constraints: Semantics and Applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gryz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In Chomicki and Saake [5], chapter 9</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Deontic Approach to Database Integrity</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Kwast</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="205" to="238" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">A Semantics for Reasoning Consistently in the Presence of Inconsistency. Artificial Intelligence</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="75" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Merging Databases under Constraints</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Cooperative Information Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="76" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">OTTER 3.0 Reference Manual and Guide</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Mccune</surname></persName>
		</author>
		<idno>ANL-94/6</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Argonne National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Role of Deontic Logic in the Specification of Information Systems</title>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wieringa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dignum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Chomicki and Saake</title>
		<imprint/>
	</monogr>
	<note>chapter 4</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Logic for Improving Integrity Checking in Relational Data Bases</title>
		<author>
			<persName><forename type="first">Jean-Marie</forename><surname>Nicolas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="227" to="253" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Principles of Database and Knowledge-Base Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Computer Science Press</publisher>
			<biblScope unit="volume">I</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
