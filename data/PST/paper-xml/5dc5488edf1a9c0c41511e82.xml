<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scaling The Capacity of Memory Systems; Evolution and Key Approaches</title>
				<funder ref="#_4mzEVNk">
					<orgName type="full">European Commission</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><surname>Attwood</surname></persName>
							<email>andrew.attwood@manchester.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="department">Scaling The Capacity of Memory Systems</orgName>
								<address>
									<postCode>2019</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kyriakos</forename><surname>Paraskevas</surname></persName>
							<email>kiriakos.paraskevas@manchester.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science University of Manchester United Kingdom</orgName>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="department">Scaling The Capacity of Memory Systems</orgName>
								<address>
									<postCode>2019</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mikel</forename><surname>Luj?n</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">School of Computer Science University of Manchester United Kingdom</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Goodacre</surname></persName>
							<email>john.goodacre@manchester.ac.uk</email>
							<affiliation key="aff3">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="department">Scaling The Capacity of Memory Systems</orgName>
								<address>
									<postCode>2019</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mikel</forename><surname>Lujan</surname></persName>
							<email>mikel.lujan@manchester.ac.uk</email>
							<affiliation key="aff4">
								<orgName type="department">Scaling The Capacity of Memory Systems</orgName>
								<address>
									<postCode>2019</postCode>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scaling The Capacity of Memory Systems; Evolution and Key Approaches</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3357526.3357555</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>DSM systems</term>
					<term>NUMA evolution</term>
					<term>Memory expansion</term>
					<term>System Virtualization</term>
					<term>Unimem</term>
					<term>Chiplets</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The demand on memory capacity from applications has always challenged the available technologies. It is therefore important to understand that this demand and the consequential limitations in various aspects led to the appearance of new memory technologies and system designs. Fundamentally, not a single solution has managed to fully solve this memory capacity challenge. As argued in this survey paper, limitations by physical laws make the effort of expanding local off-chip memory impossible without adopting new approaches. The concept of Non Unified Memory Access (NUMA) architecture provides more system memory by using pools of processors, each with their own memories, to workaround the physical constraints on a single processor, but the additional system complexities and costs led to various scalability issues that deter any further system expansion using this method.</p><p>Computer clusters were the first configurations to eventually provide a Distributed Shared Memory (DSM) system at a linear cost while also being more scalable than the traditional cache coherent NUMA systems, however this was achieved by using additional software mechanisms that introduce significant latency when accessing the increased memory capacity. As we describe, since the initial software DSM systems, a lot of effort has been invested to create simpler and higher performance solutions including: software libraries, language extensions, high performance interconnects and abstractions via system hypervisors, where each approach allows a more efficient way of memory resource allocation and usage between different nodes in a machine cluster.</p><p>Despite such efforts, the fundamental problems of maintaining cache coherence across a scaled system with thousands of nodes is not something that any of the current approaches are capable of</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Ensuring fast memory access to the required capacity is crucial for defining the performance profile of a computing system. As already predicted by the memory wall concept in 1994, <ref type="bibr" target="#b74">[75]</ref> there is a continued disparity between CPU and main memory speed increase in favour of the processor resulting in performance losses due to processor data starvation. Caches fill the gap between the slower main memory and the large data capacity demands of the applications <ref type="bibr" target="#b36">[37]</ref>, but due to the relative limited size of caches, memory accesses are still very frequent with applications often still requiring to access a byte of memory for every operation computed <ref type="bibr" target="#b53">[54]</ref>. Moreover, it is also essential to keep main memory as physically close to the processor as possible in order to minimize latency and maintain signal integrity.</p><p>In addition, applications attempt to ensure data is stored entirely in main memory in order to avoid accessing the slower storage memory that would impact application performance significantly. Providing adequate and fast memory to store the majority if not all the information of data-intensive application is a difficult task for any system. Besides, supplying the application with more memory poses a continuous challenge, due to the trend of the ever growing applications needs for memory. The problem of providing more memory by expanding the memory capacity has lots of aspects, and this paper describes how various attempts and approaches have been taken to relieve this problem, how technologies have evolved over time and why none of current approaches appear capable of solving it. To the best of our knowledge, there is no similar up-todate survey in literature that covers the broad aspects of this issue to this extent, and provide an insight into the future vision and trends.</p><p>The issues in creating a processing device capable of supporting a large memory capacity range from the physics of resistance and capacitance through to hardware design rules, including several factors such as the maximum die size, number of routable pins, timing issues and constraints as well as the mechanical placement of the memory interfaces on the silicon die, all making it more difficult to further expand main memory capacity supported by a single processing device. Due to current semiconductor manufacturing process, there are limits in chip dimensions that in return, limit the number of supportable memory interfaces as well as the connectivity to the off-chip memory devices. Maintaining timing to achieve the high frequencies of modern memory devices is also a limiting factor when attempting to place multiple memory DIMMs next to the processing device. Current technology has also pushed the limits in increasing the memory density inside a DRAM chip due to physical restrictions <ref type="bibr" target="#b40">[41]</ref>. However, newly introduced memory technologies such as non-volatile memories are promising as a capacity replacement but still fall short in terms of performance compared to conventional DRAM <ref type="bibr" target="#b73">[74]</ref>, <ref type="bibr" target="#b9">[10]</ref>. On the other hand, new interfaces such as High Bandwidth Memory (HBM) <ref type="bibr" target="#b35">[36]</ref>  <ref type="bibr" target="#b57">[58]</ref> and Hybrid Memory Cube (HMC) <ref type="bibr" target="#b59">[60]</ref>  <ref type="bibr" target="#b65">[66]</ref> offer potential solutions to some of these problems described, but are still not widely available nor provide the overall capacity offered by a DSM system.</p><p>NUMA Architectures have attempted to address the need of increased memory capacity by allowing access to memory interfaces across multiple sockets of processing devices however with different performance characteristics. Although these multi-socket NUMA systems offer additional memory capacity than a single socket system, this is at the cost of non-uniform and additional latency overheads requiring power hungry protocols to maintain cache coherence and consistency of memory access. Such systems also require kernel <ref type="bibr" target="#b42">[43]</ref> and application awareness to ensure scalability further adding to the cost of hardware and software complexity. However, such systems continue to struggle to scale up beyond a limited number of sockets <ref type="bibr" target="#b49">[50]</ref> due to maintaining coherence and associated inter-processor communication.</p><p>The struggles in scaling NUMA and emergence of computer clustering led to the creation of other approaches and architectures, such as DSM across clusters, that albeit cheaper, offer a unified address space in which all participating nodes can share a global view of the available memory. Such a DSM system is Unimem, that encapsulates the mechanism of inter-node communication while providing a paradigm for accessing the global data. Another contribution is the description of the Unimem architecture and the subsequent ongoing hardware implementation inside the context of the EuroExa project, that will eventually contribute towards the mitigation of the memory capacity issue described in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">CONSTRAINTS ON SINGLE SOCKET MEMORY CAPACITY</head><p>Increasing the total memory capacity supported by a single socket processor is a profound solution to the memory capacity problem, but in reality, it is limited by various factors. These include the placement of memory devices, the dimensions of the processor chip and the methods available to connect these two. Even with technologies that start to address aspects of these issues, the fundamental challenge related to the size of the capacitor cell required to hold the memory state is limiting any further increase in memory density and hence, capacity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Die size limitations</head><p>Semiconductor design requires the high performance I/O such as memory interfaces to be placed near the edges of a processor die, however there are only four available edges on any conventional 2D die. It would be very convenient for the chip designer to have available any size and therefore the desired area in order to fit the required number of interfaces and logical components around the edges of the die. However, as discussed below, in addition to the obvious cost implications, there are various reasons on why this cannot happen. Chip manufacturers use a procedure called microlithography to fabricate a silicon die. A silicon wafer is a thinsliced semiconductor material, which acts as a base out of which dies are produced. A chip manufacturer desires as many rectangular dies on a round wafer as possible, in order to maximize the yield, which is associated to the usable and flawless surface area of the wafer. A stepper machine first makes a number of passes around the wafer, successively projecting the image of each die layer through a photomask ,or reticle, and then, after several chemical procedures, each die layer is fabricated. Larger dimension designs require larger masks and size, and therefore it is more likely to have errors in the resulting die due to fabrication imperfections or impurities in the wafer, and as such resulting in a smaller yield. In addition, for a given manufacturing technology node, the reticle has a maximum size even if the designer can afford the limited yielding of a large die. Thus, because of these restrictions on size, there is a limit on the amount of edge space available for I/O logic which in turn limits the number of interfaces that are used to access memory. Current state-of-the-art processors are able to support around eight from a single large die. <ref type="bibr" target="#b52">[53]</ref> [15].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Packaging design limitations</head><p>Even when a large die implements many memory interfaces, further issues arise due to the complexity of routing and driving these interfaces on the Printed Circuit Board (PCB) on which and memory devices reside. A key factor that affects this ability is the number of pins that the packaged processor device can support and be integrated using current PCB technologies. Despite the increasing performance and I/O capabilities of a die, this also increases the power requirement. This creates a tension between the number of pins required to deliver power and the number of pins that can be used for memory. Reducing the size and pitch of pins can provide more pins, however each pin is less able to deliver the required power, further increasing this tension. There is also the issue of voltage drop in wires, also known as IR drop <ref type="bibr" target="#b64">[65]</ref>, which can reduce the actual core voltage and hence signal integrity between the chip and memory devices. This, in turn, limits the physical distance that can be supported between the processor's memory interface and the memory device itself, which practically provides a depth limit of eight rows of memory devices from the processor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Interface and chip placement and routing</head><p>As mentioned earlier, the length of the signal path from the processor to the memory chip will affect performance and timing. The shorter the path, the less the latency, and hence the longer the path, the higher the frequency, but the more likelyhood of skew and longer latency, factors that together limit the amount of memory that can be placed on an interface. When adding more memory channels, careful signal routing is required to maintain a uniform distance while also avoiding noise and congestion between signals.</p><p>Another scaling problem comes from the parallel bus of a DDRx systems. As the DRAM clock rates increased, the signal integrity can become further degraded due to any noise. The fact that the electrical contact to the DIMMs is maintained by physical pressure from the DIMM slot contacts and is not soldered further contributes to the issue. However in some situations in which more DIMMs are added per channel, this problem further increases and often the clock rate must be lowered in order to maintain signal integrity. This trade off of capacity for performance leads to further escalation of the capacity problem. Given all the above, the addition of more and more DRAM chips or interfaces to increase the memory capacity is not an option.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Limitations in increasing the capacity of a DRAM chip</head><p>In the memory chip level, extensive research and work has been conducted throughout the years in order to increase the memory cell density of a DRAM chip, and consequently, its capacity. Currently, we have almost reached a point where physical constraints do not allow any further increase of DIMM density on a single die, a trend clearly visible in Figure <ref type="figure" target="#fig_2">3</ref>. In a DRAM chip which can include multiple dies, each bit of memory data is stored within a small capacitor and the presence or absence of the electric charge of the capacitor defines the memory state.</p><p>For successful DRAM cell operation, the capacitor in the DRAM cell should meet two requirements, sufficient capacitance (~10 fF/cell) and ultralow leakage current (J g &lt; 10-7 A/cm 2 given an operating voltage) in order to limit the frequency by which a cell must be refreshed. The cell capacitance is expressed by C=? 0 k A t phys where C, ?0, k, A, and t phys are the capacitance, vacuum permittivity, dielectric constant, effective capacitor area, and the physical thickness of the dielectric layer, respectively. Scaling of the DRAM cell has continuously reduced the area allocated to the capacitor in the cell, such that a 3D structured capacitor is used to obtain the necessary capacitance in the limited area <ref type="bibr" target="#b41">[42]</ref>. The aspect ratio of the capacitor has sharply increased and will reach ~100 shortly because of the aggressive scaling of DRAM. However, further increase  in the aspect ratio is impossible because of structural vulnerability of the capacitor, therefore, a higher-k material has to be used as the dielectric. Industrial solutions provide new higher-k materials to address this problem, but as the size of the lithography process decreases, the task of developing higher-k materials becomes more and more challenging.</p><p>In addition, due to leakage of the electrical charge, the capacitor must be periodically refreshed, otherwise any data will be lost. By shrinking the size of the capacitor, the memory density of the DRAM can be increased. At the time being, DRAM manufacturers claim to have hit the limit in how many electrons are required to hold a charge within an acceptable refresh period. <ref type="bibr" target="#b41">[42]</ref>. The complication being that DRAM data cannot be accessed during a refresh, resulting in performance loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Bypassing the limitations</head><p>In conclusion, the effort of increasing memory capacity associated with a single socket device in order to reach the capacity required by software has fought against physical limits that now more than ever are forming a red line against various laws of physics. For these reasons, interconnects and protocols have been created to allow access to additional memory owned by another socket within the same board or device within a network. This remote memory, although not as fast as memory directly attached to the processor, has promised to be faster than a traditional local storage device and therefore can act as an suitable extension to meet the application memory capacity requirements.</p><p>The following sections discuss the various technologies and approaches that attempt to provide to the application access to large capacities of memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">NON UNIFORM MEMORY ACCESS 3.1 Emergence of NUMA</head><p>NUMA architecture implementations try to overcome memory capacity limitations by providing non uniform access to memory, increasing the capacity by connecting multiple processors and their associated memory interfaces to appear as a single processor. Each processor has directly attached memory, however any processor can access any memory attached to any processor in the system. NUMA does not change the memory to processor ratio in a system but instead provides a linear increase in memory capacity as the number of sockets increases. To improve NUMA memory access performance <ref type="bibr" target="#b22">[23]</ref>, several improvements in NUMA designs have been introduced, as well as increases in single node memory capacity. Due to the existent physical limitations that halt any further substantial increase on single socket memory capacity, NUMA can be a substitute in achieving memory expansion.</p><p>Historically, One of the first successful commercial NUMA machines was the Honeywell Bull XP S-100, a medium scaled NUMA multi-node system that was released in the late 1980s and supported up to 64 users and the by then incredible amount of 16MB of RAM across multiple memory banks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Multi-node systems</head><p>A multi-socket NUMA system consists of processor chips in multiple sockets, each with globally accessible local memory (as shown in Figure <ref type="figure" target="#fig_3">4</ref>). Accesses to remote memory of another socket was made possible through processor-to-processor interconnects and associated protocols, but their overhead induced higher access time than that of local memory. The transition from single node multi-socket to multi node multi-socket NUMA systems where each multi-socket node has additional links, required additional protocols in order to continue to provide a unified memory view.</p><p>Performance wise, these additional layers increased access latency due to the node-to-node communication overhead. This led to a shift of the memory challenges from the independent memory management into providing efficient software-hardware protocols that unify local and remote memory and allow any socket to access this unified memory address space. While minimizing latency is important, achieving higher performance on a Distributed Shared Memory NUMA system versus a typical Symmetrical Multi Processor (SMP) system with shared memory relies on using efficient interconnects and protocols, an efficient network topology ( ex. fat trees -hypercubes), as well as having a good fraction of data references satisfied by local memory. Also, locality is an important performance factor that can be greatly aided by the operating system when it can allocate memory for processes on the same node as the processors they are running on. From the developer's aspect, the distinction of the performance gap between local and remote memory accesses should also be known and therefore handled appropriately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">System scalability effort and the memory coherence problem</head><p>In addition to the overhead induced by the introduced interconnects and protocols to access remote memory, more issues arose as soon as the number of nodes increases in a NUMA system. In order to provide the same programming model, the fundamental aspect of cache coherence is guaranteed through the serialization of memory writes <ref type="bibr" target="#b4">[5]</ref>, but as the processor count increases, so does the scalability limitations due to this serialization effort, which after a point, it hits a limit <ref type="bibr" target="#b5">[6]</ref>. Multi-socket cache coherent NUMA (cc-NUMA) systems after this point eventually struggled to provide increased performance while presenting a cache coherent memory view by means of write serialization, thus limiting any further scalability. On a typical cc-NUMA, (although typically still abbreviated to just NUMA) system communication between cache controllers provide a consistent memory image when more than one cache stores the same memory location. Fundamentally, as the system scales, it clearly becomes a communication-latency problem. As more processing nodes are inserted, the latency associated with the interconnect increases with the number of cores, which also further increase the per-core memory requirement for large systems and hence total capacity requirements. Also, it is becoming even harder to provide a system unified memory due to software overheads and network constraints, for which expensive custom hardware and software solutions are required.</p><p>Research studies <ref type="bibr" target="#b48">[49]</ref> dictate that by tracking the shared data owners, the overall traffic overhead with each miss is not significantly larger with a larger core count. On the other hand the article does not provide an efficient solution on a larger scale beyond 4 thousand cores. After this core count, invalidations are becoming more expensive, and efficient tracking of the page or cache owners require even more hardware resources.</p><p>Industrial solutions such as NUMAscale with the NUMAConnect architecture <ref type="bibr" target="#b66">[67]</ref> allow direct access to memory locations from any processor within the system, resulting in a homogenous cc-NUMA system, which is crucial to a program that exploits parallel processing, such as a High Performance Computing (HPC) applications. Instead, in a commodity cluster, communication typically takes place with explicit message passing between the processes on different nodes.</p><p>Historically, SGI (silicon graphics incorporated) <ref type="bibr" target="#b1">[2]</ref> was one of the first companies to push NUMA the furthest of anybody with its Scalable Shared Memory Multiprocessor (SSMP) <ref type="bibr" target="#b45">[46]</ref> architecture and largely scaled NUMA systems deployments using multi-sockets <ref type="bibr" target="#b68">[69]</ref>. SSMP introduced and described by SGI as "the industry's first 64-bit cc-NUMA architecture and supported up to 1024 processors. " SGI effectively created a DSM system while maintaining the simplicity of the SMP programming model and latency. However it was necessary for them to create a hierarchical partition scheme (hypercubes), to allow their multi-socket NUMA system to scale even further. This effectively alleviated the problem of write serialization however conceptually turned the system into a distributed clustered system. An example of such a system was the NASA Columbia supercomputer back in 2000s, that includes over 40 SGI Altix 4700 racks for a total of 4608 cores and 9 Terabytes of memory. <ref type="bibr" target="#b12">[13]</ref> However, it became clear that clustering was a more efficient solution that could scale higher than a cc-NUMA system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">INTRODUCTION TO DISTRIBUTED SHARED MEMORY SYSTEMS</head><p>By definition, DSM systems consists of a collection of nodes with one or more processors and private memory that are connected by a high speed interconnection network. The structure of an individual node is similar to a stand alone computer, except the nodes are usually smaller in terms of peripherals. At the highest level, a DSM creates a global address space that can be accessed by all nodes. A range of the global address space can be inserted into the existing Local address space of each node, or each node can receive a fraction of a separate global address space that is then subsequently partitioned and shared across all system nodes. For the system to be scalable, various prerequisites which will be discussed later are required. In addition there is a distinction between how the global address space is presented to an application and how the system implements the node-to-node communication.</p><p>It is also useful to understand the distinction between system scale-up and scale-out, as these two forms of scaling act as the basis between the memory capacity that can be obtained within a single node (scale-up) and the number of nodes that are required to provide the desired system capacity-capability (scale-out). Over time, many solutions have contributed in both these aspects, targeting either in increased performance through various innovations such as interconnects or to reduce system complexity such as software based DSM implementations.</p><p>The term scale-up, or vertical scaling is referring to the ability of an application running on a single node to use all the increasing resources attached to that node. By scaling up a system, memory capacity or processor count can be increased but the system node count does not. In cc-NUMA, coherence is provided to maintain the application programming model, but as the system scales, it reaches a point where coherence overheads become so large that it negates any performance gains by adding more resources, such as processors, meaning that further scale-up is not possible.</p><p>Scale-out, or horizontal scaling is effectively the addition of system nodes typically with similar capabilities, by attaching all nodes to a common network. The aim is to create a uniform and capable system where applications that adopt a distributed computing model can take advantage of the additional number of nodes. However, application developers still long fought for the existence of the shared memory software model which offer an efficient way of passing data between programs, even on these network clustered machines and marked the beginning of existence of DSM.</p><p>Therefore, the evolution of DSM needed to concentrate on two aspects; how applications access the global address space typically through libraries and language extensions and how the node interconnect creates the global address space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Evolution of Interconnects</head><p>Initial DSM systems used the existing interconnect protocol stacks between nodes, such as TCP/IP, to provide communication between the nodes of a DSM. By definition these stacks add a significant overhead to the remote memory access and became a prime candidate for initial innovation. An obvious improvement was to replace the TCP with a lightweight protocol such as UDP or support the protocol with hardware offload such as Remote Direct Memory Access (RDMA) where blocks of memory can be moved directly between nodes without processor involvement. This trajectory has continued with newer innovative interconnect architectures that offer significant performance gains by further removing the network overhead of existing protocols and processor involvement.</p><p>RapidIO <ref type="bibr" target="#b23">[24]</ref> was a hardware communication stack which provided coherence between nodes in clusters, however it was not well adopted due to its proprietary nature. Newer non-proprietary interconnection protocols provide the semantics for easier adaptation. For example, Gen-Z <ref type="bibr" target="#b21">[22]</ref> is a scalable, universal system interconnect that uses a memory-semantic (Load/Store) protocol and enables multiple components of different types to efficiently communicate by instantiating a bridging device which provides direct byte addressable communication with the remote node compared to the RDMAs block structure while, at the same time, natively providing addressability into the global address space. Practically, this allows to any component (processors, accelerators, network cards) that can access this bridging device to talk to any other component as if it were communicating with its own local memory using dedicated memory access commands, and thus it is called as "memory-semantic protocol" by Hewlett Packard Enterprise. Memory-semantic communication moves data between memories located on different components with minimal overhead and latency by using load-store memory semantics everywhere. The drawback is that it does not support cache coherence, thus limiting performance in shared memory systems in which software (and subsequently additional overhead) is required to maintain coherence around every transaction across the application. Although promising, lack of cache coherence support will make scalable applications development difficult beyond the benefit of providing byte access to large storage devices.</p><p>Another interconnect, the Cache Coherent Interconnect for Accelerators (CCIX) <ref type="bibr" target="#b20">[21]</ref> is a scale-up interconnect architecture developed by the CCIX consortium and offers memory consistent communication between heterogenous elements such as system accelerators and processors. This is accomplished by providing a cache-coherent protocol over the standard PCIe physical interface which may allow it to be more successful than RapidIO. Although high-performance, this heterogenous NUMA architecture suffers from the very same memory coherence scalability issues that write serialization induces, introducing similar bottlenecks as in a homogeneous scaled system, and therefore this cannot be considered a solution to the memory scalability issue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Advancement of language extensions and libraries</head><p>From software perspective, in order to abstract the interconnect protocols and provide a DSM programming model, several language extensions as well as software libraries have been implemented. Within the HPC market various Partitioned Global Address Space (PGAS) programming models have been developed that assume a parallel programming model with a logically partitioned global memory address space across nodes. PGAS languages try to combine the advantages of a distributed memory system programming model such as MPI <ref type="bibr" target="#b71">[72]</ref>, that can benefit from hardware accelerated interconnect, with explicit data referencing semantics of a shared memory system. Examples of such implementations include, BXI by Atos <ref type="bibr" target="#b25">[26]</ref> and ConnectX by Mellanox <ref type="bibr" target="#b72">[73]</ref>, that combine proprietary interconnects and hardware primitives that can be mapped directly to communication libraries. PGAS can be provided to the programmer either as a language, language extension or through libraries, such as such as Chapel <ref type="bibr" target="#b15">[16]</ref>, Unified Parallel C (UPC) <ref type="bibr" target="#b28">[29]</ref>, and Co-array Fortran <ref type="bibr" target="#b56">[57]</ref>. They often allow a weak memory consistency to counter the restrictions of a strict sequential consistency which as the system scales, becomes prohibitively expensive performance wise. Unfortunately, these approaches are provided by multiple vendors, each often using proprietary hardware solutions, and therefore have a limited adoption. Efforts have been made to tackle this proprietary nature constrain, with attempts to standardize RDMA access to lower latency, or adding additional layers of abstraction such as Portals 4 <ref type="bibr" target="#b11">[12]</ref> in order to standardize underlying hardware and provide low latency from either the language semantics or software libraries.</p><p>Several software DSM implementations rely on kernel modifications and libraries to provide a portable solution of a DSM system Gen-Z connection</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>NIC NIC</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gen-Z connection CCIX connection</head><p>Figure <ref type="figure">5</ref>: Demonstrating the distinction between CCIX and Gen-Z path to main memory over network by merging mainly commodity solutions into a unified system. Treadmarks <ref type="bibr" target="#b39">[40]</ref> supported DSM over UDP/IP, where Grappa supported both TCP and RDMA configurations <ref type="bibr" target="#b55">[56]</ref> and provided a user-level library and runtime to the user, although these solutions came with a significant software overhead and memory latency. Treadmarks tried to reduce the amount of necessary communication to maintain memory consistency but was successful only to a point. FaRM <ref type="bibr" target="#b26">[27]</ref> utilized RDMA for better performance by removing TCP/IP network stack, but throughput is still limited to the RDMAs lowerr effective bandwidth compared to the cross sectional bandwidth of the network between multiple nodes and the inefficiencies of setting up an RDMA transfer for small amounts of data. In the latter case, a more traditional approach of data copying should be adopted.</p><p>ArgoDSM <ref type="bibr" target="#b38">[39]</ref> is another new, highly-scalable, software DSM system for HPC and Big Data applications, meant to be run on top of a RDMA-capable network layer that can provide a cache coherent global address space in a distributed system without dedicated hardware support but with efficient synchronization, page locking and a new software based coherence protocol. Benchmarks show that Argo scales more than UPC after a certain number of nodes, and generally relieves the problem of centralized coherence approach, but without dedicated hardware support, such as fast interconnects, access latency remains high.</p><p>Lastly, efforts exist to create a specification for a standardized API for parallel programming in PGAS through OpenSHMEM <ref type="bibr" target="#b16">[17]</ref>. Along with the specification, OpenSHMEM provides a reference of a portable API implementation that allows it to be deployed in various environments and hardware interconnect accelerators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Virtualization of the memory system</head><p>Despite the efforts to standardize languages and library access to DSM, the most portable standard in terms of application accessing memory is the processor architecture itself, the Instruction Set Architecture (ISA).</p><p>In this aspect, efforts there have been made to utilize the hardware virtualization of the processor to virtualize the Global memory address space and implement the DSM within the hypervisor and hence provide the global memory as an integrated part of the virtualized processor local address space. This removes the need for any library and language extension to be used by the application to access global memory, thus reducing the overall overhead. Over the years, the pure software and language implementations of DSM systems focused on reducing memory update cost for increased system scalability whereas virtualization <ref type="bibr" target="#b60">[61]</ref> was utilized to share the available resources for increased flexibility. In the first examples where the DSM moved into the hypervisor it simply presented remote memory pages in the virtualized local address space <ref type="bibr" target="#b17">[18]</ref>, however more recent examples have been able to provide a more relaxed memory consistency models in order to reduce the network load while also using advanced AI/ML algorithms that provide realtime optimization mechanisms, such as page and thread migration based on workload and memory patterns as an attempt to improve locality and offer optimal performance in common situations.</p><p>Examples of hypervisors that provide DSM to ther guests include industrial products, such as vSMP <ref type="bibr" target="#b67">[68]</ref> by ScaleMP that combines clusters of commodity x86 servers in order to create a distributed virtual symmetric multiprocessing system. By doing so, the virtual SMP system can have better scaling capabilities to proprietary SMP systems, while maintaining the cluster's low cost. Another product example is Hyperkernel, the core of the TidalScale <ref type="bibr" target="#b54">[55]</ref> tool, and as the name suggests, is a hypervisor that creates a distributed kernel to manipulate system nodes, but is transparent to the applications that run on it. TidalScale currently supporting only intel Xeon processors. AMD Epyc processors, ARM server processors, or IBM Power processors are yet to be supported. Although the application has been simplified due to access to a processor native memory system, the total complexity and depth of the stack used to implement the DSM has increased. Even with the addition of further intelligent innovations offered through the flexibility that the hypervisor provides to limit the costs of remote access, there are still many usage scenarios, such as when a large number of threads access the same page, or when a single task is accessing lots of remote pages that lead the application suffering from the full latency cost of the stack. Nevertheless, system virtualization, with further novel additions, can be a potent contributor towards the relief of the memory capacity problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EMERGING TECHNOLOGIES</head><p>On the hardware level, innovations and new architectural approaches of the memory subsystem led to significant breakthroughs, resulting in new technologies that offer higher memory capacity. Several memory dies are now stacked inside a single die, Non Volatile Memories (NVM) are pushing the density limits far beyond DRAM could ever reach, memory interfaces with serialized bus allow more memory devices to be attached to a single processor, and novel approaches, such as Unimem that aims to lift the barriers of a DSM system at scale, all these innovations would eventually allow higher capacities of memory available to a system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Multi-chip modules</head><p>One of the ways to overcome the size induced yields issues on a single die is by partitioning the large die into smaller dies which also in consequence increases the total edge area. This partitioning simplifies power supply requirements because of shorter interconnect lengths, and offers the opportunity for greater miniaturization and reliability at system level due to decreased number of interconnects between system level components thus leading to lower cost and simplification of by putting several devices, including memory devices, into a single package.</p><p>Historically, research on the Multi-chip modules (MCMs) dates back to the 80s. <ref type="bibr" target="#b13">[14]</ref>. Currently, the evolution of chip manufacturing process allowed the creation of devices with more dies integrated into a single package both in 2D and 3D plane, providing higher yielding devices capable of supporting a larger number of memory interfaces, as demonstrated in Figure <ref type="figure" target="#fig_4">6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Non Volatile Memory technologies</head><p>As discussed earlier, single DRAM chips have almost reach their density limits. However, since NVMs do not use capacitors, they are able to scale further and provide additional capacity compared to DRAM. Current generation of volatile memories cannot replace DRAM due to performance and durability concerns as already stated in <ref type="bibr" target="#b9">[10]</ref>, but since they offer higher capacity and lower power, NV Memory is a very interesting trajectory for increasing the capacity of memory that is close to the processor. This emerging technology could solve may of the big issues introduced earlier, such as the capacity per mm 2 while also capable of solving the pin out problem, due to the capabilities of the processors to control flash through the high speed serial I/O already present.</p><p>Research has shown that NV Main Memory (NVMM) improves application performance significantly over flash-based SSDs and HDDs, without application changes <ref type="bibr" target="#b75">[76]</ref>. Table <ref type="table" target="#tab_1">1</ref> summarizes the characteristics of NVM technologies, compared to DRAM <ref type="bibr" target="#b50">[51]</ref>. Spin Transfer Torque RAM <ref type="bibr" target="#b7">[8]</ref> has worse write performance compared to DRAM, as well as lower density compared to other NVMs. Resistive-RAM <ref type="bibr" target="#b70">[71]</ref> has the potential to be integrated into a CPU die, since it can be fabricated in a standard CMOS logic process, and enable massive memory parallelism, high performance and power efficiency, as shown in <ref type="bibr" target="#b34">[35]</ref>. The same study also makes clear that several challenges that span across multiple system abstraction layers need to be overcome for this concept to be realized, More specifically, in addition to the immature ability of the ReRAM to be used as main memory instead of flash memory (in terms of latency and reliability), a large chip area is to be occupied by ReRAM logic, directly pointing to the need for designing much larger cores, a task that is already difficult as we already described in Section 2.1.</p><p>Phase Change Memory (PCM) <ref type="bibr" target="#b62">[63]</ref> offers higher memory density but also higher write latency and low endurance, however, as this is a significant research area, newer technologies such as Domain Wall Memory <ref type="bibr" target="#b69">[70]</ref>, which is the less mature of the non volatile Memory technologies due to its physical nature, can offer higher density but non uniform access latency. Other promising technologies include CeRam, nanotube or Skyrmion <ref type="bibr" target="#b51">[52]</ref> based devices.</p><p>Currently, processors do not uniformly have native provision for the persistence in main memory which is a trait of NVM. Assuming that future generations of processors will overcome this by provide support for NVMM persistence, and the technologies will mature, there is a true potential to increase the total memory capacity of even a single node.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Memory Interfaces</head><p>As discussed in section 2, the delivery of memory comes through a parallel bus, which limits the off-chip capacity that can be supported. To address this problem, in-package substrates which can support many smaller pins between processors and memory can be used to alleviate the pin count problem. HBM leverages the benefits of smaller pins, and in turn by being integrated within a MCM, together they significantly reduce the issues associated with interfacing a processor with memory, however the amount of memory that can be placed inside the MCM is still small compared to the amount of memory that can be placed off-chip. An alternative to the parallel memory bus is to use a high speed serial bus. This approach addresses many issues, including the number of pins needed to be supported by the processor device. The narrower bus is also easier to route and can travel further across the PCB without suffering from timing skew. Together, this effectively allows more memory devices to be attached to a single processor, however it requires the memory device to include active control of the DRAM. The HMC includes a logic layer that redirects requests between off-chip serial interfaces and die components, while also supporting in-memory operations. HMC is a good example of this approach which in addition when multiple high speed interfaces are provided to the HMC device, a chain network of memory devices and processors can be created <ref type="bibr" target="#b65">[66]</ref>, thus effectively creating a DSM. In both the HMC and HBM technology approaches, the capacity to the associated memory devices is limited by the form factor, however the stacking of memory dies is allowing these to approach the capacity of traditional DRAM DIMMs. Performancewise, simulations have shown that HMC and HBM can reduce end-to-end application execution time by 2x-3x over DDRx and LPDDR4 architectures <ref type="bibr" target="#b46">[47]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Stacked memory technologies</head><p>The introduction of 3D-stacked DRAM inside the die however leads to the increase of the single memory device capacity by accommodating more dies inside a package, and therefore can offer more package memory density.</p><p>The DDR4 <ref type="bibr" target="#b24">[25]</ref> standard introduced the ability for Through-Silicon Vias (TSV) stacking extensions that allowed manufacturers to create high capacity DIMMs. In addition, Registered DIMMs (RDIMMs) allow more stability in situations where more than one DIMM per channel is used. Samsung announced 256-Gbytes 3D stacked RDIMM based on the 10 nm fabricating process, 16-gigabit DDR4 DRAM that offer lower power consumption and improve performance by doubling its current maximum capacity <ref type="bibr" target="#b31">[32]</ref>.</p><p>The stacked DRAM dies are connected with TSVs that shorten the interconnection paths, reducing the channel latency and the energy consumption. An HMC implementation provides device addressable memory stacked DRAM dies on top of a silicon die while removing the obstruction of limited pin count by introducing differential serial links connected to the processor. A version of HMC named Multi-Channel DRAM (MCDRAM) was developed in partnership with Intel and Micron to be used in the Intel Xeon Phi processor codenamed Knights Landing. This introduces a new paradigm in which DDR4 and 3D-stacked RAM are used by the processor, each with different performance characteristics and modes, such as a cache-only, memory addressable, and hybrid mode, which is a mixture of both <ref type="bibr" target="#b8">[9]</ref>. Lastly, it is worth mentioning what is argued in <ref type="bibr" target="#b61">[62]</ref>; even when device chains of 3D-stacked DRAM may significantly increase the available memory bandwidth, only applications with high level of memory-level parallelism will benefit, while the rest will not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Compute units, Chiplets and Unimem</head><p>At the DATE conference <ref type="bibr" target="#b19">[20]</ref> in 2013, the concept of a Compute Unit was first discussed in which a computation engine, its memory and a coherence interconnect provides a locally coherent view of the unit's memory hierarchy to the outside world while also providing a path to remote memory (see Figure <ref type="figure">8</ref>). This remote memory space by means of a global interconnect becomes a globally shareable address space, in addition to the local address space, in which remote units can access locally owned memory coherently with any cached access from any computation engine within the local unit. Unlike traditional shared memory models, this model defines a singlesided coherence scheme in which only the owning unit can cache any globally shared region of local memory. This removes the complexities and costs associated with maintaining a coherence protocol between units, and hence lifting the scalability limiting serialization of coherent writes, while also removing any need for software to manage caches at the memory owning unit. Address translation facilities in the bridges between the local and remote address spaces also enable the remote address map to be defined by the configuration of the global interconnect as opposed to a globally agreed configuration between all the local unit's address spaces.</p><p>These aspects of a Compute Unit were defined to enable a DSM capability between multiple units with the global interconnect operating at the processor native address layer of the Compute Unit. This also removes various levels of the typical DSM communication stack in that an application or any hardware block executing in one unit is able to natively Load/Store a remote unit's memory. Protection and translation between each unit's configuration of its local address space is accomplished via the configuration of their local bridges to the global address space. Support for global atomic transactions by using monitors local to each of the local memories, thus providing the fundamental capabilities to support NUMA enabled operating systems. Clearly the requirement not to cache remotely accessed memory would significantly lower the performance of operations on remote memory, however, other than sharing within a single distributed virtual address space it was found that for inter-process communication, the local cache was typically cold as the processors move data between processes.</p><p>A further benefit of the Compute Unit and the flexibility in the arrangement for the global address space was also defined so that a silicon implementation of a Compute Unit could be reused between designs and be delivered as a silicon module called a Chiplet. The term Chiplet was first used to define a silicon module that has the properties of a Compute Unit, however more recently the term is also being used to mean any subsystem of a design hardened as a module in silicon. The link between the concept of a Compute Unit, its delivery as a Chiplet, and the scalability of a design was first investigated and prototyped in the EU funded FP7 project EuroServer <ref type="bibr" target="#b27">[28]</ref>.</p><p>Following the EuroServer project, a number of subsequent projects further refined various aspects of the Compute Unit based DSM architecture, in what has become known as the Unimem Memory System Architecture <ref type="bibr" target="#b63">[64]</ref>. Currently, the H2020 project EuroExa <ref type="bibr" target="#b2">[3]</ref> Figure <ref type="figure">8</ref>: The concept of compute unit (Source: ARM) is implementing a large scale prototype of a Unimem capable HPC platform that implements an Arm processing system as a Compute Unit Chiplet capable of processor-native Load/Store transactions through address translation bridges in which a global interconnect and routing topology provides an owner-coherent, DSM system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">OVERVIEW OF THE UNIMEM ARCHITECTURE</head><p>A further contribution towards the alleviation of the issue comes by providing a description of the Unimem memory scheme, and outlining the ongoing effort of a Unimem-enabled hardware implementation, and more importantly, describing an efficient hardware mechanism for the address translation procedure in order to support a global virtual address space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">An evolved compute architecture</head><p>From 1970 up to 90's the typical compute architecture was comprised of the CPU, the main memory and the storage memory, following the von-Neumann model. Later on, until 00's, newly introduced Multi-socket SMP systems provided a computing paradigm that offers more computing power at the expense of less main and storage memory per thread. In the decade that followed, the commercially available Multi-core Multi-socket NUMA systems delivered an increased computing power while at the same time mitigating the memory issue by providing more RAM and storage memory to threads. Nevertheless, the impotence of NUMA systems to scale beyond a certain point contributed to the appearance of non Von-Neumann architectures in which the computations are offloaded to accelerators, leading to shorter computation times, but at the same time, access to main or storage memory is bottlenecked, since all memory operations are propagated through the host itself.</p><p>In order to alleviate this issue, a control-data plane architecture is proposed in EuroEXA project, where each data plane owns its own main-storage memory. In the context of the project a prototype system that aims to take the HPC approach a step further is being implemented in which accelerators are given native access to both network and application memory, and in addition, storage memory is distributed with locality to each node in contrast with the traditional HPC model where all the network and accelerator data movement to the host memory is processed by the host itself, as shown clearly in Figure <ref type="figure">9</ref>. The acceleration is centralised to the FPGA fabric of a single device and the storage is moved physically onto the network interface, which is also implemented on FPGA.</p><p>Unimem is an innovative scalable memory scheme firstly described in the EUROSERVER project as a new memory model across the server system, which breaks the traditional dual memory types available in today's systems: cached memory and device memory. Typically, in order to provide scalability to the cached memory type, a global coherent protocol is required, thus limiting system scalability. In return, this practically limits the ability to deliver fast, shared memory to the application, but at the same time is crucial for maintaining a consistent shared memory state across the system. It is known that applications in data-centres tend to partition their datasets across servers, presuming that these datasets will be placed near the processors and caches of an application task. In many cases, it is faster and more energy efficient to move tasks near the datasets New HPC approach New HPC approach Figure <ref type="figure">9</ref>: Illustration of the node approach in a traditional HPC system vs the proposed approach by the EuroEXA project, where the Accelerators have direct access to application memory and network interface than moving the datasets near the processor, especially when the datasets are large, but this requires advanced AI algorithms and pattern analysis for page and thread migration, just as hypervisors mentioned above already provide.</p><p>Instead, Unimem maintains consistency across the system by providing cache coherence within each compute node and its local DRAM, and treating remote memory as shared and uncached device memory, thus providing flexibility to the communication paradigm with small additional overhead, by utilizing the available ARM technology. This approach offers a scalable system with minimal performance loss due to maintaining cache coherency. A notable proposed scalable system architecture is described in <ref type="bibr" target="#b33">[34]</ref> in which, NAND flash is used as main memory technology and DRAM as a cache for flash, allowing a substantial increase in main memory capacity with negligible performance loss. Although this system can provide a global virtual address space and a considerable amount of main memory per node, cache coherence is relied on software solutions and eventually performance may suffer the latency cost of the stack.</p><p>In Unimem, data movement acceleration is achieved by replacing the commodity TCP/IP with RDMA for large data sizes or direct CPU memory operations for smaller sizes, thus delivering a large, fast amount of shared memory to the application. Since this Unimem sharing path is directly from within the hardware memory system of the Compute Units, the ExaNeSt-EuroEXA consortium has already demonstrated that moving the traditional TCP/IP based I/O communication stack directly on top of the Unimem RDMA stack can significantly accelerate data movement, and has also implemented additional features (such as transfer QoS) <ref type="bibr" target="#b30">[31]</ref>  <ref type="bibr" target="#b44">[45]</ref> [59] <ref type="bibr" target="#b43">[44]</ref>  <ref type="bibr" target="#b47">[48]</ref>. The majority of data-centre applications are I/O <ref type="bibr" target="#b10">[11]</ref> and memory-bound <ref type="bibr" target="#b32">[33]</ref>, and should therefore benefit from remote DRAM borrowing via Unimem. Ensuring backwards compatibility with the existing application models and software investments is important, however, Unimem's raw capability also opens up significant opportunity for further optimizations in future runtimes and application frameworks. A breakdown of the Unimem global address space is shown in Table <ref type="table" target="#tab_3">3</ref>. Since current ARMv8 <ref type="bibr" target="#b29">[30]</ref> architecture supports a 48-bit Virtual Address Space, 16 out of the 64 Global Virtual Address bits are provisioned to support future generations of CPUs. The location coordinates field are used for interconnect routing and allow geographic routing, since location awareness is provided to each node, thus simplifying network logic. Lastly, 8 of the user bits are used to specify the kind of operation, out of a total of 256 individual operations, and 16 bits are used to specify the Protection Domain ID and used for security purposes, while the rest are also reserved for future use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Features of Unimem</head><p>Additionally, applications can use RDMA to generate both local and remote transactions, in an library based API that also provides global address memory allocation and sharing. Furthermore, Eu-roExa adds support of native generation of remote transactions from the processor, hence applications can also access remote address space without using any intermediate software stack that. Table <ref type="table" target="#tab_2">2</ref> compares briefly the Unimem to other communicating schemes, highliting any similarities-differences.</p><p>Virtualized Mailboxes and Packetizers-Depacketizers are implemented in FPGA in order to send short messages between Compute Units as well as to support Atomic and Collective Unimem operations (such as barriers and reductions) across nodes, a concept that been succesfully exposed already by ExaNode/ExaNeSt/EuroExa projects <ref type="bibr">[64] [38]</ref>. One additional feature of this system compared to others is the implementation on FPGA of a large part of the Unimem hardware involved in the translation procedure, which, in conjuction with the flexibility of the user bits described earlier, provides the flexibility to broaden the range of operations accelerated in hardware and therefore, be able to adapt to specific software semantics. This approach eventually allows the implementation of special DSM functions in order for the application to natively access the shared memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Implementation of Unimem</head><p>Each EuroEXA Compute Unit shares a common local address space that includes ARM Cortex A series processors, 16GB of LPDDR4 DRAM, 154Gbps FPGA link and a 400 Gbps Interchip Link. Accessing the local address space in each node is achieved using native AXI transactions generated from the local CPU or FPGA accelerators. In current CPUs there is lack of native support for accessing a large global address space, since the larger address width surpasses the capabilities of current CPUs in terms of availible address bits. For example, current ARM processors support up to 40 bits of physical addressing that could be used to map into memories of remote nodes, practically limiting scalability. In order to provide such a capability for remote memory transactions in a large global address space, additional hardware beyond the CPU is required.</p><p>For this reason, each node contains hardware bridges implemented partially in ASIC and FPGA logic that provide the required functionality for any kind of remote memory operations between nodes, and that are also easily extendable with low cost to support future operations. The AXI locally generated transactions towards the To-Bridge have a number of user bits that are used for operation encoding, thus enabling a particular remote operation to be implemented in hardware. The To-Bridge is then responsible for translating local memory addresses into Unimem Global Virtual Addresses (Unimem GVA). These transactions reach the packetizer, which is implemented in FPGA and converts the 128-bit Unimem AXI operations into Exanet <ref type="bibr" target="#b6">[7]</ref> packets, according to the transaction type specified in the AXI user bits. In addition, the ExaNet packet 80-bit address format has a 80-bit address address space includes:</p><p>? The Protection Domain ID (PDID) that identifies the systemlevel process group to which the data belong. At each node, there is at most one process per PDID; ? the Destination Coordinates ID (DCID) that identifies the node at which the data reside, thus allowing a flexible network topology; ? the Destination Memory Address that identifies a virtual or physical address of the process belonging to the group PDID and running at node DCID.</p><p>The ExaNet packets are then propagated into the network through the ExaNet Network IP <ref type="bibr" target="#b6">[7]</ref>, implemented on FPGA by one of the project partners, which is part of the remote interconnect as shown in Figure <ref type="figure" target="#fig_6">10</ref>.</p><p>On the receiver side, the From-Bridge of the remote node essentially depacketizes and translates the exanet packets into a set of operations, where operations such as atomics may trigger an interrupt to the CPU and the corresponding interrupt handler perform the specified operation. This setup offers flexibility in operations, allowing collective or atomic operations to be conducted through the appropriate CPU interrupt handler, or RDMA engines to be used as accelerators for faster large remote reads and writes, where in the common case of load and store instructions, the depacketizer in the From-Bridge will issue native AXI read or write operations directly to its local memory without invoking the local CPU, then send the data or the notification back into the request node through mailboxes.</p><p>Likewise, Figure <ref type="figure" target="#fig_6">10</ref> displays a high-level detail of implementation that shows the distinction of the local interconnect and remote interconnect in a compute unit, and the "To" and "From" Bridges, implemented both in ASIC and FPGA, which are essentially responsible for mapping the local addressed transaction into a remote addressed transaction, and also map the local addressed transaction into a remote addressed transaction respectively.</p><p>It is also worth describing more thoroughly how the address translation process is carried out. The Unimem-To module is a configurable custom hardware that provides a Unimem address translation mechanism. The ARM-based processing elements generate AARCH64 virtual addresses, which are initially translated by the Memory Management Unit of the CPU. Then, the Physical Addresses are routed into the Unimem-To module via the ARM AXI4 interconnection protocol <ref type="bibr">[1]</ref>. The module contains two translation caches that act as TLBs, depending on the Memory Type, either Unimem, or Page Borrowing, where, in each case, the appropriate translation cache is accessed. The output of the Unimem-To module is a 128 bits Unimem Global Virtual Address.</p><p>These remotely addressed transactions are then directly packetized into ExaNet packets rather than having to create an ExaNet packet by writing multiple times to the packetizer AXI transactions which would lead to additional latency. This approach allows remote accesses to be implemented with native Load and Store instructions issued from the local CPU. We also argue that by utilizing the configurable SMMU and the protection features it provides, we can implement functions in hardware that do not invoke the OS (ex. through interrupts) to access protected pages or other resources. Instead, these functions can easily get access to these resources directly by simply meeting the SMMU security requirements already specified for these resources.</p><p>In terms of software, provisions to the OS include the support the larger 128-bit Unimem Address translation scheme, as well as to provide as much local memory quantity as possible where needed, in order to avoid the remote access penalty, and also provide self-location awareness. In addition, since the local virtual address translation into remote addresses is controlled by the remote To-Bridge, a kernel managed lookup table will be implemented to provide the Memory Management Unit (MMU) with the required additional attributes in order to extend the local virtual address into a Unimem global virtual address.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS -VISION OF THE FUTURE</head><p>Due to the ever lasting conflict between the available memory capacity and the application needs, and the base technologies that deliver memory capacity, the implementation constraints of DRAM and processors appear to be reaching the limits of current technologies. Consequently, other approaches have been introduced, such as the NUMA architecture which maintains a system in which memory is accessible by any processor, although with subsequent limits in scalability. Creating a distributed memory view across clusters of machines, even though at a lower cost, suffered greatly from interconnect technology inefficiencies and the abstractions required to transit from the software layer to the various interconnects. Emerging technologies and memory designs look promising in increasing the memory capacity, however, in conjunction with a scalable cluster technology at the hardware level, might be the catalytic agent for providing a system with fast, and ample memory capacity.</p><p>The described Unimem system enables the low cost future implementation of DSM functions in hardware, by exploiting the existing memory management capabilities of commercial processors while providing a global addressing scheme that, as already discussed, allows a scalable coherent view of memory while at the same time being customizable for supporting additional functionality in the future. This functionality is to be evaluated throughout the software stack involved, and the performance increase in various software DSM systems and applications will be measured, but for this to happen, additional kernel drivers for hardware management are to be developed and modifications in order to extend the API of the software DSM systems to exploit the custom underlying hardware will be made. Along with the increase in examples of silicon module based semiconductor design, it is expected that the Compute Unit concept will be able to provide a reuse model for such modules, and that the hardware transaction level interconnect of the Unimem system will finally close the designed questions of DSM across a cluster and once again deliver hardware native support for shared memory between nodes in scalable and low cost cluster of computers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Die layout of the Vulcan chip used within the Cavium ThunderX2 processor device demonstrating the limitations regards to the relative size and placement of I/O and memory interfaces on each edge of a large multicore processor die<ref type="bibr" target="#b3">[4]</ref> </figDesc><graphic url="image-1.png" coords="3,53.80,399.48,240.25,240.93" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2:The board layout of a Cisco blade server demonstrating the placing of DRAM memory devices (9-12) matching the edges that contain the memory interfaces inside the processors, further constrained by the physical dimensions of the blade server<ref type="bibr" target="#b18">[19]</ref> </figDesc><graphic url="image-2.png" coords="3,317.96,474.54,240.25,165.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Graph showing the reality in reducing the feature size (nm) (source [42])</figDesc><graphic url="image-3.png" coords="4,53.80,83.69,240.25,174.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: An example of two dual socket NUMA machine each having local memories interconnected to provide a global Distributed Shared Memory system</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The layout of an EPYC package containing 4 chips, supporting a total of eight DDR4 channels</figDesc><graphic url="image-4.png" coords="8,317.96,423.92,240.25,243.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: An example of 3D stacked RAM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure10: Distinction of the various EuroEXA address formats (both for Virtual and Physical addresses), while a memory operation traverses through the EuroEXA resources. On the initiator node , the ARM Cortex A series generates a 48 bits Virtual Address (VA), which is fed to the Memory Management Unit (MMU). The Physical Address (PA) generated from the MMU is 40 bits. Then, the Unimem-To module is responsible for translating the Local Physical Addresses into Unimem Full Virtual Addresses (UFVA). Finally, the reverse translation process is handled in the destination node and the resources are accessed through the System Memory Management Unit (SMMU)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Comparison of Memory technologies properties<ref type="bibr" target="#b75">[76]</ref>. We can see the larger density supported by NVMs over DRAM. Other NVMs include the Memristor, STTM, FeRAM, and MRAM..</figDesc><table><row><cell></cell><cell>DRAM</cell><cell>PCM</cell><cell>Other NVMs</cell></row><row><cell>Density (F 2 )</cell><cell>6-12</cell><cell>4-16</cell><cell>4-60</cell></row><row><cell>Read Latency</cell><cell>10-50 ns</cell><cell>48-70 ns</cell><cell>10-100 ns</cell></row><row><cell>Write Bandwidth</cell><cell cols="3">1 GB/s per die 100 MB/s per die 140 MB/s -1 GB/s per die</cell></row><row><cell cols="2">Endurance (cycles) &gt;10 16</cell><cell>10 9</cell><cell>10 12 -10 15</cell></row><row><cell>Byte Addressable</cell><cell>Yes</cell><cell>Yes</cell><cell>Yes</cell></row><row><cell>Volatile</cell><cell>Yes</cell><cell>No</cell><cell>No</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Requires coherence protocol across all memories and nodes, thus limiting scalability. Unimem surpasses this limitation by delivering local memory coherenceSoftware managed PGASSoftware solutions required to create a model and API for communicating in address space.Instead, Unimem provides true hardware support for PGAS Comparison of the Unimem approach with other communication schemes</figDesc><table><row><cell cols="3">Unimem compared to:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Cache coherent shared memory</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">(eg. SMP, ccNUMA, SGI)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">RDMA communication</cell><cell cols="10">By using a dedicated DMA device engine to move data directly to remote memory, Unimem supports a common global address space with no correlation between source and destination addresses</cell></row><row><cell cols="3">Communication devices</cell><cell cols="10">No need for the application to allocate software managed buffers for data movement. Unimem natively supports direct puts-gets at hardware level</cell></row><row><cell cols="4">Traditional HPC approach Traditional HPC approach</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Applicatio</cell><cell>n Memory</cell><cell cols="2">Accelerator Traditional Host</cell><cell>Interface</cell><cell>Network</cell><cell>Storage</cell><cell>Central</cell><cell>Application</cell><cell>Memory</cell><cell>Control Host Traditional Data Accelerator</cell><cell>Interface</cell><cell>Network</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Distribute</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">d Storage</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Unimem exposes a 128-bit global address space consisted of multiple addressable Compute Units that can be addressed natively by low latency, hardware level Load/Store transactions and primitives, without any additional CPU intervention other than issuing the transactions. In order for this local memory to be globally accessible, Brief breakdown of the 128-bit Unimem global address space format the global address of each compute unit maps directly back to the unit's local address. In such a configuration:? Any Processing Element (ex. CPUs) inside a Compute Node can access the full local memory map ? Only a single data owner can cache globally shared memory, thus providing data locality. This ensures optimal performance and memory coherence across the system ? Nodes read/write data coherently with the data-owner ? Native hardware level one-sided communication is provided for Load/Store or atomic operations.</figDesc><table><row><cell>Component</cell><cell cols="2">Width Usage</cell></row><row><cell cols="2">Global Virtual Address 64</cell><cell>Determine the memory page and offset inside the GVAS</cell></row><row><cell>Location coordinates</cell><cell>16</cell><cell>Used for interconnect routing</cell></row><row><cell>User bits</cell><cell>48</cell><cell>Used for a variety of functions, ex. to define the operation type</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This work is supported by the <rs type="funder">European Commission</rs> under the <rs type="programName">Horizon 2020 Framework Programme for Research and Innovation</rs> through the <rs type="projectName">EuroEXA</rs> project (grant agreement <rs type="grantNumber">754337</rs>)</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_4mzEVNk">
					<idno type="grant-number">754337</idno>
					<orgName type="project" subtype="full">EuroEXA</orgName>
					<orgName type="program" subtype="full">Horizon 2020 Framework Programme for Research and Innovation</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>Amba Axi Specs</surname></persName>
		</author>
		<ptr target="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf" />
		<imprint>
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.computinghistory.org.uk/det/8312/Silicon-Graphics-SGI" />
		<title level="m">Silicon Graphics -SGI -Computing History</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://cordis.europa.eu/project/rcn/210095{_}en.html" />
		<title level="m">Innovation and System for Resilient Exascale Computing in Europe: From Applications to Silicon</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The Vulcan Microarchitecture</title>
		<ptr target="https://en.wikichip.org/wiki/cavium/microarchitectures/vulcan" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Shared memory consistency models: A tutorial</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sarita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kourosh</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><surname>Gharachorloo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="66" to="76" />
			<date type="published" when="1996">1996. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Validity of the single processor approach to achieving large scale computing capabilities</title>
		<author>
			<persName><forename type="first">Gene</forename><forename type="middle">M</forename><surname>Amdahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the</title>
		<meeting>the</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1967-04-18">1967. April 18-20, 1967</date>
			<biblScope unit="page" from="483" to="485" />
		</imprint>
	</monogr>
	<note>, spring joint computer conference</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Ammendola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Biagioni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Capuani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Cretaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giulia</forename><surname>De Bonis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesca</forename><forename type="middle">Lo</forename><surname>Cicero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Lonardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Martinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pier</forename><surname>Stanislao Paolucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elena</forename><surname>Pastorelli</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1804.03893</idno>
		<title level="m">Large Scale Low Power Computing System-Status of Network Design in ExaNeSt and EuroExa Projects</title>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Spin-transfer torque magnetic random access memory (STT-MRAM)</title>
		<author>
			<persName><forename type="first">Dmytro</forename><surname>Apalkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Khvalkovskiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Watts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Nikitin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xueti</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Lottis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiseok</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Ong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Journal on Emerging Technologies in Computing Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note>JETC)</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">MCDRAM as High-Bandwidth Memory (HBM) in Knights Landing processors: developers guide</title>
		<author>
			<persName><forename type="first">Ryo</forename><surname>Asai</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<publisher>Colfax International</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Performance analysis for using non-volatile memory DIMMs: opportunities and challenges</title>
		<author>
			<persName><forename type="first">Amro</forename><surname>Awad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clay</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arun</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Hemmert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Hoekstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Memory Systems</title>
		<meeting>the International Symposium on Memory Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="411" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">System-level characterization of datacenter applications</title>
		<author>
			<persName><forename type="first">Manu</forename><surname>Awasthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tameesh</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zvika</forename><surname>Guz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anahita</forename><surname>Shayesteh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mrinmoy</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th ACM/SPEC International Conference on Performance Engineering</title>
		<meeting>the 6th ACM/SPEC International Conference on Performance Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The Portals 4.0 network programming interface</title>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">W</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><surname>Brightwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Hemmert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Pedretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyle</forename><surname>Wheeler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Underwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rolf</forename><surname>Riesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arthur</forename><forename type="middle">B</forename><surname>Maccabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trammell</forename><surname>Hudson</surname></persName>
		</author>
		<idno>SAND2012-10087</idno>
		<imprint>
			<date type="published" when="2012-11">2012. November 2012. 2012</date>
		</imprint>
		<respStmt>
			<orgName>Sandia National Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Impact of the Columbia supercomputer on NASA space and exploration missions</title>
		<author>
			<persName><forename type="first">Rupak</forename><surname>Biswas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dochan</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cetin</forename><surname>Kiris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Lawrence</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd IEEE International Conference on Space Mission Challenges for Information Technology (SMC-IT&apos;06</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multi chip modules</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">P</forename><surname>Richard H Bruce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jackson</forename><surname>Meuli</surname></persName>
		</author>
		<author>
			<persName><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th ACM/IEEE Design Automation Conference</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="389" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">ThunderX2?CN99XXProduct Brief</title>
		<author>
			<persName><surname>Cavium</surname></persName>
		</author>
		<ptr target="https://www.marvell.com/documents/cmvd" />
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Parallel programmability and the chapel language</title>
		<author>
			<persName><forename type="first">David</forename><surname>Bradford L Chamberlain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName><surname>Zima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The International Journal of High Performance Computing Applications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="291" to="312" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Introducing OpenSHMEM: SHMEM for the PGAS community</title>
		<author>
			<persName><forename type="first">Barbara</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tony</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swaroop</forename><surname>Pophale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Poole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Kuehn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chuck</forename><surname>Koelbel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lauren</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth Conference on Partitioned Global Address Space Programming Model</title>
		<meeting>the Fourth Conference on Partitioned Global Address Space Programming Model</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">vNUMA: A Virtual Shared-Memory Multiprocessor</title>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="349" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Cisco UCS B420 M3 High Performance Blade Server Installation and Service Note No Title</title>
		<author>
			<persName><surname>Cisco</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">DATE: ARM proposes ???unit of compute&apos; as basis for energy-efficient systems</title>
		<author>
			<persName><forename type="first">Luke</forename><surname>Collins</surname></persName>
		</author>
		<ptr target="http://www.techdesignforums.com/blog/2013/03/22/date-arm-unit-of-compute-energy-efficient-systems/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">An introduction to CCIX</title>
		<author>
			<persName><surname>Ccix Consortium</surname></persName>
		</author>
		<ptr target="https://docs.wixstatic.com/ugd/0c" />
		<imprint>
			<date type="published" when="2018">2018. 1418_c6d7ec2210ae47f99f58042df0006c3d.pdf</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Gen-Z overview</title>
		<author>
			<persName><forename type="first">Gen-Z</forename><surname>Consortium</surname></persName>
		</author>
		<ptr target="https://genzconsortium.org/wp-content/uploads/2018/05/Gen-Z-Overview-V1.pdf" />
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Interprocessor invocation on a numa multiprocessor</title>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">L</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">J</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><forename type="middle">E</forename><surname>Veenstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>ROCHESTER UNIV NY DEPT OF COMPUTER SCIENCE</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">RapidIO: The Interconnect Architecturefor High Performance Embedded Systems</title>
		<imprint>
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
	<note>System Architecture Manager Dan Bouvier</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Senior Principal Architect</title>
		<author>
			<persName><forename type="first">Inphi</forename><forename type="middle">David</forename><surname>Corp</surname></persName>
		</author>
		<author>
			<persName><surname>Wang</surname></persName>
		</author>
		<ptr target="https://www.eetimes.com/document.asp?doc_id=1280577" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Why migrate to DDR4?</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The BXI interconnect architecture</title>
		<author>
			<persName><forename type="first">Sa?d</forename><surname>Derradji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thibaut</forename><surname>Palfer-Sollier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Pierre</forename><surname>Panziera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Axel</forename><surname>Poudes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fran?ois</forename><surname>Wellenreiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atos</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE 23rd Annual Symposium on High-Performance Interconnects</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="18" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">FaRM: Fast remote memory</title>
		<author>
			<persName><forename type="first">Aleksandar</forename><surname>Dragojevi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dushyanth</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miguel</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orion</forename><surname>Hodson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th {USENIX} Symposium on Networked Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="401" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Euroserver: Energy efficient node for european microservers</title>
		<author>
			<persName><forename type="first">Yves</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">M</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Adami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelos</forename><surname>Bilas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Dutoit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexis</forename><surname>Farcy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgi</forename><surname>Gaydadjiev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Goodacre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Katevenis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Marazakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 17th Euromicro Conference on Digital System Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="206" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">UPC: unified parallel C</title>
		<author>
			<persName><forename type="first">Tarek</forename><surname>El-Ghazawi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lauren</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 ACM/IEEE conference on Supercomputing</title>
		<meeting>the 2006 ACM/IEEE conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">27</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Modelling the ARMv8 architecture, operationally: concurrency and ISA</title>
		<author>
			<persName><forename type="first">Shaked</forename><surname>Flur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathryn</forename><forename type="middle">E</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Pulte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susmit</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Sezgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Maranget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Will</forename><surname>Deacon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Sewell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="608" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Giannis Vardas, Leandros Tzanakis, and Manolis Katevenis</title>
		<author>
			<persName><forename type="first">Dimitris</forename><surname>Giannopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikos</forename><surname>Chrysos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evangelos</forename><surname>Mageiropoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth IEEE/ACM International Symposium on Networks-on-Chip</title>
		<meeting>the Twelfth IEEE/ACM International Symposium on Networks-on-Chip</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
	<note>Accurate congestion control for RDMA transfers</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">Marshall</forename><surname>Gunnell</surname></persName>
		</author>
		<ptr target="https://www.storagereview.com/samsung_begins_7nm_euv_production_unveils_next_generation_nand_ssd_dram" />
		<title level="m">Samsung Begins 7nm EUV Production, Unveils Next Generation NAND SSD &amp; DRAM</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Memory bound vs. compute bound: A quantitative study of cache and memory bandwidth in high performance applications</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Hutcheson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Natoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Technical report</title>
		<imprint>
			<publisher>Stone Ridge Technology</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The 2 petaFLOP, 3 petabyte, 9 TB/s, 90 kw cabinet: a system architecture for exascale and big data</title>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Jacob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="125" to="128" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Memory-systems challenges in realizing monolithic computers</title>
		<author>
			<persName><forename type="first">Meenatchi</forename><surname>Jagasivamani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Candace</forename><surname>Walden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Devesh</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luyi</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Asnaashari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvain</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><surname>Yeung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Memory Systems</title>
		<meeting>the International Symposium on Memory Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="98" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Hbm (high bandwidth memory) dram technology and architecture</title>
		<author>
			<persName><forename type="first">Hongshin</forename><surname>Jun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinhee</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kangseol</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ho-Young</forename><surname>Son</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kwiwook</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hanho</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE International Memory Workshop (IMW). IEEE</title>
		<imprint>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Memory bandwidth limitations of future microprocessors</title>
		<author>
			<persName><surname>Kagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Doug</forename><surname>James R Goodman</surname></persName>
		</author>
		<author>
			<persName><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd Annual International Symposium on Computer Architecture (ISCA&apos;96)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="78" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The exanest project: Interconnects, storage, and packaging for exascale systems</title>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Katevenis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolaos</forename><surname>Chrysos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Marazakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iakovos</forename><surname>Mavroidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabien</forename><surname>Chaix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kallimanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Navaridas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Goodacre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Piero</forename><surname>Vicini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Biagioni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Euromicro Conference on Digital System Design</title>
		<imprint>
			<biblScope unit="page" from="60" to="67" />
			<date type="published" when="2016">2016. 2016</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Turning centralized coherence and distributed criticalsection execution on their head: A new approach for scalable distributed shared memory</title>
		<author>
			<persName><forename type="first">Stefanos</forename><surname>Kaxiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Klaftenegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Magnus</forename><surname>Norgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Ros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantinos</forename><surname>Sagonas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Symposium on High-Performance Parallel and Distributed Computing</title>
		<meeting>the 24th International Symposium on High-Performance Parallel and Distributed Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">TreadMarks: Distributed Shared Memory on Standard Workstations and Operating Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">L</forename><surname>Keleher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandhya</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willy</forename><surname>Dwarkadas</surname></persName>
		</author>
		<author>
			<persName><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Winter</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">1994</biblScope>
			<biblScope unit="page" from="23" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Capacitors with an equivalent oxide thickness of&lt; 0.5 nm for nanoscale electronic semiconductor memory</title>
		<author>
			<persName><forename type="first">Sang</forename><forename type="middle">Woon</forename><surname>Seong Keun Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bora</forename><surname>Hwan Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seungwu</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cheol Seong</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advanced Functional Materials</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="2989" to="3003" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Future of dynamic random-access memory as main memory</title>
		<author>
			<persName><forename type="first">Seong</forename><surname>Keun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Mihaela</forename><surname>Popovici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MRS Bulletin</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="334" to="339" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">NUMA (Non-Uniform Memory Access): An Overview</title>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Lameter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acm Queue</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">40</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Receive-Side Notification for Enhanced RDMA in FPGA Based Networks</title>
		<author>
			<persName><forename type="first">Joshua</forename><surname>Lant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Attwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Navaridas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikel</forename><surname>Lujan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Goodacre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Architecture of Computing Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="224" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Enabling shared memory communication in networks of MPSoCs</title>
		<author>
			<persName><forename type="first">Joshua</forename><surname>Lant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Caroline</forename><surname>Concatto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Attwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose</forename><forename type="middle">A</forename><surname>Pascual</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Ashworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Navaridas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikel</forename><surname>Luj?n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Goodacre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation: Practice and Experience</title>
		<imprint>
			<biblScope unit="page">4774</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Multiprocessor design options and the Silicon Graphics S2MP architecture</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Lenoski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer physics communications</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="page" from="59" to="68" />
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">A performance &amp; power comparison of modern high-speed DRAM architectures</title>
		<author>
			<persName><forename type="first">Shang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dhiraj</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Jacob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Memory Systems</title>
		<meeting>the International Symposium on Memory Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="341" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Marios Asiminakis Nikos Chrysos Vassilis Papaeustathiou Pantelis Xirouchakis Michalis Gianoudis Nikolaos Dimou Antonis Psistakis Panagiotis Peristerakis Giorgos Kalokairinos Manolis Ploumidis, Nikolaos D. Kallimanis and Manolis Katevenis. 2019. Software and Hardware co-design for low-power HPC platforms</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Why on-chip cache coherence is here to stay</title>
		<author>
			<persName><forename type="first">Milo</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Memphis: Finding and fixing NUMArelated performance problems on multi-core platforms</title>
		<author>
			<persName><forename type="first">Collin</forename><surname>Mccurdy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Vetter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 IEEE International Symposium on Performance Analysis of Systems &amp; Software (ISPASS)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="87" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A survey of architectural approaches for managing embedded DRAM and non-volatile on-chip caches</title>
		<author>
			<persName><forename type="first">Sparsh</forename><surname>Mittal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">S</forename><surname>Vetter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1524" to="1537" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Additive interfacial chiral interaction in multilayers for stabilization of small individual skyrmions at room temperature</title>
		<author>
			<persName><forename type="first">Constance</forename><surname>Moreau-Luchaire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Moutafis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Reyren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jo?o</forename><surname>Sampaio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karim</forename><surname>Van Horne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Bouzehouane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><surname>Deranlot</surname></persName>
		</author>
		<author>
			<persName><surname>Warnicke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature nanotechnology</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">444</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Intel? Xeon? Processor Scalable Family Technical Overview | Intel? Software</title>
		<author>
			<persName><forename type="first">David</forename><surname>Mulnix</surname></persName>
		</author>
		<ptr target="https://software.intel.com/en-us/articles/intel-xeon-processor-scalable-family-technical-overview" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">The implications of working set analysis on supercomputing memory hierarchy design</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arun</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Kogge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Underwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th annual international conference on Supercomputing</title>
		<meeting>the 19th annual international conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="332" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Scaling the Computer to the Problem: Application Programming with Unlimited Memory</title>
		<author>
			<persName><forename type="first">Ike</forename><surname>Nassi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="46" to="51" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Latency-tolerant software distributed shared memory</title>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brandon</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brandon</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Preston</forename><surname>Briggs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Kahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Oskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 {USENIX} Annual Technical Conference</title>
		<title level="s">{USENIX} {ATC}</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="291" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Co-Array Fortran for parallel programming</title>
		<author>
			<persName><forename type="first">W</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Numrich</surname></persName>
		</author>
		<author>
			<persName><surname>Reid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Highlights of the high-bandwidth memory (hbm) standard</title>
		<author>
			<persName><forename type="first">Mike</forename><surname>O???connor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Memory Forum Workshop</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Vassilis Papaefstathiou, Pantelis Xirouchakis, Panagiotis Peristerakis, Michalis Giannioudis, and Manolis Katevenis</title>
		<author>
			<persName><forename type="first">Kyriakos</forename><surname>Paraskevas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolaos</forename><surname>Chrysos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Procedia Computer Science</title>
		<imprint>
			<biblScope unit="volume">136</biblScope>
			<biblScope unit="page" from="82" to="90" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
	<note>Virtualized Multi-Channel RDMAwith Software-Defined Scheduling</note>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">In 2011 IEEE Hot chips 23 symposium (HCS)</title>
		<author>
			<persName><forename type="first">Pawlowski</forename><surname>Thomas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="1" to="24" />
		</imprint>
	</monogr>
	<note>Hybrid memory cube (HMC)</note>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Formal requirements for virtualizable third generation architectures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gerald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">P</forename><surname>Popek</surname></persName>
		</author>
		<author>
			<persName><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="412" to="421" />
			<date type="published" when="1974">1974. 1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Another trip to the wall: How much will stacked dram benefit hpc</title>
		<author>
			<persName><forename type="first">Milan</forename><surname>Radulovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darko</forename><surname>Zivanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Ruiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sally</forename><forename type="middle">A</forename><surname>Bronis R De Supinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petar</forename><surname>Mckee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eduard</forename><surname>Radojkovi?</surname></persName>
		</author>
		<author>
			<persName><surname>Ayguad?</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 International Symposium on Memory Systems</title>
		<meeting>the 2015 International Symposium on Memory Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="31" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Phase-change random access memory: A scalable technology</title>
		<author>
			<persName><forename type="first">Simone</forename><surname>Raoux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">W</forename><surname>Burr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">J</forename><surname>Breitwisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">T</forename><surname>Rettner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi-Chou</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">M</forename><surname>Shelby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Salinga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Krebs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shih-Hung</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hsiang-Lan</forename><surname>Lung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">465</biblScope>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Paving the way towards a highly energy-efficient and highly integrated compute node for the Exascale revolution: the ExaNoDe approach</title>
		<author>
			<persName><forename type="first">Alvise</forename><surname>Rigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Pouget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Raho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Dutoit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre-Yves</forename><surname>Martinez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Doran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Benini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iakovos</forename><surname>Mavroidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Marazakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Euromicro Conference on Digital System Design</title>
		<imprint>
			<biblScope unit="page" from="486" to="493" />
			<date type="published" when="2017">2017. 2017</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">IR-drop in on-chip power distribution networks of ICs with nonuniform power consumption</title>
		<author>
			<persName><forename type="first">Josep</forename><surname>Rius</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE transactions on very large scale integration (VLSI) systems</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="512" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Peering over the memory wall: Design space and performance analysis of the Hybrid Memory Cube</title>
		<author>
			<persName><forename type="first">Paul</forename><surname>Rosenfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elliott</forename><surname>Cooper-Balis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Farrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Resnick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Jacob</surname></persName>
		</author>
		<idno>UMD-SCA-2012-10-01</idno>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title level="m" type="main">A high level technical overview of the NumaConnect technology and products</title>
		<author>
			<persName><forename type="first">Einar</forename><surname>Rustad</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title level="m" type="main">The Versatile SMP??? (vSMP)Architecture</title>
		<author>
			<persName><surname>Scalemp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Press release, SGI Altix Again Crushes World Record for Memory Bandwidth</title>
		<author>
			<persName><surname>Sgi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Nonvolatile ferroelectric domain wall memory</title>
		<author>
			<persName><forename type="first">Pankaj</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qi</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Sando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chi</forename><surname>Hou Lei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunya</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiangyu</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valanoor</forename><surname>Nagarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science advances</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">1700512</biblScope>
			<date type="published" when="2017-01">Jan Seidel. 2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">A 4Mb embedded SLC resistive-RAM macro with 7.2 ns read-write random-access time and 160ns MLC-access capability</title>
		<author>
			<persName><forename type="first">Shyh-Shyuan</forename><surname>Sheu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meng-Fan</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ku-Feng</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Che-Wei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu-Sheng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pi-Feng</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chia-Chen</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yih-Shan</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pei-Chia</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wen-Pin</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE International Solid-State Circuits Conference</title>
		<imprint>
			<biblScope unit="page" from="200" to="202" />
			<date type="published" when="2011">2011. 2011</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Highperformance and scalable MPI over InfiniBand with reduced memory usage: an in-depth performance analysis</title>
		<author>
			<persName><forename type="first">Sayantan</forename><surname>Sur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">J</forename><surname>Koop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dhabaleswar</forename><forename type="middle">K</forename><surname>Panda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 ACM/IEEE conference on Supercomputing</title>
		<meeting>the 2006 ACM/IEEE conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">105</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Performance analysis and evaluation of Mellanox ConnectX InfiniBand architecture with multicore platforms</title>
		<author>
			<persName><forename type="first">Sayantan</forename><surname>Sur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">J</forename><surname>Koop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Dhabaleswar</surname></persName>
		</author>
		<author>
			<persName><surname>Panda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">15th Annual IEEE Symposium on High-Performance Interconnects</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="125" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">On the role of NVRAM in data-intensive architectures: an evaluation</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Van Essen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roger</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sasha</forename><surname>Ames</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maya</forename><surname>Gokhale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 IEEE 26th International Parallel and Distributed Processing Symposium</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="703" to="714" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Hitting the memory wall: implications of the obvious</title>
		<author>
			<persName><forename type="first">Wm</forename><forename type="middle">A</forename><surname>Wulf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sally</forename><forename type="middle">A</forename><surname>Mckee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH computer architecture news</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="20" to="24" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">A study of application performance with non-volatile main memory</title>
		<author>
			<persName><forename type="first">Yiying</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Swanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 31st Symposium on Mass Storage Systems and Technologies (MSST)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
