<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast and Memory-Efficient Multi-Agent Pathfinding</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ko-Hsin</forename><forename type="middle">Cindy</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">NICTA</orgName>
								<orgName type="institution" key="instit2">Australian National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Adi</forename><surname>Botea</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">NICTA</orgName>
								<orgName type="institution" key="instit2">Australian National University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fast and Memory-Efficient Multi-Agent Pathfinding</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Multi-agent path planning has been shown to be a PSPACEhard problem. Running a complete search such as A* at the global level is often intractable in practice, since both the number of states and the branching factor grow exponentially as the number of mobile units increases. In addition to the inherent difficulty of the problem, in many real-life applications such as computer games, solutions have to be computed in real time, using limited CPU and memory resources. In this paper we introduce FAR (Flow Annotation Replanning), a method for multi-agent path planning on grid maps. When building a search graph from a grid map, FAR implements a flow restriction idea inspired by road networks. The movement along a given row (or column) is restricted to only one direction, avoiding head-to-head collisions. The movement direction alternates from one row (or column) to the next. Additional rules ensure that two locations reachable from each other on the original map remain connected (in both directions) in the graph. After building the search graph, an A* search is independently run for each mobile unit. During plan execution, deadlocks are detected as cycles of units that wait for each other to move. A heuristic procedure for deadlock breaking attempts to repair plans locally, instead of running a larger scale, more expensive replanning step. Experiments are run on a collection of maps extracted from BALDUR'S GATE 1 , a popular commercial computer game. We compare FAR with WHCA*, a recent successful algorithm for multi-agent path planning on grid maps. FAR is shown to run significantly faster, use much less memory, and scale up to problems with more mobile units.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Multi-agent path planning involves navigating units from their starting positions to their respective goals, whilst going around any static obstacles and other moving units along the way. The problem is important in many real-life applications, including motion planning in robotics <ref type="bibr" target="#b3">(Bennewitz, Burgard, &amp; Thrun 2002)</ref>, air traffic control <ref type="bibr" target="#b12">(Pallottino et al. 2007;</ref><ref type="bibr" target="#b20">Tomlin, Pappas, &amp; Sastry 1998</ref><ref type="bibr">), vehicle routing (Sharma et al. 2007)</ref>, disaster rescue <ref type="bibr" target="#b10">(Kitano et al. 1999)</ref>, and computer games <ref type="bibr" target="#b17">(Silver 2006;</ref><ref type="bibr" target="#b6">Buro &amp; Furtak 2004)</ref>.</p><p>Copyright c 2008, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.</p><p>1 http://www.bioware.com/games/baldurs gate Multi-agent pathfinding is much more challenging than the single agent case <ref type="bibr" target="#b13">(Pearl 1984)</ref>, being a PSPACE-hard problem <ref type="bibr" target="#b9">(Hopcroft, Schwartz, &amp; Sharir 1984;</ref><ref type="bibr" target="#b15">Reif 1979</ref>). The number of states and the branching factor grow exponentially with the number of mobile units on a map, as units move simultaneously. Often, a global search is intractable even for a small number of mobile units. Approaches to address this include manually abstracting a search space, when the actual topology allows it <ref type="bibr" target="#b16">(Ryan 2008)</ref>, and decomposing a problem into smaller searches <ref type="bibr" target="#b17">(Silver 2006)</ref>. Replanning is often used to handle undesired events such as collisions or deadlocks between mobile agents. Trading the method completeness and the solution optimality for improved performance is a typical feature of decentralised approaches, including the method described in this paper.</p><p>In many applications such as computer games, path planning problems have to be solved in real time <ref type="bibr" target="#b5">(Bulitko et al. 2007)</ref>. Often, a search algorithm gets limited access to the CPU and memory resources, which are allocated with higher priority to other game modules such as the graphics engine. A path planning algorithm able to scale up to many agents while using reasonably small resources can make a significant contribution to the overall quality of a game.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>In this paper we introduce FAR (Flow Annotation Replanning), a new method for multi-agent path planning on grid maps. To avoid head-to-head collisions and to reduce the branching factor in search, FAR builds a flow-annotated search graph inspired by two-way roads. The movement along a row (or column) is restricted to only one direction. Two adjacent rows (or columns) have different directions, similarly to the lanes on a two-way road. The idea is applied to all rows and columns, covering the entire map with virtual criss-crossing roads. Additional rules are implemented to guarantee that any two locations connected through a path on the original grid map are still connected in both directions in the flow-annotated graph. An A* search is independently run in the flow-annotated graph for each mobile unit. As soon as a search is completed, the computed path is cached and the memory used by the open and the closed list is released. During the execution of the planned paths, deadlocks are detected as cycles of agents that wait for each other to move. A heuristic method attempts to solve deadlocks locally instead of resorting to a more expensive replanning step.</p><p>FAR is evaluated empirically on a set of maps extracted from BALDUR'S GATE, a popular commercial computer game. We compare FAR with WHCA*, an algorithm for multi-agent path-planning on grid maps. The original WHCA* <ref type="bibr" target="#b17">(Silver 2006)</ref> has recently been enhanced with spatial abstraction <ref type="bibr">(Sturtevant &amp; Buro 2006)</ref>. We use the enhanced version as a benchmark. In experiments, FAR is significantly faster, requires less memory, and scales up to problems with more mobile units.</p><p>The rest of this paper is structured as follows. First we review related work. Next we introduce the problem addressed in this work. A detailed description of FAR follows, after which we present the experimental work. Finally we conclude and outline future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>There is a rich body of literature on multi-agent path planning and great variety in the exact problem that each algorithm is designed to solve. Multi-agent pathfinding work can be grouped into two types of methods. A centralised approach <ref type="bibr" target="#b2">(Barraquand &amp; Latombe 1991;</ref><ref type="bibr" target="#b10">LaValle &amp; Hutchinson 1998</ref>) has a single global decision maker for all agents, is theoretically optimal but, as discussed before, it does not scale up to many agents due to a prohibitive complexity. A decoupled (decentralized) approach decomposes the problem into several subproblems. The latter approach is faster but yields suboptimal solutions and loses the completeness. One such example is prioritised planning <ref type="bibr" target="#b8">(Erdmann &amp; Lozano-Perez 1986)</ref>, which uses prioritisation to assign an order in which the objects move.</p><p>The direct application of A* to multiple agent planning is a game industry standard procedure called Local Repair A*, which performs an expensive full A* for every replan, outlined in <ref type="bibr" target="#b17">(Silver 2006)</ref>. It has drawbacks such as an intensive CPU usage <ref type="bibr" target="#b14">(Pottinger 1999)</ref>, bottlenecks and cycles <ref type="bibr" target="#b0">(Alexander 1992;</ref><ref type="bibr">Stout 1996)</ref>.</p><p>In <ref type="bibr">Silver's work on Cooperative Pathfinding (2006)</ref>, units perform windowed planning from start to goal in a gridbased world. A backwards A* search is initially run for each agent. The results of these searches (i.e., full open and closed lists) are cached and used as a heuristic guidance in subsequent windowed planning steps, so that each unit knows fully the routes planned by other units. Silver's algorithm Windowed Hierarchical Cooperative A* (WHCA*) was later enhanced by Sturtevant and Buro, by combining it with spatial abstraction to improve on WHCA*'s significant memory usage <ref type="bibr">(Sturtevant &amp; Buro 2006)</ref>.</p><p>Ryan 2008 introduces a method for multi-agent path planning. His method is complete but restricted to specific search graphs, which can be decomposed into structures such as chains or rings. A problem is hierarchically decomposed into a global level and a collection of local problems, one for each subgraph such as a chain or a ring.</p><p>Automated spatial abstraction has demonstrated its success in path-finding. As map sizes scale up, searching in a reduced space, as opposed to the large, ground-level space, shows much more effective results. Techniques for abstraction include HPA* <ref type="bibr" target="#b4">(Botea, Müller, &amp; Schaeffer 2004)</ref>, PRA* <ref type="bibr" target="#b17">(Sturtevant &amp; Buro 2005)</ref>. Such methods build abstracted search graphs from a grid map with the goal of speeding up the search in single-agent search. In contrast, our method of abstracting a grid map with flow annotation aims at reducing collisions in multi-agent search.</p><p>Besides grid maps, many other types of methods have been proposed to convert a map into a search graph. Another commonly used representation of the environment is the roadmap, which is a connectivity graph of the map space, as is used for example in <ref type="bibr" target="#b16">(Ryan 2008)</ref>. First and second order Voronoi graphs can be combined to compute a Multiagent Navigation Graph (MaNG) for global path planning, applied to crowd simulation in computer graphics <ref type="bibr" target="#b19">(Sud et al. 2008)</ref>. In robotics, motion planning can be modelled in a 2D plane of objects <ref type="bibr" target="#b11">(Lumelsky &amp; Harinarayan 1997)</ref>. Bounding boxes are used in multi-robot path coordination <ref type="bibr" target="#b11">(Leroy, Laumond, &amp; Siméon 1999)</ref>. Other geometric approaches can model the world as a collection of objects such as polygons <ref type="bibr" target="#b1">(Arikan, Chenney, &amp; Forsyth 2001)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem Definition</head><p>This work assumes that the problem topology is represented as a grid map. Arguably, grid maps are the most popular approach to abstract a real-world navigation map into a search space. The map is discretized into a grid of atomic locations called tiles. Adjacency relationships are defined in eight directions, four cardinal and four diagonal. Tiles with eight movement directions are also called octiles. Each tile is either accessible (traversable) or blocked by a permanent obstacle.</p><p>Each mobile agent occupies exactly one accessible tile at a time. A tile cannot host more than one agent at a time. An accessible tile is free at a given time if no agent occupies it. Agents move between two adjacent positions instantaneously, from one discrete time step to the next. A movement can be performed only if (1) the destination is free at the current time, and (2) no other agent plans to occupy it at the next time step. There is one additional constraint for diagonal moves. They are allowed only if at least one of the two tiles that separate the starting tile from the target is free at the current time (Figure <ref type="figure">1a</ref>). Otherwise, it would be physically impossible to squeeze the agent through two diagonal locations that are each occupied either by an obstacle or by an agent (Figures <ref type="figure">1b and 1c</ref>). The distance travelled is (2) for a diagonal move, and 1 for a cardinal move.</p><p>The standard way to build a search graph from an octile grid map is to define one node for each accessible tile. Undirected edges are defined between adjacent nodes, except for two diagonal tiles separated by two blocked tiles. (See the next section for a search graph enhanced with flow annotation.) In a problem instance, each agent is associated with exactly one start and one target node (tile). A node location cannot host more than one starting position (or more than one target). We assume homogenous agents and uniform speed. After an agent reaches its target, it does not disappear from the map. When an agent sitting on its target interferes with other mobile units, they need to collaborate to solve the interference. A problem is solved when all mobile units sit on their target locations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The FAR Method</head><p>Our goal is to achieve a scalable algorithm while keeping CPU and memory requirements low. FAR starts with a preprocessing step where a grid map is abstracted into a flow-annotated search graph, a structure enhanced with flow restrictions to avoid head-on collisions and to reduce the branching factor in search. Next, a complete A* search is run for each unit independently, computing a path that ignores the other agents on the map. Plan execution starts as soon as a path is computed for each agent. A strategy based on waiting and reservation attempts to avoid deadlocks. A deadlock contains two or more agents that wait for each other in a cycle. When deadlocks cannot be avoided, a deadlock breaking procedure attempts to repair plans locally instead of a larger-scale replanning step. The rest of this section contains details on the method's main steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Flow-Annotated Search Graph</head><p>As outlined in the previous section, grid maps are typically converted into undirected search graphs, where moving between two adjacent locations is allowed in both directions.</p><p>In contrast, we build a directed graph where the navigation flow is better controlled. First, a flow annotation is imposed on the map. Then additional rules are applied to preserve the map connectivity in the new graph. The connectivity is preserved if two locations reachable from each other on the original map are still reachable in both directions in the annotated search graph. Initially no diagonal moves are considered. Relatively few diagonal edges might need to be added later, as will be explained.</p><p>The flow annotation limits the traffic on each row (column) to only one direction. The idea is expanded to cover the entire grid such that nodes in alternating rows have the same horizontal flow, and alternating columns flow in the same vertical direction, as illustrated in Figure <ref type="figure">2</ref>. This can be thought of as an extension of a road system, where we cover the entire grid with crisscrossing virtual roads. The path to a target is likely to involve a longer route with more turns to account for the imposed flow, just like how a driver navigating to her destination in a city has to obey the local traffic flow by following the roads, driving on the correct side of the road, and making turns along the way. In particular, going to a neighbour that used to be adjacent in the undirected graph, but is located at the node against the flow in the flow restricted setting, is now done in at least 3 steps instead of 1. Flow annotation replaces undirected (i.e., bi-directional) edges with directed ones. To preserve the map connectivity, we use additional rules to ensure that each two adjacent nodes remain connected in both directions via a path of one or more steps. It can be easily proven that if any two adjacent nodes are connected in both ways (local connectivity) then any two locations connected on the undirected map remain connected in the flow-annotated graph (global connectivity). We prefer to keep adjacent locations connected through short paths. Otherwise, the quality (length) of paths computed on a flow-annotated map might suffer significantly.  internal nodes, we assume that the map is bordered by a layer of blocked cells. A (single-width) tunnel on a map is a chain of nodes (locations) such that each internal node is connected to exactly two neighbours in cardinal directions.</p><p>A tunnel can be open to both ends (Figure <ref type="figure" target="#fig_3">4</ref>) or only to one end. Edges between the nodes of a tunnel are made bi-directional so that every two nodes along the tunnel are reachable from each other. On certain patterns of blocked cells, such as the source and sink nodes shown in Figure <ref type="figure">5</ref>, we are able to restore the connectivity by adding new diagonal edges. A source is a corner node with two outgoing edges and no incoming edges. To allow mobile units to visit such nodes, we add an incoming diagonal edge. A sink is a corner node with two incoming edges but no outgoing edges. A new outgoing diagonal edge allows units that visit a sink not to get trapped. The diagonal in each case is added when it does not come from another source, or lead into another sink. Figure <ref type="figure">6a</ref> presents a pattern that creates two sink nodes, A and C. The two sinks will not be fixed by having diagonals leading into each other. Instead, making a pair of orthogonal edges bidirectional at either diagonal end, as shown in Figure <ref type="figure">6b</ref>, does the trick. Figure <ref type="figure">6c</ref> shows a pattern with two source nodes. It is handled in a similar manner.</p><p>The intention is to always add new edges in resolving special cases where some default incoming or outgoing flows are blocked off, either by inserting additional diagonals or reverting back to bidirectional edges. We never delete edges from the default flow assignment. Once local connectivity is maintained, global connectivity follows directly.</p><p>The limitation of using only the local configuration of obstacles to revise the annotation is that we can not exploit the overall topology. A "twisted ladder" of trajectories results from the slanted narrow passageway, as shown in Figure <ref type="figure">7</ref>. It would have been better to enable unidirectional diagonal edges in such cases, following the same annotation idea. We revisit problems produced from such closely interwoven col-a b</p><p>Figure <ref type="figure">7</ref>: The "twisted ladder" trajectory.</p><p>lision points at the end of the deadlock section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Executing Plans</head><p>Just as the roads in real life are designed prevent headon car crashes, imposing flow restrictions as outlined in the previous section achieves the same effect. Again, similarly to roads, at junctions, where our "virtual roads" intersect, side-on collisions could still happen quite easily unless our mobile units communicate their intended moves beforehand.</p><p>Our strategy for achieving such collaborative behaviour is founded on two main ideas. Firstly, we try to avoid situations that lead to replanning. Secondly, when replanning has to be done, we try a local, cheap computation instead of an expensive, large-scale search.</p><p>A simple approach that turned out to be effective in reducing potential collisions is to keep paths as straight as possible, since fewer turns reduce the chance for side-on collisions. To favor straighter paths, the A* search that computes a path for a mobile unit has an additional criterion to order the nodes in the open queue. As in standard A*, the main ordering criterion is the f = g + h value. Ties are broken by favoring the successors which continue the current path prefix in a straight line.</p><p>To provide inter-unit cooperation during plan execution, we adopted the temporal reservation idea from <ref type="bibr" target="#b17">(Silver 2006</ref>) such that each unit is able to make its next intended moves known to all other units. Our approach differs however from Silver's: instead of integrating reservation in an expensive online search down to a fixed depth, our units reserve a number of steps ahead on their independently pre-computed paths. The basic idea is that all units must reserve a node prior to moving there. All units make reservations for k steps ahead (where k is a parameter). At the completion of those k moves, the next k steps have to be reserved to continue the execution of the path. A unit can start moving only if it has successfully reserved the next bunch of k steps -unless it is less than k steps away from its target. The node at step i ≤ k in the current sub-sequence can be reserved only if the unit can make the move to the previous location at step i − 1. In an area of high density, where multiple paths intersect the same, "busy" node, neighbouring units coming from orthogonal directions could compete for the same next node. When such conflicts occur, we first allow horizontal movements to have priority, then verticals, alternating in the ensuing time steps. In this way, we impose a temporal flow regulation on top of the spatial one that is annotated on the map. This measure achieves a similar effect as having traffic lights at road intersections.</p><p>Once a unit arrives to its target it stays there by returning the wait action in all subsequent time steps unless it blocks another unit's path. In the latter case, our method forces the blocking unit to take a step away from its target. The blocking unit then uses A* to path-plan back to its original blocking location, always following the annotated flow.</p><p>Another case where the need for replanning arises is when a unit is found to be critical in breaking a deadlock. To break a deadlock, the critical unit inserts a few detour moves into its plan. This is described in detail in the following section. The deadlocks we consider are the circular wait situations described in <ref type="bibr" target="#b7">(Coffman, Elphick, &amp; Shoshani 1971)</ref>. Figure <ref type="figure" target="#fig_4">8</ref> shows an example where four units wait for each other to move in a cycle. Assume they have reached the shown configuration after arriving at the end of their respective kstep reservations. Recall from the restriction stated in our problem definition that a move is not allowed if the target is occupied at the current time, even if the occupying agent plans to leave the position. Since the next locations of the four agents are occupied at the current time step, they are unsuccessful in making new reservations, so each of them waits for one time step before trying again to reserve a new sub-path of k steps. The units are waiting for one another, and no one is able to make further progress. With many units placed on a map, deadlocks can happen quite easily, and propagate quickly as the units in a deadlock could block more units behind them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deadlocks</head><p>When addressing deadlocks, the first step is to identify whether a deadlock has occurred. The condition that triggers the deadlock detection algorithm is that a unit u cannot move at the current step because the next node on its planned path is blocked by a unit who is not on its target. In this case, the deadlock detection needs to be launched. The procedure recursively builds a chain of agents, each waiting for the next one to move, starting from unit u. The check terminates either when it comes across a unit wanting to move to an unoccupied node, in which case no deadlock was detected, or when a unit that is already seen is re-encountered. In the later case a deadlock is discovered. Launching the deadlock detection procedure every time a unit u satisfies the triggering condition is a good trade-off. In most cases, if there is no deadlock then the procedure should terminate quickly, as the detection reaches an unoccupied node. When there is a deadlock, it is better to identify it sooner and deal with it before it propagates into a massive gridlock.</p><p>After identifying all the units in a deadlock, we force a unit called a critical unit to diverge temporarily off its preplanned trajectory, as explained later. The desired effect is that a number of units close to the critical unit are now able to pass through given the freedom from the operated change, ideally leading to more units being free to pass through. After each deadlock breaking maneuver, we call the detection procedure again. If no deadlock is found, then the job is done satisfactorily. Otherwise the original deadlock might have been reduced, rather than eliminated completely, so we repeat the process by selecting a new critical unit.</p><p>Selecting a critical unit is based on a node density heuristic. The density of a node is the number of computed paths that pass through the node. It is continuously updated such that each time a unit moves to its next location, the density count of the previous node is decremented by 1. With each local replan, the count in nodes involved in detours or step-aside trajectories are incremented accordingly. Since the unit in the deadlock who is sitting on the highest density node is likely to be blocking the largest number of units, moving it away might produce the greatest effect on the deadlock (Figure <ref type="figure" target="#fig_5">9</ref>). Thus, among the units that are able to move aside, the one whose position has the largest node density is selected as the critical one.</p><p>The deadlock breaking procedure works as follows. First, the critical unit takes one step away from the deadlock. In most cases (e.g., when no diagonal edges have been added), there are 2 outgoing flows at where the critical unit sits. One direction is that unit's intended move, which goes towards the deadlock (otherwise, the agent wouldn't be part of a deadlock), and hence there is only one other location to step aside to. At the next time step, the critical unit will replan its way back to the previous position. The journey back takes at least three time steps in general. Meanwhile, units blocked by the critical unit have a chance to pass through. The procedure outlined above has shown to be quite effective in practice. Only in cases of narrow passageways that become too congested (Figure <ref type="figure">7b</ref>), a single change made by the critical unit might produce a very limited effect due to the restrictive space and repeated collision points that prevent units from moving along quickly. Then the deadlock breaking works slowly. Fortunately, the modularity of FAR's approach allows different sub-procedures to be implemented in the future for improvement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experimental Results</head><p>Our experiments were run on a 2GHz Intel Core Duo Mac-Book laptop with 1GB of RAM. We used the 10 largest maps (the size of traversable terrain range from 13765 to 51586 tiles) from the BALDUR'S GATE map collection, a standard data set used in several previous studies (e.g., <ref type="bibr" target="#b4">Botea, Müller, &amp; Schaeffer 2004)</ref>. These grid maps are available at http: //users.rsise.anu.edu.au/ ∼ cwang/. For each map, we grow the number of mobile units N by 100 at a time. For each N , we generate 10 problems with the start and target locations randomly placed on the map. The time limit is set to 10 minutes per problem. For each problem, the measured performance parameters are the total search time, the total distance travelled by all units, the maximum size of the open and closed lists in A* search, and the total number of nodes expanded. For each N , we count how many out of the 10 problems are solved successfully.</p><p>We compared FAR with two variations of WHCA*(w, a) <ref type="bibr">(Sturtevant &amp; Buro 2006)</ref>, one with diagonals and the other without (note that Silver's original WHCA* considered cardinal movements only). The parameters are w = 8, a = 1, a combination that seems to work best in the authors' experiments. Currently, parameter k in FAR is set independently from the grid map at hand. A good value that was empirically found is k = 3. For a better understanding of the results, a brief explanation of WHCA*'s main steps is necessary. WHCA* starts with a backwards search from the target to the starting position for each agent. As a result, the perfect distance from each visited node to the target is computed. These distances will be used as a heuristic guidance in subsequent fixed-horizon (i.e., windowed) searches (the h score in A*). The closed and open lists of all initial backward searches have to be kept in memory such that the search can be extended to compute the distance to target for more nodes as required. Every new unit added to the map introduces a new pair of an open and a closed list to be stored in memory.</p><p>Detailed results for one map, selected to be representative for the results on all other maps, are shown in Figure <ref type="figure" target="#fig_6">10</ref>. A summary of the results on all maps is contained in Table <ref type="table" target="#tab_0">1</ref>. Consider Figure <ref type="figure" target="#fig_6">10</ref> first. In terms of memory usage, the requirements of both WHCA* variants grow linearly with the number of agents, whereas FAR stays about constant since it throws away its open and closed lists each time a unit completes its initial A* search. The space requirements for FAR are bounded by the size of the map, just as in a single agent problem. The memory requirements of WHCA* grow linearly in the number of agents.</p><p>In terms of total search time and total nodes expanded, WHCA* faces an exponential growth. In addition to the original backwards searches, WHCA* continuously performs windowed searches to find the next steps in each agent's path. The total search effort in FAR, dominated by its initial A* searches, grows linearly with the number of agents. Replanning is done locally and only when it is necessary to resolve deadlocks. A useful outcome from flow regulation, in addition to reducing collisions, is that the branching factor in search is also reduced.</p><p>As expected, when comparing the total distance travelled by all units to reach their targets, the only algorithm that enables diagonal movements entirely computes the shortest solutions. Compared to this, the overhead in solution quality observed in FAR is reasonably low. The average solution length ratio between WHCA* with diagonals and FAR is 86%. On the other hand, FAR computes better solutions than WHCA* without diagonals. Finally, notice that FAR scales up to problems with more mobile units.</p><p>Table <ref type="table" target="#tab_0">1</ref> summarizes the results on all maps. The three different algorithms scale up to different number of units. To enable a direct comparison between the numbers reported for each algorithm, the data included in all but the last column correspond to the number of agents N where all algorithms solve at least one problem. The last column displays the actual highest number of units that each algorithm can scale up to. Each number in columns 3-6 is averaged over all instances solved for the corresponding number of agents N . The results are consistent with the previous analysis. FAR is much better in terms of memory and CPU requirements. The differences in total travelled distance are small, with FAR coming between the two versions of WHCA*. FAR generally scales up to problems with more units. All methods, being decentralised and therefore incomplete, occasionally fail to solve some instances, especially as N increases. Recall that the data summarized in the table come from the hardest problems solved by all 3 algorithms, corresponding to the largest N where each succeeds at least once.</p><p>A closer look at FAR's performance shows that many of the observed failures are caused by targets placed inside single-width tunnels. Extending FAR to handle such situations better is a main direction for future work. Note that these cases is not always solvable in WHCA* either, if the window size w is not big enough.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion</head><p>We have presented a new algorithm, FAR, that uses approaches such as flow annotation and local plan repair measures to solve difficult multi-agent pathfinding problems. Our results have demonstrated that such procedures can be very effective in many cases. FAR solves problems more quickly and requires less memory than WHCA*. FAR can also solve problems with larger number of units in almost all cases. Like many other approaches in the literature, we trade the completeness for an improved efficiency. Arguably, this is an inherent trade-off to be made in large multi-agent pathfinding problems, given the difficulty of the problem.</p><p>In future work, in addition to handling the single-width tunnels as mentioned before, there are a number of extensions we plan to develop to further improve the performance of FAR. It would be worth performing two complete A* searches in pre-processing. The first would produce a "global traffic report", whereas the second would use this information to avoid potentially congested areas. We plan to structure the flow annotation information hierarchically, to better exploit the topological structure of a map. More ideas on achieving better performance in FAR include enhancing the deadlock breaking heuristic. For example, allow the unit that is closest to escaping from a deadlock to push units out of its way.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 1: (a) To move diagonally, u checks the 2 directly adjacent neighbouring tiles, labelled adjA and adjB, are not both blocking. The cases (b) and (c) are examples where u cannot make the diagonal move.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 2: A classical map at the left and an annotated map at the right. For clarity, diagonal moves are not shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Local connectivity.</figDesc><graphic url="image-6.png" coords="3,408.58,363.23,60.26,57.21" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A single-width tunnel.</figDesc><graphic url="image-7.png" coords="3,408.58,571.54,60.29,59.67" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Deadlock: a cycle of 4 units.</figDesc><graphic url="image-15.png" coords="5,148.08,196.07,50.29,51.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Five units in a deadlock with the node densities labelled at each location. The coloured unit sits on the highest density node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Results from experiments on BALDUR'S GATE map AR0411SR. Note that, for readability, the legend within each graph corresponds to the ordering of the graph lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Results table for the 10 largest maps from BALDUR'S GATE. The winner in each case is shown in bold.</figDesc><table><row><cell>Map</cell><cell>#</cell><cell>Algorithm</cell><cell>Total</cell><cell>Total</cell><cell>Memory</cell><cell>Total</cell><cell>Solved</cell><cell>Max #</cell></row><row><cell></cell><cell>travers-able</cell><cell></cell><cell>Search Time</cell><cell>Distance Trav-</cell><cell>Usage</cell><cell>Nodes Ex-</cell><cell>out of 10</cell><cell>Units Solved</cell></row><row><cell></cell><cell>tiles</cell><cell></cell><cell>(s)</cell><cell>elled</cell><cell></cell><cell>panded</cell><cell>Trials</cell><cell></cell></row><row><cell></cell><cell></cell><cell>FAR</cell><cell cols="2">41 172061.9</cell><cell>19674</cell><cell>3190181</cell><cell>7</cell><cell>1400</cell></row><row><cell cols="2">AR0700SR 51586</cell><cell>WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">114 175738.6 259 151371.4</cell><cell>572697 431613</cell><cell>5155596 8913488</cell><cell>7 7</cell><cell>1000 1000</cell></row><row><cell cols="2">AR0500SR 29160</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">22 121900.0 80 126048.4 203 105869.8</cell><cell>11101 335264 268609</cell><cell>1682771 3901146 7059405</cell><cell>5 5 5</cell><cell>≥1500 1100 1000</cell></row><row><cell cols="2">AR0300SR 26950</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">26 115862.6 87 121810.3 143 100950.8</cell><cell>17577 278323 228299</cell><cell>2721906 4079344 5606509</cell><cell>5 4 5</cell><cell>≥ 1500 800 900</cell></row><row><cell cols="2">AR0400SR 24945</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">26 135986.3 139 138264.8 303 114727.9</cell><cell cols="2">9775 305127 260119 11117252 2238156 6573640</cell><cell>8 4 3</cell><cell>≥1500 1100 1100</cell></row><row><cell cols="2">AR0602SR 23314</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">14 123954.4 116 128571.3 198 103827.0</cell><cell>7904 243843 204235</cell><cell>2101600 5512319 7119173</cell><cell>7 6 9</cell><cell>≥1500 900 1000</cell></row><row><cell cols="2">AR0414SR 22841</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">25 111644.1 101 115891.5 240 99540.7</cell><cell>11557 379538 308056</cell><cell>1756200 4557328 9289430</cell><cell>10 10 10</cell><cell>≥2000 1100 1000</cell></row><row><cell cols="2">AR0204SR 15899</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell>9 108 263</cell><cell>87634.6 94329.2 76194.8</cell><cell>4229 181732 164138</cell><cell>808477 4990668 9427872</cell><cell>7 9 8</cell><cell>≥2000 1200 1100</cell></row><row><cell cols="2">AR0307SR 14901</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell>4 109 203</cell><cell>77647.0 84438.3 67776.0</cell><cell>3133 118077 103695</cell><cell>663099 5435017 7530998</cell><cell>4 3 8</cell><cell>≥1500 1000 1100</cell></row><row><cell></cell><cell></cell><cell>FAR</cell><cell cols="2">7 100767.8</cell><cell>3874</cell><cell>1171818</cell><cell>8</cell><cell>1600</cell></row><row><cell cols="2">AR0411SR 14098</cell><cell>WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">130 106335.3 248 86315.0</cell><cell>164531 143990</cell><cell>6247997 9554315</cell><cell>4 10</cell><cell>1000 1100</cell></row><row><cell cols="2">AR0603SR 13765</cell><cell>FAR WHCA* (no diagonals) WHCA* (with diagonals)</cell><cell cols="2">8 102169.2 112 109636.0 214 85622.5</cell><cell>4561 190422 158887</cell><cell>1126541 5985135 8906368</cell><cell>7 1 8</cell><cell>≥1300 800 900</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0">Proceedings of the Eighteenth International Conference on Automated Planning and Scheduling(ICAPS 2008)   </note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>NICTA is funded by the Australian Government's Department of Communications, Information Technology, and the Arts and the Australian Research Council through Backing Australia's Ability and the ICT Research Centre of Excellence programs.</p><p>Many thanks to Nathan Sturtevant for providing the HOG 2 (Hierarchical Open Graph) framework, and his help with our understanding of the program. Thanks also to Phil Kilby, Jussi Rintanen, Kee Siong Ng and Nick Hay for their many helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A mobile robot navigation exploration algorithm</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Alexander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions of Robotics and Automation</title>
				<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient multi-agent path planning</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arikan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chenney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Forsyth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eurographic Workshop on Computer Animation and Simulation</title>
				<meeting>the Eurographic Workshop on Computer Animation and Simulation</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Robot motion planning: a distributed representation approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Barraquand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Latombe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Robotics Research</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Finding and optimizing solvable priority schemes for decoupled path planning techniques for teams of mobile robots</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bennewitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Burgard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Robotics and Autonomous Systems</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Near optimal hierarchical path-finding</title>
		<author>
			<persName><forename type="first">A</forename><surname>Botea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schaeffer</surname></persName>
		</author>
		<ptr target="http://www.cs.ualberta.ca/∼nathanst/hog" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Dynamic Control in Path-Planning with Real-Time Heuristic Search</title>
		<author>
			<persName><forename type="first">V</forename><surname>Html Bulitko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bjornsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luvstrek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schaeffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sigmundarson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Automated Planning and Scheduling (ICAPS)</title>
				<meeting>the International Conference on Automated Planning and Scheduling (ICAPS)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">RTS games and real-time AI research</title>
		<author>
			<persName><forename type="first">M</forename><surname>Buro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Furtak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Behaviour Representation in Modeling and Simulation Conference</title>
				<meeting>the Behaviour Representation in Modeling and Simulation Conference</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">System deadlocks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Coffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Elphick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shoshani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971">1971</date>
			<publisher>ACM Comput. Surv</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On multiple moving objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Erdmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lozano-Perez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Robotics and Automation</title>
				<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the complexity of motion planning for multiple independent objects: PSPACE-hardness of the &quot;warehouseman&apos;s problem</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sharir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Robotics Research</title>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Robocup-rescue: Search and rescue for large scale disasters as a domain for multi-agent research</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kitano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tadokor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Noda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Matsubara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Takhasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shinjou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shimada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cybernetics</forename><surname>Men</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lavalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Hutchinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Systems</title>
				<meeting>the IEEE Conference on Systems</meeting>
		<imprint>
			<date type="published" when="1998">1999. 1998</date>
		</imprint>
	</monogr>
	<note>Optimal motion planning for multiple robots having independent goals</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Decentralized motion planning for multiple mobile robots: The cocktail party model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Leroy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Laumond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Siméon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Lumelsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Harinarayan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Joint Conference on Artificial Intelligence</title>
				<imprint>
			<date type="published" when="1997">1999. 1997</date>
		</imprint>
	</monogr>
	<note>Multiple path coordination for mobile robots: A geometric algorithm</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Decentralized cooperative policy for conflict resolution in multivehicle systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Pallottino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Scordio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bicchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Robotics</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Heuristics -Intelligent Search Strategies for Computer Problem Solving</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Coordinated unit movement</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Pottinger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Game Developer Magazine</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Complexity of the mover&apos;s problem and generalizations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Reif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Foundations of Computer Science</title>
				<meeting>IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Transfer time complexity of conflict-free vehicle routing with no communications</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R K</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Savchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Voulgaris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The International Journal of Robotics Research</title>
		<imprint>
			<date type="published" when="2007">2008. 2007</date>
		</imprint>
	</monogr>
	<note>Journal of Artificial Intelligence Research</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Cooperative pathfinding. AI Programming Wisdom. Stout, B. 1996. Smart moves: Intelligent pathfinding. Game Developer Magazine</title>
		<author>
			<persName><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Sturtevant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Buro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for the Advancement of Artificial Intelligence (AAAI)</title>
				<imprint>
			<date type="published" when="2005">2006. 2005</date>
		</imprint>
	</monogr>
	<note>Partial pathfinding using map abstraction and refinement</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Improving collaborative pathfinding using map abstraction</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Sturtevant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Buro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial Intelligence and Interactive Digital Entertainment (AIIDE)</title>
				<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Real-time path planning in dynamic virtual environments using multiagent navigation graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Conflict resolution for air traffic management : A study in muti-agent hybrid systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tomlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sastry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
