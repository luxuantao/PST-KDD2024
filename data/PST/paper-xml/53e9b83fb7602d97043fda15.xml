<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interconnection Semantics for Keyword Search in XML</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sara</forename><surname>Cohen</surname></persName>
							<email>sarac@ie.technion.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Yaron</forename><surname>Kanza</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
							<email>bennyk@cs.huji.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Yehoshua</forename><surname>Sagiv</surname></persName>
							<email>sagiv@cs.huji.ac.il</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Technion-Israel Institute of Technology Haifa</orgName>
								<address>
									<postCode>32000</postCode>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Toronto</orgName>
								<address>
									<settlement>Toronto</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">The Hebrew University</orgName>
								<address>
									<postCode>91904</postCode>
									<settlement>Jerusalem</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Interconnection Semantics for Keyword Search in XML</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5313159A321A70E5BDF941C5E52D1EFF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.3 [Information Storage and Retrieval]: Information Search and Retrieval; H.2 [Database Management]: Languages Interconnection semantics</term>
					<term>keyword search</term>
					<term>XML</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A framework for describing semantic relationships among nodes in XML documents is presented. In contrast to earlier work, the XML documents may have ID references (i.e., they correspond to graphs and not just trees). A specific interconnection semantics in this framework can be defined explicitly or derived automatically. The main advantage of interconnection semantics is the ability to pose queries on XML data in the style of keyword search. Several methods for automatically deriving interconnection semantics are presented. The complexity of the evaluation and the satisfiability problems under the derived semantics is analyzed. For many important cases, the complexity is tractable and hence, the proposed interconnection semantics can be efficiently applied to real-world XML documents.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>XML facilitates the incorporation of semantic considerations into information-retrieval. The goal of this paper is to investigate how the labels (i.e., tags) of XML documents can be used for determining whether occurrences of keywords are semantically related. We are motivated by the need to develop techniques for keyword search that hide from the user the complexity of the underneath document and, yet, take into account the semantic structure when ranking results. For example, if the keyword Harris is labeled with Employee and the keyword Jones is labeled with Manager, one might want to determine whether Jones is the manager of Harris. In most systems that incorporate keyword search into relational or XML data (e.g., <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b10">10]</ref>), the sole criterion is proximity (e.g., Jones is deemed the manager of Harris if these keywords appear in a small subtree of the given XML document). In <ref type="bibr" target="#b5">[5]</ref>, it is argued that in a tree document, the keywords are semantically related if they appear in a uniquely-labeled subtree of the document. This approach is extended in <ref type="bibr" target="#b4">[4]</ref> by incorporating information-retrieval techniques. In <ref type="bibr" target="#b17">[17]</ref>, the work of <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5]</ref> is improved by introducing an approach that avoids some cases of incorrect results.</p><p>We generalize and improve all of the above work in two ways. First, we consider XML documents that form arbitrary graphs, due to ID references. Earlier work <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b17">17]</ref> considered only trees, which are easier to deal with, since a tree document has only one minimal subtree that contains a given set of nodes. Second, we propose several different semantics to overcome the problem of wrong answers. Our approach to solving this problem takes the schema into account and, consequently, can handle gracefully missing information. In comparison, the solution of <ref type="bibr" target="#b17">[17]</ref> ignores the schema and applies only to tree documents.</p><p>We investigate the problem of semantic relationships in XML documents from several perspectives. First, we propose a framework that allows either users or creators of XML documents to define explicitly interconnection semantics for the purpose of specifying how objects (i.e., elements) are semantically related. Second, we explore various types of interconnection semantics that can be derived automatically. Third, we analyze the complexity of two problems. One is the evaluation problem, that is, enumerating all the answers to a given query. The second is the satisfiability problem, namely, testing whether some given objects are semantically related. Algorithms for the latter problem can improve keyword search by incorporating into ranking techniques a test of whether occurrences of keywords are semantically related.</p><p>Our complexity analysis considers two measures: data complexity and query-and-data complexity. Since queries are usually of a small size, data complexity is commonly used. However, analyzing the complexity under the assumption that the query has an unbounded size may lead to better, more efficient algorithms; in particular, algorithms that D1 rick@abc.gov The main contributions of this paper are as follows. First, we give a wide spectrum of interconnection semantics that apply to XML documents with ID references. In practical terms, these interconnection semantics differ in their efficiency and recall-precision tradeoff. Second, we provide an exhaustive complexity analysis, including algorithms for the tractable cases. We envision that these algorithms can be combined with information-retrieval techniques to yield powerful systems for keyword search in XML documents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Graphs and Trees</head><p>A graph is a pair G = (V, E), where V is a set of nodes and E ⊆ V × V is a set of edges. A graph is either directed or undirected. We always denote an edge as (v1, v2). If the edge is directed, then (v1, v2) is an ordered pair; otherwise, it is an unordered pair (i.e., (v1, v2) is the same as (v2, v1)).</p><p>A rooted graph is a directed graph that has a designated node r, called the root, such that every node v is reachable from r by a directed path.</p><p>We use two types of trees. A rooted tree is a rooted graph, such that for every node v, there is a unique directed path from the root to v. An undirected tree is a connected undirected graph without cycles (and without a root). Note that when we say "tree," we simultaneously refer to both types.</p><formula xml:id="formula_0">G = (V , E ) is a subgraph of G = (V, E), denoted G ⊆ G, if V ⊆ V and E ⊆ E ∩ (V × V ).</formula><p>A rooted subgraph G of a rooted graph G need not have the same root as G. A rooted subtree is a special case of a rooted subgraph. We also consider undirected subtrees of rooted graphs by ignoring the directions of the edges.</p><p>If G1 and G2 are subgraphs of G, we use G1 ∪ G2 to denote the subgraph that consists of all the nodes and edges of either G1 or G2.</p><p>A rooted tree (respectively, undirected tree) T = (V, E) is reduced with respect to (abbr., w.r.t.) a subset U ⊆ V if it has no proper rooted subtree (respectively, undirected subtree) that includes all the nodes of U .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">O-Graphs and L-Graphs</head><p>An o-graph (and an o-tree) has objects as nodes. An object has an object identifier (abbr. oid) and is assigned a label and, possibly, a value. An l-graph (and an l-tree) has labels as nodes. Figure <ref type="figure" target="#fig_1">2</ref> shows a rooted l-graph S1, two rooted l-trees C1 and C2 and an undirected l-tree C3. The l-trees C1 and C2 are reduced w.r.t. the set of labels {Email, Name}, and the l-tree C3 is reduced w.r.t. {Employee, Name} (and also w.r.t. some other sets of labels, e.g., {Employee, Name, Maintains}). Note that a label occurs (at most) once in an l-graph, but may have multiple occurrences in an o-graph.</p><p>A rooted o-graph D conforms to a rooted l-graph S if the following two conditions hold:</p><p>• l(r) is the root of S, where r is the root of D, and</p><formula xml:id="formula_1">• If (o1, o2</formula><p>) is an edge of D, then (l(o1), l(o2)) is an edge of S.</p><p>For example, the rooted o-graph D1 of Figure <ref type="figure">1</ref> conforms to the rooted l-graph S1 of Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>A rooted o-tree T is isomorphic to a rooted l-tree C if T is uniquely labeled, the labels of T are exactly the nodes in C, and T conforms to C. For example, the rooted subtree of D1 (Figure <ref type="figure">1</ref>) that comprises objects 4, 5 and 6 is isomorphic to the rooted l-tree C1 (Figure <ref type="figure" target="#fig_1">2</ref>).</p><p>For undirected trees, the condition about the roots is removed from the definition of isomorphism. That is, an undirected o-tree T is isomorphic to an undirected l-tree C if T is uniquely labeled, the labels of T are exactly the nodes in C, and for every edge (o1, o2) of T , the edge (l(o1), l(o2)) is in C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Documents and Schemas</head><p>A document is a rooted o-graph and a schema is a rooted l-graph. Figure <ref type="figure">1</ref> shows a document D1 and Figure <ref type="figure" target="#fig_1">2</ref> shows a schema S1. A document D may have a user-supplied schema. Alternatively, we can use the derived schema of D, denoted SD, that consists of the following. The root l(r), where r is the root of D, the labels of D as nodes, and all the edges (l(o1), l(o2)), where (o1, o2) is an edge of D. Note that SD is the minimal schema that D conforms to; that is, if D conforms to S, then SD is a rooted subgraph of S and both have the same root. As an example, the derived schema for D1 (Figure <ref type="figure">1</ref>) is obtained from the schema S1 (Figure <ref type="figure" target="#fig_1">2</ref>) by removing the edge from the label Project to the label URL (since D1 has no edge from a node labeled with Project to a node labeled with URL).</p><p>In the remainder of this paper, when we consider a document D with a schema S, we implicitly assume that D conforms to S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">INTERCONNECTION SEMANTICS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Patterns</head><p>Informally, an interconnection semantics is a collection P of queries. We refer to these queries as patterns and they will be formally defined shortly. A set of nodes O, in a given document D, is interconnected if it is in the result of applying some pattern of P to D. We follow the principle that patterns of P should represent only the basic semantic relationships that exist in D, as opposed to relationships that can be obtained from the basic ones by composition, additional processing, etc. In the parlance of relational databases, it means two things. First, a pattern of P should not have self joins, e.g., it should not represent the manager of the manager of an employee. Second, a pattern of P should not join a pair of attributes in two distinct ways, e.g., the pat-tern could join an employee and a manager by using either the relationship between employees and project managers or the relationship between employees and departments managers, but not by using both relationships. Translating these requirements to documents means that a subgraph of a document D represents a basic semantic relationship if it is a uniquely labeled subtree of D.</p><p>Formally, a rooted (respectively, undirected ) pattern is a pair p = (L, C), where L is a set of labels and C is a rooted (respectively, undirected) l-tree that is reduced w.r.t. L. Note that L includes (at least) all the leaves of C.</p><p>Intuitively, a pattern describes when objects having the labels of L are semantically related. For example, the rooted patterns ({Name,Email}, C1) and ({Name,Email}, C2), where C1 and C2 are shown in Figure <ref type="figure" target="#fig_1">2</ref>, describe when two objects labeled with Name and Email are interconnected in the document D1 (shown in Figure <ref type="figure">1</ref>).</p><p>Formally, let O be a set of objects appearing in a document D. A rooted (respectively, undirected</p><formula xml:id="formula_2">) pattern p = (L, C) interconnects O in D, denoted p |=D O, if l(O) = L</formula><p>and D has a rooted (respectively, undirected) subtree T , such that T includes all the objects of O and is isomorphic to C. Note that a pattern can only interconnect a set of uniquely-labeled objects (and, furthermore, T must be uniquely labeled).</p><p>As an example, consider again D1, C1 and C2. The rooted pattern ({Name,Email}, C1) interconnects the pair of objects <ref type="bibr" target="#b5">(5,</ref><ref type="bibr" target="#b6">6)</ref> and also the pair <ref type="bibr" target="#b19">(19,</ref><ref type="bibr" target="#b20">20)</ref>, while the rooted pattern ({Name,Email}, C2) interconnects the pair <ref type="bibr" target="#b11">(11,</ref><ref type="bibr" target="#b13">13)</ref>.</p><p>Some relationships cannot be captured by any rooted pattern. For example, in document D1, object 19 and object 26 might be deemed meaningfully related, since they are the name of a manager and the employee that maintains the office of that manager, respectively. Yet, there is no uniquely-labeled rooted subtree of D1 that contains both objects 19 and 26; therefore, these two objects are not interconnected by any rooted pattern. Objects 19 and 26, however, are interconnected by the undirected pattern ({Name,Employee}, C3), where C3 is the undirected l-tree shown in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>An interconnection semantics is a set P of patterns. We say that P is rooted (respectively, undirected ) if all its patterns are rooted (respectively, undirected). In principle, an interconnection semantics can also be mixed, i.e., have both rooted and undirected patterns.</p><p>Let D be a document, O be a subset of the objects of D, and P be an interconnection semantics. We say that O is P-interconnected, denoted P |=D O, if P contains a pattern p, such that p |=D O.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Queries and Their Complexity</head><p>In our framework, a query is a set L of labels. Given a document D and an interconnection semantics P, an answer to a query L is a set O of objects, such that l(O) = L and P |=D O. The evaluation problem is essentially an enumeration problem, that is, all the answers to a given query have to be generated successively. The satisfiability problem is that of deciding whether a given set O of objects is interconnected, i.e., whether P |=D O.</p><p>Usually, efficiency of query evaluation is measured in terms of data complexity <ref type="bibr" target="#b20">[20]</ref>; that is, the query is assumed to be of a fixed size. The measure of query-and-data complexity <ref type="bibr" target="#b20">[20]</ref> means that the query (as well as the document) has an un-bounded size. Consequently, the number of answers could be exponential in the input size and therefore, the running time should take into consideration both the input size and the output size.</p><p>Three complexity classes for enumeration problems are proposed in <ref type="bibr" target="#b12">[12]</ref>. Polynomial total time means that the running time is polynomial in the combined size of the input and the output. Incremental polynomial time means that the time needed to generate the ith answer, after the first i -1 answers have already been produced, is polynomial in the combined size of the input and the first i -1 answers. The most efficient notion is enumeration with polynomial delay, that is, the running time between the generation of two consecutive answers is polynomial in the input size.</p><p>In this paper, we analyze the complexity of both the evaluation problem and the satisfiability problem under the two measures mentioned above. Data complexity means that the set O, in the satisfiability problem, and the query L, in the evaluation problem, are of a fixed size. Query-and-data complexity means that the sizes of O and L are unbounded. Note that under data complexity, if the satisfiability problem is in polynomial time, then so is the evaluation problem. Also note that the evaluation problem cannot be in polynomial total time if the non-emptiness problem is intractable, where the latter is the problem of deciding whether a given query has at least one answer.</p><p>If the interconnection semantics P is given explicitly, then it is part of the input. Since patterns are essentially projections of acyclic joins, the following proposition follows from the work of <ref type="bibr" target="#b21">[21]</ref>.</p><p>Proposition 3.1. Let P be an explicit interconnection semantics that is part of the input. The following results hold under query-and-data complexity. The satisfiability problem is in polynomial time. The evaluation problem is in polynomial delay if P has (at most) one pattern for L; otherwise, it is in incremental polynomial time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DERIVED SEMANTICS</head><p>Expressing explicitly all the patterns of an interconnection semantics is not always convenient or practical. As an alternative, we present several interconnection semantics that can be derived automatically from the schema S of the given document D. These semantics may depend on the specific schema S that is used for D. Note that S can be any schema that D conforms to, including the derived schema SD.</p><p>There are two approaches for solving the satisfiability and the evaluation problems when the interconnection semantics is derived from the schema. One is to generate all the patterns that are relevant to the set of labels at hand, thereby obtaining an explicit semantics. This approach is discussed in Section 5. The second approach is to find algorithms that can accept, as part of the input, the schema S rather than the derived semantics itself. In this section, we define the derived interconnection semantics and explore the second approach. Specifically, we give algorithms for the tractable cases. Lower bounds for the intractable cases are summarized in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Semantics P r</head><p>all (S) and P u all (S) Given a document D conforming to a schema S, the interconnection semantics P r all (S) comprises all rooted patterns (L, C), such that L is a set of labels appearing in S and C P r all -Array(D, k) 1: let l1, . . . , lm be the labels of SD, sorted in any topological order 2: let o1, . . . , on be the objects of D, sorted in the order implied on their labels all (S). The interconnection semantics P u all (S) is the set of all undirected patterns (L, C), such that L is a set of labels appearing in S and C is an undirected subtree of S that is reduced w.r.t. L. If P r all (S) |=D O, then P u all (S) |=D O. The advantage of P u all (S) is the ability to interconnect objects even when they are not part of a rooted hierarchy, as shown earlier for document D1 using the undirected pattern ({Name,Employee}, C3).</p><p>We now show that the satisfiability problem for P r all (SD) is in polynomial time under data complexity if SD is acyclic. The algorithm of Figure <ref type="figure">3</ref>   Corollary 4.2. For the semantics P r all (S), the satisfiability and the evaluation problems are solvable in polynomial time, under data complexity, if SD is acyclic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2</head><p>The Semantics P r min (S) and P u min (S) The semantics P r all and P u all occasionally interconnect objects that are rather weakly related to each other. For example, in document D1 (Figure <ref type="figure">1</ref>), object 11 (the name of a project) and object 8 (the URL of a manager) are P r all (S1)interconnected, where S1 is given in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>The above problem can be avoided by adopting the common assumption (e.g., <ref type="bibr" target="#b2">[2]</ref>) that meaningfully-related objects must be close to each other. Thus, for a given schema S, we define the notion of minimal patterns as follows. A rooted (respectively, undirected) pattern p = (L, C) is minimal w.r.t. S if C is a minimal-size rooted (respectively, undirected) subtree of S that includes all the labels of L. Note that since C is minimal, it is also reduced w.r.t. L.</p><p>For example, consider S1, C1 and C2 from Figure <ref type="figure" target="#fig_1">2</ref>. The pattern ({Name,Email}, C1) is minimal w.r.t. S1, but the pattern ({Name,Email}, C2) is not.</p><p>Formally, given a schema S, the interconnection semantics P r min (S) is the set of all rooted patterns that are minimal w.r.t. S. Note that defining P r min (S) in terms of a schema S is not a limitation, because the derived schema can always be used if no schema is explicitly given.</p><p>The semantics P r min (S) gracefully handles missing information. Consider, for example, document D1 (Figure <ref type="figure">1</ref>) and schema S1 (Figure <ref type="figure" target="#fig_1">2</ref>). The fact that S1 has an edge from Project to URL implies that the URL of object 10 is missing from D1. This is realized by the semantics P r min (S1) that does not interconnect object 10 with any object labeled with URL, because the only minimal rooted pattern for the set of labels {Project,URL} is ({Project,URL}, C), where C is the l-tree comprising the single edge from Project to URL.</p><p>The interconnection semantics P u min (S) is defined similarly to P r min (S); that is, P u min (S) is the set of all undirected patterns that are minimal w.r.t. S. The semantics P r min (S) and P u min (S) are incomparable; that is, for some documents and schemas, there are sets of objects that are P r min (S)-interconnected but not P u min (S)-interconnected and vice-versa. Unlike P r all (S) and P u all (S), both P r min (S) and P u min (S) have a tractable data complexity (even if S is cyclic). Testing P r min (S) |=D O is done by computing the sizes n1 and n2 of the minimal rooted subtree of D that contains O and the minimal rooted subtree of S that contains l(O), respectively. It is easy to show that P r min (S) |=D O if and only if n1 = n2. The numbers n1 and n2 can be computed by adapting a known algorithm <ref type="bibr" target="#b6">[6]</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The Semantics P r uca (S)</head><p>The semantics P r min (S) and P u min (S) may occasionally miss meaningfully related objects just because they are slightly too far away from each other. For example, consider document D1 (Figure <ref type="figure">1</ref>), schema S1 and the rooted l-trees C1 and C2 (Figure <ref type="figure" target="#fig_1">2</ref>). The semantics P r min (S1) does not include the pair <ref type="bibr" target="#b11">(11,</ref><ref type="bibr" target="#b13">13</ref>) as an answer for the set of labels {Name,Email}, because the pattern ({Name,Email}, C2) is not minimal w.r.t. S1. Dealing with this problem requires a different notion of minimal rooted subtrees-one that allows to define both ({Name,Email}, C1) and ({Name,Email}, C2) as minimal patterns. This is done as follows.</p><p>Consider an acyclic schema S and a set of labels L. A node l of S is a common ancestor of L in S if every label of L is reachable from l via a directed path in S. A rooted pattern p = (L, C), where C is a rooted subtree of S, is structurally minimal w.r.t. S if the following holds. C does not have any node, other than the root, that is a common ancestor of L in S. For example, the rooted patterns ({Name,Email}, C1) and ({Name,Email}, C2) are structurally minimal w.r.t. the schema S1 (Figure <ref type="figure" target="#fig_1">2</ref>); in fact, these are the only two rooted patterns for the set of labels {Name,Email} that are structurally minimal w.r.t. S1.</p><p>Given an acyclic schema S, the interconnection semantics P r uca (S) (where uca stands for unique common ancestor ) is the set of all rooted patterns that are structurally minimal w.r.t. S. Note that this semantics is only defined for acyclic schemas, since it may yield rather strange results when the schema is cyclic. Clearly, the interconnection semantics P r uca does not have an analogous undirected semantics.</p><p>For document D1 (Figure <ref type="figure">1</ref>) and schema S1 (Figure <ref type="figure" target="#fig_1">2</ref>), the answers to the query {Name,Email}, under the semantics P r uca (S1), are the pairs <ref type="bibr" target="#b5">(5,</ref><ref type="bibr" target="#b6">6)</ref>, <ref type="bibr" target="#b19">(19,</ref><ref type="bibr" target="#b20">20)</ref> and <ref type="bibr" target="#b11">(11,</ref><ref type="bibr" target="#b13">13)</ref>.</p><p>To show that P r uca has a polynomial data complexity, we reduce P r uca -interconnectivity to P r all -interconnectivity as follows. Let D be a document that conforms to an acyclic schema S. Given an instance P r uca (S) |=D O of the satisfiability problem, let A be the set of all common ancestors of l(O) in S. For a label l ∈ A, document D l is obtained from D by deleting all objects o, such that l(o) ∈ A and l(o) = l; in addition, a new root may have to be added to D l . It can be shown that P r uca (S) |=D O if and only if there is an l ∈ A, such that P r all |=D l O. The following is therefore a consequence of Theorem 4.1.</p><p>Corollary 4.5. Let S be an acyclic schema. For the semantics P r uca (S), the satisfiability and the evaluation problems are solvable in polynomial time under data complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SteinerTrees(G, U )</head><p>1: if no rooted subtree of G contains U then 2: return ∅ 3: for all minimal topologies τ of U do 4:</p><p>MaterializeTopology(G, τ ) MaterializeTopology(G, τ ) 1: if τ contains only one node v then 2: return ({v}, ∅) 3: arbitrarily choose a leaf v and an edge (u, v) of τ 4: T1 := MaterializeTopology(G, τv) 5: T2 := MinimalPaths(G, u, v) 6: T := ∅ 7: for all T1 ∈ T1 do 8:</p><p>for all T2 ∈ T2 do 9:</p><p>T := T ∪ {T1 ∪ T2} 10: return T </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Comparing the Derived Semantics</head><p>Figure <ref type="figure" target="#fig_5">4</ref> shows when an interconnection under one semantics is implied by an interconnection under another semantics. Note that the semantics P r min (S), P u min (S) and P r uca (S) are pairwise incomparable. For tree documents, P r min (S)interconnectivity is implied by P u min (S)-interconnectivity. In a case study we conducted, P r uca (S)-interconnectivity was usually implied by P r min (S)-interconnectivity. A special case is when the schema (but not necessarily the document) is a tree. Given a tree schema S and any subset L of the labels of S, there is exactly one rooted subtree of S that is reduced w.r.t. L. Moreover, that rooted subtree coincides with the only undirected subtree of S that is reduced w.r.t. L. Therefore, for all the interconnection semantics considered earlier in this section, the same set of patterns is derived from S. This observation and Proposition 3.1 lead to the following. Corollary 4.6. Let D be a document with a tree schema S. For a set O of an unbounded size, the following are equivalent and can be tested in polynomial time: P r all (S) |=D O, P u all (S) |=D O, P r min (S) |=D O, P u min (S) |=D O and P r uca (S) |=D O. Moreover, under query-and-data complexity, the evaluation problem is solvable with polynomial delay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ENUMERATING PATTERNS</head><p>We conducted a case study of several well-known XML documents and their DTDs (e.g., RSS, DBLP, Mondial and Shakespeare Plays) and concluded that the number of patterns, for a given set of labels, is usually not large (although in some cases this number could be very large). This observation has led us to an alternative approach to solving the satisfiability and the evaluation problems. In this approach, we first generate the patterns that correspond to the labels of the given query (or the given objects) and then employ Proposition 3.1. To make this approach practical, we need efficient algorithms for enumerating the relevant patterns.</p><p>In general, we are given a document D that conforms to a schema S and a set of labels L, where L is either a query or comprises the labels of a given set of objects. The goal is to generate all the patterns of the form (L, C), such that (L, C) is in a given derived interconnection semantics P. We start with the semantics P r min . The problem at hand is to enumerate all the minimal-size rooted subtrees of S that contain L; these subtrees are known as the Steiner trees of L. Traditionally, the Steiner-tree problem <ref type="bibr" target="#b11">[11]</ref> is to find one such tree. We show how to enumerate all Steiner trees of L in polynomial total time, assuming that L has a fixed size.</p><p>The input is a weighted, directed graph G = (V, E, w) and a subset U ⊆ V , where U is of a fixed size (note that w is a positive weight function defined on E). First, we define a key notion as follows. A topology of U in G is a weighted, rooted tree τ = (Vτ , Eτ , wτ ), such that (1) U ⊆ Vτ ⊆ V , (2) every node v ∈ Vτ \ U has at least two outgoing edges in τ , and (3) for all edges e = (u, v) ∈ Eτ , the weight wτ (e) is equal to the weight of a minimal path of G from u to v; if there is no such path, then wτ (e) = ∞. The topology τ of U is minimal if its weight is the minimum among all topologies of U . For example, Figure <ref type="figure" target="#fig_7">6</ref> depicts a graph G1 and three topologies of {u, v, w}. The topology τ1 is minimal.</p><p>It can be shown that a topology of U has at most 2|U | -1 nodes. Therefore, all the topologies of U in G can be found in polynomial time, since U has a fixed size. The algorithm SteinerTrees(G, U ) of Figure <ref type="figure" target="#fig_6">5</ref> enumerates the Steiner trees of U in G by considering each minimal topology τ of U and replacing every edge e = (u, v) of τ with some minimalweight path of G from u to v. The replacements are done by calling MaterializeTopology(G, τ ). Note that, in Line 4, MaterializeTopology calls itself recursively, on a smaller topology, i.e., a leaf v is removed from τ . For every materialized topology T1 that is returned by the recursive call, Lines 7-9 perform all possible replacements of the edge (u, v) with some minimal path T2. The result of each replacement is a Steiner tree T1∪T2, comprising the nodes and edges of T1 and T2, and it is added to T . Due to its simplicity, we omit the description of the algorithm MinimalPaths(G, u, v) for enumerating minimal-weight paths. The running time can be improved to polynomial delay by using coroutines, as done in <ref type="bibr" target="#b16">[16]</ref>. Essentially, the same algorithm applies also to undirected graphs. Thus, for both P r min (S) and P u min (S), all patterns (L, C), for a given L, can be enumerated with polynomial delay.</p><p>Patterns can be enumerated with polynomial delay also in the case of P r all (S), P u all (S) and P r uca (S) by using enumeration algorithms described in <ref type="bibr" target="#b16">[16]</ref> and, in the case of P r uca (S), combining an algorithm of <ref type="bibr" target="#b16">[16]</ref> with the reduction of P r uca (S) to P r all (S) that is described in Section 4.3. Note that the algorithms for enumerating patterns of P r all (S), P u all (S) and P r uca (S) do not assume that L has a fixed size (in contrast to the enumeration algorithms for P r min (S) and P u min (S)). There are also algorithms that enumerate patterns of P r all (S), P u all (S) and P r uca (S) in increasing weight and with polynomial delay, provided that the size of L is fixed. Therefore, if ranking is based on proximity, one can use these algorithms in order to generate query results in a ranked order. See <ref type="bibr" target="#b15">[15]</ref> for more details, including the notion of enumerating patterns in an approximate order. In summary, patterns can be enumerated quickly if there are not too many of them. In any case, since the enumeration is with polynomial delay (in the schema size), the stream of enumerated patterns has a fast flow and the patterns can be used to compute query answers as soon as they are generated. Another advantage is the ability to translate patterns to an XML query language, such as XQuery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">UNIVERSAL INTERCONNECTIONS</head><p>Interconnections semantics have been applied thus far in an existential manner; that is, one evidence for interconnection is sufficient. It is also possible to apply interconnection semantics universally by requiring that there will be an evidence of interconnection in every context implied by the document. For example, in document D1 (Figure <ref type="figure">1</ref>), objects 5 and 13 are P r all -interconnected, because there is a rooted subtree of D1 (with object 2 as its root) that is uniquely labeled and reduced w.r.t. the set of objects {5, 13}. There is also a second rooted subtree (with object 1 as its root) that is reduced w.r.t. {5, 13}. In the context of the second subtree, however, there is no evidence that objects 5 and 13 are P r all -interconnected, because that subtree has two objects, 2 and 15, that are labeled with Department.</p><p>A universal application of an interconnection semantics P depends on how we define the possible contexts of a set O of objects in a document D. Formally, contextsD(O) is a nonempty set of subtrees of D that are reduced w.r.t. O (it is natural to consider only reduced subtrees as possible contexts, since they have no redundant parts as far as the set O is concerned). The exact definition of contextsD(O) may depend on P. Intuitively, O is universally interconnected if every subtree in contextsD(O) is an evidence of interconnection. Formally, we say that O is universally Pinterconnected in D, denoted P |= ∀,D O, if for every subtree T ∈ contextsD(O), there is a pattern (l(O), C) ∈ P, such that T is isomorphic to C. Note that this definition cannot be satisfied vacuously, since contextsD(O) is nonempty.</p><p>In this section, we discuss universal interconnectivity under the semantics P r all and P u all , and we use the following definition of contextsD(O). For a rooted (respectively, undirected) interconnection semantics P, we define contextsD(O) to be the set of all rooted (respectively, undirected) subtrees of D that are reduced w.r.t. O. This definition implies that O is universally P r all -interconnected (respectively, P u allinterconnected) in D if and only if there is no rooted (respectively, undirected) subtree T of D, such that T is reduced w.r.t. O but not uniquely labeled. Hence, P r all , P u all and their universal versions are all equivalent on tree documents (but not on documents conforming to tree schemas).</p><p>Consider document D1 of Figure <ref type="figure">1</ref> and let L be the set of labels {Name,Email}. The set {(5, 6), <ref type="bibr" target="#b19">(19,</ref><ref type="bibr" target="#b20">20)</ref>, <ref type="bibr" target="#b11">(11,</ref><ref type="bibr" target="#b13">13)</ref>} comprises all pairs of objects for L that are universally P r allinterconnected. This set also comprises all pairs of objects for L that are universally P u all -interconnected in D1. As another example, objects 15 (a department) and object 10 (a project) are not universally P r all -interconnected, because the project belongs to more than one department.</p><p>The following important property is instrumental in devel-TSEnumeration(D, L, P) 1: let τ be the minimal topology of L in SD 2: let V be the set of all objects in D with labels from τ 3: Ê := {(o1, o2) | o1, o2 ∈ V , (l(o1), l(o2)) is an edge in τ and P |= ∀,D {o1, o2}} 4: let Ĝ be the o-graph ( V , Ê) 5: let lτ be the root of τ 6: add to Ĝ a new object r that has a new label 7: add to Ĝ edges from r to all objects labeled with lτ 8: let D be the subgraph of Ĝ that is induced by all the objects that are reachable from the root r 9: enumerate all sets O s. all -interconnected if and only if every pair of objects from O is universally P u all -interconnected. Interestingly, a similar result for universal P r all -interconnectivity holds only if the document is acyclic. The next theorem shows that for the interconnection semantics P r all and P u all , universal interconnectivity is more tractable than interconnectivity. Theorem 6.1. The satisfiability problem is in polynomial time under query-and-data complexity in the following two cases. First, the semantics is universal P u all . Second, the semantics is universal P r all and the document is acyclic.</p><p>Obviously, the proof uses the above property. However, it also needs algorithms for testing universal interconnectivity under P r all and P u all when O has only two objects. The details of these algorithms are rather intricate and follow from a close connection between our problems and the subgraph homeomorphism problem <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b19">19]</ref>. Interestingly, if SD is acyclic and D has n objects and m edges, then all the pairs of objects that are universally P r all -interconnected can be found in O(nm)-time. Thus, after this preprocessing, P r all |= ∀,D O can be tested in O(|O| 2 ) time.</p><p>For documents that conform to tree schemas and for the universal version of either P r all or P u all , all the answers to a query L can be enumerated with polynomial delay. The algorithm TSEnumeration(D, L, P) of Figure <ref type="figure" target="#fig_9">7</ref> enumerates all subsets O of the objects of D, such that l(O) = L and P |= ∀,D O, where P is either P r all or P u all . It is assumed that the derived schema SD is a tree. Furthermore, the labels of L appear in SD (otherwise, the result is empty).</p><p>The algorithm is a reduction to the evaluation problem under ordinary (i.e., existential) P-interconnectivity. The first step of the algorithm is to create the minimal topology τ of L in SD (based on the definition of a topology in Section 5). Note that since SD is a tree, the minimal topology is unique and can be found efficiently. Next, Ĝ is the o-graph consisting of all objects o of D, such that the label of o appears in τ . A pair of objects o1 and o2 is connected by an edge in Ĝ if there is an edge between their labels in τ and {o1, o2} is universally P-interconnected in D. The document D is obtained from Ĝ by adding a new root r with a new label lr. There are edges from r to all the objects that have the root of τ as their label. If D has objects that are not reachable from the new root, then they are removed. Line 9 enumerates all subsets O of the objects of</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 1 shows a rooted o-graph D1, where integers are used for oid's, each node has a label, and all the leaves have values. If o is an object, then l(o) denotes the label of o. Similarly, if O is a set of objects, then l(O) denotes the set {l(o)|o ∈ O}. An o-tree is uniquely labeled if distinct objects do not have the same label.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A schema S1, rooted l-trees C1 and C2, and an undirected l-tree C3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>uses dynamic programming in order to decide whether P r all (SD) |=D O, for all sets O of objects in a given document D, such that |O| ≤ k. The output is given by the array I. Upon termination, the value of I[O] is the size of a minimal rooted subtree C ⊆ SD, such that (l(O), C) |=D O; if P r all (SD) |=D O, then I[O] = ∞. Note that the values of I[O] could be used for ranking the results based on proximity, since a smaller value means that the objects of O are included in a smaller subtree of D. Furthermore, the algorithm could be extended to take into account an arbitrary weight function on the edges, thereby enabling a wider range of ranking functions. In Lines 3-5, I[O] is initialized either to ∞, if 1 &lt; |O| ≤ k, or to 0, if |O| = 1. In Lines 6-11, the objects of D are traversed according to a topological order on their labels, as implied by SD. Let o1, . . . , on be the objects of D, sorted in that order. When object oi is visited, we consider all I[O∪{oi}], where O ⊆ {o1, . . . , oi-1} and |O| &lt; k. If O∪{oi} has a repeated label, then I[O ∪ {oi}] is left unchanged. Otherwise, I[O ∪ {oi}] is assigned the minimal value among all I[O ∪ {o}] + 1, where o is some parent of oi in D. Note that all the parents of an object precede that object in the order o1, . . . , on. Hence, for every parent o of oi, the value of I[O ∪ {o}] is already determined when oi is visited.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 4 . 1 .</head><label>41</label><figDesc>Let D be a document with an acyclic SD, and let O be a set of objects of D, such that |O| ≤ k. If P r all (SD) |=D O, then the final value of I[O] is the size of a minimal rooted subtree of D that contains O and is uniquelylabeled; otherwise, I[O] = ∞. The running time of P r all -Array(D, k) is O(mn k-1 ), where n and m are the number of objects and edges of D, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>for finding Steiner trees to directed graphs. Testing P u min (S) |=D O is similar. Theorem 4.3. P r min (S) |=D O and P u min (S) |=D O can be tested in O `nsms + n d m d + (ns + n d ) 3 2 |O| + (ns + n d )3 |O| time, where ns and ms are the number of labels and edges of S, respectively, and n d and m d are the number of objects and edges of D, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A Venn diagram for the derived semantics</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Enumerating Steiner trees</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: A graph G1 and three topologies τ1, τ2 and τ3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Theorem 5 . 1 .</head><label>51</label><figDesc>The algorithm SteinerTrees(G, U ) enumerates all Steiner trees of U in G in polynomial total time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Enumerating results under universal semantics</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>3: for all O ⊆ {o1, . . . , on} s.t. |O| ≤ k do Figure 3: Enumerating results under the semantics P r all is a rooted subtree of S that is reduced w.r.t. L. It is easy to show that a set O of objects is P r all (S)-interconnected in D if and only if D has a uniquely-labeled rooted subtree T that contains O. Thus, determining interconnectivity does not depend on the specific schema that is used for D; that is, P r all (S) |=D O if and only if P r all (SD) |=D O. Hence, by a slight abuse of notation, we may sometimes write P r all instead of P r</figDesc><table><row><cell>4:</cell><cell>if |O| = 1 then I[O] := 0</cell></row><row><cell>5:</cell><cell>else I[O] := ∞</cell></row><row><cell cols="2">6: for i := 2, . . . , n do</cell></row><row><cell>7:</cell><cell>for all O ⊆ {o1, . . . , oi-1} such that</cell></row><row><cell></cell><cell>1 ≤ |O| &lt; k do</cell></row><row><cell>8:</cell><cell>O := O ∪ {oi}</cell></row><row><cell>9:</cell><cell>if O is uniquely labeled then</cell></row><row><cell>10:</cell><cell>for all parents o of oi in D do</cell></row><row><cell>11:</cell><cell>I[O ] = min(I[O ], I[O ∪ {o}] + 1)</cell></row><row><cell cols="2">12: return I</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION AND RELATED WORK</head><p>We have presented a framework for deciding when objects of an XML document are semantically related. Our frame-work includes a wide spectrum of interconnection semantics that apply to XML documents with ID references. Earlier work <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b17">17]</ref> considered only tree documents. Another advantage of our approach is using the schema for deriving interconnection semantics. Note that the derived schema can be used if none is given explicitly. The solution proposed in <ref type="bibr" target="#b17">[17]</ref> for avoiding incorrect answers in tree documents is similar to our P r uca semantics. However, in <ref type="bibr" target="#b17">[17]</ref> only the document is taken into account and hence, their approach cannot detect missing information. The work of <ref type="bibr" target="#b18">[18]</ref> on automatically inferring the structure of documents can also be modeled in our framework, under the reasonable assumption that a subtree of a document indicates a meaningful relationship only if it is uniquely labeled. Future work includes experimentation with our semantics and algorithms, and incorporation of information-retrieval techniques.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> *   <p>The work of this author was supported by the Israel Science Foundation (Grant No. 1032/05).</p><p>† The work of these authors was supported by the Israel Science Foundation (Grant No. 96/01).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In fact, the algorithm is correct not just for P r all and P u all , but also for other interconnection semantics, provided that some conditions are satisfied. Consequently, we get the following theorem. Theorem 6.2. Consider a query L and a document D, such that SD is a tree. Suppose that P is either a rooted or an undirected interconnection semantics that contains a pattern (L, C), such that C ⊆ SD. All the answers to the query L, under universal P-interconnectivity, can be enumerated with polynomial delay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">COMPLEXITY</head><p>Table <ref type="table">1</ref> summarizes the complexity of the satisfiability problem for the different types of derived interconnection semantics. The input consists of a schema S, a document D that conforms to S and a subset O of the objects of D. The top part of Table <ref type="table">1</ref> gives the data complexity and the bottom part-the query-and-data complexity. Note that the problems that are in Π p 2 are also both NP-hard and coNPhard (and in Σ p 2 ). Proofs of the intractability results are given in <ref type="bibr" target="#b14">[14]</ref>. The tractable cases were discussed earlier.</p><p>For the derived interconnection semantics considered in this paper, the data complexity of the evaluation problem is similar to that of the corresponding satisfiability problem. That is, when the satisfiability problem is in polynomial time, then so is the corresponding evaluation problem. When the satisfiability problem is intractable, then so is the corresponding non-emptiness problem, and both problems are in the same complexity class.</p><p>If the schema is a tree, the query-and-data complexity of the evaluation problem is in polynomial delay. However, if the schema is not a tree, then the evaluation problem is intractable, under query-and-data complexity, for all the types of interconnection semantics.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">DBXplorer: A system for keyword-based search over relational databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="5" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Structural proximity searching for large collections of semi-structured data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="175" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Keyword searching and browsing in databases using BANKS</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="431" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">XSEarch: a semantic search engine for XML</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kanza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mamou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="45" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Generating relations from XML documents</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kanza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="285" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Steiner problem in graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dreyfus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="195" to="207" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The directed subgraph homeomorphism problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fortune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wyllie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="11" to="121" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Proximity search in databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shivakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="26" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">DISCOVER: Keyword search in relational databases</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="670" to="681" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Keyword proximity search on XML graphs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Balmin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="367" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Steiner Tree Problem</title>
		<author>
			<persName><forename type="first">F</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Winter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<date type="published" when="1992">1992</date>
			<publisher>North-Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On generating all maximal independent sets</title>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="119" to="123" />
			<date type="published" when="1988-03">March 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the complexity of combinatorial problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="44" to="68" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interconnection semantics for XML. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<ptr target="http://www.cs.huji.ac.il/~bennyk" />
	</analytic>
	<monogr>
		<title level="m">Available at the author&apos;s home page</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>The Hebrew University of Jerusalem</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficient engines for keyword proximity search</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WebDB</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="67" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficiently enumerating results of keyword search</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DBPL</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Schema-free XQuery</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Querying websites using compact skeletons</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Graph minors. XIII. The disjoint paths problem</title>
		<author>
			<persName><forename type="first">N</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Seymour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Combinatorial Theory Series B</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="65" to="110" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The complexity of relational query languages</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Algorithms for acyclic database schemas</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="82" to="94" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
