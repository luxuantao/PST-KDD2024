<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ten Years of Hoare&apos;s Logic: A Survey Part l</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Krzysztof</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Erasmus University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Ten Years of Hoare&apos;s Logic: A Survey Part l</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9E18198D12125747FCBFFC873068A082</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Hoare&apos;s logic</term>
					<term>partial correctness</term>
					<term>total correctness</term>
					<term>soundness</term>
					<term>completeness in the sense of Cook</term>
					<term>expressiveness</term>
					<term>arithmetical interpretation</term>
					<term>while programs</term>
					<term>recursive procedures</term>
					<term>variable declarations</term>
					<term>subscripted variables</term>
					<term>call-by-name</term>
					<term>call-by-value</term>
					<term>call-by-variable</term>
					<term>static scope</term>
					<term>dynamic scope</term>
					<term>procedures as parameters CR Category: 5.24</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A survey of various results concerning Hoare's approach to proving partial and total correctness of programs is presented. Emphasis is placed on the soundness and completeness issues. Various proof systems for while programs, recursive procedures, local variable declarations, and procedures with parameters, together with the corresponding soundness, completeness, and incompleteness results, are discussed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>In 1969 Hoare <ref type="bibr" target="#b27">[27]</ref> introduced an axiomatic method of proving programs correct. This approach was partially based on the so-called intermediate assertion method of Floyd <ref type="bibr" target="#b18">[18]</ref>. Hoare's approach has received a great deal of attention during the last decade, and it has had a significant impact upon the methods of both designing and verifying programs. It has also been used as a way of specifying semantics of programming languages (see <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b40">40]</ref>).</p><p>The purpose of this paper is to present the most relevant issues pertaining to Hoare's method (namely, those of soundness and completeness) in a systematic and self-contained way. The main problem with such an exposition is that various proofs given in the literature are awkward, incomplete, or even incorrect. In many cases proof rules are introduced without any proofs of soundness or completeness at all. The field itself is enormous, since for virtually all programming constructs and notions some proof rules have been suggested. Also, for some constructs, such as recursive procedures with parameters, several alternative proof rules have been proposed.</p><p>Faced by these problems, we decided to restrict the exposition to only those constructs and notions which we found most important. In each case we selected only one, hopefully the most successful, among many possible proof systems.</p><p>Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. This paper is an extended version of a paper presented at the Fifth Scandinavian Logic Symposium, Aalborg, Denmark, January <ref type="bibr" target="#b17">[17]</ref><ref type="bibr" target="#b18">[18]</ref><ref type="bibr" target="#b19">[19]</ref><ref type="bibr">1979</ref> The choice of a semantics for the programming constructs concerned turns out to be the decisive factor for the complexity of the proofs. Therefore, we are at great pains to suggest in each case a semantics which would make the soundness and completeness proofs as simple as possible. The papers we are referring to do not necessarily provide proofs using the same semantics. However, in practically all cases the proofs can be straightforwardly translated (and simplified) into our framework. We refrain from pointing out mistakes and errors in the referenced papers. Many of them can be repaired easily, and many others cannot occur in the suggested semantical framework.</p><p>We found it convenient to divide the subject material in accordance with the constructs of programming languages: while statements (Section 2), recursive procedures (Section 3), local variables (Section 4), subscripted variables (Section 5), parameter mechanisms (Section 6), and procedures as parameters (Section 7). Of course, procedures are but another parameter mechanism. However, procedures as parameters deserve a separate treatment owing to the extensive results concerning them.</p><p>Several other important constructs which are also covered by Hoare's method, such as go-to's, coroutines, functions, data structures, and parallelism, are not treated in this paper. Those interested in the issues raised by these constructs are referred to <ref type="bibr">[14, chap. 10]</ref> (written by A. de Bruin) and to <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b47">47]</ref>. To the reader interested in a more detailed development of the subject we suggest <ref type="bibr" target="#b14">[14]</ref>. The second part of this survey, to be contained in a separate paper, will be devoted to a discussion of various Hoare-like proof systems for nondeterministic and parallel programs.</p><p>It should be mentioned that there are several other approaches to program verification which are related to Hoare's method. These approaches are not discussed in this paper. The interested reader is referred to <ref type="bibr" target="#b22">[22]</ref>, where other methods are discussed.</p><p>Throughout the paper we assume that the reader has knowledge of some basic notions and facts from mathematical logic. We state them whenever they are applied. All of them can be found in, for example, <ref type="bibr" target="#b52">[51]</ref>.</p><p>The title of this paper was perhaps appropriate at the moment of its submission but is not so appropriate now that it appears in print. We decided to retain this title, but to keep the paper up-to-date we took the liberty of incorporating here a few results proved since 1979. Most of them concern the use of procedures as parameters and form the contents of Section 7. The reader deserves a warning that that section deals with the most complex results obtained in this area. For a proper understanding of them, a thorough knowledge of all other sections of the paper is required. Due to the lack of space, the presentation of Section 7 is rather sketchy, and no examples are provided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">while PROGRAMS</head><p>Let L denote a first-order language with equality. We use the letters a, b, x, y, z to denote the variables of L, the letters s, t to denote terms (expressions) of L, the letter e to denote a quantifier-free formula (a Boolean expression) of L, and, finally, the letters p, q, r to denote the formulas (assertions) of L.</p><p>Denote by :~ the least class of programs such that 1. for every variable x and expression t, x := t E ~; and 2. if S, $1, $2 ~ ~, then $1; $2 E 5Zand, for every Boolean expression e, if e then $1 else $2 fi E 5Zand while e do Sod E ~.</p><p>The elements of ~are called while programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Proof System</head><p>The basic formulas of Hoare's logic are constructs of the form (p} S {q} (called asserted programs) where p, q are assertions and S E ~. The formulas are not subject to Boolean operations. The intuitive meaning of the construct (p} S {q} is as follows: whenever p holds before the execution of S and S terminates, then q holds after the execution of S. Hoare's logic is a system of formal reasoning about the asserted programs. Its axioms and proof rules are the following. As usual, p[t/x] stands for the result of substituting t for the free occurrences ofx inp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">An Example of a Proof</head><p>As a typical example of a proof in the system, take for L the language of Peano arithmetic augmented with the minus operation and consider the program So computing the integer division of two natural numbers x and y: a:=0;b:=x;whileb_&gt;ydob:=b-y;a:--a+ lod.</p><p>We now prove that {x-&gt;0Ay----0} So{a. y+ b=xAO &lt;_b&lt;y},</p><p>(1) that is, that if x, y are nonnegative integers and So terminates, then a is the integer quotient of x divided by y and b is the remainder. (*)</p><p>The proof runs as follows. By the assignment axiom, </p><p>Finally, ( <ref type="formula">6</ref>) and ( <ref type="formula" target="#formula_0">12</ref>) imply (1) by the composition rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The Rule of Consequence</head><p>Several remarks are in order. First, to justify the above proof we have to explain how we derived (6) from ( <ref type="formula">5</ref>) and (4) and derived <ref type="bibr" target="#b11">(11)</ref> from <ref type="bibr" target="#b9">(10)</ref> and <ref type="bibr" target="#b8">(9)</ref>. These steps, although intuitively clear, lack a formal basis. The missing proof rule which we used here is the following: RULE 5: CONSEQUENCE RULE P --* Pb (pl} S {ql}, ql ---&gt; q {p) S (q}</p><p>In the example, we used this rule for ql --q, but in general the above version is needed.</p><p>This rule forces us to include assertions among the formulas of Hoare's logic. Denote the resulting system by H. Now, to get <ref type="bibr" target="#b4">(5)</ref> and <ref type="bibr" target="#b9">(10)</ref>, we have to augment H with a formal proof system concerning assertions. In this particular case, any elementary theory T in the underlying L, in which ( <ref type="formula">5</ref>) and <ref type="bibr" target="#b9">(10)</ref> can be proved, will do. The proofs of ( <ref type="formula">5</ref>) and <ref type="bibr" target="#b9">(10)</ref> in T, concatenated with the sequence (2)-{12), (1) of asserted programs or assertions, finally form a proof of (1) in H U T.</p><p>This interpretation is by no means satisfactory for our purposes. We do not care whether <ref type="bibr" target="#b4">(5)</ref> and <ref type="bibr" target="#b9">(10)</ref> are theorems of a theory T. All we need to know is that <ref type="bibr" target="#b4">(5)</ref> and <ref type="bibr" target="#b9">(10)</ref> are true in the domain of integers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Soundness of H</head><p>Let A be a set of assertions. Let us write A b-H {p} S {q} to denote the fact that there exists a proof of {p} S (q} in H which uses as assumptions (for the consequence rule) assertions from A. We have thus shown that ( <ref type="formula">5</ref>), <ref type="bibr" target="#b9">(10)</ref> b-H {1). The whole idea of the above proof is that we wish to interpret (1) as {*). To do this, we must first introduce the notion of the truth of an asserted program under an interpretation I of the language L. In this case we choose for I the standard interpretation I0 of L with the domain of integers.</p><p>So let I be an interpretation of L with a nonempty domain D. By a state we mean a function assigning to each variable x a value from the domain D. We use the letters 8, T to denote states.</p><p>The relation "under the interpretation I an assertion p is true in a state &amp;" written as ~zp(~), is defined in the usual way. If for all states ~ ~zp{8) holds, we say that p is true under I, written ~z P. With each program S E ~ we can associate a meaning ~t/l(S) under/, this being a partial function from states to states. It is easy to define ~I(S) so as to capture the intended meaning of the program.</p><p>Having done so, we can finally define the truth of an asserted program under /. We say that an asserted program {p} S {q} is true under I if for all states 8, v, if mlp <ref type="bibr" target="#b7">(8)</ref> and ~I(S)(8) = T, then ~i q(v). This definition is clearly a correct formalization of the informal notion of the truth of (p} S {q}. We can now safely state that (*) simply says that (1) is true under I0.</p><p>The last step in the justification of (*) is the following. Call an asserted program valid if it is true under all interpretations/. Call a proof rule sound if for all interpretations I it preserves the truth under I of the asserted programs (and, in the case of the consequence rule, assertions). It is easy to prove that the axioms of H are valid and the proof rules of H are sound.</p><p>This fact implies (by induction on the length of proofs) the following theorem, which states that the proof system H is sound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THEOREM 1. For every interpretation I, set of assertions A, and asserted program cp the following holds: if all assertions from A are true under I and A ~-H ¢p, then cp is true under I.</head><p>In other words, if Trz t--H (p, then mz ¢p, where Trz denotes the set of all true assertions under/.</p><p>This theorem immediately implies that (1) is true under Io, because obviously (5) and <ref type="bibr" target="#b9">(10)</ref> are true under I0. (1) is actually true under any interpretation I under which <ref type="bibr" target="#b4">(5)</ref> and <ref type="bibr" target="#b9">(10)</ref> are true. So, for example, (1) is also true under the standard interpretation in the real numbers or in a finite set of natural numbers {xlx &lt;_ max},</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Loop Invariants</head><p>Like all formal proofs, the proof of ( <ref type="formula">1</ref>) is tedious and difficult to follow. We are not accustomed to following a line of reasoning expressed in such small steps. However, it is easy to observe that the whole argument boils down to one crucial step: observing that (11) holds. Once we guess the assertion r = a • y + b = x A b ___ 0, to find the proof is a straightforward problem. Since (11) holds, r is called an invariant of the loop while b &gt;_ y do b := b -y; a := a + 1 od. Since (6) holds, we say that the program a := 0; b := x establishes r. Since ( <ref type="formula" target="#formula_0">12</ref>) holds, we say that the program while b _ y do b := b -y; a := a + 1 od preserves r.</p><p>A concise way of embedding this information into the program S is simply to annotate it with the desired assertion(s). To illustrate this point, we now take a different example. It is easy to see that In both cases it is Theorem 1 which allows us to infer that the asserted programs are true under Io.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Termination Not Implied</head><p>It is important to note that the above proofs are not concerned with the termination of programs. Even though (1) is true under I0, we do not have any guarantee that the program So terminates. In fact, in a state in which the value of y is 0, So does not terminate. While defining the meaning of programs, we left room for nontermination by allowing J4z(S) to be a partial function from states to states.</p><p>Actually, the termination of a program is interpretation-dependent. For example, the program while x :&gt; 0 do x := x -1 od under the interpretation Io always terminates (is total), whereas under an interpretation in a nonstandard model of Peano arithmetic it is not total. This simple remark has direct consequences concerning the existence of sound proof systems dealing with termination, as we see in Section 2.11.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">The Issue of Completeness of H</head><p>A natural question of not only theoretical interest is that of the completeness of the proof system H. The question of soundness concerns the correctness of the method, whereas the question of completeness concerns the scope of its applicability (under what circumstances it can be successfully applied).</p><p>The system H alone is obviously incomplete: an asserted program {p[t/x]} x := t (true} is true under every interpretation and yet is unprovable in H; there is no way to prove in H the formula p ---) true.</p><p>Supplementing H by an axiomatic system T dealing with assertions is of no help. For any axiomatic system G the set of asserted programs provable in G is recursively enumerable (r.e.) But for the language Lp of Peano arithmetic with its standard interpretation IN the set Tr1~ is not r.e. (see <ref type="bibr" target="#b52">[51]</ref>), and for all assertions p ~I N {true} x := x {p} iff ~IN P; so the set of asserted programs true under IN is not r.e. either. This shows that in the case of the language Lp any axiomatizable deduction system dealing with the asserted programs is incomplete.</p><p>One might think that the incompleteness comes from allowing arbitrary first order formulas as assertions. However, this is not true, as the following argument shows (see <ref type="bibr" target="#b13">[13]</ref>}. For any interpretation I and program S, ~x (true} S {false} iff S fails to halt for all initial values of its variables. Therefore, the following holds.</p><p>Fact. Let ~0 be a class of programs. If L,/, and 5fo are such that the halting problem of :To for I is undecidable, then the set { (true} S {false} I ~z (true} S (false}, S ~ ~o} is not r.e. Now, the halting problem of 5~ for IN is undecidable, so the restriction of the assertion language to (true, false} cannot lead to completeness either.</p><p>The best one might hope for would be to prove relative completeness of the system H, which would be a converse of Theorem 1: For all interpretations I and all asserted programs qp, if ~z cp, then Trl t--H ¢p.</p><p>Unfortunately, even this cannot be proved. Wand <ref type="bibr" target="#b55">[54]</ref> exhibited a particular language L with an interpretation I and asserted program (p such that mz (p and Tr~ bLH Cp. The incompleteness comes from the fact that the necessary intermediate assertions cannot be expressed in L with this particular interpretation.</p><p>We now present a simple argument leading to an extension of this incompleteness result. Consider the language L÷ of Presburger arithmetic, that is, the language Lp of Peano arithmetic without the multiplication operation. Let I+ be its standard interpretation. By the result of <ref type="bibr" target="#b50">[49]</ref>, Trz+ is a recursive set. Therefore, for any axiomatic system G the set of asserted programs ~ such that Trz+ }--G cp is r.e.</p><p>On the other hand, the halting problem of £f for I÷ is undecidable, since the halting problem of 5 z for IN is undecidable and multiplication can be simulated in ~f using addition. Therefore, by the Fact above, the set of asserted programs true under/+ is not r.e. This shows that no axiomatic system G can be relatively complete for ~.</p><p>This argument is a special case of a general incompleteness result proved in <ref type="bibr" target="#b4">[5]</ref>. Various other natural structures leading to incompleteness are also exhibited there. The above argument is also implicit in <ref type="bibr" target="#b13">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.8">Completeness of H in the Sense of Cook</head><p>A way to overcome these difficulties while defining the notion of completeness has been indicated by Cook <ref type="bibr" target="#b13">[13]</ref>. Define</p><formula xml:id="formula_1">postz(p, S) = (~: 38 [~zp(8) A JZz(S)(8) = T]}; prez(S, q) = (8:Vr [~/z(S)(8) = T--* I=z q(~)]).</formula><p>Note that these sets are characterized by the following equivalences: ~i {p ) S {q} iff {8 : m,p( <ref type="formula">8</ref>)) C pre,(S, q) iff post,(p, S) C (8 : ~i q(8)}. Now let ~0 be a set of programs. Call the language L expressive relative to I and ~o if for all assertions p and programs S E ~o there exists an assertion q which defines post1(p, S) in L (i.e., such that (8 : ~l q(8)} = postl(p, S)). If I is such that L is expressive relative to I and ~o, we write that I ~ Exp(L, ~o).</p><p>Definition. A proof system G for 5z0 is complete in the sense of Cook if, for every interpretation I E Exp(L, ~o) and every asserted program ~, if m~ ~, then Tr~ t-o cp.</p><p>The results of <ref type="bibr" target="#b13">[13]</ref> imply that the proof system H for ~ is complete in the above sense. The proof of completeness proceeds by induction on the structure of programs. Let I ~ Exp(L, ~).</p><p>If ~ (p} x := t (q}, then clearly mzp --* q[t/x]; so, by the assignment axiom and the consequence rule, Trl I--H {p} X := t (q).</p><p>If ~I {p) $1; $2 (q), then clearly ~i {p) $1 {r} and ~z (r) $2 {q}, where r defines postz(p, $1); so, by the induction hypothesis and the composition rule, Trl t-, (p) 81; $2 (q}.</p><p>The case of if e then $1 else $2 fi is straightforward. If ~z {p) while e do Sod (q}, then we must find a loop invariant r such that ~i (r A e) S {r), ml p ---) r, and ~z (r A e) ---) -~q. Then, by the induction hypothesis, Trl t--H (p) while e do Sod (q}.</p><p>Consider the set C = (8 : 3k, 8o .... , ~k <ref type="bibr">[8 =</ref> ~k A ~Ip(~o) A Vi &lt; k [,//~I(S)(~/) ffi 3i+1 A ~I e(Si)]]).</p><p>Thus 8 E C iff there exists a computation which starts in a state satisfying p and which reaches state 8 after some finite number of passes through the loop. It is clear that an assertion r defining C satisfies the above three conditions. To find such an assertion, consider the list yl ..... y, of all variables which occur free in p, e, S, or q. Let rl be the assertion which defines posti(p, while e /k (yl # Za k~ 3'2 # z2 k~ "" k~ yn # Zn) do Sod), where zl ..... z, are new variables.</p><p>If ~ E C, then ~i 3Zl ..... z,r~ <ref type="bibr" target="#b2">(3)</ref>, where the values chosen for zi (i = 1 ..... n) are correspondingly 3(yi) (i = 1 ..... n). The implication ~r ~Zl ..... Znrl(~) ---&gt; ~ ~ C is obvious. Hence r -3z1 ..... Znr~ is the desired assertion. Clarke <ref type="bibr" target="#b8">[9]</ref> observed that if, in the definition of expressiveness, we change the requirement of definability of postx(p, S) to that of definability of predS, q), then the above proof (viz., the last case) can be simplified. Namely, for the invariant r we can simply take an assertion which defines prel(while e do Sod, q). This proof also shows that, when using the requirement of definability of prez(S, q) in the definition of expressiveness, it is not necessary to assume that the equality predicate is in the language L.</p><p>We chose here Cook's original definition of expressiveness, since the completeness result in the form just proved is used in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.9">Expressiveness</head><p>As indicated by Clarke <ref type="bibr">[10a]</ref> and rigorously proved by Olderog <ref type="bibr" target="#b44">[44]</ref>, these two definitions of expressiveness are actually equivalent for any class of programs considered in this paper. To give an idea of the proof, assume that, for any p and S, posti(p, S) is definable. Consider a program So. Let E be a sequence of all variables occurring in So and let 5 be a sequence of some new variables of the same length as E. Now let q0 be an assertion which defines postz(E = 5, So). It is easy to see that, for any q, prez(S0, q) is definable by the formula (VE (q0 --* q)) [~/5].</p><p>A similar construction proves the converse implication. It is worthwhile to note that the formulas {E --5} So {qo} play an important role in the completeness proofs in Section 3.</p><p>A natural question now arises: how restrictive is the assumption of expressiveness? Observe that Lp is expressive relative to IN and ~. Thus, any true (under IN) asserted program can be proved in H provided we can "ask" an oracle about the truth of the assertions under IN. Also, as Clarke <ref type="bibr" target="#b8">[9]</ref> observed, if the domain of I is finite, then L is expressive relative to I and ~.</p><p>It turns out that these are actually the only two possibilities. The following theorem is a special case of a theorem proved by De Millo, Lipton, and Snyder (see <ref type="bibr" target="#b38">[38]</ref>): THEOREM 2. If L is expressive relative to I and 5~, then either 1. a standard model of Peano arithmetic can be defined in I, or 2. VS E ~ 3n such that S reaches at most n states in any computation over the domain of I with any initial state.</p><p>In the previous section we saw that expressiveness is a sufficient condition for completeness. Is it a necessary condition as well? The answer is no, and the following argument due to Bergstra and Tucker <ref type="bibr" target="#b5">[6]</ref> gives evidence for it.</p><p>There exists a nonstandard model of Peano arithmetic with an interpretation I such that Trl = Trl~. It is a direct consequence of the compactness theorem (see <ref type="bibr" target="#b52">[51]</ref>). It is now easy to see that, for any asserted program ~, if ~i cp, then~1~ ¢p. Thus, for any ~, ml ~ implies ~IN ~, which in turn implies Trl N ~--H ~ by the justproved Cook completeness result; so finally Tr~ ~--H q) by the choice of/.</p><p>On the other hand, Lp is not expressive relative to I and ~. This follows from Theorem 2, but of course a straightforward argument can be given. Namely, consider the program S -= while x &lt; y do x :-x + 1 od. This program terminates on I when started in a state o in which x = 0 iff o(y) is a standard natural number. Thus, postz(x = 0, S) = {o : o(x) = o(y)/ky is a standard natural number}. But this set is not definable in I by any formula q of Lp. Otherwise, we could prove by the induction axiom that ~z Vx, y q, which is not the case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.10">Complete Assertion Classes</head><p>The completeness of H and the expressibility of Lp relative to IN and ~fimply that, if ~tN {P} S (q}, then there exists a proof of {p} S {q} in H (fromTriN) which uses only arithmetical assertions. In typical proofs much simpler assertions are used.</p><p>A global correctness property {p} S (q} in practice has recursive assertions 1 p and q. The precondition p is usually some simple condition on the input variables, or even true. Similarly, one may expect that the postcondition q can be checked effectively by inspection of the output variables. A natural conjecture then is that all (intermediate) assertions needed in the proof of (p} S (q} in H may also be chosen to be recursive.</p><p>Let A be a set of assertions. Let us write ~H,A {P} S {q} to denote the fact that there exists a proof of {p} S {q} in H (fromTrt~ O A) in which only assertions from A occur. We call a class of assertions A complete (with respect to 5 z) if for every p, q @ A and S E ~fwe have ~i N {p} S {q} iff~--H,A (p} S (q}. In <ref type="bibr" target="#b1">[2]</ref> it is proved that any class of recursive assertions A which contains true and false is incomplete; so the above conjecture is false. On the other hand, the class of recursively enumerable assertions and various other natural classes are complete.</p><p>We can, however, get completeness of the class of recursive assertions for ~z if we extend the proof system H by adding to it the following proof rule concerning deletion of assignments to the auxiliary variables.</p><p>Let AV be a set of variables which appear in S' only in assignments x := t, where x is in AV. If p and q do not contain free variables from AV and S is obtained from S' by deleting all assignments to the variables in AV, then {p} S' (q} {p} S {q} " This rule is from <ref type="bibr" target="#b47">[47]</ref>, where it was used in the proof system for verification of parallel programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">1 Total Correctness</head><p>By distinguishing between partial and total correctness, we stress the fact that termination is not dealt with in H. We say that a program S is partially correct under I (with respect to p and q) if ~ {p} S {q}. In contrast, we say that a program S is totally correct under I (with respect to p and q), written I~i {p} S {q}, if additionally the termination of S is guaranteed. Thus, I~i {p} S {q} holds iff for all states ~ such that ~zp <ref type="bibr" target="#b7">(8)</ref> there exists a state r such that ~dS) (~) = ¢ and ~i q(T).</p><p>Thus H is a proof system for partial correctness. It is clear that the only proof rule of H which introduces a possibility of nontermination is the while rule; so to deal with total correctness that rule has to be changed.</p><p>The following refinement of the while rule leading to total correctness has been formulated in <ref type="bibr" target="#b23">[23]</ref>. and apply the consequence rule and the composition rule. Call a proof system G totally sound if, for all interpretations I and asserted programs q~,Trz [-G ~ implies I~i ¢p. We would like to require any proof system for total correctness, including Ho, to be totally sound. Note that total soundness of H0 would imply that So is totally correct under Io with respect to x _ 0 A y &gt; 0 and a • y + b = x A 0 _ b &lt; y, thus completing the above reasoning. Unfortunately, any totally sound proof system is hopelessly weak, as the following theorem shows. THEOREM 3. There does not exist a proof system G such that 1. G is totally sound and 2. Trio ~--G {true} S~ {true} where S~ -while x &gt; 0 do x := x -1 od.</p><p>PROOF. The proof is immediate. Namely, suppose that a proof system G satisfies 1 and 2. As we did in Section 2.9, take a nonstandard model of Peano arithmetic with an interpretation I such that Trz --Trio. Now, by 2, Trl ~-G (true} $1 (true} ; so, by 1, I~ (true} $1 (true}. The latter is, however, a contradiction, since it states that $1 is total under an interpretation in a nonstandard model of Peano arithmetic. [] Therefore, when dealing with proof systems for total correctness we have to find another notion of soundness. One possibility is to restrict attention to one interpretation only, namely, IN (or a minor extension of it like I0). However, this is not a satisfactory choice, as it would force us to allow one assertion language only: that of Peano arithmetic. A more satisfactory proposal has been indicated by Harel <ref type="bibr" target="#b23">[23]</ref>.</p><p>Let L be an assertion language and let L + be the minimal extension of L containing the language Le of Peano arithmetic and a unary relation nat(x). Call an interpretation I of L ÷ arithmetical if its domain includes the set of natural numbers, I provides the standard interpretation for Le, and nat(x) is interpreted as the relation "to be a natural number." Additionally, we require that there exist a formula of L ÷ which, when interpreted under/, provides the ability to encode finite sequences of elements from the domain of I into one element. (The last requirement is needed only for the completeness proof.)</p><p>One of the examples of an arithmetical interpretation is of course IN. It is important to note that any interpretation of an assertion language L with an infinite domain can be extended to an arithmetical interpretation of L ÷. Clearly, the proof system Ho is suitable only for assertion languages of the form L ÷, and an expression such as p(n + 1) is actually a shorthand for nat(n + 1) A p(n + 1).</p><p>We now say that a proof system G for total correctness is arithmetically sound if, for all arithmetical interpretations I and asserted programs ~, Trz ~---V (~9 implies I~z ¢p.</p><p>Harel <ref type="bibr" target="#b23">[23]</ref> showed that the proof system H0 is arithmetically sound. He also proved that H0 is arithmetically complete, that is, that an implication converse to the one above holds.</p><p>The completeness proof runs by induction on the structure of programs, and only the case of the while construct is different from the corresponding case in the completeness proof of H.</p><p>Assume J~z (r)while e do Sod (q} where I is an arithmetical interpretation. Let n be a fresh variable. Consider the following set of states:</p><formula xml:id="formula_2">C -{8 : ~I nat(n) (8) A "~0 .... , ~k [8 = ~0 A ~Z (q A me)(~k) A Vi &lt; k [Jg1(S)(Si) = 8i÷1 A ~ e(t}i)]], where k = 8(n)).</formula><p>Thus 8 E C iff 8(n) is a natural number, say k, such that the loop in while e do S od is executed exactly k times when started in ~ and the final state satisfies q.</p><p>-It can be shown (thanks to the provision for coding of finite sequences) that there exists an assertion p(n) which defines C. It is easy to see that ~z p(n + 1) ----&gt; e, liar (p(n + 1)} S (p(n)}, and ~i p(0) -* -~e. Thus, by the induction hypothesis and the new rule, Trz I--Ho(3n p(n)) while e do S od {p(0)). To complete the proof it is now sufficient to observe that, by the assumption, ~z r ----&gt; 3n p(n) and ~z p(0) --* q and to apply the consequence rule.</p><p>It should be stressed that Theorem 3 applies to the notion of arithmetical soundness as well. However, in any language of the form L ÷ one can speak about "standard" natural numbers; so the formula to be proved can now be phrased as {nat(x)) S~ (true}, and this version can be proved. This shows that the essence of Harel's approach lies in the ability to speak in any assertion language of the form L ÷ about natural numbers together with the restriction on the interpretations assuring that these are the "standard" natural numbers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.12">Bibliographical Remarks</head><p>The proof system H (with the exception of Rule 3) and the example in Section 2.2 are from <ref type="bibr" target="#b27">[27]</ref>. Rule 3 is from <ref type="bibr" target="#b37">[37]</ref>, which also contains the first proof of soundness of (an extension of) H. The terminology of "establishing" and "preserving" an invariant, as well as the example in Section 2.5, is from <ref type="bibr" target="#b16">[16]</ref>. The idea of annotating a program with the relevant assertions is first expressed in <ref type="bibr" target="#b37">[37]</ref>. A different proof of Wand's incompleteness result is given in <ref type="bibr" target="#b24">[24]</ref>. The incompleteness of the class of recursive assertions and the completeness of the class of recursively enumerable assertions mentioned in Section 2.10 are also proved in <ref type="bibr" target="#b39">[39]</ref>. In <ref type="bibr" target="#b53">[52]</ref> a completeness result similar to that of Section 2.11 is presented. The first proof rules for total correctness of while programs within the framework of Hoare's logic are presented in <ref type="bibr" target="#b42">[42]</ref>. In <ref type="bibr" target="#b22">[22]</ref> various proof rules for total correctness of while programs presented in the literature are discussed and compared.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PARAMETERLESS PROCEDURES</head><p>For clarity, we have separated the issues concerning procedures from those of scope and parameter mechanisms. Parameterless procedures are discussed next; the treatment of parameters is in Section 6. To simplify the discussion, we restrict our attention to the case of one procedure declaration. All results of this section can be straightforwardly generalized to the case of more than one procedure declaration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Nonrecursive Procedures</head><p>We first consider the simpler case of a nonrecursive procedure. Assume a procedure declaration P ~ So where So E 9 ~ is the procedure body of P, and extend the set of programs 5z by allowing the programs to contain the calls of P. Call this extended class of program ~. Each procedure call P refers to the declaration P ~ So. The requirement that So E :~ implies that the procedure P is not recursive.</p><p>To deal with the procedure calls in the correctness proofs, we supplement the proof system H by the following proof rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RULE 7: PROCEDURE CALL RULE (P} So Ca} (p} P Ca} "</head><p>To consider the problem of soundness and completeness of the resulting system we must first extend the meaning function J/4z to programs from Y~. For S E let S[So/P] denote the program resulting from replacing all occurrences of P in S by So. In other words, S[So/P] is the macro expansion of S. For S E ~\:~ we define J4I(S) to be equal to .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.441(S[So/P]).</head><p>Thus ~/I(P) = ~4/i(S0), which implies that the rule of procedure calls is sound. The fact that Rules 2-5 are sound in the case of 5 p and the definition of . <ref type="bibr" target="#b3">4</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[I(S)</head><p>for S E 5~ trivially imply the soundness of Rules 2-5 in the case of ~1.</p><p>It should also be clear that the above proof system for 5P~ is complete in the sense of Cook (i.e., that I E Exp(L, 5P~) and ~i ¢p implies Trl ~H+Rule7 q)). The additional case of procedure calls is easily handled: if ~i {p} P (q}, then ~i {p} So {q}; thus Tri t-u {p} So {q} by the previous completeness result; that is, Trz t--H+Rule7 {p} P {q}. The proof of other cases is the same as in Section 2.8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Recursion Rule</head><p>When the declared procedure P ~ So is recursive, that is, when So E 5~\5~, the above system is still sound but obviously incomplete: an attempt at proving { p} P (q} results in an infinite regression. A way to overcome this difficulty has been suggested in <ref type="bibr" target="#b26">[26]</ref>. The rule one should adopt is the following. The reasoning presented by this rule is the following: infer (p} P (q} from the fact that {p} So {q} can be proved (using the other rules and axioms) from the assumption (p} P {q}. Rule 8 is actually a translation of the so-called Scott's induction rule (see <ref type="bibr" target="#b51">[50]</ref>) into this framework.</p><p>As an example of a proof using the recursion rule, consider the procedure declaration P ~ So for So-=if x= 0 theny := 1 else x := x-1;P;x:=x+ 1;y :=y • xfi.</p><p>We now prove {x &gt;_ 0} P { y = x!} in the system H augmented with the recursion rule.</p><p>By the recursion rule it is enough to prove</p><formula xml:id="formula_3">{x_&gt; 0} P {y = x!} t--H {x__ 0} So {y = x!}. Assume {x___ 0} P {y = x!}. (<label>13</label></formula><formula xml:id="formula_4">)</formula><p>By the assignment axiom, </p><p>On the other hand, since the implication</p><formula xml:id="formula_6">x&gt;_OAx#O--&gt;x- 1&gt;0<label>(20)</label></formula><p>is true, and, by the assignment axiom,</p><formula xml:id="formula_7">{x-l_&gt;0}x:=x-1 {x_&gt;0},<label>(21)</label></formula><p>we get by the consequence rule</p><formula xml:id="formula_8">{x&gt;0Ax#0}x:=x- l{x_&gt;0}. (<label>22</label></formula><formula xml:id="formula_9">)</formula><p>By the composition rule we now get from ( <ref type="formula" target="#formula_5">19</ref>) and ( <ref type="formula" target="#formula_8">22</ref>)</p><p>{x&gt;_OAx~O}x:=x-1;P;x:=x+l;y:=y.x{y=x!}.</p><p>(</p><formula xml:id="formula_10">) Since x &gt; O A x = O---~ 1 = x!<label>23</label></formula><p>is true, and, by the assignment axiom,</p><formula xml:id="formula_12">{1 --x!} y :--1 {y = x!},<label>(25)</label></formula><p>we get by the consequence rule</p><formula xml:id="formula_13">{x_&gt;0Ax=0}y:=l {y=x[}. (<label>26</label></formula><formula xml:id="formula_14">)</formula><p>(23) and ( <ref type="formula" target="#formula_13">26</ref>) finally imply by the if-then-else rule</p><formula xml:id="formula_15">{x &gt; 0} So { y = x!},<label>(27)</label></formula><p>which was to be proved. Of course, strictly speaking, we have only proved that (17), ( <ref type="formula" target="#formula_6">20</ref>), (24) }--H+nu,es {X --_-0} P {y = x!}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Insufficiency of the Recursion Rule</head><p>However, the system H augmented with the recursion rule is not complete. As evidence we now show that there is no way to prove in it that in the case of the above procedure declaration a call of P does not change the value of x; that is, there is no way to prove that {x = z} P {x = z}. Suppose by contradiction that {x = z} P {x = z} can be proved in the system. We can assume that all assertions used in the proof do not have y as a free variable (otherwise, y can be everywhere replaced by, say, 0). We can also assume that the last rule applied was that of consequence. So for some p and q such that the formulas x = z --&gt; p (28) and q --* x = z <ref type="bibr" target="#b29">(29)</ref> are true (under the standard interpretation in natural numbers) {p} P {q} can be proved. Consecutive applications of the consequence rule can be combined into one. Thus we can assume that in the proof of {p} P (q} the last rule applied was the recursion rule. In other words, the premise {p} P {q} }-(p} So {q} can be established. Hence, under the assumption of {p) P {q} both {p/k x = 0} y := 1 {q} and {p/k x ~ 0} x := x -1; P; x := x + 1; y := y • x {q} can be proved. The provability of the first formula implies that p/k x = 0 --* q <ref type="bibr" target="#b30">(30)</ref> is true (by assumption, y is not free in q). The other formula had to be proved using the assumption {p} P (q}. For some pl and ql we have that pl ~ p and q -* ql <ref type="bibr" target="#b31">(31)</ref> is true (to obtain {pl} P {ql} by the consequence rule) and both {p A x ~ 0}</p><p>x := x -1 {pl} and {q~} x := x + 1;y :=y • x {q} hold. Provability of the second correctness formula implies that</p><formula xml:id="formula_16">ql ~ q[x + l/x] (<label>32</label></formula><formula xml:id="formula_17">)</formula><p>is true. ( <ref type="formula">31</ref>) and ( <ref type="formula" target="#formula_16">32</ref>) imply that</p><formula xml:id="formula_18">q --&gt; q[x + 1/x]<label>(33)</label></formula><p>is true. But (29) implies that q[x + 1/x] --* x + 1 = z is true; so, by {33},</p><formula xml:id="formula_19">q-* x + 1 = z (<label>34</label></formula><formula xml:id="formula_20">)</formula><p>is true. From ( <ref type="formula">29</ref>) and <ref type="bibr" target="#b34">(34)</ref> we get that q --, false <ref type="bibr" target="#b35">(35)</ref> is true. On the other hand, from ( <ref type="formula">28</ref>) and <ref type="bibr" target="#b30">(30)</ref> x = z/k x = 0 ~ q is true; so, by <ref type="bibr" target="#b35">(35)</ref>, x = z A x = 0 --* false is true, which gives the desired contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The Proof System G</head><p>The system H augmented with the recursion rule is thus incomplete. Therefore, following Gorelick <ref type="bibr" target="#b19">[19]</ref>, we supplement this system by the following axiom and proof rules, which lead to a complete proof system.  Here y and 5 denote sequences of variables of the language L. p[y/5] stands for a simultaneous substitution of the variables from )7 for the variables from 5 in p. car(So) denotes the set of all variables which occur in So, and car(p) denotes the set of all free variables ofp. It should be clear what we mean by car(So, q), etc.</p><p>Let us denote the resulting proof system by G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">An Example of a Proof in G</head><p>To see how the additional rules of G are used in actual proofs, we now prove the already mentioned formula {x = z} P {x = z} where P is the factorial procedure from Section 3.2. To prove {x = z} P {x --z}, it is enough to establish the premise (x = z} P {x = z} }-{x = z} So {x = z} of the recursion rule. Assume By substitution rule I, and, by the invariance axiom,</p><formula xml:id="formula_21">{x = z}P{x = z}. (<label>36</label></formula><formula xml:id="formula_22">) {x = u}P{x = u},<label>(37)</label></formula><p>{u--z-1}P{u=z-1}; <ref type="bibr" target="#b38">(38)</ref> so, by the conjunction rule and the consequence rule, {x-~z-1}P{x=z-1}. <ref type="bibr" target="#b39">(39)</ref> Now, applying the assignment axiom and the composition and consequence rules, we get from <ref type="bibr" target="#b39">(39)</ref> {x = z} x := x-1; P; x := x + 1;y :=y</p><formula xml:id="formula_23">• x {x = z}. (<label>40</label></formula><formula xml:id="formula_24">)</formula><p>By the consequence rule we can conjoin the preassertion with the formula x ~ 0. Also, {x=zAx=0}y:= 1 {x=z} <ref type="bibr" target="#b41">(41)</ref> holds. By the if-then-else rule we now get (x = z} So {x = z}; so we have established the desired premise. This proof did not use substitution rule II. However, that rule is needed, for example, to prove {x _&gt; 0} P {y _&gt; 1}. The proof makes use of the already proved formulas {x &gt; 0} P {y = x!} and {x = z} P {x = z} and an instance {z _&gt; 0} P {z _&gt; 0} of the invariance axiom to get, by the conjunction rule, {x _&gt; 0 A x = z A z _&gt; 0} P { y = x! A x = z A z _&gt; 0}. Using the consequence rule, we now get {x = z A x &gt; 0} P {y _ 1}. Finally, by substitution rule II, (x = x A x _&gt; 0} P {y &gt; 1}; so {x &gt; 0} P {y __ 1} by the consequence rule.</p><p>These proofs shed light on the way the new rules are used. Using substitution rule I, one simply renames variables not used in the program (so-called auxiliary variables). In contrast, substitution rule II is used to get rid of the auxiliary variables from the preassertion. Auxiliary variables are typically used here to "freeze" the values of the program variables before a procedure call. In proofs usually two different premises about a procedure call are needed: one derived by the recursion rule and the other one obtained by the invariance axiom. The conjunction rule replaces these two premises by one. Finally, observe that the invariance axiom can be proved straightforwardly using the recursion rule. However, since it is often used, it is useful to have it formulated separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Semantics of Recursive Procedures</head><p>Before we dwell on the question of the soundness and completeness of G, we have to define the meaning function J/4~ on programs from 5~\ ~. We do so in a way which simplifies our considerations concerning the soundness of G. The semantics we provide is usually called an approximating semantics.</p><p>Let ~2 stand for a program from 5 z which never halts. Let us define a program S(0 ") E 5Zby induction on n:</p><formula xml:id="formula_25">S(o °) = a; s(n+I) So[S(o,)/p]. 0 -~</formula><p>A straightforward proof by induction on the structure of S shows that, for all S,, $2 E :~fand S E 5P~, ff ~/I(S,) c s/4i($2), then J/41(S[S1/P]) c J//dS[S2/P]).</p><p>[o(n+l)</p><p>This implies (by induction on n) that, for all n, Jh(Sto n) ) C Jhtoo p. Thus, for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>all S ~ .9°1, J6(S[S(o")/P]) C J4I(S[S(on+I)/P]).</head><p>For S E ~1 we now define ~dS) by putting</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Jz,(s) = 6 ~z,(s[S(o")lP]). n~O</head><p>In particular,</p><p>.//4,(P ) = 6 ./~I( S(n) ). n~O By the above, J41(S) is a (partial) function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Soundness of G</head><p>We wish to prove that the proof system G is sound, that is, that, for every interpretation I and correctness formula q0, if Trl ~c q0, then ~z (p. The fact that G is not a usual proof system in the sense of first-order logic forces us to exercise some care while doing so. It is, for example, not clear to what extent we can use the fact that Rules 2-5 are sound in the case of nonrecursive procedure declarations and in what sense the recursion rule is to be proved sound.</p><p>To deal with these problems, we first transform the system G into a proof system K which uses the usual notion of proof.</p><p>The formulas of K are implications (I) --&gt; @ (called correctness phrases), where (I) and • are finite sets of correctness formulas. If (I) is empty, we write "I' instead of (I) --&gt; ,t'. For each axiom q00 and proof rule ¢pl, • • -, ¢p. 3. The proof system K is called good if all its axioms and proof rules are good.</p><p>Observe that, for every set of assertions T, T U {¢p} b-G • iff T ~--K cp ---) xI,. The proof runs by induction on the length of proofs. Thus, in particular, for every set of assertions T, T</p><formula xml:id="formula_26">[--G (~ iff T [-K (p.</formula><p>This, together with the observation that (P ~ So I q0) is true under I iff it is Igood, implies the following claim: CLAIM 1. If the proof system K is good, then the proof system G is sound.</p><p>Also, the following holds: is sound, then the proof rule is good.</p><p>Thus the axioms and proof rules of K which are translations of axioms and proof rules of H are all good, as the system H is sound in the case of a nonrecursive procedure declaration.</p><p>By Claims 1 and 2, to prove the soundness of G it is now enough to prove a. the validity of the invariance axiom in the case of a nonrecursive procedure declaration; b. the soundness of substitution rules I and II and the conjunction rule in the above case; c. the goodness of the rule </p><p>Then by <ref type="bibr" target="#b42">(42)</ref> (P ~ S(0 ") ] {p} So {q} ) is true under I.</p><p>But So[S(o")/P] -S(o"+1); so <ref type="bibr" target="#b44">(44)</ref> implies that (P ~ ¢(n+1) ~0 I {P} P {q} ) is true under /. So, by induction, <ref type="bibr" target="#b43">(43)</ref> holds for all n.</p><p>d is obviously true. Thus the system G is indeed sound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Completeness of G in the Sense of Cook</head><p>We now prove the completeness of G for 5~ in the sense of Cook. Let 2 be a sequence of all variables which occur in So and let 5 be a sequence of some new variables of the same length as 2.</p><p>Assume that I ~ Exp(L, 5P~). There exists an assertion qo which defines postl(E = 5, P). The correctness formula {E = 5} P (qo} is called the most general formula for P, since any other true (under I) correctness formula about P can be derived from {2 = 5} P {qo} in G. This claim is the contents of the following lemma. </p><p>where p, =-p[f/E] and t7 is a sequence of some fresh variables of the same length as 5.</p><p>(45) and ( <ref type="formula" target="#formula_29">46</ref>) imply by the conjunction rule that</p><formula xml:id="formula_30">{E = 5 A p,[5/E]} P {qo AP115/2]}. (<label>47</label></formula><formula xml:id="formula_31">)</formula><p>We now show that But, by the soundness of substitution rule I, also ~i {P~) P {ql} ; so finally ~I ql(¢). This proves <ref type="bibr" target="#b49">(48)</ref>. ( <ref type="formula" target="#formula_30">47</ref>) and ( <ref type="formula" target="#formula_32">48</ref>) imply by the consequence rule that </p><formula xml:id="formula_32">~ qo A pl [5/2] ---) ql where ql = q[E/5]. (<label>48</label></formula><formula xml:id="formula_33">{E = E Apl[5/E]} P (ql).<label>(49)</label></formula><p>Clearly, ~ip (--+p~[5/ff] and mz q (--) ql[5/E]; so, by the consequence rule,</p><formula xml:id="formula_35">(p} P {q},<label>(53)</label></formula><p>which was to be proved. [] The next lemma shows that the hypothesis {2 = E} P {qo} used in the above lemma can actually be proved in G. The completeness of G is the immediate consequence of Lemmas 1 and 2. Note that in the above proof the auxiliary variables in 5 were used to "freeze" the values of the variables in E before the procedure call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9">Total Correctness of Recursive Procedures</head><p>Recursive procedures introduce another possibility of nontermination of programs. Clearly, the recursion rule does not provide any means to establish termination of the procedure calls, and so it is appropriate for proofs of partial correctness only.</p><p>Sokotowski <ref type="bibr" target="#b54">[53]</ref> proposed the following refinement of the recursion rule, which leads to proofs of total correctness. This rule can also be found in Clarke <ref type="bibr">[10a]</ref>, where it is attributed to M. O'Donnell.</p><formula xml:id="formula_36">RULE 13: RECURSION RULE II ~p(0), {p(n)} P {q} t-{p(n + 1)} So {q} {3np(n)} P {q}</formula><p>Here, as in while rule II, p(n) is an assertion with a free variable n which does not appear in So and ranges over natural numbers.</p><p>The intuition behind this rule is the following. Call a computation (q, n)-deep if it terminates in a state satisfying q and if at any moment at most n calls of P are active in it. {p(n)} S {q} is to be interpreted here as a statement that any execution of S starting inp(n) is (q, n)-deep. The assumption {p(n)} P {q} thus states that executions of P starting in states satisfying p(n) are all (q, n)-deep and is used to show that all executions of P starting in states satisfying p(n + 1) are (q, n + D-deep. The latter is shown by proving {p(n + 1)} So {q}.</p><p>Using this rule, we can easily prove the correctness formula {x _ 0} P { y = x!} considered in Section 3.2 by taking p(n) ----x _ 0 A x = n -1 and repeating the proof from Section 3.2.</p><p>However, a proof analogous to that in Section 3.3 shows that the system Ho supplemented with recursion rule II is incomplete. Therefore, essentially following <ref type="bibr" target="#b23">[23]</ref>, we extend it to a proof system which is arithmetically complete. The extension is very similar to the corresponding extension of H + Rule 8 to G. We adopt substitution rule I and the following two proof rules. where 5 N var(So, q) = ~. {35p} P {q} Call the resulting system Go. It should be clear that, if we substitute Rules 14 and 15 in G for the invariance axiom, substitution rule II, and the conjunction rule, then we also get a proof system for partial correctness which is complete in the sense of Cook. The completeness proof is in fact identical to that of G. The main reason for adopting a different extension here than in Section 3.4 is the fact that the invariance axiom is not valid when used for proofs of total correctness.</p><p>The arithmetical soundness of Go can be proved in a way analogous to the way the soundness of G was proved. When dealing with recursion rule II, one uses the premise -,p(0) to ensure that I~1 (P ~ S~0 °~ ] {p(0)} P {q} ).</p><p>The proof of the arithmetical completeness of Go is "dual" to the completeness proof of G. Before presenting the proof, we introduce the following notion. pretj(S, q) --predS, q) N {8: 3~ [~(S)(8) = T]}.</p><p>pret stands in the same relation to total correctness as pre does to partial correctness: we have 1~i {p} S {q} iff {8 : ~z p(8)} C pret1(S, q). Let E and 5 be defined as in Section 3.8 and let n be a fresh variable. Assume now that I is an arithmetical interpretation. It can be shown that there exists an assertion po(n) such that for all states ~z po <ref type="bibr" target="#b7">(8)</ref> iff ~z nat(n)(8) and 8 E pret1(S(o k), E = z),</p><p>where k = 8(n).</p><p>The following lemmas show that po(n) plays a role here analogous to that of q0 in the completeness proof of G. </p><p>where ql --q[E/5] and E is a sequence of some fresh variables of the same length as £ The implication</p><formula xml:id="formula_38">E = E A q~ [5/2] -* q~ (56)</formula><p>clearly holds; so, by the consequence rule,</p><formula xml:id="formula_39">{po(n) A ql[5/E]} P {q~}. (<label>57</label></formula><formula xml:id="formula_40">)</formula><p>By the elimination rule,</p><formula xml:id="formula_41">{3n3z (po(n) A ql[5/E])} P {q~}. (<label>58</label></formula><formula xml:id="formula_42">)</formula><p>We now show that</p><formula xml:id="formula_43">~z pl --* 3n3E (po(n) A q~[5/E]), where pl ~-p[~/E]. (<label>59</label></formula><formula xml:id="formula_44">)</formula><p>First, note that, by the arithmetical soundness of substitution rule I, I~i {p~ } P {q~}. Assume ~i p~ <ref type="bibr" target="#b7">(8)</ref>. By the definition of I~i there exist k and a state v such that ~l(S¢ok))(8) = • and ~1 q(T). Now let 81 be the state which agrees with 8 on all variables not listed in n, 5 and such that 81(5) = ~(E) and 81(n) = k. It is easy to see that ~z (po(n) A q115/£])(81). This shows that ~x 3n35 (p0(n) A q~[5/2]) <ref type="bibr" target="#b7">(8)</ref>; so (59) is proved. The completeness of Go now follows from Lemmas 3 and 4. Note that in the above proof the auxiliary variables in 5 were used to "freeze" the values of the variables in 2 after the procedure call.</p><p>It is easy to see that, following the reasoning presented above, one arrives at a dual completeness proof of the already-mentioned system H + Rules 8, 10, 14, and 15.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.10">Bibliographical Remarks</head><p>Most of the papers dealing with procedures within the framework of Hoare's logic do not discuss parameterless procedures. In particular, Rule 8 is a special case of a rule given in <ref type="bibr" target="#b26">[26]</ref>. The example in Section 3.2 is a modification of an example given by Hoare <ref type="bibr" target="#b26">[26]</ref>. The semantics of recursive procedures in Section 3.6 is a translation into our framework of the corresponding definition from <ref type="bibr" target="#b51">[50]</ref>. It is often used in the literature. The justification of the soundness of G seems to be new. The argument used in justifying c in Section 3.7 corresponds to the proof of the soundness of Scott's induction rule and often appears in the literature. The completeness proof given in Section 3.8 is a special case of the completeness proof presented in <ref type="bibr" target="#b19">[19]</ref>. A similar completeness result was proved independently (but somewhat later} in <ref type="bibr" target="#b24">[24]</ref>. The presentation of the proof system Go and its completeness proof in Section 3.9 slightly differs from that of Harel <ref type="bibr" target="#b23">[23]</ref>. Harel's result was formulated within the context of dynamic logic. A similar completeness result was proved in <ref type="bibr">[10a, 53]</ref>. The terminology of "freezing" is due to Harel, Pnueli, and Stavi <ref type="bibr" target="#b24">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">VARIABLE DECLARATIONS</head><p>Let us now consider the least class 5 °v of programs which, similarly to class ~, contains the assignment statements and is closed under the use of the composition (;), while, and if-then-else constructs but additionally satisfies the following condition: if S ~ 5 °v, then, for each variable x, begin new x; S end E 5 °~. new x stands for a declaration of a variable x which is valid within the block begin new x; S end; x is a local variable with respect to this block.</p><p>The occurrence of a variable x in a program S is called bound whenever it is within a subprogram of S of the form begin new x; S~ end. An occurrence of x in S is free if it is not bound. Let free(S) denote the set of all variables which occur free in S. We define free(S, p) analogously.</p><p>By S[y/x] we mean a substitution of y for the free occurrences of x in a program S. It is defined analogously to the substitution p[ y/x] for an assertion p.</p><p>In particular, variable clashes which arise are resolved by appropriate renamings.</p><p>Let w stand for a special constant to which we initialize all local variables. We might view co as a symbol standing for "undefined." We now adopt the following proof rule:</p><formula xml:id="formula_45">RULE 16: VARIABLE DECLARATION RULE {p A y = o~) S[y/x] {q)</formula><p>where y ~ free(p, S, q). {p} begin new x; S end {q}</p><p>The renaming of x for y is performed here to distinguish between the occurrences of local x in S and possible free occurrences of nonlocal x in p and q. The expression y = w captures the idea of initialization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Semantics for Variable Declarations</head><p>In order to pose the question of soundness of the variable declaration rule, as usual we must first define the meaning of the programs involved. We follow here the approach of Clarke <ref type="bibr" target="#b8">[9]</ref>.</p><p>To this purpose we redefine the notion of a state. By a state we now mean a finite function from the set of variables into the domain D of an interpretation/.</p><p>For a state a, if x ~ dom(a) and d E D, then a tJ (x, d) stands for the extension of a yielding d when applied to x. DROP(o, x) stands for a state obtained from a by deleting x from its domain.</p><p>We define the meaning of a program in the same way as before, with the only new case being that of a block. For all statements S we assume that J/Jz(S)(a) is undefined if free(S) (Z dom(o).</p><p>Let $1 -begin new x; S end, and suppose that free(S1) _C dom(a). We define</p><formula xml:id="formula_46">~z(S1 )(o) = DROP(Jf/~(S[ y/x]) (a U ( y, ~_)), y)</formula><p>where y is the first variable not in dom(o) and w is the value assigned to the constant o~. Since we are using a new definition of a state, we have to provide a new notion of truth under/. Given an assertion p and a state o, we define ~z p(a) to hold in the event that p becomes true when all its free variables lying in dom(o) get assigned values provided by o and when the other free variables are universally quantified. For example, ~IN (x = 0/k z = z)((x, 0)) holds. Thus, for ~z p(a) to hold we do not need to have free(p) ___ dom(a). Thanks to this definition, we can now retain the definition Of truth of an asserted program under I given in Section 2.4, with the only difference being that the new definition of state is now used. As a result, various former definitions and results do not need to be reconsidered with respect to the newly introduced semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Soundness and Completeness of the System H + Rule 1 6</head><p>Soundness of Rule 16 follows from the fact that</p><formula xml:id="formula_47">J6(S[y/x])(o U (y, d)) = Jf6(S[z/x])(o U (z, d))</formula><p>for any programS and y, z ~ dora(o). ( <ref type="formula">62</ref>)</p><p>To prove this fact, one should actually strengthen the claim and rather prove that, for any program S and yl ..... y,, zl,..., z, ~ dom(o),</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• /[[I(S[yl/xl] ".. [yn/Xn])(O U (yi, dl) .." (y,,, dn)) = ~f1(S[z,/xl] ... [z,,/x,])(o U (zl, dl) ... (z,, dn)).</head><p>The last claim can be proved by induction on the structure of S, where only the case of blocks requires some caution due to the possibility of various variable clashes.</p><p>Soundness of the rules of H was proved (or rather stated) with respect to a different notion of state. But, since virtually the same definition of truth of an asserted program under I is now used, the same proofs of soundness apply. Thus the system H + Rule 16 is sound.</p><p>We now turn to the problem of the completeness of H + Rule 16. The definitions of pre, post, and expressiveness given in Section 2.8 should now be interpreted with respect to the new notion of state.</p><p>The system H + Rule 16 is easily seen to be complete in the sense of Cook. The case of blocks is dealt with using (62), and the other cases are the same as in the completeness proof of H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Adding Procedures</head><p>Having settled the case of while programs, we now pass to the programs allowing procedure calls.</p><p>Consider an extension Y~I of 5 zv in which the programs are allowed to contain calls of a nonrecursive parameterless procedure P. We assume a procedure declaration P ~ So where So E 5 °v. To provide a meaning to programs from SPY, we proceed as in Section 3.1.</p><p>A program S E 5z~\5 ~v assumes the meaning assigned to it by the clause</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>~,(S) = .A6(S[So/P]),</head><p>where S[So/P] stands for the substitution of all occurrences of P by So. The aim of this clause is to avoid binding any of the free occurrences of the variables in So through the substitution process. The other clauses are defined in a natural way.</p><p>To prove the correctness of programs from Y~, we now use in addition Rule 7. However, to apply Rule 16 to programs from ~ we have to require additionally that y ~ free(S0). It is easy to see that otherwise this rule becomes unsound. To illustrate the use of Rule 16 in conjunction with Rule 7, we give the following example. Consider the procedure declaration P ~ x := z and the program S -= z := 1; begin new z; z := 0; P end. We now prove (true) S {x = 1}.</p><p>By the assignment axiom, so, by Rule 7, {z=l) x:=z(x=l); {z= l} P {x= l}.</p><p>By the assignment axiom and the consequence and composition rules, {z=l/~y=~0}y:=0;P{x=l}, from which we obtain the desired formula {true} S {x = 1}.</p><p>It should be noted that, according to ALGOL 60 semantics, the value of x after the execution of S should be 1 and not 0.</p><p>We now prove the soundness and completeness in the sense of Cook of the system H 4-Rules 7, 16. We proceed as in Section 3.1. The definition of semantics of blocks given above provides the meaning for programs from ~Y in terms of the meaning of programs from ~v. Therefore, we can easily reduce the problem to that of the soundness and completeness of H 4-Rule 16 for ~v. The only case in both proofs which requires some explanation is that of blocks.</p><p>If x, y ~ free(S0), then, for S E ~,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>./£z(S[ y/x]) = ./[/lz(S[ y/x][So/P]) = ~l~(S[So/P][ y/x])</head><p>and J//l(begin new x; S end) --~/~(begin new x; S[SO/P] end).</p><p>Ify ~ free(S0) and x ~ free(So}, then This shows that in both cases the soundness of Rule 16 applied to programs from 5a~ indeed follows from the soundness of Rule 16 applied to programs from y,v. Similar reduction takes care of the appropriate case in the completeness proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Jl/ldS[y/x]) = ./[/li(S[y/x][So/P]) = ./£i(S[x'/x][So/P][y/x'])</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Scope Issues</head><p>Our discussion concerning local variables would not be complete without providing an answer to the following seemingly innocent question. Why did we not adopt the following rule? where y ~ free(p, S, q). {p} begin new x; S end {q} Here the substitution is performed in assertions and not programs; consequently, the rule should be easier to use and handle.</p><p>The answer touches the issue of the scope of identifiers in programs. We say that a static scope is assumed if each procedure call is evaluated in the environment in which the procedure has been declared. In our case this means that all free variables of the procedure body are understood to be the free variables of the program. If, on the other hand, each procedure call is evaluated in the environment in which the procedure is called, then we say that dynamic scope is assumed.</p><p>Using this terminology, we can say that Rule 16 leads to static scope, whereas Rule 17 leads to dynamic scope. All ALGOL-like languages assume static scope. Therefore, one might think that dealing with dynamic scope is irrelevant. However, as we see in Sections 6 and 7, a theoretical analysis of scope issues within the framework of Hoare's logic reveals important differences between these two scope assumptions and sheds light on the static scope assumption.</p><p>To conclude this discussion, we provide a semantics for blocks which leads to a dynamic scope assumption. This semantics is due to Clarke <ref type="bibr" target="#b8">[9]</ref>. For this purpose we need a slightly refined notion of a state. By a state we mean here a finite sequence of pairs (x, d ) where x is a variable and d an element of the domain D of an interpretation/. A variable can occur in more than one pair belonging to a state. By dom(o) we now mean the set of all variables which belong to a pair from o.</p><p>For x E dora(o) let (x, d) be the last pair in o to which x belongs. We define this d to be the value of x in state a. o U (x, d) now stands for the result of extending o with the element (x, d ), whereas DROP(o, x) stands for the sequence obtained from o by deleting the last pair to which x belongs.</p><p>Assume now that free(S0 _C dom(o) where $1 ---begin new x; S end. We define J/6($1) (0) = DROP(J6(S)(o U (x, ~)), x).</p><p>It can be shown that Rule 17 is sound for programs from ~v when the above semantics is used. Also, the corresponding completeness resplt concerning H + Rule 17 holds.</p><p>To extend these results to the case of programs admitting procedures, we have to provide a semantics for such programs. Given a procedure declaration P ~ So and a program S, let S(So/P) stand for the result of a literal replacement of each occurrence of P in S by So. If P is nonrecursive, we define the meaning of a program S ~ ~fY\5 °v by ./tli ( S ) = ./[4 ~( S ( So / P ) ).</p><p>If P is a recursive procedure, then we put</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• /~Ill(S) = nU=o.//[l(S(S~n)/P))</head><p>where S~ °) = ~2 and S~ "+1) = So(S~")/P).</p><p>The corresponding soundness and completeness results concerning the systems H + Rules 7, 17 and G + Rule 17 now follow by the same reasoning as was used in Section 4.3.</p><p>Note that the difficulties with the use of uninitialized variables arise in the case of dynamic scope as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Bibliographical Remarks</head><p>Rule 16 (without the formula y = ¢o) is from <ref type="bibr" target="#b26">[26]</ref>. The addition of the formula y = w first appears in <ref type="bibr" target="#b19">[19]</ref>. The use of substitution in programs in the definition of semantics of blocks independently appeared in <ref type="bibr" target="#b3">[4]</ref>. The soundness and completeness of H + Rule 16, H + Rules 7, 16, and G + Rule 16 are special cases of a completeness result mentioned in <ref type="bibr" target="#b8">[9]</ref> and proved in <ref type="bibr">[1]</ref>. <ref type="bibr" target="#b14">[14]</ref> provides a detailed proof of the soundness and completeness of the system H + Rule 16. Rule 17 {without y = ¢0) is due to <ref type="bibr" target="#b37">[37]</ref>, where also its soundness is proved. The completeness of H + Rules 7, 17 and the completeness of G + Rule 17 are special cases of the completeness results of <ref type="bibr" target="#b13">[13]</ref> and <ref type="bibr" target="#b19">[19]</ref>, respectively. All these results are subsumed by the results of <ref type="bibr" target="#b45">[45]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SUBSCRIPTED VARIABLES</head><p>So far we have allowed assignment to simple variables only. Allowing subscripted variables in expressions and assignments leads to extension of the previous syntax. To keep things simple we restrict our attention to the case of onedimensional arrays, omitting any specifications of the bounds.</p><p>Let d~ be a set of array variables. We extend the syntax of L by allowing expressions of the form a[t] for a E ~/~and t being an expression, and we now allow an assignment a[s] := t where a E ~/'and s, t are expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">An Assignment Axiom for Subscripted Variables</head><p>In what follows we assume that conditional expressions of the form if s = t then tl else t2 fi (so-called equality conditionals) are allowed. To obtain a better picture of the problem, we consider first the case of an assignment when the subscript is a simple variable. Essentially the following axiom was proposed in <ref type="bibr" target="#b29">[29]</ref>: If we now allow arbitrary expressions as subscripts, we run into difficulties. Namely, the formula (true} a[t] := 1 Ca[t] = 1} is no longer valid! To see this, observe that, if all] --a[2] = 2, then {true} a[a <ref type="bibr" target="#b1">[2]</ref>] := 1 Ca[a <ref type="bibr" target="#b1">[2]</ref>] = 1} is not true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By p[t/a[x]] we denote a substitution of an expression t for the subscripted variable a[x]. It is defined by induction, with the main clause being a[z][t/a[x]] =</head><formula xml:id="formula_48">{p[t/a[x]]} a[x] := t (p}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Using this axiom, we can prove</head><p>This shows that the above definition of substitution has to be appropriately refined for the general case of subscripts being arbitrary expressions. Perhaps the simplest solution to this problem is to circumvent it. The above substitution still leads to correct results when used for arbitrary subscripted variables if applied only to assertions allowing simple variables as subscripts. The main clause of this substitution is thus</p><formula xml:id="formula_49">a[z][t/a[s]] •-if z = s then t else a[s] fi,</formula><p>and the case in which an arbitrary expression stands for z is simply not handled.</p><p>Given now an arbitrary assertion p, let p' denote an assertion equivalent to p which is obtained by "quantifying out" all subscripts which are not simple variables. For example, ifp is a[a <ref type="bibr" target="#b1">[2]</ref></p><formula xml:id="formula_50">] --1, thenp' is 3z (a[z] = 1 A z = a[2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>]). We now extend the above substitution to arbitrary assertions by putting p[t/a[s]] = p'[t/a[s]].</head><p>We finally arrive at a general form of the axiom:</p><formula xml:id="formula_51">AXIOM 18: ASSIGNMENT AXIOM FOR SUBSCRIPTED VARIABLES Cp[t/a[s]]} a[s] := t {p}.</formula><p>Note the similarity in form between this axiom and Axiom 1. By way of example, we now prove</p><formula xml:id="formula_52">{a[2] = 2--~ a[1] = 1} a[a[2]] := 1 (a[a[2]] = 1}. We have (a[a[2]] = 1)[1/a[a[2]]] -(3z (a[z] --1 A a[2] = z))[1/a[a[2]]]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3z (if z --a[2] then 1 else a[z] fi = 1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A if 2 = a[2] then 1 else a[2] fi = z).</head><p>The last formula is implied by the assertion a[2] = 2 --* a[1] --1. Namely, if a[2] --2 holds, then choose z --1, and otherwise choose z --a <ref type="bibr" target="#b1">[2]</ref>. Thus, by the consequence rule and Axiom 18 above, we get the desired result.</p><p>Axiom 18 is also complete in the following sense: if ~i {P} a[s] := t {q}, then</p><formula xml:id="formula_53">~I P --* q[t/a[s]]. So, if ~: {P} a[s] := t {q}, then TRz ~-RuleS+Axioml8 CP} a[s] := t (q},</formula><p>where TRz is the set of all assertions of the extension of L which are true under/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Bibliographical Remarks</head><p>The final form of the axiom is motivated by the solutions given in <ref type="bibr" target="#b15">[15]</ref> and (for the simpler case) in <ref type="bibr" target="#b43">[43]</ref>. Validity and completeness of the axiom follow from <ref type="bibr" target="#b15">[15]</ref>, from which the example is taken as well (see also <ref type="bibr" target="#b14">[14]</ref>). Different solutions for the assignment to subscripted variables are given in <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b49">48]</ref> and <ref type="bibr" target="#b15">[15]</ref> (also to be found in <ref type="bibr" target="#b14">[14]</ref>). <ref type="bibr" target="#b30">[30]</ref> also provides a solution for the case of an assignment of the form if e then x else y fi := t and an assignment to pointers. <ref type="bibr" target="#b20">[20]</ref> and <ref type="bibr" target="#b21">[21]</ref> provide solutions for the case of a multiple assignment to subscripted variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">PARAMETER MECHANISMS</head><p>Parameter mechanisms are among the most troublesome issues in the framework of Hoare's logic. One of the reasons is that parameter passing is always modeled syntactically by some form of variable substitution in a program, and this leads to various subtle problems concerning variable clashes. These difficulties are especially acute in the presence of recursion and static scoping.</p><p>In contrast to our exposition of the previous sections, the presentation cannot be complete here, as not all problems have been solved in this area. In the subsequent discussion we attempt to clarify which particular issues lead to difficulties and indicate what still remains to be done in this area.</p><p>We begin our presentation with a treatment of the parameter mechanism of call-by-name in the presence of the dynamic scope assumption. These results do not concern most usual features of programming languages. However, techniques introduced to deal with them form an adequate basis to study more common parameter mechanisms under the assumption of static scope. Therefore, it is useful to treat these features first. where (E: g) is the formal parameter list and So E ~v is the procedure body. 2 and 5 are disjoint lists of distinct variables, and the variables in 5 cannot occur to the left of any assignment statement in So. So does not contain procedure calls; so P is not recursive.</p><p>In the extension of 5 pv, called 5p~, we allow procedure calls of the form P(E:t) where ff is a list of distinct variables, t is a list of expressions containing no variable in E, and no variable in {if:t) different from formal parameters occurs free in the procedure body So.</p><p>All procedure calls mentioned below are assumed to satisfy the above restrictions.</p><p>S0[E, t/2, ~] indicates the result of simultaneous substitution of the actual parameters if, t for the corresponding free occurrences of the formal parameters 2 and ~ in So.</p><p>Following <ref type="bibr" target="#b13">[13]</ref>, we now supplement the proof system H + Rule 16 by the following three proof rules. Call the resulting system C. The last two rules are rather difficult to understand because of the restrictions imposed on the substituted expressions and variables. To get a better idea of how these proof rules are used, consider an example proof in C.</p><p>Assume the declaration P ~ (name(x : v) I x := v; a := v). According to the imposed restrictions, the calls P(y: y + 1) or P(y: a + 1) are disallowed, but calls P(z : y + 1), P(v : y + 1), or P(v : x + 1) are allowed. We now prove {x=z}P(v:y+ 1) {v=y+ 1Aa=y+ lAx=z}.</p><p>To this purpose we have to rename the formal parameter x of the procedure occurring free in the assertions. Therefore, we first prove {u=z} P(v:y+ 1) {v=y+lAa=y+ 1Au=z}.</p><p>We have {u=z} x:=v;a:=v{x=vAa=vAu=z); so, by procedure call rule II,</p><formula xml:id="formula_54">{u = z} P(x : v) {x = v A a = v A u = z}.</formula><p>Now, by the parameter substitution rule,</p><formula xml:id="formula_55">{u = z} P(x: v') {x = v' A a = v' A u = z};</formula><p>so once again, by the same rule,</p><formula xml:id="formula_56">{u=z) P(v:y+ 1) {v=y+lAa=y+ 1Au=z).</formula><p>Finally, by the variable substitution rule, {x=z} P(v:y+ l) {v=y+ lAa=y+ lAx=z}.</p><p>The reader can check that in all steps the corresponding restrictions were obeyed. Note that the direct step from the call P(x:v) to P(v:y + 1) is not allowed. Namely, the parameter substitution rule requires here that the actual parameter v in the call P(v : y + 1) be identical to x in P(x : v), as v occurs free in the assertion x = v A a = v A u = z.</p><p>It is worthwhile to note that the restrictions mentioned in the substitution rules are necessary. To see this, consider the procedure declaration P ~ (name(x : ) Ix := 0). We now have {u --1} P(x:) (u = 1), but of course (u = 1) P(u:) {u = 1} is not true. This shows that the restriction in the parameter substitution rule is needed. Also, {x = 1} P(x :) {x = 1} is not true; so the corresponding restriction in the variable substitution rule is necessary as well.</p><p>This artificial example provides a better insight into the nature and use of the substitution rules. Note that the variable substitution rule was used here to rename free occurrences of the formal parameters in the assertions of the correctness formula to be proved. The step from P(x : v) to P(v : y + 1) had to be split in two; so the parameter substitution rule had to be used twice here.</p><p>We now continue with the discussion of the system C. Let S be a program from 5z~\5 pv. We define the meaning of S by putting</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>sg~(S) = Jg~(S(So~P) )</head><p>where S(SO/P) E ~q~v is the result of the literal replacement of each procedure call P(E: t) occurring in S by SOLE, t/2, 5].</p><p>The results of <ref type="bibr" target="#b13">[13]</ref> imply that the proof system C is sound and complete in the sense of Cook, where the definition of the meaning of blocks from Section 4.5 is used. The proofs are delicate, mainly due to the possibility of various variable clashes in the substitution rules.</p><p>The only new case in the completeness proof is that of the procedure calls. We present here an argument which only works if the formal and actual parameters have no variables in common and if the assertions p and q do not have free occurrences of formal parameters. Note that in the above example the first issue forced us to use the parameter substitution rule twice, and the second problem was resolved by the use of the variable substitution rule. These difficulties are resolved in a similar way in the completeness proof of the general case, which is a careful refinement of the argument presented below. Suppose Note that the parameter substitution rule can be applied here, since, by the assumption, E n free('i) = O and, by the imposed restriction, E n (2 U ~) = •; so no variable from E occurs free in the assertions from the premise of the rule.</p><p>Note that Rules 19-21 could be replaced here by the simpler rule {p} S0[E, 'i/• 6] {q} {p} P(E:'I) (q} '</p><p>and soundness and completeness would be preserved. If this rule were adopted, the restrictions concerning the procedure cAll.q would be unneeded. However, if this rule were used, its hypothesis would have to be verified each time a procedure call with different actual parameters appeared. As a result, the actual proofs would be longer in general than the corresponding proofs in the proof system C, where it is sufficient to prove a general property {p} So {q} of the procedure body just once.</p><p>6.1.2 Recursive Procedures. <ref type="bibr" target="#b19">[19]</ref> contains an extension of the above result to the case of a recursive procedure. The relevant proof system is the following modification of the system G: a. in the recursion rule P is replaced by P(E: ~); b. the invariance axiom takes the form {p} P(E:'I) {p} where p has no free variable occurring free in S0[t2, 'i/Y, ~]; c. substitution rule I is replaced by the variable substitution rule; d. substitution rule II takes the form</p><formula xml:id="formula_57">[p} P(t2:'i) {q} where 5nfree(So[t2,-i/Y,~],q) =0; [p[~/2]} P(t2:'i) {q}</formula><p>e. in the conjunction rule P is replaced by P(t2:'i); and f. the parameter substitution rule is added.</p><p>Our definition of the meaning of programs containing procedure calls is similar to the definition in Section 4.5 (so using the dynamic scope requirement). Since the procedures now have parameters, we have to be careful so as to perform the appropriate substitutions of the actual parameters for formals in the proper order. Therefore, we proceed in a slightly different manner.</p><p>By induction on n we define a sequence of procedure declarations D,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P. ~ (name (Y: ~)]S~ ")) where S~ °) --~2 and S~ ~+'~ --So[P./P].</head><p>S[P,/P] stands for the result of substituting the procedure identifier P by P, in a program S. We define the meaning of a program S by putting</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>./~i( 8 ) = 0 ,/gI( S[ P,~/ P ]),</head><p>n=O where the context of the procedure declarations Dn is assumed. In particular, J/h(P(ff:i)) = (J JdPn(i:t)). n=0</p><p>Due to these definitions,</p><p>• //6(S[P,,/P]) = sCh(S [~]) where S tn] --S[P,,/P](S~")/P,) ..</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. (S(o°)/Po).</head><p>Observe that S ['1 is the result of repeated literal replacement of each procedure call P(5: t) by So[if, 7/2, 5] performed from the "top" being S to the depth n, followed by the literal replacement of each procedure call by ~.</p><p>Strictly speaking, the above definitions require an extension of the considered syntax by allowing a system of nonrecursive procedure declarations D1 ..... nn.</p><p>The results of <ref type="bibr" target="#b13">[13]</ref> cover such a case. The soundness proof of the above system can now be established following the reasoning used in Section 3.7 to prove the soundness of G. Due to the soundness of an extension of C dealing with a system of nonrecursive procedures, it is sufficient to prove the validity of the invariance axiom, the soundness of substitution rule II and the conjunction rule in the case of a system of nonrecursive procedure declarations, and the goodness of the recursion rule. Of course, in all cases we mean the modified versions of the axioms and proof rules. All proofs are straightforward.</p><p>The completeness proof is analogous to the completeness proof of G given in Section 3.8. For the most general formula for P we now choose the correctness formula {5' = 5} P(E: 5) {qo} where 5' is a sequence of all variables which occur free in So, 5 is a sequence of some new variables of the same length as 5', and qo is an assertion which defines postdS' = ~, P(2: 5)). In the proof of a lemma corresponding to Lemma 1 from Section 3.8, we now have to tackle the case of procedure calls with actual parameters different from the formal ones. The other cases are the same as before. The argument used by Cook <ref type="bibr" target="#b13">[13]</ref> in the completeness proof of C shows the following implicitly.</p><p>There exist two assertions pl and q~ which depend on p, q, So, and E, t such that (p} P(i:/) (q) {pl) P(2: 5) (ql) is sound in the case of a nonrecursive procedure declaration, and 2. (pl} P(E:5) (q~} I--C-Rule 19 (p} P(i:t) (q). In the special case of the completeness proof of C which we considered here, we can take p~ = 5 = [ A p[2/E] and ql =-q[2/E]. That conditions 1 and 2 are satisfied immediately follows from the argument presented here. The rest of the proof is the same as in Section 3.7.</p><p>The systems presented in this subsection assume dynamic scope. However, the relevant results should also hold when static scope is assumed. The main problem with such proofs is that the soundness of Rule 16, the first variable declaration rule, in the presence of parameter mechanisms becomes much more difficult to prove. of a nonrecursive procedure P. x and y are the formal value and variable parameters, respectively, and So, as usual, is the procedure body.</p><p>To provide a meaning for procedure calls and to deal with procedure calls in a proof system, we introduce the following notation:</p><formula xml:id="formula_58">B[t, z] =-begin new u; u := t; So[u/x][z/y] end, B[t, a[s]] -begin new ul, u2; ul := t; u2 := s; So[Ul/X][a[ue]/y] end,</formula><p>where u is the first simple variable ~-x, y and not free in So, t, or z (and analogously for ul, u2).</p><p>The above notation assumes a straightforward extension of the former definitions in that it uses substitution of a subscripted variable for a simple one in a program and uses a declaration of two local variables ul, u2 in one block.</p><p>Let v stand for a variable which is either simple or subscripted. We define the meaning of procedure calls by where S[So/P] is the result of substituting each procedure call P(t, v) occurring in S by B <ref type="bibr">[t, v]</ref>. S[So/P] is defined analogously to the way it is defined in Section 4.3. We assume that J//~ is defined in an appropriate way for programs using subscripted variables and not containing procedure calls.</p><p>We now adopt the following proof rule:</p><formula xml:id="formula_59">(p} B[t, v] (q} (p} P(t, v) {q} "</formula><p>This proof rule allows us to deal with arbitrary procedure calls. The construct <ref type="bibr">Bit, v]</ref> captures in a syntactic way the transmission of actual parameters to the procedure body. The following artificial example shows how various subtleties concerning the treated parameter mechanisms are handled here. Consider the declaration P~ (val x; vary I i := i + 1;y := x + 1; x :---0). We now show that {x=lAi=0}P(x,a[i])</p><p>(i=lAa[0]=2Ax=l}.</p><p>We have</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B[x, a[i]]</head><p>-begin new ul, u2; ul := x; u2 := i; i := i + 1; a[u2] := ul + 1; u~ := 0 end.</p><p>Using the assignment axioms, we now get {x=lAi=0}u~:=x;u~:=i;i:=i+l;a[u~]:=u~+l;u~:=0 {i= 1Aa[0]--2Ax= 1}.</p><p>Applying the introduced proof rule, we get the desired formula. We now supplement the proof system H + Rule 16 + Axiom 18 by the last rule. The soundness of the resulting system can be established in the same way as the soundness of H + Rules 7, 16 discussed in Section 4.3. Note that the new rule is obviously sound. However, we have to prove anew the soundness of the former rules, since they are now used for a bigger class of programs, namely, those containing subscripted variables. It should be clear that the above system is also complete in the sense of Cook. (We assume here that the notions of expressibility and completeness are extended in a proper way to cover the case of programs and assertions using subscripted variables.) 6.2.2 Recursive Procedures. Assume now that the procedure P is recursive.</p><p>Our definition of the meaning of programs containing procedure calls is analogous to the definition in Section 6.1 but now using the static scope requirement.</p><p>The corresponding recursion rule now takes the form To get a complete proof system, we now proceed similarly to the way we did in Section 6.1. We take an extension of the proof system H + Axiom 18 + Rule 16 which, apart from the above recursion rule, contains the corresponding versions of the invariance axiom, the variable substitution rule, substitution rule II, the conjunction rule, and the parameter substitution rule. The only new rule is the following rewrite rule:</p><formula xml:id="formula_60">(</formula><p>(p} S' (q} {p} S (q} " S' denotes here a program such that S' = S and no bound variable of S' occurs free in So. In turn, $1 = S means that Sa is obtained from S by replacing some blocks begin new z; $2 end occurring as subprograms in S~ by begin new u; S2[u/z] end where u ~ free(S, So).</p><p>[14] contains a proof of soundness of the above proof system. The proof can be simplified if we proceed exactly as before, making use of the soundness of an extension of the system H + Rule 18 + Rule 16 dealing with a system of nonrecursive procedures.</p><p>In <ref type="bibr" target="#b14">[14]</ref> it is also proved that the above proof system is complete in the sense of Cook. We present here a sketch of the proof for the case when the procedure body So contains only one procedure call.</p><p>Let</p><formula xml:id="formula_61">p(t, v) = 5" = 5 A Vu (5'[u] = 5[u])</formula><p>where 5' and 5' are correspondingly the sequences of all simple and array variables which occur free in So, t, or v and 5 and 5 are corresponding sequences of fresh simple and array variables. Let q(t, v) be an assertion defining postz(p(t, v), P(t, v)).</p><p>The only interesting case in the above completeness proof is that of procedure calls. In a manner similar to the way the completeness of G was proved, one can prove that, if~z (p} P(t, v) {q}, then TRz U (p(t, v)} P(t, v) (q(t, v)} F-(p} P(t, v) (q}; so it is enough to prove TRz F-{p(t, v)} P(t, v) {q(t, v)}.</p><p>The proof runs as follows. PROOF. The proof proceeds by induction on the structure of programs. The above remark indicates how to proceed in the case in which S is a procedure call. The only other nontrivial case in the proof is that of blocks. Assume S' is begin new x; $1 end. under I is not recursively enumerable. Therefore, no Hoare's system W for this programming language can be complete in the sense of Cook.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Copy Rules</head><p>Under what restrictions, then, is it possible to get sound and complete Hoare's systems dealing with procedures as parameters? Clarke <ref type="bibr" target="#b8">[9]</ref> stated that, if any of the above features 1 to 5 is disallowed, then there exists a natural Hoare's system for the corresponding programming language which is sound and complete in the sense of Cook. Unfortunately, the corresponding proofs for the cases in which 1, 2, 4, or 5 is disallowed are not worked out there. Also, some additional restrictions to be discussed in Section 7.7 (concerning sharing and self-application) are imposed on the language.</p><p>A detailed analysis of these and related issues is provided in <ref type="bibr" target="#b45">[45]</ref>, where most of the missing proofs are supplied in a uniform way. In the subsequent discussion we allow procedure declarations of the form P ~ (proc/~; var Yl So) where P is the name of the declared procedure,/t is the list of distinct formal procedure parameters, and y is the list of distinct formal parameters called by variable.</p><p>Subscripted variables are not allowed here; consequently, only simple variables can be used as actual parameters called by variable. With such restrictions imposed on the language, call-by-variable is of course equivalent to call-by-name. In blocks, systems of declarations of local procedures are allowed in addition to declarations of local variables. Call this class of programs ~P.</p><p>A uniformity similar to the one exemplified in Section 6.2.3 forms an important aspect of Olderog's considerations. However, the situation is more complicated here because procedures are allowed as parameters.</p><p>Uniformity is reached by employing the notion of copy rule. A copy rule is a relation between two programs differing only by an injective bound renaming of some local identifiers. By an identifier we mean here a simple variable or a procedure name. By idf(S) we denote the set of all identifiers occurring in S.</p><p>Injective bound renaming (written as S = S') is defined as follows: S ~ S' iff S h~j mj S' (bound renaming as defined in the previous section but now referring to all identifiers) holds and additionally the renaming is injective. Now let Id be a set of identifiers. Olderog <ref type="bibr" target="#b45">[45]</ref> considers three copy rules:</p><p>1. The ALGOL 60 copy rule ~o: (S, Id)~6o S, iff $1 = S and no identifier</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>~, inj</head><p>Bound in S, occurs in Id.</p><p>2. The "most recent" copy rule ~: (S, Id) ~ S~ iffS, = S, no simple variable inj bound in S, occurs in Id, and procedure names have not been renamed.</p><p>3. The naive copy rule ~n: (S, Id) ~n $1 iff $1 -S.</p><p>Note that, according t0this terminology, (S, free(So)) ~6o S' and (S, free(So)) ~ S' hold for programs discussed in Section 6.2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">The Proof System (O, cg)</head><p>These copy rules are incorporated into the proof system as a parameter; this is similar to the case of static and dynamic scope assumptions discussed in Section 6.2.3.</p><p>The proof system (O, ~) has a structure similar to that of the systems discussed in Section 6. But since we are now dealing with declarations of local procedures, we cannot take a fixed procedure declaration P ~ (...IS0) such that every procedure name P occurring within an asserted program {p} S {q} refers to this declaration. Instead, we augment each program S with a context E, being a sequence of procedure declarations with different procedure names. Thus, we now consider formulas {p} (E[S) {q} instead of simply {p} S (q). Throughout this section it is always assumed that for every procedure name occurring freely in S there exists a corresponding declaration P ~ (... [So) in E. We say that a procedure call S -= P(/t~, 371) is incorrect with respect to E if the declaration of P in E requires different actual parameters. To cover the case of incorrect procedure calls, the following new axiom is introduced. where the procedure call P(R~, Yl ) is incorrect with respect to E. This axiom is valid because an incorrect procedure call gets a nowhere defined function as its meaning. The need for such an axiom arises from the fact that the execution of a syntactically correct program can lead to an incorrect procedure call in the case in which procedures are allowed as parameters.</p><p>A copy rule ~E is used in two proof rules. The first of them is the recursion rule, which now has the following form. This rule deals with n different procedures, and of course all formulas (pi} (Ei lPi <ref type="bibr">(Ri,</ref><ref type="bibr" target="#b23">23)</ref> {qi} can be taken here as conclusions.</p><p>The second rule which refers to the copy rule is the following rewrite rule. Among all axioms and proof rules of the system, only the rewrite rule allows us to pass to a program S without any context of procedure declarations. Therefore, to prove a property of a program S we are forced to use the rewrite rule exactly once, and this as the last step in the proof.</p><p>The next step in the development of the system (O, ~) is the introduction of the following rule. where add(E, El) is the system of procedure declarations obtained from E by first deleting from it all declarations referring to a procedure name also declared in E1 and then adding El to it.</p><p>The discussion of the proof system from Section 6.2.2 given in Section 6.2.3 aimed to provide a better understanding of the decisions standing behind the choice of the above three rules.</p><p>To deal with the constructs present in the while programs, we adopt an appropriately modified system H in which each program S is replaced by (E I S). From Section 3.3 we know that proofs concerning procedure calls require some additional axioms and proof rules. An additional set of axioms and proof rules similar to the one used in Sections 6.1.2 and 6.2.2 is adopted here. This is a bit surprising in view of the fact that procedure parameters are now allowed. In particular, the invariance axiom, the conjunction rule, and substitution rules I and II are used (all referring to constructs of the form ( E I S) ).</p><p>The final rule is a substitution rule corresponding to the parameter substitution considered in Section 6.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RULE 26: SUBSTITUTION RULE III {P} (E IS) {q} {p[y/2]} (add(E~, E)[y/£]IS[y/£]) {q[:)7/~]}</head><p>where the substitution y/E is injective when restricted to the subset free(p, q) U idf(E, S) of 2. Here E can contain procedure names; xi is a simple variable iff yi is a simple variable.</p><p>This rule is stronger than the parameter substitution rule from Section 6.1 in the case in which both are restricted to procedure calls with actual parameters being simple variables. The reason for this strengthening is that no restrictions on actual parameters in procedure calls are imposed here, in contrast to Section 6.1.</p><p>It is instructive to check that the arguments from Section 6.1.1 showing the necessity of restrictions in Rules 20 and 21 do not indicate that the above rule is unsound. Both substitutions considered there, namely, [u, u/x, u] and [x, x/x, u], are not injective; so the argument does not apply here.</p><p>Note also that the above rule admits extending the procedure environment in the conclusion. Intuitively, this is allowed because the newly added procedures will never be called. The subsequent proofs are not affected if the program S is restricted in Rule 26 to be a procedure call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Semantic Issues</head><p>We now pass to semantic issues. Each copy rule ~ generates a corresponding semantics J/~,~ for the programs from 5 pp. The case of procedure calls is now more complicated because declarations of local systems of procedures are allowed. In particular, it is difficult to retain the approach of Section 6.1. Therefore, we proceed in a somewhat different way. We first define by induction on i a sequence Jg~,~ of approximating semantics. The crucial clause concerns procedure calls. We put jE},~(E I p(/~ ' )7)) where S' is defined as in Rule 24.</p><p>As opposed to the approach taken in Section 4.1, here all renamings of local identifiers (necessary to satisfy scope requirements) are done first when we replace S by (~]S') and subsequently at every step where the copy rule ~# is applied, that is, where P(/~, y) is replaced by B~.</p><p>We now define ~z,~ {p} (EIS) {q} iff for all states a, ¢,~zp(o)</p><p>and .~t/l,~(E]S)(a) = T implies ~z q (~).</p><p>The soundness proof of (O, c6) with respect to the ~t,~ semantics proceeds through the same steps as the ones originally defined in Section 3.7 and later repeated in Sections 4.3, 6.1.2, and 6.2.2. Note that the last clause in the definition of Jtz, ~ assures the soundness of Rule 24. The only complicated case in the proof is that of the soundness of Rule 26.</p><p>We now relate copy rules to scope assumptions. In the presence of declarations of local procedures, the ALGOL 60 copy rule leads to a semantics with the static scope assumption. For programs satisfying the "most recent" property (see <ref type="bibr" target="#b41">[41]</ref>) the same result is already achieved by using the "most recent" copy rule. Finally, the naive copy rule leads to a semantics with the dynamic scope assumption. Due to the lack of space, we do not elaborate more precisely on these issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">The Characterization Theorem</head><p>From the theorem which opened this section we know that we cannot expect (O, ~) to be complete in the sense of Cook when &lt;E is the ALGOL 60 copy rule. Olderog <ref type="bibr" target="#b45">[45]</ref> found a rather simple criterion which, when imposed on a true asserted program, guarantees its provability in (O, P). To define this condition, we first introduce two notions.</p><p>Given a program S, we write P ---&gt;s Q iff P and Q are non-formal procedure names from S such that Q occurs freely in the procedure body of P. By a reference chain of S we mean a sequence of the form P1 ---&gt;s P2 --&gt;s "'" ---~s P, where Pi ~ Pj for i # j.</p><p>Given two programs S1 and $2, we write $1 --*~ $2 if $2 can be obtained by a single application of the copy rule ~d, that is, if $2 results from a literal replacement of some call P(/t, y) in $1 by a modified procedure body Bz defined as in the formulation of Rule 23. Let --** stand for the transitive closure of --~. We now say that a program S is P-bounded if, for some constant k, whenever S --*$ $1, then the lengths of reference chains of $1 are bounded by k. Intuitively speaking, a program is P-bounded if it cannot be expanded using the copy rule P to programs with arbitrarily long reference chains.</p><p>Equipped with this notion, we can formulate the following characterization theorem due to Olderog <ref type="bibr" target="#b45">[45]</ref>. THEOREM 5. Let I be an interpretation such that the assertion language is expressive relative to I and 5 p'. Then the following statements are equivalent:</p><p>1. Trl ~o,~,) {p} S (q}. 2. ~i.z (p} S (q} and S is &lt;d-bounded.</p><p>Note that the implication 1 ---) 2 is a strengthening of the soundness theorem concerning (O, ~). The implication 2 --* 1 is a completeness theorem. The proof deals with constructs of the form (EIS) and proceeds by induction on their structure. The step to programs S is obtained by using the last clause in the definition of semantics, ~z, ~, and the rewrite rule.</p><p>All cases in the proof are dealt with in a way analogous to the handling of the cases in the previous proofs. As usual, the nontrivial case is that of procedure calls. The proof is a generalization of the techniques used so far. First, we choose the most general formula for a procedure call P{/~, ~).</p><p>Let 5 be a sequence of all simple variables occurring free in (E ] P(R, y) ) where P(F, y) is a correct procedure call with respect to E. Let 5' be a sequence of fresh variables of the same length as 5. Put p{R, ~) =-E = E'. Choose q(R, y) to be an assertion which defines postdp(/~, y), (E ] P(/~, y)).  Due to the lack of space, we can only present a rough sketch of the proof.</p><p>Given a procedure call P(/~, )7) correct with respect to E, let ~((E I P(/~, )7) )) denote the set of all constructs of the form (E' I P'(/~, Y) ) such that 1. P'(/~', y) is a correct procedure call with respect to E' and 2. it can be obtained by a formal expansion of (EIP(R,)7)) using symbolic execution and the copy rule ~.</p><p>For example, if E is P ~ (O I begin new x; El; P end), then ~((EIP)) is {(E IP), (add(E, El) I P)} because add((add(E, El)), El) = add(E, El). Symbolic execution is incorporated here by symbolically elaborating the block.</p><p>Applying this terminology to the procedure declaration E considered in the completeness proof in Section 6.2.2, we have {(EIP(ti , vi)) : i = 1, ..., 4} __ ~l~((EIP(tz, v~))). Intuitively speaking, the set ~ is the set of all correct' procedure calls which could possibly occur during the execution of the program begin E; P(R, y) end. Each such call has an appropriate procedure environment E' in which it is called. This set is usually infinite.</p><p>It turns out, however, that, if the program begin E; P (R,)7) end is Cd-bounded, then this set possesses a finite subset from which all other elements can be derived by a substitution conforming to the restrictions of Rule 26. Lemma 6</p><p>shows that ((EIP(ti, vi))i=~,...,3} is such a subset of ~((EIP(tl, v~))).</p><p>Once such a subset has been found, reasoning analogous to that in Section 6.2.2 can be applied. Namely, take the set A1 of most general formulas for the elements of this subset. Let B be the set of corresponding correctness formulas concerning the bodies B~ related to procedure calls from A~. In turn, let A2 be the set of most general formulas for the procedure c~lls taken from the bodies B~v. A lemma corresponding to the Corollary in Section 6. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.6">Applications of the Characterization Theorem</head><p>The characterization theorem can now be applied to various classes of programs from 5 °p for which the assumption of ~-boundedness can be established. We list several such classes without going into further details.</p><p>1. cd = Cd6o (the ALGOL 60 copy rule, i.e., static scope): a. All programs disallowing one of the features 1, 2, or 5 from Theorem 4. b. All programs disallowing feature 4 from Theorem 4 referring to procedure names.</p><p>2. cd = ~dmr (the "most recent" copy rule): All programs satisfying the "most recent" property. 3. &lt;d= ~#n (the naive copy rule, i.e., dynamic scope): All programs from 5 :p.</p><p>It should be noted that not all programs from 5 :p are Cd6o-bounded. Olderog <ref type="bibr" target="#b45">[45]</ref> exhibits such a program. Of course, the existence of such programs follows from Theorems 4 and 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.7">Decidability Issues</head><p>When studying such subclasses, it is sensible to ask whether they are properly defined, that is, whether they form decidable subsets of 5 Qp. The classes listed in 1 and 3 above obviously satisfy this requirement. Also, by a theorem of Kandzia <ref type="bibr" target="#b31">[31]</ref>, the class listed in 2 is a decidable subset of £fP.</p><p>These decidability results should be contrasted with the restrictions imposed on parameters in Section 6.1. Recall that, according to these restrictions, all actual simple variables are to be distinct and different from global variables of the considered procedure bodies (here, those from E).</p><p>We say that a program is sharing-free if all procedure calls arising during its execution satisfy the above restriction. In <ref type="bibr" target="#b8">[9]</ref> all programs are assumed to be sharing-free. In general, the restriction "sharing-free" is dangerous in light of decidability requirements: if we interpret "sharing-free" as allowing only sharingfree programs in our subclass 5 ° of ~P, then 5 p is in general undecidable. This follows from a result of Langmaack <ref type="bibr" target="#b35">[35]</ref> stating that for 5 pp the formal reachability of procedures is undecidable when the ALGOL 60 copy rule is applied.</p><p>Fortunately, these problems do not arise in Section 6.1 because, by the result of <ref type="bibr" target="#b33">[33]</ref>, sharing is a decidable property for programs without procedures as parameters.</p><p>Another possible interpretation of "sharing-free" is to allow arbitrary programs but restrict the application of Rule 26 to sharing-free procedure calls. But this in turn makes the substitution rule itself undecidable; so the set of provable asserted programs is not r.e. Hence, the only proper way to solve these difficulties is to formulate a proof rule which can deal with sharing. Also, in <ref type="bibr" target="#b8">[9]</ref> no self-application is allowed (e.g., procedure calls of the form P(... P...) are disallowed).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.8">Lipton's Theorem and Its Implications</head><p>The proof of Theorem 4 related decidability of the halting problem for all finite interpretations to the existence of a complete Hoare's system for the language in question. Lipton <ref type="bibr" target="#b38">[38]</ref> showed that these two properties are in fact equivalent for a wide class of programming languages, thereby proving a conjecture of Clarke. Unfortunately, details of the proof are not fully worked out.</p><p>Recently Langmaack <ref type="bibr" target="#b32">[32]</ref> provided a rigorous proof of the theorem for the case of ALGOL-like programming languages. This proof is based on the usual static scope semantics of ALGOL-like programs (defined by the ALGOL 60 copy rule), whereas Lipton uses a more general notion of programming language merely requiring the semantics to be defined by a certain type of interpreter. The version proved by Langmaack can be stated as follows. and suggestions concerning the paper which significantly influenced the final version. Professor H. Langmaack and E. R. Olderog provided detailed suggestions concerning Section 7.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>. Author's present address: LITP, Universit~ Paris 7, 2, place Jussieu, 75221 Paris, France. @ 1981 ACM 0164-0925/81/1000-0431 $00.75 ACM Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981, Pages 431-483.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>AXIOM 1: ASSIGNMENT AXIOM {pit~x]} X := t (p}. RULE 2: COMPOSITION RULE (p} $1 {r}, {r} $2 {q} {p} 81; 82 {q} RULE 3: if-then-else RULE {p A e} S, (q}, (p A ~e} S2 {q} {p} if e then $1 else $2 fi {q} RULE 4: while RULE (p A e} S {p} {p} while e do S od (p/~ -~e) "</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>( 6 )</head><label>6</label><figDesc>O. y+ x=xAx&gt;_O} a:--0 (a. y+ x=xAx&gt;-O) (2) and {a . y+ x=xAx&gt;_O} b:=x {a . y+ b=xAb&gt;_O}; (3) so, by the composition rule, (O.y+x=xAx&gt;_O}a:=O;b:=x{a.y+b=xAb&gt;_O). a:=0;b:=x(a.y+b=xAb&gt;_0). (On the other hand, by the assignment axiom, {(a+l) . y+ b-y=xAb-y&gt;_O) b:=b-y ((a+l) .y+b=xAb_0) (7) and ((a + 1).y+b=xAb&gt;_O}a:=a+l{a.y+b=xAb&gt;-O); (8) so, by the composition rule, {(a+l) . y+b-y=xAb-y&gt;-O) b:=b-y;a:=a+ l (a. y+ b=xAb&gt;_O}. a+ 1) .y+b-y=xAb-y&gt;-O (10) holds; so (10) and (9} imply {a .y+b=xAb&gt;_OAb&gt;-y) b:=b-y;a:=a+ 1 (a. y+b=xAb-&gt;O). (11) (11) implies, by the while rule, {a • y + b = xA b_&gt; 0) while b &gt;_y do b := b -y; a:= a + 1 od {a • y+ b =xA b_0A b&lt; y).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>{x&gt;_0Ay&gt;_0}a:=x;b:--y;z:=l; whileb~0dob:ffib-1;z:=z, aod{z=x y} is true under the interpretation I0 once we write it as {x_~0Ay_&gt;0} a:-x;b:-y;z:=l; whileb~0do {z. a b--x y} b:--b-1;z:=z, aod {z=xY}. Thinking in terms of establishing an invariant and preserving it has immediate implications for reasoning about programs and their design. For example, in the case of the above program, an observation that the loop while even(b) do b := b/2; a := a • a od preserves the invariant z • a b --x y leads to the following improvement: {x _&gt; 0 A y &gt;_ 0} a :--x; b := y; z := 1; whileb~0do{z, a b ffi x y} while even(b) do {z • a b ----X y} b:=b/2;a:=a, a od; b:=b-1;z:=z, aod{z--xY}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>RULE 6 :</head><label>6</label><figDesc>while RULE II. Let p(n) be an assertion with a free variable n which does not appear in S and ranges over natural numbers. Then p(n + 1) --* e, {p(n + 1)} S {p(n)},p(O) --* -~e {3np(n)} while e do Sod {p(0)} Let H0 denote the proof system obtained from H by replacing the while rule (Rule 4) by Rule 6. In Ho we can easily prove total correctness of the program So from Section 2.2 with respect tox_0Ay&gt;0anda.y+ b=xA0_&lt;b&lt;y. Namely, takep(n) =-ran • y&lt;_ b&lt; (n + 1) • ywhere r = a • y+ b =xA b _&gt; 0 is the loop invariant from the proof in Section 2.2. p(n) clearly satisfies the premises of the above rule for e = b _&gt; y and S = b := b -y; a := a + 1. Also, similarly to (6), {x_0Ay&gt;0} a:=0;b:=x{rAy&gt;0} holds. To conclude the proof it is now sufficient to observe that ~i0 r Ay &gt; 0--* 3np(n) and ~0P(0)--~ a • y+ b = xA0_&lt; b&lt;y</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>RULE 8 :</head><label>8</label><figDesc>RECURSlON RULE {p} P {q} I--{p} So {q} {P} P {q}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(y . x = x!} y := y . x (y = x!} (14) and {y. (x+l)= (x+l)!}x:---x+l {y-x---x!}; (15) so, by the composition rule, {y. (x+l)--(x+l)!}x:=x+l;y:=y. x{y=x!}. (16) Since the implication y=x!--*y-(x+l)=(x+l)! (17) is true, by the consequence rule and (13), {x_&gt;0} P{y • (x+ 1) = (x+ 1)!}. (18) (16) and (18) imply, by the composition rule, {x-&gt;0}P;x:=x+l;y:=y.x{y=x!}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>AXIOM 9 :</head><label>9</label><figDesc>INVARIANCE AXIOM {p} P {p} where var(p) N var(So) = O. RULE 10: SUBSTITUTION RULE I {P} P {q} where 5N var(So) = 0 and qN var(So) = 0. {p[:)7/5]} P {q[y/~]} RULE 11: SUBSTITUTION RULE II {p} P {q} where E rl var(So, q) = 6. {p[Y/E]} P {q} ACM Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>RULE 12 :</head><label>12</label><figDesc>CONJUNCTION RULE {p} P {q}, {p'} P {r} {p Ap'} P {q A r}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(~n+l of G, we adopt in K an axiom (I) --* ¢po and a proof rule (I) ---) ¢pl, • •., ~o. (I) "') (pn+l We also have the rule {p} P {q) --) (p} So (q} {p} P {q} corresponding to the recursion rule, the collection rule (I) --) ~1 .... , ~)--) xI.. 0 "---) XI]I, • •., XIPn ' and the selection axiom (I) --) ~ where cp E (I). This translation of G into K corresponds to a translation of a Gentzen natural deduction system into a Gentzen sequent calculus. In the following discussion we write (P ~ S[ cp) instead of cp to indicate that each procedure call P in ¢p refers to the procedure declaration P ~ S. Definition. Let I be an interpretation of L. 1. An implication (P ~ So I (I) ---) xI,) is called I-good if, for every n, (P ~ S(o n) I (~ ---) ~) is true under I. 2. For a nonrecursive procedure declaration P ~ S: a. (P ~ S I (I) --* ~) is true under I if the truth under I of (P ~ S I (I)) implies the truth under I of (P ~ S I ~); and b. (P ~ S I (I)) is true under I if, for all cp E (I), (P ~ S I ~0) is true under I. Definition 1. A correctness phrase is called good if it is/-good for all interpretations I. 2. A proof rule of K is called good if for all interpretations I it preserves the Igoodness of correctness phrases.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>CLAIM 2 1</head><label>2</label><figDesc>. If, for each n, (P ~ S~")I ¢p) is valid, then (P ~ So I ¢P ---) cp) is good. 2. If for each n a proof rule &lt;P S(o") I ¢, ) S (") ~I" (P~ 01 2)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>(</head><label></label><figDesc>p} P (q} --* (p} So (q) {p} P (q} that is, that for any/, if for all n (P ~ S(o ") [ {p} P {q} ---) {p} So {q} ) is true under/, then for all n (P ~ S(o") I {p} P {q} ) is true under I; and d. the goodness of the selection axiom and the collection rule. Proofs of a and b are straightforward. To prove c, assume that for a given I and aUn (P ~ S(o") [ (p} P (q} --4 (p} So (q}) is true under I. (42) Clearly (P ~ S(o°) I {p} P {q} ) is true under L Assume now that for some n (p o(,*) oo I (P} P (q}) is true under I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>LEMMA 1 .</head><label>1</label><figDesc>If ~1 (p} S {q}, then Trz U {E = E} P {qo} t--O (p} S (q}. PROOF. The proof proceeds by induction on the length of S. If S ~ P, the proof is identical to the completeness proof for H. Suppose that S -= P. Assume (E--5) P (qo}. (45) By the invariance axiom, {p, [5/2]} P {p, [5/E]},</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>)</head><label></label><figDesc>Assume ~i (qo A pl[5/E])(r). By the definition of qo there exists a state o such that J6(P) (o) = r and J/z(E = 5) (o). Suppose now that ~I mpl[5/2]  (o). Then, by the validity of the invariance axiom, ~i -Tp~[5/E](r), since ~1(P)(o) = r. This contradicts our assumption, so ~ip~ [5/2] (o). Since ~i (E = 5 A px [5/£]) --)pl, we now get ~xpdo).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Now, by substitution rule II, (2 = 2Ap~) P {ql}, (50) since E = E A p~ ----(E = E A pl [5/2])[2/5]. By the consequence rule, (px) P (ql}; (51) so, by substitution rule I, (pl [5/E] } P {qx [5/5]}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>LEMMA 2 .</head><label>2</label><figDesc>Tr~ b"G (E = 5} P {qo}. PROOF. The proof is immediate. By the defmition of qo, ml {2 = 5} P (qo} ; so ~ (E ~ 5} So (qo} since MdP) = J4dSo). By Lemma 1, Tr~ U {2 = 5} P {qo} ~--G (E ----5) So {qo} ; so, by the recursion rule, Trz ~-G {E ----5) P (qo}-[]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>RULE 14 :</head><label>14</label><figDesc>INVARIANCE RULE {P} P {q} where var(r) gl var(So) = 0. {p A r} P {q A r} RULE 15: ELIMINATION RULE {P} P {q}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>LEMMA 3 .</head><label>3</label><figDesc>If ]~I {p} S {q}, then Tr~ 0 {po(n)} P {2 = 5} }--Go {P} S {q}. PROOF. The proof proceeds by induction on the length of S, and only the case S -P needs explanation. Assume {po(n)} P {E = 5}. (54) By the invariance rule, {po(n) A q~[5/E]} P {E = 5 A ql[5/E]},</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>(LEMMA 4 .</head><label>4</label><figDesc>58) and (59} imply by the consequence rule that (p~} P (ql); Trz t--Go {po(n)} P (£ = 5}. PROOF. Observe that, by the definition of p0, I~z (p0(n + 1)) P {2 = 5); so Imz {p0(n + 1)) So (E = 5} as ~z(S0) = ~z(P). By Lemma 3, Trj O {p0(n)} P (2 --5} t--a ° {p0(n+l)) So (E = 5}. Clearly, ~i -~p0(0); so, by recursion rule II, Trz t--Go (3n p0(n)) P (2 = E). But the implication po(n)~ =In po(n} obviously holds; so, by the consequence rule, Trx t-ao (p0(n)} P (£ = E}. []</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>and.</head><label></label><figDesc>~2(begin new x; S end) = .//4dbegin new x; S end[So~P]) = .//41(begin new x'; S[x'/x][So/P] end) where x' ~ free(S, So).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>RULE 17 :</head><label>17</label><figDesc>VARIABLE DECLARATION RULE II {ply~x] A x = ~o} S {q[y/x]}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>if z = x then t else a[z] ft. ACM Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>Cx =y} a[x] := 1 {a[y] = 1} since (a[y] = 1)[1/a[x]] =-ify = x then 1 else a[y] fi = 1, and this formula is implied by x = y. Also, {true} a[x] :--1 Ca[x] = 1} holds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>6. 1</head><label>1</label><figDesc>Call-by-Name 6.1.1 Nonrecursive Procedures. Consider a procedure declaration of the form P ~ (name(2: 5) I So),</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>RULE 19 :</head><label>19</label><figDesc>PROCEDURE CALL RULE II {p} So {q} {p} P(2: ~) {q} " RULE 20: PARAMETER SUBSTITUTION RULE (p} P(2' : 5') {q} where ~ f3 free(p, q) C 2'. {p[ff, t/2', 5']} P(ff:t) {q[E, t/2', 5']} RULE 21: VARIABLE SUBSTITUTION RULE {P} P(~:t) {q} {p[~/5]} P(d:t) (q[g/5]} where no variable in g or E occurs free in S0[E, t/2, 5].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head></head><label></label><figDesc>~i (p} P(5:t) {q}. Then, by definition of ~#i, ~i {p} SO[E, [/2, 6] {q}. From this it follows due to the above restrictions that ~, (5 = i A p[~/5]} So {q[2/E]}, as no variable clashes arise here. So does not contain procedure calls; so, by the completeness of H + Rule 17, Tr~ t-c {5 = [ A p[Y/E]} So {q[Y/E]}. By the rule of procedure calls, Trl ~-c {5 = t Ap[Y/E]} P(Y: 5) {q[Y/E]}. By the parameter substitution rule, Trl ~-c [t = tap} P(5:'i) (q}; so, finally, by the consequence rule, Trl ~-c [p} P(E:'I) [q}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>ACM</head><label></label><figDesc>Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981. 1. the proof rule Ten Years of Hoare's Logic: A Survey • 467 Thanks to the arguments used in Section 3.7, the above proof rule is also sound in the case of a recursive procedure declaration. Assume now that ~, {p) P(ff:t) (q}. By the above, ~, {pl} P(2:~) (ql}. Repeating the reasoning of Lemma 1, we get {5' = 5) P(2: ~) (q0} t-{pl} P(2: 5) (q~); hence, due to 2, {E'= E} P(E: U) (qo) I-{p) P(ff:t) {q), which was to be proved.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>6. 2</head><label>2</label><figDesc>Call-by-Value and Call-by-Variable 6.2.1 Nonrecursive Procedures. In this section we consider the parameter mechanisms of call-by-value and call-by-variable, which can be found in the programming language PASCAL and other languages. We allow local variables as well as subscripted variables. Consider a declaration P~B where B--(valx;vary[So)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>putting ~z(P(t, v)) = J&amp;(B[t, v]), and, consequently, for a program S containing calls of P, ~I(S) = JEz(S[ So/ P]) ACM Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>LEMMA 5 .</head><label>5</label><figDesc>Let S be a program and let P(ti, vi),=l ...... be all procedure calls occurring in S'. If ~z (p} S' (q}, then TRz U {p(ti, vi)} P(ti, vi) {q(ti, vi)}i=l ...... ~--(p} S' (q}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>RULE 22 :</head><label>22</label><figDesc>AXIOM OF INCORRECT PROCEDURE CALLS (p) (El P(/~,, •1)) {q}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>RULE 23 :</head><label>23</label><figDesc>RECURSlON RULE III {pi) (Ei[Pi(Ri, yi)) (qi)i-1 ...... [-(pi) (El IBis,) (qi)i=l ...... (p,} (EIIPI(Rx, yl)) {q~} where, for some Si (i = 1 ..... n), 1. Pi ~ (proc R~; var Y~ I s,&gt; ~Ei with In, I = I R; I, I:,1 = lY; I; and 2. (Si[Ri/R ~][ yi//)5~], Idi) ~ Bi~¢ where Idi = idf(Ei, Pi (Ri, yi)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>RULE 24 :</head><label>24</label><figDesc>REWRITE RULE (p} (OlS') {q} {p} S (q} where S' = S in the case of the naive copy rule ~n and S' = S where S' is distinguished (different defining occurrences of identifiers are denoted differently) in the case of the ~so and ~¢mr copy rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head>RULE 25 :</head><label>25</label><figDesc>RULE OF BLOCKS {p[y/x] /~ x = ~o} (add(E, El) I S1) {q[y/x]} {p} (E I begin new x; El; $1 end) {q}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_34"><head></head><label></label><figDesc>i--1 ./~,~(EIBD if i~1, P~(proe~';varylS)~E = with I ql = I,q' I, lYl = lY'I; undefined otherwise. Here, analogously to Rule 23, (S[R/[t'][y/y'], Id)~ B~ where Id = idf(E, P(/~, Y)). The semantics of blocks is defined by the clause J/C~,~(E I begin new x; El; $1 end)(o) = DROP(Jf~.~(add(E, El) [ $1)(o'), x) where o' = a (3 (x, _~).Here the definition and use of states of Section 4.5 are adopted. The other clauses are defined as usual. We now put i=0 and ;gr,~(S) = ~¢6,~(O I S')</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head></head><label></label><figDesc>In a manner similar to the way we proved the completeness of G we can prove that, if~z,~ (p} (EIP(/~,)7)) {q), thenTrzU (p(/~,)7)(EIp(/~,)7)) {q(~,])} t-(o,~)(p) (EIP(/t,])) (q}.Thus, as in Section 6.2.2, the problem reduces to proving the most general formula, that is, to proving that Trl t-(o,~ {p(/t, :~)} (EIP([t, :~)) {q(/t, )7)}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head></head><label></label><figDesc>2.2 states that Trl (J A1 U A2 I-(o.~)B. Now, by the choice of A~, all formulas from A2 can be derived from A~ by Rule 26. Thus Trz (J A1 F-(o,~B. By Rule 23, Tr~ F-(o,~) A~. In particular, (63) holds as desired.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>It is not difficult to see that the proof systems H + Rule 16 and H + Rule 17 are equivalent. However, if we allow procedures, the corresponding proof systems H + Rules 7, 16 and H + Rules 7, 17 are no longer equivalent. To see this, take the correctness formula {true} S {x = 1} considered in Section 4.3. It is easy to see that it cannot be proved in H + Rules 7, 17. A straightforward proof shows rather that {true} S ix = 0} holds.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The hypothesis of this rule states that the formulas (pi} B[ti, vi]  {qi} for i = 1, .... n can be proved from the assumptions (pi} P(ti, vi) {qi}i=l ...... The conclusion of the rule states that (pl} P(6, v~) (ql} can be proved (without any assumptions), but of course all formulas (pi} P(ti, vi) {qi)i=l ...... can be taken here as conclusions.</figDesc><table><row><cell>pi} P(ti, vi) (qi}i=l ...... F'-(pi} B[ti, vii (qi}i=] ......</cell></row><row><cell>(p]} P(tl, vl) (q~}</cell></row></table><note><p>using other proof rules. These assumptions are needed to deal with the (inner) calls from the procedure body, or, more precisely, from B[t~, vl].</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>That is, assertions which define a recursive set. ACM Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981,</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank D. Harel, P. E. Lauer, E. W. Mayr, and J. Zucker for their comments on earlier versions of this paper. One of the referees made extensive comments ACM Transactions on Programming Languages and Systems, Vol. 3, No. 4, October 1981.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We now consider the case of recursive procedures. To provide a semantics in the case in which P is recursive, we proceed as in Section 3.6. If we assume now that So E ~y\~v, we can define a meaning of a program S ~ ~T\~ v by putting .or</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>J//h(S) = t9 ~dS[S~o"~/P])</head><p>where S~ °~ -~2; Using these definitions, the proof system G + Rule 16 for Y~T is sound and complete in the sense of Cook. Indeed, the arguments used in Sections 3.7 and 3.8 can be applied here without any changes. The additional case of blocks is reduced as above to the already handled case of programs from A zv.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Problems with Uninitialized Variables</head><p>In Rule 16 we incorporated the assumption that each local variable is initialized by using the formula y = w. To prove the soundness (and completeness) of this rule, we were forced later to reflect this assumption while defining semantics for blocks. But is this assumption needed?</p><p>We might equally well drop the formula y = w from the premise of the rule and, while providing a semantics, initialize each local variable to, say, the first element of the domain of I not in range(o). It should be clear that with such changes the claim (62) retains its validity; so both the soundness and the completeness proofs remain valid.</p><p>Why then did we not adopt this simpler solution? The answer is subtle. Consider the following correctness formula: {true} begin new z; x := z end; begin new u; y := u end ix = y}.</p><p>According to the semantics we adopted and also the semantics we have just suggested, this formula is true under any interpretation/. It is also easy to prove it in the system H + Rule 16, since clearly both {true} begin new z; x := z end ix = w} and ix = w} begin new u; y := u end ix = y} can be proved.</p><p>If, however, we adopt the proposal just suggested, we cannot find any intermediate assertion which would play the role of x = w above. What is more, the suggested semantics results in an inexpressiveness of any L relative to any I and Azv! (The case in which I II = 1 should be excluded here, since the suggested semantics is then ill-defined.) To see this, note that the set postI(true, begin new z; x := z end) is not definable by any formula of L. Thus the completeness proof is indeed valid but vacuously so.</p><p>All these problems were caused here by the use of uninitialized local variables. We could avoid these difficulties by simply disallowing programs in which some local variables are uninitialized. Such a class of programs can easily be defined, and the newly suggested approach can be taken in dealing with it. This is the solution adopted in <ref type="bibr" target="#b14">[14]</ref>. By the definition of S', x is not free in So. Therefore, {p(ti, vl)[y/x]} P(t~, v;) {q(ti, vi)[y/x]} can be derived from {p(ti, vi)} P(ti, vi) {q(ti, vi)} using the corresponding parameter substitution rule. Also, since x ~ free(So) and y is a fresh variable, and ~p(ti, vi)[ y/x] +-~ p(t~, v~) ~i q(ti, vi)[ y/x] ~-* q(t~, v~).</p><p>The last three facts imply the claim. [] It is this case in the proof of Lemma 5 which forces us to work with S' instead of directly with S. Note that, if x were free in So, then we could not apply the corresponding parameter substitution rule. Also, observe that, if dynamic scope were assumed here, then we could use Rule 17 instead of Rule 16. Consequently, we could work directly with S, and the rewrite rule would be unneeded in the proof system. COROLLARY. For any procedure call P(tl, vl),</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TRI U {p(ti, vi)} P(ti, vi) {q(ti, vi)}i=1,2,3,4 ~-{p(ti, v~)} B[ti, vii' {q(t, v~)}~=~,2.,3 where, for i = 2, 3, 4, P(ti, vi) is the procedure call occurring in B[ti-1, vi-~]'.</head><p>LEMMA 6. {p(t4, V4)} P(t4, v4) {q(t4, V4)} can be derived from {p(t,~, v3)} P(t3, v3) {q(t3, v3)} using the corresponding parameter substitution rule.</p><p>The proof distinguishes eight different cases depending on the form of vl and v0, where P(to, Vo) is the inner call of So. Now, by the above corollary, Lemma 6, and the rewrite rule, we get TR~ U (p(t~, v~)} P(t~, v~) (q(ti, vi)}~=1,2,3 ~ (p(ti, v3} B[t~, v~] {q(ti, v~)},=~,2..~; so, by the recursion rule, TRz ~-{p(tl, v~)} P(tl, v~) {q(tl, vD}.</p><p>It should be noted that the proof of Lemma 6 leads to a veritable combinatorial explosion of cases to be dealt with when So contains more than one procedure call and/or there are more than two formal parameters. Some other parameter mechanisms can be described in a way similar to the above discussion. By way of illustration, consider a declaration of a recursive procedure P: and where y is a formal result parameter as used in ALGOL W (see <ref type="bibr" target="#b56">[55]</ref>).</p><p>We define The corresponding proof system is sound and complete in the sense of Cook. The proofs are virtually the same as in the case of call-by-variable. The only difference is that the case of procedure calls in the completeness proof is now easier to handle and does not lead to a combinatorial explosion of the cases in the proof of Lemma 6. The reason is that a call-by-result parameter, in contrast to a call-by-variable parameter, does not lead to a substitution in the procedure body. As a result, (p(ta,"(i) va(i))), p(t(ai), o3(i)). [q(ea ,"(~) v~i))} can be derived from {p(t~ i), v(2i))} P(t(z i), v~ ~)) { q(t(z ~), v(z~))} using the corresponding substitution rule.</p><p>Here P(t~ i), v(2 i)) is the ith procedure call occurring in B[tl, vl] , and P(t(a ~), va is the ith procedure call occurring in B[t(j ), v~J)] ' for somej. 6.2.3 A Discussion. One of the basic disadvantages of the proof systems dealt with in this section is the fact that each procedure call requires a separate proof of the premise concerning the body of the procedure in question. It should be possible to remove this deficiency by following the approach presented in the previous section and imposing appropriate restrictions on the actual parameters.</p><p>A useful observation in this respect is that procedure declarations where u is a fresh variable lead to equivalent procedure calls when no subscripted variables are allowed. Therefore, the proof systems from the previous section dealing with the second declaration can be readily adopted to deal with programs in the context of the first declaration. Thus, in effect the study of call-by-value and call-by-variable can be reduced to the study of call-by-name. What remains to be done here is to incorporate subscripted variables and the static scope assumption into this framework. Another point concerns the use of the renaming mechanism denoted here by the ..... sign. First, note that we could use a slightly different version of the recursion rule, obtained by replacing B <ref type="bibr">[ti, vi]</ref> in the recursion rule by B[ti, v~]'. After this change, the rewrite rule needs to be applied only once: as the last step of the proof. Thus, for any program S the whole proof deals in fact with programs of the form Si. But for such programs it does not matter which of the two variable declaration rules is applied. We conclude that, when using the refined version of the recursion rule, we can adopt variable declaration rule II provided that the rewrite rule is applied exactly once, namely, as the last step of the proof.</p><p>If we now drop from the recursion and rewrite rule the ..... sign, we get a sound and complete proof system dealing with the dynamic scope assumption. Thus we can treat static and dynamic scope in a uniform way here. At the level of semantics, a similar uniformity can be found by distinguishing between two forms of substitution: [.../P] and (.../P), defined in Sections 6.2 and 6.1, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Bibliographical Remarks</head><p>The division E: ~ of formal name parameters and the restriction on the procedure calls in Section 6.1 are from <ref type="bibr" target="#b26">[26]</ref>. Rules 20 and 21 are from <ref type="bibr" target="#b13">[13]</ref>; they are refinements of the corresponding proof rules from <ref type="bibr" target="#b26">[26]</ref> where global variables in procedure bodies (i.e., free variables different from formal parameters) are disallowed. Both Cook <ref type="bibr" target="#b13">[13]</ref> and Gorelick <ref type="bibr" target="#b19">[19]</ref> proved slightly stronger completeness results. The definition in Section 6.1.2 of the meaning of calls of recursive procedures is from <ref type="bibr" target="#b29">[29]</ref>. The restrictions on procedure calls used in <ref type="bibr" target="#b19">[19]</ref> are lifted in <ref type="bibr" target="#b6">[7]</ref>, where the static scope is also assumed. A recent paper of Gries and Levin <ref type="bibr" target="#b21">[21]</ref> deals with related issues but only for the case of nonrecursive procedures. The notation "Bit, v]" and the corresponding recursion rule in Section 6.2.2 are from <ref type="bibr" target="#b2">[3]</ref>. The definition of semantics of programs containing procedure calls suggested in Section 6.2 is partially motivated by <ref type="bibr" target="#b45">[45]</ref>. Clarke <ref type="bibr" target="#b9">[10]</ref> relates various completeness results concerning recursive procedures with parameters called by name to the existence of fixed points of some operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">PROCEDURES ~,S PARAMETERS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Clarke's Incompleteness Result</head><p>A satisfactory treatment of procedures having procedures as parameters is impossible in full generality within the framework of Hoare's logic. This rather astonishing result was proved by Clarke <ref type="bibr" target="#b8">[9]</ref> and is the contents of the following theorem. THEOREM 4. There exists no Hoare's proof system which is sound and complete in the sense of Cook for a programming language which allows 1. procedures as parameters in procedure calls, 2. recursion, 3. static scope, 4. global variables in procedure bodies, and 5. local procedure declarations.</p><p>The proof follows the line of incompleteness results proved in Section 2.7. First, the following crucial lemma is proved. LEMMA 7. The halting problem is undecidable for programs in a programming language with features (1) to (5) above for all finite interpretations I with [1[&gt;_2. Now take a finite interpretation I with I I I &gt;_ 2. It is easy to see that Trz is a recursive set. Thus the set of asserted programs ~ such that Trz F-w ~ in a Hoare's system W is recursively enumerable. Also, as observed in Section 2.9, the assertion language is expressive relative to I and the class of programs considered. On the other hand, Lemma 7 and the Fact from Section 2.7 imply that the set of all asserted programs from the above programming language which are true THEOREM 6. For any "acceptable" ALGOL-like programming language PL the following are equivalent:</p><p>1. PL has uniformly decidable halting problems for finite interpretations. 2. PL has a sound and complete Hoare's logic provided the assertion language allows quantifier-free formulas only.</p><p>PL is called acceptable if PL is closed under certain program transformations such as replacing basic statements in a program S ~ PL by an arbitrary program S' E PL. Roughly speaking, the existence of Hoare's logic means here that the set {¢p : ~i ~} is uniformly recursively enumerable in Tri for interpretations I satisfying the expressiveness condition.</p><p>Note that the existence of a Hoare's system which is sound and complete in the sense of Cook implies the existence of sound and complete Hoare's logic.</p><p>Theorem 6 implies that for all toy programming languages considered in Sections 2-6 of this paper there exists a sound and complete Hoare's logic. However, it must be noted that the above theorem does not provide any useful axiomatization of the corresponding Hoare's logics. Also, quantifiers are disallowed in the assertions. In contrast, all proof systems considered in this paper are natural and can be used straightforwardly to prove the correctness of programs.</p><p>An interesting question is whether there exists an application of Theorem 6 which shows the existence of a sound and complete Hoare's logic for a programming language with no known sound and complete Hoare's proof system. The answer is positive. Consider the class of all programs from 5 p" which disallow selfapplication and global simple variables in procedure bodies. Langmaack <ref type="bibr" target="#b34">[34]</ref> proved that this class of programs satisfies condition 1 of Theorem 6 in the case of the ALGOL 60 copy rule. By Theorem 6 there exists a sound and complete Hoare's logic for this class of programs.</p><p>The problem of finding a natural Hoare's proof system for this class of programs is offered in <ref type="bibr" target="#b36">[36]</ref> as a challenge to researchers in this area. It should be noted that the characterization theorem does not apply here, since not all programs in this class are cd60-bounded. An example of such a program that is not ¢d6o-bounded is given in <ref type="bibr" target="#b36">[36,</ref><ref type="bibr" target="#b45">45]</ref>. There is as yet no proof system available in which the partial correctness of this program can be studied. modifications of the corresponding versions used in <ref type="bibr" target="#b8">[9]</ref>. The construct ~(...) is used implicitly in <ref type="bibr" target="#b19">[19]</ref> and explicitly in <ref type="bibr" target="#b8">[9]</ref>, where it is called a range of a statement. In [1] a completeness result concerning a language disallowing procedures with parameters and with features 2-5 from Theorem 4 is proved. The discussion of sharing in Section 7.7 is due to a private communication from Langmaack and Olderog. In <ref type="bibr" target="#b36">[36]</ref> they give an overview of the results discussed in this section.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A sound complete Hoare-like system for a fragment of PASCAL</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rep. IW 97/78, Mathematisch Centrum</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Recursive assertions are not enough--Or are they?</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G L T</forename><surname>Meertens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1979</biblScope>
			<biblScope unit="page" from="73" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Semantics and proof theory of PASCAL procedures</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Colloq. Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>4th Colloq. Automata, Languages and Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="30" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Exercises in denotational semantics</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Syrup. Mathematical Foundations of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th Syrup. Mathematical Foundations of Computer Science<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1976">1976</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Some natural structures which fail to possess a sound and decidable Hoare-like logic for their while-programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Tucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Mathematisch Centrum</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
	<note>to appear; earlier version appeared as Rep. IW 136/80</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Expressiveness and the completeness of Hoare&apos;s logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Tucker</surname></persName>
		</author>
		<idno>IW 149/80</idno>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Mathematisch Centrum</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Unrestricted procedure calls in Hoare&apos;s Logic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cartwright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Oppen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. Rec., 5th Ann. ACM Symp. Principles of Programming Languages</title>
		<meeting><address><addrLine>Tucson, Ariz.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1978">Jan. 23-25, 1978</date>
			<biblScope unit="page" from="131" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Proving correctness of coroutines without history variables</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="169" to="188" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Programming language constructs for which it is impossible to obtain good Hoare axiom systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="129" to="147" />
			<date type="published" when="1979-01">Jan. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Program invariants as fixed points</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th IEEE Symp. Foundations of Computer Science</title>
		<meeting>18th IEEE Symp. Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="18" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Completeness and incompleteness theorems for Hoare-like axiom systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><surname>Jr</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Dep., Cornell Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Program proving: Coroutines</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clint</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Aeta Inf</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="50" to="63" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Program proving: Jumps and functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="214" to="224" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Soundness and completeness of an axiom system for program verification</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="70" to="90" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Mathematical Theory of Program Correctness</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Correctness proofs for assignment statements</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
		<idno>Rep. IW 55/76</idno>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Mathematisch Centrum</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A Discipline of Programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Complementary Definitions of Programming Language Constructs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Donahue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<date type="published" when="1976">1976</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Assigning meanings to programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AMS Symp. Applied Mathematics</title>
		<meeting>AMS Symp. Applied Mathematics</meeting>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1967">1967</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="19" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">A complete axiomatic system for proving assertions about recursive and nonrecursive programs</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Gorelick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
		</imprint>
		<respStmt>
			<orgName>Dep. Computer Science, Univ. Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. 75</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The multiple assignment statement</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="89" to="93" />
			<date type="published" when="1978-03">March 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Assignment and procedure call proof rules</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="564" to="579" />
			<date type="published" when="1980-10">Oct. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Proving the correctness of regular deterministic programs: A unifying survey using dynamic logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="61" to="81" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">First-Order Dynamic Logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1979-10">1979. October 1981</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Completeness issues for inductive assertions and Hoare&apos;s method</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stavi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<pubPlace>Israel</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dep. Computer Science, Univ. Tel Aviv</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Proof of correctness of data representations</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="271" to="281" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Procedures and parameters: An axiomatic approach</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantics of Algorithmic Languages</title>
		<title level="s">Lecture Notes in Mathematics</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1971">1971</date>
			<biblScope unit="volume">188</biblScope>
			<biblScope unit="page" from="102" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">583</biblScope>
			<date type="published" when="1969-10">Oct. 1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">An axiomatic definition of the programming language PASCAL</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="335" to="355" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Automatic program verification I: A logical basis and its implementation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>London</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Luckham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="145" to="182" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the proper treatment of referencing, dereferencing and assignment</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M V</forename><surname>Janssen</surname></persName>
		</author>
		<author>
			<persName><surname>Van Emde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Boas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Colloq. Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>4th Colloq. Automata, Languages and Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="282" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On the &quot;most recent&quot; property of ALGOL-like programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kandzia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2d Colloq. Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>2d Colloq. Automata, Languages and Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="97" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A proof of a theorem of Lipton on Hoare Logic and applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Langmaack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inst. Inf. Prakt. Math</title>
		<imprint>
			<biblScope unit="volume">8003</biblScope>
			<date type="published" when="1980">1980</date>
			<publisher>W. Germany</publisher>
		</imprint>
		<respStmt>
			<orgName>Univ. Kiel</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">On a theory of decision problems in programming languages</title>
		<author>
			<persName><forename type="first">H</forename><surname>Langmaack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Mathematical Studies of Information Processing</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Int. Conf. Mathematical Studies of Information essing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="538" to="558" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On termination problems for finitely interpreted ALGOL-like programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Langmaack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inst. Inf. Prakt. Math</title>
		<imprint>
			<biblScope unit="volume">7904</biblScope>
			<date type="published" when="1980">1980</date>
		</imprint>
		<respStmt>
			<orgName>Univ. Kiel, W. Germany</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On correct procedure parameter transmission in higher programming languages</title>
		<author>
			<persName><forename type="first">H</forename><surname>Langmaack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="110" to="142" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Present-day Hoare-like systems for programming languages with procedures: Power, limits and most likely extensions</title>
		<author>
			<persName><forename type="first">H</forename><surname>Langmaack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Olderog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Colloq. Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>7th Colloq. Automata, Languages and Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="363" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Consistent formal theories of the semantics of programming languages</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Lauer</surname></persName>
		</author>
		<idno>TR.25.121</idno>
		<imprint>
			<date type="published" when="1971">1971</date>
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
		<respStmt>
			<orgName>IBM Lab</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A necessary and sufficient condition for the existence of Hoare Logics</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th IEEE Syrup</title>
		<meeting>18th IEEE Syrup</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">O slo~nosti induktivnyh uslovii dlja verifikacii arffmeti~eskih programm (On the complexity of inductive assertions for the verification of arithmetical programs)</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Lomazova</surname></persName>
		</author>
		<editor>Materialy Wsesojuznoi Nau~noi StudenSeskoi Konferencii, Matematika, Novosibirsk State Univ., Novosibirsk, U.S.S.R.</editor>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="85" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Proof rules for the programming language Euclid</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>London</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Guttag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Horning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Popek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">The &quot;most recent&quot; error: Its causes and correction</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Mcgowan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Conf. Proving Assertions About Programs; published as joint issue of SIGPLAN Notices</title>
		<meeting>ACM Conf. Proving Assertions About Programs; published as joint issue of SIGPLAN Notices</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1972-01">Jan. 1972. Jan. 1972</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="191" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Axiomatic approach to total correctness of programs</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="253" to="263" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Definability in dynamic logic</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Parikh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. Proc. 12th Ann. ACM Symp. Theory of Computing</title>
		<meeting><address><addrLine>Los Angeles, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1980">April 28-30, 1980</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">General equivalence of expressivity definitions using strongest postconditions resp</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Olderog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inst. Inf. Prakt. Math</title>
		<imprint>
			<biblScope unit="volume">8007</biblScope>
			<date type="published" when="1980">1980</date>
			<pubPlace>West Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. Kiel</orgName>
		</respStmt>
	</monogr>
	<note>Bet.</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Sound and complete Hoare-like calculi based on copy rules</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Olderog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ber. 7905, Inst. Inf. Prakt. Math., Univ. Kiel, West Germany</title>
		<imprint>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
	<note>also Acta Inf., to appear</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Proving assertions about programs that manipulate data structures</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Oppen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. Rec., 7th Ann. ACM Symp. Theory of Computing</title>
		<meeting><address><addrLine>Albuquerque, N.M.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975">May 5-7, 1975</date>
			<biblScope unit="page" from="107" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">An axiomatic proof technique for parallel programs I</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="319" to="340" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1981-10">October 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Semantical considerations on Floyd-Hoare logic</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Pratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th IEEE Symp. Foundations of Computer Science</title>
		<meeting>17th IEEE Symp. Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="109" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Uber die Vollst/indigkeit eines gewissen Systems der Arithmetic ganzer Zahlen, in welchen die Addition als einzige Operation hervortritt</title>
		<author>
			<persName><forename type="first">M</forename><surname>Presburger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">C.R. ler Congr. de Mathdmaticiens de Pays Slavs</title>
		<imprint>
			<date type="published" when="1929">1929</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">A theory of programs: Notes of an IBM Vienna seminar</title>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
	<note>Unpublished</note>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Si-Ioenfield</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Logic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1967">1967</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Axioms for total correctness</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sokoi~owsk[</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="61" to="72" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Total correctness for procedures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sokoi~owski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Symp. Mathematical Foundations of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>6th Symp. Mathematical Foundations of Computer Science<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="475" to="483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A new incompleteness result for Hoare&apos;s system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="168" to="175" />
			<date type="published" when="1978-01">Jan. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A contribution to the development of ALGOL</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="413" to="432" />
			<date type="published" when="1966-06">June 1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1979-09">September 1979. 1981. 1981. October 1981</date>
		</imprint>
	</monogr>
	<note>revised January. accepted May</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
