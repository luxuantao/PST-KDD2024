<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Flaws in Applying Proof Methodologies to Signature Schemes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jacques</forename><surname>Stern</surname></persName>
							<email>jacques.stern@ens.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Dépt d&apos;Informatique</orgName>
								<orgName type="institution">ENS -CNRS</orgName>
								<address>
									<addrLine>45 rue d&apos;Ulm</addrLine>
									<postCode>75230, Cedex 05</postCode>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Pointcheval</surname></persName>
							<email>david.pointcheval@ens.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Dépt d&apos;Informatique</orgName>
								<orgName type="institution">ENS -CNRS</orgName>
								<address>
									<addrLine>45 rue d&apos;Ulm</addrLine>
									<postCode>75230, Cedex 05</postCode>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Malone-Lee</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Dept</orgName>
								<orgName type="institution">University of Bristol</orgName>
								<address>
									<addrLine>Woodland Road</addrLine>
									<postCode>BS8 1UB</postCode>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Dept</orgName>
								<orgName type="institution">University of Bristol</orgName>
								<address>
									<addrLine>Woodland Road</addrLine>
									<postCode>BS8 1UB</postCode>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Flaws in Applying Proof Methodologies to Signature Schemes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4A19923D4EAF33F479F32A2D9C53B100</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Methods from provable security, developed over the last twenty years, have been recently extensively used to support emerging standards. However, the fact that proofs also need time to be validated through public discussion was somehow overlooked. This became clear when Shoup found that there was a gap in the widely believed security proof of OAEP against adaptive chosen-ciphertext attacks. We give more examples, showing that provable security is more subtle than it at first appears. Our examples are in the area of signature schemes: one is related to the security proof of ESIGN and the other two to the security proof of ECDSA. We found that the ESIGN proof does not hold in the usual model of security, but in a more restricted one. Concerning ECDSA, both examples are based on the concept of duplication: one shows how to manufacture ECDSA keys that allow for two distinct messages with identical signatures, a duplicate signature; the other shows that from any message-signature pair, one can derive a second signature of the same message, the malleability. The security proof provided by Brown [7]  does not account for our first example while it surprisingly rules out malleability, thus offering a proof of a property, non-malleability, that the actual scheme does not possess.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In the last twenty years provable security has dramatically developed, as a means to validate the design of cryptographic schemes. Today, emerging standards only receive widespread acceptance if they are supported by some form of provable argument. Of course, cryptography ultimately relies on the P vs. N P question and actual proofs are out of reach. However, various security models and assumptions allow us to interpret newly proposed schemes in terms of related mathematical results, so as to gain confidence that their underlying design is not flawed. There is however a risk that should not be underestimated: the use of provable security</p><p>The first and last examples in this paper are based on the result of an evaluation requested by the Japanese Cryptrec program and performed by this author.</p><p>is more subtle than it appears, and flaws in security proofs themselves might have a devastating effect on the trustworthiness of cryptography. By flaws, we do not mean plain mathematical errors but rather ambiguities or misconceptions in the security model. The first such example appeared recently, when Victor Shoup noted in <ref type="bibr" target="#b28">[29]</ref> that there was a gap in the widely believed security proof of OAEP against adaptive chosen-ciphertext attacks. By means of a nice counter-example in a relativized model of computation, he showed that, presumably, OAEP could not be proven secure from the one-wayness of the underlying trapdoor permutation. A closer look at the literature, notably <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b1">2]</ref>, showed that the security proof was actually valid in a weaker security model, namely against indifferent chosenciphertext attacks (IND-CCA1), also called lunchtime attacks <ref type="bibr" target="#b17">[18]</ref>, and not in the full (IND-CCA2) adaptive setting <ref type="bibr" target="#b23">[24]</ref>. This came as a shock, even though Fujisaki, Okamoto, Pointcheval and Stern <ref type="bibr" target="#b11">[12]</ref> were quickly able to establish that the security of RSA-OAEP could actually be proven under the RSA assumption alone, in the random oracle model. Since the more general result could not hold, a different argument based on specific properties of the RSA function had to be used.</p><p>Goldwasser, Micali and Rivest <ref type="bibr" target="#b13">[14]</ref> introduced the notion of existential forgery against adaptive chosen-message attacks for public key signature schemes. This notion has become the de facto security definition for digital signature algorithms, against which all new signature algorithms are measured. The definition involves a game in which the adversary is given a target user's public key and is asked to produce a valid message/signature pair with respect to this public key. The adversary is given access to an oracle which will produce signatures on messages of his choice. However, the above definition does not directly deal with the most important property of a digital signature, namely non-repudiation: the signer should be unable to repudiate his signature. One should not that an adversary against the non-repudiation property of a signature scheme would be the legitimate signer himself. Hence, such an adversary has access to the private key, and may even control the key generation process.</p><p>The present paper gives further examples of flaws in security proofs, related to signature schemes. Two of them stem from a subtle point that has apparently been somehow overlooked: in non deterministic signature schemes, several signatures may correspond to a given message. Accordingly, the security model should unambiguously decide whether an adaptive attacker is allowed to query several signatures of the same message. Similarly, it should make clear whether obtaining a second signature of a given message, different from a previously obtained signature of the same message, is a forgery or not, and namely an existential forgery.</p><p>The first example that we give is related to the security proof offered in <ref type="bibr" target="#b21">[22]</ref> for the ESIGN signature scheme. Crosschecking the proof, with the above observations in mind, it can be seen that it implicitly assumes that the attacker is not allowed to query the same message twice. Thus, the security proof does not provide security against existential forgeries under adaptive chosen-message attacks.</p><p>It only applies to a more restricted class, which may be termed single-occurrence chosen-message attacks.</p><p>The two other examples are related to the elliptic curve digital signature algorithm ECDSA <ref type="bibr" target="#b0">[1]</ref>. In <ref type="bibr" target="#b6">[7]</ref>, Brown uses the so-called generic group model to prove the security of the generic DSA, a natural analog of DSA and ECDSA in this setting. This result is viewed as supporting the security of the actual ECDSA: in the generic model, ECDSA prevents existential forgeries under adaptive chosen-message attacks. But as already remarked, this security notion does not deal with the important non-repudiation property that signature schemes should guarantee. The obvious definition is that it should be hard for a legitimate signer to produce two messages which have the same signature with respect to the same public key. If a signature scheme did not have this property then a user could publish the signature on one message and then claim it was actually the signature on another. Such a signature we shall call a duplicate signature, since it is the signature on two messages. This shows an inadequacy between the classical security notions and the practical requirements. Furthermore, we show that with ECDSA a signer which controls the key generation process can easily manufacture duplicate signatures, without finding a collision in the hash function. Luckily, however, our construction of duplicate signatures means that, as soon as the signer reveals the second message, the signer's private key is revealed. Concerning the generic group model, which was the sole assumption on which relies the security result provided in <ref type="bibr" target="#b6">[7]</ref>, carefully crosschecking the proof, with the above observations in mind, we see that it actually prevents a forgery which creates a different signature to a previously obtained signature of the same message. Hence, the proof implies the scheme produces non-malleable signatures. Unfortunately, ECDSA does not withstand such forgeries. What goes wrong here is the adequacy of the model. The proof is correct but the underlying model is flawed, since it disallows production of malleable signatures.</p><p>Note that we have not broken any of the two schemes. In particular, there are some easy ways of revising ESIGN so that it satisfies the classical security notions (see e.g. <ref type="bibr" target="#b14">[15]</ref>).</p><p>2 Digital Signature Schemes and Security Proofs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Formal Framework</head><p>In modern terms (see <ref type="bibr" target="#b13">[14]</ref>), a digital signature scheme consists of three algorithms (K, Σ, V ):</p><p>-A key generation algorithm K, which, on input 1 k , where k is the security parameter, outputs a pair (pk, sk) of matching public and private keys. Algorithm K is probabilistic. -A signing algorithm Σ, which receives a message m and the private key sk, and outputs a signature σ = Σ sk (m). The signing algorithm might be probabilistic.</p><p>-A verification algorithm V which receives a candidate signature σ, a message m and a public key pk, and returns an answer V pk (m, σ) as to whether or not σ is a valid signature of m with respect to pk. In general, the verification algorithm need not be probabilistic.</p><p>Attacks against signature schemes can be classified according to the goals of the adversary and to the resources that it can use. The goals are diverse:</p><p>-Disclosing the private key of the signer. This is the most drastic attack. It is termed total break. -Constructing an efficient algorithm which is able to sign any message with significant probability of success. This is called universal forgery. -Providing a single message/signature pair. This is called existential forgery.</p><p>In terms of resources, the setting can also vary. We focus on two specific attacks against signature schemes: the no-message attacks and the known-message attacks. In the first scenario, the attacker only knows the public key of the signer. In the second, the attacker has access to a list of valid message/signature pairs. Again, many sub-cases appear, depending on how the adversary gains knowledge. The strongest is the adaptive chosen-message attack (CMA), where the attacker can require the signer to sign any message of its choice, where the queries are based upon previously obtained answers. When signature generation is not deterministic, there may be several signatures corresponding to a given message. A slightly weaker security model, which we call single-occurrence adaptive chosenmessage attack (SO-CMA), allows the adversary at most one signature query for each message. In other words the adversary cannot submit the same message twice for signature.</p><p>In known-message attacks, one should point out that existential forgery becomes the ability to forge a fresh message/signature pair that has not been obtained during the attack. Again there is a subtle point here, related to the context where several signatures may correspond to a given message. We actually adopt the stronger rule that the attacker needs to forge the signature of message, whose signature was not queried. The more liberal rule, which makes the attacker successful, when it outputs a second signature of a given message, different from a previously obtained signature of the same message, will be called malleability.</p><p>Conversely, the non-repudiation property means the impossibility to produce two messages with the same signature, which will be called a duplicate signature. However, one should note that the adversary for such a forgery is the signer himself, who may furthermore have control on the key generation process. Such a security notion is not covered by the usual notions, and should be studied independently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Random Oracle Model</head><p>Ideally, one would like to obtain provable security for a signature scheme, based on the sole assumption that some underlying computational problem is hard. Unfortunately, very few schemes are currently known that allow such a proof. The next step is to hope for a proof in a non-standard computational model, as proposed by Bellare and Rogaway <ref type="bibr" target="#b2">[3]</ref>, following an earlier suggestion by Fiat and Shamir <ref type="bibr" target="#b10">[11]</ref>. In this model, called the random oracle model, concrete objects such as hash functions are treated as random objects. This allows one to carry through the usual reduction arguments to the context of relativized computations, where the hash function is treated as an oracle returning a random answer for each new query. A reduction still uses an adversary as a subroutine of a program that contradicts a mathematical assumption, such as the assumption that RSA is one-way <ref type="bibr" target="#b24">[25]</ref>. However, probabilities are taken not only over coin tosses but also over the random oracle.</p><p>Of course, the significance of proofs carried in the random oracle is debatable. Hash functions are deterministic and therefore do not return random answers. Along those lines, Canetti et al. <ref type="bibr" target="#b7">[8]</ref> gave an example of a signature scheme which is secure in the random oracle model, but insecure under any instantiation of the random oracle. Despite these restrictions, the random oracle model has proved extremely useful to analyze many encryption and signature schemes. It clearly provides an overall guarantee that a scheme is not flawed, based on the intuition that an attacker would be forced to use the hash function in a non generic way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Generic Algorithms</head><p>Recently, several authors have proposed to use yet another model to argue in favor of the security of cryptographic schemes, that could not be tackled by the random oracle model. This is the so-called black-box group model, or generic model <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b16">17]</ref>. In particular, paper <ref type="bibr" target="#b6">[7]</ref> considered the security of ECDSA in this model. Generic algorithms had been earlier introduced by Nechaev and Shoup <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b27">28]</ref> to encompass group algorithms that do not exploit any special property of the encodings of group elements other than the property that each group element is encoded by a unique string. Typically, algorithms like Pollard's ρ algorithm <ref type="bibr" target="#b22">[23]</ref> fall under the scope of this formalism, while index-calculus methods do not.</p><p>We will now go into a bit more detail of proofs in this generic model, because in one of our examples, this model is the origin of the apparent paradox. More precisely, we will focus on groups which are isomorphic to (Z q , +), where q is a prime. Such groups will be called standard cyclic groups. An encoding of a standard cyclic group Γ is an injective map from Γ into a set of bit-strings S. We give an example: consider a subgroup of prime order of the group of points of a non-singular elliptic curve E over a finite field F. Given a generator g of E, an encoding is obtained by computing σ(x) = x • g, where x • g denotes the scalar multiplication of g by the integer x and providing coordinates for σ(x). Note that the encoding set appears much larger than the group size, but compact encodings using only one coordinate and a sign bit ±1 exist and, for such encodings, the image of σ is included in the binary expansions of integers &lt; tq for some small integer t, provided that q is close enough to the size of the underlying field F. This is exactly what is recommended for cryptographic applications <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b8">9]</ref>.</p><p>A generic algorithm A over a standard cyclic group Γ is a probabilistic algorithm that takes as input an encoding list L = {σ(x 1 ), . . . , σ(x k )}, where each x i is in Γ . While it executes, the algorithm may consult an oracle for further encodings. Oracle calls consist of triples {i, j, }, where i and j are indices of the encoding list L and is ±. The oracle returns the string σ(x i ± x j ), according to the value of and this bit-string is appended to the list L, unless it was already present. In other words, A cannot access an element of Γ directly but only through its name σ(x) and the oracle provides names for the sum or difference of two elements addressed by their respective names. Note however that A may access the list L at any time. In many cases, A takes as input a pair {σ(1), σ(x)}. Probabilities related to such algorithms are computed with respect to the internal coin tosses of A as well as the random choices of σ and x.</p><p>In <ref type="bibr" target="#b6">[7]</ref>, the adversary is furthermore allowed to include additional elements z i in the encoding list L, without calling the oracle. This is consistent with the fact that one may detect whether an element is in the group or not (e.g. whether the coordinates of a point satisfy the equation which defines the elliptic curve.) However, this definitely enlarges the class of generic algorithm, compared to <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b27">28]</ref>. One can keep the number of additional elements smaller than twice the number of queries, since additional elements not appearing in a further query can be deleted and since each query involves at most two additional elements. Some useful results about the generic model are provided in Appendix A.1.</p><p>Again, from a methodological point of view, proofs in the generic model have to be handled with care. A specific group is not generic and specific encodings may further contradict genericity. If it happens, the exact meaning of a security proof may become highly questionable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Provable Security of ESIGN</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Description of ESIGN</head><p>We follow <ref type="bibr" target="#b21">[22]</ref>, where a specification of ESIGN appears. The key generation algorithm of ESIGN chooses two large primes p, q of equal size k and computes the modulus n = p 2 q. The sizes of p, q are set in such a way that the binary length |n| of n equals 3k. Additionally, an exponent e &gt; 4 prime to ϕ(n) is chosen.</p><p>Signature generation is performed as follows, using a hash function H, outputting strings of length k -1.</p><p>1. Pick at random r in Z pq . 2. Convert (0 H(m) 0 2k ) into an integer y and compute z = (yr e ) mod n. 3. Compute w 0 = z/pq and w 1 = w 0 .pqz. If w 1 ≥ 2 2k-1 , return to step 1. 4. Set u = w 0 • (er e-1 ) -1 mod p and s = r + upq. 5. Output s as the signature of m.</p><p>The basic paradigm of ESIGN is that the arithmetical progression r e mod n+tpq consists of e-th powers of easily computed integers: one adjusts t so as to fall into a prescribed interval of length 2 2k-1 .</p><p>Signature verification converts integer s e mod n into a bit string S of length 3k and checks that [S] k = 0 H(m), where [S] k denotes the k leading bits of S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Approximate e-th Root Problem</head><p>As noted in the previous section, RSA moduli of the from p 2 q offer a very efficient way to solve the following problem, having knowledge of the factorization of n: given n and y in Z n , find x such that x e mod n lies in the interval [y, y + 2 2k-1 ), where the bit-size of n is 3k and [y, y + 2 2k-1 ) denotes {u|y ≤ u &lt; y + 2 2k-1 }.</p><p>It is conjectured that the above problem, called the approximate e-th root problem (AERP) in <ref type="bibr" target="#b21">[22]</ref>, is hard to solve. More precisely, denote by Succ aerp (τ, k) the probability for any adversary A to find an element whose e-th power lies in the prescribed interval, within time τ . In symbols, it reads</p><formula xml:id="formula_0">Pr[(n, e) ← K(1 k ), y ← Z n , x ← A(n, e, y) : (x e mod n) ∈ [y, y + 2 2k-1 )],</formula><p>then, for large enough moduli, this probability is extremely small. Variants of the above can be considered, where the length of the interval is replaced by 2 2k or 2 2k+1 .</p><p>Of course, the factorization of n allows to solve the AERP problem. It is unknown whether the converse is true, i.e. whether AERP and inverting RSA are computationally equivalent. Various attacks against AERP are known for e = 2, 3 (see <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b29">30]</ref>). However, it is fair to say that there is no known attack against AERP when e is greater or equal than 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Security Proof</head><p>For this signature scheme, one can prove, in the random oracle model, the following security result, where T exp (k) denotes the computing time of modular exponentiation modulo a 3k-bit integer.</p><p>Theorem 1. Let A be a SO-CMA-adversary against the ESIGN signature scheme that produces an existential forgery, with success probability ε, within time τ , making q H queries to the hash function and q s distinct requests to the signing oracle respectively. Then, AERP can be solved with probability ε , and within time τ , where</p><formula xml:id="formula_1">ε ≥ ε q H -(q H + q s ) × (3/4) k - 1 2 k-1 and τ ≤ τ + k(q s + q H ) • T exp (k).</formula><p>Our method of proof is inspired by Shoup <ref type="bibr" target="#b28">[29]</ref> and differs from <ref type="bibr" target="#b21">[22]</ref>: we define a sequence of Game 1 , Game 2 , etc of modified attack games starting from the actual game Game 0 . Each of the games operates on the same underlying probability space, only the rules defining how the view is computed differ from game to game.</p><p>Proof. (of Theorem 1). We consider an adversary A outputting an existential forgery (m, s), with probability ε, within time τ . We denote by q H and q s respectively the number of queries from the random oracle H and from the signing oracle. As explained, we start by playing the game coming from the actual adversary, and modify it step by step, until we reach a final game, whose success probability has an upper-bound obviously related to solving AERP. Game 0 : The key generation algorithm K(1 k ) is run and produces a pair of keys (pk, sk). The adversary A is fed with pk and, querying the random oracle H and the signing oracle Σ sk , it outputs a pair (m, s). We denote by S 0 the event that V pk (m, s) = 1. We use a similar notation S i in any Game i below.</p><p>By definition, we have Pr[S 0 ] = ε.</p><p>Game 1 : In this game, we discard executions, which end up outputting a valid message/signature pair (m, s), such that m has not been queried from H. This means restricting to the event AskH that m has been queried from H.</p><p>Unwinding the ESIGN format, we write: s e = 0 w modn. If AskH does not hold, H(m) is undefined, and the probability that</p><formula xml:id="formula_2">H(m) = w holds is 1/2 k-1 : Pr[S 0 | ¬AskH] ≤ 2 -k+1 . Thus, Pr[S 1 ] = Pr[S 0 ∧ AskH] ≥ Pr[S 0 ] - 2 -k+1 .</formula><p>Game 2 : In this game, we choose at random an index κ between 1 and q H . We let m κ be the κ-th message queried to H. We then discard executions which output a valid message/signature pair (m, s), such that m = m κ . Since the additional random value κ is chosen independently of the execution of Game Game 4 : We now simulate the random oracle H, by maintaining an appropriate list, which we denote by H-List. For any fresh query m, we pick at random u ∈ Z n and compute z = u e mod n, until the most significant bit of z is 0. We next parse z as 0 w , where w is of length k -1 and check whether zw.2 2k is less than 2 2k-1 . If this is true, we store (m, u, w) in H-List and returns w as the answer to the oracle call. Otherwise we restart the simulation of the current query. However, we stop and abort the game after k trials. This game differs from the previous one if z remains undefined after Summing up the above inequalities, we obtain</p><formula xml:id="formula_3">k attempts: | Pr[S 4 ] -Pr[S 3 ] | ≤ (q H + q s ) × (3/4) k .</formula><formula xml:id="formula_4">Pr[S 6 ] ≥ Pr[S 3 ] -(q H + q s ) × (3/4) k ≥ ε q H -(q H + q s ) × (3/4) k - 1 2 k-1 .</formula><p>When Game 6 terminates outputting a valid message/signature pair (m, s), we unwind the ESIGN format and get s e = (0 v ) mod n, with v = H(m). If S 6 holds, we know that m = m κ and H(m) = v. This leads to an element whose e-th power lies in the interval [v2 2k , v2 2k + 2 2k ), thus solving an instance of AERP. We finally have: Pr[S 6 ] ≤ Succ aerp (τ , k), where τ denotes the running time of Game 6 . This is the requested bound. Observe that τ is the sum of the time for the original attack, plus the time required for simulations, which amounts to at most k(q s + q H ) modular exponentiations. We get τ ≤ τ + k(q s + q H ) • T exp (k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Comments on the Security Model</head><p>We definitely had to use the SO-CMA model. If the adversary was allowed to submit the same message twice to the signing oracle, the simulation would fail at the second call, since there is a single signature available. Thus, contrarily to what is claimed in <ref type="bibr" target="#b21">[22]</ref>, the result only applies to single-occurrence adaptive chosen-message attacks. We do not know how to extend the proof to deal with the stronger CMA model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Duplicates in ECDSA</head><p>Let us now turn to the ECDSA signature scheme, on which we give two more examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Description of ECDSA</head><p>The ElGamal signature scheme <ref type="bibr" target="#b9">[10]</ref> appeared in 1985 as the first DL-based signature scheme. In 1989, using the Fiat and Shamir heuristic <ref type="bibr" target="#b10">[11]</ref> based on fair zeroknowledge <ref type="bibr" target="#b12">[13]</ref>, Schnorr provided a zero-knowledge identification scheme <ref type="bibr" target="#b25">[26]</ref>, together with the corresponding signature scheme. In 1994, a digital signature standard DSA <ref type="bibr" target="#b19">[20]</ref> was proposed, whose flavor was a mixture of ElGamal and Schnorr. The standard was later adapted to the elliptic curve setting under the name ECDSA <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b19">20]</ref>. Following <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>, we propose the description of a generic DSA (see Figure <ref type="figure" target="#fig_1">1</ref>), which operates in any cyclic group G of prime order q, thanks to a reduction function. This reduction function f applies to any element of the group G, into Z q . In the DSA, f takes as input an integer modulo p and outputs f (r) = r mod q. In the elliptic curve version <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b8">9]</ref>, the function is defined in a more intricate manner, which we now describe. An elliptic curve point r is given by two coordinates (x, y), which take values in the base field. For elliptic curves over prime fields, one simply sets f (r) = x mod q. For curves over F 2 m , x is a sequence of m bits and f (r) is obtained by first turning x into an integer less than 2 m , by a standard conversion routine. Anyway, one just has to keep in mind that in ECDSA the function f depends on the x-coordinate only, and thus f (-r) = f (r).</p><p>Before we review the security results proven about ECDSA, namely in <ref type="bibr" target="#b6">[7]</ref>, let us show some surprising properties of the scheme due to the above choice of reduction function f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Duplicate Signatures</head><p>Let us first describe how to produce duplicate signatures for ECDSA. Recall we have two messages m 1 and m 2 and we wish to produce a signature which is valid for both messages, with a possible control on the key generation process. We will do this by "concocting" a public/private key pair, hence we see that our method assumes that the two target messages are known to the signer before he generates his public/private key pair. We note that the special key pair is still valid and the user is still able to sign other messages as usual.</p><p>We first compute h 1 = H(m 1 ) and h 2 = H(m 2 ). We generate a random k ∈ {1, . . . q -1}, compute r = f (k • g), and then set the private key to be</p><formula xml:id="formula_5">x = - h 1 + h 2 2r mod q,</formula><p>with the public key being given by y = x • g. To generate our duplicate signature on m 1 and m 2 we compute s = k -1 (h 1 + xr) mod q. That (r, s) is a valid signature on m 1 follows from the definition of ECDSA, we only need to show that (r, s) is also a valid signature on m 2 . We evaluate the r in the verification algorithm for the signature (r, s) on the message m 2 , noting that rx = -(h 1 + h 2 )/2 mod q, r = (h 2 /s)g + (r/s)y =</p><formula xml:id="formula_6">h 2 + rx s g = k h 2 -h 1 h 1 -h 2 g = -k • g = -r.</formula><p>Hence, f (r ) = f (-r) = f (r) = r and the signature verifies.</p><p>Initialization G a cyclic group of prime order q g a generator of G H : {0, 1} → {0, 1} h a hash function f : G → Zq a reduction function K: Key Generation → (y, x) private key 0 &lt; x &lt; q public key y = x • g Σ: Signature of m → (r, s) k randomly chosen 0 &lt; k &lt; q r = k • g r = f (r) if r = 0 abort and start again e = H(m) s = k -1 (e + xr) mod q if s = 0 abort and start again V : Verification of (m, r, s) → valid ? check whether 0 &lt; r, s &lt; q and r = f (r ) where e = H(m) and r = es -1 • g + rs -1 • y Fig. <ref type="figure" target="#fig_1">1</ref>. The Generic DSA Example. As an example we use one of the recommended curves from X9.62 <ref type="bibr" target="#b0">[1]</ref>. The curve is defined over F p where p = 2 192 -2 64 -1, and is given by equation</p><formula xml:id="formula_7">y 2 = x 3 -3x + b, where b = 0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1.</formula><p>This curve has prime group order given by q = 6277101735386680763835789423176059013767194773182842284081, and a base point is given by g = (X, Y ) where</p><formula xml:id="formula_8">X = 0x188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012, Y = 0x07192B95FFC8DA78631011ED6B24CDD573F977A11E794811.</formula><p>Suppose we have a public key given by y = (X , Y )</p><formula xml:id="formula_9">X = 0xA284DB03CAC23298DF9FD9C60560B16292FBE5C7E2C26C25, Y = 0x3F9EABD65A25DA6E72285670AA3D639B381952AFDDECEBAA.</formula><p>Consider the two, hundred byte messages m 1 = [0, 1, 2, 3, . . . , 99] and m 2 = [10, 11, 12, 13, . . . , 109], with hash values, computed via SHA-1 <ref type="bibr" target="#b20">[21]</ref>,</p><formula xml:id="formula_10">h 1 = SHA-1(m 1 ) = 0x1E6634BFAEBC0348298105923D0F26E47AA33FF5, h 2 = SHA-1(m 2 ) = 0x71DDBA9666E28406506F839DAA4ECAF8D03D2440.</formula><p>A duplicate signature on both m 1 and m 2 is provided by (r, s), with r = 0x7B3281ED9C01372E09271667D88F840BEB888F43AF4A7783, s = 0xAFC81CEC549C77F00B4790160A584FD636BB049FD9D9E0BD.</p><p>Note that, as soon as one publishes the duplicate signature, a third party can recover the signer's private key and so is able to forge messages. Hence, this example of duplicate signatures should not be considered a security weakness. However, one does not know that no other duplicate signature exists, for this or any other signature scheme, which do not arise from collisions in the hash function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Malleability</head><p>Still using the above specific property of f , that is f (-r) = f (r), ECDSA is easily malleable. Indeed, from a signature (r, s) of a message m, whatever the keys are, one can derive a second signature, namely (r, -s). Referring to Figure <ref type="figure" target="#fig_1">1</ref>, we see that the values of r that appear in the verification of both signatures are symmetric, so that their image by f is the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Comments on the Security Results</head><p>Let us now see whether the above security notions have been appropriately dealt with or not in the security analyses which appeared in the literature. For the reader's convenience, we include in Appendix A.3 our own version of the theorem and its proof (it is highly based on <ref type="bibr" target="#b6">[7]</ref>). The original theorem <ref type="bibr" target="#b6">[7]</ref> claims that the generic DSA withstands existential forgeries against adaptive chosen-message attacks, in the generic model, under some assumptions, namely the collision-resistance of the hash function and the almost-invertibility of the reduction function (see more details in Appendix A.2). This latter property is not satisfied for DSA, but is clearly satisfied with the reduction function used in ECDSA: given an x-value, if it does not correspond to the x-coordinate of a point on the curve, g outputs Fail, otherwise it randomly outputs one of the (two) corresponding points. Hasse's theorem ensures that g is an almost inverse of f . It furthermore helps to say that the statistical distance between D g and U is less than 5/q. Therefore, f is (5/q, t)-almost-invertible for any t.</p><p>Going through the proof, the reader can check that it actually establishes that, in the generic model, ECDSA is non-malleable under the collision-resistance of the hash function only. The question now becomes: what is the meaning of a proof supporting a scheme by means of an ideal model where the scheme has a property (non-malleability) that it does not have in reality? The flaw here comes from the encoding which is not generic because of the automorphism. Notice that Koblitz curves, as advocated in some standards, are even "less" generic since they have more automorphisms.</p><p>About the duplicate signatures, the proof does not deal with the problem at all, since as already remarked, for non-repudiation the adversary is the signer himself. The methodological lesson is that in some scenarios non-repudiation does not necessarily follows from resistance to existential forgeries. In other words, the security model does not properly account on a possible collusion between the key generation algorithm and the signing algorithm. Whilst our example of duplicate signatures is not a security concern, there may be others. Hence, the proof methodology and security model should allow for this.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have shown that the version of the ESIGN cryptosystem described in the P1363 submission <ref type="bibr" target="#b21">[22]</ref> withstands existential forgery against single-occurrence adaptive chosen-message attacks, based on the hardness of AERP. However, the proof does not extend to the usual CMA scenario. We have also considered a new kind of attack, independent of existential forgeries, since the attacker may be the signer himself. We have illustrated it on ECDSA. It shows that non-repudiation is not totally encompassed by usual security analyses. Finally, we have proved the non-malleability of the generic DSA under adaptive chosen-message attacks. This is in contrast with the actual malleability of ECDSA and puts some doubts on the significance of the generic model.</p><p>In conclusion, we give the warning to practitioners, that security proofs need some time to be discussed, accepted, and interpreted within the research community.</p><p>We give another interpretation of the encoding σ. This interpretation is based on defining from the tuple {z 1 , . . . , z n+2 }, a sequence of polynomials F i (X, X 1 , . . . , X 2n ), with coefficients modulo q, depending on the execution of A:</p><p>-Polynomials F 1 and F 2 are set to F 1 = 1 and F 2 = X, respectively. Thus L = {F 1 , F 2 }. -When the adversary puts an additional k-th element z k in the encoding list, polynomial F n+k+2 is defined as X k , and added to L. -At the -th query {i, j, }, polynomial F is defined as F i ±F j , where the sign ± is chosen according to . If F is already listed as a previous polynomial F h ∈ L, then F is marked and A is fed with the answer corresponding to h. Otherwise, z is returned by the oracle and F is added to L.</p><p>Observe that all F i polynomials are affine, i.e. of the form a 0 + j i=1 a i X i . Once A has come to a stop, variable X is set to x, and the X k s are set to x k . In other words, σ is set at random, subject to the conditions z = σ(F (x, x 1 , . . . , x 2n )), = 1, . . . , n + 2 and z k = σ(x k ), k = 1, . . . , 2n. It is easy to check that the behavior of the algorithm that is driven by the polynomials F i is exactly similar to the behavior of the regular algorithm, granted that elements in the sequence (z 1 , . . . , z n+2 ) are all distinct, and that no polynomial F i -F j vanishes at (x, x 1 , . . . , x 2n ), where i, j range over the 3n + 2 indices of polynomials in L. We call a sequence {z 1 , . . . , z n+2 , x, x 1 , . . . , x 2n } which satisfies both requirements a safe sequence. As explained, an encoding σ can be defined from a safe sequence, such that:</p><formula xml:id="formula_11">σ(F i (x, x 1 , . . . , x 2n )) = z i , for all unmarked F i , and 1 ≤ i ≤ n + 2, σ(x k ) = z k , for k = 1, . . . , 2n.</formula><p>This correspondence preserves probabilities. However, it does not completely cover the sample space {σ, x} since executions such that F i (x, x 1 , . . . , x 2n ) = F j (x, x 1 , . . . , x 2n ), for some indices i, j, such that F i and F j are not identical are omitted. The following lemmas allow to bound the probability of unsafe sequences.</p><p>Lemma 1. Let P be a non-zero affine polynomial in Z q [X 1 , . . . , X j ], then Pr x1,...,xj ∈Zq</p><p>[P (x 1 , . . . , x j ) = 0] ≤ 1 q .</p><p>Lemma 2. Assume n 2 &lt; q. The probability of unsafe sequences is at upperbounded by 5(n + 1) 2 /q.</p><p>Proof. We first observe that sequences of random elements {z 1 , z 2 , . . . , z n+2 }, which are not all distinct appear with probability</p><formula xml:id="formula_12">1 - n+1 k=1 1 - k q ≤ 1 -1 - n+1 k=1 k q ≤ (n + 1)(n + 2) 2q .</formula><p>Next, using Lemma 1, we can bound the probability that F i -F j vanishes at (x, x 1 , . . . , x 2n ) by 1/q. Since there are at most 3n+2 2 such polynomials, we infer that, once {z 1 , . . . , z n+2 } have been set and are distinct, the set of (x, x 1 , . . . , x 2n ) such that {z 1 , . . . , z n+2 , x, x 1 , . . . , x 2n } is not safe has probability bounded by 3n+2 2</p><p>/q = (3n + 2)(3n + 1)/2q. One easily completes the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Preliminaries</head><p>Let f be a reduction function f : G → Z q . An almost-inverse g of f is a probabilistic algorithm g, possibly outputting Fail, such that</p><formula xml:id="formula_13">(i) Pr b∈RZq [g(b) ∈ G ∧ f (g(b)) = b] ≥ 1/3</formula><p>Function f is (δ, t)-almost-invertible, with almost-inverse g, if furthermore:</p><p>(ii) D g ≈ δ U, where</p><formula xml:id="formula_14">D g = {g(b) | b ∈ R Z q ∧ g(b) ∈ G} U = {a | a ∈ R G}.</formula><p>In the second item, notation D g ≈ δ U means that no distinguisher with running time bounded by t can get an advantage greater than δ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 The security proof</head><p>We now prove the security of the generic DSA in the generic model. We follow <ref type="bibr" target="#b6">[7]</ref>, but we adopt a different style of proof, inspired by Shoup <ref type="bibr" target="#b28">[29]</ref>. Referring to Figure <ref type="figure" target="#fig_1">1</ref>, we clarify our use of encodings. The base point g of the group G is identified with the canonical generator 1 of Z q and therefore labeled by σ(1).</p><p>Similarly, the public key y is labeled by σ(x), where x is the private key. When an element r is requested, at signature generation, it is obtained as σ(k), where k is randomly chosen. Finally, the reduction function f directly operates on the set of encodings S. Contrary to the earlier approach of <ref type="bibr" target="#b26">[27]</ref>, we do not model the hash function as a random oracle. Rather, along the lines first investigated in <ref type="bibr" target="#b5">[6]</ref>, we use specific properties of the hash function, such as one-wayness or collision resistance. A couple of lemmas will be needed. We first show how one can perfectly simulate the distribution of valid signatures. We define a simulator S. The simulator, picks elements u ∈ R S, and s ∈ R Z q , and outputs the pair (r, s), with r = f (u). Lemma 3. For any message m, the output distribution of S is perfectly indistinguishable from the output distribution of Σ sk (m).</p><p>We also state an easy lemma from elementary probability theory. Lemma 4. Let S be a binomial distribution, which is the sum of k = 5 ln n Bernoulli trials with probability for success ≥ 1/3. Then, the probability that S = 0 is at most 1/n 2 .</p><p>We finally state the security result.</p><p>Theorem 2. Let Γ be a standard cyclic group of prime order q. Let S be a set of bit-string encodings. Let H : {0, 1} * → {0, 1} h be a hash function and f : S → Z q be a reduction function with almost-inverse g. Let A be a generic algorithm over Γ , that makes at most q s queries to the signing oracle and n queries to the group-oracle, respectively. Assume that A, on input {σ(1), σ(x)}, returns a message m and a valid generic DSA signature (r, s) of m, achieving malleability with probability ε = Succ cma (A), within running time t. Then there exist adversaries B H , C H , D g , operating within time bound t , and such that B H is attempting to invert H = H mod q with success probability ε H , C H is attempting to find collisions for H = H mod q with success probability γ H , and D g is playing a distinguishing game for g, with advantage δ g , where</p><formula xml:id="formula_15">ε ≤ 2γ H + 2n(δ g + ε H ) + 5(n + 1)(n + q s + 1) q , t ≤ t + n × (5τ g ln n + τ H ),</formula><p>with τ g the running time of g and τ H the running time for H.</p><p>Proof. Let A be a generic attacker able to forge a pair consisting of a message m and a valid signature (r, s). We assume that, once these outputs have been issued, A goes on checking the signature by requesting the encoding of es -1 +xrs -1 mod q, where e = H(m), and checking that its image under f is r. The request can be performed by mimicking the usual double-and-add algorithm, calling the generic encoding at each group operation. We assume furthermore, that, after each query m j to the signing oracle, the adversary immediately performs a similar request to check the validity of the answer. To keep things simple, we do not perform any book-keeping of the additional requests and keep n to denote the overall number of queries to the group oracle. We now play games as before:</p><p>Game 0 : An encoding σ is chosen and a key pair (pk, sk) is generated using K(1 k ). Adversary A is fed with pk and, querying the generic encoding and the signing oracle, outputs a message m and a signature (r, s). We denote by S 0 the event V pk (m, (r, s)) = 1 and use a similar notation S i in any Game i below. By definition, we have Pr[S 0 ] = ε. Game 1 : We slightly modify this game, by using the interpretation of the encoding proposed in Section A.1: this uses a sequence {z 1 , . . . , z n+2 , x, x 1 , . . . , x 2n }. As shown in Section A.1, in Lemma 2, the new game only differs from the old on unsafe sequences: | Pr[S 1 ] -Pr[S 0 ] | ≤ 5(n + 1) 2 /q. Game 2 : In this game, we perform additional random tests, without modifying the simulation of the generic oracle: a test is performed at each index , such that the corresponding affine polynomial appears for the first time (or is unmarked following the terminology of Section A.1). Let F = b X + a . We pick at random ẽ ∈ R Z q , and compute c ← g(b a -1 ẽ mod q) until the computation of g returns an answer different from Fail. However, we stop and abort the game after 5 ln n trials. This game differs from the previous one if c remains undefined after 5 ln n attempts. Since ẽ is uniformly distributed, and since the successive trials are mutually independent, we may use Lemma 4 and bound the corresponding probability by 1/n 2 . This provides the overall bound 1/n, when varies. Taking into account the fact that the experiments are independent from the execution of Game 1 , we get Pr[S 2 ] ≥ (1 -1/n) Pr[S 1 ]. Game 3 : Here, we further modify the previous game by letting c replace z , for each index such that F is unmarked. Note that we have f (z ) = b a -1 ẽ mod q. Since the ẽ s are uniformly distributed, the inputs to g are uniformly distributed as well. Applying the so-called hybrid technique, which amounts to using n times the almost-invertibility of g, we bound the difference between the success probabilities of the two games by nδ g , and thus: | Pr[S 3 ] -Pr[S 2 ] | ≤ nδ g . Game 4 : In this game, we simulate the signing oracle. For any query m j to the signing oracle, one computes e j = H(m j ), and issues a random signature (r j , s j ), using the simulation of Lemma 3. Recall that the simulation picks s j at random and computes r j as f (u j ), where u j is randomly drawn from S. By Lemma 3, this simulation is perfect. Observe that, while checking the signature, the adversary requests, at some later time, the encoding of e j s j -1 +xr j s j -1 mod q. We let the first index corresponding to such query, F = b X + a . We modify z , replacing its earlier value by u j and define ẽ as e j = H(m j ). Observe that we still have f (z ) = b a -1 ẽ mod q. This game only differs from the previous one if polynomial e j s j -1 + Xr j s j We note that the final simulation runs in time t ≤ t + n × (5τ g ln n + τ H ) and we finally upper-bound Pr[S 4 ]. We observe that, while checking the signature, the final request of the adversary, with index n + 2, is the encoding of es -1 + xrs -1 mod q, where e = H(m). We let be the first occurrence of F n+2 . If the signature is valid, the following equalities hold:</p><p>es -1 = a mod q, rs -1 = b mod q, f (z ) = b a -1 ẽ mod q and r = f (z ).</p><p>From these equalities, it easily follows that r = f (z ) = re -1 ẽ mod q, which in turn implies e = ẽ mod q. We distinguish two cases:</p><p>-If z has been created according to the rule of Game 3 , then a pre-image m of some randomly chosen element ẽ among the n possible ones has been found. -If z has been created according to the rule of Game 4 , then ẽ = e j is the image under H of a message m j queried from the signing oracle. Furthermore, we have: e j s -1 j = a mod q and r j s -1 j = b mod q. Comparing to the above equalities, we get that s = s j mod q and r = r j mod q. Note that m j cannot be equal to m, since otherwise the output forged signature would coincide with an earlier signature (r j , s j ) of the same message m. Thus, a collision has been found for H , where H (m) def = H(m) mod q.</p><p>The probability that an algorithm running in time t finds a preimage under H of an element among n is at most nε H . From this, we obtain that: Pr[S 4 ] ≤ nε H + γ H . Summing up inequalities, we get the announced result.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Game 5 :Game 6 :</head><label>56</label><figDesc>We modify the simulation by replacing H(m κ ) by v, where v is a bit string of length k -1, which serves as an additional input. The distribution of H-outputs is unchanged: Pr[S 5 ] = Pr[S 4 ]. We finally simulate the signing oracle: for any m, whose signature is queried, we know that m = m κ cannot hold, since corresponding executions have been aborted. Thus H-List includes a triple (m, u, w), such that u e mod n has its k leading bits of the form 0 H(m). Accordingly, u provides a valid signature of m. Therefore, Pr[S 6 ] = Pr[S 5 ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>- 1 collides</head><label>1</label><figDesc>with a previous one. Due to the randomness of s j , we can bound | Pr[S 4 ] -Pr[S 3 ] | ≤ nq s /q.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Tatsuaki Okamoto for fruitful discussions. It should be emphasized that the first and the last examples are based on the result of an evaluation requested by the Japanese Cryptrec program and performed by the first named author. This author wishes to thank Cryptrec.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A The Security Proof of ECDSA</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Proofs in the Generic Model</head><p>With the proofs in the generic model, we identify the underlying probabilistic space with the space S n+2 × Γ × Γ 2n , where S is the set of bit-string encodings. Given a tuple {z 1 , . . . , z n+2 , x, x 1 , . . . , x 2n } in this space, z 1 and z 2 are used as σ(1) and σ(x), the successive z i are used in sequence to answer the n oracle queries and the x i ∈ Γ serve as pre-images of the additional elements z i (in the group) included by the adversary into the encoding list L. However, this interpretation may yield inconsistencies as it does not take care of possible collisions.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm</title>
	</analytic>
	<monogr>
		<title level="j">ANSI X</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="62" to="1998" />
			<date type="published" when="1999-01">January 1999</date>
		</imprint>
		<respStmt>
			<orgName>American National Standards Institute</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Relations among Notions of Security for Public-Key Encryption Schemes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto &apos;98</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1462</biblScope>
			<biblScope unit="page" from="26" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Random Oracles Are Practical: a Paradigm for Designing Efficient Protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1st CCS</title>
		<meeting>of the 1st CCS</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Optimal Asymmetric Encryption -How to Encrypt with RSA</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt &apos;94</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">950</biblScope>
			<biblScope unit="page" from="92" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Attack on a Signature Scheme proposed by Okamoto and Shiraishi</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Delaurentis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto &apos;85</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">218</biblScope>
			<biblScope unit="page" from="28" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Design Validations for Discrete Logarithm Based Signature Schemes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC &apos;2000</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1751</biblScope>
			<biblScope unit="page" from="276" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Exact Security of ECDSA</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R L</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 1363</title>
		<imprint>
			<date type="published" when="2001-01">January 2001</date>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Random Oracles Methodology, Revisited</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th STOC</title>
		<meeting>of the 30th STOC</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Standards for efficient cryptography</title>
		<author>
			<persName><surname>Certicom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-09">September 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms</title>
		<author>
			<persName><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory, IT</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="469" to="472" />
			<date type="published" when="1985-07">July 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">How to Prove Yourself: Practical Solutions of Identification and Signature Problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto &apos;86</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">263</biblScope>
			<biblScope unit="page" from="186" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">RSA-OAEP is Secure under the RSA Assumption. In Crypto</title>
		<author>
			<persName><forename type="first">E</forename><surname>Fujisaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="260" to="274" />
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The Knowledge Complexity of Interactive Proof Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 17th STOC</title>
		<meeting>of the 17th STOC</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="291" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Digital Signature Scheme Secure Against Adaptative Chosen-Message Attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="1988-04">April 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">How to repair ESIGN. NESSIE internal document</title>
		<author>
			<persName><forename type="first">L</forename><surname>Granboulan</surname></persName>
		</author>
		<ptr target="http://www.cryptonessie.org/.DocumentNES/DOC/ENS/WP5/019" />
		<imprint>
			<date type="published" when="2002-05">may 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><surname>Ieee P1363</surname></persName>
		</author>
		<ptr target="http://grouper.ieee.org/groups/1363/" />
		<title level="m">Standard Specifications for Public Key Cryptography</title>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Twin Signatures: an Alternative to the Hash-and-Sign Paradigm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Naccache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th CCS</title>
		<meeting>of the 8th CCS</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Public-Key Cryptosystems Provably Secure against Chosen Ciphertext Attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 22nd STOC</title>
		<meeting>of the 22nd STOC</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="427" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Complexity of a Determinate Algorithm for the Discrete Logarithm</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">I</forename><surname>Nechaev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Mathematical Notes</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="165" to="172" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Federal Information Processing Standards Publication 186</title>
		<author>
			<persName><surname>Nist</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994-11">November 1994. January 2000</date>
			<biblScope unit="page" from="186" to="188" />
		</imprint>
	</monogr>
	<note>Digital Signature Standard (DSS). Revision (To include ECDSA</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Secure Hash Standard (SHS)</title>
		<author>
			<persName><surname>Nist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Federal Information Processing Standards Publication 180-1</title>
		<imprint>
			<date type="published" when="1995-04">April 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">TSH-ESIGN: Efficient Digital Signature Scheme Using Trisection Size Hash</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fujisaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Morita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 1363</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Monte Carlo Methods for Index Computation (mod p)</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Pollard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Computation</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">143</biblScope>
			<biblScope unit="page" from="918" to="924" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Non-Interactive Zero-Knowledge Proof of Knowledge and Chosen Ciphertext Attack</title>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto &apos;91</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="433" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A Method for Obtaining Digital Signatures and Public Key Cryptosystems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Adleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="120" to="126" />
			<date type="published" when="1978-02">February 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Efficient Signature Generation by Smart Cards</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Schnorr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="161" to="174" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Security of Signed ElGamal Encryption</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Schnorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jakobsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asiacrypt &apos;2000</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1976">1976. 2000</date>
			<biblScope unit="page" from="458" to="469" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Lower Bounds for Discrete Logarithms and Related Problems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt &apos;97</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="256" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OAEP Reconsidered. In Crypto</title>
		<imprint>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="239" to="259" />
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">How to break Okamoto&apos;s Cryptosystem by Reducing Lattice Bases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Vallée</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Girault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Toffin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt &apos;88</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">330</biblScope>
			<biblScope unit="page" from="281" to="292" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
