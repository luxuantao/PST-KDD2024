<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Simple Method for Parameterized Verification of Cache Coherence Protocols</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Ching-Tsun</forename><surname>Chou</surname></persName>
							<email>ching-tsun.chou@intel.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<addrLine>3600 Juliette Lane</addrLine>
									<postCode>SC12-322, 95054</postCode>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Phanindra</forename><forename type="middle">K</forename><surname>Mannava</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<addrLine>3600 Juliette Lane</addrLine>
									<postCode>SC12-322, 95054</postCode>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Seungjoon</forename><surname>Park</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<addrLine>3600 Juliette Lane</addrLine>
									<postCode>SC12-322, 95054</postCode>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Simple Method for Parameterized Verification of Cache Coherence Protocols</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A60842AAE0C42D2ABF5B5ECE4DE1DDEB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a simple method for verifying the safety properties of cache coherence protocols with arbitrarily many nodes. Our presentation begins with two examples. The first example describes in intuitive terms how the German protocol with arbitrarily many nodes can be verified using a combination of Murphi model checking and apparently circular reasoning. The second example outlines a similar proof of the FLASH protocol. These are followed by a simple theory based on the classical notion of simulation proofs that justifies the apparently circular reasoning. We conclude the paper by discussing what remains to be done and by comparing our method with other approaches to the parameterized verification of cache coherence protocols, such as compositional model checking, machine-assisted theorem proving, predicate abstraction, invisible invariants, and cut-off theorems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The by-now standard method in industry for debugging a cache coherence protocol is to build a formal model of the protocol at the algorithmic level and then do an exhaustive reachability analysis of the model for a small configuration size (typically 3 or 4 nodes) using either explicit-state or symbolic model checking. While this method does offer a much higher degree of confidence in the correctness of the protocol than informal reasoning and simulation can, and protocol designers often have intuitions about why 3 or 4 nodes suffice to exercise all "interesting" scenarios, it is still very desirable to actually have a proof that the protocol model is correct for any number of nodes.</p><p>Proving a protocol correct for any number of nodes (or some other configuration parameters) is called parameterized verification. Unfortunately, parameterized verification is in general an undecidable problem <ref type="bibr" target="#b0">[1]</ref>. While this result may not be directly applicable to a specific protocol or even a restricted class of protocols, it does suggest that parameterized verification of real-world protocols will likely require a certain amount of human intervention. So our goal here is to figure out how to minimize human intervention and maximize the work done by Main contact.</p><p>A.J. Hu and A.K. Martin (Eds.): FMCAD 2004, LNCS 3312, pp. 382-398, 2004. c Springer-Verlag Berlin Heidelberg 2004 automatic tools (such as model checkers). Most importantly, we would like the automatic tools to extract the necessary information from the protocol that can guide the human prover to come up with the crucial lemmas that will enable the automatic tools to finish the proof unaided.</p><p>Inspired by McMillan's work on compositional model checking <ref type="bibr" target="#b9">[10]</ref> and its application to the FLASH cache coherence protocol <ref type="bibr" target="#b11">[12]</ref>, we present in this paper a simple method for the parameterized verification of cache coherence protocols that meet the above desiderata. Our method has several advantages:</p><p>1. It can be used with any model checker. The freedom to choose model checkers is important in practice, as experience shows that for cache coherence protocols explicit-state model checkers are more robust and often more powerful than symbolic model checkers 1 . In this paper we use Murphi <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b7">8]</ref>. 2. It has a clearly spelled-out and, we hope, easy-to-understand theory justifying the soundness of the apparent circularity in its reasoning. The theory is based on the classical notion of simulation proofs <ref type="bibr" target="#b14">[15]</ref>. 3. The invariants, called noninterference lemmas, that the human prover has to provide for the proof to go through fall far short of a full-fledged inductive invariant, which are very hard to construct for any nontrivial protocol. This is especially true for more complex protocols such as FLASH. <ref type="bibr" target="#b3">4</ref>. The capability of model checkers to do reachability analysis completely automates the reasoning about the states of individual nodes and is used to discover crucial interactions between nodes, which then guide the human prover to formulate the right noninterference lemmas. 5. Having applied our method to the German and FLASH cache coherence protocols successfully, we believe that it is quite applicable to many industrial cache coherence protocols, though certain automation will make it easier and more reliable to use.</p><p>The rest of this paper is organized as follows. Sections 2 and 3 explain our method in intuitive terms using as examples the German and FLASH cache coherence protocols. In addition to demonstrating the feasibility of our method, these examples give a flavor of the hardest human task in applying our method: the formulation of noninterference lemmas using insights gained from counterexamples. Once all the counterexamples are removed, the theory developed in Section 4 based on the classical notion of simulation proofs can be used to justify the 1 There are several possible reasons for this. First, the speed and space requirement of explicit executions do not vary a lot with the details of data structures used in the protocol, while BDD performance can be very sensitive to the precise nature of data structures (e.g., FIFO queues tend to be bad for BDDs). Second, explicit-state model checking can take advantage of symmetry reduction <ref type="bibr" target="#b7">[8]</ref> in each run, while symmetry reduction only reduces the number of cases to prove, not the complexity of each proof, in symbolic model checking <ref type="bibr" target="#b9">[10]</ref>. Third, explicit-state model checkers lend themselves better than symbolic ones to disk-based techniques <ref type="bibr" target="#b3">[4]</ref>, which can trade time for capacity. SAT-based symbolic model checkers are not known to outperform BDD-based ones on cache coherence protocols <ref type="bibr" target="#b12">[13]</ref>.</p><p>apparently circular reasoning needed in our proofs. Section 5 discusses what remains to be done, in particular how the many tedious tasks performed by hand in the German and FLASH proofs can and should be mechanized. Section 6 compares our method with other approaches to the parameterized verification of cache coherence protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Parameterized Verification of the German Protocol</head><p>The German protocol <ref type="bibr" target="#b6">[7]</ref> is a simple cache coherence protocol devised by Steven German in 2000 as a challenge problem to the formal verification community<ref type="foot" target="#foot_0">2</ref> .</p><p>Since then it has become a common example in papers on parameterized verification <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b16">17]</ref>. The Murphi code of the German protocol we will use is shown in Figure <ref type="figure">1</ref> and should be self-explanatory. It is essentially the same as the one in <ref type="bibr" target="#b16">[17]</ref> except that we have shortened identifier names and added data paths to make it more interesting. The state variable AuxData is an auxiliary variable for tracking the latest value of the cache line and does not affect the execution of the protocol in any way; its sole purpose is to allow us to state the property (DataProp) about the correct data values in memory and caches. Now let us try to prove that the invariants CtrlProp and DataProp are true in the German protocol (abbreviated as German below) for an arbitrary number of caching nodes. The basic idea behind our method is as follows. Consider an instance of German with a large number of caching nodes. Choose any 2 of the caching nodes (the reason for the number 2 will become clear later) and observe the behaviors of them plus the home node (whose data structures are not indexed by NODE). Note that since all caching nodes are symmetric <ref type="bibr" target="#b7">[8]</ref> with respect to one another, it does not matter which 2 nodes we choose. We will try to construct an abstract model AbsGerman containing the home node plus the 2 chosen nodes with the following properties: P1. AbsGerman permits all possible behaviors that the home node plus the 2 chosen nodes can engage in, including what those nodes that are not chosen can do to them. P2. The behaviors of AbsGerman are sufficiently constrained that interesting properties (including CtrlProp and DataProp) can be proved about them.</p><p>If we can achieve both P1 and P2, then we can deduce the truth of CtrlProp and DataProp in German from their truth in AbsGerman. But there is clearly a tension between P1 and P2 and it is not obvious how to meet them both. Our strategy is to start with an AbsGerman that obviously satisfies P1 but violates P2 and then refine AbsGerman over several steps until P2 is satisfied, while maintaining P1 all the time. We begin with a naive abstraction of German shown in Figure <ref type="figure">2</ref> that is obtained by making the following changes to the model in Figure <ref type="figure">1</ref>:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. Abstract German protocol: First version</head><p>5. There is nothing to be done about abstracting the state initialization routine Init, since no node pointer is initialized to a specific node (CurPtr is initialized to undefined). 6. We now consider how to abstract the state transition rulesets, each of which has a node parameter i. There are two cases to consider: (a) When i is one of the 2 chosen nodes: This is taken care of by keeping a copy of the original ruleset, since now the type NODE contains precisely those 2 nodes. There is one subtlety, though: note that the precondition of ruleset SendGntE contains a universal quantification over NODE, which is weakened by the "shrinking" of NODE to only the 2 chosen nodes. But since the universal quantification occurs positively, this weakening only makes the rule more permissive, which is what we want (recall P1 above). (b) When i is an Other: We create an abstract version of each ruleset for this case, as shown in Figure <ref type="figure">2</ref>. The goal is to satisfy P1 without making the abstract rulesets too permissive. Our method is summarized below: i. All occurrences of i in the original rulesets are replaced by Other.</p><p>ii. All references to the part of the state indexed by Other that occur positively in the preconditions are replaced by true, since the abstract model does not track that part of the state and hence cannot know the truth values of such references. By substituting true for such references, the rules are made more permissive (indeed, often too permissive, which we will fix later). iii. Similarly, all changes to the part of the state indexed by Other are discarded, since they have no effects on the part of the state that the abstract model keeps. As a consequence, the rulesets SendReq*, SendInv, SendInvAck, and RecvGnt* are all abstracted by a single no-op rule ABS_Skip. Furthermore, since the statement part of ruleset ABS_RecvInvAck now contains only a single "if c then s end", we move the condition c into the guard of the ruleset. iv. If a part of the state indexed by Other is assigned to a state variable in the abstract model, we undefine that variable to represent the fact that the value being assigned is unknown. This happens to MemData in ruleset ABS_RecvInvAck. v. The argument about the universal quantification in the precondition of the ruleset ABS_SendGntE is the same as before.</p><p>Clearly, the above abstraction steps are conservative in the sense that the Abs-German thus obtained permit all possible behaviors of the home node plus any 2 caching nodes in German. It is, however, too conservative: if we model-check the abstract model in Figure <ref type="figure">2</ref>, we will get a counterexample. In the rest of this section we explain how AbsGerman can be "fixed" to remove all counterexamples. But before we do that, let us comment out the property DataProp, because for cache coherence protocols it is generally a good idea to prove all control logic properties before working on any data path properties, as the latter depends on the former but not vice versa.</p><p>We now do the model checking, which produces the following counterexample to CtrlProp: node n 1 sends a ReqE to home; home receives the ReqE and sends a GntE to node n 1 ; node n 1 receives the GntE and changes its cache state to E; node n 2 sends a ReqS to home; home receives the ReqS and is about to send an Inv to node n 1 ; but suddenly home receives a bogus InvAck from Other (via ABS_RecvInvAck), which causes home to reset ExGntd and send a GntS to node n 2 ; node n 2 receives the GntS and changes its cache state to S, which violates CtrlProp because node n 1 is still in E. The bogus InvAck from Other is clearly where things start to go wrong: if there is a node in E, home should not receive InvAck from any other node. We can capture this desired property as a noninterference lemma:</p><formula xml:id="formula_0">invariant "Lemma_1" forall i : NODE do Chan3[i].Cmd = InvAck &amp; CurCmd != Empty &amp; ExGntd = true -&gt; forall j : NODE do j != i -&gt; Cache[j].State != E &amp; Chan2[j].Cmd != GntE end end;</formula><p>which says that if home is ready to receive an InvAck from node i (note that the antecedent is simply the precondition of RecvInvAck plus the condition ExGntd = true, which is the only case when the InvAck is to have any effect in ABS_RecvInvAck), then every other node j must not have cache state E or a GntE in transit to it. (We are looking ahead a bit here: if the part about GntE is omitted from Lemma_1, the next counterexample will compel us to add it.) If Lemma_1 is indeed true in German, then we will be justified to refine the offending abstract ruleset ABS_RecvInvAck as follows: where we have strengthened the precondition by instantiating Lemma_1 with i = Other. (Note that since Other is distinct from any j in NODE in the abstract model, there is no need to test for the inequality.) Why is this strengthening justified? Because Lemma_1 says that when RecvInvAck with i = Other is enabled, the conjunct we add to the precondition of ABS_RecvInvAck is true anyway, so adding that conjunct does not make ABS_RecvInvAck any less permissive.</p><p>But how do we prove that Lemma_1 is true in German? The surprising answer is that we can prove it in the same abstract model where we have used it to refine one of the abstract ruleset! Is there any circularity in our argument? The answer is no, and we will develop a theory in Section 4 to justify this claim.</p><p>So we can refine ABS_RecvInvAck as shown above and add Lemma_1 as an additional invariant to prove in the abstract model. But this is not yet sufficient for removing all counterexamples. More noninterference lemmas and ruleset refinements are needed for that and the model checker will guide us to discovering them via the counterexamples. The final result of this process is shown in Figure <ref type="figure" target="#fig_2">3</ref>, where the step numbers refer to the following sequence of steps:</p><p>Step 1: This is the discussion above.</p><p>Step 2: A rather long counterexample to Lemma_1 shows the following. --Everything up to rule "ABS_SendGntE" --is exactly the same as in Figure <ref type="figure">2</ref>. Other acquires an E and then messes up MemData by writing back undefined data. The fix is to refine ABS_RecvInvAck using a strengthened Lemma_1 asserting that the written back data must be AuxData.</p><p>Step 5: A short counterexample to the second clause of DataProp shows that a node acquires an E copy and then suddenly Other does a store that changes AuxData. The fix is to refine ABS_Store using a strengthened Lemma_2 asserting that if any node i is in state E, then any other node j cannot be in E as well. Looking ahead, j should also be required not to be in S or about to become E or S, for similar counterexamples can arise without these additional properties. Again, the model checker will lead us to these additional requirements even if we have not thought of them.</p><p>Step 6: A counterexample to Lemma_1 shows the following. Node n 1 acquires an E copy, which is invalidated by a ReqE from Other. But before the InvAck reaches home, Other does a store that changes AuxData to violate its equality to the data carried by the InvAck (which is added to Lemma_1 in Step 4).</p><p>The fix is to refine ABS_Store using a strengthened Lemma_2 asserting that if any node has cache state E, then any other node cannot have an InvAck in transit to home.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>After</head><p>Step 6, all counterexamples disappear. According to the theory developed in Section 4, this means that CtrlProp and DataProp (plus the noninterference lemmas) have been proved for German with arbitrarily many nodes. Now we come to the question of why the abstract model is set up to have 2 nodes. This is because none of the universally quantified formulas in the desired properties (CtrlProp and DataProp), the noninterference lemmas (Lemma_1 and Lemma_2), and the rulesets has more than 2 nested quantifiers over nodes. So a 2-node abstract model suffices to give a "maximally diverse" interpretation to the quantified formulas (i.e., an interpretation in which different quantified variables are not forced to take on the same values due to the small size of the universe of the interpretation).</p><p>A related question is why, unlikely McMillan in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12]</ref>, we have been able to dispense with a three-valued logic in the abstraction and reasoning process. The reason for this is that we have imposed the following syntactic constraints on our models and properties: (1) a state variable (or array entry) of type NODE is never compared with another state variable (or array entry) of the same type, and (2) an array over NODE is never indexed into directly by a state variable (or array entry). For instance, in the rulesets SendGnt* in Figure <ref type="figure">1</ref>, instead of using CurPtr to index into arrays directly (as is done in <ref type="bibr" target="#b16">[17]</ref>), we introduce a bound variable i ranging over NODE, test CurPtr = i in the precondition, and use i to index into arrays. Under these syntactic constraints, the abstraction process outlined above becomes feasible <ref type="foot" target="#foot_2">4</ref> and every logic formula is either true or false in the abstract model, where Other is a possible value of a node-valued state variable (or array entry). Our experience suggests that all practical cache coherence protocols can be modeled and their properties stated under these syntactic constraints. Also note that these constraints make it impossible for a formula to implicitly say that "there are K nodes" (e.g., by stating that K nodevalued state variables are pairwise unequal) without a corresponding number of quantifiers over nodes<ref type="foot" target="#foot_3">5</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Parameterized Verification of the FLASH Protocol</head><p>The Murphi code of FLASH we use is translated from McMillan's SMV code <ref type="bibr" target="#b11">[12]</ref>, which in turn is translated from Park's PVS code <ref type="bibr" target="#b15">[16]</ref>. To be precise, this is a model of the "eager mode" of the FLASH protocol <ref type="foot" target="#foot_4">6</ref> .</p><p>FLASH is much more complex and realistic than German. Their numbers of reachable states (after symmetry reduction) are an indication of this: German has 852, 5235, 28088 states and FLASH has 6336, 1083603, 67540392 states at 2, 3, 4 nodes, respectively. So, with brute-force model checking, FLASH is at best barely verifiable at 5 nodes and definitely not verifiable at 6 nodes. (SMV does not perform any better than Murphi on FLASH.) FLASH is a good test for any proposed method of parameterized verification: if the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols. We have done a proof of the safety properties of FLASH for any number of nodes (which is available upon request) using the same method as described in Section 2. Due to space limitations, we cannot give full details here. Below we only list the main differences between this proof and the proof of German:</p><p>1. The number of nodes in the abstract model is 3 (instead of 2). For, in FLASH, the request processing flow is such that it is convenient to make the home node data structures also indexed by NODE. This has the effect of making some noninterference lemmas contain 3 nested quantifers over nodes. 2. In FLASH there are node-indexed arrays whose entries are node-valued, which is a type of data structures that German does not have. In the abstract model those node-valued array entries must be allowed to have the value Other, just like node-valued state variables. 3. In FLASH a ruleset may have up to 2 node parameters. A typical example is a node n 1 with the exclusive copy receiving a forwarded request from the home, in which case n 1 sends the copy directly to the requesting node n 2 without going through the home. To abstract such a ruleset, we have to consider four cases: when n 1 and n 2 are both in the abstract model, when n 1 is in but n 2 is Other, when n 2 is in but n 1 is Other, and when n 1 and n 2 are both Other. So a single ruleset in FLASH may be split into up to four rulesets in the abstract model. Despite these differences and the complexity of FLASH, we find that we need to introduce only five noninterference lemmas (shown in Figure <ref type="figure" target="#fig_3">4</ref>) to get the proof to work for both control logic and data path properties. As can be seen, the conjunction of these lemmas fall far short of an inductive invariant. Perhaps more importantly, the total amount of efforts required for the proof is modest: 1 day to translate the SMV code into Murphi code, 0.5 day to flush out translation errors using conventional model checking (up to 4 nodes), 0.5 day to manually abstract the model, and 1 day to iteratively find the noninterference lemmas from counterexamples and to finish the proof. One interesting observation is that the abstract FLASH model has 21411411 reachable states (after symmetry reduction), so its complexity is roughly between 3-node and 4-node FLASH, which makes perfect sense.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Theory Justifying Apparently Circular Reasoning</head><p>When the proof in Section 2 or 3 is completed, a small (2-or 3-node) abstract model has been constructed and the model checker has proved several invariants (desired properties and noninterference lemmas) about the abstract model. Why are we then justified in concluding that the desired properties are in fact true for the original parameterized model with any number of nodes? We have made some informal arguments, but they appear alarmingly circular. In particular, why is it sound to prove the noninterference lemmas in the abstract model which have been argued to be more permissive than the original model using the very same lemmas? In this section we first develop a theory based on the classical notion of simulation proofs <ref type="bibr" target="#b14">[15]</ref> that justifies such apparently circular reasoning, and then shows how it is applied in the German and FLASH proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Simulation Proofs</head><p>We will use standard set-theoretic notations. For any function f ∈ A → B and</p><formula xml:id="formula_1">C ⊆ A and D ⊆ B, the image of C under f is f (C) = {f (a) ∈ B : a ∈ C} and the inverse image of D under f is f -1 (D) = {a ∈ A : f (a) ∈ D}. A useful fact to know is that f (C) ⊆ D ⇔ C ⊆ f -1 (D) ⇔ ∀a ∈ C : f (a) ∈ D. We also generalize f to operate on A × A: f (a, a ) = (f (a), f(a )). Let V be a set of indices. If B is the (cartesian) product of an indexed family of sets, B = v∈V B v , then f naturally induces a family of functions, f v ∈ A → B v for v ∈ V , such that f (a) = f v (a) : v ∈ V .</formula><p>We will model protocols and their abstractions as state transition systems. Formally, a state transition system (STS) M = (S, I, T ) consists of a set S of states, a set I ⊆ S of initial states, and a transition relation T ⊆ S × S. An execution (s 0 , s 1 , . . .) of M is a finite or infinite sequence of states of M such that s 0 ∈ I and (s i , s i+1 ) ∈ T for all i ≥ 0. A state s of M is reachable iff s is the last state of a finite execution of M ; the set of reachable states of M is denoted by R(M ). For an indexed family of STSs,</p><formula xml:id="formula_2">M v = (S v , I v , T v ) for v ∈ V , the product STS is v∈V M v = ( v∈V S v , v∈V I v , v∈V T v ). Clearly, we have R( v∈V M v ) = v∈V R(M v ). A set of states P ⊆ S is an invariant of M iff R(M ) ⊆ P . A set of states Q ⊆ S is inductive in M iff ∀s ∈ I : s ∈ Q and ∀(s, s ) ∈ T : s ∈ Q ⇒ s ∈ Q.</formula><p>Clearly, an inductive set of states of M is always an invariant of M , and the set of reachable states of M , R(M ), is the strongest invariant of M and is always inductive. All safety properties of M can be reduced to invariant properties provided that a sufficient amount of history information is recorded in the state, which can always be achieved by adding auxiliary variables.</p><p>Milner <ref type="bibr" target="#b14">[15]</ref> introduced the notion of simulation. The following definition is not the most general possible, but rather is tailored to our needs. Let M = (S, I, T ) be a concrete STS and M = ( S, I, T ) an abstract STS. Definition 1. A simulation (P, f ) from M to M consists of an inductive invariant P ⊆ S and an abstraction function f ∈ S → S such that:</p><formula xml:id="formula_3">∀s ∈ I : s ∈ P ∧ f (s) ∈ I (1) ∀(s, s ) ∈ T : s ∈ P ⇒ s ∈ P ∧ f (s, s ) ∈ T (2)</formula><p>The notion of simulation is useful because it allows one to infer invariant properties of the concrete system from those of the abstract system.</p><formula xml:id="formula_4">Theorem 1. If (P, f ) is a simulation from M to M , then: ∀s ∈ R(M ) : s ∈ P ∧ f (s) ∈ R( M )<label>(3)</label></formula><p>Proof. By induction over the lengths of executions of M . Formula (3) says that each reachable state s of M not only satisfies the inductive invariant P , but also inherits all invariant properties of M via f -1 .</p><p>In practice, the main difficulty in using simulation to infer properties of the concrete system from those of the abstract system lies in coming up with a suitable inductive invariant, which is very hard for any nontrivial system. But, fortunately, the following theorem says that there is at least one invariant that always works: Theorem 2. For any function f ∈ S → S, if: <ref type="formula">4</ref>) and ( <ref type="formula">5</ref>) imply ( <ref type="formula">1</ref>) and (2), respectively. So (P, f ) is a simulation from M to M . Furthermore, ( <ref type="formula">6</ref>) and ( <ref type="formula" target="#formula_4">3</ref>) are equivalent in this case.</p><formula xml:id="formula_5">∀s ∈ I : f (s) ∈ I (4) ∀(s, s ) ∈ T : f (s) ∈ R( M ) ⇒ f (s, s ) ∈ T (5) then (f -1 (R( M )), f) is a simulation from M to M and: ∀s ∈ R(M ) : f (s) ∈ R( M ) (6) Proof. Let P = f -1 (R( M )). Since R( M ) is inductive in M , (</formula><p>Theorem 2 is the ultimate source of apparent circularity in our proof method, in the following sense. On the one hand, <ref type="bibr" target="#b5">(6)</ref> says that the invariant property that M inherits from M is f -1 (R( M )). On the other hand, (5) says that f -1 (R( M )) can also be used as an assumption in the inductive step of the simulation proof.</p><p>For reasoning about a parameterized concrete system, the abstract system we will use is a product of many small systems, each of which captures a partial view of the concrete system. What views are will become clear shortly; here we just want to point out that a view is not a node in a cache coherence protocol. Theorem 3. Suppose the abstract system is a product STS, M = v∈V M v , where</p><formula xml:id="formula_6">M v = ( S v , I v , T v ) for v ∈ V . If for each v ∈ V : ∀s ∈ I : f v (s) ∈ I v (7) ∀(s, s ) ∈ T : ( ∀u ∈ V : f u (s) ∈ R( M u ) ) ⇒ f v (s, s ) ∈ T v (8) then (f -1 (R( M )), f) is a simulation from M to M and: ∀s ∈ R(M ) : ( ∀v ∈ V : f v (s) ∈ R( M v ) ) (9)</formula><p>Proof. Theorem 3 is simply a re-statement of Theorem 2 using the following facts:</p><formula xml:id="formula_7">I = v∈V I v , T = v∈V T v , and R( M ) = v∈V R( M v ).</formula><p>Theorem 3 enables one to break a simulation proof into small subproofs, one for each view v as represented by the abstract system M v (see the antecedent of the theorem). Furthermore, <ref type="bibr" target="#b7">(8)</ref> says that the conjunction of all inherited invariants can be used as an inductive hypothesis in every subproof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Applying the Theory</head><p>We now show how Theorem 3 is used. Let M be German or FLASH with a large number of nodes.</p><p>First, note that the states of M are valuations of a finite number of state variables each of which is in one of the following forms: where N is the set of nodes (or rather, node names) and B is the set of booleans. (There is no loss of generality in considering only booleans because enumerated types can be encoded using booleans.)</p><p>Second, there is a fixed m such that any subset of m nodes determines a view v = {n 1 , . . . , n m } of M . In other words, V is the set of m-element subsets of N . (For example, m = 2 for German and m = 3 for FLASH 7 .) For each v ∈ V , the abstraction function f v retains all boolean and pointer variables, discards all array entries except those indexed by a node in v, and sets any pointer-valued variable or array entry to a special value Other ∈ N if its value is ∈ v. More precisely, we define f v as follows:</p><formula xml:id="formula_8">       f v (s)(x) = s(x) f o r x : B f v (s)(y) = s(y) ↓ v for y : N f v (s)(z) = λi ∈ v : s(z)(i) f o rz : array [N ] of B f v (s)(w) = λi ∈ v : s(w)(i) ↓ v for w : array [N ] of N where j ↓ v = if j ∈ v then j else Other.</formula><p>Third, since all nodes are symmetric with respect to each other in M (i.e., the set N is a scalarset <ref type="bibr" target="#b7">[8]</ref>), we can take all M v 's to be isomorphic copies of the same abstract system M r ("r" for "representative"). For instance, for German, we can take M r to be the STS corresponding to AbsGerman (i.e., Figure <ref type="figure" target="#fig_2">3</ref>). For each v ∈ V , M v is obtained from M r by renaming the nodes using any 1-1 mapping from r to v, where r also denotes the set of (non-Other) nodes in M r . Now let us see what Theorem 3 says, given the above. Its conclusion (9) says that the property</p><formula xml:id="formula_9">P = ∀v ∈ V : f -1 v (R( M v )) is an invariant of M .</formula><p>But what does P say? P is true of a state s of M iff for any v ∈ V , any invariant of M v is true of s when projected via f -1 v onto the view v (remember that the set of reachable states is also the strongest invariant). For example, the property CtrlProp has been proved (by model checking) to be an invariant of AbsGerman and hence also an invariant of any isomorphic copy M v of AbsGerman. Since CtrlProp contains 2 node quantifiers and M v contains 2 nodes, (9) allows us to conclude that CtrlProp is an invariant of M . The same reasoning applies to all desired properties and noninterference lemmas in the German and FLASH proofs. Note again that the reasoning depends on the fact that there are at least as many nodes in M v as there are nested node quantifiers in the invariant.</p><p>But, in order to invoke the conclusion (9) of Theorem 3, we must discharge its antecedents <ref type="bibr" target="#b6">(7)</ref> and <ref type="bibr" target="#b7">(8)</ref> for each view v ∈ V . Since M v is a renamed copy of M r and all nodes are symmetric in M , there is no loss of generality in considering only the case when v = r. We will discuss only <ref type="bibr" target="#b7">(8)</ref>, since <ref type="bibr" target="#b6">(7)</ref> is similar but simpler. Consider any step (s, s ) of M . Note that the transition relation T can be decomposed as follows:</p><formula xml:id="formula_10">T = r1∈R1 i∈N T r1 i ∪ r2∈R2 (i,j)∈N ×N T r2 i,j</formula><p>where each T r1 i (respectively, T r2 i,j ) corresponds to an instance of a ruleset with name r 1 (r 2 ) and node parameters i (i and j). So the proof of (8) entails a case split into which ruleset instance, T r1 i or T r2 i,j , the step (s, s ) belongs to. The former case is split further into subcases i ∈ r or i ∈ r; the latter into subcases (i ∈ r and j ∈ r) or (i ∈ r and j ∈ r) or (i ∈ r and j ∈ r) or (i ∈ r and j ∈ r). We will do one subcase for German as an example of the apparently circular reasoning; all other cases in the German and FLASH proofs are similar.</p><p>Consider the ruleset RecvInvAck in German when i ∈ r. Suppose it fires. If we can prove that the state change it effects in M is (via f r ) permitted by ABS_RecvInvAck or ABS_Skip in M r , then we have discharged <ref type="bibr" target="#b7">(8)</ref> for this subcase. Since RecvInvAck fires, its precondition: </p><formula xml:id="formula_11">= ∀v ∈ V : f -1 v (R( M v )</formula><p>) is true at s. So we can project the noninterference lemma Lemma_1 on i and any node j in r. There are two further cases to consider: if ExGntd is true, the projected Lemma_1 implies that the state change is permitted by ABS_RecvInvAck (in particular, the precondition of ABS_RecvInvAck is true); otherwise, if ExGntd is false, RecvInvAck has no effect whatever after f r (because i ∈ r) and hence is trivially permitted by ABS_Skip. QED.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">What Remains to Be Done</head><p>The first priority is clearly mechanization. We have carried out by hand the reasoning steps in Section 4.2 (i.e., the discharging of ( <ref type="formula">7</ref>) and ( <ref type="formula">8</ref>) and the application of ( <ref type="formula">9</ref>)). Though they are quite simple, it would be much better if they are checked by a theorem prover. Another task that should be completely automatable is the construction of the initial abstract models as described in Sections 2 and 3. Such abstraction is very tedious and may allow errors to creep in when the protocol description is long. Ideally, we want to formalize not only the reasoning steps in Section 4.2 but also the theory developed in Section 4.1 in a theorem prover, so that we can have a completely formal proof.</p><p>It is also desirable to be able to reason about liveness, which we cannot do now. We have put some thoughts into this and believe that it is doable, but of course the devil will be in the details. Since Theorem 3 is quite general and does not depend on any intrinsic property of the index set V , it should be possible to use it to reason about parameterized systems where the parameter sets are not scalarsets but have additional structures (such as successor and ordering) <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Comparison with Other Works</head><p>This paper owes most of its intellectual debts to McMillan's work on compositional model checking <ref type="bibr" target="#b9">[10]</ref> and its application to FLASH <ref type="bibr" target="#b11">[12]</ref>. The abstractions we used, the reliance on apparently circular reasoning, and the counterexampleguided discovery of noninterference lemmas are all deeply influenced by McMillan's work. His framework is also more general than ours by encompassing liveness properties <ref type="bibr" target="#b10">[11]</ref>, though we believe that our framework can be generalized to handle liveness as well. Relative to his work, we think we make two main contributions. First, we show that practical parameterized verification can be done using any model checker (not just Cadence SMV) plus some simple reasoning. The freedom to choose model checkers is important in practice, as experience shows that for cache coherence protocols explicit-state model checkers are often superior to symbolic model checkers. Second, we develop a simple theory based on the classical notion of simulation proofs to justify the apparently circular reasoning. We believe this de-mystifies compositional model checking and opens the way to formalizing the theory and its application in a theorem prover.</p><p>Park and Dill <ref type="bibr" target="#b15">[16]</ref> proved the safety properties of FLASH using machineassisted theorem proving in PVS. Their proof is also based on the notion of simulation proofs, but uses the formulation of simulation in Definition 1, which requires an inductive invariant. Not surprisingly, they spent a significant amount (perhaps most) of their efforts on formulating and proving the inductive invariant. In contrast, the conjunction of the noninterference lemmas in Figure <ref type="figure" target="#fig_3">4</ref> falls far short of an inductive invariant. Also, it took them roughly two weeks to come up with the inductive invariant and to do the proof, which is a lot longer than the one day we spent.</p><p>Predicate abstraction has been used to verify German (without data paths) by Baukus, Lakhnech, and Stahl <ref type="bibr" target="#b1">[2]</ref> and FLASH by Das, Dill, and Park <ref type="bibr" target="#b2">[3]</ref>; the former also handles liveness. There are two main problems to be solved when applying predicate abstraction to parameterized verification: how to discover a suitable set of predicates, and how to map a finite set of predicates onto an unbounded set of state variables. To solve the second problem, the above two papers use complex predicates containing quantifiers, some of which are almost as complex as an invariant. This makes the discovery of such predicates nonobvious and probably as hard as the formulation of noninterference lemmas. More recently, a conceptual breakthrough was made by Lahiri and Bryant <ref type="bibr" target="#b8">[9]</ref>, who developed a theory of and the associated symbolic algorithms for indexed predicates, where the indices are implicitly universally quantified over. They used their techniques to verify a version of German with unbounded FIFO queues. We believe that there are close connections between their work and this paper, which we want to explore in the future.</p><p>Pnueli, Ruah, and Zuck <ref type="bibr" target="#b16">[17]</ref> proposed an automatic (though incomplete) technique for parameterized verification called invisible invariants, which uses a small instance with N 0 nodes to generate an inductive invariant that works for instances of any size, where the bound N 0 depends on the forms of protocol and property descriptions. For German (without data paths), N 0 = 4. Although their technique is very attractive for being automatic, there are reasons to believe that it would not work for FLASH. First, their theory does not seem to allow the protocol to use node pointer arrays indexed by nodes, which FLASH has. Second, even if the theory can be made to work, the bound N 0 for FLASH is likely to be much greater than 4. Given the remarks in Section 3, this makes it very doubtful that FLASH can be verified using their method. We believe that the large bound results from the automatic nature of their method, which forces them to use general arguments that depend only on the form of the protocol and property descriptions. In our framework, human insights about specific protocols can limit the number of nodes needed by means of noninterference lemmas.</p><p>Emerson and Kahlon <ref type="bibr" target="#b5">[6]</ref> verified German (without data paths) by first reducing it to a snoopy bus protocol and then invoking a theorem of theirs asserting that if a snoopy bus protocol of a certain form is correct for 7 nodes then it is correct for any number of nodes. Unfortunately, no such cut-off results are known for protocols as complex as FLASH (or, for that matter, for German directly), nor is it clear how FLASH can be reduced to protocols for which cut-off results are known.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>the original German protocol model --here, but with the above changes/additions. rule "ABS_Skip" end; rule "ABS_RecvReqS" CurCmd = Empty ==&gt; CurCmd := ReqS; CurPtr := Other; for j : NODE do InvSet[j] := ShrSet[j] end; end; rule "ABS_RecvReqE" CurCmd = Empty ==&gt; CurCmd := ReqE; CurPtr := Other; for j : NODE do InvSet[j] := ShrSet[j] end; end; rule "ABS_RecvInvAck" CurCmd != Empty &amp; ExGntd = true ==&gt; ExGntd := false; undefine MemData; end; rule "ABS_SendGntS" CurCmd = ReqS &amp; CurPtr = Other &amp; ExGntd = false ==&gt; CurCmd := Empty; undefine CurPtr; end; rule "ABS_SendGntE" CurCmd = ReqE &amp; CurPtr = Other &amp; ExGntd = false &amp; forall j : NODE do ShrSet[j] = false end ==&gt; ExGntd := true; CurCmd := Empty; undefine CurPtr; end; ruleset d : DATA do rule "ABS_Store" true ==&gt; AuxData := d; end end;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>rule "ABS_RecvInvAck" CurCmd != Empty &amp; ExGntd = true &amp; forall j : NODE do Cache[j].State != E &amp; Chan2[j].Cmd != GntE end ==&gt; ... end;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Abstract German protocol: Final version</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Noninterference lemmas for FLASH</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>-</head><label></label><figDesc>A boolean variable, x : B. -A (node) pointer variable, y : N . -An array of booleans, z : array [N ] of B. -An array of (node) pointers, w : array [N ] of N .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Chan3[i].Cmd = InvAck &amp; CurCmd != Empty must be true in the current state s. Now comes the crucial point: (8) allows us to assume that the aforementioned property P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Fig. 1. The German cache coherence protocol 1</head><label></label><figDesc>. Set NODE NUM to 2, which has the effect of changing the type NODE to containing only the 2 nodes chosen for observation. 2. Add a new type declaration: "ABS_NODE : union {NODE, enum{Other}}", which contains the 2 chosen nodes plus a special value Other representing all those nodes that are not chosen.3. If a state variable (including array entries) has type NODE, change it toABS NODE, because in the abstract model a node pointer can still point to a node that is not being observed (i.e., an Other). In German, there is only one variable whose type is so changed: "CurPtr : ABS_NODE".</figDesc><table><row><cell cols="3">const ----Configuration parameters ----</cell><cell>ruleset i : NODE do rule "SendInv"</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Chan2[i].Cmd = Empty &amp; InvSet[i] = true &amp;</cell></row><row><cell cols="2">NODE_NUM : 4;</cell><cell></cell><cell>( CurCmd = ReqE | CurCmd = ReqS &amp; ExGntd = true )</cell></row><row><cell cols="2">DATA_NUM : 2;</cell><cell></cell><cell>==&gt;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Chan2[i].Cmd := Inv; InvSet[i] := false;</cell></row><row><cell>type</cell><cell>----Type declarations ----</cell><cell></cell><cell>end end;</cell></row><row><cell cols="2">NODE : scalarset(NODE_NUM);</cell><cell></cell><cell>ruleset i : NODE do rule "SendInvAck"</cell></row><row><cell cols="2">DATA : scalarset(DATA_NUM);</cell><cell></cell><cell>Chan2[i].Cmd = Inv &amp; Chan3[i].Cmd = Empty</cell></row><row><cell></cell><cell></cell><cell></cell><cell>==&gt;</cell></row><row><cell cols="2">CACHE_STATE : enum {I, S, E};</cell><cell></cell><cell>Chan2[i].Cmd := Empty; Chan3[i].Cmd := InvAck;</cell></row><row><cell cols="3">CACHE : record State : CACHE_STATE; Data : DATA; end;</cell><cell>if (Cache[i].State = E) then Chan3[i].Data := Cache[i].Data end;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Cache[i].State := I; undefine Cache[i].Data;</cell></row><row><cell cols="3">MSG_CMD : enum {Empty, ReqS, ReqE, Inv, InvAck, GntS, GntE};</cell><cell>end end;</cell></row><row><cell cols="3">MSG : record Cmd : MSG_CMD; Data : DATA; end;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>ruleset i : NODE do rule "RecvInvAck"</cell></row><row><cell>var</cell><cell>----State variables ----</cell><cell></cell><cell>Chan3[i].Cmd = InvAck &amp; CurCmd != Empty</cell></row><row><cell></cell><cell></cell><cell></cell><cell>==&gt;</cell></row><row><cell cols="2">Cache : array [NODE] of CACHE;</cell><cell>--Caches</cell><cell>Chan3[i].Cmd := Empty; ShrSet[i] := false;</cell></row><row><cell cols="2">Chan1 : array [NODE] of MSG;</cell><cell>--Channels for Req*</cell><cell>if (ExGntd = true)</cell></row><row><cell cols="2">Chan2 : array [NODE] of MSG;</cell><cell>--Channels for Gnt* and Inv</cell><cell>then ExGntd := false; MemData := Chan3[i].Data; undefine Chan3[i].Data end;</cell></row><row><cell cols="2">Chan3 : array [NODE] of MSG;</cell><cell>--Channels for InvAck</cell><cell>end end;</cell></row><row><cell cols="2">InvSet : array [NODE] of boolean;</cell><cell>--Nodes to be invalidated</cell></row><row><cell cols="2">ShrSet : array [NODE] of boolean;</cell><cell>--Nodes having S or E copies</cell><cell>ruleset i : NODE do rule "SendGntS"</cell></row><row><cell cols="2">ExGntd : boolean;</cell><cell>--E copy has been granted</cell><cell>CurCmd = ReqS &amp; CurPtr = i &amp; Chan2[i].Cmd = Empty &amp; ExGntd = false</cell></row><row><cell cols="2">CurCmd : MSG_CMD;</cell><cell>--Current request command</cell><cell>==&gt;</cell></row><row><cell cols="2">CurPtr : NODE;</cell><cell>--Current request node</cell><cell>Chan2[i].Cmd := GntS; Chan2[i].Data := MemData; ShrSet[i] := true;</cell></row><row><cell cols="2">MemData : DATA;</cell><cell>--Memory data</cell><cell>CurCmd := Empty; undefine CurPtr;</cell></row><row><cell cols="2">AuxData : DATA;</cell><cell>--Latest value of cache line</cell><cell>end end;</cell></row><row><cell cols="2">----Initial states ----</cell><cell></cell><cell>ruleset i : NODE do rule "SendGntE"</cell></row><row><cell></cell><cell></cell><cell></cell><cell>CurCmd = ReqE &amp; CurPtr = i &amp; Chan2[i].Cmd = Empty &amp; ExGntd = false &amp;</cell></row><row><cell cols="2">ruleset d : DATA do startstate "Init"</cell><cell></cell><cell>forall j : NODE do ShrSet[j] = false end</cell></row><row><cell cols="2">for i : NODE do</cell><cell></cell><cell>==&gt;</cell></row><row><cell cols="3">Chan1[i].Cmd := Empty; Chan2[i].Cmd := Empty; Chan3[i].Cmd := Empty;</cell><cell>Chan2[i].Cmd := GntE; Chan2[i].Data := MemData; ShrSet[i] := true;</cell></row><row><cell cols="3">Cache[i].State := I; InvSet[i] := false; ShrSet[i] := false;</cell><cell>ExGntd := true; CurCmd := Empty; undefine CurPtr;</cell></row><row><cell>end;</cell><cell></cell><cell></cell><cell>end end;</cell></row><row><cell cols="3">ExGntd := false; CurCmd := Empty; MemData := d; AuxData := d;</cell></row><row><cell cols="2">end end;</cell><cell></cell><cell>ruleset i : NODE do rule "RecvGntS"</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Chan2[i].Cmd = GntS</cell></row><row><cell cols="2">----State transitions ----</cell><cell></cell><cell>==&gt;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Cache[i].State := S; Cache[i].Data := Chan2[i].Data;</cell></row><row><cell cols="2">ruleset i : NODE do rule "SendReqS"</cell><cell></cell><cell>Chan2[i].Cmd := Empty; undefine Chan2[i].Data;</cell></row><row><cell cols="3">Chan1[i].Cmd = Empty &amp; Cache[i].State = I</cell><cell>end end;</cell></row><row><cell>==&gt;</cell><cell></cell><cell></cell></row><row><cell cols="2">Chan1[i].Cmd := ReqS;</cell><cell></cell><cell>ruleset i : NODE do rule "RecvGntE"</cell></row><row><cell cols="2">end end;</cell><cell></cell><cell>Chan2[i].Cmd = GntE</cell></row><row><cell></cell><cell></cell><cell></cell><cell>==&gt;</cell></row><row><cell cols="2">ruleset i : NODE do rule "SendReqE"</cell><cell></cell><cell>Cache[i].State := E; Cache[i].Data := Chan2[i].Data;</cell></row><row><cell cols="3">Chan1[i].Cmd = Empty &amp; (Cache[i].State = I | Cache[i].State = S)</cell><cell>Chan2[i].Cmd := Empty; undefine Chan2[i].Data;</cell></row><row><cell>==&gt;</cell><cell></cell><cell></cell><cell>end end;</cell></row><row><cell cols="2">Chan1[i].Cmd := ReqE;</cell><cell></cell></row><row><cell cols="2">end end;</cell><cell></cell><cell>ruleset i : NODE; d : DATA do rule "Store"</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Cache[i].State = E</cell></row><row><cell cols="2">ruleset i : NODE do rule "RecvReqS"</cell><cell></cell><cell>==&gt;</cell></row><row><cell cols="3">CurCmd = Empty &amp; Chan1[i].Cmd = ReqS</cell><cell>Cache[i].Data := d; AuxData := d;</cell></row><row><cell>==&gt;</cell><cell></cell><cell></cell><cell>end end;</cell></row><row><cell cols="3">CurCmd := ReqS; CurPtr := i; Chan1[i].Cmd := Empty;</cell></row><row><cell cols="3">for j : NODE do InvSet[j] := ShrSet[j] end;</cell><cell>----Invariant properties ----</cell></row><row><cell cols="2">end end;</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>invariant "CtrlProp"</cell></row><row><cell cols="2">ruleset i : NODE do rule "RecvReqE"</cell><cell></cell><cell>forall i : NODE do forall j : NODE do</cell></row><row><cell cols="3">CurCmd = Empty &amp; Chan1[i].Cmd = ReqE</cell><cell>i != j -&gt; (Cache[i].State = E -&gt; Cache[j].State = I) &amp;</cell></row><row><cell>==&gt;</cell><cell></cell><cell></cell><cell>(Cache[i].State = S -&gt; Cache[j].State = I | Cache[j].State = S)</cell></row><row><cell cols="3">CurCmd := ReqE; CurPtr := i; Chan1[i].Cmd := Empty;</cell><cell>end end;</cell></row><row><cell cols="3">for j : NODE do InvSet[j] := ShrSet[j] end;</cell></row><row><cell cols="2">end end;</cell><cell></cell><cell>invariant "DataProp"</cell></row><row><cell></cell><cell></cell><cell></cell><cell>( ExGntd = false -&gt; MemData = AuxData ) &amp;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>forall i : NODE do Cache[i].State != I -&gt; Cache[i].Data = AuxData end;</cell></row></table><note><p><p><ref type="bibr" target="#b3">4</ref></p>. But the occurrences of NODE as array index types are not changed, because we are observing only the nodes in NODE (plus the home node, which is not indexed) and have discarded the part of the state corresponding to the nodes represented by Other.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>GntE to node n 2 in the network, which violates Lemma_1 once Other sends a ReqE to home. The fix to this problem is to outlaw the bogus InvAck from Other by refining ABS_RecvInvAck using a strengthened Lemma_1 asserting that there can be at most one InvAck if it is from an E copy. After this step, CtrlProp is proved 3 , so we bring DataProp back by uncommenting it.Step 3: A trivial counterexample to the first clause of DataProp shows Other doing a store when ExGntd is false. The fix is to refine ABS_Store using a new noninterference lemma Lemma_2 that outlaws this.</figDesc><table /><note><p>Node n 1 acquires an E copy, which is invalidated by a ReqS from Other. But before the InvAck reaches home, home receives a bogus InvAck from Other, which makes home think that there is no E copy outstanding and hence sends GntS to Other. Now node n 2 sends ReqE to home, which receives the stale InvAck from node n 1 and sends GntE to node n 2 . But the Inv that home sends to n 1 on behalf of n 2 is still in the network, which now reaches node n 1 and generates a InvAck. So now we have both a InvAck from node n 1 and a</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>German's challenge was to verify the protocol fully automatically, which is not our goal. But his protocol, being short, is a good medium for presenting our method.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The fact that CtrlProp is proved for any number of nodes after only two steps and four more steps are needed to prove DataProp, suggests that there are interesting properties about the control logic that are not needed to prove the former but needed for the latter. Interestingly, none of the research papers on verifying German<ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b16">17]</ref> considered adding the data paths.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Existentially quantified formulas that occur positively in rule preconditions will still cause problems, but in practice they rarely occur and can always be replaced by auxiliary variables that supply explicit witnesses.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>We are grateful to Steven German for pointing out this issue to us.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>In the eager mode of FLASH, the home is allowed to grant an exclusive copy before all shared copies have been invalidated. In contrast, in the delayed mode of FLASH, the home must invalidate all shared copies before granting an exclusive copy.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>There is a slight complication here: in the case of FLASH, one of the 3 nodes in a view must be the home node.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are grateful to Steven German for his comments, which greatly helped to improve this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Limits for automatic program verification of finite-state concurrent systems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="307" to="309" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Parameterized verification of a cache coherence protocol: safety and liveness</title>
		<author>
			<persName><forename type="first">K</forename><surname>Baukus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lakhnech</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Stahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VMCAI</title>
		<imprint>
			<biblScope unit="page" from="317" to="330" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Experience with predicate abstract</title>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CAV</title>
		<imprint>
			<biblScope unit="page" from="160" to="171" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Exploiting transition locality in the disk based Murphi verifier</title>
		<author>
			<persName><forename type="first">G</forename><surname>Della Penna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Intrigila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tronci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Zilli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FMCAD</title>
		<imprint>
			<biblScope unit="page" from="202" to="219" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Protocol verification as a hardware design aid</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Drexler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">on Computer Design: VLSI in Computers and Processors</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="522" to="525" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Exact and efficient verification of parameterized cache coherence protocols</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kahlon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CHARME</title>
		<imprint>
			<biblScope unit="page" from="247" to="262" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>German</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Personal communications</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Better verification through symmetry</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Ip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CHDL</title>
		<imprint>
			<biblScope unit="page" from="87" to="100" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Constructing quantified invariants via predicate abstraction</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VMCAI</title>
		<imprint>
			<biblScope unit="page" from="267" to="281" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Verification of infinite state systems by compositional model checking</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CHARME</title>
		<imprint>
			<biblScope unit="page" from="219" to="234" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Circular compositional reasoning about liveness</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CHARME</title>
		<imprint>
			<biblScope unit="page" from="342" to="345" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Parameterized verification of FLASH cache coherence protocol by compositional model checking</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CHARME</title>
		<imprint>
			<biblScope unit="page" from="179" to="195" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Exploiting SAT solvers in unbounded model checking</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<ptr target="http://www-cad.eecs.berkeley.edu/~kenmcmil/cav03tut.ppt" />
	</analytic>
	<monogr>
		<title level="j">CAV tutorial</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<title level="m">Induction in compositional model checking. CAV</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="312" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An algebraic definition of simulation between programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCAI</title>
		<imprint>
			<biblScope unit="page" from="481" to="489" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Verification of the FLASH cache coherence protocol by aggregation of distributed transactions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SPAA</title>
		<imprint>
			<biblScope unit="page" from="288" to="296" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automatic deductive verification with invisible invariants</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ruah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zuck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TACAS</title>
		<imprint>
			<biblScope unit="page" from="82" to="97" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
