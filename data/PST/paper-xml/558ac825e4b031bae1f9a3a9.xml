<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Power Average Operator</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ronald</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
						</author>
						<title level="a" type="main">The Power Average Operator</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EB717D132B8D67AA13C46950AF0F5C93</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Aggregation operator</term>
					<term>averaging</term>
					<term>data mining</term>
					<term>information fusion</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce the power average to provide an aggregation operator which allows argument values to support each other in the aggregation process. The properties of this operator are described. We discuss the idea of a power median. We introduce some possible formulations for the support function used in the power average. We extend the facility of empowerment, supported aggregation, to a wider class of mean operators such as the OWA and generalized mean.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Aggregating data using techniques such as the average is an operation common to many information fusion processes. This situation has become even more pervasive with the expansion of the Internet and its accumulation of massive amounts of data. Tasks such as data mining and user profiling rely heavily on these types of techniques. The commonly used data aggregation techniques, such as the average, median, or mode, often do not capture the sophisticated nuances the user wants to reflect in the aggregated value. Great benefit would be had if we were able to add additional intelligence to these fusion processes by taking into account information about the relationship between the values being fused, as was done in <ref type="bibr" target="#b0">[1]</ref>. Here, we provide a tool to aid and provide more versatility in this data aggregation process. In this paper, we introduce the concept of the power average. With the aid of the power average we are able to allow values being aggregated to support and reinforce each other. This operator allows for aggregations in which a subset of data clustered around a common value can combine in a nonlinear fashion to act in concert in determining the aggregated value. One manifestation of this power average is to enable aggregations which can capture both the features of mode-like methods, with their focus on finding the most common or typical value, and the averaging-type operator with its focus on a fusing of the data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. POWER AVERAGE</head><p>In the following, we shall define an aggregation-type operator which we call the power average (P-A). This operator takes a collection of values and provides a single value. We define this operator as follows: We shall denote Sup(a; b) as the support for a from b. Typically, we shall assume that Sup(a; b) satisfies the following three properties:</p><p>1) Sup(a; b) 2 [0; 1];</p><p>2) Sup(a; b) = Sup(b; a);</p><p>3) Sup(a; b) Sup(x; y) if ja 0 bj &lt; jx 0 yj. <ref type="bibr">March 26, 2001</ref>; revised September 30, 2001. This paper was recommended by Associate Editor T. Sudkamp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Manuscript received</head><p>The author is with the Machine Intelligence Institute, Iona College, New Rochelle, NY 10801 USA (e-mail: yager@panix.com).</p><p>Publisher Item Identifier S 1083-4427(01)10798-8.</p><p>Thus we see the more similar, the closer two values, the more they support each other.</p><p>We shall find it convenient to denote V i = 1 + T (a i ) and w i = Vi = n i=1</p><p>Vi . Here, wi is a proper set of weights, wi 0 and 6i wi = 1. Using this notation, we have P-A(a 1 ; . . . ; a n ) = 6 i w i a i which is a weighted average of the a i . However, it should be emphasized that this is a nonlinear weighted average as wi depends upon the arguments.</p><p>Let us look at some properties of this power average. First, we see that this operator provides a generalization of the simple average. If Sup(a; b) = 0 for all a and b, then P-A(a 1 ; . . . ; a n ) = 1 n 6 i a i :</p><p>Thus, with no support element, the power average is simply the average. More generally, we see that if Sup(a; b) = k for all a and b, then T (ai) = k(n 0 1) for all i, and hence P-A(a1; . . . ; an ) = (1=n)6 i a i . Thus, when all the supports are the same, the power av- erage reduces to the simple average. We see that the power average is commutative, i.e., it does not depend on the indexing of the arguments. Any permutation of the arguments has the same power average.</p><p>The fact that P-A(a1; . . . ; an) = 6i wi ai where wi 0 and 6 i w i = 1 implies that the operator is bounded Min[a i ] P-A(a 1 ; a 2 ; . . . ; a n ) Max i [a i ]:</p><p>This, in turn, implies that it is idempotent, if a i = a for all i, then P-A(a1; . . . ; an) = a.</p><p>As a result of the fact that the w i depends upon the arguments, one property typically associated with the averaging operator that is not generally satisfied by the power average is monotonicity.</p><p>We recall that monotonicity requires that if a i b i for all i, then P-A(a 1 ; . . . ; a n ) P-A(b 1 ; . . . ; b n ). As the following example illustrates, an increase in one of the arguments can result in a decrease in the power average. Thus, we see that P-A(2; 4; 10) &gt; P-A(2; 4; 11).</p><p>As we shall subsequently see, this ability to display nonmonotonic behavior provides one of the useful features of this operator which helps distinguish it from the usual average. For example, the behavior displayed in the example is a manifestation of the ability of this operator to discount outliers. For as we shall see in the subsequent discussion, as an argument moves away from the main body of arguments, it will be accommodated by having the average move in its direction. This will happen up to point, then when it gets too far away, it will be discounted by having its effective weighting factor diminished.</p><p>To some degree, this power average can be seen to have some of the characteristics of the mode operator. We recall that the mode of a collection of arguments is equal to the value that appears most in the argument. We note that the mode is bounded by the arguments and commutative; however, as the following example illustrates, it is not monotonic.</p><p>Example: Mode(1; 1; 3; 3; 3) = 3. Consider now Mode(1; 1; 4; 7; 8) = 1, here we increase all of the "3s" and obtain a value less than the original.</p><p>As we shall subsequently see, while both the power average and mode in some sense are trying to find the most supported value, a fundamental difference exists between these operators. We note that in the case of the mode we are not aggregating the value; as a matter of fact, the mode must be one of the arguments, in the case of power average we are allowing blending of values.</p><p>It is interesting to note, however, a formal relationship between the mode and the power average. To attain this, we introduce an operator we call a power mode. In the case of the power mode, we define a support function Sup m (a; b), indicating the support for a from b, such that then we get the usual mode. In the power mode, we are allowing some support for a value by neighboring values. It is also interesting to note the close relationship to the mountain clustering method introduced by Yager and Filev <ref type="bibr" target="#b1">[2]</ref>, and particularly with the special case of mountain clustering called the subtractive method suggested by Chu <ref type="bibr" target="#b2">[3]</ref>. Some connection also seems to exist between the power mode and the idea of fuzzy typical value introduced in <ref type="bibr" target="#b3">[4]</ref>. At this point, we do not pursue this power mode but continue to focus on the power average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. POWER AVERAGE WITH BINARY SUPPORT FUNCTIONS</head><p>In order to obtain some intuition for the power average operator, we shall consider first a special, although very useful, case of support function; a binary support function. Here, we assume</p><formula xml:id="formula_0">Sup(a; b) = K if ja 0 bj d Sup(a; b) = 0 if ja 0 bj &gt; d:</formula><p>Thus, two values support each if they are less than or equal d away, otherwise they supply no support. Here, K is the worth of support. In the following discussion, we shall find it convenient to use the following terminology. If ja 0 bj d we shall say a and b are neighbors.</p><p>The set of values that are neighbors of x will be denoted N x . We shall call a set of values such that all points in it are neighbors and no other points are neighbors to those points a cluster. We note if x and y are in the same cluster then the subset fxg [ N x = fyg [ N y defines the cluster.</p><p>Let us first assume that we have two disjointed clusters of values A = fa 1 ; . . . ; a n g and B = fb 1 ; . . . ; b n g. Here, all points in A support each other but support none in B , while the opposite holds for B . In this case, for all i and j , jai 0 aj j d, jbi 0 bj j d, and ja i 0 b j j &gt; d. In this case, for each a i in A, T (a i ) = K (n 1 0 1) and for each b j in B , T (b j ) = K (n 2 0 1). From this we get 1 + T (a i ) = (1 0K)+n1K and 1 + T (bj ) = (10 K ) + n2 K . Using this, we have </p><formula xml:id="formula_1">) + n 1 K )n 1 a + ((1 0 K ) + n 2 K ))n 2 b n 1 (1 0 K + n 1 K ) + n 2 (1 0 K + n 2 K ) :</formula><p>We get a weighted average of the cluster averages. If we let wa =</p><formula xml:id="formula_2">(1 0 K + n 1 K )n 1 n 1 (1 0 K + n 1 ) + n 2 (1 0 K + n 2 K )</formula><p>and</p><formula xml:id="formula_3">w b = (1 0 K + n 2 K )n 2 n 1 (1 0 K + n 1 ) + n 2 (1 0 K + n 2 K )</formula><p>then PA(a 1 ; . . . ; a n ; b 1 ; . . . ; b n ) = w a a + w b b. We note w a + w b = 1 and</p><formula xml:id="formula_4">w a w b = (1 0 K + n 1 K )n 1 (1 0 K + n 2 k)n 2 :</formula><p>We see that if K = 1, then w a =w b = (n 1 =n 2 ) 2 , the weights are proportional to the square of the number of elements in the clusters. Thus, in this case Thus, we see as we move from K = 0 to K = 1, that we move from being proportional to number of elements in each cluster to being proportional to the square of the number of elements in each cluster. We now begin to see the effect of this power average. If we allow support then elements that are close, supporting each other, gain power. This become a reflection of the adage that there is power in sticking together.</p><p>We also observe that if n1K and n2K (1 0 K ), there are a large number of arguments, then again w a =w b = (n 1 =n 2 ) 2 . Furthermore, we note if n 1 = n 2 , then we always have w a =w b = 1; here we take the simple average. Consider now the case when we have q disjoint clusters, each only supporting elements in its neighborhood. Let aji for i = 1 to nj be the elements in the j th cluster. In this case</p><formula xml:id="formula_5">P-A = q j=1 n i=1 (1 0 K + n j K )a ji q j=1 n j (1 0 K + n j K ) :</formula><p>Letting (1=n j ) n i=1 a ji = a j , the individual cluster averages, we can express this power average as</p><formula xml:id="formula_6">P-A = q j=1 ((1 0 K + nj K )nj aj ) q j=1</formula><p>(1 0 K + nj K )nj :</p><p>Again we get a weighted average of the individual cluster averages, P-A = q j=1 w j a j . In this case</p><formula xml:id="formula_7">w i = (1 0 K + n i K )n i q j=1</formula><p>(1 0 K + n j K )n j and wi wj = (1 0 K + niK )ni (1 0 K + nj K )nj :</p><p>Again we see if k = 1, then wi =wj = n 2 i =n 2 j , the proportionality factor is the square of the number of elements. Here then w i = n 2 i =( q j=1 n 2 j ). If we allow no support, K = 0, then w i =w j = nj =ni ; here we get the usual average. We note that k is the value of support.</p><p>Consider a case with small value of support, 1 0 K 1. Further- more, assume n i is a considerable number of elements while n j is a very small number. Here, (10K)+njK 1 while (10K)+niK n1K then</p><formula xml:id="formula_8">w i w j = n 2 i K (1 0 K )n j n 2 i K n j :</formula><p>On the other hand, if ni and nj are large, niK and nj K &gt;&gt;&gt; 1 then w i =w j = n 2 i =n 2 j . We note that if (1 0 K ) n j K for all j then P-A = we see that for all ai we have T (ai) = K (n1 + n2 0 1); for all b i T (b i ) = K (n 1 +n 2 +n 3 01); and for all c i T (c i ) = K (n 2 +n 3 01). We see that the relationship between the weights associated A and C is w a w c = (n 0 n 3 )n 1 (n 0 n 1 )n 3 = (n 2 + n 1 )n 1</p><p>(n 2 + n 3 )n 3 :</p><p>If n 2 is large compared with both n 1 and n 3 , then w a =w c = n 1 =n 3 , their relationship is proportion to the number of elements in A and C .</p><p>If n 2 is small compared with both n 1 and n 3 , then w a =w c = n 2 1 =n 2 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P-</head><formula xml:id="formula_9">A = (1 0 K + K (n1 + n2))n1 a + (1 0 K + K (n1 + n2 + n3)n2 a + (1 0 K + K (n2 + n3)n3 a (1 0 K + K (n1 + n2))n1 + (1 0 K + K (n1 + n2 + n3)n2 + (1 0 K + K (n2 + n3)n3</formula><p>2) For each data point ajj = 1 to n augment Mi, Mi = Mi + e 0(a 0a ) . This builds the support mountain.</p><p>3) Calculate V i = (1 0 K) + K M i -linear transformation of mountain values.</p><p>4) Calculate wi = Vi= n j=1 Vj. 5) P-A = 6 i w i a i .</p><p>As we have noted, an important characteristic of this power average is its possibility for displaying nonmonotonicity, a feature that can provide one of the benefits of this method. The following example illustrates the occurrence of nonmonotonicity.</p><p>Example: Consider the power average of 20 elements, ten of which are 10's and ten of which are 5's. In this case, the ordinary average evaluates to 7.5 and for any choice of K and , the power average also evaluates to 7. We see that as we decrease the value and move it toward the cluster of 5's, our P-A decrease, although more dramatically than the average.</p><p>Essentially the variable value is beginning to join the cluster of 5's and increase its power. In the case of increasing the value the situation is more complex. Initially the power average, instead of increasing does the average, begins to decrease, exhibiting nonmonotonicity. This decrease is a reflection of the fragmentation of the cluster at ten, it is losing its power because it lost a member and the cluster at five has gained in power more than compensating for the increase in value.</p><p>This decreasing in the P-A continues as we increase the element until it reaches 18, at which time we see a reversal and the P-A starts increasing. At this point, the increase in value begins overcoming the loss of power, but we are still favoring the cluster of 5's.</p><p>We describe another approach for obtaining the support function which combines the partitioning of the first method with the continuity displayed by the exponential function. This approach, motivated by Zadeh's idea of computing with words <ref type="bibr" target="#b4">[5]</ref>, makes use of fuzzy systems modeling technology <ref type="bibr" target="#b5">[6]</ref>. We shall briefly describe the possibilities for this approach. Using this approach, we can express our support function by a description of its performance in terms of a set of rules using linguistic values. For example</p><formula xml:id="formula_10">If difference is very small then support is K 1 If difference is small then support is K 2 If difference is moderate then support is K3 If difference is large then support is K 4 If difference is very large then support is K 5 :</formula><p>Representing the italic terms as fuzzy sets V S, S, M, L, and V L, respectively, and denoting the difference between a and b as 1, then we have a collection of fuzzy if-then rules, or a fuzzy systems model</p><formula xml:id="formula_11">If 1 is V S then S(a; b) = K 1 If 1 is S then S(a; b) = K2 If 1 is M then S(a; b) = K 3 If 1 is L then S(a; b) = K 4 If 1 is V L then S(a; b) = K5</formula><p>where Ki &lt; Kj if i &gt; j.</p><p>To obtain the Sup(a; b), we use the inference mechanism of fuzzy systems modeling. Letting 1 = ja 0 bj, the analytic formulation of our support function is</p><formula xml:id="formula_12">Sup(a; b) = K 1 V S(1) + K 2 S(1) + K 3 M(1) + K 4 L(1) + V L(1)</formula><p>V S(1) + S(1) + M(1) + L(1) + V L(1) where V S(1) indicates the membership of 1 in the fuzzy subset V S.</p><p>We now look at the power average in the special situation in which the arguments that are being aggregated, the a i , are always in the unit interval [0; 1]. This is a situation which occurs in many environments when the arguments are degrees of belief. We note that a particular important situation is the aggregation of fuzzy subsets <ref type="bibr" target="#b6">[7]</ref>.</p><p>In the case when the arguments lie in the unit interval, a very natural definition for the Sup function is Sup(a; b) = K(1 0 ja 0 bj ) for 0. Here, we see that the term ja 0 bj is a measure of distance between the arguments. We note that since a and b are assumed to lie in the unit interval, then ja0bj must also lie in the unit interval, as well as ja 0 bj . We see ja 0 bj ! 0 indicates the elements are close and ja 0 bj ! 1 indicates the elements are far. We see that Sup is related to the negation of the distance.</p><p>We notice that, because a and b always lie in the unit interval, ja 0 bj = 1 if and only if one of the arguments equals zero and the other equals one. Furthermore, we note that modifies the effects of distance. Since (a 0 b) &lt; 1, then &gt; 1 reduces the effect of distance while &lt; 1 increases the effects of distance. We note Sup(a; b) = K when a = b.</p><p>As in the preceding Here, V i = 1 + T (a i ) with T (a i ) = K n (1 0 (a i 0 a j ) 2 ):</p><formula xml:id="formula_13">Realizing 1 0 (a i 0 a i ) 2 = 1 then V i = (1 0 K) + K n j=1</formula><p>(1 0 (a i 0 a j ) 2 ):</p><p>Letting Q i = n j=1 (a i 0 a j ) 2 we have V i = 1 0 K + Kn 0 KQ i :</p><p>monotonicity. Other examples of mean-type operators are Max, Min, and median. In the preceding, with the power average we extended the average operator by introducing the idea of support. That is, with the P-A operator, we allowed arguments in the aggregation to support each other. This effectively resulted in weights associated with the different arguments depending upon the support they obtained from other elements being aggregated. In this section, we want to generalize the idea of supported aggregation to a wider class of mean operators.</p><p>We first look at the OWA operator <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref> and introduce the power-OWA operator. An OWA operator can be defined in terms of function g: [0; 1] ! [0; 1], called a BUM function, having the properties: g(0) = 0, g(1) = 1, and g(x) g(y) if x &gt; y. Using this BUM function, the OWA aggregation OWAg(a1; . . . ; an) can be expressed as OWA g (a 1 ; . . . ; a n ) = n i=1 w i b i where b i is the ith largest of a j and the w i are a collection of weights such that wi = g(i=n) 0 g((i 0 1)=n). It can be easily shown these weights are proper, w i 2 [0; 1] and n i=1 w i = 1. This assures us that the OWA operator is and idempotent. appropriately g, can implement different types of aggregation imperative. For example, if g(x) = x then the OWA operator becomes the ordinary average with wj = 1=n for all j. If g is such that g(x) = 1 for all x &gt; 0, then we get the maximal aggregation OWA g (a 1 ; . . . ; a n ) = Max i [a i ]. If g is such that g(x) = 0 for all x &lt; 1, then we get the minimal aggregation OWAg(a1; . . . ; an) = Min i [a i ]. A median-type operator can be implemented if g(x) = 0 for x &lt; 0:5 and g(x) = 1 for x 0:5. A class of OWA operators can be obtained if g(x) = x with 0. Here, it is not our interest to investigate the many operators that can be characterized using the OWA operator; for this we point the reader to <ref type="bibr" target="#b10">[11]</ref>.</p><p>Before proceeding to our task, defining the power OWA, we shall find it convenient to use a slightly different notation for the OWA operator. We shall let index be an indexing function such that index(i) is the index of the ith largest of the aj. Thus, we order the argument in descending order and then index(i) is the index of ith element in this list. Since bi is the ith largest of the aj using this index function, we see that bi = a index(i) . Using this, we can express the OWA aggregation as OWA g (a i ; . . . ; a n ) = n i=1 w i a index(i) where w i as before are w i = g(i=n) 0 g((i 0 1)=n).</p><p>As in the preceding, we shall let Sup(a; b) indicate the support for a from b. We note that using the index operator Sup(a index(i) , a index(j) ) still represents the support of the second argument for the first. Here, it indicates the support of jth largest argument for the ith largest argument. Because of the nature of the Sup function, Sup(a; b) Sup(x; y) when ja 0 bj &lt; jx 0 yj, and the ordering captured by the index function we note that if i &lt; j &lt; k then Sup(a index(i) , a index(j) ) Sup(a index(i) , a index(k) ) and Sup(a index(j) , a index(k) ) Sup(a index(i) , a index(k) ).</p><p>As in the preceding, we shall let T (a index(i) ) be the support of the ith largest argument by all the other arguments, hence T (a index(i) ) = n Sup(a index(i) , a index(j) ). In addition, we shall let V index(i) = 1 + T (a index(i) ) and denote T V = n i=1 V index(i) .</p><p>We now can define the power OWA operator POWA g (a 1 ; . . . ; a n ) = n i=1 u i a index(i)</p><p>where</p><formula xml:id="formula_14">u i = g(R i =T V ) 0 g(R i01 =T V ) with R i = i j=1 V index(j) ,</formula><p>by definition Ri01 = 0. We note that T V = Rn We also observe that</p><formula xml:id="formula_15">R i = R 01 0 V index(i) .</formula><p>We look at the special case where g(x) = x, which corresponded to the average, and see that this reduces to the power average. In this case</p><formula xml:id="formula_16">ui = g R i T V 0 g R i01 T V = R i T V 0 R i01 T V = 1 T V V index(i) : Using this POWA g (a 1 ; . . . ; a n ) = n i=1 u i a index(i) = 1 T V n i=1 V index(i) a index(i)</formula><p>POWA g (a 1 ; . . . ; a n ) = 1 T V n i=1</p><p>V i a i where 1 + T (a i ). This is just the power average.</p><p>Another class of mean operators, called generalized means <ref type="bibr" target="#b11">[12]</ref>, are defined by GM (a 1 ; a 2 ; . . . n n a j</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simple Average</head><p>! 2 G M (a 1 ; a 2 ; . . . ; a n ) = 1 n n a 2 j 1=2 Euclidian Mean ! 1 GM (a 1 ; a 2 ; . . . ; a n ) = Max j [a j ]</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Maximum</head><p>High-Speed Customizable Fuzzy-Logic Processor: Architecture and Implementation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Zoran Salcic</head><p>Abstract-A generic field-programmable logic device (FPLD)-based fuzzy-logic system aimed at high-speed applications that can be easily customized for practically any application is presented. It implements fuzzy logic systems that vary in terms of number of inputs and outputs and their accuracy, membership functions (MFs), fuzzy rules, and the speed at which new outputs have to be generated. This is achieved by using the unique architecture and its parameterized description, which is based on VHDL generics. The system can be used as either a and-alone system or as an application-specific co-processor added to the standard or customized microprocessors.</p><p>Index Terms-Author, please supply your own keywords or send a blank e-mail to keywords@ieee.org to receive a list of suggested keywords.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Fuzzy models have supplanted many conventional technologies in various scientific applications and engineering systems, especially in control systems and pattern recognition <ref type="bibr" target="#b0">[1]</ref>. The approach to implement fuzzy logic systems can be software-only, hardware-only, or a combination of software and hardware. Suitability of an implementation approach depends mostly on the application type and performance requirements. The partitioning of the solution to its software and hardware parts can be done with respect to different criteria (e.g., propagation or execution time, response time, reliability, price, etc). The software part requires a processor, on which it will run, while the hardware part can be in a form of functions implemented as functional units and used as the standard blocks available at design time from a digital design library. In recent years, field-programmable logic device (FPLD) technology <ref type="bibr" target="#b1">[2]</ref> has been used to implement fuzzy logic for solving real-world problems such as image processing, robotics and motion control, fuzzy database, and industrial engineering applications [3]- <ref type="bibr" target="#b5">[6]</ref>.</p><p>In the applications requiring high-speed processing such as real-time control, the fuzzy logic controller has been presented as a lookup table (LUT) using FPLDs <ref type="bibr" target="#b6">[7]</ref>. The hardware implementation of fuzzy controller was achieved by realizing the Boolean equations on the FPLDs Manuscript received January 16, 2000; revised September 9, 2001. This paper was recommended by Associate Editor S. Lakshmivarahan.</p><p>The author is with the Department of Electrical and Electronic Engineering, University of Auckland, Private Bag 92019, Auckland, New Zealand (e-mail: z.salcic@auckland.ac.nz).</p><p>Publisher Item Identifier S 1083-4427(01)10799-X.</p><p>1083-4427/01$10.00 © 2001 IEEE</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example: 5 T</head><label>5</label><figDesc>Assume the support function Sup is such that Sup(2; 4) = 0:5 Sup(2; 10) = 0:3 Sup(2; 11) = 0 Sup(4; 10) = 0:4 Sup(4; 11) = 0 the required symmetry means S(a; b) = S(b; a) for these values. Consider first P-A(2; 4; 10), in this case T (2) = Sup(2; 4) + Sup(2; 10) = 0:5 + 0:3 = 0:8 T (4) = Sup(4; 2) + Sup(4; 10) = 0:5 + 0:4 = 0:9 T (10) = Sup(10; 2) + Sup(10; 4) = 0:3 + 0:4 = 0:7 and therefore P-A(2; 4; 10) = (1 + 0:8)2 + (1 + 0:9)4 + (1 + 0:7)10 (1 + 0:8) + (1 + 0:9) + (1 + 0:7) = 5:22: 1083-4427/01$10.00 © 2001 IEEEConsider now P-A(2; 4; 11), in this case T (2) = Sup(2; 4) + Sup(2; 11) = 0:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 ) 2 ) 3 ) 4 )</head><label>1234</label><figDesc>Sup m (a; b) 2 [0; 1]; Sup m (a; b) = Sup m (b; a); Sup m (a; b) Sup m (x; y) if ja 0 bj jx 0 yj; Sup m (a; a) = 1. We then calculate Vote(i) = n j=1 Sup m (a i ; a j ) and define power mode(a1; . . . ; an) = ai where Vote(i 3 ) = Max i [Vote(i)], it is the argument with the largest vote. If Sup m (a; b) = 0 for b 6 = a [Sup m (a; a) = 1 by definition]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>P-A (a 1 ; . . . ; a n ; b 1 ; . . . ; b n ) ) + n2K ))bj n1(1 0 K + n1K ) + n2(1 0 K + n2K ) : Letting a = (1=n1) n i=1 ai , the average of the arguments in the first cluster and b = (1=n 2 ) n j=1 b j we have PA (a1; . . . ; an ; b1; . . . ; bn ) = ((1 0 K</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>:</head><label></label><figDesc>On the other hand, if we allow no support, K = 0, then w a =w b = n 1 =n 2 , the weights are just proportional to the number of elements in each cluster. In this case</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2 1 + n 2 2 : 6 :</head><label>226</label><figDesc>proportion to the square of the number of elements. Let us see another interesting property of this P-A. To most clearly illustrate this characteristic, we shall assign K = 1. Assume we have two clusters; then with K = 1 we have P-A = n 2 1 a1 + n 2 2 a2 n If n1 n2 = (1=2)n, they have the same number of elements then P-A = (1=2)a 1 + (1=2)a 2 . Assume now that Cluster 2 is broken into two equal disjoint clusters. Then P(A) = n 2 1 a1 + n 2 2 a2 + n 2 3 a3 n 2 1 + n 2 2 + n 2 3 with n1 = (1=2)n, n2 = (1=4)n, and n3(1=4)n. From this we see that We see Cluster 1's influence (power) has greatly increased because of the fragmentation of Cluster 2.We now consider a situation in which we have three sets of elements, A = fa 1 ; . . . ; a n g, B = fb 1 ; . . . ; b n g, and C = fc 1 ; . . . ; c n g.We assume all the elements in A are neighbors with each other as well as with those in B . Those in B are neighbors with each other and also with those in both A and C . The elements in C are neighbors with themselves and B . Thus, B is seen to be between A and C . Here,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Let a = (1=n j )6 a j , b = (1=n 2 )6 b j , and c = (1=n 3 )6 b j . Using this, we have the equation shown at the bottom of the page. Again for illustrative purposes, we assume K 1 hence P-A = (n 1 + n 2 )n 1 a + n n 2 b + (n 2 + n 3 )n 3 c (n 1 + n 2 )n 1 + n n 2 + (n 2 + n 3 )n 3 P-A = (n 0 n 2 )n 1 a + n n 2 b + (n 0 n 1 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>:</head><label></label><figDesc>Let us consider the case when = 2, Sup(a; b) = K(1 0 (a 0 b) 2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>01; 1]. It is required when using these operators that aj 0. Some special cases of this operator are shown in the equation at the bottom of the page.! 01 GM (a 1 ; a 2 ; . . . ; a n ) = Min j [a j ] Minimum ! 01 GM (a 1 ; a 2 ; . . . ; a n ) M (a 1 ; a 2 ; . . . ; a n ) = 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>5. The following table shows what happens as we change one of the values originally equal to 10. For illustrative purposes, we</figDesc><table><row><cell>used K = 1 and = 0:3 Value 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5</cell><cell>AVE 8 7:9 7:9 7:85 7:8 7:75 7:7 7:65 7:6 7:55 7:5 7:45 7:4 7:35 7:3 7:25</cell><cell>P-A 7:22834 7:22832 7:22831 7:22829 7:22828 7:22856 7:232 7:259 7:346 7:4727 7:5 7:398 7:278 7:193 7:083 6:982</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Consider the relationship between A and B, which is analogous to B and C wa w b = n1(n1 + n2) (n)(n2) :</p><p>If n 2 is large compared with n 1 and n 3 , then wa w b n1 n2</p><p>(n)(n2) n1 n :</p><p>We consider now another situation which exemplifies the possibility for nonmonotonicity. Let fa 1 ; ...; a n ; a n+1 g be a collection of points in the same cluster, for all ai and aj, ja1 0 ajj d. In this case P-Afa; ...; a n+1 g = 1 n + 1 n+1 j=1 a i = a:</p><p>Assume now that we replace an+1 with ân+1 where ân+1 an+1</p><p>and ja n+1 0 a j j &gt; d for all other a j . That is, we have moved the n + 1 observation all the way to the right. In this case, we can view the situation having two disjoint clusters; one being fa 1 ; ...; a n g and the other fâ n+1 g. As we already established the power average of this situation is P-A(a1; a2; ...; an; ân+1g = w1ã + w2ân+1 here ã = (1=n) n i=1 ai and ân+1 = an+1 + 1. We also note that a = (1=(n + 1))a n+1 + (n=(n + 1))ã hence ã = (n + 1)a 0 a n+1 n :</p><p>In the situation where K = 1, we have w 1 =w 2 = n 2 1 =n 2 2 = n 2 =1. This gives us w 1 = n 2 =(n 2 + 1) and w 1 = 1=(n 2 + 1)and hence P-A(a 1 ; ...; ân+1 ) = n 2 n 2 + 1 ã + 1 n 2 + 1 â P-A(a 1 ; ...; ân+1 ) = n 2 n 2 + 1 (n + 1)a 0 an+1 n + 1 n 2 + 1 [a n+1 + 1] P-A(a1; ...; ân+1)</p><p>= n 1 n 2 + 1 [(n)(n + 1)a 0 na n+1 + a n+1 + 1] P-A(a1; ...; ân+1)</p><p>= n 1 n 2 + 1 [(n 2 + 1)a + (n 0 1)a 0 (n 0 1)a n+1 + 1] P-A(a 1 ; ...; ân+1 ) = a + 1 0 (n 0 1)(an+1 0 a) n 2 + 1 :</p><p>Thus, we see that if an+1 was the right most element, then we get a nonmonotonicity as long as 1 is not too</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. FORMS FOR THE SUPPORT FUNCTION</head><p>The support function is a crucial part of the power average method. The form of the support function is typically context dependent. Here, we shall consider some useful parameterized formulations for expressing the Sup function. The determination of the values of the parameters may require the use of some learning techniques.</p><p>We recall if R is the range of the values to be aggregated, then Sup: R 2 R ! [0; 1] such that Sup(a; b) = S(b; a), and Sup(a; b) Sup(x; y) if ja 0 bj jx 0 yj.</p><p>In the preceding, we assumed a binary Sup function, if ja 0 bj d then Sup(a; b) = K and if ja0bj &gt; d then Sup(a; b) = 0. A natural extension of this is to consider a partitioned-type support function. Let Ki for i = 1 to p be a collection of values such that Ki 2 [0; 1] and where K i &gt; K j if i &lt; j. Let d i be a collection of values such that d i 0 and where d i &lt; d j if i &lt; j. We now can define a support function as If ja 0 bj d 1 then Sup(a; b) = K 1 If d j01 &lt; ja 0 bj d j then Sup(a; b) = K j If d p01 &lt; ja 0 bj then Sup(a; b) = K p for j = 2 to p 0 1:</p><p>Inherent in the above type of support function is a discontinuity as we move between the different ranges.</p><p>One useful form for the Sup function, one that provides a continuous transition, is a0b)   where K 2 [0; 1] and 0. We easily see that this function is symmetric and lies in the unit interval. We see K is the maximal allowable support and is acting as an attenuator of the distance. The larger the , the more meaningful differences in distance. We note here that a = b gives us Sup(a; b) = K and as the distance between a and b gets large, then Sup(a; b) ! 0.</p><p>Using this form for support function, we have</p><p>(1 + T (ai))</p><p>where T (a i ) = n Ke 0(a 0a ) :</p><p>Denoting Vi = 1 + T (ai) we express P-A(a1; ...; an) = 6iwiai where w i = V i = n j=1 V j . Since e 0(a 0a ) = 1 we can express Vi = 1 0 K + K Mi where Mi = n j=1 e 0(a 0a ) . Noting the similarity of Mi to the mountain function used in mountain clustering <ref type="bibr" target="#b1">[2]</ref>, we call M i the support mountain at i. It is clear that if a p = a q then Mq = Mp and hence Vq = Vp. It is also noted that Mi 1 for all i.</p><p>We see here that A simple algorithm approach which is somewhat in spirit of the mountain method is as follows.</p><p>1) For each argument value a i , i = 1 to n, initialize M i = 0.</p><p>Let us carefully look at the term Qi. We shall denote a = (1=n) n j=1 a j , it is the average, and denote Var(a) = (1=n) n j=1 (a j 0 a) 2 . Using these notations, we can express Letting 1 i = ja i 0 aj. We have Q i = n 1 2 i + n Var(a).</p><p>From this we have Vi = (10K)+Kn0nK(1 2 i +Var(a)).Using We see that if the arguments are such that there are a few large values far away from the rest of the mean, then the power average tends to pull a downwards.</p><p>Another interesting case of Sup(a; b) = K(1 0 ja 0 bj ) occurs when = 1; here, Sup(ab) = K(10ja 0bj). We note that ja0bj = Max </p><p>[(a i _ a j ) 0 (a j ^ai )]:</p><p>Without loss of generality, let us assume that ai have been indexed in descending order, thus a i is the ith largest of the arguments. In this case a i = Min[a i ; a j ] and a j = Max[a i ; a j ] for j = 1 to i 0 1 aj = Min[ai; aj] and ai = Max[ai; aj] for j = i + 1 to n a i = Min[a i ; a j ] = Max[a i ; a j ] for j = 1. If we denote Q i = n j=1 ja i 0 a j j, then Denoting SL(i) = i j=1 a j and SU(i) = n j=i+1 a j , then Q i = SL(i) 0 SU(i) + (n 0 2i)ai and V i = 1 + (n 0 1)K 0 K(SL(i) 0 SU(i) + (n 0 2i)a i ) The average operator 1=n n i=1 a i , provides one example of mean-type aggregation operators <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. We recall that mean-type operators are characterized by boundedness, commutativity, and</p><p>The inclusion of support in this class of mean operators can be accomplished in the following manner. Again, let T (a i ) = n Sup(a i ; a j ); V i = 1 + T (a i ) and T V = n i=1 V i :</p><p>Then, the power generalized mean is defined as</p><p>We shall not look further at the properties of the power OWA or the power generalized mean only to indicate that they act with respect to their mother operations in a manner similar to the way the power average acts with respect to the average.</p><p>In the preceding, we assumed that all of the objects being aggregated were of equal importance. Here, we shall consider the effect on the power operations of having importances be associated with the objects being aggregated. We assume that each being aggregated has a weight !i 2 [0; 1] indicating its importance. The procedure for including this importance involves a simple modification of the value V i which we recall is defined as V i = 1 + T (a i ) where T (a i ) = n Sup(a i ; a j ):</p><p>In order to include the weights, we suggest redefining V i as V i = ! i 1 + n ! j Sup(a i ; a j ) and then continuing as described earlier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION</head><p>We introduced the power average operator to provide an aggregation operator which allows argument values to support each other in the aggregation process. The properties of this operator were described. We discussed the idea of a power median. We introduced some formulations for support function used in the power average. We extended the idea of empowerment, supported aggregation, to a wider class of mean operators such as OWA and generalized mean. Interesting applications of this approach to aggregation can be seen in data mining, group decision making, and information fusion.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fusion of fuzzy information with considerations for compatibility, partial aggregation and reinforcement</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Approx. Reason</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="93" to="122" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Approximate clustering via the mountain method</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Filev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Syst., Man, Cybern</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1279" to="1284" />
			<date type="published" when="1994-08">Aug. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fuzzy model identification based on cluster estimation</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Chiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Fuzzy Intell. Syst</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="267" to="278" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A note on a fuzzy measure of typicality</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Intell. Syst</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="233" to="249" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">From computing with numbers to computing with words-From manipulation of measurements to manipulations of perceptions</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Zadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="105" to="119" />
			<date type="published" when="1999-01">Jan. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Filev</surname></persName>
		</author>
		<title level="m">Essentials of Fuzzy Modeling and Control</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A review of fuzzy sets aggregation connectives</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Prade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Sci</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="85" to="121" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On mean-type aggregation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Syst., Man, Cybern</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="209" to="221" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On ordered weighted averaging aggregation operators in multicriteria decision making</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Syst., Man, Cybern</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="183" to="190" />
			<date type="published" when="1988-02">Jan.-Feb. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Ordered Weighted Averaging Operators: Theory and Applications</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kacprzyk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Norwell, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Families of OWA operators</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fuzzy Sets Syst</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="125" to="148" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Generalized means as model of compensative connectives</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dyckhoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pedrycz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fuzzy Sets Syst</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="143" to="154" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
