<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Arrow Distributed Directory Protocol</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Demmer</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Maurice</forename><forename type="middle">P</forename><surname>Herlihy</surname></persName>
							<email>herlihy@cs@brown.~du</email>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Brown University</orgName>
								<address>
									<postCode>02912</postCode>
									<settlement>Providence</settlement>
									<region>RI</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Tera Computer Company</orgName>
								<address>
									<postCode>98102</postCode>
									<settlement>Seattle, mikedQtera</settlement>
									<region>WA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Arrow Distributed Directory Protocol</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1B9DF75C69312A1825AD04FBCDB5C297</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:12+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Most practical techniques for locating remote objects in a distributed system suffer from problems of scalability and locality of reference. We have devised the Arrow distributed directory protocol, a scalable and local mechanism for ensuring mutually exclusive access to mobile objects. This directory has communication complexity optimal within a factor of (1 + MST-stretch(G))/2, where MST-stretch(G) is the "minimum spanning tree stretch" of the underlying network.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many distributed systems support some concept of mobile objects. A mobile object could be a file, a process, or any other data structure. For an object to be mobile, we require only that it can be transmitted over a network from one node to another. A mobile object "lives" on only one node at a time, and it moves from one node to another in response to explicit requests by client nodes. A directory service allows nodes to keep track of mobile objects. A directory must provide the ability to locate a mobile object (navigation), as well as the ability to ensure mutual exclusion in the presence of concurrent requests (synchronization).</p><p>This paper describes the arrow distributed directory protocol, a novel directory protocol being implemented as part of the Aleph toolkit <ref type="bibr" target="#b9">[10]</ref>, an distributed shared object system currently under development at Brown. The arrow directory protocol is designed to avoid scalability problems inherent in many directory services currently used in distributed shared memory systems. In this paper, we focus on proving the correctness of the protocol, and on analyzing its communication complexity. The service's data structures and protocols are extremely simple, and yet its coramunication complexity compares well to more complicated asymptotic schemes in the literature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivation</head><p>Perhaps the simplest way to implement a directory service is to have each node broadcast each access request, and await the response from the node currently holding the object. Indeed, this approach is common in bus-based multiprocessor systems (e.g., <ref type="bibr" target="#b8">[9]</ref>), where broadcasting can be accomplished efficiently. In * Supported by AFOSR agreement F30602-96-0228 DARPA OD885.</p><p>distributed systems, however, broadcast is impractical, so a directory structure must provide a way to navigate and synchronize by point-to-point communication. It is equally impractical to have each node store each object's current location, since all nodes must be notified when an object moves. Additionally, since requests occur simultaneously, maintaining consistency in such schemes becomes difficult.</p><p>The most common directory protocol used in existing distributed shared memory systems is a home-based structure. Each mobile object is associated with a fixed node, termed that object's "home". The home keeps track of the object's location and status (e.g., busy or idle). When a client node requests an object, it sends a message to the object's home. The home sends a message to the client currently holding the object, and that client forwards the object to the requesting client node. The home can also enforce the necessary synchronization, by queuing concurrent requests. Home-based schemes are simple and easy to implement, and they have been observed to work well for small-to-medium scale systems. Nevertheless, such schemes suffer from problems of scalability and locality. As the number of nodes grows, or if an object is a "hot spot", that object's home is likely to become a synchronization bottleneck, since it must mediate all access to that object. Moreover, if a client is far from an object's home, then it must incur the cost of communicating with the home, even if the node currently holding the object is nearby. One way to alleviate these problems is to allow an object's home to move. For example, Li and Hudak <ref type="bibr" target="#b14">[15]</ref> proposed a protocol in which each object is initially associated with a particular node, but as an object is moved around, it leaves a virtual trail of forwarding pointers, starting from the original home.</p><p>A limitation of this approach is that many requests for an object may still go through the original home, or end up chasing an arbitrarily long sequence of pointers. Additionally, if the object is close but the home is far, the client may still have to incur the large communication costs.</p><p>Our approach is also based on the idea of a trail of pointers, although we use them in a different way. Objects have no fixed homes, and synchronization and navigation are integrated into a single simple protocol. When a client requests an object from another client, all messages are sent through direct or nearly-direct paths, preserving locality, and permitting us to give explicit worst-case bounds on the protocol's communication complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head><p>The Directory Structure</p><p>In this section, we give an informal definition of the arrow directory protocol, together with examples illustrating the interesting aspects of its behavior. A more formal treatment appears in Section 4.</p><p>For brevity, we consider a directory that tracks the location of a single object. We model a distributed system in the usual way, as a connected graph G = (V, E), where IV[ = n. Each vertex models a node, and each edge a two-way reliable communication link. A node can send messages directly to its neighbors, and indirectly to non-neighbors along a path. Each edge is weighted with a communication cost. The cost of sending a message from one node to another along a particular path is just the sum of that path's edge costs. The distance da(x,y) is the cost of the shortest path from z to y in G. The network is asynchronous (steps are interleaved in an arbitrary order) but reliable (every node eventually takes a step and every message is eventually delivered). We assume the network provides a routing service <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b20">21]</ref> that allows node v to send a message to node u with cost da(u, v).</p><p>The arrow directory is given by a minimum spanning tree T for G. Each node v stores a directory entry link(v), which is either a neighbor of v in T, or v itself. The meaning of the link is essentially the following: if link (v) = v, then the object either resides at v, or will soon reside at v. Otherwise, the object currently resides in the component of the spanning tree containing link(v). Informally, except for the node that currently holds an object, a node knows only in which "direction" that object lies. IfT has maximum degree A, then the directory requires n-log(A) bits of memory to track the object (some techniques for memory reduction are discussed below).</p><p>The entire directory protocol can be described in a single paragraph. The directory tree is initialized so that following the links from any node leads to the node where the object resides. When a node v wants to acquire exclusive access to the object, it sends a find(v) message to ul = link(v) and sets link(v) to v. When node ui receives a find(v) message from node ui-], where u~+l = link(ui), it immediately "flips" link(ul) to ui-1. If Ui+l # u~, then ui forwards the message to ui+l. Otherwise, u~ buffers the request until it is ready to release the object to v. Node ui releases the object by sending a move(v) message containing the object directly to v, without further interaction with the directory.</p><p>Despite the protocol's simplicity, it has a number of non-trivial properties that we believe to be of both practical and theoretical interest. Before analyzing this behavior, it is helpful to review some simple examples. Figure <ref type="figure">1</ref> shows a properly initialized directory, where directed edges correspond to the directory links. The object resides at node u (indicated by a square). When node v requests the object, it sends a find(v) message to ul = link(v), and then sets link(v) to v. When ul receives the message from v, it forwards it to u2 = link(u1), and sets link(u1) to v. Continuing in this way, each vertex thus "flips" the link to point in the direction from which the find(v) message arrived. Figure <ref type="figure" target="#fig_0">2</ref> illustrates the directory state after three steps. Links changed by the protocol are shown in gray: v's link points to itself, Ul points to v and u2 points to ul.</p><p>As shown in Figure <ref type="figure">3</ref>, the find(v) message continues to flip links until it arrives at u, where the object resides (marked by link(u) = u). When u receives the find(v) message, it responds by sending the object in a move((v) message directly to v. This response takes the shortest path, and does not affect the directory structure. As illustrated in Figure <ref type="figure" target="#fig_1">4</ref>, after v has received the object, all links in the graph again lead to the object's new location, so any subsequent find messages will be directed there. The cost of acquiring access to the object is d (u, v) + dc(v, u). The term tiT(u, v) is the cost of sending the find(v) message from u to v through the directory tree, and the term da(v, u) is the cost of sending the move(v) message directly through the network. Notice the locality of this interaction: the message traffic affects only the nodes between u and v in the directory tree and network.</p><p>We now turn our attention to a concurrent example in which multiple nodes try to acquire the object at the same time. As described above, as a find message traverses the directory tree, it flips each link to point back to the neighbor from which the find originated. If two find messages are issued at about the same time, one will eventually cross the other's path, and be "diverted" away from the object and toward its competitor. Figure <ref type="figure" target="#fig_0">2</ref> illustrates this behavior. If any of the nodes on the right half of the tree requests the object, then its find message will follow the links to v, whereas nodes on the left half of the tree will follow the links to u.</p><p>For example, suppose w requests the object while v's find is still in progress. This second find will be diverted go v. When v receives w's message, it will not respond until it is has received the object and is ready to release it. This directory state is illustrated in Figure <ref type="figure" target="#fig_2">5</ref>, where w's request is blocked at v. Now suppose that node z issues a find which arrives at u, where it is buffered (u is not finished with the object). The find message from v is then diverted to z, as illustrated in Figure <ref type="figure">6</ref>. This example illustrates how the arrow directory integrates synchronization and navigation in a natural way. In a quiescent state (when no messages are in transit), the directory imposes a distributed queue structure on blocked find requests. When z completes its find, after flipping its links, it blocks at u. Similarly, v blocks at z, and w at v. These blocked requests create a distributed queue where each find is buffered at its predecessor's node. When u releases the object, it goes directly to z, then v, then w. This distributed queue structure is valuable from a practical perspective, for several reasons. First, it ensures that no single node becomes a synchronization bottleneck. Second, if there is high contention for an object, then each time that 0 0 queue, wQ o.,mo object is released, that node will already have a buffered find request. In the limit, the cost of delivering find messages is hidden by the local computation times, and the protocol's performance approaches optimal (repeated local computation followed by direct object delivery). Third, the queue structure ensures locality: each find message takes a direct path through the spanning tree to its predecessor's node, with no detour to a home node. The communication complexity of the concurrent execution in which the object goes from u to z to v to w is</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(aT(z, ~) + a~(~, z)) + (aT(v, z) + da(z, g) + (d~(w, v) + d~(v, w)).</head><p>The first expression in each parenthesized term is the cost of sending the find message from each node to its predecessor via the directory tree, and the second is the cost of sending the move message directly from each node to its successor.</p><p>There are two important points to notice about this communication cost. First, there is no synchronization overhead: the communication cost is the same as a serial execution in which each node issues its find only after its predecessor is ready to release the object. Second, the inherent cost of the transfer from u to z is da(z, u) -4-da(u, z), the inherent cost of delivering matching find and move messages. The arrow directory replaces the first term with dT(z, u), suggesting that the navigation cost of the arrow directory approaches optimality to the degree that dT (z, u) approaches de (z, u). We elaborate on these observations in the next section. <ref type="bibr" target="#b3">4</ref> Analysis</p><p>In this section, we describe the algorithm using a simplified version of the I/O automaton formalism of Lynch and Tuttle <ref type="bibr" target="#b16">[17]</ref>, we sketch safety and liveness issues, and evaluate the algorithm's cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head><p>Recall that the network is a connected graph G : (V, E), where IV] = n. There are two kinds of messages: node v issues a find(v) message to request access to an object, and move(u) to transfer ownership to u. Each node v has following attributes: link(v) is a node, queue(v) is either a node or _L, and owner(v) is a boolean. Each pair of nodes (u, v) has a an associated pending(u, v), which is a set of messages that have been sent but not delivered (i.e., in transit, or queued at the sender or receiver).</p><p>A node v or link link(v) is terminal if link(v) --v. The directory is initialized so that there is exactly one node v0 such that v0 is terminal and owner(vo) is true, the remaining non-terminal link pointers form an oriented tree, and all pending(u, v) sets are empty. Message delivery is reliable, but not necessarily FIFO. A node initiates a find operation by sending a find message to itself For brevity, we assume that a node w has only one find(w) message in the network at a time.</p><p>We use T to denote the undirected tree, and L to denote the directed graph induced by non-terminal links. The algorithm has the property that T does not change, but L does. The algorithm is defined by a number of transitions. The first part of each transition is a precondition that must be satisfied for the transition to occur, and the second part describes the state of the directory after the transition. A primed component indicates how a component's state changes after the transition.</p><p>Several transitions require a node atomically to remove a message from a network link, undergo an internal transition, and insert the message in another link. In practice, this atomicity is realized simply by requiring each node to finish processing one message before it starts processing the next.</p><p>The first transition says that when find(w) is sent from node u to a nonterminal node v, v flips its link pointer to u and forwards the message to its old link. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>pe,,ding'(v, link(v)) = pending(v, link(v)) V {find(w)} link'(v) = u</head><p>If, however, v is a terminal node, then w is enqueued behind v.</p><formula xml:id="formula_0">find(w) E pending(u, v) link(v) = v pending' (u, v) = pending(u, v) -{find(w)} link'(v) = u queue'(v) = w</formula><p>We do not explicitly model whether the object is actively in use. Instead, we treat the owner's receipt of a find and its corresponding move as distinct events, separated by an arbitrary but finite delay. If the current owner's queue is nonempty, then it may relinquish ownership and move the object directly to the waiting node. pre:</p><formula xml:id="formula_1">owner(v) = true queue(v) r _L post: pending'(v, queue(v)) = pending(v,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>queue(v)) U {move(queue(v))} owner'(v) = false queue' ( v ) = _L</head><p>When a waiting node receives the object, that node becomes the new owner. pre:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>move(v) E pending(u, v)</head><p>post:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>owner'(v) = true pending' (u, v) = pending (u, v) -{ move (v) }</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Safety</head><p>Our proof of the directory's safety properties is an invariance argument. At all times, we show that there exists a well-defined path in L from any node that leads either to the object's current owner, or to another node that has requested the object. Because find messages follow these paths, any message that reaches the end of a path will either acquire ownership of the object, or join the queue waiting for the object.</p><p>First, we need to check that such paths exist.</p><p>Lemma 1. The following property is invariant:</p><formula xml:id="formula_2">find(w) E pending(u, v) ~ link(u) • v A link(v) • u. (<label>1</label></formula><formula xml:id="formula_3">)</formula><p>Proof. Initially, the property holds vacuously, because no messages are in transit.</p><p>Consider the first transition to violate the property. There are two cases to consider. In the first case, suppose the directory enters a state where</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>find(w) pending'(u, v) ^ link'(u) = v</head><p>Immediately before this transition, we claim that find(w) E pending(v, u) A link(u) = v, so the property was already violated. First, find(w) is in pending(v, u), because otherwise link'(u) would not be set to v. Second, link(u) must be v, because otherwise the message would not be forwarded to v. In the second case, suppose the directory enters a state where find(w) 9 pending'(u, v) A link'(v) = u.</p><p>Immediately before this transition, we claim that find(w) 9 pending(v, u) A link(v) = u, so the property was already violated. First, find(w) is in pending(v, u), because otherwise link'(u) would not be set to v. Second, link(v) must be u, because the transition does not change link(v).</p><p>Lemma2. The directed graph L induced by the non-terminal links is always acyclic.</p><p>Proof. Because T is a tree, it suffices to show the directory cannot enter a state where link(u) = v and link(v) = u for distinct nodes u and v. Consider the first transition that sets link'(v) = u while link(u) = v. Any such transition is enabled only if find(w) E pending(u, v) and link(u) = v, which is impossible by Lemma 1.</p><p>Definition3. The path from a node is the directed path in L from that node to a terminal node.</p><p>Definition4. The target of v, denoted target(v), is the terminal node at the end of its path. If find(w) is a message in pending(u, v), then that message's target is target(v).</p><p>Lemma 2 guarantees that these notions are well-defined. A node is a waiter if it has requested an object, but has not yet become the owner of that object.</p><p>We are now ready to prove our principal safety result:</p><p>Theorem 5. The path from any node always leads either to the current owner or a waiter.</p><p>Proof. Any node v partitions the set of nodes G into Ay and By, where Ay consists of nodes whose paths include v, and By consists of the rest. For every u in Av, target(u) = target(v).</p><p>Consider the directory state immediately before a transition"flipping" link (v) to u. By Lemma 2, u E By. After the transition, for every w in By, target'(w) = target(w), so target(w) remains an owner or a waiter. For every z in Av (including v itself), target'(z) = target'(u) -= target(u), so target(z) remains an owner or a waiter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Liveness</head><p>Liveness is also based on invariance arguments. Liveness requires that transitions occur fairly: any transition whose precondition remains true will eventually occur. (For example, any message in pending(u, v) will eventually be removed.) We will show that when a find message is in transit, that message "traps" its target in a component L1 of the link graph L: other find and move messages can move the target within L1, but the target cannot leave L1. Each transition that advances the find message shrinks L1 by at least one node, so after at most n advances, L1 consists of a single node, and the find message must reach its target. Theorem 6. Each find(w) message will be delivered to its target in n steps or fewer, Proof. Suppose find(w) is in pending(u, v). Deleting the edge (u, v) from the undirected tree T splits T into two disjoint trees, before(w) (containing u) and after(w) (containing v). Lemma 1 states that as long as find(w) is in pending(u, v), then link(v) ~s u and link(u) r v, so the message's target will remain in after(w). (Other find requests may still move the target within after(w).)</p><p>If a transition delivers find(w) to its target, we are done. A transition that moves the message from pending(u, v) to pending' (v, link(v)) induces a new partition before'(w) and after'(w), where v • after'(w). Because each after'(w) is strictly smaller than after(w), the find(w) message will arrive at its target after at most n steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Complexity</head><p>How should we evaluate the communication cost of this protocol? Following Peleg <ref type="bibr" target="#b19">[20]</ref>, it is natural to compare our communication complexity to that of an optimal directory for which synchronization and navigation are free. The optimal directory accepts only serial schedules (so it pays nothing for synchronization), and delivers each find and move message directly (so it pays nothing for navigation).</p><p>An execution is a sequence of atomic node steps, message sends, and message receipts. An execution is complete if every find message has a matching move. and an execution is serial if the receipt of the i-th move message precedes the sending of each (i + 1)-st find. The next lemma states that we can restrict our attention to complete serial executions. Lemma 7. If E is any complete concurrent execution of the arrow directory protocol, then there exists a complete serial execution E ~ that serializes requests in the same order, sends the same messages, and leaves the directory in the same state.</p><p>Define the MST-stretch of G, denoted MST-stretch(G), to be dT(u,v) max --</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>u,vev dG(u, v) "</head><p>This quantity measures how far from optimal a path through the minimum spanning tree can be. The MST-stretch can be n in the worst case (a ring), but is likely to be much smaller in realistic networks (such as LANs, or the Internet).</p><p>Consider a serial execution in which v0, 9 9 vl successively acquire the object.</p><p>In the arrow directory, each find message traverses the spanning tree T, with cost dT (vi, V~+l), while in the optimal directory, the message goes directly from vi to Vi+l, with cost dG <ref type="bibr">(v~, v~+l)</ref>. The ratio of these quantities is no more than MST-stretch(G). In both the arrow and optimal directories, the move message incurs cost dc(v~, Vi+l), so this ratio is 1. (From a practical perspective, it is worth emphasizing that we are not hiding any constants: these bounds really are MST-streteh(G) and 1, not O(MST-stretch(G)) or O(1).)</p><p>As a result, for any complete serial execution, the ratio of communication costs for the arrow directory and the optimal directory is bounded by</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">+ MST-stretch(G) 2</head><p>The lower the network's MST-stretch, the closer the communication cost of the arrow directory is to optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>Our discussion so far has focused on the safety, liveness, and communication cost of an idealized directory scheme. We now briefly address other issues of practical interest.</p><p>One sensible way to reduce the directory's memory consumption and message traffic is to organize the directory as a two-level structure. The network is partitioned into neighborhoods of small diameter, where the arrow directory is maintained at a per-neighborhood granularity, and a home-based directory is used within each individual neighborhood. (For example, the neighborhood could be a local subnetwork, and the node its gateway.) The resulting hybrid scheme trades communication cost against memory consumption and directory tree traffic. As discussed below, Peleg <ref type="bibr" target="#b19">[20]</ref> and Awerbuch and Peleg <ref type="bibr" target="#b2">[3]</ref> have also proposed multi-level directory structures.</p><p>Note that only find messages go through the directory tree --the network's routing service handles all other traffic, such as move messages, remote procedure calls, etc. Find messages for different objects that arrive together can be combined before forwarding.</p><p>We have assumed for simplicity that every node is initialized with a directory entry for each object. It is more practical to initialize an object's directory links in the following "lazy" manner. Before a node can request an object, it must first acquire that object's name. When a node u receives a message from v containing the name of an unfamiliar object, it sends a message through the directory tree to v initializing the intermediate missing links. This lazy strategy preserves locality: if all references to an object are localized within the directory tree, then the other nodes need never create a directory entry for that object.</p><p>So far, we have considered only exclusive access to objects. Many applications would benefit from support for shared (read-only) access as well. We now outline a simple extension of the arrow directory protocol to support read-only replication. When multiple read-only copies exist, one is designated the primary. Each directory entry consists of a primary link pointing toward the primary copy, and a set of secondary links, each pointing toward one or more copies. When a node requests a read-only copy of an object, it follows any secondary link from each vertex, creating a new secondary link pointing back to itself at each node it visits. When a node requests exclusive access to the object, it first follows the primary links, flipping each primary link toward itself. When the node has acquired exclusive access to the primary, it invalidates the read-only copies by following, flipping, and consolidating the secondary links. When all invalidations are complete, the node has acquired the object. This protocol is linearizable <ref type="bibr" target="#b10">[11]</ref>. More efficient protocols might be achieved by replacing linearizability with weaker notions of correctness <ref type="bibr" target="#b0">[1]</ref>.</p><p>We have not addressed the issue of fault-tolerance. Distributed mutual exclusion algorithms address the problem by "token regeneration", effectively electing a node to hold the new token. Here, the problem is different, since we cannot elect a new object, but we do need to recover navigational information that may be lost following a crash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Distributed directory management is closely related to the problem of distributed mutual exclusion. Na'imi, Tr~hel, and Arnold <ref type="bibr" target="#b17">[18]</ref> describe a distributed mutual exclusion algorithm (the NTA algorithm) also based on a dynamically changing distributed directed graph. In the NTA algorithm, when a node receives a message, it flips its edge to point to the node from which the request originated. In our algorithm, however, the node flips its edge to point to the immediate source of the message. As a result, our graph is always a directed subgraph of a fixed minimal spanning tree, while the NTA graph is more fluid. The safety and liveness arguments for NTA and for our algorithm are similar, (though not identical), but the complexity models are quite different. The complexity analysis given in <ref type="bibr" target="#b17">[18]</ref> is based on a model in which the underlying network is a clique, with unit cost to send a message from any node to any other. All nodes are assumed equally likely to request the token, and requests are assumed to occur sequentially. Under these assumptions, NTA shows that the average number of messages sent over a long period converges to O(log n). <ref type="bibr">(Ginat [8]</ref> gives an amortized analysis of the NTA algorithm and some variants.) Our analysis, by contrast, models the underlying network as a weighted graph, where the end-to-end cost of sending a message is the sum of weights along its path. Instead of taking an average over a presumed uniform distribution, we compete against a directory with perfect instantaneous knowledge of the object's current location and no synchronization costs. The complexity analysis of Na'imi et al. does not apply to our algorithm, nor ours to theirs.</p><p>The NTA complexity model is appropriate for the general problem of distributed mutual exclusion, while ours is intended for the more specific problem of managing distributed directories in the Internet. Each link in our spanning tree is intended to represent a direct network link between routers, which is why our algorithm does not flip edges to point to arbitrarily distant network nodes (even though the routing service renders any pair of nodes "adjacent" for communication). The NTA complexity model, while mathematically quite elegant, does not seem well-suited for distributed Internet directory management, because point-to-point communication cost is not uniform in real networks, and access requests to distributed objects are typically not generated uniformly at random, but often have strong locality properties. For these reasons, a competitive complexity model seems more appropriate for our purposes.</p><p>Another mutual exclusion protocol employing path reversal is attributed to SchSnhage by Lynch and Tuttle <ref type="bibr" target="#b15">[16]</ref>. In this protocol, the directory is a directed acyclic graph. Users residing at leaf nodes request the object, and requests are granted by arbiters residing at internal nodes. Edges change labels and orientation to reflect the object's current status and location.</p><p>The arrow directory protocol was motivated by emerging active network technology <ref type="bibr" target="#b13">[14]</ref>, in which programmable network switches are used to implement customized protocols, such as application-specific packet routing. Active networks are intended to ensure that the cost of routing messages through the directory tree is comparable to the cost of routing messages directly through the network.</p><p>Small-scale multiprocessors (e.g., <ref type="bibr" target="#b8">[9]</ref>) typically rely on broadcast-based protocols to locate objects in a distributed system of caches. Existing large-scale multiprocessors and existing distributed shared memory systems are either homebased, or use a combination of home-based and forwarding pointers <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b18">19]</ref>.</p><p>Plaxton et al. <ref type="bibr" target="#b21">[22]</ref> give a randomized directory scheme for read-only objects. Peleg <ref type="bibr" target="#b19">[20]</ref> and Awerbuch and Peleg <ref type="bibr" target="#b2">[3]</ref> describe directory services organized as a hierarchical system of subdirectories based on sparse network covers <ref type="bibr" target="#b1">[2]</ref>. The earlier paper <ref type="bibr" target="#b19">[20]</ref> proposed the notion of stretch to evaluate the performance of distributed directory services. In the worst case, these directories use per-object memory logarithmic in n, while ours is linear. (As described above, we believe we can avoid worst-case memory consumption in practice.) Strictly speaking, the asymptotic communication complexities are incomparable. Their notion of an optimal concurrent find execution is less conservative than ours, but for simplicity we will treat them as equivalent. The ratio of their concurrent find and move operations to their notion of an optimal protocol is polylogarithmic in n, while the ratio of our concurrent find and move operations to our (more conservative) notion of an optimal protocol is (1 + MST-stretch(G))/2. The arrow directory has lower asymptotic communication complexity when the MST-stretch of the network is less than some polylogarithm in n. Nevertheless, we feel the most important distinction is that the arrow directory protocol is much simpler than any of the hierarchical protocols, because it is explicitly designed to be implemented. We plan to report experimental results in the near future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 1. Initial Directory State</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 3. Find message received</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. w's request blocked at v Q queue: v %</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>) e pending(u, v) link(v) r v pending' (u, v) --= pending (u, v) -{find (w) }</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A version of this paper appears in IEEE Computer</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
		<idno>ECE TR 9512 and Western Research Laboratory Research Re- port 95/7</idno>
		<imprint>
			<date type="published" when="1995-09">September 1995. December 1996</date>
			<biblScope unit="page" from="66" to="67" />
			<pubPlace>Houston, TX</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Rice University ECE</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Shared memory consistency models: A tutorial</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast distributed network decompositions and covers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cowen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="114" />
			<date type="published" when="1996-12-15">15 December 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Online tracking of mobile users</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1021" to="1058" />
			<date type="published" when="1995-09">September 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Midway distributed shared memory system</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zekauskas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Sawdon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 38th IEEE Computer Society International Conference</title>
		<meeting>38th IEEE Computer Society International Conference</meeting>
		<imprint>
			<date type="published" when="1993-02">February 1993</date>
			<biblScope unit="page" from="528" to="537" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Implementation and performance of Munin</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Bennet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Symposium on Operating Systems Principles</title>
		<meeting>the 13th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1991-10">October 1991</date>
			<biblScope unit="page" from="152" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">LimitLESS directories: A scalable cache coherence scheme</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Of The ~th International Conference on Architectural Support ]or Programming Langauges and Operating Systems</title>
		<meeting>Of The ~th International Conference on Architectural Support ]or Programming Langauges and Operating Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1991-04">April 1991</date>
			<biblScope unit="page" from="224" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Memory requirement for universal routing schemes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Frajgniaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gavoille</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing</title>
		<meeting>the 13th Annual ACM Symposium on Principles of Distributed Computing</meeting>
		<imprint>
			<publisher>acm</publisher>
			<date type="published" when="1995-08">August 1995</date>
			<biblScope unit="page" from="223" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Adaptive ordering ofcondending processes in distributed systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ginat</surname></persName>
		</author>
		<idno>CS-TR-2335</idno>
		<imprint>
			<date>October 89</date>
		</imprint>
		<respStmt>
			<orgName>University of Maryland, Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Synchronization algorithms for shared-memory multiprocessors</title>
		<author>
			<persName><forename type="first">G</forename><surname>Graunke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thakkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="60" to="70" />
			<date type="published" when="1990-06">June 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Aleph toolkit: Platform-independent distributed shared memory</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Herlihy</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>preliminary report). ,,w. cs.brown, edu/&apos;mph/aloph</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Linearizability: A correctness condition for concurrent objects</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions On Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="463" to="492" />
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">CRL: High-Performance All-Software Distributed Shared Memory</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proe. of the 15th ACM Syrup. on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="1995-12">December 1995</date>
			<biblScope unit="page" from="213" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">TreadMarks: Distributed Shared Memory on Standard Workstations and Operating Systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Keleher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dwarkadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Winter 1994 USENIX Conference</title>
		<meeting>of the Winter 1994 USENIX Conference</meeting>
		<imprint>
			<date type="published" when="1994-01">January 1994</date>
			<biblScope unit="page" from="115" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Improving the performance of distributed applications using active networks</title>
		<author>
			<persName><forename type="first">U</forename><surname>Legedza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherhall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guttag</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-04">April 1998</date>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
	<note>Submitted to IEEE INFOCOMM</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Memory coherence in shared virtual memory systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="321" to="359" />
			<date type="published" when="1987-11">November 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Hierarchical correctness proofs for distributed algorithms</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Tuttle</surname></persName>
		</author>
		<idno>MIT/LCS/TM-387</idno>
		<imprint>
			<date type="published" when="1987-04">April 1987</date>
		</imprint>
		<respStmt>
			<orgName>MIT Laboratory For Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">An introduction to input/output automata</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Tuttle</surname></persName>
		</author>
		<idno>MIT/LCS/TM-373</idno>
		<imprint>
			<date type="published" when="1988-11">November 1988</date>
		</imprint>
		<respStmt>
			<orgName>MIT Laboratory For Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Tr6hel, and A. Arnold. A log(n) distributed mutual exclusion algorithm based on path reveral</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nai'mi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Shared Memory&quot; C for Distributed-Memory Machines</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Nikhil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th Int&apos;l Workshop on Languages and Compilers for Parallel Computing</title>
		<meeting>of the 7th Int&apos;l Workshop on Languages and Compilers for Parallel Computing</meeting>
		<imprint>
			<date type="published" when="1994-08">August 1994</date>
		</imprint>
	</monogr>
	<note>Cid: A Parallel</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Distance-dependent distributed directories</title>
		<author>
			<persName><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">103</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="298" />
			<date type="published" when="1993-04">April 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A trade-off between space and efficiency for routing tables</title>
		<author>
			<persName><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="43" to="52" />
			<date type="published" when="1989-07">July 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Accessing nearby copies of replicated objects in a distributed environment</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Plaxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Richa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual ACM Symposium on Parallel Algorithms and Architectures</title>
		<meeting>the 9th Annual ACM Symposium on Parallel Algorithms and Architectures</meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
			<biblScope unit="page" from="311" to="321" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
