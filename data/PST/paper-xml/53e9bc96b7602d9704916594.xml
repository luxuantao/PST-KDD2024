<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Pacifier: High-Throughput, Reliable Multicast Without &quot;Crying Babies&quot; in Wireless Mesh Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE, ACM</roleName><forename type="first">Dimitrios</forename><surname>Koutsonikolas</surname></persName>
							<email>dimitrio@buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering Depart-ment</orgName>
								<orgName type="institution" key="instit1">University at Buffalo</orgName>
								<orgName type="institution" key="instit2">State University of New York (SUNY)</orgName>
								<address>
									<postCode>14260</postCode>
									<settlement>Buffalo</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Purdue University</orgName>
								<address>
									<postCode>47907</postCode>
									<settlement>West Lafayette</settlement>
									<region>IN</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Y</forename><forename type="middle">Charlie</forename><surname>Hu</surname></persName>
							<email>ychu@purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering Depart-ment</orgName>
								<orgName type="institution" key="instit1">University at Buffalo</orgName>
								<orgName type="institution" key="instit2">State University of New York (SUNY)</orgName>
								<address>
									<postCode>14260</postCode>
									<settlement>Buffalo</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Chih-Chun</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering Depart-ment</orgName>
								<orgName type="institution" key="instit1">University at Buffalo</orgName>
								<orgName type="institution" key="instit2">State University of New York (SUNY)</orgName>
								<address>
									<postCode>14260</postCode>
									<settlement>Buffalo</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Pacifier: High-Throughput, Reliable Multicast Without &quot;Crying Babies&quot; in Wireless Mesh Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2DD54B9EE048E7CC164DFBD15E6C3A10</idno>
					<idno type="DOI">10.1109/TNET.2011.2177274</idno>
					<note type="submission">Manuscript received September 08, 2009; revised June 02, 2010, June 04, 2011, November 09, 2011; accepted November 14, 2011; approved by IEEE/ACM TRANSACTIONS ON NETWORKING Editor S. Borst. Date of publication December 15, 2011; date of current version October 11, 2012.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Network coding</term>
					<term>reliable multicast</term>
					<term>wireless mesh networks (WMNs)</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In contrast to unicast routing, high-throughput reliable multicast routing in wireless mesh networks (WMNs) has received little attention. There are two primary challenges to supporting high-throughput, reliable multicast in WMNs. The first is no different from unicast: Wireless links are inherently lossy due to varying channel conditions and interference. The second, known as the "crying baby" problem, is unique to multicast: The multicast source may have varying throughput to different multicast receivers, and hence trying to satisfy the reliability requirement for poorly connected receivers can potentially result in performance degradation for the rest of the receivers. In this paper, we propose Pacifier, a new high-throughput, reliable multicast protocol for WMNs. Pacifier seamlessly integrates four building blocks-namely, tree-based opportunistic routing, intraflow network coding, source rate limiting, and round-robin batching-to support high-throughput, reliable multicast routing in WMNs, while at the same time it effectively addresses the "crying baby" problem. Our experiments on a 22-node IEEE 802.11 WMN testbed show that Pacifier increases the average throughput over a state-of-the-art reliable network coding-based protocol MORE by up to 144%, while at the same time it solves the "crying baby" problem by improving the throughput of well-connected receivers by up to a factor of 14.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In contrast to unicast routing, high-throughput, reliable multicast routing has received relatively little attention. In contrast to IP multicast in the wired Internet, we believe multicast is and will be a fundamental mode of communication in wireless networks due to the wireless multicast advantage (WMA) <ref type="bibr" target="#b7">[8]</ref>. The use of IEEE 802.11 broadcast-based multicast instead of individual unicast sessions has been heavily studied recently in the community in the context of 802.11 WLANs (e.g., <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b9">[10]</ref>). Also, in <ref type="bibr" target="#b5">[6]</ref>, the proposed MORE protocol is designed to be a reliable unicast and multicast protocol to support future applications in multihop WMNs.</p><p>We envision at least three important classes of applications of high-throughput, reliable multicast in the context of community WMNs: 1) multicasting WMN-related software (e.g., a router software update or a security patch) hosted on a node controlled by the WMN operator to the WMN routers; 2) multicasting community-related audio/video files (e.g., a local football match that was held the day before) stored in a local database to WMN clients. In both these scenarios, the WMN node hosting the content serves as the multicast root; 3) a large group of WMN users downloading a popular file from the Internet (e.g., a new version of Windows); in that case, a proxy at the WMN gateway serves as the multicast root. For all these applications, using multicast instead of individual multihop unicast sessions can lead to significant wireless bandwidth savings due to the WMA.</p><p>A common characteristic of all these applications, in contrast to live streaming (another popular class of multicast applications), is a strict requirement of 100% packet delivery ratio (PDR) since every byte of the downloaded file has to be received by all the receivers. This requirement makes many of the reliable multicast protocols proposed in the past (e.g., <ref type="bibr" target="#b10">[11]</ref>- <ref type="bibr" target="#b13">[14]</ref>) inappropriate since they cannot guarantee 100% PDR. In addition, reliability for this class of applications cannot come at the cost of significantly reduced throughput, unlike in many military applications <ref type="bibr" target="#b14">[15]</ref>, since Internet users always desire fast downloads.</p><p>The fundamental challenge in achieving reliable multicast in WMNs is no different from that of reliable unicast-that wireless links are lossy. To overcome this, researchers have applied classic techniques such as automatic repeat request (ARQ), forward error correction (FEC), or combinations of the two. The majority of the works on reliable multicast in multihop wireless networks either are solely based on ARQ (e.g., <ref type="bibr" target="#b15">[16]</ref> and <ref type="bibr" target="#b16">[17]</ref>), which suffers the feedback implosion problem, or combine ARQ with congestion control (e.g., <ref type="bibr" target="#b12">[13]</ref> and <ref type="bibr" target="#b17">[18]</ref>). A recent work <ref type="bibr" target="#b18">[19]</ref> studied the applicability of FEC and hybrid ARQ-FEC techniques, borrowed from the wired Internet, to WMNs and showed that RMDP <ref type="bibr" target="#b19">[20]</ref>, a hybrid ARQ-FEC protocol, can achieve both reliability and high throughput.</p><p>More recently, researchers have applied network coding (NC), a technique originally developed for the wireline Internet, to overcome the above challenge. Reference <ref type="bibr" target="#b20">[21]</ref> showed that the operation of mixing packets resembles the operation of rateless FEC codes. Actually, NC can be viewed as a technique equivalent to performing hop-by-hop FEC, without the delay penalty incurred by the decoding operations at each hop, that would be required by hop-by-hop FEC. In <ref type="bibr" target="#b21">[22]</ref>, the authors went one step further and showed that the reliability gain (expressed as the expected number of transmissions) of NC over end-to-end FEC for a wireless multicast tree of height with link loss rate is in the order of . Practical work that exploits the idea of utilizing NC for reliable multicast is still at a preliminary stage. MORE <ref type="bibr" target="#b5">[6]</ref> is the only practical NC-based protocol that supports high-throughput, reliable multicast. It combines NC with OR, with the primary goal of removing the need for coordination required in opportunistic routing. However, the design of MORE also guarantees reliability, i.e., MORE is a routing protocol for reliable file transfer, for both unicast and multicast.</p><p>A second fundamental challenge in reliable multicast, which is unique to multicast, is the "crying baby" problem as first pointed out in <ref type="bibr" target="#b22">[23]</ref> in the context of multicast in the Internet. If one receiver has a particularly poor connection, then trying to satisfy the reliability requirement for that receiver may result in performance degradation for the rest of the receivers. This problem also raises the interesting question of what is a suitable definition of overall performance metric if multiple receivers are allowed to achieve uneven throughput. Regardless, a major challenge in the design of high-throughput, reliable multicast protocols is whether it is possible to develop a protocol that improves the throughput of well-connected receivers without worsening the already low throughput of poorly connected receivers.</p><p>In spite of its significance, the "crying baby" problem has been largely ignored by the majority of the wireless reliable multicast protocols proposed in the past. To our best knowledge, BMCC <ref type="bibr" target="#b12">[13]</ref>, a multicast protocol for mobile ad hoc networks, was the first protocol to consider the problem in the context of multihop wireless networks. BMCC allows a router to drop packets on the path toward the worst receiver in order to prevent that receiver from holding back the rest of the receivers. This solution is not applicable in file-download applications where 100% PDR is required, and hence dropping packets for some receivers is not an option. Essentially, the requirement for 100% PDR makes the problem much more challenging.</p><p>In this paper, we propose Pacifier, a high-throughput, reliable multicast protocol that systematically addresses the above two challenges for reliable file transfer applications. Pacifier seamlessly integrates four building blocks-namely, tree-based OR, intraflow NC, source rate limiting, and round-robin batching-to support high-throughput, reliable multicast routing and at the same time solve the "crying baby" problem. First, Pacifier builds an efficient multicast tree traditionally used by multicast protocols and naturally leverages it for opportunistic overhearing. Second, Pacifier applies intraflow, random linear NC to overcome packet loss over lossy links, which avoids hop-by-hop feedback and the coordination of multicast tree forwarders in packet forwarding. Third, Pacifier applies rate limiting at the source, reducing the congestion level in the network. Fourth, Pacifier solves the "crying baby" problem by having the source send batches of packets in a round-robin fashion. This functionality allows Pacifier to improve the throughput of well-connected nodes drastically and often times of poorly connected nodes.</p><p>To evaluate Pacifier, we first compare its performance against MORE, using extensive realistic simulations. Our simulations use a realistic physical model with random signal variations due to fading, take into account the additional packet header overhead introduced by the use of NC and OR, and are conducted over a variety of network topologies and multicast groups. Our simulation results show that Pacifier increases the average throughput of multicast receivers over MORE by 171%, while it solves the "crying baby" problem, by increasing the maximum throughput gain for well-connected receivers by up to 20 . Interestingly and importantly, Pacifier also improves the throughput of the "crying babies", i.e., the poorly connected receivers, by up to 4.5 .</p><p>Second, since Pacifier uses the same type of NC as MORE and has the same memory requirements at the routers, hence, like MORE, it can be easily implemented on commodity hardware. To demonstrate this, we present an application-layer implementation of Pacifier and MORE on Linux and their performance evaluation on a 22-node 802.11 WMN testbed deployed in two academic buildings on the Purdue University campus in West Lafayette, IN. Our testbed results verify the simulation results showing that Pacifier increases the average multicast throughput over MORE by 83%-114%, while the maximum throughput gain for well-connected receivers can be as high as 14 , and the maximum throughput gain for the "crying baby" itself can be as high as 5. <ref type="bibr" target="#b3">4</ref> .</p><p>In summary, we make the following contributions.</p><p>• We address the problem of high-throughput, reliable multicast for file-download applications in deployed WMNs. We identify two challenges in supporting high-throughput, reliable multicast (i.e., 100% PDR) in deployed WMNs: high packet loss rates <ref type="bibr" target="#b23">[24]</ref> and the "crying baby" problem.</p><p>In particular, to our best knowledge, this is the first work that addresses the well-known in the wired Internet "crying baby" problem in the context of file-download applications in multihop WMNs. The requirement for 100% PDR, posed by the nature of the application into consideration, makes the problem even more challenging, and existing solutions <ref type="bibr" target="#b12">[13]</ref> are not applicable. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>In spite of the extensive research on reliable multicast in the wired Internet, which went through the development of ARQ-based schemes (e.g., <ref type="bibr" target="#b22">[23]</ref> and <ref type="bibr" target="#b24">[25]</ref>), to FEC schemes (e.g., <ref type="bibr" target="#b25">[26]</ref>), to hybrid ARQ-FEC schemes (e.g., <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b26">[27]</ref>, and <ref type="bibr" target="#b27">[28]</ref>), to rateless codes <ref type="bibr" target="#b28">[29]</ref>- <ref type="bibr" target="#b31">[32]</ref>, the majority of the work on reliable multicast in multihop wireless networks has used the traditional ARQ techniques. A survey on reliable multicast protocols for ad hoc networks <ref type="bibr" target="#b33">[33]</ref> classifies them into deterministic and probabilistic ones, depending on whether data delivery is fully reliable or not. Deterministic protocols (e.g., <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b17">[18]</ref>, and <ref type="bibr" target="#b34">[34]</ref>- <ref type="bibr" target="#b36">[36]</ref>) provide deterministic guarantees for packet delivery ratio, but they can incur excessive high overhead and drastically reduced throughput. On the other hand, probabilistic protocols (e.g., <ref type="bibr" target="#b10">[11]</ref> and <ref type="bibr" target="#b11">[12]</ref>) incur much less overhead compared to the former, but they do not offer hard delivery guarantees. Using rateless codes requires the source to continuously send packets, which can cause congestion in the bandwidth-limited wireless networks. Recently, <ref type="bibr" target="#b18">[19]</ref> studied the applicability of FEC and hybrid ARQ-FEC techniques, borrowed from the wired Internet, to WMNs, and showed that RMDP <ref type="bibr" target="#b19">[20]</ref>, a hybrid ARQ-FEC protocol, can provide both reliability and high throughput.</p><p>Most recently, intraflow network coding has been proposed as a whole new approach to reliable routing. NC in theory is equivalent to hop-by-hop FEC <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, and hence the maximum amount of redundancy injected from any node in the network is determined by the lossiest link of the tree, and not by the lossiest path from the source to any receiver, unlike in end-to-end FEC. However, hop-by-hop FEC/NC also has its practical drawbacks; it requires buffering packets at each node for decoding/reencoding (in case of FEC) or only reencoding (in case of NC). Due to the constraints on the buffer size and on packet delay, NC needs to send packets in batches, i.e., the source needs to wait until a batch is received by all receivers before proceeding to the next batch. This introduces the "crying baby" problem, where the poorly connected receivers slow down the completion time of well-connected receivers.</p><p>To our best knowledge, MORE is the only NC-based protocol for high-throughput, reliable multicast routing (though it is also for unicast). Due to its significance, and since we will compare Pacifier against it in our evaluation, we present a brief overview of MORE in Section II-A. To our knowledge, the only other practical NC-based multicast protocol is CodeCast <ref type="bibr" target="#b13">[14]</ref>, which exploits NC for improving but not guaranteeing reliability in multimedia multicast applications in mobile ad hoc networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overview of MORE</head><p>MORE <ref type="bibr" target="#b5">[6]</ref> is an OR protocol for reliable file transfer. MORE is implemented as a shim between the IP and the 802.11 MAC layer. In the following, we describe the main functions of MORE, focusing on its multicast operation. We briefly review its two major features: forwarding node (FN) selection and packet batching.</p><p>FN Selection: MORE uses the ETX metric <ref type="bibr" target="#b37">[37]</ref>, based on loss rate measurements, to select the possible FNs. ETX is equal to the expected number of transmissions required to successfully transmit a packet from the source to a destination. For each destination, the source includes in the FN list the nodes whose ETX distance to that destination is shorter than the source's distance. Also, for each FN, the source includes a TX credit in the FN list. The TX credit is the expected number of transmissions a node should make for every packet it receives from a node farther from a destination in the ETX metric in order to ensure that at least one node closer to the destination will receive the packet.</p><p>The algorithm for FN selection and TX credit calculation is run at the source. The algorithm starts by assuming that every node is a candidate FN for a source-destination pair and calculates the expected number of transmissions this node would make. It then prunes nodes that are expected to perform less than 10% of the total transmissions and assigns TX credits to the remaining ones, which form a belt of FNs that connects the source to the destination. The algorithm is repeated for each destination; in the end, the belts formed for each destination are merged into the final FN set. If an FN belongs to more than one belt, (i.e., for more than one destination), the algorithm calculates a different expected number of transmissions for each of the belts to which it belongs. Its final TX credit is then calculated using the maximum number of transmissions among these belts.</p><p>Batching and Coded Packet Forwarding: In MORE, the source breaks a file into batches of packets. Whenever the MAC is ready to send a packet, the source creates a random linear combination of the packets of the current batch and broadcasts the encoded packet. Each packet is augmented with its code vector, the batch ID, the source and destination IP addresses, and the list of FNs for that multicast with their TX credits.</p><p>Packets are broadcast at the MAC layer, and hence they can be received by all nodes in the neighborhood. When a node hears a packet, it checks if it is in the packet's FN list. If so, the node checks if the packet is linearly independent with all the packets belonging to the same batch that it has already received. Such packets are called innovative packets and are stored in a buffer. Non-innovative packets are discarded. Every time a node receives a packet from an upstream node, it increments its credit counter by its assigned TX credit included in the packet header. If its credit counter is positive, whenever the MAC is ready to send a packet, the node creates a linear combination of the innovative packets it has received so far and broadcasts it. Broadcasting a packet decrements the credit counter by one unit.</p><p>A multicast receiver decodes a batch once it collects innovative packets from that batch. It then sends an ACK back to the source along the shortest ETX path in a reliable manner. The source keeps sending packets from the same batch until all receivers have decoded and acknowledged the current batch; it then proceeds to the next batch. Whenever a receiver acknowledges the current batch, the source removes the FNs responsible for forwarding packets only toward that receiver and recalculates the credits for the remaining FNs, using the maximum number of transmissions taken only over FN belts to receivers that have not yet acknowledged the batch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. Pacifier DESIGN</head><p>The design of Pacifier addresses several weaknesses of MORE. In particular, the belt-based forwarding in MORE can be inefficient for multiple receivers, MORE lacks source rate limiting, which can lead to congestion in data dissemination, and MORE suffers the "crying baby" problem.</p><p>For clarity, we present the design of Pacifier in several steps. We first present a basic version of Pacifier, which consists of several building blocks: tree-based opportunistic multicast routing, batching and NC-based forwarding, and credit calculation. The basic version guarantees reliability and already increases throughput compared to MORE, but does not solve the "crying baby" problem. We then present two optimizations: source rate limiting that reduces congestion and further improves the throughput, and round-robin batching, which solves the "crying baby" problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Tree-Based Opportunistic Routing</head><p>We argue that the use of OR in the form used in MORE is an overkill for multicast, and it can lead to congestion, for two reasons. First, even for a single destination, congestion can occur if too many nodes act as FNs, or if the FNs are far from each other and they cannot overhear each other's transmissions <ref type="bibr" target="#b38">[38]</ref>. The situation is worsened when the number of flows increases since almost all nodes in the network may end up acting as FNs. Such performance degradation was observed in the evaluation of MORE in <ref type="bibr" target="#b5">[6]</ref> for many unicast flows; the situation for many hypothetical unicast flows is not very different from a source to many multicast receivers. Second, the benefit of overhearing of broadcast transmissions, which is exploited by OR in MORE, is naturally exploited in a fixed multicast tree, where the use of broadcast allows nodes to receive packets not only from their parent in the multicast tree, but also from ancestors or siblings, essentially transforming the tree into a mesh. We note this property of opportunistic reception of broadcast transmissions has been previously exploited in the design of some of the first multicast protocols for multihop wireless networks (e.g., ODMRP <ref type="bibr" target="#b39">[39]</ref>) for improving the PDR.</p><p>The above observation motivates a simple multicast-tree-based OR design. Specifically, Pacifier starts by building a multicast tree to connect the source to all multicast receivers. The tree is a shortest-ETX tree, constructed at the source by taking the union of all the shortest-ETX paths from the source to the receivers, which in turn are based on periodic loss rate measurements. The multicast tree is reconstructed at the source every time the number of active receivers changes.</p><p>1) Batching and Coded Forwarding: As in MORE, the source and the FNs in Pacifier use intraflow random linear NC. The source breaks a file into small batches of packets and sends random linear combinations of the packets belonging to the current batch. Intermediate FNs store all the innovative packets of the batch and also send random linear combinations of them. We selected a batch size of packets, the same as in <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr" target="#b40">[40]</ref>. The random coefficients for each linear combination are selected from a Galois Field of size 2 , again the same as in <ref type="bibr" target="#b5">[6]</ref>. When a receiver receives any linearly independent coded packets of a batch, it decodes the batch and sends an ACK back to the source along the shortest ETX path in a reliable manner.</p><p>To achieve reliability, this basic version of Pacifier uses the following batch termination scheme: The source keeps transmitting packets from the same batch until all the receivers acknowledge this batch. Such a transmission scheme, however, introduces the "crying baby" problem as the completion time of each batch is limited by that of the worst receiver.</p><p>2) How Many Packets Does an FN Send?: Despite the use of a multicast tree for data forwarding, the use of 802.11 broadcast effectively enables opportunistic routing, i.e., a node can opportunistically receive packets from nodes other than its parent in the multicast tree. If a node forwards every packet it receives, a receiver could potentially receive each packet originated from the source multiple times. To avoid unnecessary transmissions, we need to carefully analyze how many (coded) packets an FN should send upon receiving a data packet.</p><p>Our solution is inspired by the approach used in MORE and is based on the notion of TX credits. Since, in practice, an FN should be triggered to transmit only when it receives a packet, we derive the number of transmissions each FN needs to make for every packet it receives. We define this number as the TX credit for that FN. Thus, in Pacifier, an FN node keeps a credit counter. When it receives a packet from an upstream node (defined below), it increments the counter by its TX credit. When the 802.11 MAC allows the node to transmit, the node checks whether the counter is positive. If yes, the node creates a coded packet, broadcasts it, then decrements the counter. If the counter is negative, the node does not transmit. We note that opportunistic reception of data packets is always allowed, even from downstream nodes. The credit calculation is on how many packets to be transmitted by the FN upon receiving a data packet from an upstream node.</p><p>In the analysis, we focus on disseminating one data packet from the root down the multicast tree. Our analysis is based on the simple principle that in disseminating a packet from the root, each FN in the multicast tree should ensure that each of its child nodes receives the packet at least once. Note this principle slows down a parent node to wait for the worst child and creates the "crying baby" problem at each FN, but is consistent with the batch termination scheme of this basic version of Pacifier.</p><p>We assume an FN sends packets after receiving from any nodes with lower ETX distance from the root to them, i.e., 's upstream nodes. These nodes are likely to receive packets from the root before . <ref type="foot" target="#foot_0">1</ref> We also assume that wireless receptions at different nodes are independent, an assumption that is supported by prior measurements <ref type="bibr" target="#b41">[41]</ref>.</p><p>Let be the number of FNs in the multicast tree rooted at . Let denote the loss probability in sending a packet from node to node . Let denote the expected number of transmissions that FN must make in disseminating one packet (from the root) down the multicast tree. Let denote the set of child nodes of in the multicast tree, and denote the set of 's upstream nodes.</p><p>The expected number of packets that receives from ancestor nodes is . Recall 's objective is to make sure each of its child nodes receives at least one packet. Since each child node has already overheard from node 's ancestors, the amount of packets node actually needs to forward for child is <ref type="bibr" target="#b0">(1)</ref> The operation ensures that does not forward the same packet more than once, in case it receives it from more than one FN. Note for the source node for all . Since the expected number of times node has to transmit a packet to ensure that its child will receive one packet is , the expected number of transmissions of for child to receive is</p><p>Since packets are broadcast, they can be received by more than one child node at a time. Hence, the expected number of transmissions node has to make to ensure that each child node has one packet is <ref type="bibr" target="#b2">(3)</ref> and are interdependent and can be calculated recursively in operations, i.e., by traversing the FNs in the increasing order of their ETX values from the source. Since the order of FNs is well defined, there are no loops in the credit calculation.</p><p>For each data packet the source sends down the multicast tree (which may require multiple transmissions), FN receives . Thus, the TX credit of node is</p><p>A fundamental difference between the TX credit calculation in MORE and in Pacifier is that the latter decouples the credit calculation from the routing process. Indeed, in Pacifier, we first build a multicast tree and then calculate the TX credits only for those FNs that are part of the tree. In contrast, in MORE, FN selection and TX credit calculation are tighly coupled; TX credits are calculated for the whole network, and then some FNs are pruned based on this calculation. As we will show in Section IV, this decoupling in Pacifier significantly improves the efficiency of both procedures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Source Rate Limiting</head><p>Recent studies have shown the importance of adding rate control to NC-based unicast routing protocols, which exploit MAC-layer broadcast <ref type="bibr" target="#b38">[38]</ref>, <ref type="bibr" target="#b40">[40]</ref>, <ref type="bibr" target="#b42">[42]</ref>, <ref type="bibr" target="#b43">[43]</ref>. However, end-to-end rate control in multicast is much more complex than in unicast, and there is no widely accepted solution so far. In the version of Pacifier presented so far, the use of TX credits implements a form of rate control at which each intermediate FN injects packets into the network. However, the source can potentially send out all the packets in a batch unpaced.</p><p>To add rate control to the source, we exploit the broadcast nature of the wireless medium and apply a simple form of backpressure-based rate limiting, inspired by BMCC <ref type="bibr" target="#b12">[13]</ref>. The basic idea is to have the source wait until it overhears its child nodes forward the previous packet it sent before it transmits the next packet. Since the number of transmissions by the source has already factored in packet losses to its child nodes, the source does not need to worry about losses of individual transmissions, i.e., it does not need to wait until all its child nodes forward each packet it sends out. In fact, it is not even sure that every of its transmissions will trigger a transmission at each of its child nodes, as some nodes may have negative credit counters. Instead, the source waits until it overhears a transmission from any of its child nodes or until a timeout before it sends the next packet in the batch.</p><p>The work in <ref type="bibr" target="#b12">[13]</ref> does not discuss how to set the timeout. In <ref type="bibr" target="#b44">[44]</ref>, the authors suggested a heuristic timeout of for the backpressure-based unicast version of BMCC, where is the transmission time of one data packet, which depends on the packet size and the MAC data rate. The factor of 3 is to account for the contention time preceding each transmission. Following the same reasoning, in Pacifier, we set the timeout to . This choice for the timeout reflects the fact that in Pacifier a transmission from the source will trigger on average transmissions from its child nodes, which in the worst case can be sequential, and also the fact that in multicast contention near the source is in general higher.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Solving the "Crying Baby" Problem</head><p>In MORE, the source keeps transmitting packets from the same batch until all the receivers acknowledge that batch, as shown in Fig. <ref type="figure" target="#fig_0">1(a)</ref>. This policy makes the protocol susceptible to the "crying baby" problem since if the connection to one receiver is poor, that receiver can slow down the rest of the receivers. The basic version of Pacifier we have described so far suffers from the same problem.</p><p>As an example, assume the source multicasts a file consisting of batches to two receivers and . can download a batch (i.e., collect the required number of linearly independent coded packets and decode the batch) in time , and can download a batch in time . With MORE, will remain idle for time after decoding each batch and for a total time of , and both receivers will finally complete the file download in time . We want a solution that would allow the well-connected receiver to complete the download in time and the poorly connected receiver (i.e., the crying baby) in time no more than . Note the problem would not exist if the whole file could be encoded into one batch. However, such an approach is not realistic due to the prohibitively high computational overhead (associated with coding operations), header overhead (from including the random coding coefficients in packet headers), and memory requirement at the intermediate routers. In the following, we describe a practical solution to the problem, which requires no more memory than MORE or our basic version, i.e., FNs still maintain only one batch at a time in their memory.</p><p>In the proposed scheme, the source iteratively sends the batches of a file in a round-robin fashion, for as many rounds as required, until it has received ACKs for all batches from all the receivers, as shown in Fig. <ref type="figure" target="#fig_0">1(b)</ref>. In detail, the source maintains a counter for each batch that is equal to the number of remaining packets the source has to transmit for that batch. The counter for batch is initialized as , where is calculated in (3) and is the batch size, and it is decremented every time a packet from batch is transmitted. Each intermediate FN forwards coded packets according to its TX credit and only buffers packets belonging to the current batch; when it receives the first packet from a new batch, it flushes its buffer and starts buffering packets from the new batch.</p><p>The source determines when to switch to work on the next batch as follows. It sends packets from batch until either: 1) reaches zero; or 2) it receives from one receiver acknowledging completion of this batch; it then moves to the next batch for which there are still receivers that have not acknowledged it. When the source finishes with the last batch , it starts the next round by going back to the first batch for which it has not received ACKs from all receivers. For each such batch it revisits, it recalculates the multicast tree (i.e., the FNs) and the TX credit values for the FNs based on the receivers that have not sent ACKs and resets using the newly calculated . The proposed approach effectively addresses the "crying baby" problem. Back to our example, the source now stays at each batch only for time , i.e., until it receives an ACK from receiver . After a total time of completes the whole file and leaves the multicast tree. The user can now disconnect from the Internet and watch the movie or install the software he/she just downloaded, or join another multicast group and download a different file, or start a new unicast session (e.g., browsing the Web). The source recalculates the multicast tree, keeping only those FNs responsible for , and starts a second round, spending an additional time at each batch. At the end of the second round, also completes the download and the total time for is . In practice, things are a bit more complicated, and the batch switching policy is critical to achieving high throughput for both well-and poorly connected receivers. On one hand, if one receiver has already acknowledged the current batch before the source sends all the scheduled packets for that batch, not moving to the next batch at the source will reduce the throughput of that receiver. On the other hand, after all the scheduled packets have been sent out, allowing the source to move to the next batch only when it receives an ACK from one receiver can be inefficient, as ACKs may delay to reach the source, due to congestion, or because they have to traverse several hops to reach the source. This could result in redundant packet transmissions from the current batch at the source while waiting for an ACK. Instead, immediately moving to the next batch after finishing the scheduled packets ensures that the "network pipe" is always filled with useful packets, and delayed ACKs will have little impact on the performance. Our evaluation in Sections IV-B, V-D shows that switching batch when either of the two conditions is satisfied results in significant throughput improvements over MORE for both well-connected receivers and the worst ones (i.e., the "crying babies"). We note previously that <ref type="bibr" target="#b45">[45]</ref> also noticed that this "stop-and-wait" policy (also used in MORE) can result in significantly low throughput, in the context of unicast, as the network scales.</p><p>A round-robin batching scheme was also used in Fcast <ref type="bibr" target="#b27">[28]</ref>, an FEC-based protocol for the wired Internet. However, there are two major differences between the two protocols. First, the use of NC in Pacifier eliminates duplicate packet transmissions; the source sends different random combinations of the original packets in every round. In contrast, in Fcast, each batch of packets is preencoded to produce a fixed number of packets (typical values for are 32 and 255, respectively). Once the source finishes the transmission of all encoded packets from each of the batches, it starts a new round where it retransmits again the same encoded packets for each batch. Under high packet loss rates, observed in WMNs <ref type="bibr" target="#b18">[19]</ref>, this policy may result in some receivers receiving duplicate packets and may further delay decoding. While rateless codes (e.g., <ref type="bibr" target="#b46">[46]</ref>) can indeed help to avoid duplication as in these codes is not limited, a second difference still remains. In Pacifier, both the source and the FNs perform coding operations, which allows the protocol to exploit the benefits of OR without the burden of coordination overhead. In contrast, in Fcast (even with a rateless code), only the source performs coding operations. This limits the efficiency of OR with Fcast since FNs need a coordination mechanism <ref type="bibr" target="#b3">[4]</ref> to avoid duplicate transmissions.</p><p>1) Adjusting TX credit Calculation: In the basic version of Pacifier (Section III-A.2), we defined the TX credit of an FN as the expected number of packets it has to transmit for every packet it receives from its upstream nodes in order to ensure that all of its child nodes will receive one packet. This definition is consistent with the batch termination scheme of the basic scheme, i.e., the source completes a batch when it receives ACKs from all receivers. However, it is inconsistent with the round-robin batching scheme, which aims to prevent poorly connected receivers from slowing down well-connected receivers. Hence, under the round-robin batching, we adjust the definition of TX credit of an FN to be the expected number of packets it has to transmit for every packet it receives from its upstream nodes in order to ensure that at least one of its child nodes will receive one packet. To realize this change, we simply change the operator to in <ref type="bibr" target="#b2">(3)</ref>. We note this new definition is also consistent with the policy of moving to the next batch whenever any receiver acknowledges the current batch.</p><p>2) Intricacies in TX credit Calculation: There is a subtlety in the above adjustment to the TX credit calculation under the round-robin batching scheme, i.e., changing the operator to in <ref type="bibr" target="#b2">(3)</ref>. The derivation of ( <ref type="formula">3</ref>) is based on expected number of opportunistic packet receptions (based on the ETX measurements). However, in the actual dissemination of any given batch , it is possible that the actual packet reception is below or above the expected value. In the latter case, the best receiver will successfully receive all packets for that batch, and it is the correct thing to do for the source to move on to the next batch. However, in the former case, the best receiver could be a few packets short of receiving the whole batch , and hence if the source moves on to the next batch, even the best receiver has to wait for a whole round before the source transmits again packets from batch . On the other hand, if we had let the source send some additional packets to those predicted by (3), there is a good chance that the best receiver would have finished in the current round; this would increase the throughput of the best receiver. The challenge here is that it is unknown beforehand whether the opportunistic reception in any particular batch is above or below the expectation, and hence those extra packets sent by the source for a batch can potentially elongate each batch and reduce the throughput of the best receiver.</p><p>To facilitate studying the above subtlety in the TX credit calculation under the round-robin batching scheme, we introduce a tunable knob in <ref type="bibr" target="#b2">(3)</ref>. Essentially, we define the expected number of transmissions node makes to its child nodes as . Setting to 1 changes the objective to ensuring all child nodes receive a packet at least once, while setting to 0 changes the objective to ensuring at least one child node receives a packet at least once. In Section IV-B.5, we evaluate the impact of this knob by comparing the performance of Pacifier under different values of .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. SIMULATION STUDIES</head><p>We first evaluate the performance of Pacifier by comparing it against MORE using extensive simulations. The use of a simulator allowed us to evaluate the performance of the two protocols in large networks, using a diverse set of topologies, which are difficult to create in a testbed. We note Pacifier uses the same type of NC and has the same memory requirements and the same fields in the packet header as MORE, 2 and hence it can be easily implemented in practice. We present an implementation study of Pacifier in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Evaluation Methodology</head><p>Simulation Setup: We used the Glomosim simulator <ref type="bibr" target="#b47">[47]</ref>, a widely used wireless network simulator with a detailed and accurate physical signal propagation model. Glomosim simulations take into account the packet header overhead introduced by each layer of the networking stack and also the additional 2 Pacifier only includes the list of FN nodes in the header, sorted in increasing ETX distance from the source. It does not require information about the edges of the tree. overhead introduced by MORE or Pacifier. For the implementation of MORE, we followed the details in <ref type="bibr" target="#b5">[6]</ref>.</p><p>We simulated a network of 50 static nodes placed randomly in a 1000 1000 m area. The average radio propagation range was 250 m, the average sensing range was 460 m, and the channel capacity was 2 Mbps. The TwoRay propagation model was used. To make the simulations realistic, we added fading in our experiments. The Rayleigh model was used, as it is appropriate for WMN environments with many large reflectors, e.g., walls, trees, and buildings, where the sender and the receiver are not in line of sight of each other. Because of fading, the probability for a node to hear/sense another node decreases with the distance and there is no clear cutoff. For example, at a distance of 250 m, the probability of hearing a neighbor node is very low. Although sometimes nodes can hear each other even in distances larger than 250 m, in most cases, link quality is very low for distances larger than 150 m.</p><p>We simulated each protocol on 10 different randomly generated topologies (scenarios), i.e., placement of the 50 nodes. For each scenario, we randomly generated a multicast group consisting of one source and nine receivers. The source sent a 12-MB file, consisting of 1500-B packets, transmitting at the maximum rate allowed by the MAC (in case of MORE) or by the MAC and the backpressure-based rate limiting (in case of Pacifier). We present the result for each scenario and the average result over all 10 scenarios.</p><p>Following the methodology in <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr" target="#b5">[6]</ref>, we implemented an ETX measurement module in Glomosim that was run for 10 min prior to the file transfer for each scenario to compute pairwise delivery probabilities. During these 10 min, each node broadcasts a 1500-B packet every second and keeps track of the packets it receives from its neighbors. At the end of the 10-min duration, all the measurements are distributed to all the nodes. The source uses these measurements to compute the forwarding lists and the transmission credits for the two protocols. There was no overhead due to loss rate measurements during the file transfer.</p><p>Evaluation Metrics: We used the following metrics.</p><p>Average throughput: the file size (in bytes) divided by the total time required for a receiver to collect the necessary number of packets for decoding, averaged over all receivers.</p><p>Total number of data packet transmissions:<ref type="foot" target="#foot_1">3</ref> the total number of data packets broadcast by the source and the FNs.</p><p>Source Redundancy: the total number of encoded data packets sent by the source divided by the file size. It gives an estimate of the redundancy injected in the network by the source. Note that we did not use the PDR as a metric since both protocols guarantee 100% PDR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Simulation Results</head><p>We start by optimizing MORE's pruning strategy as the default strategy appears to cause frequent network partitions. We then proceed to evaluate the incremental performance benefit of Pacifier's major components, i.e., the basic version, adding  1) Fixing More's Pruning Threshold: Recall from Section II-A that MORE prunes FNs that are expected to perform less than 10% of the total number of transmissions. We found using such a pruning threshold can result in disconnection of some receivers. The probability for this to happen naturally increases with the network size since the larger the number of nodes acting as FNs, the smaller the expected number of transmissions each of them has to make. Recall also that in MORE, the source proceeds to the next batch only when all receivers acknowledge the current batch. When a receiver is disconnected, the source will never leave the first batch, and all the receivers will receive zero throughput.</p><p>One solution to the problem is to use a much lower pruning threshold than 0.1. However, using a very low threshold can lead to too many FNs in dense WMNs, which increases the contention for the channel. To be fair in our evaluation and not cause performance degradation for MORE, we used the following approach, which favors MORE, instead of a common threshold for all 10 scenarios: For each scenario, we repeated the simulation for different values of the pruning threshold , starting with the default value of 0.1, and lowering it by 0.01 until no receiver was disconnected. This last value was the one we used for the comparison against Pacifier.</p><p>Fig. <ref type="figure" target="#fig_1">2</ref> shows the number of FNs and the throughput with the default threshold of 0.1 (MORE_orig) and with the best threshold for each scenario (MORE_new) in each of the 10 scenarios. Fig. <ref type="figure" target="#fig_10">2(a)</ref> shows that using the default threshold resulted in a very low number of FNs; on average, only 11.2 FNs were used in a network of 50 nodes. However, this low number of FNs caused disconnection of at least one receiver and resulted in zero throughput in eight out of 10 scenarios, as shown in Fig. <ref type="figure" target="#fig_10">2(b)</ref>. For the 10 scenarios studied, the largest pruning threshold that does not cause any disconnection varies from 0.1 to 0.03.</p><p>In the following, we compare various versions of Pacifier to MORE_new. For simplicity, we will call it MORE.</p><p>2) Impact of Tree-Based OR: We start the evaluation of Pacifier by examining the impact of its tree-based OR by comparing the basic version of Pacifier (TREE) to MORE. The only difference between the protocols is the algorithm used for selecting FNs and assigning TX credits to them. The results for 10 different scenarios are shown in Fig. <ref type="figure" target="#fig_2">3</ref>.</p><p>Fig. <ref type="figure" target="#fig_2">3</ref>(a) shows TREE achieves higher throughput than MORE in eight out of 10 scenarios. The gain ranges from 20% (Scenario 7) up to 199% (Scenario 4), with an average throughput gain over all 10 scenarios equal to 42%. Only in two scenarios (2 and 3), there is a small throughput reduction with TREE, about 16%.</p><p>The higher throughput achieved by TREE compared to MORE can be explained by the fewer FNs and lower total number of transmissions in the former compared to the latter. In particular, Fig. <ref type="figure" target="#fig_2">3(b)</ref> shows that the use of a tree instead of a union of belts results in on average 36% fewer FNs in TREE than in MORE. Note that in some cases, TREE uses equal or even fewer FNs compared to MORE with the default pruning threshold (e.g., in Scenarios 2, 4, and 6). However, the FN selection algorithm ensures that no receiver is disconnected from the source, unlike in MORE, since there is no random, threshold-based pruning. Fig. <ref type="figure" target="#fig_2">3(c)</ref> shows the use of a tree combined with the new algorithm for TX credit calculation results in on average 44% reduction in the total number of transmissions in TREE, compared to MORE. Finally, Fig. <ref type="figure" target="#fig_2">3(d)</ref> shows MORE has a high source redundancy; the source sends on average 17 times the file size. TREE reduces the average source redundancy to 12. The difference in source redundancy suggests TREE is more efficient in selecting FNs and more accurate in calculating the TX credit values for the FNs.</p><p>3) Impact of Source Rate Limiting: We next evaluate the impact of backpressure-based rate limiting at the source, as implemented in the TREE+RL version of Pacifier. Fig. <ref type="figure" target="#fig_3">4(a)</ref> shows that the use of rate limiting at the source improves the throughput by 5% (Scenario 6) to 94% (Scenario 1), with an average of 20%, compared to TREE. Fig. <ref type="figure" target="#fig_3">4(c)</ref> shows that TREE+RL on averages reduces the source redundancy to 5.84, a 52% reduction compared to the value of 12.15 for TREE. The reduction in the source redundancy in turn reduces the total number of transmissions by 28% on average, as shown in Fig. <ref type="figure" target="#fig_3">4(b)</ref>. We found that this reduction comes not only from the contribution of the source, but also from the majority of the FNs. This confirms that by pacing the source's transmissions, the source's children and grandchildren get better chances to successfully transmit packets and make progress down the tree.</p><p>4) Solving the "Crying Baby" Problem: The above results have shown that TREE and TREE+RL already offer significant throughput improvement over MORE. However, these two versions of Pacifier still suffer from the "crying baby" problem. We next evaluate the effectiveness of round-robin batching on solving the "crying baby" problem by comparing TREE+RL+RRB (the complete Pacifier protocol) to TREE+RL.</p><p>Fig. <ref type="figure" target="#fig_4">5</ref> shows the average throughput achieved with TREE+RL+RRB and TREE+RL in each of the 10 scenarios, as well as the throughput of the best and the worst receiver (top and bottom of error bars) in each scenario under TREE+RL+RRB. We make three observations. First, with TREE+RL, which uses sequential batch transmission, all nine receivers in each scenario achieve the same throughput, which is determined by the worst receiver. In contrast, with TREE+RL+RRB, well-connected receivers get much higher throughput than the average, as shown by the large gap between the top of the error bars and the average in most scenarios. Averaging over 10 scenarios, the best receiver achieves 58% higher throughput than the average throughput by all receivers. Second, allowing receivers to proceed independently in TREE+RL+RRB also increases the average throughput by 47% on average over all 10 scenarios, compared to TREE+RL. Third, importantly, the throughput improvement for the best receivers comes at  almost no penalty to the worst receivers. In particular, compared to with TREE+RL, the throughput of the worst receiver with TREE+RL+RRB gets slightly worse in three scenarios (Scenarios 7-9 by 10%, 7%, and 3%, respectively), remains unaffected in two scenarios (Scenarios 2 and 3), and increases by 26%-146% for the remaining five scenarios.</p><p>5) Tuning the knob in TX credit Calculation: Finally, we study the intricacies in calculating TX credit values by varying the value introduced in Section III-C.2. We vary the value of from 0 (the version evaluated in Section IV-B.4) to 1. Intuitively, as increases, the throughput of the best receiver is expected to decrease and the throughput of the worst receiver is expected to increase since we spend more time on each batch in every round. Fig. <ref type="figure" target="#fig_5">6</ref> shows the average, max, and min throughput with Pacifier, as varies from 0 to 1. Every point is the average over 10 scenarios.</p><p>improves the min throughput and maximizes the average, and, somewhat surprisingly, the max throughput as well. On the other hand, achieves the lowest max, average, and min throughput compared to all the other values. This confirms our speculation in Section III-C that setting may not give the best result as the TX credit calculation is fundamentally based on the expected opportunistic receptions, and a lower-than-expected number of receptions in any given batch can cause the best receiver to be a few packets short of decoding a batch and wait for a whole round. In the remainder of this paper, we use . 6) Overall Comparison: Fig. <ref type="figure" target="#fig_6">7</ref>(a) summarizes the average, maximum, and minimum throughput comparison among MORE, TREE, TREE+RL, and TREE+RL+RRB (Pacifier), where TREE+RL+RRB used a value of 1. We observe that, on average, Pacifier outperforms TREE+RL, TREE, and MORE by 60%, 90%, and 171%, respectively. In addition, Pacifier allows well-connected receivers to achieve much higher throughput, which can be up to 20 higher than with MORE (for scenario 1), and also improves throughput of the worst receiver in all 10 scenarios, compared to the other three protocols.</p><p>Fig. <ref type="figure" target="#fig_6">7</ref>(b) depicts the same results in a different way. It plots the cumulative distribution function (CDF) of the 90 throughput values obtained from 10 scenarios with nine receivers each, for the four protocols. In this figure, the CDFs for MORE, TREE, and TREE+RL have a staircase form since, for each scenario, all nine receivers get roughly the same throughput (equal to that of the worst receiver) due to the "crying baby" problem. In contrast, with Pacifier, receivers finish independently of each other and the CDF has a continuous form. In the median case, Pacifier outperforms TREE+RL, TREE, and MORE by 20%, 49%, and 178%, respectively.</p><p>The benefit of Pacifier becomes more prominent if we look at the two ends of the CDF. Pacifier solves the "crying baby" problem by allowing good receivers to achieve very high throughput. The 90th percentile is 223 kb/s for Pacifier, 70% higher than with TREE+RL, 77% higher than with TREE, and 159% higher than with MORE. If we look at the 10th percentile, i.e., the worst receivers, we observe that Pacifier outperforms TREE+RL, TREE, and MORE by 80%, 300%, and 450%, respectively. This shows again that Pacifier not only solves the "crying baby" problem-it also simultaneously offers a significant improvement to the performance of the "crying baby" itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PROTOCOL IMPLEMENTATION AND TESTBED EVALUATION</head><p>In this section, we describe an implementation of Pacifier on a WMN testbed and present experimental results comparing Pacifier and MORE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Testbed Description</head><p>Our testbed, Mesh@Purdue (MAP) <ref type="bibr" target="#b48">[48]</ref>, currently consists of 22 mesh routers (small form factor desktops) deployed on two floors of two academic buildings on the Purdue University campus. Each router has an Atheros 5212-based 802.11a/b/g wireless radio operating in b ad hoc mode and attached to a 2-dBi rubber duck omnidirectional antenna with a low-loss pigtail. Each mesh router runs Mandrake Linux 10.1 (kernel 2.6. <ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref>, and the open-source madwifi driver [49] is used to enable the wireless cards. IP addresses are statically assigned. The testbed deployment environment is not wireless-friendly, having floor-to-ceiling office walls, as well as laboratories with structures that limit the propagation of wireless signals and create multipath fading.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Implementation Details</head><p>NC-based wireless protocols (e.g., <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr" target="#b6">[7]</ref>) are typically implemented as a shim between the IP and the MAC layer, i.e., at layer 2.5. Here, for ease of debugging, deployment, and evaluation, we implemented Pacifier at the application layer, using broadcast sockets, on Mandrake Linux 10.1 (kernel 2.6.8-12). For a fair comparison, we also implemented MORE at the application layer, following all the details in <ref type="bibr" target="#b5">[6]</ref>. <ref type="foot" target="#foot_2">4</ref> Although such an implementation unavoidably results in some performance degradation, compared to an implementation closer to the MAC layer, from crossing the kernel-user boundary, we note that this degradation is expected to be similar for both protocols since they use the same type of network coding and have the same memory requirements at the routers and the same header fields.</p><p>Our implementation handles only synthetic traffic, i.e., data packets are generated within the MORE or Pacifier application, similarly as the implementation in <ref type="bibr" target="#b49">[50]</ref>, in which packets are generated within Click. The layer-2.5 header of MORE or Pacifier is part of the application-layer packet payload. The source initially generates random payloads for the current batch and mixes them every time it wants to transmit a packet. It then appends the MORE or Pacifier header and delivers the resulting packet to the IP layer, which in turn delivers the packet to the MAC for transmission. Packets are broadcast at the MAC layer, and every neighbor node can hear them. When a node receives a packet, it extracts and processes the protocol-specific header from the payload; if the node is an FN (i.e., it finds its ID <ref type="foot" target="#foot_3">5</ref>in the FN list in the header), it also uses the coding coefficients (also included in the header) to check for linear independence. If the received packet is innovative, the rest of the payload is stored for future mixing (if the node is an FN) or for decoding (if the node is a multicast receiver).</p><p>1) Dealing With Queue Sizes: In an ideal implementation at layer 2.5, a node running either MORE or Pacifier transmits a packet when: 1) the 802.11 MAC allows; and 2) the credit counter is positive. A layer-2.5 implementation <ref type="bibr" target="#b5">[6]</ref> does not queue packets in the wireless card. Instead, innovative packets for the current batch are stored at a buffer. A precoded packet is always available awaiting for transmission. If another innovative packet is received before the precoded packet is transmitted, the precoded packet is updated by multiplying the newly received packet with a random number and adding it to the precoded packet. This approach ensures that every transmitted packet includes information from all the received innovative packets, including the most recent ones.</p><p>In our application layer implementation, we cannot get any feedback from the MAC, and hence we have no control over the time a packet is transmitted. Instead, the application delivers packets to the IP when only the second condition holds and there is enough space in the socket buffer; from the IP layer, the packets are delivered to the wireless driver stored at the card's queue for transmission at a later time.</p><p>Since we have no control over a packet, once it leaves the application layer, we cannot update the packets buffered at the socket buffer or awaiting for transmission at the card's queue if a new innovative packet is received. This inefficiency can have a significant impact on the performance of the two protocols. If a packet is queued either at the IP or at the MAC layer for a long time, it may not contain information from all the received packets so far. Even worse, the downstream nodes may have already received enough packets from the current batch, in which case the enqueued packets should not be transmitted at all. This is true in particular at the source, which may create packets at a rate faster than the (actual) MAC's transmission rate. To avoid this problem with application-level implementation, we limit the socket buffer size to one packet and the card's queue length to three packets, so as to limit the time from the moment a packet is created at the application layer until the moment the packet is actually transmitted.</p><p>2) Dealing With End-to-End ACKs: In both protocols, a multicast receiver sends an end-to-end ACK back to the source every time it decodes a batch. It is critical for the performance of the protocols that these ACKs are propagated to the source in a fast and reliable way. In particular in MORE, loss of an ACK breaks the operation of the protocol since the source only moves to the next batch when all receivers acknowledge the current batch. Similarly, delayed ACKs cause throughput degradation since the source again cannot quickly move to the next batch. In Pacifier, the first problem does not exist since even if no ACK is received for batch , the source will eventually move to the next batch when the counter reaches zero (Section III-C). However, delayed or lost ACKs can again significantly affect performance if the source unnecessarily spends time on batches that have already been decoded by all the receivers.</p><p>ACK Reliability: To provide reliability, the ACKs in MORE are unicast at the MAC layer. In contrast to 802.11 broadcast mode, 802.11 unicast mode provides a reliability mechanism through acknowledgments and retransmissions. Unfortunately, there is an upper limit to the number of times a packet can be retransmitted at the MAC layer. For our Atheros wireless cards, this limit is 11. In our experiments, we found that 11 retransmissions were not always enough to deliver the packet to the next hop (especially under heavy traffic). Since this particular card does not allow changing this limit through iwconfig, we had to implement a simple but efficient reliability scheme at the application layer. In our scheme, every node maintains an ACK cache, where it caches every ACK it transmitted, along with some metadata (the next hop of the path toward the source, the multicast group, the batch acknowledged by the ACK, and its status-"ACKed" or "not ACKed"). Nodes also remember the last ACK they forwarded for each multicast group. Every time a node transmits a data packet, it piggybacks information about the last ACK it received. This serves as an acknowledgment for the ACK to the ACK's previous hop. When the previous hop overhears a data packet acknowledging the ACK, it marks it as "ACKed" in the ACK cache. A node retransmits an ACK when: 1) it overhears packets from the ACK's next hop that do not acknowledge the ACK; or 2) it overhears packets from any node other than the ACK's next hop. We experimented with different values of and and finally selected . Fast ACK Propagation: Similarly as in <ref type="bibr" target="#b5">[6]</ref>, ACKs are sent to the source over the shortest ETX path to ensure quick propagation. Moreover, in <ref type="bibr" target="#b5">[6]</ref>, ACKs are prioritized over data transmissions. In addition to ensuring fast ACK propagation, prioritizing ACKs over data packets is critical in our application layer implementation for one more reason. Since we have no control over a packet once it leaves the application layer, we have to guarantee that an ACK packet will never be dropped if the card's queue is full of data packets.</p><p>To implement ACK priority over data packets in our application layer implementation, we leveraged the TOS bits ("TOS field") of the IP header, which can be set using setsockopt at the application layer, and the priority properties in Linux routing <ref type="bibr" target="#b50">[51]</ref>. The basic queuing discipline in Linux, pfifo_fast, is a three-band first-in-first-out queue. Packets are enqueued in the three bands based on their TOS bits. We set the TOS bits of the ACKs to 1010, which corresponds to "minimum delay maximum reliability" (or "mr md") and enqueues the ACKs in the highest priority band.</p><p>In addition to the two protocols, we also implemented an ETX measurement module, the same as the one we used in our simulations (described in Section IV-A). The source code for the two protocols and the ETX module together is over 9000 lines of C code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Experimental Setup</head><p>In the implementation of the two protocols, we used the same parameters as in our simulation study in Section IV. In all the experiments, the bit rate of the wireless cards was set to 2 Mbps and the transmission power to 16 dBm. We disabled RTS/CTS for unicast frames as most operational networks do. With these settings, the length of the shortest-ETX paths between different nodes is 1-6 hops in length, and the loss rates of the links vary from 0% to 88%, with an average value of 29%.</p><p>We ran each protocol on 10 different scenarios (i.e., selection of source and multicast group members). In each scenario, one source and four receivers were randomly selected among the 22 nodes of our testbed. In each scenario, we first ran the ETX module for 10 min to collect the pairwise loss rates and ETX metric for each link of our testbed, and then we ran the two protocols, MORE and Pacifier, in sequence. With both protocols, the source sent a 2.3-MB file consisting of 1460-B packets. Since the quality of some links of our testbed varies substantially from day to day in a week, we repeated the experiments for the same 10 scenarios on four different days (one weekend and two weekdays). Due to space limitation, we present the results for the first and the fourth day (the results for the other two days were similar). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Experimental Results</head><p>Fig. <ref type="figure" target="#fig_7">8</ref> Similar to the simulation results, we observe that Pacifier outperforms MORE in nine out of 10 scenarios on both days. The average throughput improvement over all 10 scenarios ranges between 83% (for Day 4) and 144% (for Day 1). This is somewhat lower than the corresponding simulation result [171% in Fig. <ref type="figure" target="#fig_6">7(a)</ref>]. The reason is that the size of our testbed is much smaller than the simulated networks, and hence path diversity is not as large, and the "crying baby" problem is not as severe, as in the simulations.</p><p>We observe again that Pacifier solves the "crying baby" problem, allowing well-connected receivers in each case to achieve throughputs much higher than the average value, while also improving throughput of the worst receivers in almost all scenarios. Averaging over 10 scenarios for each day, the throughput of the best receiver with Pacifier is 244% and 259% higher than with MORE, but in some cases, it can be much higher, e.g., more than 8 in Scenario 8, Day 4, and more than 14.4 in Scenario 7, Day 1. Similarly, the average (over 10 scenarios) throughput of the worst receiver with Pacifier is on 83% and 53% higher than with MORE on each day, and the maximum improvement can be as high as 5.4 (higher than in the simulation results) in Scenario 7, Day 1.</p><p>Fig. <ref type="figure" target="#fig_9">9</ref>(a) and (b) plots the CDF of the 40 throughput values obtained from the 10 scenarios with four receivers each, for the two protocols, on each of the two days. Similar to Fig. <ref type="figure" target="#fig_6">7(b</ref>) for the simulation results, we observe that the CDFs for MORE exhibit a staircase form. In contrast, with Pacifier, receivers finish independently of each other, and the CDF always has a continuous form. Pacifier outperforms MORE on both days both in the median case, by 158%-286%, and in the two ends of the CDFs-the 90th percentile is 85%-128% higher and the 10th percentile is 128%-294% higher with Pacifier than with MORE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. SCOPE OF OUR WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. On the Choice of Transmission Rates</head><p>In both our simulation and our testbed evaluation, we used a low fixed MAC transmission rate of 2 Mbps and disabled the rate adaptation mechanism of 802.11 for the following two technical reasons. 1) Implementation-related reasons: NC protocols are currently implemented as user-level programs, and they cannot work with high data rates. The pioneering COPE <ref type="bibr" target="#b4">[5]</ref> and MORE <ref type="bibr" target="#b5">[6]</ref> protocols, implemented using the Click software router <ref type="bibr" target="#b51">[52]</ref>, were evaluated using 6 and 5.5 Mbps, respectively. In the publicly available implementation of MORE <ref type="bibr" target="#b49">[50]</ref>, it is stated that "it is highly recommended that no bit-rates faster than 6 Mbps are used for comparison." Our implementation at the application layer posed even greater challenges with respect to timing constraints, and we had to limit our testing to the bit rate of 2 Mbps. Note that the second generation of NC/OR protocols exploiting PHY-MAC cross-layer interactions have been evaluated using even lower bit rates (a few hundreds of kilobits per second) due to hardware constraints (e.g., <ref type="bibr" target="#b52">[53]</ref>). problem due to the speed versus range tradeoff (a higher bit rate may reduce the number of neighboring nodes being able to overhear a transmission, limiting the gain from OR). Preliminary efforts to integrate MORE with an offline rate selection algorithm have not produced satisfactory results <ref type="bibr" target="#b53">[54]</ref>. The lack of an appropriate rate adaptation algorithm for broadcast has led many researchers to use a low fixed bit rate even in simulation studies of NC/OR protocols in order to exploit the WMA <ref type="bibr" target="#b7">[8]</ref> (e.g., the very recent works <ref type="bibr" target="#b54">[55]</ref> and <ref type="bibr" target="#b55">[56]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. On Link-Loss Rate Measurement</head><p>In our evaluation of Pacifier and MORE, we followed the evaluation methodology of all state-of-the-art OR/NC protocols (e.g., <ref type="bibr" target="#b3">[4]</ref>- <ref type="bibr" target="#b5">[6]</ref>) and measured the link loss rates only once, prior to each experiment. In practice, a link-state mechanism should be used to ensure that nodes periodically broadcast probes to their neighbors and the estimated loss rates are periodically but less frequently distributed to all the nodes. As <ref type="bibr" target="#b5">[6]</ref> argues, such a link-state mechanism is required in all state-of-the-art routing protocols, and the overhead this process incurs is not considered Pacifier-specific.</p><p>The use of stale loss measurements can affect two features of OR/NC protocols: topology control (i.e., the choice of FNs) and credit calculation. As pointed out in <ref type="bibr" target="#b3">[4]</ref>, the impact on the former is not significant. The performance of OR protocols is relatively insensitive to suboptimal choice of FNs since a packet's actual path is determined by conditions at the time of transmission. This is the main benefit of OR. <ref type="foot" target="#foot_4">6</ref> However, the impact on the latter may be more serious since inaccurate credit calculation may result in a large number of redundant transmissions leading to congestion. Addressing this problem, which can affect all OR/NC protocols, is not trivial and is out of scope of this paper. In our recent work <ref type="bibr" target="#b56">[57]</ref>, we proposed a solution for unicast OR/NC protocols, which decouples credit calculation from loss rate measurements. We plan to extend this solution to multicast in our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Generality of Our Results</head><p>The above limitations that prevent the use of higher data rates in the evaluation of NC-based OR protocols should not limit by any means the scope of our work and the generality of our results to the low-rate 802.11b. On the contrary, the significance of our work will only be more pronounced when considering future high-rate technologies (with fixed or varying rates). A core contribution of our work is to solve the classic "crying baby" problem in the new context of reliable multicast to a set of heterogeneous receivers in WMNs. As we move toward novel 802.11 technologies offering a larger selection of data rates (up to 54 Mbps for 802.11a/g, and up to 600 Mbps for 802.11n), receiver heterogeneity will only increase, making the "crying baby" problem even more prominent and the need for our solution even greater.</p><p>Imagine an example scenario in an 802.11n network with two receivers: Receiver is directly connected to the multicast source over a 600-Mbps link, while receiver is connected to the source over a three-hop path including one poor link of 26 Mbps. Even though the throughput of is already much higher than the throughput achieved in an 802.11b network, there is no reason to limit 's throughput to 's level. Doing so would significantly underutilize the network and does not exploit the maximum benefits possible from the advanced PHY layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>High-throughput, reliable multicast routing has many important applications in WMNs, such as software updates and video/audio file downloads. However, designing high-throughput, reliable multicast protocols faces two challenges: the inherent lossiness of wireless links and the "crying baby" problem. In this paper, we presented Pacifier, the first practical NC-based high-throughput, reliable multicast protocol for WMNs. Pacifier seamlessly integrates tree-based OR, intraflow NC, source rate limiting, and round-robin batching to achieve high throughput and solve the "crying baby" problem.</p><p>Our performance evaluation of Pacifier via extensive simulations and an implementation on a WMN testbed have shown Pacifier significantly outperforms the state-of-the-art MORE for various multicast scenarios. In particular, the experimental results on our 22-node WMN testbed show that Pacifier increases the average multicast throughput over MORE by 83%-114%, while the maximum throughput gain for well-connected receivers is as high as 14 , and the maximum throughput gain for the "crying baby" itself is as high as 5.4 , compared to MORE.</p><p>Since the cumulative path loss rate in wireless multihop networks increases with the path length, multicast receiver heterogeneity is unavoidable in WMNs. In fact, the degree of heterogeneity is expected to increase as future WMNs scale in size. Our experience with designing Pacifier shows the importance of exploiting heterogeneity, rather than ignoring it. By treating heterogeneous receivers equally, MORE penalizes well-connected receivers, forcing them to achieve the same throughput as the worst receiver. In contrast, by exploiting heterogeneity and prioritizing well-connected receivers over the "crying babies," Pacifier manages to achieve several-fold throughput improvement for well-connected receivers, without penalizing the poorly connected ones; on the contrary, it often drastically improves throughput of the worst receivers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Two different ways of transmitting batches of original packets each: sequential (as in MORE) and round-robin (as in Pacifier). For better visualization, we assume here (not true in the actual operations of the protocols) that the same total amount of redundancy is required to be sent for each batch. (a) Sequential batch transmission in MORE. Each batch is acknowledged by all the receivers before the source moves to the next batch. (b) Round-robin batch transmission in Pacifier. The source moves to the next batch every time one receiver acknowledges the current batch.</figDesc><graphic coords="5,304.98,64.14,246.00,84.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Number of FNs and throughput with default pruning threshold (MORE orig) and the largest pruning threshold that does not cause any disconnection (MORE new), for 10 different scenarios. For MORE new, the labels above the bars show the pruning threshold used for each scenario. (a) Number of FNs. (b)Throughput.</figDesc><graphic coords="8,42.00,65.10,246.00,94.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Throughput, number of FNs, total number of transmissions, and source redundancy with MORE and TREE for 10 different scenarios. (a) Throughput. (b) Number of FNs. (c) Total number of transmissions. (d) Source redundancy.</figDesc><graphic coords="8,306.00,64.14,246.00,204.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Throughput, total number of transmissions, and source redundancy with MORE and TREE+RL for 10 different scenarios. (a) Throughput. (b) Total number of transmissions. (c) Source redundancy.</figDesc><graphic coords="9,40.98,64.14,246.00,192.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Throughput with TREE+RL and TREE+RL+RRB (Pacifier) for 10 different scenarios. The error bars show throughput of the best and the worst receiver.</figDesc><graphic coords="9,304.98,64.14,246.00,189.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Average throughput with Pacifier as a function of , over 10 scenarios. The error bars show average max and min values over the 10 scenarios.</figDesc><graphic coords="9,304.98,304.14,246.00,183.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Overall throughput comparison of MORE, TREE, TREE+RL, and TREE+RL+RRB (Pacifier). (a) Average, max, and min throughput with each protocol for each of the 10 scenarios. (b) CDF of the 90 throughput measurements obtained with each protocol for 10 scenarios with nine receivers each.</figDesc><graphic coords="10,42.00,63.12,246.00,94.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Testbed throughput comparison of MORE and Pacifier in 10 different scenarios on two different days. (a) Day 1. (b) Day 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Fig. 8(a) and (b) shows the average throughput achieved with MORE and Pacifier in each of the 10 scenarios, as well as the throughput of the best and the worst receiver (top and bottom of error bars) in each scenario, on two different days.Similar to the simulation results, we observe that Pacifier outperforms MORE in nine out of 10 scenarios on both days. The average throughput improvement over all 10 scenarios ranges between 83% (for Day 4) and 144% (for Day 1). This is somewhat lower than the corresponding simulation result [171% in Fig.7(a)]. The reason is that the size of our testbed is much smaller than the simulated networks, and hence path diversity is not as large, and the "crying baby" problem is not as severe, as in the simulations.We observe again that Pacifier solves the "crying baby" problem, allowing well-connected receivers in each case to achieve throughputs much higher than the average value, while also improving throughput of the worst receivers in almost all scenarios. Averaging over 10 scenarios for each day, the throughput of the best receiver with Pacifier is 244% and 259% higher than with MORE, but in some cases, it can be much higher, e.g., more than 8 in Scenario 8, Day 4, and more than 14.4 in Scenario 7, Day 1. Similarly, the average (over 10 scenarios) throughput of the worst receiver with Pacifier is on 83% and 53% higher than with MORE on each day, and the maximum improvement can be as high as 5.4 (higher than in the simulation results) in Scenario 7, Day 1.Fig.9(a) and (b) plots the CDF of the 40 throughput values obtained from the 10 scenarios with four receivers each, for the two protocols, on each of the two days. Similar to Fig.7(b) for the simulation results, we observe that the CDFs for MORE exhibit a staircase form. In contrast, with Pacifier, receivers finish independently of each other, and the CDF always has a continuous form. Pacifier outperforms MORE on both days both in the median case, by 158%-286%, and in the two ends of the CDFs-the 90th percentile is 85%-128% higher and the 10th percentile is 128%-294% higher with Pacifier than with MORE.</figDesc><graphic coords="12,42.00,63.12,246.00,106.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. CDFs of 40 testbed throughput measurements obtained with MORE and Pacifier for 10 scenarios with four receivers each on two different days. (a) Day 1. (b) Day 4.</figDesc><graphic coords="12,306.00,64.14,246.00,105.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>2 )</head><label>2</label><figDesc>Reasons related to the 802.11 standard: NC protocols are built on top of 802.11 broadcast; in contrast to unicast, 802.11 broadcast uses no rate adaptation. Integrating rate adaptation with broadcast is by itself a very interesting and, at the same time, extremely challenging open research</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>We present extensive simulations with a realistic physical model showing that Pacifier offers significant throughput improvements over the state-of-the-art MORE and, unlike MORE, it solves the "crying baby" problem. Starting with a basic version of Pacifier and adding one building block at a time, we show the additional benefits of each building block. • We present an application-layer implementation of Pacifier and MORE and their evaluation on a 22-node 802.11 WMN testbed deployed in two academic buildings on the Purdue University campus. Our testbed experiments confirm the simulation findings. • To facilitate further research of this subject, we have made the source code of our implementation publicly available at https://engineering.purdue.edu/MESH/pacifier/. The software has been downloaded by over 20 research groups from six countries since September 2009.</figDesc><table><row><cell>• We propose Pacifier, the first practical multicast pro-</cell></row><row><cell>tocol that simultaneously addresses both challenges: It</cell></row><row><cell>guarantees 100% PDR for all multicast receivers while</cell></row><row><cell>simultaneously solving the "crying baby" problem by</cell></row><row><cell>offering significant throughput improvements for both</cell></row><row><cell>well-connected and poorly connected receivers over a</cell></row><row><cell>state-of-the-art protocol.</cell></row><row><cell>• We present the design of Pacifier, which seamlessly in-</cell></row></table><note><p><p>tegrates four building blocks-namely, tree-based OR, intraflow NC, source rate limiting, and round-robin batching. While the design of Pacifier is based on the numerous principles and techniques developed over the past 15 years in the field of reliable multicast, the novelty of Pacifier is in the use of NC to gracefully integrate all four building blocks to develop a full-fledged multicast protocol.</p>•</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I VERSIONS</head><label>I</label><figDesc>OF MORE AND Pacifier EVALUATED IN OUR STUDY. ALL VERSIONS INCLUDE INTRAFLOW NC</figDesc><table /><note><p>source rate limiting and adding round-robin batching. Table I summarizes the different versions of MORE and Pacifier evaluated.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In contrast, MORE's credit calculation was based on the ordering of FNs according to their ETX distance to the destination node. It is unclear that nodes with larger ETX distance to the destination will receive the packet from the root sooner.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The number of control packets (ACKs) is the same for both MORE and Pacifier, equal to, where is the number of receivers and is the number of batches the file is broken into.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>The publicly available implementation of MORE<ref type="bibr" target="#b49">[50]</ref> using the Click modular router from the authors of<ref type="bibr" target="#b5">[6]</ref> currently supports only unicast.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p><ref type="bibr" target="#b4">5</ref> To reduce the header overhead, we used 1-B IDs instead of 4-B IP addresses.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>In contrast, in single-path routing, suboptimal choice of FNs may even result in a broken path.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by the NSF under Grants CNS-0626703 and CCF-0845968. Chih-Chun Wang (M'05) received the B.E. degree from National Taiwan University, Taiwan, in 1999, and the M.S. and Ph.D. degrees in electrical engineering from Princeton University, Princeton, NJ, in 2002 and 2005, respectively. He joined the School of Electrical and Computer Engineering, Purdue University, West Lafayette, IN, in 2006 as an Assistant Professor. His current research interests are in the graph-theoretic and algorithmic analysis of iterative decoding and of network coding. His other research interests fall in the general areas of optimal control, information theory, detection theory, coding theory, iterative decoding algorithms, and network coding. Dr. Wang received the NSF CAREER Award in 2009.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">"</forename><surname>Mit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roofnet</forename></persName>
		</author>
		<ptr target="http://www.pdos.lcs.mit.edu/roofnet" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Seattle Wireless</title>
		<ptr target="http://www.seattlewireless.net" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Technology for All (TFA)</title>
		<ptr target="http://tfa.rice.edu" />
		<imprint>
			<pubPlace>Houston, TX</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Rice University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">ExOR: Opportunistic multi-hop routing for wireless networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Biswas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="133" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">XORs in the air: Practical wireless network coding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Medard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2006-08">Aug. 2006</date>
			<biblScope unit="page" from="243" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Trading structure for randomness in wireless opportunistic routing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chachulski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jennings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-COMM</title>
		<meeting>ACM SIG-COMM</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Embracing wireless interference: Analog network coding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gollakota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="397" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Minimum-energy broadcast in all-wireless networks: NP-completeness and distribution</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cagalj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Hubaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Enz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiCom</title>
		<meeting>ACM MobiCom</meeting>
		<imprint>
			<date type="published" when="2002-09">Sep. 2002</date>
			<biblScope unit="page" from="172" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dircast: A practical and efficient Wi-Fi multicast system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Karanth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moscibroda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Navda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ravindranath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ICNP</title>
		<meeting>IEEE ICNP</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="161" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Scalable WiFi media delivery through adaptive broadcasts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Madabhushi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX NSDI</title>
		<meeting>USENIX NSDI</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Anonymous gossip: Improving multicast reliability in mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ramasubramaniam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Birman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDSC</title>
		<meeting>ICDSC</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="275" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Route driven gossip: Probabilistic reliable multicast in ad hoc networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Hubaux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="2229" to="2239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Backpressure multicast congestion control in mobile ad-hoc networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Scheuermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Transier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L M</forename><surname>Mauve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Effelsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CoNEXT</title>
		<meeting>CoNEXT</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Codecast: A network-coding-based ad hoc multicast protocol</title>
		<author>
			<persName><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Lun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Medard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Wireless Commun</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="76" to="81" />
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A reliable, congestion-controlled multicast transport protocol in multimedia multi-hop networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Obraczka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WPMC</title>
		<meeting>WPMC</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="252" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Reliable broadcast in mobile multihop packet networks</title>
		<author>
			<persName><forename type="first">E</forename><surname>Pagani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiCom</title>
		<meeting>ACM MobiCom</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="34" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">ReMHoc: A reliable multicast protocol for wireless mobile multihop ad hoc networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sobeih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Baraka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fahmy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE CCNC</title>
		<meeting>IEEE CCNC</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="146" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Combining source-and localized recovery to achieve reliable multicast in multi-hop ad hoc networks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Obraczka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Netw</title>
		<meeting>Netw</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="112" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The case for FEC-based reliable multicast in wireless mesh networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Koutsonikolas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DSN</title>
		<meeting>DSN</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="491" to="501" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">RMDP: An FEC-based reliable multicast protocol for wireless environments</title>
		<author>
			<persName><forename type="first">L</forename><surname>Rizzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Visicano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="23" to="31" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>Mobile Comput</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient operation of wireless packet networks using network coding</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Medard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koetter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IWCT</title>
		<meeting>IWCT</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Invited paper</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Reliability gain of network coding in lossy wireless networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ghaderi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="2171" to="2179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Log-based receiver-reliable multicast for distributed interactive simulation</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Holbrook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Singhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="328" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Link-level measurements from an 802.11b mesh network</title>
		<author>
			<persName><forename type="first">D</forename><surname>Aguayo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bicket</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Biswas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Judd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-COMM</title>
		<meeting>ACM SIG-COMM</meeting>
		<imprint>
			<date type="published" when="2004-08">Aug. 2004</date>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A reliable multicast framework for light-weight sessions and application level framing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="784" to="803" />
			<date type="published" when="1997-12">Dec. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Effective erasure codes for reliable computer communication protocols</title>
		<author>
			<persName><forename type="first">L</forename><surname>Rizzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="24" to="36" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Parity-based loss recovery for reliable multicast transmission</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nonnenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Biersack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="289" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Using multicast FEC to solve the midnight madness problem</title>
		<author>
			<persName><forename type="first">E</forename><surname>Schooler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gemmel</surname></persName>
		</author>
		<idno>MSR-TR-97-25</idno>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">LT codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 43rd FoCS</title>
		<meeting>43rd FoCS</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="271" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Rateless codes and big downloads</title>
		<author>
			<persName><forename type="first">P</forename><surname>Maymounkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazieres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IPTPS</title>
		<meeting>IPTPS</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="247" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Raptor codes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shokrollahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ISIT</title>
		<meeting>IEEE ISIT</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page">36</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Rateless Slepian-Wolf codes</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Eckford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Asilomar Conf. Signals, Syst. Comput</title>
		<imprint>
			<biblScope unit="page" from="1757" to="1761" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">A survey of reliable broadcast protocols for mobile ad-hoc networks</title>
		<author>
			<persName><forename type="first">E</forename><surname>Vollset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ezhilchelvan</surname></persName>
		</author>
		<idno>CS-TR-792</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>University of Newcastle Upon Tyne, Tyne and Wear, U.K., Tech. Rep</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">An adaptive protocol for reliable multicast in mobile multi-hop radio networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Srimani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="111" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A reliable multicast algorithm for mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gopalsamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Singhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sadayappan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDCS</title>
		<meeting>ICDCS</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="563" to="570" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Reliable adaptive lightweight multicast protocol</title>
		<author>
			<persName><forename type="first">K</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Obraczka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ICC</title>
		<meeting>IEEE ICC</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1054" to="1058" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A highthroughput path metric for multi-hop wireless routing</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S J</forename><surname>De Couto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Aguayo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Bicket</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiCom</title>
		<meeting>ACM MobiCom</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="134" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Simple opportunistic routing protocol for wireless mesh networks</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rozner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WiMesh</title>
		<meeting>WiMesh</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="48" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">On-demand multicast routing protocol</title>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE WCNC</title>
		<meeting>IEEE WCNC</meeting>
		<imprint>
			<date type="published" when="1999-09">Sep. 1999</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1298" to="1302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Multipath code casting for wireless mesh networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gkantsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Key</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Radunovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gheorghiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rodriguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM CoNEXT</title>
		<meeting>ACM CoNEXT</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Measurement-based models of delivery and interference in static wireless networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Reis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zahorjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="51" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Effects of interference on throughput of wireless mesh networks: Pathologies and a preliminary solution</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rozner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotNets-VI</title>
		<meeting>HotNets-VI</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">How to evaluate exotic wireless routing protocols?</title>
		<author>
			<persName><forename type="first">D</forename><surname>Koutsonikolas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Papagiannaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM HotNets-VII</title>
		<meeting>ACM HotNets-VII</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Implicit hop-by-hop congestion control in wireless multihop networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Scheuermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lochert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mauve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ad Hoc Netw</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="260" to="286" />
			<date type="published" when="2008-04">Apr. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">CodeOR: Opportunistic routing in wireless mesh networks with segmented network coding</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ICNP</title>
		<meeting>IEEE ICNP</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">A digital fountain approach to asynchronous reliable multicast</title>
		<author>
			<persName><forename type="first">J</forename><surname>Byers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Sel. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1528" to="1540" />
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Glomosim: A library for parallel simulation of large-scale wireless networks</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bagrodia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PADS Workshop</title>
		<meeting>PADS Workshop</meeting>
		<imprint>
			<date type="published" when="1998-05">May 1998</date>
			<biblScope unit="page" from="154" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Purdue University wireless mesh network testbed</title>
		<ptr target="http://www.engineering.purdue.edu/mesh" />
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>West Lafayette, IN</pubPlace>
		</imprint>
	</monogr>
	<note>Purdue University</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">MORE source code</title>
		<ptr target="http://people.csail.mit.edu/szym/more" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Linux advanced routing and traffic control</title>
		<ptr target="http://lartc.org" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The Click modular router</title>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jannoti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SOSP</title>
		<meeting>ACM SOSP</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="217" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Symbol-level network coding for wireless mesh networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Medard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-COMM</title>
		<meeting>ACM SIG-COMM</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="401" to="412" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">The importance of being overheard: Throughput gains in wireless mesh networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Afanasyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Snoeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM/USENIX IMC</title>
		<meeting>ACM SIGCOMM/USENIX IMC</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="384" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Model-driven optimization of opportunistic routing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rozner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMETRICS</title>
		<meeting>ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="269" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Optimized overlaybased opportunistic routing</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bhartia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rozner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiHoc</title>
		<meeting>ACM MobiHoc</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Efficient network coding based opportunistic routing through cumulative coded acknowledgments</title>
		<author>
			<persName><forename type="first">D</forename><surname>Koutsonikolas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1368" to="1381" />
			<date type="published" when="2011-10">Oct. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">He is currently an Assistant Professor of Computer Science and Engineering with the University at Buffalo, the State University of New York, Buffalo, NY. His research interests are broadly on experimental wireless networking and mobile computing</title>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Koutsonikolas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Charlie Hu (S&apos;90-M&apos;93-SM&apos;07) received the Ph.D. degree in computer science from Harvard University</title>
		<meeting><address><addrLine>West Lafayette, IN; Cambridge, MA; West Lafayette; Houston, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">2010. 1997. 1997. 2001</date>
		</imprint>
		<respStmt>
			<orgName>Purdue University ; Research Scientist with Rice University</orgName>
		</respStmt>
	</monogr>
	<note>He has published over 130 papers in the areas of operating systems, distributed systems, Internet measurement and routing analysis, and wireless networking. Dr. Hu is an ACM distinguished scientist. He received the NSF CAREER Award in 2003</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
