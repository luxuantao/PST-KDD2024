<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A NATURAL AXIOMATIZATION OF COMPUTABILITY AND PROOF OF CHURCH&apos;S THESIS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nachum</forename><surname>Dershowitz</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yuri</forename><surname>Gurevich</surname></persName>
						</author>
						<title level="a" type="main">A NATURAL AXIOMATIZATION OF COMPUTABILITY AND PROOF OF CHURCH&apos;S THESIS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2E100AE4094CFA0169884C8AE6EE3D8D</idno>
					<idno type="DOI">10.2178/bsl/1231081370</idno>
					<note type="submission">Received July 10, 2007. 2000 Mathematics Subject Classification. 03D10.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>effective computation</term>
					<term>recursiveness</term>
					<term>computable functions</term>
					<term>Church&apos;s Thesis</term>
					<term>Turing&apos;s Thesis</term>
					<term>abstract state machines</term>
					<term>algorithms</term>
					<term>encodings</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Church's Thesis asserts that the only numeric functions that can be calculated by effective means are the recursive ones, which are the same, extensionally, as the Turingcomputable numeric functions. The Abstract State Machine Theorem states that every classical algorithm is behaviorally equivalent to an abstract state machine. This theorem presupposes three natural postulates about algorithmic computation. Here, we show that augmenting those postulates with an additional requirement regarding basic operations gives a natural axiomatization of computability and a proof of Church's Thesis, as Gödel and others suggested may be possible. In a similar way, but with a different set of basic operations, one can prove Turing's Thesis, characterizing the effective string functions, and-in particular-the effectively-computable functions on string representations of numbers. Contents 1. Introduction: Effectivity 300 1.1. Historical background 300 1.2. Current status 303 1.3. Sketch of axioms 306 1.4. Preliminary discussion 307 2. Stepwise effectivity 310 2.1. Sequentiality 311 2.2. Abstractness 314 2.3. Boundedness 318 3. Abstract state machines 321 4. Arithmetical effectivity 324 4.1. Arithmetical states 324 4.2. Arithmetical machines 325</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>§1. Introduction: Effectivity. Church formulated the thesis bearing his name to address a very fundamental issue in modern logic and mathematics.</p><p>1.1. Historical background. In the beginning of the twentieth century, Hilbert famously introduced fundamental questions of decidability to mathematics:</p><p>[Problem] 10. Determination of the solvability of a Diophantine equation. Given a Diophantine equation with any number of unknown quantities and with rational integral numerical coefficients: To devise a process according to which it can be determined in a finite number of operations whether the equation is solvable in rational integers. <ref type="foot" target="#foot_1">1</ref>  <ref type="bibr" target="#b42">[44]</ref> The Entscheidungsproblem [decision problem for first-order logic] is solved when we know a procedure that allows for any given logical expression to decide by finitely many operations its validity or satisfiability. . . . The Entscheidungsproblem must be considered the main problem of mathematical logic. . . . The solution of the Entscheidungsproblem is of fundamental significance for the theory of all domains whose propositions could be developed on the basis of a finite number of axioms. 2  <ref type="bibr">[45, p.</ref> 73ff.] Hilbert was looking for well-defined procedures that would solve each instance of a problem, positively or negatively, by applying a finite number of operations. He did not have a formal notion of which operations would be reasonable in this context and which not, but clearly he was looking for operations that could be carried out by a mathematician acting mechanically, sans ingenuity. "We assume that we have the capacity to name things by signs, that we can recognize them again. With these signs we can then carry out operations that are analogous to those of arithmetic and that obey analogous laws" (Hilbert, quoted in <ref type="bibr" target="#b86">[95]</ref>).</p><p>With regard to numeric functions, that is, functions from the natural numbers to the natural numbers, 3 Church suggested in 1936 that the recursive functions, which had been defined by G ödel earlier that decade (based on a suggestion of Herbrand's), adequately capture the intended concept of function computable by a finite procedure. 4 He adopted this identification in the form of a definition of effectiveness, and wrote <ref type="bibr">[23, pp. 346, 356]</ref>:</p><p>The purpose of the present paper is to propose a definition of effective calculability which is thought to correspond satisfactorily to the somewhat vague intuitive notion. . . . We now define the notion . . . of an effectively calculable function of positive integers by identifying it with the notion of a recursive function of positive integers (or of a -definable function of positive integers). Church identified "the commonly used term 'effectively calculable'" <ref type="bibr">[22, p. 40]</ref> in reference to a function, that is, the existence of "an algorithm" for 2 "Das Entscheidungsproblem ist gel öst, wenn man ein Verfahren kennt, das bei einem vorgelegten logischen Ausdruck durch endlich viele Operationen die Entscheindung über die Allgemeing ültigkeit bzw. Erf üllbarkeit erlaubt. Das Entscheidungsproblem muss als das Hauptproblem der mathematischen Logik bezeichnet werden. . . . Die Lösung des Entscheidungsproblems ist f ür die Theorie aller Gebiete, deren Sätze überhaupt einer logischen Entwickelbarkeit aus endlich vielen Axiomen fähig sind, von grundsätzlicher Wichtigkeit." 3 Nowadays (e.g., <ref type="bibr" target="#b74">[82]</ref>) it is more common to work with the nonnegative integers, including zero, though in the past (e.g., <ref type="bibr" target="#b22">[23]</ref>) it was common to deal only with the positive integers. The difference is immaterial for discussions of effectiveness of computation. 4 Already in 1935, Church thought (in correspondence to Bernays, quoted in <ref type="bibr">[94, p. 155]</ref>) that the "results of Kleene [regarding the -calculus] are so general and the possibilities of extending them apparently so unlimited that one is led to the conjecture that a formula can be found to represent any particular constructively defined function of positive integers whatever." Kleene is reported <ref type="bibr">[2, p. 185]</ref> to have said much later, "I would like to be able to say that, at the moment of discovering how to lambda define the predecessor function, I got the idea of Church's Thesis. But I did not, Church did." In retrospect, Kleene (see <ref type="bibr">[51, p. 62]</ref>) and Rosser (see <ref type="bibr">[84]</ref>) felt that the lambda calculus might have been a more appropriate basis for characterizing effective computability.</p><p>computing the value of that function for any arguments <ref type="bibr">[23, p. 356]</ref>, with the specific requirement that there be recursion equations by means of which the evaluation of the function can be effected. Only with such a formalization of effectivity in hand could one prove "absolute" undecidability results, namely, that no algorithmic solution whatsoever exists for some particular problem-like the Entscheidungsproblem-as Church set out to show in his papers.</p><p>Church was roundly criticized by <ref type="bibr">Post [75,</ref><ref type="bibr">p. 105]</ref> for hiding a debatable formalization of "effective calculability" behind a definition:</p><p>The work done by Church and others carries this identification considerably beyond the working hypothesis stage. But to mask this identification under a definition hides the fact that a fundamental discovery in the limitations of mathematicizing power of Homo Sapiens has been made and blinds us to the need of its continual verification. For Post <ref type="bibr">[76, p. 418</ref>], it "is not a matter of mathematical proof but of psychological analysis of the mental processes involved in combinatory mathematical processes".</p><p>Turing, in his seminal 1936 paper <ref type="bibr" target="#b96">[107]</ref>, analyzed human computation "from the bottom up", building complex procedures from the most primitive of operations on single symbols. He asserted that computation proceeds by sequential symbol manipulation ("Computing is normally done by writing certain symbols on paper"), and argued that any such computation can be mimicked by a symbolic computation with the following characteristics:</p><p>• Deterministic behavior: "The behaviour of the [human] computer at any moment is determined by the symbols which he is observing, and his 'state of mind' at that moment." • Finitely many internal states: "If we admitted an infinity of states of mind, some of them will be 'arbitrarily close' and will be confused. . . .</p><p>[T]his restriction is not one which seriously affects computation, since the use of more complicated states of mind can be avoided by writing more symbols on the tape." • A finite symbol space: "If we were to allow an infinity of symbols, then there would be symbols differing to an arbitrary small extent. The effect of this restriction of the number of symbols is not very serious.</p><p>It is always possible to use sequences of symbols in the place of single symbols." • Finite observability and local action: "Let us imagine the operations performed by the computer to be split up into 'simple operations' which are so elementary that it is not easy to imagine them further divided. . . . We may suppose that there is a bound. . . to the number of symbols or squares which the computer can observe at one moment. If he wishes to observe more, he must use successive observations."</p><p>• Linear external memory: "The two-dimensional character of paper is no essential of computation. I assume then that the computation is carried out on one-dimensional paper." When Church learned of Turing's work, <ref type="foot" target="#foot_4">5</ref> he conceded that Turing's machines have "the advantage of making the identification with effectiveness in the ordinary (not explicitly defined) sense evident immediately" <ref type="bibr">[24, p. 43]</ref>. He responded to Post, saying: "To define effectiveness as computability by an arbitrary machine, subject to restrictions of finiteness, would seem an adequate representation of the ordinary notion" <ref type="bibr">[25]</ref>.</p><p>A few years later, Kleene, a student of Church, reformulated Church's contention that the recursive functions and the effective numeric functions are one and the same as a "thesis" <ref type="bibr">[48, p. 60]</ref>, [49, p. 300]: <ref type="foot" target="#foot_5">6</ref>[Church's] Thesis I. Every effectively calculable function (effectively decidable predicate) is general recursive. Again, "effective" is meant in the "vague intuitive" sense of computable by humans acting in an algorithmic fashion. In order to accurately match the effect of computations, one must allow functions to be partial, as Kleene subsequently did [49, p. 332]: <ref type="foot" target="#foot_6">7</ref>[Church's] Thesis I † . Every partial function which is effectively calculable (in the sense that there is an algorithm by which its value can be calculated for every n-tuple belonging to its range of definition) is . . . partial recursive. 8 1.2. Current status. Though Kleene spoke of this thesis as unprovable ("Since our original notion of effective calculability . . . is a somewhat vague intuitive one, the thesis cannot be proved" [49, p. 317]), he did present evidence in its favor [49, Chaps. XII-XIII]. Three main lines of argument have been adduced in support of Church's Thesis (already in [49, pp. 319-323]):</p><p>1. In years of experience, all the many effective computational models that have been investigated (starting with the lambda calculus and continuing on down to the latest programming languages) have been shown to compute only partial recursive functions.</p><p>2. A vast number of computational models and a multitude of variants, all yield the exact same class of functions. In particular, <ref type="bibr">Turing [108]</ref> showed that his machines computed the same functions as did the lambda calculus. "The proposed characterizations of Turing and of Kleene, as well as those of Church, Post, Markov, and certain others, were all shown to be equivalent" (Rogers' Basic Result <ref type="bibr">[82, pp. 18-19]</ref>).<ref type="foot" target="#foot_8">9</ref> 3. Turing's analysis of "the sorts of operations which a human computer could perform, working according to preassigned instructions" showed that these can be simulated by his machines [49, p. 321]. <ref type="bibr">Turing [108]</ref> modestly wrote: "The identification of 'effectively calculable' functions with [Turing-] computable functions is possibly more convincing than an identification with the -definable or general recursive functions.</p><p>For those who take this view the formal proof of equivalence provides a justification for Church's calculus, and allows the 'machines' which generate computable functions to be replaced by the more convenient -definitions." The first, "heuristic" argument is relatively unconvincing ("heuristic" is Kleene's word). History is full of examples of delayed discoveries. Aristotelian and Newtonian mechanics lasted much longer than the seventy years that have elapsed since Church proposed identifying effectiveness with recursiveness, but still those physical theories were eventually found lacking. As Barendregt writes <ref type="bibr" target="#b1">[2]</ref>:</p><p>One may wonder why doubting Church's Thesis is not a completely academic question. This becomes clear by realizing that [Skolem in 1923] had introduced the class of primitive recursive functions that for some time was thought to coincide with that of the intuitively computable ones. But then <ref type="bibr" target="#b43">[Ackermann in 1928]</ref> showed that there is a function that is intuitively computable but not primitive recursive. The empirical second argument, from "confluence" of models, is also weak, and has been deemed so by <ref type="bibr">Kreisel [58,</ref><ref type="bibr">p. 144]</ref> and <ref type="bibr">Mendelson [69,</ref><ref type="bibr">p. 228,</ref><ref type="bibr">n. 4]</ref>. Clearly the notion captured by these equivalent models is a robust one, but there still could be a class of effective algorithms not captured by it. As Kreisel <ref type="bibr">[58, p. 144</ref>] put it: "What excludes the case of a systematic error?"</p><p>The third argument is by far the strongest, so strong, in fact, that G ödel [39, p. 168] thought the idea "that this [the recursive functions] really is the correct definition of mechanical computability was established beyond any doubt by Turing". <ref type="foot" target="#foot_9">10</ref> For an analysis of G ödel's opinion in this matter, see <ref type="bibr" target="#b87">[98]</ref>; see, also, <ref type="bibr">Gandy [36,</ref><ref type="bibr">p. 72]</ref> in this connection. Turing's analysis was qualitatively different from those of his predecessors. Soare <ref type="bibr" target="#b93">[104]</ref> goes so far as to write: "It was Turing alone who . . . gave the first convincing formal definition of a computable function . . . <ref type="bibr">[and]</ref> proved that the informal notion coincided with this formal one" (emphasis in the original). Still, though the grand sweep of Turing's argument is overwhelming, there remain weaknesses when it comes to details. For example, the universality of Turing's supposition that "the number of states of mind which need be taken into account is finite" is debatable. Also, how certain is it that each and every elaborate data structure used during a computation can be encoded as a string, and its operations simulated by effective string manipulations? In any event, it is non-trivial to reduce Turing's analysis to a few general axioms.</p><p>Subsequent models of computation did not add much force to Turing's arguments, with the possible exception of Kolmogorov's model <ref type="bibr" target="#b49">[56,</ref><ref type="bibr" target="#b50">57]</ref>, which, according to Leonid Levin [personal communication], 11 was inspired by an analysis of computation in physical space-time. This model partly addresses the issue of computations that compute with data other than mere strings of symbols. But one can only guess at the analysis of computations that was in Kolmogorov's head. Kolmogorov machines, and other variants of the pointer machine, do provide greater fidelity to algorithmic behavior than do Turing machines; see <ref type="bibr" target="#b9">[10]</ref>. But Kolmogorov's published work does not delve into philosophical motivations for, or implications of, his model. In any event, an algorithm need not fit the constraints placed on the states of Kolmogorov's machines. (See Section 7.1.)</p><p>Hence, it remains of importance to provide a small number of convincing postulates in support of Church's Thesis. Indeed, G ödel has been reported (by Church in a letter to Kleene cited by Davis in <ref type="bibr" target="#b25">[28]</ref>) to have believed "that it might be possible . . . to state a set of axioms which would embody the generally accepted properties of [effective calculability], and to do something on that basis". As explained by Shoenfield (and partially quoted in the opening tag line) <ref type="bibr">[92, p. 26]</ref>:</p><p>It may seem that it is impossible to give a proof of Church's Thesis. However, this is not necessarily the case. . . . In other words, we can write down some axioms about computable functions which most people would agree are evidently true. It might be possible to prove Church's Thesis from such axioms. . . . However, despite strenuous efforts, no one has succeeded in doing this (although some interesting partial results have been obtained). Kalmár <ref type="bibr">[46]</ref> and Rogers <ref type="bibr">[82, p. 20]</ref> (and, more recently, Folina <ref type="bibr" target="#b28">[31]</ref>) argued against provability of the thesis, while Gandy <ref type="bibr" target="#b32">[35]</ref> and Mendelson <ref type="bibr" target="#b62">[69,</ref><ref type="bibr">70]</ref> notion with your -definability gives a stronger conviction of the adequacy of these concepts for expressing the popular meaning of 'effective calculability'." 11 Levin was Kolmogorov's student.</p><p>(along with <ref type="bibr" target="#b80">[88,</ref><ref type="bibr">90,</ref><ref type="bibr" target="#b53">60,</ref><ref type="bibr" target="#b85">94,</ref><ref type="bibr" target="#b5">6]</ref>) argued in favor of the possibility of axiomatizing effectivity. Kreisel described the discovery of "evident axioms about constructive functions" as "one of the really important open problems" <ref type="bibr" target="#b51">[58]</ref> and "one of the more feasible problems at the present time" <ref type="bibr" target="#b52">[59]</ref>. We propose just such an axiomatization of effective computation in the sections that follow.</p><p>For more on the history of Church's Thesis, see Kleene's retrospective [51], the historical remarks of Rosser in [84], and the article by Davis <ref type="bibr" target="#b25">[28]</ref>; all three of the authors were students of Church.</p><p>1.3. Sketch of axioms. The first issue that needs to be addressed when axiomatizing effective computation is: What kind of object is a "computation"? Once we agree that it is some sort of state transition system (Postulate I in what follows), we need to formalize the appropriate notions of "state" and of "transition". To model states, we take the most generic of mathematical objects, namely, logical structures (Postulate II). To ensure that each transition step is effective, we require only that it not entail an unbounded amount of exploration of the current state (Postulate III). Finally, we need to make sure that a computation does not start out with any magical abilities (Postulate IV). We will demonstrate that under these very natural and general hypotheses regarding algorithmic activity, which certainly suffice for the computation of all recursive functions, the recursiveness of the computed function is in fact guaranteed.</p><p>More precisely, but still informally, the postulates say the following about algorithms:</p><p>I. An algorithm determines a sequence of "computational" states for each valid input. II. The states of a computational sequence are structures. And everything is invariant under isomorphism. III. The transitions from state to state in computational sequences are governable by some fixed, finite description. IV. Only undeniably computable operations are available in initial states. Postulates I-III are called the "Sequential Postulates" <ref type="bibr" target="#b39">[42]</ref>. They axiomatize (deterministic, sequential) algorithms in general, not only those for computable functions; they apply equally to algorithms dealing with complex numbers, say, as to those for integers only. Postulate IV, which will be fleshed out later, ensures that an algorithm is not endowed from the outset with uncomputable oracles, such as infinite precision operations on real numbers, or a solvability decider for Diophantine equations. We will show in this paper that Church's Thesis provably follows from these four postulates.</p><p>In the next section, we formulate the three Sequential Postulates rigorously, motivate each of them, and adduce support for them from the classical literature. In Section 3, we recall the definition of abstract state machines <ref type="bibr" target="#b38">[41]</ref>, and the fact that they emulate any algorithm obeying those postulates <ref type="bibr" target="#b39">[42]</ref>.</p><p>(See also <ref type="bibr" target="#b72">[80]</ref>.) These machines will play a central part in our proof. Then, in Section 4, we turn Church's Thesis into a precise mathematical statement and explain why the fact that only the recursive functions can be calculated by effective means follows provably from our four postulates. In the same way, as shown in Section 5, it follows that relative effectiveness (modulo oracles) and relative recursiveness are equivalent.</p><p>Church supplied examples to argue that a decision problem in a nonnumerical domain could also "be interpreted as a problem in elementary number theory", since properties in other domains "can be described in number-theoretic terms" <ref type="bibr">[23, p. 345</ref>]. Accordingly, in Section 6, we extend our analysis to deal with such algorithms that manipulate additional objects, besides numbers, like strings of symbols. There, we formalize what it means to "be described", without recourse to any intuitive notion of effectiveness of encodings. Furthermore, individual steps can be as large as one wishes, as long as they can be guaranteed to be effective. This analysis, turned around so that everything is viewed in terms of strings, also yields an axiomatization and proof of Turing's Thesis, namely, that every effective string-to-string (partial) function is Turing-computable.</p><p>1.4. Preliminary discussion. Turing's analysis <ref type="bibr" target="#b96">[107]</ref> and its subsequent generalizations by Post <ref type="bibr" target="#b69">[77]</ref> and Kolmogorov <ref type="bibr" target="#b49">[56,</ref><ref type="bibr" target="#b50">57]</ref> are on an informal level. Gandy <ref type="bibr" target="#b32">[35]</ref> was the first to attempt an axiomatization, and was followed in this endeavor by Sieg <ref type="bibr" target="#b84">[93,</ref><ref type="bibr" target="#b85">94,</ref><ref type="bibr">97,</ref><ref type="bibr">96,</ref><ref type="bibr" target="#b88">99,</ref><ref type="bibr" target="#b89">100]</ref>; though their axioms are formal, they are expressed on the level of a specific representation of states (namely, hereditarily finite sets). In contrast, our axioms of effective computation are, at the same time, formal and generic. They are formal in the sense that they are precise mathematical statements about computation sequences. Our postulates are generic, in that they are expressed in terms of computation sequences with arbitrary states and arbitrary programmable transitions. Each transition corresponds exactly to a single step in a given algorithmic process. In these ways, our proposed axiomatization improves upon its predecessors.</p><p>All attempts to axiomatize computation inevitably formalize the notion of state as a mathematical object, and, as such, involve some measure of abstraction from, and representation of, the physical realities of human or machine computations. Indeed, science in general is impossible without modeling. Mathematics, in particular, deals with mathematical objects, not physical ones. To quote Kleene <ref type="bibr">[53, p. 30</ref>]:</p><p>Mathematicians deal with idealized systems of objects, obtained by extrapolating for the purposes of their thought from what people encounter in the real world. They imagine the infinite sequence 0, 1, 2, . . . of the natural numbers, and thus get a beautiful theory with an elegant logical structure, though in actual counting of discrete objects we can never use more than finitely many of them.</p><p>Regarding the modeling of solvable and unsolvable puzzles, for instance, Turing wrote <ref type="bibr">[110, p. 11]</ref>: "If one wants to treat the problem seriously and systematically one has to replace the physical puzzle by its mathematical equivalent." So the right question is whether our representation goes beyond what is absolutely necessary for formalization.</p><p>One abstraction, one that we inherit from all classical analyses, is that transitions are discrete (Postulate I). An additional abstraction we make is that states are structures. Our claim, expressed in the Abstract State Postulate (Postulate II), is that using structures is the unavoidable, bare minimum that is necessary for formalizing actual computational states.</p><p>There are strong arguments to support this claim. In the first place, the history of mathematical endeavor is on our side. Long experience supports the contention that any static mathematical reality can be viewed as a structure, without resorting to coding, translation, or the like. In this way, our Abstract State Postulate allows formal computational states to be as true to reality as is mathematically feasible. Whatever the states of some algorithmic computation "really" are (e.g., a piece of paper containing geometric drawings), their reality is faithfully modeled by logical structures, the "least common denominator" of all of mathematical modeling of static realities. No unnecessary properties of the real states (e.g., the thickness of the paper) appear in the model, nor does the model introduce unneeded and unwanted attributes (like the length of some particular textual representation of a triangle), as is invariably the case when objects of one kind are encoded as objects of another kind, be that numbers as strings, strings as graphs, graphs as matrices, or matrices as nested sets. (Compare the foundational discussion in <ref type="bibr" target="#b13">[14]</ref>.)</p><p>By virtue of the generality of structures, every other model of (sequential) computation extant in the literature is a special case of ours. As one would expect, the presentations of state are-from the mathematical point of view-structures, in every case. Here is a sampling of structures used in programming languages:</p><p>• Traditional arithmetic operates over natural numbers, having a "Platonic" existence. Numbers are endowed with elementary-school operations, like addition and multiplication, or with more complex functionality, like primality tests. • Common Lisp's arithmetic operates over the infinite set of rational numbers. • Counter machines, at the other extreme, make do with very simple, "neolithic" operations. • In the classical random access (RAM) model of computation, memory cells are arbitrary integers and memory content is a dynamic function with an infinite address domain. • The states of a pushdown automaton include a stack of symbols and simple stack operations.</p><p>• The Burroughs B5500 computer had a stack-based architecture with hardwired stack operations and no programmer-addressable registers. • In Lisp, nested list expressions are the basic datatype, with primitive operations for adding and removing elements. • The basic datatype in APL is arrays, including arrays of arrays. These objects are endowed with a very rich repertoire of matrix operations. • Infinite streams are the basis for the lazy programming paradigm used in languages like Lucid and Haskell. • Strings, with complex string operations, including matching and concatenation, are used for text processing in languages like Snobol and Perl. • Plain lambda calculus has lambda terms as its basic objects andreduction as a basic operation.</p><p>All of these are straightforward instances of structures, and fit effortlessly into our framework.</p><p>No previous approach has nearly the generality of the one espoused here. For example, in Turing's formalism, states are modeled by means of strings; Kolmogorov machines are based on labeled graphs; Gandy's states are hereditarily finite sets. But strings, graphs and sets are all distinct from one another and come with very different native operations. Nested sets are not labeled graphs, nor are labeled graphs, nested sets. Neither can lay claim to genericity. Hypergraphs, for instance, are not strings, graphs, or sets, per se.</p><p>State structures can be quite intricate, involving many types of objects. For example, a programming language can itself be thought of as an algorithm (an interpreter) that takes a program as input and executes it on given data. Its states would comprise a variegated domain and an abundance of operations. To represent all structures used by programmers in terms only of strings, or graphs, or sets would require a daunting amount of encoding. In our setting, however, this poses no problem; witness the detailed structuralrepresentations of C and Java given in <ref type="bibr" target="#b40">[43]</ref> and <ref type="bibr" target="#b94">[105]</ref>, respectively.</p><p>Even algorithms computing purely numeric functions or pure string functions typically involve additional types of objects. So, to define effectiveness of numerical calculations or of string calculations, one needs to consider the effectiveness of operations over those auxiliary objects. But to show the effectiveness of a graph operation by applying standard notions of effectiveness of strings, say, requires an appeal to intuition in support of the assertion that the encoding of graphs as strings is effective. (Compare <ref type="bibr">[72, pp. 430-431</ref>].) This is because the encoding does not reside in either a pure string domain or a pure graph domain, for either of which there is a standard effective model of computation (Turing machines and Kolmogorov machines, respectively). Rather, it is a function over a domain with both strings and graphs, for which there is no direct, formal definition of effectiveness. In Section 6, we provide an alternative approach to effectiveness of basic operations over non-numerical domains, requiring, instead, effectiveness of their numerical homomorphic images. 12  In contradistinction to Turing machines or any other model of computation with a limited repertoire of basic objects, using structures for states makes it possible for an abstract state machine to provide a step-for-step emulation of any algorithm, regardless of the complexity of its data structures and primitive operations. 13  These issues are discussed further in the concluding section. §2. Stepwise effectivity. Church was striving to characterize the numeric functions that are algorithmically computable. The question is how does one know that all possible algorithms have been characterized, or as Post already phrased the problem in 1921 <ref type="bibr" target="#b68">[76]</ref>: one needs to capture "all the possible ways in which the human mind could set up finite processes".</p><p>Rogers, a student of Church's, starts his classic book [82, pp. 1-2] with the following elaboration on the informal notion of "effective procedure" (italics in original):</p><p>Roughly speaking, an algorithm is a clerical (i.e., deterministic, bookkeeping) procedure which can be applied to any of a certain class of symbolic inputs and which will eventually yield, for each such input, a corresponding symbolic output. An example of an algorithm is the usual procedure given in elementary calculus for differentiating polynomials. . . . Several features of the informal notion of algorithm appear to be essential. We describe them in approximate and intuitive terms. *1. An algorithm is given as a set of instructions of finite size. . . . *2. There is a computing agent, usually human, which can react to the instructions and carry out the computation. *3. There are facilities for making, storing, and retrieving steps in a computation. 12 Barendregt expresses the importance of transparent representations as follows [2, pp. 188-189]: "Lambda definability was introduced for functions on the set of natural numbers N. In the resulting mathematical theory of computation (recursion theory) other domains of input or output have been treated as second class citizens by coding them as natural numbers. In more practical computer science, algorithms are also directly defined on other data types like trees or lists. Instead of coding such [inductive] data types as numbers one can treat them as first class citizens by coding them directly as lambda terms while preserving their structure. Indeed, lambda calculus is strong enough to do this. . . ." 13 Indeed, the experience of a wide range of abstract state machine applications <ref type="bibr" target="#b19">[20]</ref> also supports this claim: In all cases, it has been possible to specify software faithfully on the precise proper level of abstraction, without introducing unnecessary details, or divulging internal details, thereby eliminating unwanted ambiguity, while-at the same time-preserving any desired ambiguities. *4. Let P be a set of instructions as in *1 and L be a computing agent as in *2. Then L reacts to P in such a way that, for any given input, the computation is carried out in a discrete stepwise fashion, without use of continuous methods or analogue devices. *5. L reacts to P in such a way that a computation is carried forward deterministically, without resort to random methods or devices, e.g., dice.</p><p>Virtually all mathematicians would agree that features *1 to *5, although inexactly stated, are inherent in the idea of algorithm. Rogers also goes on to say <ref type="bibr">[82, p. 4</ref>] that there should be a "fixed finite bound on the capacity" of the agent L, which would necessitate L's using the unlimited memory resource, alluded to in *3, to "keep track of . . . progress" in the computation and remember "one's place" in the program. In what follows, we formalize these considerations of finite program and computation that is stepwise-bounded and deterministic-without delineating the r ôles of program P and agent L. We base ourselves on the formalization of <ref type="bibr" target="#b39">[42]</ref>, while elaborating and refining aspects that are important from the point of view of effectiveness.</p><p>2.1. Sequentiality. We begin by characterizing computations, in general. Computation, as opposed to the behavior of a physical process, is usually conceived of as a sequence of discrete computational steps. 14  This is what Kolmogorov presumably had in mind when he presented his view of algorithms in 1953 <ref type="bibr" target="#b49">[56]</ref>: 15  We start with the following obvious ideas concerning algorithms:</p><p>(1) An algorithm Γ being applied to any "input" (= "initial state") A which belongs to some set (the "domain" of the algorithm) gives a "solution" (= "final state") B. 14 Turing was explicitly interested in formalizing "discrete" machines, not continuous processes <ref type="bibr" target="#b97">[109]</ref>: "The nervous system is certainly not a discrete-state machine. A small error in the information about the size of a nervous impulse impinging on a neuron, may make a large difference to the size of the outgoing impulse. It may be argued that, this being so, one cannot expect to be able to mimic the behaviour of the nervous system with a discrete-state system. It is true that a discrete-state machine must be different from a continuous machine. But if we adhere to the conditions of the imitation game, the interrogator will not be able to take any advantage of this difference." The first attempt, as far as we know, at characterizing analogue computation is <ref type="bibr" target="#b64">[72]</ref>. 15 Cf. Knuth in 1966 <ref type="bibr" target="#b48">[54]</ref>: "Algorithms are concepts which have existence apart from any programming language. . . . I believe algorithms were present long before Turing et al. formulated them, just as the concept of the number 'two' was in existence long before the writers of first grade textbooks and other mathematical logicians gave it a certain precise definition. . . . A computational method comprises a set Q (finite or infinite) of 'states', containing a subset X of 'inputs' and a subset Y of 'outputs'; and a function F from Q into itself. (These quantities are usually also restricted to be finitely definable, in some sense that corresponds to what human beings can comprehend.) . . . In this way we can divorce abstract algorithms from particular programs that represent them."</p><p>(2) An algorithmic process splits into separate steps of limited complexity; each step consists of an "immediate transformation" of the state S obtained up to this moment into the state</p><formula xml:id="formula_0">S * = Ω Γ (S). (3) The process transforming A 0 = A into A 1 = Ω Γ (A 0 ), then A 1 into A 2 = Ω Γ (A 1 ), then A 2 into A 3 = Ω Γ (A 2</formula><p>), etc. is continued until the next step is impossible (i.e., the operator Ω Γ is undefined on the current state) or a signal indicating the appearance of the "solution" is received. It is possible, however, that this process of transformations would never stop (if we get no signal at all). (4) The immediate transformation of S into S * = Ω Γ (S) is based only on information about the limited "active part" of S and affects this part only. Much earlier, in 1922, Behmann <ref type="bibr">[4, p. 166</ref>] expressed the stepwise nature of algorithmic activity by saying (cited in <ref type="bibr" target="#b101">[113]</ref>): <ref type="foot" target="#foot_10">16</ref>A completely determined general [set of] instructions shall be exhibited, according to which the correctness or falsity of an arbitrary given claim, which can be formulated with purely logical means, can be decided after a finite number of steps. This is also what Kleene envisioned when he wrote <ref type="bibr">[53, pp. 16-17]</ref> (emphasis in the original):</p><p>Such a method is given by a set of rules or instructions, describing a [decision] procedure that works as follows. After the procedure has been described, if we select any question from the class, the procedure will then tell us how to perform successive steps, so that after a finite number of them we will have the answer to the question selected. . . . After our performing any step to which the procedure has led us, the rules or instructions will either enable us to recognize that now we have the answer before us and read it off, or else that we do not yet have the answer before us, in which case they will tell us what steps to perform next. Furthermore, we view computation as proceeding deterministically, "leaving no place to arbitrariness" [66, p. 1]. As Rosser, also a student of Church, puts it <ref type="bibr" target="#b75">[83]</ref>:</p><p>"Effective method" is used here in the rather special sense of a method each step of which is precisely determined and which is certain to produce the answer in a finite number of steps. . . . An effective method of solving certain sets of problems exists if one can build a machine which will then solve any problem of the set with no human intervention beyond inserting the question and (later) reading the answer. Shoenfield adds <ref type="bibr">[91, p. 107]</ref>, "A method must be mechanical. . . . Methods which involve chance procedures are excluded; . . . methods which involve magic are excluded; . . . methods which require insight are excluded."</p><p>Computations may, therefore, be formalized as a (deterministic) statetransition system, comprising a set of states S, a subset I of which are initial, and a (typically partial) transition function ; on states, which determines the next-state relation. States with no "next" state, namely, { ∈ S | ¬ ∃ . ; }, will be, for us, terminal states. Remark 2.1. For Kolmogorov <ref type="bibr" target="#b49">[56]</ref>, terminal states somehow "signal" their appearance. In the original definition of abstract state machines <ref type="bibr" target="#b38">[41]</ref>, the transition function is always total; intuitively terminal states are their own next state. Since we are interested in the output of algorithms, we distinguish between a terminal state that marks the end of a computational sequence, and a non-terminating state that may be its own next state. This understanding of computation as proceeding in discrete steps is encapsulated as follows:</p><p>Postulate I (Sequential time). An algorithm is a state-transition system. Its transitions are partial functions. Continuous (analogue) processes, transfinite computation sequences (involving limits) <ref type="bibr" target="#b70">[78,</ref><ref type="bibr" target="#b37">40]</ref>, nondeterministic transitions, and nonprocedural input-output specifications are thereby excluded from consideration.</p><p>Classical algorithms, of the sort Church was considering, never leave room for choices. For example, though segments of the evaluation of recursive functions could, in principle, proceed in a nondeterministic fashion, or even in parallel, when it came down to specifying their computation, a particular order was always fixed in advance. Thus, Rogers <ref type="bibr">[82, p. 7]</ref> writes, "We obtain the computation uniquely by working from the inside out and from left to right" (and, similarly, in <ref type="bibr">[48, p. 45]</ref> and <ref type="bibr">[91, p. 109]</ref>). Classical algorithms also do not involve any sort of interaction with the environment to determine the next step. For this reason, we are justified in restricting our attention to fully deterministic algorithms. Remark 2.2. Moschovakis [73, p. 919] claims that "algorithms are recursive definitions while machines model implementations, a special kind of algorithms". We beg to differ. Algorithms, for us, are deterministic transition systems. This traditional viewpoint is in accord with that of most students of computability-including those quoted above-and that of virtually all computer scientists and engineers. Besides, recursive definitions by themselves are open to more than one interpretation. Most programming languages in fact use an eager evaluation strategy and compute a function that is, in general, less defined than the least fixed point. Recursive definition have, besides their least fixed-point solution, a unique "optimal" (maximally consistent) fixed point <ref type="bibr" target="#b57">[65]</ref>, which (though not necessarily computable) is, in general, more defined than the least fixed point and could also be taken as the intended semantics of the definition. Even after specifying that the least fixed point is what is meant, as Moschovakis does, there is much room for algorithmic variation. There can be significant algorithmic distinctions and performance differences between reasonable methods of computing that least fixed point, such as "call by name" and "call by need". So, for us (see <ref type="bibr" target="#b7">[8]</ref>), recursion equations are a partial specification of desired properties of the algorithm in question, not the algorithm itself. Nevertheless, if one does accept Moschovakis's point of view, then it is the various "implementations" of such recursive definitions that we have set out to characterize here. In <ref type="bibr" target="#b7">[8]</ref>, it is argued that such a machine-independent implementation does not reduce the level of abstraction; in <ref type="bibr" target="#b6">[7]</ref>, it is argued that there is no "one size fits all" notion of equivalence between algorithms-or between faithful implementations of recursive definitions.</p><p>Remark 2.3. Though Turing's (human) computers operate deterministically when computing functions, he did envision choice-machines, which wait for an "arbitrary choice . . . by an external operator" before continuing (in an exploration of proofs, say). The Sequential Postulates have been adapted to admit the essential use of nondeterminism, as in modern distributed computations; see <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref> for an in-depth treatment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Abstractness.</head><p>Specific models of computation work with specific data structures. For example, Turing designed a model that works with tapes, though he explained why such a one-dimensional medium suffices for what is normally carried out by people in two dimensions <ref type="bibr" target="#b96">[107]</ref>: "I think that it will be agreed that the two-dimensional character of paper is no essential of computation." Kolmogorov-Uspensky's model <ref type="bibr" target="#b50">[57]</ref>, and later variants of the "pointer machine" (e.g., <ref type="bibr" target="#b76">[85]</ref>), use graphs as a more free-form representation of state. Gandy <ref type="bibr" target="#b32">[35]</ref> suggests hereditarily finite sets as a generic data structure for the same purpose.</p><p>Since we are interested here in characterizing arbitrary algorithms, we ought not limit the form of states a priori. Accordingly, we let the states of state-transition systems be first-order structures with equality <ref type="bibr" target="#b95">[106]</ref>, firstorder structures being the most general thing mathematicians have in their arsenal for representing discrete states. It will simplify matters if the relations (predicates) of a first-order structure are viewed as their characteristic, truthvalued functions, but this is merely a matter of convenience.</p><p>Structures, like our states, whose vocabulary does not include relation symbols are called algebras (in the universal algebra sense). We shall refer to state-transition systems with algebraic states as abstract transition systems (ATSs).</p><p>Remark 2.4. If one chooses to forego the convenience of dealing with algebras and work with states that are classical structures, with relations as well as functions, then Boolean truth values and Boolean connectives need not be an integral part of states. Instead, the semantics of Boolean operations could be imparted by the "outside world", whereas here Boolean operations are an integral part of states. Cf. Remark 3.3. Both the logical structure-based approach and the programming-oriented algebra-based approach yield precisely the same results on effectivity. The differences are purely aesthetic.</p><p>As already indicated in Section 1.4, the justification for postulating that structures or algebras are appropriate for capturing algorithmic states is the enormous experience of mathematicians who have faithfully and transparently presented every kind of static mathematical reality as a first-order structure.</p><p>The reader should not be misled by the modifier "first-order": Should an algorithm make use of sets and/or higher-order functions, then sets and functions should be incorporated in the domain (a.k.a. base set, universe, underlying set, or carrier) of the structure, and the appropriate "higher" operations can be included in the "first-order" structure.</p><p>We assume, furthermore, that the classes of states and initial states are closed under isomorphism, and that transitions commute with isomorphisms, so that isomorphic states transition to isomorphic states. Closure under isomorphism is justified by the intention that all essential information about a state be given by the basic functions, as is usual in logic and algebra. The individual nature of elements is unimportant; therefore, structures are mere representations of isomorphism types. There should be no more reality to a domain element than what is observable from the structure. This isomorphism constraint is what makes states "abstract". It reflects the fact that an ATS works at a fixed level of abstraction, and "lower-level" representations do not matter. The relevance of insisting on closure under isomorphism was underscored by Gandy <ref type="bibr">[35, p. 128</ref>]. For more discussion, see <ref type="bibr" target="#b39">[42,</ref><ref type="bibr">Sect. 4.6]</ref>.</p><p>All states of an algorithm should share the same fixed vocabulary. Furthermore, transitions do not change the underlying domain. Whatever vocabulary or domain elements may possibly be needed at some point in a computation are included from the outset. Since, as we will see in the next subsection, algorithms are finitely describable, we may assume that the vocabulary is finite. See <ref type="bibr" target="#b39">[42,</ref> for more detailed considerations.</p><p>Usually, the states of an ATS include some static functions that are present in initial states and are never changed by transitions. In particular, equality and the Boolean operations are always static and inviolate. The values (interpretation) of any other ("defined") functions, however, are dynamic and may change from state to state. But in any case, all the functions of a state are total, formally speaking.</p><p>Since a state is a structure, it "holds" a value for each function in its vocabulary, applied to every possible combination of domain values. A specific location in a state α is given by a function symbol f from the vocabulary of α and by a tuple (a 1 , . . . , a n ) of elements of the domain Dom α of α, where n is the arity of f. Let f α signify the interpretation of f in state α. The value stored at location f(a 1 , . . . , a n ) is just f α (a 1 , . . . , a n ). In this way, every state α assigns a value [[t]] α ∈ Dom α to each (ground, that is, variable-free) term t over its vocabulary.</p><p>A domain might use a particular element to signify a singularity, or that the arguments in question are for all practical purposes invalid, or that its value has not yet been ascertained. For example, a state might contain the datum, 3/0 = ⊥, where ⊥ is some particular domain element, to indicate that the result of division by zero is undefined, and has no numerical value. <ref type="foot" target="#foot_11">17</ref>Remark 2.5. Following <ref type="bibr" target="#b39">[42]</ref>, we will henceforth assume that the domain of states includes an undefined value, ⊥, for this purpose. This is a mere convenience; it is not an essential ingredient of abstract states.</p><p>Of course, each state must contain all the data required by the algorithm for making the next step. As Turing <ref type="bibr">[107, pp. 232, 253-254]</ref> explains:</p><p>At any stage of the motion of the machine, the number of the scanned square, the complete sequence of all symbols on the tape, and the m-configuration will be said to describe the complete configuration at that stage. . . . It is always possible for the computer to break off from his work, to go away and forget all about it, and later to come back and go on with it. If he does this he must leave a note of instructions (written in some standard form) explaining how the work is to be continued. This note is the counterpart of the "state of mind". We will suppose that the computer works by such a desultory manner that he never does more than one step at a sitting. The note of instructions must enable him to carry out one step and write the next note. So, to completely characterize the intermediate status of a Turing machine computation, while the computer is "out to lunch", the abstract state should include the condition of the control (Turing's "state of mind" or "mconfiguration"), the complete contents of the tape, and the position of the read/write head (what is called, nowadays, the "instantaneous description" of an intermediate state of the machine).</p><p>To sum up, we have:</p><p>Postulate II (Abstract state). States are structures, sharing the same fixed, finite vocabulary. States and initial states are closed under isomorphism. Transitions preserve the domain, and transitions and isomorphisms commute.</p><p>Since transitions do not change the vocabulary or the domain, it is only the interpretation that a state gives to the symbols in its vocabulary that changes from state to state.</p><p>Commutation here means that whenever there is a transition α ; α and an isomorphism from α to another state = (α), then there must also be a transition ; from to the corresponding isomorphic image = (α ) of α . It follows that terminal states are also closed under isomorphisms.</p><p>Infinitary operations, like taking limits, are excluded, since the vocabulary is first-order, but-then again-operations that are not finitary cannot be expected to be evaluatable in a single algorithmic step. As already mentioned, algorithms working with higher-order structures are not precluded, since the domain may include sets and higher-order functions. Similarly, one can have a limit operator operating on a whole sequence as a unity, along with operations for building sequences provided as part of the state.</p><p>Note that we are not saying that the states of an algorithm can be somehow "encoded" as (isomorphism-closed) structures. Rather, we are postulating that, once formalized, states are essentially structures-whether or not the author of the algorithm conceived of them that way. In other words, there is always a set of relevant objects (which is the domain), and the salient characteristics of the state are in fact relations or functions over those objects.</p><p>Post, according to his own testimony in [76, pp. 420, 426-429], had the following intuitions about abstract representations of computational states in 1922:</p><p>We are . . . to regard our symbols as without properties except that of permanence, distinguishability and that of being part of certain symbol-complexes.</p><p>We . . . give what is at least a first approximation to a definitive solution of the difficulty of finding a natural normal form for symbolic representation. . . . We . . . assume [symbolic representations] to be finite and we might say discrete. . . . Each symbolization can be considered to consist of a finite number of unanalysable parts (unanalysable from the standpoint of the symbolization) these parts having certain properties and certain relations with each other. . . . The ways in which these parts can be related will be assumed to be specified for the whole system of symbolizations. . . . The number of these elementary properties and relations used is finite and . . . there is a certain specific finite number of elements in each relation. . . . The symbol-complexes are completely determined by specifying all the properties and relations of [their] parts. . . . Each complex of the system can be completely described [by a conjunction of relations]. . . . Due to discreteness and finiteness we would thus have a finite sequence of symbol-complexes representing the various stages in the method.</p><p>Post is asserting here that computational states are completely determined by the relations of a first-order structure. <ref type="foot" target="#foot_12">18</ref>2.3. Boundedness. So far, nothing we have said guarantees that the behavior of a transition system is effective. For effectivity, it must be possible to express the rules for going from state to state in some finite fashion. Kleene stresses this point repeatedly:</p><p>An algorithm in our sense must be fully and finitely described before any particular question to which it is applied is selected. When the question has been selected, all steps must then be predetermined and performable without any exercise of ingenuity or mathematical invention by the person doing the computing. <ref type="bibr">[50, pp. 240-241n.]</ref> The notion of an "effective calculation procedure" or "algorithm" (for which I believe Church's thesis) involves its being possible to convey a complete description of the effective procedure or algorithm by a finite communication, in advance of performing computations in accordance with it. [52, p. 493] An algorithm is a finitely described procedure. . . . In performing the steps, we simply follow the instructions like robots; no ingenuity or mathematical invention is required of us. Such methods as I have described . . . have been called "algorithms". <ref type="bibr">[53, p. 17]</ref> Turing analyzed the need for transitions to depend on only a finite segment of the state, for his model, as follows [107, Sect. 9]:</p><p>The behaviour of the computer at any moment is determined by the symbols which he is observing and his "state of mind" at that moment. We may suppose that there is a bound B to the number of symbols or squares which the computer can observe at one moment. If he wishes to observe more, he must use successive observations. We will also suppose that the number of states of mind which need be taken into account is finite. The reasons for this are of the same character as those which restrict the number of symbols. This finiteness requirement is expressed in more general terms by Kolmogorov and Uspensky <ref type="bibr">[57, pp. 6, 16]</ref>:</p><p>The mathematical notion of Algorithm has to preserve two properties. . . . 1. The computational operations are carried out in discrete steps, where every step only uses a bounded part of the results of all preceding operations.</p><p>2. The unboundedness of memory is only quantitative: i.e., we allow an unbounded number of elements to be accumulated, but they are drawn from a finite set of types, and the relations that connect them have limited complexity. . . . It seems plausible to us that an arbitrary algorithmic process satisfies our definition of algorithms. We would like to emphasize that we are talking not about a reduction of an arbitrary algorithm to an algorithm in the sense of our definition, but that every algorithm essentially satisfies the proposed definition.</p><p>To achieve this for arbitrary abstract transition systems, we demand the following:</p><p>Postulate III (Bounded exploration). Transitions are determined by a fixed finite "glossary" of "critical" terms. That is, there exists some finite set of (variable-free) terms over the vocabulary of the states, such that states that agree on the values of these glossary terms, also agree on all next-step state changes.</p><p>Algorithms, by their nature, explain how to update states by manipulating values stored at locations in the current state. For an algorithm to refer to a particular location f(a 1 , . . . , a n ), it needs to specify the function f, and also to identify each of the arguments a i . But how can the algorithm specify domain elements a i in an abstract state? It can indirectly, by means of locations. So, in the final analysis, terms provide a perfectly general means of specifying locations and elements of states. Each critical term f(t 1 , . . . , t n ) "points" to the location f(a 1 , . . . , a n ), containing f α (a 1 , . . . , a n ), where a i = [[t i ]] α is the value of the term t i in state α. Thus, this postulate means that only a bounded number of locations need to be explored for the algorithm to make a transition. Needing only a bounded number of critical terms corresponds exactly to the ability to describe finitely how transitions are effected, whatever the language or format of description. Additional arguments in support of this postulate may be found in <ref type="bibr" target="#b39">[42]</ref>.</p><p>By an update, we will mean a triple, written as an "assignment" f( ā) := b, indicating that the value b is to be assigned to location f( ā), changing the graph of function f. Let</p><formula xml:id="formula_1">Δ(α) = {f( ā) := b | α ; α , f ∈ F, a i ∈ Dom α, f α ( ā) = f α ( ā) = b},</formula><p>be the set of updates that transpire in a transition out of α. Bounded exploration demands that whenever [[t]] α = [[t]] holds for all critical terms t in the glossary, then either α and are both terminal states, or else Δ(α) = Δ( ), meaning that they both change in the same way. <ref type="foot" target="#foot_13">19</ref> Together with isomorphism preservation of transitions (Postulate II), the equality of the Δ's implies that any updated value b in Δ(α) is the interpretation of one of the critical terms in the glossary [42, Lemma 6.2]. Bounded exploration is what ensures that the step-by-step behavior of the procedure is effective, since it implies that the algorithm can be described by a finite text <ref type="bibr" target="#b39">[42]</ref>, as we will see in the next section.</p><p>Infinite programs, as well as individual steps that require examination of unboundedly many locations within states, or which update unboundedly many values in one fell swoop, are precluded by this postulate. To the extent that an unbounded operation is effective on account of its having a bounded schematic description, that schema should be incorporated in the state itself. For example, a transition cannot be governed by an "instruction" like</p><formula xml:id="formula_2">n := 2 3 ••• n ,</formula><p>as it refers to unboundedly many terms (depending on the value of n). One would need, instead, a new operation for such an exponential tower. Nor can the transition be something like</p><formula xml:id="formula_3">n := 3 ↑↑ • • • ↑ n times n,</formula><p>where the arrow is Knuth's "uparrow" notation for iterated operations. <ref type="foot" target="#foot_14">20</ref>This instruction is also unbounded, as it is really a schema for infinitely many conditional assignments, each involving a different operation: . . .</p><formula xml:id="formula_4">if n = 2 then n := 3 ↑↑ 2 if n = 3 then n := 3 ↑↑↑ 3 if n = 4 then n := 3 ↑↑↑↑ 4 . . .</formula><p>To obtain the equivalent effect would require some form of iteration involving a long sequence of state transitions, or a new ternary operation a ↑ n b.</p><p>Similarly, a bounded quantifier, like ∃ i&lt;n.f(i)=f(n), which refers to an unbounded number of values of f, is actually an operation in its own right, taking the predicate i,n.f(i)=f(n) as an argument.</p><p>As explained in the previous subsection, each abstract state is meant to explicitly incorporate all information needed for the continuation of the computation from that point on. To determine the next state only a bounded amount of that information needs to be explored. With Bounded Exploration, an algorithm computes in "steps of limited complexity", as demanded by Kolmogorov <ref type="bibr" target="#b49">[56]</ref> (quoted above). This postulate, thereby, goes straight to the heart of Kolmogorov's implicit question: What does it mean to bound the complexity of each individual step? §3. Abstract state machines. An abstract state machine, or ASM, is a state-transition system in which algebraic states store the values of functions, in other words, their "graphs", and each transition updates a finite number of locations of the current state. Transitions are programmed using a convenient language based on guarded commands for updating individual locations in states. ASMs capture the notion that each step of an algorithm performs a bounded amount of work, whatever domain it operates over, so are central to our development. Definition 3.1 (ASM <ref type="bibr" target="#b39">[42]</ref>). An abstract state machine (ASM ) is given by: 21  • a set (or proper class) <ref type="foot" target="#foot_15">22</ref> S of algebraic states, closed under isomorphism, sharing a vocabulary F, • a set (or proper class) I ⊆ S of initial states, closed under isomorphism, and • a program P, consisting of finitely many commands, each taking the form of a guarded assignment if p then t := u, for terms t and u over F and conjunction p of equalities and disequalities between terms.</p><p>At each step of a computation, all assignments in P whose guards hold true in the current state are executed in parallel so as to give the next state. More precisely, given a state α ∈ S, program P defines the following set Δ + (α) of updates: 21 What is defined here is what are called "small-step" (or "sequential") ASMs, but since that is the only kind of ASM used in this paper, the modifier "small-step" will be omitted. A richer and more liberal language for small-step ASMs is provided in <ref type="bibr" target="#b39">[42]</ref>, but the simplistic form given here suffices for our purposes.</p><formula xml:id="formula_5">f([[ s]] α ) := [[u]] α (if p then f( s ) := u) ∈ P, [[p]] α = True ,</formula><p>where True is Boolean truth and the valuation given by state α is extended to tuples s in the obvious way. A set of updates is inconsistent if it contains two updates, f( ā) := b and f( ā) := b , with b = b . If Δ + (α) is empty or if it is inconsistent, then α is a terminal state. Otherwise, α has a next state α , with the same vocabulary and domain as α, and with its valuations updated as follows:</p><formula xml:id="formula_6">f α ( ā) = b if (f( ā) := b) ∈ Δ + (α), f α ( ā) otherwise.</formula><p>Remark 3.2. In <ref type="bibr" target="#b39">[42]</ref>, there was no need to deal with the output of algorithms, so there was no need to single out terminal states. Since we need to do just that here, we have slightly modified the behavior of ASMs, so that a state α has no next state when an ASM performs no updates (rather than have α also be the next state, as in <ref type="bibr" target="#b39">[42]</ref>). On the other hand, when there are only trivial updates, assigning the same value to each location as it already has, the result is an infinite, nonterminating computation. Despite this minor difference (which is but a small part of the ASM enhancements made in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref>), the proof in <ref type="bibr" target="#b39">[42]</ref> of Theorem 3.4 below goes through. Remark 3.3. Note that guards are essentially propositional formulae. If one prefers to view states as traditional structures, having both functions and relations, then one needs to extend the valuation provided by states to also give propositional formulae their usual meaning. From this more traditional viewpoint, truth values and propositional connectives need not be an actual part of states, but get their meaning from the "outside".</p><p>Obviously, every ASM satisfies the three postulates of the previous section, collectively referred to as the Sequential Postulates. Moreover, any process that satisfies the Sequential Postulates provably behaves just like some ASM: Theorem 3.4 (ASM Theorem <ref type="bibr" target="#b39">[42]</ref>). For every process satisfying the Sequential Postulates, there is an abstract state machine in the same vocabulary (and with the same sets of states and initial states) that emulates it.</p><p>We use the term "emulate" for step-by-step simulation. <ref type="foot" target="#foot_16">23</ref> The proof is based in large part on the ability to use critical terms to express all transitions of abstract states.</p><p>This emulation is effective, in that the abstract state machine provides an effective means of computing each state of a computation sequence from its predecessor, provided the latter is finitely representable. So, whenever initial states can be represented effectively-a notion that will be axiomatized in Sections 4 and 6-the whole computation becomes effective.</p><p>Methods satisfying the Sequential Postulates include: (1) the classical algorithm for greatest common divisor-which Euclid applied to both rational and irrational values, and which can be applied more generally to Euclidean rings; (2) the ancient "rectangular array" method for solving linear equations (from the two-millennia old Chinese classic, Jiuzhang suanshu <ref type="bibr" target="#b44">[47]</ref>); and (3) the very similar method of Gaussian elimination, even when the field (or division ring) over which it is applied is unspecified. On the other hand, the postulates exclude underspecified methods (like, "Guess a solution to a system of linear equalities"), and non-algorithms ("Try all numbers to see whether or not there is a solution to a system of linear equalities" or ". . . to a Diophantine equation"). They are also meant to exclude nondeterministic methods (like "pivot on any non-zero element"), randomized algorithms (like multiplying by a random matrix prior to performing Gaussian elimination), probabilistic methods (like Rabin's algorithm for testing primality), modern distributed processes (like Internet routing), or massively parallel DNA computations (for the traveling salesman problem, say). <ref type="foot" target="#foot_18">24</ref>Up to this point, we have established conditions under which an algorithm is effective to the extent that the operations in the initial state are. In addition, it is universally required that states have constructive representation. "We are", Kleene writes [52, p. 493], "dealing with discrete objects (the arguments and the result included) -it is digital, not analog, computing." Uspensky and Semenov [111, p. 9] write that, "We insist . . . that algorithms can deal directly only with constructive objects but not with finite objects not being constructive ones."</p><p>As Knuth writes [55, p. 6]: An algorithm is also generally expected to be effective. This means that all of the operations to be performed in the algorithm must be sufficiently basic that they can in principle be done exactly and in a finite length of time by a man using pencil and paper. [Euclid's Algorithm] uses only the operations of dividing one positive integer by another, testing if an integer is zero, and setting the value of one variable equal to the value of another. These operations are effective, because integers can be represented on paper in a finite manner, and because there is at least one method (the "division algorithm") for dividing one by another. But the same operations would not be effective if the values involved were arbitrary real numbers specified by an infinite decimal expansion, nor if the values were lengths of physical line segments (which cannot be specified exactly). Indeed, if all initial states of an ATS are finitely-representable objects, then Bounded Exploration ensures that all subsequent states also are, and the ASM formalism effectively computes the ensuing sequence of states, until a terminal state is obtained-if ever. But, the Sequential Postulates do not, in and of themselves, guarantee that an algorithm computes a computable function, since they allow initial states to be pre-endowed with non-computable functionalities (something that can be necessary for general algorithms, which may operate over domains like the real line or a Hilbert space).</p><p>This issue is taken up next. §4. Arithmetical effectivity. Since we are interested in the computation of functions, we may suppose that the vocabulary of an ATS includes (nullary) symbols Out for the output and In 1 , . . . , In n , for n ≥ 0 input values. (Constants are treated as nullary functions.) <ref type="foot" target="#foot_19">25</ref> Furthermore, we should insist that there is exactly one initial state, up to isomorphism, for each n-tuple of input values. An ATS operating over a domain D may be said to compute the following function:</p><formula xml:id="formula_7">{([[In 1 ]] α , . . . , [[In n ]] α ) → [[Out]] | α ∈ I, ∈ O, α ; * },</formula><p>where I and O are the sets of initial and terminal states with domain D, respectively, and ; * is the reflexive-transitive closure of its transition function ;. This input-output relation is a partial function over D, since α ; * ∈ O is a partial function, by virtue of ; being undefined for terminal states. Remark 4.1. It is often convenient to distinguish between successful and unsuccessful termination of algorithms. So, it is natural to declare that a terminal state in which the value of Out is ⊥ constitutes failure, while obtaining a defined value for the output is deemed a success. This distinction is of no consequence in the development that follows.</p><p>Church was interested in formalizing numerical algorithms, that is, algorithms that apply arithmetic operations to the natural numbers. So we should endow our states with basic arithmetic abilities.</p><p>4.1. Arithmetical states. The choice of basic functions is somewhat flexible, as we will see. But the standard "grade school" operations are what one typically has in mind. Menabrea, <ref type="foot" target="#foot_20">26</ref> in his 1842 description of Babbage's Analytical Engine, wrote <ref type="bibr" target="#b61">[68]</ref>:</p><p>We must limit ourselves to admitting that the first four operations of arithmetic, that is addition, subtraction, multiplication and division, can be performed in a direct manner through the intervention of the machine. The machine is thence capable of performing every species of numerical calculation, for all such calculations ultimately resolve themselves into the four operations we have just named. Babbage's design also included a conditional branch on zero; see, for example, <ref type="bibr">[36]</ref>. Definition 4.2 (Arithmetical state). Up to isomorphism, an arithmetical state is as follows: Its domain includes the natural numbers N, as well as the two (distinct) Boolean truth values, True and False, and some (other) distinguished value ⊥ signifying "undefined". Its operations include some or all of the "grade school" operations of arithmetic, namely, zero (0), successor (+ 1), addition (+), subtraction (-), multiplication (•), integer quotient (÷, which ignores any remainder), equality (=), and inequality (&gt;), as well as logical constants and standard operations for the Booleans. Besides symbols for all these operations, the vocabulary of an arithmetical state may also have various symbols for dynamic functions.</p><p>So that these arithmetic functions are all total, we let m -n = 0 when n &gt; m (this is "proper" or "natural" subtraction for the natural numbers) and let n ÷ 0 = ⊥ for all n. Arithmetic and Boolean operations are "typed" and "strict", so applying an arithmetic operation to a non-number or a Boolean operation to anything but truth values results in ⊥.</p><p>Dynamic operations act as "variables" in the programming sense; their values may be updated by the algorithm in the course of a computation. When all dynamic operations in a state, other than the inputs In i , are completely undefined-that is, are assigned the value ⊥ for all arguments-we say that the state is blank. This will be the case initially.</p><p>To capture the fact that Church's Thesis is dealing specifically with numerical calculations, we need the following additional postulate:</p><p>Postulate IV (Arithmetical state). Initial states are arithmetical and blank. Up to isomorphism, all initial states share the same static operations, and there is exactly one initial state for any given input values. This postulate will be considerably weakened in Section 6 to allow richer domains than the purely numeric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Arithmetical machines.</head><p>Our goal is to characterize everything that is effectively computable, starting with arithmetical states. Accordingly, we are interested in the following class of machines:</p><formula xml:id="formula_8">Definition 4.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">(Arithmetical ASM). An arithmetical ASM is an ASM satisfying the Arithmetical State Postulate (IV).</head><p>To begin with, since transitions do not change the domain, vocabulary, or static operations, we obviously have the following: Proposition 4.4. All states of an arithmetical ASM are arithmetical. In Lisp, for example, one can simply maintain an associative list (an "environment") that records the values of all dynamic functions as locationvalue pairs (f, a 1 , . . . , a n ), b . Initially, only the input values are placed on this list. At that stage, all other dynamic functions have undefined (⊥) values for all arguments, so their location-value pairs are not listed. Simulating a step of the ASM involves using equality tests to search for values in the list, in order to evaluate all the expressions in the ASM program's commands. Anything not in the list is presumed to be undefined. If an attempt is made to perform a basic arithmetic or Boolean operation on ⊥, the result is also ⊥; otherwise, native Lisp operations are applied to the arguments. The updates for assignments whose guards evaluate to true are computed using the old values stored in the list, before prepending all the new values en masse to the list, so that the effect corresponds to the parallel execution of the ASM's commands. (Values closer to the head of the list take precedence, so there is no need to erase old, stored values.) If no update is performed, or if a clash is detected between the values assigned by different updates, the program halts, and outputs the value of Out. The above corollary, rephrased, is precisely what we have set out to establish, namely:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.8 (Church's Thesis). Every numeric (partial ) function computed by an arithmetical algorithm is (partial ) recursive.</head><p>The converse also follows from Theorem 4.5, since arithmetical ASMs-by their very nature-satisfy Postulates I-IV: Proposition 4.9. Every partial recursive function can be computed by an arithmetical algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Recursive oracles.</head><p>There is nothing very special about the particular set of arithmetic operations allowed in arithmetical states. It can be seen from the proof of Theorem 4.5, and the fact that three counters suffice to compute whatsoever to Church's Thesis. So working recursion theorists should not be regarded as appealing to Church's Thesis in the sense of assuming an unproved conjecture." all recursive functions, <ref type="foot" target="#foot_21">30</ref> that it would be enough if states had just zero, successor, equality, and a handful of dynamic nullary operations-serving as counters-for all recursive functions to be computable. (Predecessor of a positive integer can be computed from zero, successor, and equality.) In fact, the (partial) functions computed by all arithmetical ASMs with n ≥ 1 inputs plus three additional dynamic nullary symbols (including Out) are precisely the (partial) recursive functions of arity n.</p><p>At the other extreme, effectiveness is maintained no matter how many additional recursive functions are permitted in arithmetical states. Since our algebraic states always include the Boolean truth values, True and False, and the undefined value, ⊥, we extend the notion of recursiveness to cover functions that may also involve these values.</p><p>In what follows, we apply any unary function, say , to n-tuples x, so ( x) will serve as shorthand for ( (x 1 ), . . . , (x n )).</p><p>Let B ⊥ stand for {True, False, ⊥} and let be the following bijection from N to N B ⊥ :</p><formula xml:id="formula_9">(x) = ⊥, False, True if x = 0, 1, 2, respectively, x -3 i fx &gt; 2.</formula><p>We say that a function f of arity n over N B ⊥ is (partial) recursive if its numeric conjugate • f • -1 is (partial) recursive in the ordinary, purely numeric sense. Our terminology is sensible, since a numeric function can be recursive in both senses, or partial recursive in both senses, or else it is not partial recursive in either sense. The quotient operator (÷) in arithmetical states, for instance, which is only partially defined, is recursive in this wider sense:</p><formula xml:id="formula_10">m ÷ n = ⊥ if n = 0, m/n if n &gt; 0.</formula><p>A divisibility predicate defined as</p><formula xml:id="formula_11">n | m = ⎧ ⎪ ⎨ ⎪ ⎩ ⊥ if n = 0, True if n &gt; 0 and n × (m ÷ n) = m, False otherwise is also recursive in this sense.</formula><p>The proof of Theorem 4.5 holds fast even when initial states incorporate many such recursive functions (because they are all programmable like basic arithmetic is). Later, we will make use of the following variant of Corollary 4.6, which uses this slightly more general notion of recursive function and which allows for arbitrarily many recursive oracles: Corollary 4.10. Every partial function computed by a state-transition system satisfying the Sequential Postulates, whose states are arithmetic and whose initial states only have recursive (possibly partially defined ) operations, is partial recursive.</p><p>Recall that the operations of algebraic states are always total, formally speaking, though they need not be numeric. So, when this corollary speaks of a partially-defined function f as being recursive, it means that the total function f, whose range includes ⊥, is recursive (not just partial recursive) in the expanded sense given above.</p><p>The partial function computed by such an algorithm, on the other hand, may be only partial recursive, since the algorithm might not terminate for some inputs. For example, there is an algorithm that satisfies the conditions of the above corollary and which interprets Turing machines that act on string-representations of the natural numbers. The interpreter computes the following partial recursive function:</p><formula xml:id="formula_12">TM(m, n) = ⎧ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎩ z if machine number m on input n</formula><p>terminates with numeric output z, ⊥ if machine number m on input n aborts or terminates with non-numeric output.</p><p>When machine number m does not terminate at all on input n, the algorithm also does not terminate, and TM(m, n) returns nothing, not even ⊥.</p><p>In Section 6, we will see how to incorporate richer domains than mere arithmetic. §5. Relative effectivity. Church provided some justifications for his claim that "every function, an algorithm for the calculation of the values of which exists, is effectively calculable" by means of recursion <ref type="bibr">[23, p. 357</ref>]. But, as Sieg <ref type="bibr">[94, p. 78]</ref> clarifies, Church's argument lacked a formal analysis of the recursiveness of the individual steps in the performance of an algorithm, a point regarding which Church was quite aware. (See also <ref type="bibr">[103, p. 291</ref>].) So, as Shoenfield <ref type="bibr">[91, pp. 120-121]</ref> also makes clear, it all boils down to the effectivity of the operations that are applied at each step of a computation.</p><p>We have seen in the previous section that effectiveness is guaranteed by the Sequential Postulates and the Arithmetical State Postulate. We also saw that additional recursive functions in initial states do not increase computational power: Bounded Exploration guarantees that each single step is in fact effective, because it allows only a bounded number of applications of those initial functions to values derived in the same fashion during the preceding finitely many steps. Adding non-recursive functions to the initial state, on the other hand, is a different story, taken up next.</p><p>A (partial) function f is said to be (partial) recursive relative to a set of functions B if its values can be inferred by equational reasoning from a set of (true) equations involving B. This is equivalent to stating that f can be obtained by composition, primitive recursion, and/or minimization from the oracles B. See [49, §63]. We assume that B always includes zero, successor, and equality. The ordinary recursive functions are just those that are defined in this way from only zero, successor, and equality. Theorem 5.1. A numeric function is partial recursive relative to "oracular" functions B if and only if it is computable by an ASM operating over domain N B ⊥ and initial functions B (containing at least zero, successor, and equality), but no other functions defined in its initial state.</p><p>Proof. It is an ordinary programming exercise to show how to obtain an ASM for the composition of the functions computed by two given ASMs, or for primitive recursion, given ASMs for the zero and non-zero cases, or for iterating to look for the minimal input value (if there is one) such that a given ASM returns zero. So, by induction on the construction of a function that is partial recursive in B, we know that there is an ASM that computes any such function, given oracles for B.</p><p>On the other hand, one can write an interpreter for such ASMs, which can be programmed in any standard programming language, 28 except for calls to the oracles. Such an interpreter can in turn be implemented in terms of the functions in B, using composition, primitive recursion, and minimization. 29  Clearly, ASMs necessarily satisfy the Sequential Postulates, so any relatively recursive function can be computed by a process satisfying those postulates. By Theorems 3.4 and 5.1, the converse is also true: Corollary 5.2. The only numeric functions that are algorithmically computable by a process satisfying the Sequential Postulates are those that are partial recursive relative to the initial functions.</p><p>We have, then, what Kleene [49, p. 332] (paraphrased) refers to as: Thesis I * † . Every (partial) function which is effectively calculable relative to some initial functions is (partial) recursive relative to those functions. This version of Church's Thesis follows from the Sequential Postulates alone, without Arithmetical State. The clause "relative to some initial functions" means that the algorithm is allowed to apply "black box" primitive operations B. The results of the previous section are obtained whenever B is a subset of the recursive functions.</p><p>In the development so far, all functions operate over numbers or truth values. But one can add as many non-numerical values to the domain as one wishes to more naturally mimic human "notations" to keep track of things while in the midst of arithmetic calculations. Moreover, one may incorporate algorithmic operations on strings of symbols, or on other kinds of objects, as shown in the next section. §6. Arithmetized effectivity. We consider now algorithms that operate over larger domains than just natural numbers, domains that may include rationals, vectors, matrices, strings, lists, graphs, etc. To work with such objects, an algorithm would be provided with operations like division of rationals, vector addition, matrix multiplication, string concatenation, list sorting, or graph complementation.</p><p>6.1. Arithmetizable states. Indeed, one might naturally employ nonnumerical capabilities in the process of computing what is a strictly numeric function. The object domain of such an algorithm would include elements besides numbers and truth values, and its initial states would include operations over those auxiliary domains and operations connecting those domains with the natural numbers, in addition to purely arithmetic operations.</p><p>As we are only interested in effective computations, it is necessary to limit the initial repertoire of operations to what is undeniably effective. Anything more complicated should be programmed, just as sophisticated arithmetic operations are.</p><p>Let the enriched object domain of an algorithm be D ⊇ N B ⊥ and let : D → N B ⊥ be an injection of that domain into the natural numbers that preserves the special elements B ⊥ = {True, False, ⊥}. We will use N to denote the restriction N of to the natural numbers in D. We will say that a function f of arity n over D is -recursive if there exists a recursive function f over N B ⊥ of the same arity such that f(</p><formula xml:id="formula_13">( x)) = (f( x)) for all x ∈ D n , that is, if • f = f • .</formula><p>In other words, f is -recursive if there is some recursive extension f of the function f over the image (D) whose graph is {( ( x), (y)) | ( x, y) ∈ f}. Recursiveness of the witness f is meant in the expanded sense of Section 4.4. Note that the witness is not necessarily unique, since need not be onto; what exactly f produces for arguments not all in (D) is immaterial.</p><p>We adopt a generous version of the presumption that initial operations are effective:</p><p>Postulate IVb (Arithmetizability). Initial states are blank. Up to isomorphism, all initial states share the same domain and static operations, and there is exactly one initial state for any given numerical input values. There is an encoding whose restriction N to the natural numbers is recursive (in the ordinary sense), and via which all static operations of the initial states are -recursive.</p><p>The completely undefined dynamic functions of blank states are triviallyrecursive for any encoding (they are witnessed by a completely undefined function), as are the nullary input operations (witnessed by their images under ). Note that this postulate places no demands on the dynamic functions that evolve over the course of a computation, only on the static operations of initial states. Remark 6.1. It is quite natural to demand that an encoding and its inverse be "effective" in some informal sense (cf. <ref type="bibr">[82, p. 27]</ref>). We demand less: only that the encoding N of the natural numbers N within the domain D be effective. Indeed, as long as the successor function s on the natural numbers is -recursive, then N is in fact recursive, since (0) is some constant and (s(n)) = s( (n)), where s is the recursive witness for successor (cf. <ref type="bibr" target="#b73">[81,</ref><ref type="bibr" target="#b17">18]</ref>).</p><p>A similar approach to effectiveness in non-numerical domains D is taken in the field of computable algebra, namely that operations on D are tracked by homomorphic images in N (e.g., <ref type="bibr" target="#b31">[34,</ref><ref type="bibr" target="#b56">64,</ref><ref type="bibr" target="#b71">79]</ref>), but our conditions on the encoding are noticeably weaker.</p><p>Remark 6.2. When, in addition to N being recursive, the image N (N) it gives of the natural numbers is recursive (as in <ref type="bibr" target="#b56">[64,</ref><ref type="bibr" target="#b71">79]</ref>), then the inverse of N is also (formally total and) recursive:</p><formula xml:id="formula_14">-1 N (x) = min n. (n) = x if x ∈ (N), ⊥ otherwise.</formula><p>In that case, every recursive function f over N B ⊥ is automaticallyrecursive, since its conjugate -1 N • f • N by N is its recursive witness. However, Lemma 6.8 and Theorem 6.4 below hold even when N has a perversely non-recursive image. So, we do not impose this otherwise perfectly reasonable requirement on encodings. See the discussion in Section 6.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Arithmetized algorithms.</head><p>We will say that an algorithm (and its set of static operations) operating over a domain D is arithmetizable if there is an encoding of D such that the conditions of the Arithmetizability Postulate are fulfilled.</p><p>We generalize now the notion of arithmetical algorithm (Definition 4.2) to allow for basic operations over other domains: Definition 6.3 (Arithmetized algorithm). A state-transition system satisfying the Sequential and Arithmetizability Postulates is called an arithmetized algorithm.</p><p>This gives the following variation on Church's Thesis (Theorem 4.8) for enriched domains: Theorem 6.4. Every numeric (partial ) function computed by an arithmetized algorithm is (partial ) recursive.</p><p>The special case when the object domain is not enriched (D = N B ⊥ ) was already dealt with in Section 4.</p><p>We will make use of several easy lemmata. Proof. All the extra elements introduced by the enlarging of the domain D of α are inaccessible in (i.e., there is no ground term t over the vocabulary for which <ref type="bibr">[[t]</ref>] ∈ D \D), and, therefore, those extra domain elements have no influence on transitions. Specifically, the update set Δ(α) for M is identical to Δ( ) for M whenever α ⊆ .</p><p>Let : D → D be an injection from domain D to domain D, and suppose that algebras α and have domains D and D, respectively, and share the same vocabulary. Then one says that α is embedded in via , written as α → , if (α) ⊆ , where is the bijection obtained by restricting to its image (D) ⊆ D. This implies (using Lemma 6.5) that</p><formula xml:id="formula_15">[[t]] = [[t]] e (α) = ([[t]] α ) = ([[t]] α ) ∈ (D),</formula><p>for all (ground) terms t over their joint vocabulary. For any collection S of abstract states, let the corresponding collection S (for the embedding ) be { | ∃ ϕ ∈ S. ϕ → }, closed under isomorphisms.</p><p>Combining the above lemmata, we get the following: Lemma 6.7. Suppose an ASM M with states S has a computation α ; * α * for states α and α * with domain D. Suppose further that α → via some injection : D → D. Then an ASM M with exactly the same vocabulary and the same program as M , but with states S, engenders the corresponding computation ; * * ( , * ∈ S), where α * → * . Furthermore,</p><formula xml:id="formula_16">[[t]] * = ([[t]] α * ),</formula><p>for all (ground ) terms t over the vocabulary of M .</p><p>Proof. By Lemma 6.5, M also has a computation (α) ; * (α * ), and, by repeated application of Lemma 6.6, M has a computation ; * * , with (α * ) ⊆ * , for any such that (α) ⊆ . In other words, ; * * ← α * , when ← α ; * α * . Accordingly, we also have</p><formula xml:id="formula_17">[[t]] * = [[t]] e (α * ) = ([[t]] α * ),</formula><p>for all terms t. Lemma 6.8. If g : N → N is a partial recursive function and N :</p><formula xml:id="formula_18">N → N is a recursive injection, then N • g • -1</formula><p>N is also partial recursive. Proof. Since the injection N is recursive, its inverse -1 N (x) = min n. (n) = x is partial recursive. Its composition with other partial recursive functions is partial recursive.</p><p>Proof of Theorem 6.4. Suppose A is the arithmetized algorithm operating over the rich domain D and : D → N B ⊥ is the postulated injective encoding. By the ASM Theorem (Theorem 3.4), algorithm A (which satisfies Postulates I-III) is emulated by an ASM M that computes the same numeric function g as does A over D. Up to isomorphism, M has one initial state for every possible combination of numeric inputs.</p><p>Consider an ASM M with the same vocabulary and program as M , but with states S, and with initial states in which every static symbol f is interpreted as its witness f, each dynamic symbol other than the input symbols is completely undefined, and input symbols take all possible values in N. Recall that N is postulated to be recursive and that the partial function g computed by A is numeric. Hence, it follows from Lemma 6.8 that g =</p><formula xml:id="formula_19">N • g • -1</formula><p>N must also be partial recursive, as claimed. And if g is total, it is recursive. Remark 6.9. Suppose we wish to arithmetize a many-sorted domain</p><formula xml:id="formula_20">D = D 0 D 1 • • • D m {⊥}, m ≥ 1.</formula><p>Specifically, we are assuming that the domain is partitioned into m + 1 disjoint sorts: the natural numbers D 0 = N, zero or more auxiliary domains D 1 , . . . , D m-1 , and the Booleans, D m . (The undefined value, ⊥, is part of the domain but does not belong to any of the sorts.) It may be convenient to arithmetize such a D, sort by sort: Let N be stratified into m disjoint parts N j , 0 ≤ j &lt; m, via m stratification injections j : N → N, such that j N j ⊆ N and j (N) ⊆ N j for each j. Then, given individual embeddings j : D j → N, and letting 0 : N → N and m , m : B ⊥ → B ⊥ all be identity maps (so that the natural numbers and the Boolean truth values are preserved), we can define the encoding (x) = j ( j (x)) for x ∈ D j , and (⊥) = ⊥. Let (x) = j (x) for x ∈ D j and (⊥) = ⊥. The restriction N of such a to N is recursive as long as the given stratification function 0 for encoded natural numbers is recursive. If -1 0 is also recursive, then all purely numeric functions over D are in fact -recursive, as explained in Remark 6.2. Compare <ref type="bibr" target="#b4">[5]</ref>. Example 6.10. One convenient stratification mapping is obtained by partitioning the natural numbers into m residue classes N j modulo m, corresponding to the m sorts of D. The mappings and their inverses are easily computable, as follows:</p><formula xml:id="formula_21">j (x) = mx + j, -1 (x) = x ÷ m,</formula><p>for each j, 0 ≤ j &lt; m, where ÷ gives the integer quotient. Since this -1 does not depend on the stratum, we have omitted the subscript j. The classification function κ(x) = x mod m is also effective. This regimen is tantamount to the standard type-tagging scheme used in programming languages, and is clearly recursive. Example 6.11. As an example of such a stratified encoding, consider an algorithm that uses finite strings over some alphabet Σ, in addition to the natural numbers. It is not hard to conjure up a mapping that encodes finite strings from the auxiliary domain D 1 = Σ * as natural numbers. For example, if Σ is a binary alphabet, then the injection 1 (uv) could be 2 i (2j + 1), where u is the prefix of all leading zeroes, i is the length of u, and j is the binary value of the suffix v. Composing this with the stratification mappings of the previous example gives the following family of domain encodings: 0 (n) = 2n for numbers n; 1 (w) = 2 1 (w) + 1 for strings w. Remark 6.12. When all the operations (save equality) of an ATS are simply typed, the condition needed for arithmetizability can be simplified by ignoring the stratification. A simple type takes the shape S 1 × • • • × S n → S 0 (n ≥ 0), where every S i is one of the sorts D k of the domain D, meaning that f(x 1 , . . . , x n ) yields an element of S 0 or ⊥ whenever x i ∈ S i for all the arguments x i , and that f(x 1 , . . . , x n ) yields ⊥, otherwise. Let j and j be as described in Remark 6.9; suppose the j and their inverses are recursive as in Example 6.10; and let be the composite encoding defined in that remark. Consider a function f with result sort S 0 = D j and input sorts S having indices ī. Define the tuple-mapping ī applied to a list of arguments x to be the result of applying the corresponding functions</p><formula xml:id="formula_22">ı i to each component x i of x. With this machinery, a function f is -recursive if it is -recursive, since if f is the witness of -recursiveness, then f = -1 ī • f • j is a recursive witness of -recursiveness. To wit, • f = • ī • -1 ī • f • j = • f • j = f • j • j = f • .</formula><p>Note that we are not insisting that the encodings j are effective in any sense; it is enough that the stratification is effective for the requirements of the postulate to be met. Example 6.13. To manipulate strings, Post's tag machines <ref type="bibr" target="#b69">[77]</ref> use the following all-powerful set of basic string operations:</p><p>• Read: Σ * → Σ (read first letter);</p><p>• Delete: Σ * → Σ * (delete first letter);</p><p>• Add: Σ * × Σ → Σ * (add letter to end).</p><p>The encoding 1 of Σ * given in Example 6.11 turns these basic string operations into combinations of addition, multiplication, exponentiation, and taking remainders. For example, Read(n) would return 2 = 1 (0) if n is even, and 3 = 1 (1) if it's odd.</p><p>Remark 6.14. When the types of operations are the union of simple types (like the "overloaded" &gt; operator in many programming languages, which compares strings as well as numbers and returns a Boolean value in both cases), it is enough if there are recursive witnesses for every combination of input types, since operations can be "dispatched" to the appropriate witness based on the sorts of the arguments. (By "union" we mean that the graph of the function on correctly-typed arguments is the union of the graphs of simply-typed functions on their correct types.) For example, suppose a domain D includes three sorts D 0 , D 1 , and D 2 , and some function f : D → D is the union of two simply-typed unary functions f 1 : D 1 → D 0 and f 2 : D 2 → D 0 . Suppose further that there are witnesses f 1 , f 2 : N → N for some i as in the previous remark. Then we can use the stratification scheme of Example 6.10 and note that the recursive function</p><formula xml:id="formula_23">f(n) = ⎧ ⎪ ⎨ ⎪ ⎩ 0 ( f 1 ( -1 (n))) if κ(n) = 1, 0 ( f 2 ( -1 (n))) if κ(n) = 2, ⊥ otherwise</formula><p>is a witness that f is -recursive for (x) = j ( j (x)), as in Remarks 6.9 and 6.12.</p><p>Remark 6.15. When operations have generalized types and return results of more than one sort (as can list operations in Lisp), -recursiveness with respect to a more complicated encoding of all the sorts of elements of D, as in Remark 6.9, is called for.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Turing's Thesis.</head><p>As a byproduct of the ASM Theorem (Theorem 3.4) and the above result (Theorem 6.4), one obtains a straightforward method of showing that other deterministic models of computation cannot compute more than the partial recursive functions.</p><p>Consider, by way of example, Markov's normal algorithms <ref type="bibr" target="#b58">[66]</ref>, which repeatedly apply a series of substring-replacement rules of the form u → v to a given input string. To connect effectiveness of normal algorithms with that of the recursive functions, one needs to show that the operations of testing for the occurrence of a substring u in a string w and of replacing the first such occurrence (of u in w) with another substring (v) are both arithmetizable. This is quite easy with an encoding in the style of that given in Example 6.11 above. By the ASM Theorem, issues of control-like that of determining the first applicable rule, if any, in a Markov program, and of terminating as soon as one of the rules that are marked "final" is appliedcan always be handled effectively, using numbers to represent control states. As a consequence of the previous theorem, one may conclude that regardless of how numerical inputs are given as strings to normal algorithms (whether a number n is represented by a string of n marks in "tally" notation, or-more compactly-in decimal notation, or using any other convention), as long as the homomorphic image under of that number-representation function is recursive, one can be sure that only partial-recursive functions can be computed.</p><p>Just as we have shown above that the recursive functions are the only numeric functions that can be computed by an effective algorithm, we could likewise have shown that Turing machines compute all effective string functions, by adopting some basic set of primitive string operations, like Post's (see Example 6.13), and postulating that initial states of string algorithms are endowed with nothing additional. In other words, the exact same approach as that taken above gives an axiomatization and proof of Turing's Thesis regarding string-based effective computation. We have seen how to enrich an arithmetic model with strings. By mapping numbers to strings, instead of strings to numbers, one gets the analogous enrichment of string-based machines, empowering them to compute all recursive number-theoretic functions.</p><p>6.4. Significance. Theorem 6.4 and its proof demonstrate the full strength of Church's Thesis: No matter what additional data structures an algorithm has at its disposal, it cannot compute any non-recursive numeric functions, since essentially the same computations can be performed over the natural numbers. The ASM Theorem was crucial in this argument, enabling us to cover all possible algorithms, regardless of the data structures employed.</p><p>To axiomatize effectiveness of algorithms operating over such domains, we have formalized requirements for domain encodings. Church <ref type="bibr">[23, p. 345</ref>] asserted that non-numerical domains "can be described in number-theoretic terms". Particular encodings (like G ödel numberings) are used all the time; some are more "natural" than others. Rogers <ref type="bibr">[82, p. 27]</ref> demands the following of such encodings:</p><p>The coding is chosen so that (a) it is itself given by an informal algorithm in the unrestricted sense; and (b) it is reversible; i.e., there exists an informal algorithm (in the unrestricted sense) for recognizing code numbers and carrying out the reverse "decoding" mappings from code numbers to nonnumerical entities. Furthermore, it is stipulated that a coding shall be used only when (c) an informal algorithm exists for recognizing the expressions that constitute the uncoded, nonnumerical class.</p><p>Demanding the existence of "informal algorithms" for the encoding and decoding of the additional data structures, however, is problematic. And there is no accepted formal sense of effectiveness that covers operations over arbitrary domains. (See <ref type="bibr" target="#b64">[72,</ref><ref type="bibr" target="#b80">88,</ref><ref type="bibr" target="#b18">19]</ref> for discussions of this problem.) Instead, we have insisted only that-under some representation-the homomorphic images of the basic native operations, which track the native operations on the natural numbers, be effective in the technical, recursive sense, and that the mapping N of the natural numbers alone be recursive. We propose that such encodings be deemed "reasonable"; they provide just the right amount of effectiveness. With this approach, recourse to informal considerations is not needed.</p><p>As Ada Lovelace asserted in 1843 <ref type="bibr" target="#b61">[68]</ref>:</p><p>Many persons who are not conversant with mathematical studies imagine that because the business of [Babbage's Analytical Engine] is to give its results in numerical notation, the nature of its processes must consequently be arithmetical and numerical rather than algebraical and analytical. This is an error. The engine can arrange and combine its numerical quantities exactly as if they were letters or any other general symbols; and in fact it might bring out its results in algebraical notation were provisions made accordingly. §7. Conclusion. Our goal in this work has been to remedy the situation described thus by Montague <ref type="bibr">[72, p. 432]</ref>: "Discussion of Church's thesis has suffered for lack of a precise general framework within which it could be conducted." We have shown how the Sequential ASM Postulates provide just such a framework, and how Church's Thesis follows from them, plus the postulate that nothing uncomputable is given ab initio.</p><p>We saw in the introduction that G ödel surmised that Church's Thesis may follow from appropriate axioms of computability. But, as far as we can ascertain, no complete axiomatization has previously been presented in the literature. In fact, the challenge of proving Church's Thesis is first in Shore's list of "pie-in-the-sky problems" for the twenty-first century <ref type="bibr" target="#b20">[21]</ref>. Whereas Kripke <ref type="bibr">[60, p. 14]</ref> feels that it is "a very difficult task", Friedman <ref type="bibr" target="#b30">[33]</ref> predicted that sometime in this century, "There will be an unexpected striking discovery that any model of computation satisfying certain remarkably weak conditions must stay within the recursive sets and functions, thus providing a dramatic 'proof' of Church's Thesis."</p><p>Our axiomatization provides a small number of principles that imply Church's Thesis, and focuses attention on the axioms. Thus, to the extent that one might entertain the notion that there exist non-recursive effective functions, one must reject one or more of these postulates. 31 The need for "continual verification" of the legitimacy of Church's identification of recursiveness with effectivity, to which Post <ref type="bibr">[75, p. 105]</ref> referred, can now center around the universality of the individual axioms.</p><p>7.1. Previous analyses. Turing long ago dissected the essentials of computation. (See Section 1.2.) As G ödel <ref type="bibr">[38, p. 72]</ref> commented: "Turing's work gives an analysis of the concept of 'mechanical procedure' (alias 'algorithm' or 'computation procedure' or 'finite combinatorial procedure'). This concept is shown to be equivalent with that of a Turing machine." See also Kleene in <ref type="bibr">[53, p. 30]</ref>:</p><p>Computation, theoretically considered (to be performable for all possible values of the independent variables), is idealized. Turing's analysis takes this idealized aspect of it into account. A Turing machine is like an actual digital computing machine, except that 31 For one well-known example of the claim that there is an "effective" mode of reasoning that computes a non-recursive function, see Lucas <ref type="bibr" target="#b55">[63]</ref>: "One can feel confident without having an effective method within the meaning given to effective-i.e., programmable into a Turing machine. . . . It is not necessary that all reasoning must in this sense be effective. And in the sense in which reasoning might be necessarily effective, effectiveness does not imply computability."</p><p>(1) it is error free. . . , and (2) by its access to an unlimited tape it is unhampered by any bound on the quantity of its storage of information or "memory". Turing <ref type="bibr" target="#b96">[107]</ref> stressed the finite limitations on exploration of state by an "idealized" human computer, but his analysis was on an informal level, and related only to two-dimensional symbolic manipulations, though his interests extended into higher dimensions <ref type="bibr" target="#b98">[110]</ref>. Turing analyzed human reckoning, but there are many things that modern computers (let alone future computers) can do that are very hard or even impossible for a human computer to imitate.</p><p>Kolmogorov <ref type="bibr" target="#b49">[56]</ref> generalized Turing's analysis, insisting on the "limited complexity" of operations and on the locality of information needed to determine the next state, but he too gave no precise characterizations. Kolmogorov and Uspensky <ref type="bibr" target="#b50">[57]</ref> and Sieg and Byrnes <ref type="bibr" target="#b90">[101]</ref> proposed sufficient conditions on labeled graphs to ensure boundedness of complexity and locality of action for Kolmogorov-like machines, but their conditions are overly restrictive, and cannot characterize effective computation, in its generality.</p><p>Gandy <ref type="bibr" target="#b32">[35]</ref> proposed postulates for human and machine effectivity. He defined a model, "Gandy machines", whose states are described by hereditarily finite sets. Effectivity of Gandy machines is achieved by bounding the rank (depth) of states, insisting that they be unambiguously assemblable from individual "parts" of bounded size, and requiring that transitions have local causes. Gandy's ideas have been expounded and simplified by Sieg and Byrnes <ref type="bibr" target="#b91">[102]</ref>. <ref type="foot" target="#foot_22">32</ref> Gandy admitted that his model cannot emulate all computations <ref type="bibr">[35, p. 146]</ref>: "Despite the liberality advertised . . . there is a limit to what a machine can do in a single step." <ref type="foot" target="#foot_23">33</ref>An alternative approach to proving Church's Thesis has been suggested by <ref type="bibr">Kripke [61]</ref>, based on "Hilbert's Thesis" that "any mathematical argument . . . can be formalized in some first-order language", and-in particulararguments about the effects of applying the instructions of an algorithm can be so formalized.</p><p>7.2. This work. Unlike all previous formalizations of effectiveness, the postulates proposed here apply to transition systems with arbitrary structures as states. Our abstract states can hold one-dimensional tapes (as in Turing's original work <ref type="bibr" target="#b96">[107]</ref>), two-dimensional arrays (as extended in <ref type="bibr" target="#b84">[93]</ref>), bounded-degree graphs (as in Kolmogorov machines <ref type="bibr" target="#b49">[56,</ref><ref type="bibr" target="#b50">57]</ref>), or boundedrank hereditarily finite sets (as in Gandy machines <ref type="bibr" target="#b32">[35,</ref><ref type="bibr" target="#b91">102]</ref>). But, in fact, states can also be multi-dimensional grids, or unbounded-degree graphs, or sets with unbounded rank, so long as the program satisfies the Bounded Exploration Postulate. In this sense, we are truer to the claim of Kolmogorov and Uspensky <ref type="bibr" target="#b50">[57,</ref><ref type="bibr" target="#b15">16]</ref>: "We . . . are talking not about a reduction of an arbitrary algorithm to an algorithm in the sense of our definition, but [contend] that every algorithm essentially satisfies the proposed definition."</p><p>Our postulates of effectivity relate to these arbitrary structures-without encoding complete states as numbers, strings, or graphs. Moreover, we place no restrictions on state transitions, other than the respecting of isomorphism and Bounded Exploration. We do not straitjacket transitions to follow any particular format-as, for example, in Turing's formalism. The critical restriction, the one that makes individual steps effective, is Bounded Exploration.</p><p>Abstract states are what allow this crucial Bounded Exploration Postulate to be phrased at the abstract level of algorithms, rather than on some particular representation level. Our analysis culminated in Theorem 6.4, which is Church's Thesis expressed so as to allow algorithms to employ arbitrary non-numerical auxiliary domains, while placing no restrictions on the effectiveness of the encoding of those domains as numbers.</p><p>On account of their abstractness, our postulates apply equally well to all sequential machine models in the literature. The three Sequential Postulates apply as is; the fourth axiom, that initial states include only undeniably effective operations, would need to be expressed in terms of the domain and primitive operations of the specific computational model. Some might aver that convoluted structures can be encoded linearly or graphically, and that complex transitions can be decomposed into smaller steps, and then effectiveness of the encoded operations can be established. But it is far from evident that computational power is not increased or decreased by particular representations. It can be the case that the implementation f of what is an intuitively effective function f over some rich domain D does not satisfy axioms of effectivity expressed on the level of the domain D in which it is implemented-simply because the choice of encoding is not ideal. In fact, there is no a priori reason to believe that there always is a reasonable encoding such that everything that can be done effectively (in the intuitive sense) in one domain can be done effectively in another. On the other hand, it may be that f is uncomputable in one model of computation, buthaving been encoded-its implementation f becomes computable over D . Given a sufficiently malevolent encoding, one can "effectively" compute blatantly uncomputable functions. (See <ref type="bibr" target="#b81">[89,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b73">81]</ref> for discussions of this point.) It is, therefore, imperative to deal with effectiveness in the same terms as those in which the algorithm operates-as undertaken here.</p><p>7.3. Related issues. Some of Gandy's considerations were motivated by physical limitations of machines, like "the finite velocity of propagation of effects and signals" <ref type="bibr">[35, p. 135]</ref>. We, on the other hand, are not concerned at all with what Gandy calls "Thesis M" (also called the "Physical Church-Turing Thesis"), namely, that whatever can be calculated by a physical machine can be computed by a Turing machine, a claim regarding limitations that physics may, or may not, place on physical computing devices. <ref type="foot" target="#foot_24">34</ref> As already pointed out, our analysis is not specific to a computational model operating over hereditarily finite sets, but applies to arbitrary state-transition systems with arbitrary structures for states. For a recent critique of Gandy, see <ref type="bibr" target="#b79">[87]</ref>. For another set of (informal) physical postulates, see <ref type="bibr" target="#b29">[32]</ref>.</p><p>We should point out that, nowadays, one deals daily with more flexible notions of algorithm, such as interactive and distributed computations. To capture such non-sequential processes and non-classical algorithms, additional postulates are required. For these developments, see <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">37]</ref>.</p><p>We also do not address the question of the computational capabilities of the human mind, what Shagrir <ref type="bibr">[87, p. 223</ref>] refers to as "The Human version of the Church-Turing Thesis" (more generally called the "AI [Artificial Intelligence] Thesis"), that (idealized) humans cannot compute any uncomputable function. Nevertheless, it does follow from our axiomatization that any state-transition mechanism that computes a non-recursive function, whether physical or biological, must violate (at least) one of the Sequential Postulates, and/or must include at least one non-recursive function in its initial states.</p><p>See <ref type="bibr">[74, pp. 101-123</ref>] and <ref type="bibr" target="#b23">[26]</ref> for discussions of these and other variants of Church's Thesis.</p><p>Finally, the question of what effectiveness means for computations over arbitrary, non-numerical domains is taken up in <ref type="bibr" target="#b56">[64,</ref><ref type="bibr" target="#b54">62,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref>, and elsewhere.</p><p>Acknowledgments. We thank Nikolaj Bjørner, Andreas Blass, Maria Paola Bonacina, Martin Davis, Andreas Glausch, Pierre Lescanne, Wilfried Sieg, Robert Soare, and Moshe Vardi for their valuable comments.</p><p>[The Sliced Bread Thesis:] "Turing machine = coolest idea since sliced bread" Even a rabid fan of the Turing machine concept, who firmly believes the Sliced Bread Thesis, would not claim that the Sliced Bread Thesis is formalizable in ZFC (or whatever). Possibly one could come up with an axiomatic definition of "effective algorithm" that is not trivially equivalent to the definition of a Turing machine, and then one could formalize Church's Thesis and ask for a proof of it. Shoenfield worked on this for a while, I am told, but didn't get very far.</p><p>-Tim Chow, Foundations of Mathematics (FOM) Forum (January <ref type="bibr" target="#b11">12,</ref><ref type="bibr">2004)</ref> </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>4 . 3 .Corollary 4 . 6 .</head><label>4346</label><figDesc>Church's Thesis. It follows from Theorem 4.5 that: Every numeric function computed by a state-transition system satisfying the Sequential Postulates, and provided initially with only basic arithmetic, is partial recursive. Proof. By the ASM Theorem (Theorem 3.4), every such algorithm can be emulated by an ASM whose initial states are provided only with the basic arithmetic operations. By Theorem 4.5, such an ASM computes a partial recursive function. Definition 4.7 (Arithmetical algorithm). A state-transition system satisfying the Sequential and Arithmetical Postulates is called an arithmetical algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 6 . 5 .</head><label>65</label><figDesc>Suppose α ; * α * by a computation of an ATS A, and let = (α) for some isomorphism . Then one also has ; * * via A, where * = (α * ). Furthermore,[[t]] * = ([[t]] α *), for all (ground ) terms t over the vocabulary of A. Proof. To begin with, by the nature of isomorphisms, [[t]] = ([[t]] α ) for all t. By virtue of the Abstract State Postulate (II), the isomorphism is preserved by every transition of A, from which it follows that [[t]] = ([[t]] α ) whenever α ; α and ; = ( ). The result follows by induction on the computation α ; * α * . Let D ⊆ D for domains D and D, and suppose that algebras α and have domains D and D, respectively, and share the same vocabulary. Then α is called a subalgebra of , denoted α ⊆ , if the operations of are closed on the subdomain D and every operation f α of α is the restriction f D of the corresponding operation f of . This implies, of course, that [[t]] α = [[t]] ∈ D for all (ground) terms t over their joint vocabulary. Lemma 6.6. Suppose an ASM M with states S has a transition α ; α for states α and α with domain D ⊆ D. Suppose further that α ⊆ , where Dom = D. Then an ASM M with exactly the same vocabulary and the same program as M , but with extended states { | ∃ ϕ ∈ S. ϕ ⊆ } (closed under isomorphisms), engenders the corresponding transition ; ( for extended states , ), where α ⊆ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Modulo isomorphism, all states of M have domain N B ⊥ . Restricting an initial state α of M to (D) gives a state α that is isomorphic by to an initial state α of M , since the restriction f (D) of each witness f is isomorphic to the original static operation f of M . Static arithmetic operations of M are reinterpreted as their witnesses in M , but Boolean operations and equality remain intact. By the Arithmetizability Postulate, M 's initial states provide recursive functions only. Since Definition 4.2 does not require arithmetical states to have any specific operations, other than equality and Boolean connectives, M does in fact satisfy the requirements of Corollary 4.10, and must compute a recursive function g. Consider any computation α ; * α * , where α is an initial state of M and α * is a terminal state. The ASM M has an initial state α such that α → α, and wherein [[In i ]] b α = ([[In i ]] α ) for each input In i . By Lemma 6.7, there is a corresponding computation α ; * α * for M , such that α * → α * . Furthermore, by that lemma, z = (z), where z = [[Out]] α * is the output of M and z = [[Out]] b α * is the output of M . By construction, x = ( x), where x = [[In]] α are the inputs to M and x = [[In]] b α are the inputs to M . By convention, z = g( x) and z = g( x) are the output values computed by M and M , respectively. It follows that (g( x)) = (z) = z = g( x) = g( ( x)), for all x, or, put another way, g • = • g.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>"10. Entscheidung der Lösbarkeit einer Diophantischen Gleichung. Eine Diophantische Gleichung mit irgend welchen Unbekannten und mit ganzen rationalen Zahlencoefficienten sei vorgelegt: man soll ein Verfahren angeben, nach welchem sich mittelst einer endlichen Anzahl von Operationen entscheiden läßt, ob die Gleichung in ganzen rationalen Zahlen l ösbar ist." https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="24" xml:id="foot_2"><p>Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.NATURAL AXIOMATIZATION OF COMPUTABILITY</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms. NATURAL AXIOMATIZATION OF COMPUTABILITY</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Church was Turing's official Ph.D. advisor at Princeton.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>The converse, namely, that all recursive functions are effectively computable, is almost universally held. (Goodstein is an exception [36, n. 29]; Kalmár is not[6, n. 10].) Kleene claims to have proved this (e.g.,[50, p. 300]), though some (e.g., Folina in<ref type="bibr" target="#b28">[31]</ref>) contend that such an argument, inasmuch as it too involves the informal notion of effectiveness, should not be designated a "proof". Cf. Gödel's assertion[38, p. 44]  that primitive recursive functions "can be computed by a finite procedure".</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>"G ödel points out that the precise notion of mechanical procedures is brought out clearly by machines producing partial rather than general recursive functions." Reported in[112,  p.  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_7"><p>84].<ref type="bibr" target="#b7">8</ref> The omitted word is "potentially", which is nowadays left unstated but understood. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>Even the solution sets of Diophantine equations are exactly the recursively-enumerable subsets of the integers<ref type="bibr" target="#b60">[67]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>So, too, Bernays in a letter to Church, quoted in[94, p. 169], "[Turing]  seems to be very talented. His concept of computability is very suggestive and his proof of equivalence of this https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_10"><p>"Es soll eine ganz bestimmte allgemeine Vorschrift angegeben werden, die über die Richtigkeit oder Falschheit einer beliebig vorgelegten mit rein logischen Mitteln darstellbaren Behauptung nach einer endlichen Anzahl von Schritten zu entscheiden gestattet." https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms. NATURAL AXIOMATIZATION OF COMPUTABILITY</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_11"><p>A non-terminating computation (denoted ⊥ in some other contexts) is something altogether different, and corresponds to an infinite sequence of transitions. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms. NATURAL AXIOMATIZATION OF COMPUTABILITY</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_12"><p>The idea of providing the basic operations of recursively-defined functions over arbitrary domains by means of a logical structure also appears in<ref type="bibr" target="#b54">[62]</ref>.https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="19" xml:id="foot_13"><p>This definition of Bounded Exploration takes into account the possibility of the transition function being partial, along the lines of<ref type="bibr" target="#b10">[11]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="20" xml:id="foot_14"><p><ref type="bibr" target="#b19">20</ref> A single ↑ is ordinary exponentiation, ↑↑ is tetration (repeated exponentiation), ↑↑↑ is "pentration" (repeated tetration), and so on. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_15"><p>See [42, fn. 2] https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="23" xml:id="foot_16"><p>"Emulate. To duplicate the functions of one system with a different system, so that the second system appears to behave like the first system." American National Standards Institute<ref type="bibr" target="#b0">[1]</ref>. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="24" xml:id="foot_17"><p>Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="24" xml:id="foot_18"><p>Large classes of such non-classical algorithms are covered by the generalizations of the ASM Theorem in [9, 13, 16, 37]. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="25" xml:id="foot_19"><p>Neither constants, nor functions, are guaranteed to maintain their values, because their value may vary from state to state, which is what would make it awkward were we to talk about "variable constants".</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="26" xml:id="foot_20"><p>Luigi Federico Menabrea, an engineer, later became prime minister of Italy. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="30" xml:id="foot_21"><p>See<ref type="bibr" target="#b2">[3]</ref> (also<ref type="bibr" target="#b77">[86]</ref>) for the fundamental weakness of a two-counter machine, as compared to a machine with three counters or more. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="32" xml:id="foot_22"><p>The explicit bound on rank is removed in Sieg's more recent work[96, 97,<ref type="bibr" target="#b88">99,</ref><ref type="bibr" target="#b89">100]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="33" xml:id="foot_23"><p>Indeed, the algorithm in<ref type="bibr" target="#b27">[30]</ref> (determining the "parity" of certain graphs) cannot be naturally encoded as hereditarily finite sets of bounded rank, as shown there. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms. NATURAL AXIOMATIZATION OF COMPUTABILITY</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="34" xml:id="foot_24"><p>Copeland [26]  argues against the all too common misconstrual of Turing as having himself asserted such a physical claim. https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>First author's research supported in part by the Israel Science Foundation under grant no. 250/05.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The following characterization is the main point of this section: Theorem 4.5. A numeric function is partial recursive if and only if it is computable by an arithmetical ASM.</p><p>Proof. It is well-known that counter <ref type="bibr">(Minsky)</ref> machines can compute any partial recursive function <ref type="bibr" target="#b63">[71]</ref>. And any counter machine (which only uses 0, = 0, + 1, -1) can be directly emulated by an arithmetical ASM, with nullary symbols for each counter (which include the inputs In i and output Out), plus another "program counter" to keep track of the current countermachine instruction. The ASM commands take the following forms:</p><p>• Initialization instructions:</p><p>The program counter p and non-input counters c are initially ⊥; 0 and ⊥ in the above commands are the nullary symbols for those values; i, j and k are (instruction) numbers; numbers appearing in commands are written in successor notation (0 + 1 + • • • + 1). 27  On the other hand, it is also clear that any arithmetical ASM can be programmed in a standard programming language, 28 by storing the current non-⊥ values of all dynamic functions (and possibly some ⊥ values, as well) and interpreting the ASM's conditional updates step-by-step. Such programs, of course, can compute only partial recursive functions. 29   27 For details of counter-machine ASMs, consult <ref type="bibr" target="#b16">[17]</ref>. 28 By "standard programming language", we mean the "idealized" version of existing languages, in the sense that programs are allowed to be arbitrarily large and complex, the namespace is unlimited, and arbitrarily large numbers can be manipulated. The textbook, <ref type="bibr" target="#b26">[29]</ref>, describes one such idealized language in detail. 29 This implicit appeal to the formal effectiveness of standard programming techniques (viz. what can be programmed in any formalism can be expressed as general recursion) is sometimes also referred to as an invocation of Church's Thesis (cf. <ref type="bibr">[82, pp. 20-21]</ref>), but the omitted details could be fleshed out in what amounts to no more than a programming assignment for an undergraduate course. Shoenfield <ref type="bibr">[91, p. 121</ref>] refers to such uses of the thesis as "very convenient", but "not really essential". Kripke <ref type="bibr">[60, p. 13]</ref> explains: "If a recursion theorist is given an informal effective procedure for computing a function, he or she will regard it as proved that that function is recursive. However, an experienced recursion theorist will easily be able to convert this proof into a rigorous proof which makes no appeal https://doi.org/10.2178/bsl/1231081370 Downloaded from https://www.cambridge.org/core. INSEAD, on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at https://www.cambridge.org/core/terms.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Alliance for Telecommunications Industry Solutions, Committee T1A1 Performance and Signal Processing</title>
		<author>
			<orgName type="collaboration">ATIS Telecom Glossary</orgName>
		</author>
		<idno>ANS T1.523-2001</idno>
		<ptr target="http://www.atis.org/glossary/definition.aspx?id=7687" />
		<imprint>
			<date type="published" when="2000-02-28">2000. 28 February 2001. 2008</date>
			<biblScope unit="volume">23</biblScope>
		</imprint>
		<respStmt>
			<orgName>American National Standards Institute Document</orgName>
		</respStmt>
	</monogr>
	<note>Latest version available</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The impact of the lambda calculus in logic and computer science, this</title>
		<author>
			<persName><forename type="first">Henk</forename><surname>Barendregt</surname></persName>
		</author>
		<ptr target="http://www.math.ucla.edu/∼asl/bsl/0302/0302-003.ps" />
	</analytic>
	<monogr>
		<title level="j">Bulletin</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="181" to="215" />
			<date type="published" when="1997">1997. viewed Apr. 21, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Ob odnom klasse mashin Tjuringa (mashiny Minskogo) [On a class of Turing machines (Minsky machines)], Algebra i Logika [Algebra and Logic</title>
		<author>
			<persName><forename type="first">Janis</forename><forename type="middle">M</forename><surname>Barzdin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1963">1963</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="42" to="51" />
		</imprint>
	</monogr>
	<note>in Russian</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Beitrage zur Algebra der Logik, insbesondere zum Entscheidungsproblem</title>
		<author>
			<persName><forename type="first">Heinrich</forename><surname>Behmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematische Annalen</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="163" to="229" />
			<date type="published" when="1922">1922</date>
		</imprint>
	</monogr>
	<note>in German</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Algebraic specifications of computable and semi-computable datastructures</title>
		<author>
			<persName><forename type="first">Jan</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">V</forename><surname>Tucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="137" to="181" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Proving Church&apos;s thesis</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Black</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philosophia Mathematica</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="244" to="258" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">When are two algorithms the same?</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Blass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nachum</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuri</forename><surname>Gurevich</surname></persName>
		</author>
		<idno>MSR-TR-2008-20</idno>
		<ptr target="http://research.microsoft.com/∼gurevich/Opera/192.pdf" />
		<imprint>
			<date type="published" when="2008-02-30">February 2008. viewed Apr. 30, 2008</date>
			<pubPlace>Microsoft Research, Redmond, WA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Algorithms vs. machines</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Blass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuri</forename><surname>Gurevich</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/∼gurevich/Opera/158.pdf(viewedNov.28" />
	</analytic>
	<monogr>
		<title level="m">Current Trends in Theoretical Computer Science: The Challenge of the New Century</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Paun</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Salomaa</surname></persName>
		</editor>
		<imprint>
			<publisher>World Scientific Publishing Company</publisher>
			<date type="published" when="2002">2002. 2004. 2007</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="215" to="236" />
		</imprint>
	</monogr>
	<note>Formal Models and Semantics</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">See also: Abstract state machines capture parallel algorithms: Correction and extension</title>
		<ptr target="http://tocl.acm.org/accepted/314gurevich.pdf" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="578" to="651" />
			<date type="published" when="2003-11-28">2003. Nov. 28, 2007. Nov. 28, 2007</date>
		</imprint>
	</monogr>
	<note>ACM Transactions on Computational Logic</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Algorithms: A quest for absolute definitions, Church&apos;s Thesis after 70 years</title>
		<author>
			<persName><forename type="first">A</forename><surname>Olszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wolenski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Janusz</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/∼gurevich/Opera/164.pdf(viewedNov.28" />
	</analytic>
	<monogr>
		<title level="m">Current trends in theoretical computer science</title>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="2003">2006. 2003. 2004. 2007</date>
			<biblScope unit="page" from="283" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Ordinary interactive small-step algorithms, I</title>
		<ptr target="http://tocl.acm.org/accepted/blass04.ps" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="363" to="419" />
			<date type="published" when="2006">2006. viewed Apr. 23, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Ordinary interactive small-step algorithms</title>
		<ptr target="http://tocl.acm.org/accepted/blass2.ps" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2007">2007. viewed Apr. 23, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Ordinary interactive small-step algorithms, III</title>
		<ptr target="http://tocl.acm.org/accepted/250blass.pdf" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2007">2007. viewed Apr. 23, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Pillars of computer science: Essays dedicated to Boris (Boaz) Trakhtenbrot on the occasion of his 85th birthday</title>
		<ptr target="http://research.microsoft.com/∼gurevich/Opera/172.pdf" />
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Avron</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Dershowitz</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rabinovich</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4800</biblScope>
			<biblScope unit="page" from="179" to="198" />
			<date type="published" when="2008-03-08">2008. viewed Mar. 8, 2008</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>Why sets?</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interactive small-step algorithms I: Axiomatization</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Blass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuri</forename><surname>Gurevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dean</forename><surname>Rosenzweig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Rossman</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/∼gurevich/Opera/176.pdf" />
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007">2007. viewed Dec. 16, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interactive small-step algorithms II: Abstract state machines and the characterization theorem</title>
		<ptr target="http://research.microsoft.com/∼gurevich/Opera/182.pdf" />
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007">2007. viewed Dec. 16, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Abstract effective models</title>
		<author>
			<persName><forename type="first">Udi</forename><surname>Boker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nachum</forename><surname>Dershowitz</surname></persName>
		</author>
		<ptr target="http://www.cs.tau.ac.il/∼nachum/papers/AbstractEffectiveModels.pdf(viewedNov.28" />
	</analytic>
	<monogr>
		<title level="m">New developments in computational models: Proceedings of the first international workshop on Developments in Computational Models</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Fernández</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Mackie</surname></persName>
		</editor>
		<meeting><address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-02">DCM 2005. July 2005. February 2006. 2007</date>
			<biblScope unit="volume">135</biblScope>
			<biblScope unit="page" from="15" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Comparing computational power</title>
		<ptr target="http://www.cs.tau.ac.il/∼nachum/papers/ComparingComputationalPower.pdf" />
	</analytic>
	<monogr>
		<title level="j">Logic Journal of the IGPL</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="633" to="648" />
			<date type="published" when="2006-11-28">2006. Nov. 28, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Pillars of computer science: Essays dedicated to Boris (Boaz) Trakhtenbrot on the occasion of his 85th birthday</title>
		<ptr target="http://www.cs.tau.ac.il/∼nachum/papers/ArbitraryDomains.pdf(viewedNov.28" />
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Avron</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Dershowitz</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rabinovich</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4800</biblScope>
			<biblScope unit="page" from="199" to="229" />
			<date type="published" when="2007">2008. 2007</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">The Church-Turing Thesis over arbitrary domains</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The origins and the development of the ASM method for high level system design and analysis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Egon</surname></persName>
		</author>
		<author>
			<persName><surname>Örger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2" to="74" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The prospects for mathematical logic in the twenty-first century</title>
		<author>
			<persName><forename type="first">R</forename><surname>Samuel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">A</forename><surname>Buss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Kechris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">A</forename><surname>Pillay</surname></persName>
		</author>
		<author>
			<persName><surname>Shore</surname></persName>
		</author>
		<ptr target="http://www.math.ucla.edu/∼asl/bsl/0702/0702-001.ps" />
	</analytic>
	<monogr>
		<title level="j">Bulletin</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="169" to="196" />
			<date type="published" when="2001">2001. viewed Apr. 21, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A note on the Entscheidungsproblem</title>
		<author>
			<persName><forename type="first">Alonzo</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="110" to="115" />
			<date type="published" when="1936">1936. 1936</date>
		</imprint>
	</monogr>
	<note>The Journal of Symbolic Logic. Reprinted in [27</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On computable numbers, with an application to the Entscheidungsproblem</title>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">M</forename><surname>Turing</surname></persName>
		</author>
		<idno type="DOI">10.2307/2371045</idno>
	</analytic>
	<monogr>
		<title level="m">Review of Emil Post, Finite combinatory processes, Formulation I (The Journal of Symbolic Logic</title>
		<title level="s">American Journal of Mathematics</title>
		<imprint>
			<date type="published" when="1936">1936. 1936. 1937. 1936. 1937</date>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page">43</biblScope>
		</imprint>
	</monogr>
	<note>The Journal of Symbolic Logic</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">Jack</forename><surname>Copeland</surname></persName>
		</author>
		<ptr target="http://plato.stanford.edu/entries/church-turing" />
		<title level="m">Stanford encyclopedia of philosophy</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Zalta</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1996-11-28">1996. Nov. 28, 2007</date>
		</imprint>
	</monogr>
	<note type="report_type">The Church-Turing Thesis</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The undecidable: Basic papers on undecidable propositions, unsolvable problems and computable functions</title>
		<editor>Martin Davis</editor>
		<imprint>
			<date type="published" when="1965">1965. 2004</date>
			<publisher>Dover Publications</publisher>
			<pubPlace>Hewlett, NY; Mineola, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Why Gödel didn&apos;t have Church&apos;s thesis</title>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="3" to="24" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">D</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><surname>Sigal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><forename type="middle">J</forename><surname>Weyuker</surname></persName>
		</author>
		<title level="m">Computability, complexity, and languages: Fundamentals of theoretical computer science</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Choiceless polynomial time, counting and the Cai-Fürer-Immerman graphs</title>
		<author>
			<persName><forename type="first">Anuj</forename><surname>Dawar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Richerby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Rossman</surname></persName>
		</author>
		<ptr target="http://www.mit.edu/∼brossman/CPT-CFI.pdf" />
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">152</biblScope>
			<biblScope unit="page" from="31" to="50" />
			<date type="published" when="2008">2008. viewed Apr. 30, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Church&apos;s thesis: Prelude to a proof</title>
		<author>
			<persName><forename type="first">Janet</forename><surname>Folina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philosophia Mathematica</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="302" to="323" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Conservative logic</title>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">F</forename><surname>Fredkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tommaso</forename><surname>Toffoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Theoretical Physics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3/4</biblScope>
			<biblScope unit="page" from="219" to="253" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Mathematical logic in the 20th and 21st centuries</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harvey</surname></persName>
		</author>
		<author>
			<persName><surname>Friedman</surname></persName>
		</author>
		<ptr target="http://cs.nyu.edu/pipermail/fom/2000-April/003913.html" />
	</analytic>
	<monogr>
		<title level="m">Foundations of Mathematics mailing list</title>
		<imprint>
			<date type="published" when="2000-04-27">April 27 2000. viewed Mar. 27, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Effective procedures in field theory</title>
		<author>
			<persName><forename type="first">Albrecht</forename><surname>Fr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Shepherdson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philosophical transactions of the Royal Society of London, Series A</title>
		<imprint>
			<biblScope unit="volume">248</biblScope>
			<biblScope unit="page" from="407" to="432" />
			<date type="published" when="1956">1956</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The universal Turing machine: A half-century survey</title>
		<author>
			<persName><forename type="first">Robin</forename><forename type="middle">O</forename><surname>Gandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Herken</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland, Amsterdam; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1980">1980. 1988</date>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="page" from="55" to="111" />
		</imprint>
	</monogr>
	<note>Church&apos;s Thesis and principles for mechanisms</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An ASM-characterization of a class of distributed algorithms, Proceedings of the Dagstuhl seminar on rigorous methods for software construction and analysis</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Glausch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Reisig</surname></persName>
		</author>
		<ptr target="http://www2.informatik.hu-berlin.de/top/download/publications/GlauschR2007dagstuhl.pdf" />
	</analytic>
	<monogr>
		<title level="j">Informatik-Berichte</title>
		<editor>
			<persName><forename type="first">J.-R</forename><surname>Abrial</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Glässer</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">196</biblScope>
			<date type="published" when="2006-05">May 2006. viewed Mar. 26, 2008</date>
		</imprint>
		<respStmt>
			<orgName>Humboldt-Universität zu</orgName>
		</respStmt>
	</monogr>
	<note>Longer version: Distributed abstract state machines and their expressive power</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName><surname>Berlin</surname></persName>
		</author>
		<ptr target="http://www2.informatik.hu-berlin.de/top/download/publications/GlauschR2006hubtr196.pdf" />
		<imprint>
			<date type="published" when="2006-01">Jan. 2006. viewed Mar. 26, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">On undecidable propositions of formal mathematical systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kurt</surname></persName>
		</author>
		<author>
			<persName><surname>Ödel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1934">1934</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="41" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">S</forename><surname>Gödel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Feferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dawson</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Goldfarb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Parsons</surname></persName>
		</author>
		<author>
			<persName><surname>Solovay</surname></persName>
		</author>
		<title level="m">Unpublished essays and lectures, Kurt Gödel: Collected works</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">III</biblScope>
			<biblScope unit="page" from="164" to="174" />
		</imprint>
	</monogr>
	<note>Undecidable diophantine propositions</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Limiting recursion</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Mark</forename><surname>Gold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Journal of Symbolic Logic</title>
		<imprint>
			<date type="published" when="1965">1965</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="28" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">Yuri</forename><surname>Gurevich</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/∼gurevich/Opera/103.pdf" />
		<title level="m">Evolving algebras 1993: Lipari guide, Specification and validation methods</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Örger</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1995-11-28">1995. Nov. 28, 2007</date>
			<biblScope unit="page" from="9" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Sequential abstract state machines capture sequential algorithms</title>
		<ptr target="http://tocl.acm.org/accepted/gurevich.ps" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="77" to="111" />
			<date type="published" when="2000">2000. viewed Apr. 23, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The semantics of the C programming language</title>
		<author>
			<persName><forename type="first">Yuri</forename><surname>Gurevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">K</forename><surname>Huggins</surname></persName>
		</author>
		<idno type="DOI">10.2178/bsl/1231081370</idno>
		<ptr target="https://doi.org/10.2178/bsl/1231081370" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the sixth workshop on Computer Science Logic (CSL &apos;92) (Berlin)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the sixth workshop on Computer Science Logic (CSL &apos;92) (Berlin)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993-03-13">1993. viewed Mar. 13, 2008</date>
			<biblScope unit="volume">702</biblScope>
			<biblScope unit="page" from="334" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title/>
		<idno type="DOI">10.2178/bsl/1231081370</idno>
		<ptr target="https://www.cambridge.org/core/terms" />
		<imprint/>
	</monogr>
	<note>on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">David</forename><surname>Hilbert</surname></persName>
		</author>
		<ptr target="http://www.mathematik.uni-bielefeld.de/∼kersten/hilbert/rede.html" />
		<title level="m">Mathematische Probleme: Vortrag, gehalten auf dem internationalen Mathematiker-Kongreß zu Paris 1900, in German</title>
		<imprint>
			<date type="published" when="2007-11-28">Nov. 28, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">English version of the second (1938) edition: Principles of theoretical logic</title>
		<author>
			<persName><forename type="first">David</forename><surname>Hilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">R E</forename><surname>Wilhelm Ackermann</surname></persName>
		</author>
		<author>
			<persName><surname>Luce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">L ászl ó Kalmár, An argument against the plausibility of Church&apos;s thesis</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Heyting</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin; New York; North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>AMS Chelsea Publishing</publisher>
			<date type="published" when="1928">1928. 1950. 1959</date>
			<biblScope unit="page" from="201" to="205" />
		</imprint>
	</monogr>
	<note>Constructivity in mathematics</note>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">N</forename><surname>Shen Kangshen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><forename type="middle">W C</forename><surname>Crossley</surname></persName>
		</author>
		<author>
			<persName><surname>Lun</surname></persName>
		</author>
		<title level="m">The nine chapters on the mathematical art: Companion and commentary</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Recursive predicates and quantifiers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName><surname>Kleene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="255" to="287" />
			<date type="published" when="1943">1943</date>
		</imprint>
	</monogr>
	<note>reprinted in [27</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Origins of recursive function theory</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th annual IEEE symposium on Foundations of Computer Science (FOCS)</title>
		<meeting>the 20th annual IEEE symposium on Foundations of Computer Science (FOCS)<address><addrLine>New York; Mineola, NY; San Juan, PR</addrLine></address></meeting>
		<imprint>
			<publisher>Notre Dame Journal of Formal Logic</publisher>
			<date type="published" when="1967">1967. 2002. 1981. Oct. 1979. 1987</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="490" to="498" />
		</imprint>
	</monogr>
	<note>Reflections on Church&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Turing&apos;s analysis of computability, and major applications of it</title>
		<editor>R. Herken</editor>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Oxford University Press</publisher>
			<biblScope unit="page" from="17" to="54" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>The universal Turing machine: A half-century survey</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Algorithm and program; information and data</title>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamental algorithms, The art of computer programming</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1966">1966. 1997</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">654</biblScope>
		</imprint>
	</monogr>
	<note>rd ed.</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Andreȋ</surname></persName>
		</author>
		<author>
			<persName><surname>Kolmogorov</surname></persName>
		</author>
		<title level="m">Uspekhi Matematicheskikh Nauk</title>
		<imprint>
			<date type="published" when="1953">1953</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="18" to="19" />
		</imprint>
	</monogr>
	<note>Russian. English version in</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">English version: On the definition of an algorithm</title>
		<author>
			<persName><forename type="first">N</forename><surname>Andreȋ</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladimir</forename><forename type="middle">A</forename><surname>Kolmogorov</surname></persName>
		</author>
		<author>
			<persName><surname>Uspensky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matematicheskikh</forename><surname>Uspekhi</surname></persName>
		</author>
		<author>
			<persName><surname>Nauk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Russian</title>
		<title level="s">American Mathematical Society Translations, Series II</title>
		<imprint>
			<date type="published" when="1958">1958. 1963</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="217" to="245" />
		</imprint>
	</monogr>
	<note>Russian Mathematical Surveys</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Mathematical logic</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Kreisel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lectures in modern mathematics III</title>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Saaty</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley and Sons</publisher>
			<date type="published" when="1965">1965</date>
			<biblScope unit="page" from="95" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Mathematical logic: What has it done for the philosophy of mathematics</title>
		<editor>R. Schoenman</editor>
		<imprint>
			<date type="published" when="1967">1967</date>
			<biblScope unit="page" from="201" to="272" />
			<pubPlace>Bertrand Russell; Allen &amp; Unwin, London</pubPlace>
		</imprint>
	</monogr>
	<note>Philosopher of the century</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Elementary recursion theory and its applications to formal systems</title>
		<author>
			<persName><forename type="first">Saul</forename><surname>Kripke</surname></persName>
		</author>
		<ptr target="http://www.vanleer.org.il/eng/videoShow.asp?id=317" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th annual IEEE symposium on Logic in Computer Science</title>
		<meeting>the 15th annual IEEE symposium on Logic in Computer Science<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-06">1996. June 2000. Mar. 28, 2008</date>
			<biblScope unit="page">177</biblScope>
		</imprint>
	</monogr>
	<note>From the Church-Turing thesis to the first-order algorithm theorem</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A notion of effectiveness in arbitrary structures</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">M</forename><surname>Lambert</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="577" to="602" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">R</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Judson</forename><forename type="middle">C</forename><surname>Review</surname></persName>
		</author>
		<author>
			<persName><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mechanism, mentalism and metamathematics: An essay on finitism (D. Reidel</title>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1980">1980. 1982</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="441" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">English version: Constructive algebras, I, The metamathematics of algebraic systems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Anatoliȋ</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Hirsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Konstruktivnyye algyebry. 1, Uspekhi Matematicheskikh Nauk</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Wells</surname></persName>
		</editor>
		<editor>
			<persName><surname>Iii</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="148" to="212" />
			<date type="published" when="1961">1961. 1961. 1971</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
	<note>Also in: The metamathematics of algebraic systems. Collected papers 1936-1967</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">The optimal approach to recursive programs</title>
		<author>
			<persName><forename type="first">Zohar</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="824" to="831" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Teor iia algorifmov</title>
		<author>
			<persName><forename type="first">A</forename><surname>Andreȋ</surname></persName>
		</author>
		<author>
			<persName><surname>Markov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Works of the Mathematics Institute Im</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">English version: Theory of algorithms</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Steklov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Russian</title>
		<title level="s">American Mathematical Society Translations, Series</title>
		<meeting><address><addrLine>Jerusalem</addrLine></address></meeting>
		<imprint>
			<publisher>Israel Program for Scientific Translations</publisher>
			<date type="published" when="1954">1954. 1961</date>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Enumerable sets are Diophantine</title>
		<author>
			<persName><forename type="first">Yuri</forename><forename type="middle">V</forename><surname>Matijasevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Russian. English version: Soviet Mathematics</title>
		<imprint>
			<biblScope unit="volume">191</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="354" to="357" />
			<date type="published" when="1970">1970. 1970</date>
		</imprint>
	</monogr>
	<note>Doklady Akademiia Nauk SSSR</note>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Also in: Charles Babbage, The works of Charles Babbage</title>
		<author>
			<persName><forename type="first">Luigi</forename><surname>Federico</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Menabrea</forename></persName>
		</author>
		<ptr target="http://www.fourmilab.ch/babbage/sketch.html(viewedNov.28" />
	</analytic>
	<monogr>
		<title level="m">English version: Sketch of the Analytical Engine invented by Charles Babbage</title>
		<title level="s">Notions sur la machine analytique de M Charles Babbage, Bibliothèque Universelle de Genève n.s.</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Taylor</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>NYU Press</publisher>
			<date type="published" when="1842">1842. 1989. 1843. 2007</date>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="666" to="731" />
		</imprint>
	</monogr>
	<note>Scientific Memoirs</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">On the impossibility of proving the &apos;hard-half&apos; of Church&apos;s thesis, Church&apos;s thesis after 70 years</title>
		<author>
			<persName><forename type="first">Elliott</forename><surname>Mendelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Philosophy</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Olszewski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Wolenski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Janusz</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="304" to="309" />
			<date type="published" when="1990">1990. 2006</date>
			<publisher>Ontos Verlag</publisher>
			<pubPlace>Frankfurt</pubPlace>
		</imprint>
	</monogr>
	<note>Second thoughts about Church&apos;s thesis and mathematical proofs</note>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<author>
			<persName><forename type="first">Marvin</forename><surname>Minsky</surname></persName>
		</author>
		<title level="m">Computation: Finite and infinite machines, 1st ed</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Towards a general theory of computability</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Montague</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthese</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="429" to="438" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Yiannis</surname></persName>
		</author>
		<author>
			<persName><surname>Moschovakis</surname></persName>
		</author>
		<ptr target="http://www.math.ucla.edu/∼ynm/papers/eng.ps" />
		<title level="m">What is an algorithm?, Mathematics unlimited-2001 and beyond</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Engquist</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Schmid</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001-11-28">2001. Nov. 28, 2007</date>
			<biblScope unit="page" from="919" to="936" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Classical recursion theory: The theory of functions and sets of natural numbers</title>
		<author>
			<persName><forename type="first">Piergiorgio</forename><surname>Odifreddi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics</title>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">125</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Finite combinatory processes, Formulation I</title>
		<author>
			<persName><forename type="first">Emil</forename><forename type="middle">L</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="289" to="303" />
			<date type="published" when="1936">1936</date>
		</imprint>
	</monogr>
	<note>reprinted in [27</note>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Absolutely unsolvable problems and relatively undecidable propositions: Account of an anticipation</title>
		<editor>Emil L. Post (M. Davis</editor>
		<imprint>
			<date type="published" when="1941">1941. 1994</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="375" to="441" />
			<pubPlace>Birkhäuser, Boston, MA</pubPlace>
		</imprint>
	</monogr>
	<note>Also in Solvability, provability, definability: The collected works of</note>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Formal reductions of the general combinatorial decision problem</title>
		<idno type="DOI">10.2307/2371809</idno>
	</analytic>
	<monogr>
		<title level="j">American Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="197" to="215" />
			<date type="published" when="1943">1943</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Trial and error predicates and the solution to a problem of Mostowski</title>
		<author>
			<persName><forename type="first">Hilary</forename><surname>Putnam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="57" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Computable algebra, general theory and the theory of computable fields</title>
		<author>
			<persName><forename type="first">O</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="341" to="360" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">On Gurevich&apos;s theorem on sequential algorithms</title>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Reisig</surname></persName>
		</author>
		<ptr target="http://www.informatik.hu-berlin.de/top/download/publications/Reisig" />
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="273" to="305" />
			<date type="published" when="2003-11-28">2003. 2003. Nov. 28, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<monogr>
		<title level="m" type="main">Church&apos;s Thesis and the conceptual analysis of computability</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Rescorla</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Notre Dame Journal of Formal Logic</publisher>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="253" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title level="m" type="main">Theory of recursive functions and effective computability</title>
		<author>
			<persName><surname>Hartley Rogers</surname><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="1967">1967. 1987</date>
			<publisher>MIT Press</publisher>
			<pubPlace>New York; Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">An informal exposition of proofs of Gödel&apos;s Theorem and Church&apos;s Theorem</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Barkley</forename><surname>Rosser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Highlights of the history of lambda calculus</title>
		<imprint>
			<date type="published" when="1939">1939. 1984</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="337" to="349" />
		</imprint>
	</monogr>
	<note>The Journal of Symbolic Logic</note>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Storage modification machines</title>
		<author>
			<persName><forename type="first">Arnold</forename><surname>Sch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Önhage</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="490" to="508" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title level="m" type="main">A two counter machine cannot calculate 2 N</title>
		<author>
			<persName><forename type="first">Rich</forename><surname>Schroeppel</surname></persName>
		</author>
		<idno>AIM-</idno>
		<imprint/>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b78">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">I</forename><surname>Laboratory</surname></persName>
		</author>
		<ptr target="ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-257.pdf" />
		<imprint>
			<date type="published" when="1972-05">May 1972. Nov. 28, 2007</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology, Cambridge, MA</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<author>
			<persName><forename type="first">Oron</forename><surname>Shagrir</surname></persName>
		</author>
		<ptr target="http://edelstein.huji.ac.il/staff/shagrir/papers/" />
		<title level="m">Effective computation by humans and machines, Minds and Machines</title>
		<imprint>
			<date type="published" when="2002-11-28">2002. Nov. 28, 2007</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="221" to="240" />
		</imprint>
	</monogr>
	<note>Effective computation by human and machine</note>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Understanding Church&apos;s thesis</title>
		<author>
			<persName><forename type="first">Stewart</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Philosophical Logic</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="353" to="365" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Understanding Church&apos;s thesis, again</title>
	</analytic>
	<monogr>
		<title level="j">Acta Analytica</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="59" to="77" />
			<date type="published" when="1982">1982. 1995</date>
			<publisher>Notre Dame Journal of Formal Logic</publisher>
		</imprint>
	</monogr>
	<note>Acceptable notation</note>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">R</forename><surname>Shoenfield</surname></persName>
		</author>
		<title level="m">Mathematical logic</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Recursion theory</title>
		<title level="s">Lecture Notes in Logic</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Peters</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin; Natick, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993. 2001</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Mechanical procedures and mathematical experiences</title>
		<author>
			<persName><forename type="first">Wilfried</forename><surname>Sieg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematics and mind</title>
		<editor>
			<persName><forename type="first">A</forename><surname>George</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="71" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Step by recursive step: Church&apos;s analysis of effective computability, this</title>
		<ptr target="http://www.math.ucla.edu/∼asl/bsl/0302/0302-002.ps" />
	</analytic>
	<monogr>
		<title level="j">Bulletin</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="154" to="180" />
			<date type="published" when="1997-11-28">1997. Nov. 28, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">). [96] , Calculations by man and machine: Conceptual analysis, Reflections on the foundations of mathematics: Essays in honor of Solomon Feferman</title>
		<ptr target="http://www.math.ucla.edu/∼asl/bsl/0501/0501-001.ps" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eleventh international congress of Logic</title>
		<title level="s">Lecture Notes in Logic</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Gärdenfors</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Wole</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Kijania-Placek</surname></persName>
		</editor>
		<meeting>the eleventh international congress of Logic<address><addrLine>Natick, MA; Cracow, Poland; Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic</publisher>
			<date type="published" when="1999">1999. viewed Apr. 21, 2008. 2002. August 1999. 2003</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="247" to="262" />
		</imprint>
	</monogr>
	<note>Synthese Library</note>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Gödel on computability</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="189" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<monogr>
		<title level="m" type="main">Church without dogma-Axioms for computability, New computational paradigms: Changing conceptions of what is computable</title>
		<ptr target="http://www.hss.cmu.edu/philosophy/sieg/Church%20without%20dogma.pdf" />
		<editor>S. B. Cooper, B. L öwe, and A. Sorbi</editor>
		<imprint>
			<date type="published" when="2007">2008. Nov. 28, 2007</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="139" to="152" />
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Emergence and analysis of a mathematical notion</title>
		<author>
			<persName><surname>Computability</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of the philosophy of mathematics</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Irvine</surname></persName>
		</editor>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">K-graph machines: Generalizing Turing&apos;s machines and arguments</title>
		<author>
			<persName><forename type="first">Wilfried</forename><surname>Sieg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Byrnes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Gödel 96: Logical Foundations of Mathematics, Computer Science, and Physics</title>
		<title level="s">Lecture Notes in Logic</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Hájek</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="98" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">An abstract model for parallel computations: Gandy&apos;s thesis</title>
	</analytic>
	<monogr>
		<title level="s">The Monist</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="150" to="164" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Computability and recursion</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">I</forename><surname>Soare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<ptr target="http://www.people.cs.uchicago.edu/∼soare/siena502m.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the third conference on Computability in Europe</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Cooper</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sorbi</surname></persName>
		</editor>
		<meeting>the third conference on Computability in Europe<address><addrLine>Siena, Italy; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007-06">CiE 2007. June 2007. Nov. 28, 2007</date>
			<biblScope unit="volume">4497</biblScope>
			<biblScope unit="page" from="705" to="715" />
		</imprint>
		<respStmt>
			<orgName>Computability and incomputability</orgName>
		</respStmt>
	</monogr>
	<note>Longer version to appear</note>
</biblStruct>

<biblStruct xml:id="b94">
	<monogr>
		<author>
			<persName><forename type="first">Robert</forename><surname>St Ärk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Egon</forename><forename type="middle">B</forename><surname>Örger</surname></persName>
		</author>
		<title level="m">Java and the Java Virtual Machine: Definition, verification, validation</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">English version: The concept of truth in formalized languages</title>
		<author>
			<persName><forename type="first">Alfred</forename><surname>Tarski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">J H</forename><surname>Woodger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Der Wahrheitsbegriff in den formalisierten Sprachen</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Corcoran</surname></persName>
		</editor>
		<meeting><address><addrLine>Hackett, Indianapolis, IN</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1936">1936. 1983</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="152" to="277" />
		</imprint>
	</monogr>
	<note>Logic, semantics, methamathematics</note>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Computability and -definability</title>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">M</forename><surname>Turing</surname></persName>
		</author>
		<ptr target="http://www.abelard.org/turpap2/tp2-ie.asp" />
	</analytic>
	<monogr>
		<title level="m">The essential Turing: Seminal writings in computing, logic, philosophy, artificial intelligence, and artificial life, plus the secrets of Enigma</title>
		<title level="s">Proceedings of the London Mathematical Society, Series 2</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">O</forename><surname>Gandy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">E M</forename><surname>Yates</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland, Amsterdam; North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1936">1936. 1937. 2004. 2001. viewed Nov. 27, 2007. 1937. 2001</date>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="59" to="69" />
		</imprint>
	</monogr>
	<note>Corrigenda. reprinted in Collected works of A. M. Turing. Mathematical logic (R. O. Gandy and C. E. M. Yates, editors</note>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Mechanical intelligence</title>
		<ptr target="http://web.comlab.ox.ac.uk/oucl/research/areas/ieg/e-library/sources/tarticle.pdf" />
	</analytic>
	<monogr>
		<title level="m">Computing machinery and intelligence</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">Jack</forename><surname>Copeland</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1950">1950. 1992. 2004. Nov. 28, 2007</date>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="433" to="464" />
		</imprint>
	</monogr>
	<note>The essential Turing</note>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Solvable and unsolvable problems</title>
	</analytic>
	<monogr>
		<title level="m">Mechanical intelligence</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Ince</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1954">1954. 1992</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="187" to="204" />
		</imprint>
	</monogr>
	<note>reprinted in Collected works of A. M. Turing</note>
</biblStruct>

<biblStruct xml:id="b99">
	<monogr>
		<title level="m" type="main">Algorithms: Main ideas and applications</title>
		<author>
			<persName><forename type="first">Vladimir</forename><forename type="middle">A</forename><surname>Uspensky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexei</forename><forename type="middle">L</forename><surname>Semenov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<pubPlace>Kluwer, Norwell, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<monogr>
		<author>
			<persName><forename type="first">Wang</forename><surname>Hao</surname></persName>
		</author>
		<title level="m">From mathematics to philosophy, Routledge and Kegan Paul</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<monogr>
		<author>
			<persName><forename type="first">Richard</forename><surname>Zach</surname></persName>
		</author>
		<ptr target="http://www.math.ucla.edu/∼asl/bsl/0503/0503-003.ps" />
		<title level="m">MICROSOFT RESEARCH REDMOND, WA 98052, USA and SCHOOL OF COMPUTER SCIENCE TEL AVIV UNIVERSITY RAMAT AVIV</title>
		<imprint>
			<date type="published" when="1999-11-28">1999. Nov. 28, 2007</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="331" to="366" />
		</imprint>
	</monogr>
	<note>Completeness before Post: Bernays, Hilbert, and the development of propositional logic, this Bulletin</note>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">E-Mail</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WA</title>
		<imprint>
			<biblScope unit="volume">98052</biblScope>
			<pubPlace>USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<monogr>
		<author>
			<persName><forename type="first">E-Mail</forename></persName>
		</author>
		<idno type="DOI">10.2178/bsl/1231081370</idno>
		<ptr target="https://doi.org/10.2178/bsl/1231081370" />
		<title level="m">gurevich@microsoft.com URL: research.microsoft.com/ ∼ gurevich</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<monogr>
		<title/>
		<idno type="DOI">10.2178/bsl/1231081370</idno>
		<ptr target="https://www.cambridge.org/core/terms" />
		<imprint/>
	</monogr>
	<note>on 24 Mar 2018 at 22:42:25, subject to the Cambridge Core terms of use, available at</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
