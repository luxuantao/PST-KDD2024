<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Packet Transactions: High-Level Programming for Line-Rate Switches</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Anirudh</forename><surname>Sivaraman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">‡ University of Washington, § VMWare Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mihai</forename><surname>Budiu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Changhoon</forename><surname>Kim</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">++ Microsoft Research</orgName>
								<address>
									<settlement>Barefoot Networks</settlement>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">+ Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">‡ University of Washington, § VMWare Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><roleName>++</roleName><forename type="first">George</forename><surname>Varghese</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">‡ University of Washington, § VMWare Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><surname>Mckeown</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Steve</forename><surname>Licking</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">++ Microsoft Research</orgName>
								<address>
									<settlement>Barefoot Networks</settlement>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">+ Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Packet Transactions: High-Level Programming for Line-Rate Switches</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2DEBF013207F8885DE74E5610D26A5C3</idno>
					<idno type="DOI">10.1145/2934872.2934900</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Programmable switches; stateful data-plane algorithms</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Many algorithms for congestion control, scheduling, network measurement, active queue management, and traffic engineering require custom processing of packets in the data plane of a network switch. To run at line rate, these dataplane algorithms must be implemented in hardware. With today's switch hardware, algorithms cannot be changed, nor new algorithms installed, after a switch has been built.</p><p>This paper shows how to program data-plane algorithms in a high-level language and compile those programs into low-level microcode that can run on emerging programmable line-rate switching chips. The key challenge is that many data-plane algorithms create and modify algorithmic state. To achieve line-rate programmability for stateful algorithms, we introduce the notion of a packet transaction: a sequential packet-processing code block that is atomic and isolated from other such code blocks.</p><p>We have developed this idea in Domino, a C-like imperative language to express data-plane algorithms. We show with many examples that Domino provides a convenient way to express sophisticated data-plane algorithms, and show that these algorithms can be run at line rate with modest estimated chip-area overhead.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Network switches in modern datacenters, enterprises, and service-provider networks perform many tasks in addition to standard packet forwarding. The set of requirements for switches has only increased with time as network operators seek greater control over performance. Performance may be improved using both data-plane and control-plane mechanisms. This paper focuses on data-plane algorithms. These algorithms process and transform packets, reading and writing state in the switch. Examples include active queue management <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b50">51]</ref>, scheduling <ref type="bibr" target="#b57">[58]</ref>, congestion control with switch feedback <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b59">60]</ref>, network measurement <ref type="bibr" target="#b62">[63,</ref><ref type="bibr" target="#b36">37]</ref>, and data-plane traffic engineering <ref type="bibr" target="#b20">[21]</ref>.</p><p>An important requirement for data-plane algorithms is the ability to process packets at the switch's line rate: 10-100 Gbit/s on 10-100 ports. Therefore, these algorithms are typically implemented using dedicated hardware. Hardware designs are rigid and not reconfigurable in the field. Thus, implementing and deploying a new algorithm, or even modifying a deployed one, requires an investment in new hardware-a time-consuming and expensive proposition.</p><p>This rigidity affects many stakeholders adversely: vendors <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b6">6]</ref> building network switches with merchantsilicon chips <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b16">16]</ref>, network operators deploying these switches <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b55">56]</ref>, and researchers developing new dataplane algorithms <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b59">60]</ref>.</p><p>To run new data-plane algorithms after a switch has been built, researchers and companies have attempted to build programmable switches for many years, starting from efforts on active networks <ref type="bibr" target="#b60">[61]</ref> to network processors <ref type="bibr" target="#b14">[14]</ref> to software routers <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b45">46]</ref>. All these efforts sacrificed performance for programmability, typically running an order of magnitude (or worse) slower than hardware line rates. Unfortunately, this reduction in performance has meant that these systems are rarely deployed in production networks.</p><p>Programmable switching chips <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b18">19]</ref> competitive in performance with state-of-the-art fixed-function chips <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b16">16]</ref> are now becoming available. These chips implement a few low-level hardware primitives that can be configured by software into a processing pipeline, and are fieldreconfigurable. Building a switch with such a chip is attractive because it does not compromise on data rates <ref type="bibr" target="#b27">[28]</ref>.</p><p>In terms of programmability, these chips today allow the network operator to program packet parsing and forwarding, i.e., a programmer can program the set of protocol formats to be matched and the set of actions to be executed when matching packet headers in a match-action table. Languages such as P4 <ref type="bibr" target="#b26">[27]</ref> are emerging as a way to express such matchaction processing in a hardware-independent manner.</p><p>There is a gap between this form of programmability and the needs of data-plane algorithms. By contrast to packet forwarding, which doesn't modify state in the data plane, many data-plane algorithms create and modify algorithmic state in the switch as part of packet processing.</p><p>For such algorithms, programmability must directly capture the algorithm's intent without requiring the algorithm to be shoehorned into hardware primitives like a sequence of match-action tables. Indeed, the ability to directly capture an algorithm's intent pervades programming models for many other networking devices, e.g., software routers <ref type="bibr" target="#b45">[46]</ref>, network processors <ref type="bibr" target="#b35">[36]</ref>, and network endpoints <ref type="bibr" target="#b5">[5]</ref>.</p><p>By studying the requirements of data-plane algorithms and the constraints of line-rate hardware, we introduce a new abstraction to program and implement data-plane algorithms: a packet transaction ( §3). A packet transaction is a sequential code block that is atomic and isolated from other such code blocks, with the semantics that any visible state is equivalent to a serial execution of packet transactions across packets in the order of packet arrival. Packet transactions let the programmer focus on the operations needed for each packet without worrying about other concurrent packets.</p><p>Packet transactions have an all-or-nothing guarantee: all packet transactions accepted by the packet transactions compiler will run at line rate, or be rejected. There is no "slippery slope" of running network algorithms at lower speeds as with network processors or software routers: when compiled, a packet transaction runs at line rate, or not at all. Performance is not just predictable, but guaranteed.</p><p>In realizing packet transactions, we make three new contributions. First, Banzai, a machine model for programmable line-rate switches ( §2). Banzai models two important constraints ( §2.4) for stateful line-rate operations: the inability to share state between different packet-processing units, and the requirement that any switch state modifications be visible to the next packet entering the switch. Based on these constraints, we introduce atoms to represent a programmable switch's packet-processing units.</p><p>Second, Domino, a new domain-specific language (DSL) for data-plane algorithms, with packet transactions at its core ( §3). Domino is an imperative language with C-like syntax, to our knowledge the first to offer such a high-level programming abstraction for line-rate switches.</p><p>Third, a compiler from Domino packet transactions to a Banzai target ( §4). The Domino compiler extracts codelets from transactions: code fragments, which if executed atomically, guarantee a packet transaction's semantics. It then uses program synthesis <ref type="bibr" target="#b58">[59]</ref> to map codelets to atoms, rejecting the transaction if the atom cannot execute the codelet.</p><p>We evaluate expressiveness by programming a variety of data-plane algorithms (Table <ref type="table" target="#tab_5">3</ref>) in Domino and compare with P4. We find that Domino provides a more concise and natural programming model for stateful data-plane algo-rithms. Next, because no existing programmable switch supports the set of atoms required for our data-plane algorithms, we design a set of compiler targets for these algorithms based on Banzai ( §5.2). We show that these targets are feasible in a 32-nm standard-cell library with &lt; 2% cost in area relative to a 200 mm 2 baseline switching chip <ref type="bibr" target="#b39">[40]</ref>. Finally, we compile data-plane algorithms written in Domino to these targets ( §5.3) to show how a target's atoms determine the algorithms it can support. We conclude with several lessons for programmable switch design ( §5.4).</p><p>Code for the Domino compiler, the Banzai machine model, and the code examples listed in Table <ref type="table" target="#tab_5">3</ref> is available at http://web.mit.edu/domino.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A MACHINE MODEL FOR LINE-RATE SWITCHES</head><p>Banzai is a machine model for programmable line-rate switches that serves as the compiler target for Domino. Banzai is inspired by recent programmable switch architectures such as Barefoot Networks' Tofino <ref type="bibr" target="#b3">[3]</ref>, Intel's FlexPipe <ref type="bibr" target="#b13">[13]</ref>, and Cavium's XPliant Packet Architecture <ref type="bibr" target="#b18">[19]</ref>. Banzai abstracts these architectures and extends them with stateful processing units to implement data-plane algorithms. These processing units, called atoms, model atomic operations that are natively supported by a programmable line-rate switch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Background: Programmable switches</head><p>Packets arriving at a switch (top half of Figure <ref type="figure">1</ref>) are parsed by a programmable parser that turns packets into header fields. These header fields are first processed by an ingress pipeline consisting of match-action tables arranged in stages. Processing a packet at a stage may modify its header fields, through match-action rules, as well as some persistent state at that stage, e.g., packet counters. After the ingress pipeline, the packet is queued. Once the scheduler dequeues the packet, it is processed by a similar egress pipeline before it is transmitted.</p><p>To reduce chip area, there is only one ingress and one egress pipeline. This single pipeline is shared across all switch ports and handles aggregate traffic belonging to all ports, at all packet sizes. For instance, a 64-port switch with a line rate of 10 Gbit/s per port and a minimum packet size of 64 bytes needs to process around a billion packets per second, after accounting for minimum inter-packet gaps <ref type="bibr" target="#b27">[28]</ref>. Equivalently, the pipeline runs at 1 GHz, and pipeline stages process a packet every clock cycle (1 ns). We assume one packet per clock cycle throughout the paper, and for concreteness, a 1 GHz clock frequency.</p><p>Having to process a packet every clock cycle in each stage constrains the operations that can be performed on each packet. In particular, any packet operation that modifies state visible to the next packet must finish execution in a single clock cycle ( §2.3 shows why). Because of this restriction, programmable switching chips provide a small set of processing units or primitives for manipulating packets and state in a stage, unlike software routers. These primitives determine which algorithms run on the switch at line rate. The challenge for us is to develop primitives that allow a broad range of data-plane algorithms to be implemented, and to build a compiler to map a user-friendly description of an algorithm to the primitives provided by a switch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Banzai machine model</head><p>Banzai (the bottom half of Figure <ref type="figure">1</ref>) models the ingress or egress switch pipeline. It models the computation within a match-action table in a stage (i.e., the action half of the match-action table), but not how packets are matched (e.g., direct or ternary). Banzai does not model packet parsing and assumes that packets arriving to Banzai are already parsed.</p><p>Concretely, Banzai is a feed-forward pipeline<ref type="foot" target="#foot_0">1</ref> consisting of a number of stages executing synchronously on every clock cycle. Each stage processes one packet every clock cycle and hands it off to the next. Unlike a CPU pipeline, which occasionally experiences pipeline stalls, Banzai's pipeline is deterministic, never stalls, and always sustains line rate. However, relative to a CPU pipeline, Banzai is restricted in the operations it supports ( §2.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Atoms: Banzai's processing units</head><p>An atom is an atomic unit of packet processing supported natively by a Banzai machine, and the atoms within a Banzai machine form its instruction set. Each pipeline stage in Banzai contains a vector of atoms. Atoms in this vector modify mutually exclusive sections of the same packet header in parallel in every clock cycle, and process a new packet header every clock cycle.</p><p>In addition to packet headers, atoms may modify persistent state on the switch to implement stateful data-plane algorithms. To support such algorithms at line-rate, the atoms for a Banzai machine need to be substantially richer (Table 4) than the simple RISC-like stateless instruction sets for programmable switches today <ref type="bibr" target="#b27">[28]</ref>. We explain why below.</p><p>Suppose we need to atomically increment a switch counter to count packets. One approach is hardware support for three simple single-cycle operations: read the counter from memory in the first clock cycle, add one in the next, and write it to memory in the third. This approach, however, does not provide atomicity. To see why, suppose packet A increments the counter from 0 to 1 by executing its read, add, and write at clock cycles 1, 2, and 3 respectively. If packet B issues its read at time 2, it will increment the counter again from 0 to 1, when it should be incremented to 2.</p><p>Locks over the shared counter are a potential solution. However, locking causes packet B to wait during packet A's increment, and the switch no longer sustains the line rate of one packet every clock cycle. CPUs employ microarchitectural techniques such as operand forwarding for this problem. But these techniques still suffer pipeline stalls, which prevents line-rate performance from being achieved.</p><p>Banzai provides an atomic increment operation at line rate with an atom to read a counter, increment it, and write it back in a single stage within one clock cycle. It uses the same approach of reading, modifying, and writing back to implement other stateful atomic operations at line rate.</p><p>Unlike stateful atomic operations, stateless atomic operations are easier to support with simple packet-field arithmetic. Consider, for instance, the operation pkt.f1 = pkt.f2 + pkt.f3 -pkt.f4. This operation does not modify any persistent switch state and only accesses packet fields. It can be implemented atomically by using two atoms: one atom to add fields f2 and f3 in one pipeline stage, and another to subtract f4 from the result in the next. An instruction set designer can provide simple stateless instructions operating on a pair of packet fields. These instructions can then be composed into larger stateless operations, without designing atoms specifically for each stateless operation.</p><p>Representing atoms. An atom is represented by a body of sequential code that captures the atom's behavior. It may also contain internal state local to the atom. An atom completes execution of this entire body of code, modifying a packet and any internal state before processing the next packet. The designer of a programmable switch would develop these atoms, and expose them to a switch compiler as the programmable switch's instruction set, e.g., Table <ref type="table" target="#tab_6">4</ref>.</p><p>Using this representation, a switch counter that wraps around at a value of 100 can be written as the atom: 2 if ( counter &lt; 99) counter ++; else counter = 0;</p><p>Similarly, a stateless operation like setting a packet field to a constant value can be written as the atom:</p><p>pkt . field = value ;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Constraints for line-rate operation</head><p>Memory limits. State in Banzai is local to each atom. It can neither be shared by atoms within a stage, nor atoms across stages. This is because building multi-ported memories accessible to multiple atoms is technically challenging and consumes additional chip area. However, state can be read into a packet header in one stage, for subsequent use by a downstream stage 3 . But, the Banzai pipeline is feedforward, so state can only be carried forward, not backward.</p><p>Computational limits. Atoms need to execute atomically from one packet to the next, so any state internal to the atom must be updated before the next packet arrives. Because packets may be separated by as little as one clock cycle, we mandate that atom bodies finish execution within one clock cycle, and constrain atom bodies to do so.</p><p>We constrain atom bodies by defining atom templates ( §4.3). An atom template is a program with configurable parameters that terminates within a clock cycle and specifies 2 We use p.x to represent field x within a packet p and x to represent a state variable x that persists across packets. 3 Figure <ref type="figure" target="#fig_2">3b</ref> shows an example. last_time is read into pkt.last_time in stage 2, for subsequent use by stage 3. the atom's behavior. An example is an ALU with a restricted set of primitive operations (Figure <ref type="figure" target="#fig_1">2a</ref>).  Resource limits. We also limit the number of atoms in each stage (pipeline width) and the number of stages in the pipeline (pipeline depth). This is similar to limits on the number of stages, tables per stage, and memory per stage in programmable switch architectures <ref type="bibr" target="#b42">[43]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">What can Banzai not do?</head><p>Banzai is a good fit for data-plane algorithms that modify a small set of packet headers and carry out small amounts of computation per packet. Data-plane algorithms like deep packet inspection and WAN optimization require a switch to parse and process the packet payload as well-effectively parsing a large "header" consisting of each byte in the payload. This is challenging at line rates of 1 GHz, and such algorithms are best left to CPUs <ref type="bibr" target="#b51">[52]</ref>. Some algorithms require complex computations, but not on every packet, e.g., a measurement algorithm that periodically scans a large table to perform garbage collection. Banzai's atoms model small operations that occur on every packet, and are unsuitable for such operations that span many clock cycles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PACKET TRANSACTIONS</head><p>A programmer programs a data-plane algorithm by writing it as a packet transaction in Domino (Figure <ref type="figure" target="#fig_2">3a</ref>). The Domino compiler then compiles this transaction to an atom pipeline for a Banzai machine (Figure <ref type="figure" target="#fig_2">3b</ref>). We first describe packet transactions in greater detail by walking through an example ( §3.1). Next, we discuss language constraints in Domino ( §3.2) informed by line-rate switches. We then discuss triggering packet transactions ( §3.3) and handling multiple transactions ( §3.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Domino by example</head><p>We use flowlet switching <ref type="bibr" target="#b56">[57]</ref> as our running example. Flowlet switching is a load-balancing algorithm that sends bursts of packets, called flowlets, from a TCP flow on a randomly chosen next hop, provided the bursts are separated by a large enough time interval to ensure packets do not arrive out of order at a TCP receiver. For ease of exposition, we  Figure <ref type="figure" target="#fig_2">3a</ref> shows flowlet switching in Domino and demonstrates its core language constructs. All packet processing happens in the context of a packet transaction (the function flowlet starting at line 17). The function's argument type Packet declares the fields in a packet (lines 5-12) <ref type="foot" target="#foot_1">4</ref> that can be referenced by the function body (lines 18-32). The function body can also modify persistent switch state using global variables (e.g., last_time and saved_hop on lines 14 and 15, respectively). The function body may use intrinsics such as hash2 on line 23 to directly access hardware accelerators on the switch such as hash generators. The Domino compiler uses an intrinsic's signature to analyze read/write dependencies ( §4.2), but otherwise considers it a blackbox.</p><p>Packet transaction semantics. Semantically, the programmer views the switch as invoking the packet transaction serially in the order in which packets arrive, with no concurrent packet processing. Put differently, the packet transaction modifies the passed-in packet argument and runs to completion, before starting on the next packet. These se-mantics allow the programmer to program under the illusion that a single, extremely fast, processor is serially executing the packet processing code for all packets. The programmer doesn't worry about parallelizing the code within and across pipeline stages to run at line rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Domino language</head><p>Domino's syntax (Figure <ref type="figure" target="#fig_4">4</ref>) is similar to C, but with several constraints (Table <ref type="table">1</ref>). These constraints are required for deterministic performance. Memory allocation, unbounded iteration counts, and unstructured control flow cause variable performance, which may prevent an algorithm from achieving line rate. Additionally, within a Domino transaction, each array can only be accessed using a single packet field, and repeated accesses to the same array are allowed only if that packet field is unmodified between accesses.</p><p>For example, all read and write accesses to last_time use the index pkt.id. pkt.id is not modified during the course of a single transaction execution (single packet); it only changes between executions (packets). This restriction on arrays mirrors restrictions on the stateful memories attached to atoms ( §2.4), which require multiple ports to support distinct read and write addresses every clock cycle.</p><p>No iteration (while, for, do-while). No unstructured control flow (goto, break, continue). No heap, dynamic memory allocation, or pointers. At most one location in each array is accessed by a single execution of a transaction. No access to unparsed portions of the packet (payload).</p><p>Table <ref type="table">1</ref>: Restrictions in Domino  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Triggering packet transactions</head><p>Packet transactions specify how to process packet headers and state. To specify when to run packet transactions, programmers use guards: predicates on packet fields that trigger a transaction if a packet matches the guard. For example, (pkt.tcp_dst_port == 80) would trigger heavy-hitter detection <ref type="bibr" target="#b62">[63]</ref> on packets with TCP destination port 80.</p><p>Guards can be realized using an exact match in a matchaction table, with the actions being the atoms compiled from a packet transaction. Guards can take various forms, e.g., exact, ternary, longest-prefix, and range-based matches, depending on the matches supported by the match-action pipeline. Because guards map straightforwardly to the match key in a match-action table, we focus only on compiling packet transactions in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Handling multiple transactions</head><p>So far, we have discussed a single packet transaction corresponding to a single data-plane algorithm. In practice, a switch would run multiple data-plane algorithms, each processing its own subset of packets. To address this, we envision a policy language that specifies pairs of guards and transactions. Realizing a policy is straightforward when all guards are disjoint. When guards overlap, multiple transactions need to execute on the same subset of packets, requiring a mechanism to compose transactions.</p><p>One composition semantics is to run the two transactions one after another sequentially in a user-specified order. This can be achieved by concatenating the two transaction bodies to create a larger transaction. We leave a detailed exploration of multiple transactions to future work, and focus only on compiling a single packet transaction here.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE DOMINO COMPILER</head><p>The Domino compiler translates Domino programs to Banzai targets. The compiler provides an all-or-nothing model: if compilation succeeds, the program will run at line rate on the target with packet transaction semantics. Otherwise, if the program cannot run at line rate, it will not compile. This all-or-nothing model trades off diminished programmability for guaranteed line-rate performance, in contrast to software routers that provide greater flexibility, but lower and unpredictable run-time performance <ref type="bibr" target="#b33">[34]</ref>.</p><p>The Domino compiler has three passes (Figure <ref type="figure" target="#fig_5">5</ref>), which we illustrate using the flowlet switching example. Preprocessing ( §4.1) simplifies packet transactions into a simpler three-address code form <ref type="bibr">[18]</ref>. Pipelining ( §4.2) transforms preprocessed code into code for a Pipelined Virtual Switch Machine (PVSM), an intermediate representation that models a switch pipeline with no computational or resource limits. Code generation ( §4.3) transforms this intermediate representation into configuration for a Banzai machine, given the machine's computational and resource limits ( §2.4), and rejects the program if it can not run at line rate. The Domino compiler uses many existing compilation techniques, but adapts them in important ways for line-rate switches ( §4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Preprocessing</head><p>Branch removal. A packet transaction's body can contain (potentially nested) branches (e.g., Lines 27 to 29 in Figure <ref type="figure" target="#fig_2">3a</ref>). Branches alter control flow and complicate dependency analysis, i.e., whether a statement should precede another. We transform branches into conditional assignments, starting from the innermost if and proceeding outwards (Figure <ref type="figure">6</ref>). This turns the transaction body into straight-line code with no branches, which simplifies dependency analysis during pipelining ( §4.2).</p><p>Rewriting state variable operations. We now identify state variables in a packet transaction, e.g., last_time and saved_hop in Figure <ref type="figure" target="#fig_2">3a</ref>. For each state variable, we create a read flank to read the variable into a temporary packet field. For an array, we also move the index expression into the read flank using the fact that only one array index is accessed per packet ( §3.2). Within the packet transaction, we replace the state variable with the temporary packet field, and create a write flank to write this temporary packet field back to the state variable (Figure <ref type="figure">7</ref>). After this, the only operations on state variables are reads and writes; all arithmetic happens on packet fields. Restricting stateful operations simplifies handling of state during pipelining ( §4.2).</p><p>Converting to static single-assignment form.</p><p>We next convert the code to static single-assignment form (SSA) <ref type="bibr" target="#b31">[32]</ref>, where every packet field is assigned exactly once. We do this by replacing every assignment to a packet field with a new packet field and propagating this until the next assignment to the same field (Figure <ref type="figure">8</ref>) . Because fields are assigned once, SSA removes Write-After-Read and Write-After-Write dependencies. Only Read-After-Write dependencies remain during pipelining ( §4.2).</p><p>Flattening to three-address code. Three-address code is a representation where all instructions are either reads/writes into state variables or operations on packet fields of the form pkt.f1 = pkt.f2 op pkt.f3, where op can be an arithmetic, logical, relational, or conditional <ref type="foot" target="#foot_2">5</ref> operator. We also allow either one of pkt.f2 or pkt.f3 to be an intrinsic function call. To convert to three-address code, we flatten expressions that are not in three-address code using temporary packet fields, e.g., pkt.tmp2 in Figure <ref type="figure" target="#fig_6">9</ref>.</p><p>Flattening to three-address code breaks down statements in the packet transaction into a much simpler form that is closer to the atoms available in the Banzai machine. For instance, there are no nested expressions. The simpler form of three-address code statements makes it easier to map them one-to-one to atoms during code generation ( §4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Pipelining</head><p>At this point, the preprocessed code is still one sequential code block. Pipelining turns this sequential code block into a pipeline of codelets, where each codelet is a sequential block of three-address code statements. This codelet pipeline corresponds to an intermediate representation we call the Pipelined Virtual Switch Machine (PVSM). PVSM has no computational or resource limits, analogous to intermediate representations for CPUs <ref type="bibr" target="#b15">[15]</ref> that have infinite virtual registers. Later, during code generation, we map these codelets to atoms available in a Banzai machine while respecting its constraints.</p><p>We create PVSM's codelet pipeline using the steps below. 1. Create a graph with one node for each statement in the preprocessed code. 2. Now, add stateful dependencies by adding a pair of edges between the read and write flanks of the same state variable, e.g., in Figure <ref type="figure" target="#fig_8">10a</ref>, the node pair pkt.last_time = last_time[pkt.id] and last_time[pkt.id] = pkt.arrival. Because of preprocessing, all stateful operations are paired up as read and write flanks. Hence, there is no risk of a "stranded" stateful operation. 3. Now, add stateless dependencies by adding an edge from any node that writes a packet variable to any node that reads the same packet variable, e.g., from pkt.tmp = pkt.arrival -pkt.last_time to pkt.tmp2 = pkt.tmp &gt; THRESH in Figure <ref type="figure" target="#fig_8">10a</ref>. We only check read-after-write dependencies because write-after-read and write-after-write dependencies don't exist after SSA, and we eliminate control dependencies <ref type="bibr" target="#b31">[32]</ref> through branch removal. 4. Generate strongly connected components (SCCs) of this dependency graph and condense them into a directed acyclic graph (DAG). This captures the notion that all operations on a state variable must be confined to one codelet/atom because state cannot be shared between atoms. Figure <ref type="figure" target="#fig_8">10b</ref> shows the DAG produced by condensing Figure <ref type="figure" target="#fig_8">10a</ref>. 5. Schedule the resulting DAG by creating a new pipeline stage when one node depends on another. This results in the codelet pipeline shown in Figure <ref type="figure" target="#fig_2">3b</ref>. <ref type="foot" target="#foot_3">6</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Code generation</head><p>To determine if a codelet pipeline can be compiled to a Banzai machine, we consider two constraints specified by any Banzai machine ( §2.4). Resource limits specify the number of atoms in a stage (pipeline width) and number of stages (pipeline depth), while computational limits specify the atom templates provided by a Banzai machine.</p><p>Resource limits. To handle resource limits, we scan each pipeline stage in the codelet pipeline starting from the first to check for pipeline width violations. If we violate the pipeline width, we insert as many new stages as required and spread codelets evenly across these stages. We continue until the number of codelets in all stages is under the pipeline width, rejecting the program if we exceed the pipeline depth.</p><p>Computational limits. Next, we determine if each codelet in the pipeline can be mapped to atoms provided by the Banzai machine. In general, codelets have multiple threeaddress code statements that need to execute atomically. For instance, updating the state variable saved_hop in Figure <ref type="figure" target="#fig_2">3b</ref> requires a read followed by a conditional write. It is not apparent whether such codelets can be mapped to an available atom. We develop a new technique to determine the implementability of a codelet, given an atom template.</p><p>Each atom template has a set of configuration parameters, where the parameters determine the atom's behavior. For instance, Figure <ref type="figure" target="#fig_1">2a</ref> shows an atom that can perform stateful addition or subtraction, depending on the configuration parameters choice and constant. Each codelet can be viewed as a functional specification of the atom. With that in mind, the mapping problem is equivalent to searching for values of the atom's configuration parameters that result in the atom implementing the codelet.</p><p>We use the SKETCH program synthesizer <ref type="bibr" target="#b58">[59]</ref> for this purpose, as the atom templates can be easily expressed using SKETCH. SKETCH also provides efficient search algorithms and has been used for similar purposes in other domains <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref>. As an illustration, assume we want to map the codelet x=x+1 to the atom template shown in Figure <ref type="figure" target="#fig_1">2b</ref>. SKETCH will search for possible parameter values so that the resulting atom is functionally identical to the codelet, for all possible input values of x up to a certain bound. In this case, SKETCH finds the solution with choice=0 and    If-Conversion <ref type="bibr" target="#b22">[23]</ref> No backward control flow (gotos, break, continue) SSA Cytron et al. <ref type="bibr" target="#b31">[32]</ref> SSA runs on straight-line code with no branches Strongly Connected Components Lam <ref type="bibr" target="#b47">[48]</ref> Scheduling in space vs. time Code generation using program synthesis Chlorophyll <ref type="bibr" target="#b52">[53]</ref>, technology mapping <ref type="bibr" target="#b48">[49]</ref>, instruction selection <ref type="bibr" target="#b19">[20]</ref> Optimal vs. best-effort mapping, One-to-one mapping vs. one-to-many mapping Using program synthesis for code generation frees the compiler developer from implementing custom code generators for different Banzai machines. Instead, the compiler developer only has to express the Banzai machine's atom templates using SKETCH, and the SKETCH synthesizer automatically maps codelets to atoms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Related compiler techniques</head><p>Table <ref type="table" target="#tab_4">2</ref> shows the relationship between Domino's compilation techniques and prior work. The use of Strongly Connected Components (SCCs) is inspired by software pipelining for VLIW architectures <ref type="bibr" target="#b47">[48]</ref>. The size of the largest SCC affects the maximum throughput of the pipelined loop in software pipelining. For Domino, it affects the circuit area of the atom required to run a program at line rate. Domino trades off an increase in space for line-rate performance.</p><p>Program synthesis was used for code generation in Chlorophyll <ref type="bibr" target="#b52">[53]</ref>. Code generation for Domino also shares similar goals to technology mapping <ref type="bibr" target="#b48">[49]</ref> and instruction selection <ref type="bibr" target="#b19">[20]</ref>. However, prior work maps a code sequence to multiple instructions/tiles, using heuristics to minimize instruction count. Domino's problem is simpler: we map each codelet to a single atom using SKETCH. The simpler problem allows a non-heuristic solution: if there is any way to map the codelet to an atom, SKETCH will find it.</p><p>Branch removal resembles If-Conversion <ref type="bibr" target="#b22">[23]</ref>, a technique used in vectorizing compilers. This procedure is easier in Domino because there is no backward control transfer (goto, break, continue).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>We evaluate Domino's expressiveness by using it to program several data-plane algorithms (Table <ref type="table" target="#tab_5">3</ref>), and comparing it to writing them in P4 ( §5.1). To validate that these algorithms can run at line rate, we design a concrete set of Banzai machines (Table <ref type="table" target="#tab_6">4</ref>) as compiler targets for Domino ( §5.2). We estimate that these machines are feasible in hardware because their atoms incur modest chip area overhead. We use the Domino compiler to compile the algorithms in Table <ref type="table" target="#tab_5">3</ref> to the targets in Table 4 ( §5.3). We conclude with some lessons for programmable switch design ( §5.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Expressiveness</head><p>We program several data-plane algorithms (Table <ref type="table" target="#tab_5">3</ref>) using Domino. These algorithms encompass data-plane traffic engineering, in-network congestion control, active queue management, network security, and measurement. We also used Domino to express the priority computation for programming scheduling using push-in first-out queues <ref type="bibr" target="#b57">[58]</ref>.</p><p>In all these cases, the algorithms are already available as blocks of imperative code from online sources; translating them to Domino syntax was straightforward. In contrast, expressing any of them in P4 requires manually teasing out portions of the algorithm that can reside in independent match-action tables and then chaining these tables together.</p><p>Of the algorithms in Table <ref type="table" target="#tab_5">3</ref>, only flowlet switching has a publicly available P4 implementation <ref type="bibr">[9]</ref> that we can compare against. This implementation requires 231 lines of uncommented P4, compared to only 37 lines of Domino code in Figure <ref type="figure" target="#fig_2">3a</ref>. Not only that, using P4 also requires the programmer to manually specify tables, the actions within tables, and how tables are chained-all to implement a single data-plane algorithm. The Domino compiler automates this process; to demonstrate this, we developed a backend for Domino that generates the equivalent P4 code. We list the number of lines of code for these auto-generated P4 programs in Table <ref type="table" target="#tab_5">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Compiler targets</head><p>We design a set of compiler targets for Domino based on the Banzai machine model ( §2). First, we describe how to assess the feasibility of atoms: whether they can run at a 1 GHz clock frequency, and what area overhead they incur in silicon. Next, we discuss the design of stateless and stateful atoms separately. Finally, we discuss how these stateless and stateful atoms are combined together in our compiler targets.</p><p>Atom feasibility. We synthesize a digital circuit corresponding to an atom template by writing the atom template in Verilog, and using the Synopsys Design Compiler <ref type="bibr" target="#b7">[7]</ref> to compile the Verilog code. The Design Compiler checks if the resulting circuit meets timing at 1 GHz in a 32-nm standard-cell library, and outputs its gate area. We use this gate area, along with the area of a 200 mm 2 baseline switching chip <ref type="bibr" target="#b39">[40]</ref>, to estimate the area overhead for provisioning a Banzai machine with multiple instances of this atom.</p><p>Designing stateless atoms. Stateless atoms are easier to design because arbitrary stateless operations can be broken up into multiple pipeline stages without violating atomicity ( §2.3). We design a stateless atom that can support simple arithmetic (add, subtract, left shift, right shift), logical (and, or, xor), relational (&gt;=, &lt;=, ==, !=), and conditional instructions (C's "?" operator) on a pair of packet fields. Any packet field can also be substituted with a constant operand. This stateless atom meets timing at 1 GHz and occupies an area of 1384 µm 2 (Table <ref type="table" target="#tab_6">4</ref>).</p><p>Designing stateful atoms. The choice of stateful atoms determines the algorithms a line-rate switch can support. A more complex stateful atom can support more data-plane al- To illustrate this effect, we design a containment hierarchy (Table <ref type="table" target="#tab_6">4</ref>) of stateful atoms, where each atom can express all stateful operations that its predecessor can. These atoms start out with the simplest stateful capability: the ability to read or write state alone. They then move on to the ability to read, add, and write back state atomically (RAW), a predicated version of the same (PRAW), and so on. When synthesized to a 32-nm standard-cell library, all our stateful atoms meet timing at 1 GHz. However, the atom's area and minimum end-to-end propagation delay increases with the atom's complexity (Table <ref type="table" target="#tab_6">4</ref>).</p><p>The compiler targets. We design seven Banzai machines as compiler targets. A single Banzai machine has 600 atoms. 1. 300 are stateless atoms of the single stateless atom type from Table <ref type="table" target="#tab_6">4</ref>. 2. 300 are stateful atoms of one of the seven stateful atom types from Table <ref type="table" target="#tab_6">4</ref> (Read/Write through Pairs). These 300 stateless and stateful atoms are laid out physically as 10 stateless and stateful atoms per pipeline stage and 30 pipeline stages. While the number 300 and the pipeline layout are arbitrary, they are sufficient for all examples in Ta-ble 3, and incur modest area overhead as we show next.</p><p>We estimate the area overhead of these seven targets relative to a 200 mm 2 chip <ref type="bibr" target="#b39">[40]</ref>, which is at the lower end of chip sizes today. For this, we multiply the individual atom areas from Table <ref type="table" target="#tab_6">4</ref> by 300 for both the stateless and stateful atoms. For 300 atoms, the area overhead is 0.2 % for the stateless atom and 0.9 % for the Pairs atom, the largest among our stateful atoms. The area overhead combining both stateless and stateful atoms for all our targets is at most 1.1%-a modest price for the programmability it provides.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Compiling Domino programs to Banzai machines</head><p>We now consider every target from Table <ref type="table" target="#tab_6">4</ref> <ref type="foot" target="#foot_4">7</ref> , and every data-plane algorithm from Table <ref type="table" target="#tab_5">3</ref> to determine if the algorithm can run at line rate on a particular Banzai machine.</p><p>We say an algorithm can run at line rate on a Banzai machine if every codelet within the data-plane algorithm can be mapped ( §4. are arranged in a containment hierarchy, we list the most expressive stateful atom/target required for each data-plane algorithm in Table <ref type="table" target="#tab_5">3</ref>.</p><p>As Table <ref type="table" target="#tab_5">3</ref> shows, the choice of stateful atom determines what algorithms can run on a switch. For instance, with only the ability to read or write state, only the Bloom Filter algorithm can run at line rate, because it only requires the ability to test and set membership bits. Adding the ability to increment state (the RAW atom) permits Heavy Hitters to run at line rate, because it employs a count-min sketch that is incremented on each packet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Lessons for programmable switches</head><p>Atoms with a single state variable support many algorithms. The algorithms from Bloom Filter through DNS TTL Change Tracking in Table <ref type="table" target="#tab_5">3</ref>  Here, best_path (the path id of the best path for a particular destination) is updated conditioned on best_path_util (the utilization of the best path to that destination) <ref type="foot" target="#foot_5">8</ref> and vice versa. These two state variables cannot be separated into different stages and still guarantee a packet transaction's semantics. The Pairs atom, where the update to a state variable is conditioned on a predicate of a pair of state variables, allows CONGA to run at line rate.</p><p>There will always be algorithms that cannot sustain line rate. While the targets and their atoms in Table <ref type="table" target="#tab_6">4</ref> are sufficient for several data-plane algorithms, there are algorithms that they can't run at line rate. An example is CoDel, which cannot be implemented because it requires a square root operation that isn't provided by any of our targets. One possibility is a look-up table abstraction that allows us to approximate such mathematical functions. However, regardless of what set of atoms we design for a particular target, there will always be algorithms that cannot run at line rate.</p><p>Atom design is constrained by timing, not area. Atoms are affected by two factors: their area and their timing, i.e., the minimum delay on the critical path of the atom's combinational circuit. For the few hundred atoms that we require, atom area is insignificant (&lt; 2%) relative to chip area. Further, even for future atoms that are larger, area may be controlled by provisioning fewer atom instances.</p><p>However, atom timing is critical. Table <ref type="table" target="#tab_6">4</ref> shows a 3.4x range in minimum critical-path delay between the simplest and the most complex atoms. This increase can be explained by looking at the simplified circuit diagrams for the first three atoms (Table <ref type="table" target="#tab_8">5</ref>), which show an increase in circuit depth with atom complexity.</p><p>Because the clock frequency of a circuit is at least as small as the reciprocal of this minimum critical-path delay, a more complex atom results in a lower clock frequency and a lower line rate. Although all our atoms have a minimum criticalpath delay under 1 ns (1 GHz), it is easy to extend them with functionality that violates timing at 1 GHz.</p><p>In summary, for a switch designer, the minimum delay on the critical path of atoms is the most important metric to optimize. The most programmable line-rate switches will have the highest density of useful stateful functionality squeezed into a critical path budget of 1 clock cycle.</p><p>Compilers can be used to design instruction sets. Designing an instruction set for a programmable substrate is a chicken-and-egg problem: the choice of instructions determines which algorithms can execute on that target, while the choice of algorithms dictates what instructions are required in the target. Indeed, other programmable substrates (GPUs, CPUs, DSPs) go through an iterative process to design a good instruction set.</p><p>A compiler can aid this process. To show how, we describe how we designed the stateful atoms in Table <ref type="table" target="#tab_6">4</ref>. We pick a data-plane algorithm, partially execute the Domino compiler to generate a codelet pipeline, inspect the stateful codelets, and create an atom that expresses all the computations required by the stateful codelets. We check that an atom can express all these computations by fully executing the compiler on the data-plane algorithm with that atom as the target. We then move on to the next algorithm, extending our atom through a process of trial-and-error to capture more computations, and using the compiler to verify our intuitions on extending atoms. In the process, we generate a hierarchy of atoms, each of which works for a subset of algorithms.</p><p>Our atom design process is manual and ad hoc at this point, but it already shows how a compiler can aid in instruction-set design for programmable switches. Using the same iterative approach involving a compiler, we anticipate the atoms in Banzai machines evolving as data-plane algorithms demand more of the hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Abstract machines for line-rate switches. NetASM <ref type="bibr" target="#b54">[55]</ref> is an abstract machine and intermediate representation (IR) for programmable data planes that is portable across network devices: FPGAs, virtual switches, and line-rate switches. Banzai is a low-level machine model for line-rate switches alone and can be used as a NetASM target. Because of its role as a low-level machine model, Banzai models practical constraints required for line-rate operation ( §2.4) that an IR like NetASM doesn't have to. For instance, Banzai machines don't permit sharing state between atoms and use atom templates to limit computations that can happen at line rate.</p><p>Programmable data planes. Eden <ref type="bibr" target="#b24">[25]</ref> provides a programmable data plane using commodity switches by programming end hosts alone. Domino targets programmable switches that provide more flexibility relative to an endhost-only solution. For instance, Domino allows us to program in-network congestion control and AQM schemes, which are beyond Eden's capabilities. Tiny Packet Programs (TPP) <ref type="bibr" target="#b41">[42]</ref> allow end hosts to embed small programs in packet headers, which are then executed by the switch. TPPs use a restricted instruction set to facilitate switch execution; we show that switch instructions must and can be substantially richer (Table <ref type="table" target="#tab_6">4</ref>) for stateful data-plane algorithms.</p><p>Software routers <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b45">46]</ref> and network processors <ref type="bibr" target="#b14">[14]</ref> are flexible, but at least 10×-100× slower than programmable switches <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b3">3]</ref>. FPGA-based platforms like the Corsa DP 6440 [1], which supports an aggregate capacity of 640 Gbit/s, are faster, but still 5×-10× slower than programmable switches <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b18">19]</ref>.</p><p>Programming languages for networks. Many programming languages target the network control plane <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b61">62]</ref>. Domino focuses on the data plane, which requires different programming constructs and compilation techniques.</p><p>Several DSLs target the data plane. Click <ref type="bibr" target="#b45">[46]</ref> uses C++ for packet processing on software routers. packetC <ref type="bibr" target="#b35">[36]</ref>, Intel's auto-partitioning C compiler <ref type="bibr" target="#b32">[33]</ref>, and Microengine C <ref type="bibr" target="#b12">[12]</ref> target network processors. Domino's C-like syntax and sequential semantics are inspired by these DSLs. However, because it targets line-rate switches, Domino is more constrained. For instance, because compiled programs run at line rate, Domino forbids loops, and because Banzai has no shared state, Domino has no synchronization constructs.</p><p>Jose et al. <ref type="bibr" target="#b42">[43]</ref> focus on compiling P4 programs to programmable data planes such as the RMT and FlexPipe architectures. Their work focuses only on compiling stateless data-plane tasks such as forwarding and routing, while Domino handles stateful data-plane algorithms.</p><p>Abstractions for stateful packet processing. SNAP <ref type="bibr" target="#b23">[24]</ref> programs stateful data-plane algorithms using a network transaction: an atomic block of code that treats the entire network as one switch <ref type="bibr" target="#b43">[44]</ref>. It then uses a compiler to translate network transactions into rules on each switch. SNAP needs a compiler to compile these switch-local rules to a switch's pipeline, and can use Domino for this purpose.</p><p>FAST <ref type="bibr" target="#b49">[50]</ref> provides switch support and software abstractions for state machines. Banzai's atoms support more general stateful processing beyond state machines that enable a much wider class of data-plane algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">DISCUSSION</head><p>Packet transactions provide a pathway to take algorithms that were hitherto meant only for software routers and run them on emerging programmable line-rate switching chips. However, more work must be done before packet transactions are ready for production use.</p><p>1. Packet transactions provide the first transactional semantics for line-rate packet processing. These semantics make it easier to reason about correctness and performance, but they exclude algorithms that cannot run at line rate while respecting these semantics. Are weaker semantics sensible? One possibility is approximating transactional semantics by only processing a sampled packet stream. This provides an increased time budget for each packet in the sampled stream, potentially allowing the packet to be recirculated through the pipeline multiple times for packet processing. 2. Our compiler doesn't aggressively optimize. For instance, it is possible to fuse two stateful codelets incrementing two independent counters into the same instance of the Pairs atom. However, by carrying out a one-to-one mapping from codelets to the atoms implementing them, our compiler precludes these optimizations. Developing an optimizing compiler for packet transactions is an area for future work. 3. Supporting multiple packet transactions in Domino also requires further work. When a switch executes multiple transactions, there may be opportunities for inter-procedural analysis <ref type="bibr" target="#b19">[20]</ref>, which goes beyond compiling individual transactions and looks at multiple transactions together. For instance, the compiler could detect computations common to multiple transactions and execute them only once. 4. Finally, we have a manual design process for atoms.</p><p>Formalizing this design process and automating it into an atom-design tool would be useful for switch designers. For instance, given a corpus of data-plane algorithms, can we automatically mine this corpus for stateful and stateless codelets, and design an atom (or atoms) that captures the computations required by some (or all) of them?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>This paper presented Domino, a C-like imperative language that allows programmers to write packet-processing code using packet transactions, which are sequential code blocks that are atomic and isolated from other such code blocks. The Domino compiler compiles packet transactions to hardware configurations for Banzai, which is a machine model based on programmable line-rate switch architectures <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b3">3]</ref>. Our results suggest that it is possible to have both the convenience of a familiar programming model and the performance of a line-rate switch, provided that the algorithm can indeed run at line rate. Packet-processing languages are still in their infancy; we hope these results will prompt further work on programming abstractions for highperformance packet-processing hardware.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: An atom and its template. The atom above can add or subtract a constant from a state variable x based on two configurable parameters, constant and choice.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Programming flowlet switching in Domino</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>l</head><label></label><figDesc>∈ literals v ∈ variables bop ∈ binary ops uop ∈ unary ops e ∈ expressions ::= e.f | l | v | e bop e | uop e | e[d.f ] | f (e 1 , e 2 , . . .) s ∈ statements ::= e = e | if (e) {s} else {s} | s ; s t ∈ packet txns ::= name(v){s} d ∈ packet decls ::= {v 1 , v 2 , . . .} sv ∈ state var inits ::= v = e | sv ; sv p ∈ Domino programs ::= {d; sv; t}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Domino grammar. Type annotations (void, struct, int, and Packet) are elided for simplicity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Passes in the Domino compiler</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Flowlet switching in three-address code. Lines 1 and 4 are flipped relative to Figure 3a because pkt.id is an array index expression and is moved into the read flank.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>=⇒ pkt.next_hop = pkt.tmp2 ? pkt.new_hop : pkt.saved_hop saved_hop[pkt.id] = pkt.tmp2? pkt.new_hop : pkt.saved_hop pkt.id = hash2(pkt.sport, pkt.dport) % NUM_FLOWLETS pkt.last_time = last_time[pkt.id] pkt.tmp = pkt.arrival -pkt.last_time last_time[pkt.id] = pkt.arrival pkt.tmp2 = pkt.tmp &gt; THRESH pkt.new_hop = hash3(pkt.sport, pkt.dport, pkt.arrival) % NUM_HOPS pkt.saved_hop = saved_hop[pkt.id] (b) DAG after condensing SCCs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Dependency graphs before and after condensing strongly connected components</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Domino's compiler in relation to prior work constant=1. In contrast, if the specification is the codelet x=x*x, SKETCH will return an error as no parameters exist.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Data-plane algorithms gorithms, but may not meet timing and occupies more area.</figDesc><table><row><cell>Algorithm</cell><cell>Stateful operations</cell><cell>Most ex-</cell><cell># of stages,</cell><cell>Ingress</cell><cell>Domino</cell><cell>P4</cell></row><row><cell></cell><cell></cell><cell>pressive</cell><cell>max.</cell><cell>or</cell><cell>LOC</cell><cell>LOC</cell></row><row><cell></cell><cell></cell><cell>atom</cell><cell>atom-</cell><cell>Egress</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>s/stage</cell><cell>Pipeline?</cell><cell></cell><cell></cell></row><row><cell>Bloom filter (3 hash functions)</cell><cell>Test/Set membership bit on every packet.</cell><cell>Write</cell><cell>4, 3</cell><cell>Either</cell><cell>29</cell><cell>104</cell></row><row><cell>Heavy Hitters [63] (3 hash functions)</cell><cell>packet. Increment Count-Min Sketch [31] on every</cell><cell>RAW</cell><cell>10, 9</cell><cell>Either</cell><cell>35</cell><cell>192</cell></row><row><cell>Flowlets [57]</cell><cell>Update saved next hop if flowlet threshold</cell><cell>PRAW</cell><cell>6, 2</cell><cell>Ingress</cell><cell>37</cell><cell>107</cell></row><row><cell></cell><cell>is exceeded.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>RCP [60] Sampled NetFlow [17]</cell><cell>Accumulate RTT sum if RTT is under maximum allowable RTT. Sample a packet if packet count reaches N; Reset count to 0 when it reaches N.</cell><cell cols="2">PRAW IfElseRAW 4, 2 3, 3</cell><cell>Egress Either</cell><cell>23 18</cell><cell>75 70</cell></row><row><cell>HULL [22]</cell><cell>Update counter for virtual queue.</cell><cell>Sub</cell><cell>7, 1</cell><cell>Egress</cell><cell>26</cell><cell>95</cell></row><row><cell>Adaptive Virtual Queue [47]</cell><cell>pacity Update virtual queue size and virtual ca-</cell><cell>Nested</cell><cell>7, 3</cell><cell>Ingress</cell><cell>36</cell><cell>147</cell></row><row><cell>Priority computa-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>tion for weighted</cell><cell>Compute packet's virtual start time using</cell><cell>Nested</cell><cell>4, 2</cell><cell>Ingress</cell><cell>29</cell><cell>87</cell></row><row><cell>fair queueing [58]</cell><cell>finish time of last packet in that flow.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>DNS TTL change tracking [26]</cell><cell>TTL for each domain Track number of changes in announced</cell><cell>Nested</cell><cell>6,3</cell><cell>Ingress</cell><cell>27</cell><cell>119</cell></row><row><cell></cell><cell>Update best path's utilization/id if we see a</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>CONGA [21]</cell><cell>better path. Update best path utilization alone if it</cell><cell>Pairs</cell><cell>4, 2</cell><cell>Ingress</cell><cell>32</cell><cell>89</cell></row><row><cell></cell><cell>changes.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>Update:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>Whether we are marking or not.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>CoDel [51]</cell><cell>Time for next mark. Time at which min. queueing delay will Number of marks so far.</cell><cell>map Doesn't</cell><cell>15, 3</cell><cell>Egress</cell><cell>57</cell><cell>271</cell></row><row><cell></cell><cell>exceed target.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>3) to either the stateful or stateless atoms provided by the Banzai machine. Because our stateful atoms Atom areas and minimum critical-path delays in a 32-nm standard-cell library. All atoms meet timing at 1 GHz. Each of the seven compiler targets contains 300 instances of one of the seven stateful atoms (Read/Write to Pairs) and 300 instances of the single stateless atom.</figDesc><table><row><cell>Atom</cell><cell></cell><cell>Description</cell><cell>Area</cell><cell>Min.</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(µm 2 )</cell><cell>de-</cell></row><row><cell></cell><cell></cell><cell></cell><cell>at 1</cell><cell>lay</cell></row><row><cell></cell><cell></cell><cell></cell><cell>GHz</cell><cell>(ps)</cell></row><row><cell>Stateless</cell><cell></cell><cell>Arithmetic, logic, relational,</cell><cell>1384</cell><cell>387</cell></row><row><cell></cell><cell></cell><cell>and conditional operations</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>on packet/constant operands</cell><cell></cell><cell></cell></row><row><cell cols="2">Read/Write</cell><cell>Read/Write packet field/-</cell><cell>250</cell><cell>176</cell></row><row><cell></cell><cell></cell><cell>constant into single state</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>variable.</cell><cell></cell><cell></cell></row><row><cell cols="2">ReadAddWrite</cell><cell>Add packet field/constant to</cell><cell>431</cell><cell>316</cell></row><row><cell>(RAW)</cell><cell></cell><cell>state variable (OR) Write</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>packet field/constant into</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>state variable.</cell><cell></cell><cell></cell></row><row><cell cols="2">Predicated ReadAd-</cell><cell>Execute RAW on state vari-</cell><cell>791</cell><cell>393</cell></row><row><cell cols="2">dWrite (PRAW)</cell><cell>able only if a predicate is</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>true, else leave unchanged.</cell><cell></cell><cell></cell></row><row><cell>IfElse</cell><cell>ReadAd-</cell><cell>Two separate RAWs: one</cell><cell>985</cell><cell>392</cell></row><row><cell>dWrite</cell><cell></cell><cell>each for when a predicate is</cell><cell></cell><cell></cell></row><row><cell cols="2">(IfElseRAW)</cell><cell>true or false.</cell><cell></cell><cell></cell></row><row><cell cols="2">Subtract (Sub)</cell><cell>Same as IfElseRAW, but</cell><cell>1522</cell><cell>409</cell></row><row><cell></cell><cell></cell><cell>also allow subtracting a</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>packet field/constant.</cell><cell></cell><cell></cell></row><row><cell cols="2">Nested Ifs (Nested)</cell><cell>Same as Sub, but with an ad-</cell><cell>3597</cell><cell>580</cell></row><row><cell></cell><cell></cell><cell>ditional level of nesting that</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>provides 4-way predication.</cell><cell></cell><cell></cell></row><row><cell>Paired</cell><cell>updates</cell><cell>Same as Nested, but allow</cell><cell>5997</cell><cell>606</cell></row><row><cell>(Pairs)</cell><cell></cell><cell>updates to a pair of state</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>variables, where predicates</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>can use both state variables.</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>can run at line rate using the Nested Ifs atom that modifies a single state variable.</figDesc><table><row><cell>But, some algorithms modify a pair of state variables</cell></row><row><cell>atomically. An example is CONGA, whose code is given</cell></row><row><cell>below:</cell></row><row><cell>if (p.util &lt; best_path_util[p.src]) {</cell></row><row><cell>best_path_util[p.src] = p.util;</cell></row><row><cell>best_path[p.src] = p.path_id;</cell></row><row><cell>} else if (p.path_id == best_path[p.src]) {</cell></row><row><cell>best_path_util[p.src] = p.util;</cell></row><row><cell>}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 5 :</head><label>5</label><figDesc>An atom's minimum critical-path delay increases with circuit depth. Mux is a multiplexer. RELOP is a relational operation (&gt;, &lt;, ==, !=). x is a state variable. pkt.f1 and pkt.f2 are packet fields. Const is a constant operand.</figDesc><table><row><cell>Atom</cell><cell>Circuit</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Min.</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>de-</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>lay</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(ps)</cell></row><row><cell></cell><cell></cell><cell cols="2">pkt.f1 Const</cell><cell></cell><cell>2-to-1 Mux</cell><cell>x</cell><cell></cell></row><row><cell>Read/Write</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>176</cell></row><row><cell></cell><cell></cell><cell>x</cell><cell cols="2">2-to-1</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">0</cell><cell>Mux</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Adder</cell><cell>x</cell><cell></cell></row><row><cell></cell><cell cols="2">Const</cell><cell></cell><cell>2-to-1</cell><cell></cell><cell></cell><cell></cell></row><row><cell>ReadAddWrite</cell><cell cols="2">pkt.f1</cell><cell></cell><cell>Mux</cell><cell></cell><cell></cell><cell></cell><cell>316</cell></row><row><cell>(RAW)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>Const pkt.f1 pkt.f2</cell><cell></cell><cell cols="2">3-to-1 Mux</cell><cell>RELOP</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">x</cell><cell cols="2">2-to-1</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0</cell><cell>Mux</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Predicated ReadAddWrite</cell><cell>pkt.f1 Const pkt.f2</cell><cell>x 0</cell><cell cols="2">2-to-1 Mux 3-to-1 Mux</cell><cell>Adder x</cell><cell>2-to-1 Mux</cell><cell>x</cell><cell>393</cell></row><row><cell>(PRAW)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>It is hard to physically route backward-flowing wires that would be required for feedback.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>A field is either a packet header, e.g., source port (sport) and destination port (dport), or packet metadata (id).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Conditional operations alone have four arguments.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>We refer to this both as a codelet and an atom pipeline because codelets map one-to-one atoms ( §4.3).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>Because every target is uniquely identified by its stateful atom type, we use the two interchangeably.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>p.src is the address of the host originating this message, and hence the destination for the host receiving it and executing CONGA.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank our shepherd, Bruce Maggs, the anonymous SIG-COMM reviewers, Amy Ousterhout, and Pratiksha Thaker for their suggestions that improved the presentation of the paper. This work was partly supported by NSF grants CNS-1563826 and CNS-1563788. We thank the industrial part-ners of the MIT Center for Wireless Networks and Mobile Computing (Wireless@MIT) for their support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<ptr target="http://www.corsa.com/products/dp6440/" />
	</analytic>
	<monogr>
		<title level="m">DP 6430 | Corsa Technology</title>
		<imprint>
			<biblScope unit="volume">6440</biblScope>
		</imprint>
	</monogr>
	<note>Data Planes</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="https://www.arista.com/en/products/7050-series" />
		<title level="m">Arista -Arista 7050 Series</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="https://barefootnetworks.com/media/white_papers/Barefoot-Worlds-Fastest-Most-Programmable-Networks.pdf" />
		<title level="m">The World&apos;s Fastest and Most Programmable Networks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Cisco</forename><surname>Nexus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Family</forename></persName>
		</author>
		<ptr target="http://www.cisco.com/c/en/us/products/switches/cisco_nexus_family.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<ptr target="http://tldp.org/HOWTO/Traffic-Control-HOWTO/components.html" />
	</analytic>
	<monogr>
		<title level="j">Components of Linux Traffic Control</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="http://www.force10networks.com/" />
		<title level="m">Dell Force10</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Design</forename><surname>Compiler -Synopsys</surname></persName>
		</author>
		<ptr target="http://www.synopsys.com/Tools/Implementation/RTLSynthesis/DesignCompiler/Pages/default.aspx" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><surname>Dpdk</surname></persName>
		</author>
		<ptr target="http://dpdk.org/" />
		<title level="m">Data Plane Development Kit</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="https://github.com/p4lang/tutorials/tree/master/SIGCOMM_2015/flowlet_switching" />
		<title level="m">Flowlet Switching in P4</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://www.broadcom.com/products/Switching/Data-Center/BCM56850-Series" />
		<title level="m">High Capacity StrataXGS®Trident II Ethernet Switch Series</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<ptr target="http://www.broadcom.com/products/Switching/Data-Center/BCM56960-Series" />
		<title level="m">High-Density 25/100 Gigabit Ethernet StrataXGS Tomahawk Ethernet Switch Series</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="http://www.intel.com/pressroom/archive/releases/2001/20010220net.htm" />
		<title level="m">Intel Enhances Network Processor Family with New Software Tools and Expanded Performance</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Intel</forename><surname>Flexpipe</surname></persName>
		</author>
		<ptr target="http://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/ethernet-switch-fm6000-series-brief.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://www.intel.com/content/www/us/en/intelligent-systems/previous-generation/intel-ixp4xx-intel-network-processor-product-line.html" />
		<title level="m">IXP4XX Product Line of Network Processors</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="http://llvm.org/docs/LangRef.html#abstract" />
		<title level="m">LLVM Language Reference Manual -LLVM 3.8 documentation</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<ptr target="http://www.mellanox.com/page/products_dyn?product_family=146&amp;mtag=switchx_2_en" />
		<title level="m">Mellanox Products: SwitchX-2 Ethernet Optimized for SDN</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Sampled</forename><surname>Netflow</surname></persName>
		</author>
		<ptr target="http://www.cisco.com/c/en/us/td/docs/ios/12_0s/feature/guide/12s_sanf.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://www.cavium.com/XPliant-Ethernet-Switch-Product-Family.html" />
		<title level="m">XPliant™ Ethernet Switch Product Family</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers: Principles, Techniques, and Tools</title>
		<meeting><address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">CONGA: Distributed Congestion-Aware Load Balancing for Datacenters</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Edsall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dharmapurikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Vaidyanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fingerhut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Matus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yadav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Less Is More: Trading a Little Bandwidth for Ultra-Low Latency in the Data Center</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kabbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Edsall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yasuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Conversion of Control Dependence to Data Dependence</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Porterfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Arashloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Karol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1512.00822</idno>
		<title level="m">SNAP: Stateful Network-Wide Abstractions for Packet Processing</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Enabling End-Host Network Functions</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gkantsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Grosvenor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Karagiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Koromilas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>O'shea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">EXPOSURE: Finding Malicious Domains Using Passive DNS Analysis</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bilge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Balduzzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Talayco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">P</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2014-07">July 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Forwarding Metamorphosis: Fast Programmable Match-action Processing in Hardware for SDN</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mujica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Using Program Synthesis for Social Recommendations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Optimizing Database-backed Applications with Query Synthesis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An Improved Data Stream Summary: The Count-Min Sketch and Its Applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<date type="published" when="2005-04">April 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficiently Computing Static Single Assignment Form and the Control Dependence Graph</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cytron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ferrante</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">K</forename><surname>Zadeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Language Systems</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Automatically Partitioning Packet Processing Applications for Pipelined Architectures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Harrison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Toward Predictable Performance in Software Packet-Processing Platforms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dobrescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Argyraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">RouteBricks: Exploiting Parallelism to Scale Software Routers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dobrescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Egi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Argyraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-G</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Iannaccone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Knies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Manesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">packetC Language for High Performance Packet Processing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Duncan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jungck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th IEEE International Conference on High Performance Computing and Communications</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Bitmap Algorithms for Counting Active Flows on High-speed Links</title>
		<author>
			<persName><forename type="first">C</forename><surname>Estan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fisk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Random Early Detection Gateways for Congestion Avoidance</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<date type="published" when="1993-08">Aug. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Frenetic: A Network Programming Language</title>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Story</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Design Principles for Packet Parsers</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ANCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">VL2: A Scalable and Flexible Data Center Network</title>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Maltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Millions of Little Minions: Using Packets for Low Latency Network Programming and Visibility</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Geng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Compiling Packet Programs to Reconfigurable Switches</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Optimizing the &quot;One Big Switch&quot; Abstraction in Software-defined Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CoNEXT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Congestion Control for High Bandwidth-Delay Product Networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rohrs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">The Click Modular Router</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">An Adaptive Virtual Queue (AVQ) Algorithm for Active Queue Management</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Kunniyur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<date type="published" when="2004-04">Apr. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Software Pipelining: An Effective Scheduling Technique for VLIW Machines</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Synthesis and Optimization of Digital Circuits</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Micheli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>McGraw-Hill Higher Education</publisher>
		</imprint>
	</monogr>
	<note>1st edition</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Flow-level State Transition As a New Switch Primitive for SDN</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moshref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bhargava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">K</forename><surname>Nichols</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Controlling Queue Delay. ACM Queue</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2012-05">May 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">E2: A Framework for NFV Applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Palkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rizzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Chlorophyll: Synthesis-aided Compiler for Low-power Spatial Architectures</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Phothilimthana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jelvis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Totla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chasins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="396" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Inside the Social Network&apos;s (Datacenter) Network</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bagga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Snoeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">The Case for an Intermediate Representation for Programmable Data Planes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSR</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1" to="3" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Jupiter Rising: A Decade of Clos Topologies and Centralized Control in Google&apos;s Datacenter Network</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Armistead</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Boving</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Felderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Germano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kanagala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Provost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simmons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tanda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wanderer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Hölzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stuart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Harnessing TCPs Burstiness using Flowlet Switching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotNets</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Programmable Packet Scheduling at Line Rate</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-T</forename><surname>Chuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Edsall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Combinatorial Sketching for Finite Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Saraswat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Making Large Scale Deployment of RCP Practical for Real Networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dukkipati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Towards an Active Network Architecture</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Tennenhouse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DARPA Active Networks Conference and Exposition</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Maple: Simplifying SDN Programming Using Algorithmic Policies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">R</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Software Defined Traffic Measurement with OpenSketch</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
