<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Packet Classification for Core Routers: Is there an alternative to CAMs?</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Florin</forename><surname>Baboescu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sumeet</forename><surname>Singh</surname></persName>
						</author>
						<author>
							<persName><forename type="first">George</forename><surname>Varghese</surname></persName>
						</author>
						<title level="a" type="main">Packet Classification for Core Routers: Is there an alternative to CAMs?</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">58EAB3C6B3860E74F394248C2611B554</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A classifier consists of a set of rules for classifying packets based on header fields. Because core routers can have fairly large (e.g., 2000 rule) database and must use limited SRAM to meet OC-768 speeds, the best existing classification algorithms (RFC, HiCuts, ABV) are precluded because of the large amount of memory they need. Thus the general belief is that hardware solutions like CAMs are needed, despite the amount of board area and power they consume. In this paper, we provide an alternative to CAMs via an Extended Grid-of-Tries with Path Compression (EGT-PC) algorithm whose worst-case speed scales well with database size while using a minimal amount of memory. Our evaluation is based on real databases used by Tier 1 ISPs, and synthetic databases. EGT-PC is based on a observation that we found holds for all the Tier 1 databases we studied: regardless of database size, any packet matches only a small number of distinct source-destination prefix pairs. The code we wrote for EGT-PC, RFC, HiCuts, and ABV is publicly available [16], providing the first publicly available code to encourage experimentation with classification algorithms.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The rapid growth of the Internet has brought great challenges and complex issues in deploying high-speed networks. The number of users, the volume of traffic and the type of services to be provided are continually increasing. The increasing traffic demand requires three key factors to keep pace: high link speeds, high router data switching throughput and high packet forwarding rates. Although there are already solutions for the first two factors, packet forwarding continues to be be a difficult task at wire speeds.</p><p>Packet forwarding based on a longest matching prefix lookup of destination IP addresses is fairly well understood with both algorithmic and CAM-based solutions in the market. Using basic variants of tries and some pipelining, it is fairly easy to perform one packet lookup every memory access time, which can easily scale (beyond even today's OC-768 speeds of 40 Gbps) to 100 Gps using 1 nsec SRAMs.</p><p>However, the Internet is becoming a more complex place to live in because of its use for mission critical functions executed by organizations. Organizations desire that their critical activities not be subverted either by high traffic sent by other organizations (i.e., they require QoS guarantees) or by malicious intruders (i.e., they require security guarantees). Both QoS and security guarantees require a finer discrimination of packets based on fields other than the destination that we call packet classification.</p><p>F. Baboescu, S. Singh and G. Varghese are with the Computer Science and Engineering Department, University of California, San Diego(UCSD), La Jolla, California. E-mail: baboescu, varghese¡ @cs.ucsd.edu Other fields a router may need to examine include source addresses (to forbid or provide different service to some source networks), port fields (to discriminate between traffic types such as Napster and say Email), and even TCP flags (to distinguish between say externally and internally initiated connections). Besides security and QoS, other functions that require classification include network address translation (NAT), metering, traffic shaping, policing, and monitoring.</p><p>The industry standard for classifier formats has come from Cisco ACLs, which consist of a number of rules. Each rule specifies a destination address prefix, a source address prefix, a protocol type or a wildcard, ranges for the destination and source port fields, and some values of TCP flags. The rules are arranged in order of priority and have an associated action (such as drop, forward, place in queue ¢ etc.). Conceptually, a packet must be matched to the first (i.e., highest priority) rule that matches the packet.</p><p>Classifiers historically evolved from firewalls that were placed at the edges of networks to filter out unwanted packets. Such databases are generally small, containing 10-500 rules, and can be handled by ad hoc methods. However, with the DiffServ movement, there is potential anticipation <ref type="bibr" target="#b11">[12]</ref> of classifiers that could support one hundred thousand rules for DiffServ and policing applications at edge routers. Thus while many classification algorithms <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b5">[6]</ref> work well for classifiers up to say 1000 rules, there is a real scaling problem for larger databases that is partially addressed by <ref type="bibr" target="#b0">[1]</ref>.</p><p>While large classifiers are anticipated for edge routers to enforce QoS via DiffServ, it is perhaps surprising that even within the core fairly large (e.g., 2000 rule) classifiers are commonly used for security. Emerging core routers operate at 40 Gbs speeds, thus requiring the use of limited SRAM to store state for any algorithmic solution. Unfortunately, the best existing classification schemes described in the literature (RFC <ref type="bibr" target="#b5">[6]</ref>, HiCuts <ref type="bibr" target="#b6">[7]</ref>, ABV <ref type="bibr" target="#b0">[1]</ref>) require large amounts of memory for even medium size classifiers, precluding their use in core routers.</p><p>While these core router classifiers are nowhere near the anticipated size of edge router classifiers, there seems no reason why they should not continue to grow beyond the sizes reported in this paper. For example, many of the rules appear to be denying traffic from a specified subnetwork outside the ISP to a server (or subnetwork) within the ISP. Thus, new offending sources could be discovered and new servers could be added that need protection. In fact, we speculate that one reason why core router classifiers are not even bigger is because most core router implementations slow down (and do not guarantee true wire speed forwarding) as classifier sizes increase.</p><p>Thus the general belief is that hardware solutions like Ternary CAMs are needed for core routers, despite the large amount of board space and power that CAMs consume <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b7">[8]</ref>. For a large number of designers, Ternary CAMs, which essentially compare a packet to every rule simultaneously, are the only solution.</p><p>There are several reasons to consider algorithmic alternatives to Ternary CAMs, however, some of which are stronger than others: £ Density Scaling: One bit in a TCAM requires <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref> transistors while an SRAM requires 4-6 transistors. Thus TCAMs will also be less dense than SRAMs or take more area. Board area is a critical issue for many routers.</p><p>£ Power Scaling: TCAMs take more power because of the parallel compare. CAM vendors are, however, chipping away at this issue by finding ways to turn off parts of the CAM to reduce power. Power is a key issue in large core routers.</p><p>£ Time Scaling: The match logic in a CAM requires all matching rules to arbitrate so that the highest match wins. Older generation CAMs took around 10 nsec for an operation but currently announced products appear to take 5 nsec, possibly by pipelining parts of the match delay.</p><p>£ Extra Chips: Given that many routers like the Cisco GSR or the Juniper M160 already have a dedicated ASIC (or network processor) doing packet forwarding it is tempting to integrate the classification algorithm with the lookup without adding CAM interfaces and CAM chips. Note that CAMs typically require a bridge ASIC in addition to the basic CAM chip, and sometimes require multiple CAM chips.</p><p>£ Rule Multiplication for Ranges: CAMs need to represent port ranges by several prefixes thus causing extra entries. To see that this problem is not just of academic interest consider the following recent announcement by Cypress (a leading manufacturer of CAM chips) in EE Times <ref type="bibr" target="#b11">[12]</ref>. Basically, Cypress is considering shipping a chip that implements an algorithmic approach to classification to provide a lower cost, lower area, and lower power alternative to their CAMs. The article also mentions other companies such as Fast-Chip, EZchip, and Integrated Silicon Solution that are claiming algorithmic solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PAPER CONTRIBUTIONS</head><p>Our paper has three main contributions: a new classifier characteristic, a new algorithm, and the first standardized comparison across a number of major algorithms. £ i, New Characteristic: Our paper studies the characteristics of core router classifiers used by Tier 1 ISPS. While previous studies have shown <ref type="bibr" target="#b5">[6]</ref> that every packet matches at most a few rules, we refine this earlier observation to show that every packet matches at most a few distinct source-destination prefix pairs present in the rule set. In other words, if we project the rule set to just the source and destination fields, no packet matches more than a small number of rules in the new set of projected rules. Note that this is emphatically not true for single fields because of wildcards: a single packet can match hundreds of rules when considering any one field in isolation.</p><p>£ ii, New Algorithm: Based on the observation above, our paper introduces a new algorithm we call Extended Grid of Trie with Path Compression(EGT-PC) for multidimensional packet classification and evaluates it. While our EGT algorithm is inspired by the earlier gridof-tries algorithm <ref type="bibr" target="#b16">[17]</ref>, it requires a significant extension. Briefly, the standard grid-of-tries assumes that any source-destination prefix pair ¤ ¦¥ ¨ § © § that is no more specific in both fields than another pair ¤ ¥ © ! " can be eliminated. While this works for 2 field classification it does not work for more than 2 fields, and requires new machinery (e.g., jump pointers instead of switch pointers) for correctness. We had to experiment with a number of extension variants before finding one that did not result in storage replication and yet had good performance.</p><p>£ iii, New standardized comparison: Previous work mostly compares the new algorithm presented in the paper with one other algorithm. Thus for example, the HiCuts paper <ref type="bibr" target="#b6">[7]</ref> describes improvements over RFC <ref type="bibr" target="#b5">[6]</ref>; similarly, the ABV paper <ref type="bibr" target="#b0">[1]</ref> paper describes improvements over the Lucent bit vector scheme <ref type="bibr" target="#b10">[11]</ref>. The code for each algorithm is also usually difficult to obtain. We have written code for each of these algorithms<ref type="foot" target="#foot_0">1</ref> and compared them using databases used by Tier 1 ISPs. We also do comparisons based on synthetic databases that preserve the structure of the smaller real databases that we have.<ref type="foot" target="#foot_1">2</ref> Finally, our code is publically available on a web site described in the references. By making multiple classification algorithms publicly available we hope to encourage experimentation and improvements that can then be incorporated into revisions on the same web site.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PRIOR WORK AND SUMMARY OF RESULTS</head><p>The packet classification problem is inherently hard( <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b18">[19]</ref>) from a theoretical standpoint. It has been shown <ref type="bibr" target="#b10">[11]</ref>  is the number of rules, and 5 is the number of header fields used in rules.</p><p>Most practical solutions either use linear time <ref type="bibr" target="#b10">[11]</ref> to search through all rules sequentially<ref type="foot" target="#foot_2">3</ref> , or use a linear amount of parallelism (e.g., Ternary-CAMs as in <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b9">[10]</ref>). Ternary CAMs are Content Addressable Memories that allow wildcard bits. Solutions based on caching <ref type="bibr" target="#b19">[20]</ref> do not appear to work well in practice because of poor hit rates and small flow durations 7  [14], and still need a fast classifier as a backup when the cache fails.</p><p>Several algorithms have been developed for the case of rules on two fields (e.g., source and destination IP address only). For this special case, the lower bounds do not apply (they apply only for 5 98 A@ ); thus hardly surprisingly, there are algorithms that take logarithmic time and linear storage. These include the use of range trees and fractional cascading <ref type="bibr" target="#b10">[11]</ref>, grid-of-tries <ref type="bibr" target="#b16">[17]</ref>, area-based quad-trees <ref type="bibr" target="#b1">[2]</ref>, and FIS-trees <ref type="bibr" target="#b4">[5]</ref>. While these algorithms are useful for special cases (such as measuring traffic between source and destination subnets), they do not solve the general problem of 5 CB dimensional packet classification.</p><p>The papers by <ref type="bibr">Gupta and McKeown [6]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b18">[19]</ref> introduced a major new direction into packet classification research. Since the problem is unsolvable in the worst case, they look instead for heuristics to exploit the structure of the databases. They observed for the first time that a given packet matches only a few rules even in large classifiers. Baboescu and Varghese <ref type="bibr" target="#b0">[1]</ref> also exploit this observation to reduce the search times for the algorithm described in <ref type="bibr" target="#b10">[11]</ref>. Qiu et al <ref type="bibr" target="#b14">[15]</ref> exploit the observation that any packet matches at most a few distinct values in each field to suggest backtracking trie search as a viable (though fairly slow) alternative.</p><p>Performance of Existing Schemes: In terms of the current state of the art (see comparisons later), it appears that RFC has the fastest search times (12 memory accesses using 16 bit chunks) but at the cost of a large amount of storage (for example, on a database of 2800 rules, RFC requires 24 Mbits of memory). HiCuts takes more memory accesses and requires less memory (e.g., 3 Mbits for the same database using 82 memory accesses).</p><p>HiCuts mostly works well. However, with the space factor of 4 used in the HiCuts paper, it is fast (82 memory accesses for a @ D E )E rules database) but requires a large amount of storage for databases (see F HG below) in which there are a large number of rules where the destination address is wildcarded, and a large number of rules where the source address is wildcarded. Using a lower space factor of 1, HiCuts tends to sometimes do better in storage but still does worse in time. In the case of F PI , Q SR UT HV XW `Y ¨B !a uses more than b times more memory than c ed gf hB pi qT while the worst case search time is only slightly better: D )@ vs. D 1r while Q SR UT HV XW `Y sB ut uses about t 3v xw less memory than c qd gf yB i qT but sacrifices the worst case search time which is now twice as large as the one for c qd gf B i qT .</p><p>Besides these better results for existing core router databases, c qd gf B i qT has three other characteristics that may make it more attractive than HiCuts. £ Predictability: It appears to be difficult to predict the performance of Q SR UT HV W `Y on arbitrary database because there is no model to predict its performance. c qd gf B i qT performance can be characterized in terms of the maximum number of rules that match a projection of the original rule set onto the source and destination fields. £ Scaling: c qd gf B i qT appears to scale well to large databases.</p><p>£ Patent issues: c qd gf B i qT is not subject to patent restriction unlike Q SR UT HV W `Y which is patented. While this is not a fundamental issue, it does provide an important reason for looking for alternatives to HiCuts in practice.</p><p>While RFC is very fast, its large amount of memory makes it hard to implement using limited SRAM. Thus for existing ISP databases none of the existing algorithms including HiCuts scale as well in both memory and time. Further, the EGT-PC scheme can easily be implemented using a small amount of SRAM.</p><p>More importantly, when we attempted to scale the database sizes to 100,000 while preserving their structure, EGT-PC took only slightly more memory accesses (at most 118) while preserving low storage <ref type="foot" target="#foot_3">4</ref> . Thus EGT-PC should scale well assuming that larger databases keep the same sourcedestination prefix characteristics of the Tier 1 ISP databases we studied.</p><p>Assuming a chip capable of around 32 memory accesses per minimum size packet (using say a 32 way pipeline), EGT-PC should allow the handling of large classifiers in 2-3 minimum size packet times in the worst-case. While this is not quite wire speed forwarding, such performance for large classifiers in some pathological cases seems adequate since most core routers today can also fall below wire speed forwarding for large classifiers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Models and Metrics</head><p>Readers familiar with classification should skip the next section to get to the new material presented in the paper. In general, the job of a packet classifier is to categorize packets based on a set of rules. Rules are also sometimes called filters.</p><p>The information relevant for classifying a packet is contained in distinct header fields in the packet. These header fields are denoted Q p 't © Q @ ¦© " ' '© Q p S .</p><p>For example, the fields typically used to classify IPv4 packets are the destination IP address, source IP address, protocol field, destination port number, source port number, and protocol flags. The number of protocol flags is limited, so we can combine them into the protocol field itself.</p><p>Using these fields, a rule F=(128.252.*, *, TCP, 23, *), for example, matches all traffic addressed to subnet t @ D @ )d @ using TCP destination port 23, which is used for incoming Telnet; using a rule like this, a firewall may disallow Telnet into its network.</p><p>A classifier (also known as rule database or filter database) consists of address must match prefix 128.252.*"; or range match, e.g. "destination port must be in the range 0 to 1023."</p><p>Each rule e ji has an associated directive l )R UY `m n , which specifies the action to perform for a packet that matches this rule. This directive may indicate whether to block the packet, send it out a particular interface, or perform some other action. A packet i is said to match a rule e if each field of i matches the corresponding field of e . For instance, let e o ¤ Ut 3@ D p q@ d )@ r ts 1© us r© `f vT gi w© u@ b © us be a rule with l R UY m o yx {z | } ~5 . Then, a packet with header (128.252.169. <ref type="bibr">16, 128.111</ref> Since a packet may match multiple rules in the database, we associate a cost for each rule to resolve ambiguous matches. The packet classification problem is to find the lowest cost rule matching a given packet i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Performance metrics for packet classification</head><p>The two main metrics for packet classification are speed in memory accesses and memory. A secondary metric could be the number of fields that can be handled; some applications require more than 5 fields although we will only consider 5 field classifiers in this paper.</p><p>Speed: The goal of packet classification is to ideally classify packets at wire speed, which means that for each packet a decision is to be made in the time we have for handling a minimum size packet. At OC-192 rates of 10 Gbps and using 40 byte packets, a decision must be made in 32 nsec.</p><p>In practice, this is tricky for several reasons. First, even the definition of minimum packet size is debatable: there are a few rare packets that arrive in with sizes of 30 bytes or less; while most studies use 40 byte minimum size packets (since packets with TCP, IP, and Data link headers are at least this size) some vendors aim for a 64 byte packet sizes with a small queue to handle bursts of smaller sizes. Second, some packet processing events like handling encapsulated packets or multiple levels of label stacking may require multiple lookups that cannot strictly be handled at line speed for a minimum packet size. Thus some relaxation of strict wire speed processing limits for say packet processing may be acceptable (especially when using a large classifier); indeed, this appears to be true for most core routers today.</p><p>Speed is measured in terms of memory accesses. Often a wider memory access can reduce the number of memory accesses required. We will assume a 32 bit wide memory. Many of the algorithms described here (especially the two leading contenders HiCuts and EGT) can benefit from wider words, but we normalize our results to 32 bit words.</p><p>Memory size: On-chip SRAM for semi-custom ASICS is at most 32 Mbits today. Since on-chip SRAM provides the fastest memory (around 1 nsec), one would ideally like the memory of a classification algorithm to scale with the size of an on-chip SRAM. For example, the RFC sizes of 24 Mbits for a 2800 size table (see results later) tend to rule out RFC for high speed implementations.</p><p>Update complexity is generally not an issue for core routers as rules are rarely changed. On the other hand, edge routers that do stateful filtering or intrusion detection systems that dynamically identify certain flows to be tracked may indeed require faster updates. We do not consider update complexity in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. BRIEF REVIEW OF RFC AND HICUTS</head><p>In this section we briefly describe two of the previous algorithms that we compare against our new EGT scheme. We describe HiCuts in some detail as it is the strongest contender for the core router databases we examined. We describe our new algorithm in the next Section. In order to provide examples, let's consider the small firewall database in the Figure <ref type="figure">1</ref>. The example contains twelve rules on five fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Recursive Flow Classification(RFC)</head><p>The first algorithm we consider is RFC <ref type="bibr" target="#b5">[6]</ref>. <ref type="bibr">Gupta and McKeown [6]</ref> have invented a scheme called Recursive Flow Classification (RFC). RFC is really an improved form of crossproducting that significantly compresses the cross-product table at a slight extra expense in search time. The scheme works by building larger cross-products from smaller crossproducts; the main idea is to place the smaller cross-products into equivalence classes before combining them to form larger cross-products. This equivalencing of partial cross-products considerably reduces memory requirements, because several original cross-product terms map into the same equivalence class.</p><p>In Figure <ref type="figure">2</ref> we apply the equivalence cross-producting to the first two columns in the example in Figure <ref type="figure">1</ref>. A two dimensional table is built based on the unique prefixes in each of the first two fields. In this case the result is r distinct values which is close to the number of unique prefixes in the second field.</p><p>Prefix matching on a large field can be performed by splitting it up and treating it as several smaller fields. This is useful for fields exceeding 16 bits in length, since a field bits in size requires a table of size @ x to map values to equivalence classes. We use the field value of 16 bits suggested in the RFC paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Hierarchical Intelligent Cuts (HiCuts)</head><p>HiCuts was introduced by <ref type="bibr">Gupta and</ref> McKeown in <ref type="bibr" target="#b6">[7]</ref>. The scheme is based on a precomputed decision tree which is traversed for each packet that need to be classified in order to identify the matching rule which is always located in a leaf node. Each leaf node stores a small number of rules which are linearly searched in the last step. It is a remarkably effective algorithm and so is worth describing in more detail.</p><p>In HiCuts each node can be regarded as a 5 CB dimensional box cut up into a set of j} smaller boxes using heuristics which try to take into account the structure of the classifiers. The size of a box is given by the range covered by the box. For example the root node for a d rB tuple (IP Source and Destination, Port Source and Destination, Protocol) may be seen as the box</p><formula xml:id="formula_0">E p© @ G B t ~ ¢ E p© u@ G B t ~ ¢ E © @ § ` B t ¢ E © @ § U B t ¢ E p© @ B t ~ .</formula><p>Each box has associated the set of rules which intersect the box range. </p><formula xml:id="formula_1">E E )E E )E pt t )t "E )E pt t so yT § E E )E E )E E E )E E )E pt t so yT t 3E xs E E t t )t "E E t "E )E pt t so yT G E E )E E )E E E t "E )E pt t so yT I T t s T I T I T E t s E E )E E )E E E )E pt )t t t so yT T T E xs E E )E E )E E E )E E t t t so yT T T s T T T</formula><p>Fig. <ref type="figure">2</ref>. Forming the partial cross-products of the first two fields in Figure <ref type="figure">1</ref> and assigning them into the same equivalence class if they have the same set of matching rules.</p><p>A similar ideea with bit tests replacing range tests, was described by T. Woo in <ref type="bibr" target="#b18">[19]</ref>. Much more <ref type="bibr" target="#b18">[19]</ref> introduces one more degree of freedom in building the decision tree: it allows to arbitrarily interleave the bit tests for all fields. Thus the root of the trie could test for (say) Bit 10 of the source field; if the bit is 0, this could lead to a node that tests for say Bit 22 of the port number field. Clearly, there are an exponential number of such decision trees. The schemes in <ref type="bibr" target="#b18">[19]</ref> and <ref type="bibr" target="#b6">[7]</ref> build the final decision tree using local optimization decisions at each node to choose the next bit to test.</p><p>In what follows, we describe HiCuts in more detail using an example. The HiCuts local optimization criterion works well when tested on real core router classifiers.</p><p>Picking the number of boxes j} a node is split into may be done based on several heuristics which try to make a tradeoff between the depth of the decision tree and implicitly the search time versus the memory space occupied by the decision structure. The dimension on which a cut may be executed may be chosen either to:¤ Ut 3 minimize the maximum number of rules into any partition, or ¤ @ ) maximize the different number of specifications in one dimension, etc. Picking the right number of partitions ¤ % j} ~ to be made affects the overall memory space. The algorithm tunes j} as a function of a space measure. In order to do this it uses to parameters: ¤ Ut binth and (2) spfac.</p><p>Figure <ref type="figure">3</ref> shows a decision tree for the Example in Figure <ref type="figure">1</ref>. Let's assume that a packet with the header ¤ %E E t "E © ~t t 3E pt )© E E © E t © `f PT gi q needs to be classified. The path followed by this packet is shown in red in Figure <ref type="figure">3</ref>. In the first node, marked , based on the value in its first field, the packet is directed to the node marked F . Node F uses information in the second field to direct to a leaf node containing a small list of rules which may be a possible match. In this case e h is the lowest cost rule matching the packet.</p><formula xml:id="formula_2">F9 F10 F11 F8 F9 F10 F7 F10 F11 F7 F10 F11 F3 F7 F10 F11 F3 F7 F10 F11 F5 F7 F10 F11 F7 F10 F11 F1 F7 F10 F11 F11 F7 F10 F0 F5 F6 Field 3, 4 Field 1, 4 Field 2, 4</formula><p>Field4, 2 (0010, 1101, 00, 01, TCP) A B Fig. <ref type="figure">3</ref>.</p><p>A decision tree is built for the database of Figure <ref type="figure">1</ref>. The dimension on which a cut is made is associated with the field which has the largest number of unique values. For example the first node is cut along the first field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CHARACTERISTICS OF REAL LIFE CLASSIFIERS</head><p>Each designer of packet classification heuristics faces the same problem; he or she must know the characteristics of large rule databases. In this section we analyze 4 real life classifiers which are used by several large Tier 1 ISPs. While real databases were also used in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b5">[6]</ref>, the databases in <ref type="bibr" target="#b0">[1]</ref> are small and only reflect firewall applications which are not a good characterization of core router databases. Similarly, it is unclear whether the databases in <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b5">[6]</ref> were mostly from edge routers.</p><p>The number of rules in the classifiers varies from D )d to @ D )E E as is shown in Figure <ref type="figure">9</ref>. All the classifiers are five dimensional with the IP source and destination field represented as prefixes while the port fields are represented as ranges. The prefix length distribution for both IP source and destination fields is given in Figures <ref type="figure" target="#fig_0">4</ref> and<ref type="figure">5</ref>.</p><p>With the exception of one database which appears to have rules connecting subnetworks (prefix lengths with values of t "v qB @ a ) all the other databases have the similar maximums at length of E , t "v , @ a and b x@ . The distribution is very different from the prefix distribution in publicly available routing tables( <ref type="bibr" target="#b8">[9]</ref>) which is described in <ref type="bibr" target="#b0">[1]</ref>.</p><p>The performance of many classifier algorithms are strictly dependent on the largest number of valid prefixes that may be seen on a path from the root to a leaf in a trie that is generated using all the prefixes. The values for this number are between b and r for source and destination address tries. However if we consider the source tries associated with any particular destination trie, then the number is even smaller: between @ and a .</p><p>The number of rules matching all five fields is somewhere between b and d . This result is consistent with the result given by Gupta and McKeown in <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>. A value of b is easily achieved by a classifier which contains a default rule to be executed on all packets, a second rule to be executed on all the packets carrying a TCP message, and a third rule to be executed on all packets for an established TCP connection.</p><p>Analyzing the number of IP source and destination pairs only in the rule set we notice that the most common ones in order of their occurrence are: £ i. b x@ rB bit IP source to b )@ rB bit IP destination. This form of rule appears to be protecting particular ISP servers/routers from particular hosts. Of course, these rules are qualified by port fields that specify the traffic type.</p><p>£ ii.Anything (wildcarded) to b x@ rB bit IP destination. This form of rule appears to be protecting servers from being reached from the external world.</p><p>£ iii.t "v or @ a bit network source address to b x@ rB bit IP destination. This form of rule is similar to the first type of pattern except generalized to protecting servers from particular subnets.</p><p>£ iv. @ a B bit network source address to anything. This form of rule simply forbids certain subnetworks for certain specified traffic types. To test scaling later, we use a much simpler synthetic database generation algorithm than <ref type="bibr" target="#b0">[1]</ref>. Since each database we studied is quite different in patterns and distribution of length tuples, we used each database as a model to synthesize larger databases by simply replacing each IP address or prefix in a rule by other addresses while keeping other fields the same. This seems to be a reasonable model of an ISP growing in servers to be protected and subnetworks to be protected against.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. IP Source-Destination matching characteristic</head><p>The key observation that forms the basis of our new algorithm is as follows. Prefix Distribution in the IP destination field.Prefix length is represented on the horizontal axis while the percentage of entries with a given prefix length is given on the vertical axis. The graphs have a maximum on the lengths of , ` , u and ¡ { Source-Destination Matching: For all our databases, we computed the BV bitmap on all possible source and destination prefix values. Then for each possible source-destination prefix pair (crossproduct) we computed the intersection of these bitmaps and counted the number of rules that matched a given packet when considering only the first two fields. We found that for £ )£ p £ xw of the source-destination crossproducts, the number of matching rules was d or less. Even in a worst case sense, no crossproduct (and hence packet) for any database matches more than @ E rules when considering only source destination field matches.</p><p>Notice that this observation implies that the number of distinct source-destination prefix pairs matching a packet is even less ¤ than 20 because there can be several rules that share the same source-destination prefix pair. This observation is true for the smallest to the largest database of around 2800 rules. We expect it to remain approximately true even as databases scale because the number of overlapping prefixes (e.g., of lengths 0, 24, 32) are so limited in each of the source and destination fields.</p><p>Note that the small number of matches is not true when one considers only the source or destination fields because of the large numbers of wildcards in each field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXTENDING 2D SCHEMES</head><p>A number of algorithms simply use linear search to search through all possible rules. This scales well in storage but poorly in time. The source-destination matching observation leads to a very simple idea shown in Figure <ref type="figure" target="#fig_1">6</ref> to use sourcedestination address matching to reduce the linear searching to all rules corresponding to source-destination prefix pairs in the database that match the given packet header. Since mostly 5 and at most 20 rules will match any packet when considering only the source and destination fields, this will reduce the number of rules to be searched to be between 5 and 20. Thus we have linear searching among a pruned space of around 20 rules compared to linear searching the entire database (e.g., 2800 rules in our large databases). The main idea is depicted in Figure <ref type="figure" target="#fig_1">6</ref>. The idea is to use any efficient two dimensional matching scheme to find all the distinct source-destination prefix pairs ¤ ¥ § © ¥ § ~ C ~ " "¤ ¦¥ C¦ u© ¦ U that match a header. For each distinct pair ¤ ¥ n © !n ¦ there is a linear array or list with all rules that contain ¤ ¥ n `© !n ¦ in the source and destination fields. Thus in the figure, we have to traverse the list at ¤ ¥ ¨ § © § ~ searching through all the rules (in reality only the other fields such as port numbers) for , , and I . Then we move on consider the lists at ¤ ¥ © , etc.</p><p>Notice that this structure has two important advantages: £ Each rule is only represented once without replication.However, one may wish to replicate rules to reduce the number of source-destination pairs considered to reduce search times.</p><p>£ The port range specifications stay as ranges in the individual lists without the blowup associated with range translation in say CAMs, BV, and ABV. Since the Grid-of-Tries implementation by Srinivasan et al <ref type="bibr" target="#b16">[17]</ref> is one of the most efficient two dimensional schemes described, we now instantiate this general schema by using grid-of-tries as the 2D algorithm in Figure <ref type="figure" target="#fig_1">6</ref> A. Extended Grid-of-Tries(EGT)</p><p>In a naive generalization of a k-dimensional trie we either pay a large price in memory or we may be forced to do backtracking and we pay a large price in time <ref type="bibr" target="#b14">[15]</ref>. However, we may eliminate part of the waste of backtracking by using precomputation. This basic technique was introduced in the two dimensional trie implementation using grid of tries <ref type="bibr" target="#b16">[17]</ref>.</p><p>However one can immediately see that the approach in grid of tries cannot be generalized in 5 C© u5 8 §@ dimensions. This is because the grid of tries algorithm assumes that a rule may have at most two fields. If two rules are a match for a packet, then the most specific rule is picked. This observation allows the replacement of the backtracking mechanism with switch pointers. By using a switch pointer in any failure point in the source trie, it allows the search to jump to the next possible second dimension trie which may contain a matching rule.</p><p>Our goal is that for each packet header Q ¨o ¤ %Q § © Q © " ~ ~ q to be able to identify the set of rules e such that e ©o ª e ¥ R ¦ « e § R j¬ Q § e R ¦ ¨¬ Q ® .</p><p>In our extended grid of trie structure, a first trie is associated with the first dimension in the rule database. For every valid prefix node in this trie a special node is created. Each of these nodes contains a link to a trie which contains values from the second dimension field. For example, if the node in the first dimension trie is associated with a prefix i f § then the second dimension trie nodes is generated using all the second dimension field prefixes i R ¦ from the rules e hn o</p><formula xml:id="formula_3">¤ %i § R ¦ © i R © ~ " ~ {© `R o ¯t s ~ ~ 4</formula><p>in the database. A node ¢ in the second dimension trie which is associated with a valid prefix i is appended with a list of rules which correspond to rules that match i § and i in the first two dimensions. A node also contains a list of pointers to all the valid prefixes nodes which are a prefix of i . Thus node ¢ knows the list of all the rules e ¥ R ¦ °o A¤ i f § R ¦ © i R ¦ ¦© " ~ ~ for which i § R o i § and i R ¦ s± yi<ref type="foot" target="#foot_4">5</ref> . However, a rule occurs in exactly one position.</p><p>A different approach is to keep in each node associated with a valid prefix i h the list of rules e ¥ R ¦ which have i § in the first field and in the second field a prefix i R ¦ which is either an exact match or a prefix of i . We discuss these two approaches when we analyze the scheme behavior on real classifiers.</p><p>At this point, for each packet with a header</p><formula xml:id="formula_4">Q o ¤ %Q § © Q ! © " ~ ~ q</formula><p>we can identify the set of rules e o ª e ¥ R ¦ « e ¥ R o ¤ i § © i h ) R ¦ ¦© " ~ " ® where i § is the longest matching prefix of Q § for which at least a rule e n o ¤ %i § © " ~ ~ q exists and i x R ¦ if exists is i ) R ¦ w± •Q ! . In order to get all the rules e such that ¸e ¯o ª e ¥ R ¦ U« e § R ¦ ¦± Q § ee h ) R ¦ j± Q ! ® is necessary to traverse all the tries associated with prefixes in the first field that are prefixes of the field Q § of the packet header. However this requires backtracking in which case we pay a large price in time.</p><p>In order to avoid the backtracking we follow an approach inspired by but different from <ref type="bibr" target="#b16">[17]</ref>: we introduce at each failure point in the second dimension trie a jump pointer to directly allow the search to jump to the next possible second dimension trie that may contain a matching rule. If the node in which we inserted a jump pointer is associated with a prefix i in the second dimension trie, the jump is either to a node associated with a valid prefix i that is either shorter or equal with i , if such a node exist, or to a regular node which is the longest matching prefix of i , otherwise.</p><p>Figure <ref type="figure" target="#fig_2">7</ref> shows the extended grid of tries for the database in Figure <ref type="figure">1</ref>. Let's consider the search for rules that match a packet header ¤ %E E )E E © ~t t 3E E © ~ ~ " . The search in the first dimension trie gives i § ¹o yE E E as the best match. So we start the search for finding the matching prefix associated with the second value in the header t t )t t . We do not find a match in this trie. The search fails in the node t t . However a jump pointer allows the search to continue further into the trie associated with the prefix E xs in the first dimension. The search in this trie provides t s as the longest matching prefix and one rule e as being a matching rule. Once the search fails again in this dimension a jump pointer brings us to the last node corresponding to s 1© {s . This last node adds two more rules to the list making the final matching list to be: e © e § U © e § § .</p><p>The worst search time for the scheme can be proved to be:</p><formula xml:id="formula_5">»º ¤ %Q º t 3 s o 9¤ Q º @ hs</formula><p>where is the time to find the best prefix in a trie and Q is the maximum length of the trie, Q ¼o ½b )@ for IP addresses. However, we expect that the worst case scenario does not occur in practice. Instead we expect the worst case search time to be on the order ¾ us with ¾ being a small value.</p><p>We can also reduce by using compressed multibit tries <ref type="bibr" target="#b3">[4]</ref> instead of using 1-bit tries. If we use 5 CB bit expansion, the depth of the trie reduces to 5</p><p>and so the lookup time goes down correspondingly without a corresponding @ 0 increase in storage that would be incurred by uncompressed tries.</p><p>The bottom line is that using multibit tries, the time to search for the best matching rule in an arbitrarily large multidimensional database could effectively reduce to 5 times the time to do IP lookups using multibit tries, with 5 assumed to be a small constant, plus the time to search through a small list of rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Extended Grid of Trie with Path Compression</head><p>We further improve the Extended Grid of Trie algorithm by using Path Compression <ref type="bibr" target="#b2">[3]</ref>. This is a standard compression scheme for tries in which single branching paths are removed. Figure <ref type="figure">8</ref> shows how the path compression is applied to the tries in the Figure <ref type="figure" target="#fig_2">7</ref>.By doing so a trie with 4 leaf nodes can be compressed into a trie with at most @ 4 B ¿t nodes. Further improvement may be gained by applying both path compression as well as the compression techniques introduced in <ref type="bibr" target="#b3">[4]</ref>. Reducing the time of the trie traversal by applying path compression to the tries in Figure <ref type="figure" target="#fig_2">7</ref>.The tries are generated using the database in Figure <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. METHODOLOGY</head><p>In this section we describe how the EGT algorithm can be implemented, and how it performs on both real life databases and synthetically created databases. Note that we need synthetically created databases to test the scalability of our scheme.</p><p>First, we consider the complexity of the preprocessing stage and the storage requirements of the algorithm. Then, we consider search performance and we relate it to the performance of other algorithms: RFC, HiCuts, BV and ABV. The speed measure we use is the worst case number of memory accesses to be executed across all possible packet headers. Fortunately, computing this number does not entail generating all possible packet headers. This is because packet headers fall into equivalence classes based on distinct cross-products <ref type="bibr" target="#b16">[17]</ref>; a distinct cross-product is a unique combination of distinct prefix values for each header field.</p><p>Since each packet that has the same cross-product is matched to the same node 4 n (in trie f n ) for each field R , each packet that has the same cross-product will behave identically. Thus it suffices to compute worst case search times for all possible cross-products.</p><p>One can easily see that our algorithm has a worst case behavior when it may need to traverse a very large number of tries that are associated with the second dimension field. However pathological cases for which the heuristics experience the worst behavior may be found for all the algorithms we presented. Therefore in this paper we focus on the worst case search time for a series of realistic test databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experimental Platform</head><p>We used two different types of databases. First we used a set of four core router databases that we obtained from several large Tier 1 ISPs. For privacy reasons we are not allowed to disclose the name of the ISP or the actual databases. Each entry in the database contains a v B W V )m z % (source IP prefix, destination IP prefix, source port number(range), destination port number(range), protocol and action). We call these databases F g § f ~ ~ F vI . The database characteristics are discussed in Section V.</p><p>The second type of databases is generated using the real life databases as a starting point. We extend each of the original databases by randomly generating prefixes for the first two fields with the same length distribution as in the original one. We also maintain the distribution for the last three fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Performance Evaluation on Real Life Core Router Databases</head><p>We experimentally evaluate all the algorithms on a number of four real life core router databases F À § © ~ " ~ "© F vI . The rules in the databases are converted into prefix format using the technique described in <ref type="bibr" target="#b16">[17]</ref> for the evaluation of the BV and ABV algorithms. The memory space that is used by each of them can be estimated based on the number of nodes in the tries, and the number of nodes associated with valid prefixes in the case of BV and ABV.</p><p>In the case of c qd gf we also need to take into account the sizes for the list as well as the jump pointers. We use words of size b )@ bits and aggregate size of b )@ for PF Á . In the case of e qT at each level if the number of unique elements is</p><formula xml:id="formula_6">4 we use z | 3Â</formula><p>4 bits for an index into that level. Therefore for each table ¢ Ãs wÄ the total memory size in bits is ¢ s Ä ys wz %| 3Â 4 .</p><p>Our results are summarized in Figure <ref type="figure">9</ref>.</p><p>Both the search time and memory space in Q SR UT HV W `Y <ref type="bibr" target="#b6">[7]</ref> are dependent on two parameters which may be tuned: (1)space factor (spfac)-which determines the amount of total memory space that will be allocated on the decision tree and a ¤ @ ) threshold(binth)(a node with fewer than binth rules is not partitioned further). <ref type="bibr" target="#b6">[7]</ref> makes the observation that the tree depth is inversely proportional to binth and spfac while the total memory space is proportional with spfac and inverse proportional to binth. The results in Figure <ref type="figure">11</ref>  In the case of three databases the memory space occupied by Q SR UT HV XW `Y XB Àa (the value used in the original HiCuts paper) is an order of magnitude larger than the memory space occupied by the c qd gf B yi qT . However, by tuning the space factor parameter(spfac) to a value of t corresponding to optimizing Q SR UT HV XW `Y for memory space, the overall space occupied by Q SR UT HV XW `Y is comparable in size with c qd gf for three databases while in the case of F HG it is still about r times higher than c qd gf B i qT . F HG shows a database type which may hurt the performance of the Q SR UT HV XW `Y heuristics. In this case the height of the decision tree that is generated by Q ÈR T HV W `Y stays the same when Y m Ç C 1} is changed from t to a . This is because of a set of rules which gets replicated in a majority of the leaf nodes.</p><p>In the case of both F °Á and PF Á notice the increase in the (aggregated) bit vector size with the number of rules in the database contributes to a higher increase in the overall memory size, being multiplied with the total number of valid prefix nodes in all the tries. However, not keeping the bits in the original bit vector which are associated with an aggregate bit with the value E may reduce the memory usage of PF Á . While this optimization can reduce the memory size of PF Á , we have not shown its effect here. The results for e qT confirm the assumption in <ref type="bibr" target="#b5">[6]</ref> that despite of a worst case scenario in which an implementation may take # !¤ 4 0 32 § memory space, in reality the memory space occupied by the algorithm's search structure is smaller. Overall, as expected, e qT occupies by far the largest memory space. On the other side in terms of lowest memory space c qd gf B ¿i qT and Q SR UT HV XW `Y are the main competitors.</p><p>c qd gf B i qT in general is the one with the best use of space. However, when Q SR UT HV W `Y is optimized for memory space it comes close to c qd gf B i qT but is slower with an worst case search time that is @ HB Éb times slower than c qd gf B i qT .</p><p>We also evaluate the performance of the five algorithms in terms of worst case lookup time on the core router databases. The results are shown in Figure <ref type="figure">11</ref>.</p><p>As anticipated e qT has the best search time with a number of 12 memory accesses. The results in Figure <ref type="figure">11</ref> shows that classifying packets with PF Á has benefits when the number of memory entries in the database is large. In this case the search time for PF Á is more than four times faster than in F °Á even without rule rearrangement. However, if the number of rules is small, on the order of hundreds, the phenomenon of false matching described in <ref type="bibr" target="#b0">[1]</ref> may limit the performance of PF °Á .</p><p>The search time in c qd gf ÊB i qT is mostly due to the several traversals of the tries. The worst case search time using c qd gf yB i qT is on the same order of magnitude as Q SR UT HV W `Y when Q SR UT HV W `Y is optimized for speed. However the memory space occupied by c ed gf hB pi qT is on an order of magnitude smaller than any other analyzed heuristic with the exception of HiCuts optimized for a space factor of t . In this case Q SR UT HV W `Y and c qd gf B i qT occupy similar memory space sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Performance evaluation on synthetic generated databases</head><p>In this section we want to investigate the scalability of c qd gf uB Si qT . In order to do so we generated databases with a large number of rules between d r© E E )E and t "E )E p© E E E . The first two types of databases, ¥ F À § and ¥ Å F are generated using as a generator the two longest real core router databases. The last type of database,¥ ËF vG are generated using a combination of all four real core router databases as a generator. Figure <ref type="figure">13</ref> shows the size of the memory occupied by </p><formula xml:id="formula_7">F g § D )d d d r© u@ E x@ t t © v E )D t )© b a )v t )© `a )£ )v t )© d )r @ b © ~t r a t )© ~t "v )D F v t @ d t t ~a X© E )D E t "E p© {r E a t )© £ )D v t )© d b )E t )© v E )v b £ )b )d t )© `a 1r @ F G b xd rt t "E E © £ )£ pt v a © ud a Xt t 3£ p© E E pt a X© `a xd )@ a X© v )d pt b © D a xd @ p© @ v t F PI @ xr £ £ r a 1r r© @ xr 1t t t r r© D )E pt @ )d r© ud a )b @ xr v p© v E a @ D )d r© E £ )£ r d r© b xr v b )E p© ur d b</formula><p>Fig. <ref type="figure">9</ref>. The total memory space occupied by the search structure in all 6 heuristics RFC, HiCutsÌ Í Î Ï Ð "Ñ jÒ ´ {Ó % ~Ô , BV, ABV, EGT and EGT-PC for the four core router databases. The size is in memory words, one memory word is ¡ { bits.  </p><formula xml:id="formula_8">F À § b p© E pt 3£ t 3d d b © ~t r a t )© E t "b t 3d )d t © ~t 3v D F H b p© {r 1t 3b @ @ @ b © £ b xd t )© @ )d E @ @ )@ t © `a rr @ F G b p© b b )£ d E v b © D a 1d t )© ur d d d E )v @ r© @ v pt F I r E © ur 1t 3E a © v v v r d r© b 1r v @ v p© E )D xr a © v v )v b )E</formula><formula xml:id="formula_9">F À § D )d t 3@ D )@ v a t "E )v t t )t t "E 1r b x@ F t 3@ d t 3@ a )v t 3E v t "E t t "E )v t t 3E d a F HG b )d rt t 3@ t t "D t r @ t "b )v t 3@ v t t "a a rr F vI @ r© {r £ £ t 3@ D )@ t r @ D a xv t "£ )v t 3d a D 1r</formula><p>Fig. <ref type="figure">11</ref>. The total number of memory accesses for a worst case search in all 5 heuristics RFC, HiCutsÌ ÕÍ %Î )Ï Ð ~Ñ jÒ ´ {Ó ¦ ~Ô , BV, ABV, EGT and EGT-PC for the four core router databases. One memory access is one word. One word is ¡ { bits.</p><p>the number of rules in the classifier increases from</p><formula xml:id="formula_10">d p© E E )E to t "E E © E )E E .</formula><p>The results prove that the memory space occupied by c qd gf ÖB ×i qT scales linearly in number of rules. Of course, this should be taken with a grain of salt because the large database generation methodology preserves the sourcedestination structure of the original databases. If this assumption does not hold as databases scale up, c qd gf ØB i qT will not scale. However, we have not seen any experimental evidence that this is not the case.</p><p>The worst case scenario for a search using c qd gf §B ui qT is shown in Figure <ref type="figure">12</ref>. In the case of ¥ F G with t 3E E © E E )E rules it takes about t )t "D memory accesses. This corresponds to about d trie traversals plus the selection of roughly b E rules that are a match. In the case of ¥ F H with t "E )E p© E E E in the worst case it takes £ D memory accesses due to four one dimensional lookups and the selection of about t r rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>Packet filter classification has received tremendous attention( <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b18">[19]</ref>). Unfortunately, despite the vast amount of previous work, there does not appear to be a good algorithmic solution when rules contain more than 2 fields. At the same time, classification is an extremely important problem with several vendors, including Juniper, allowing the use of filter-based actions for purposes such as accounting and security. While Ternary CAMs <ref type="bibr" target="#b12">[13]</ref> offer a good solution in hardware for small classifiers, they may use too much power and board area for large classifiers. Thus it is worth looking for alternatives <ref type="bibr" target="#b11">[12]</ref> to CAMs.</p><p>Because real-life classifiers have considerable structure, <ref type="bibr" target="#b5">[6]</ref> observed that such structure could be exploited to yield heuristics that beat the worst-case bounds on real databases. The primary observation till this paper was <ref type="bibr" target="#b5">[6]</ref> that each packet only matches a few rules. Our paper starts with a fresh observation driven by data we observed: each packet does indeed match only a few rules, but it also matches only a few rules when the rules are projected to only the source and destination fields. Thus even for large classifiers, if one can find all the source-destination prefix pairs that match a packet, one need only linearly search through a set of 20 possible rules.</p><p>This suggests that any efficient two-field classification scheme can be extended with a small amount of linear search to general classifiers. The only catch is that the two-field scheme has to find matches, and not eliminate less specific matches. Thus, while this suggested starting with the grid-oftries, we had to modify it using jump pointers to compute all matches, losing worst case guarantees on even the search time for 2-field search. Despite this, c qd gf B ´i qT works very well compared to all other algorithms. Its worst case search times are on the same order as for the HiCuts optimized for speed while its memory storage requirements are on the same order as for HiCuts optimized for space. Therefore we consider that c qd gf B i qT provides a reasonably fast algorithm with minimal storage requirements that can fit into on-chip SRAM. Much more, c qd gf B ui qT has the advantage of being more predictable, of not having any patent restrictions, and potentially allowing simple further improvements using compressed multibit tries Database Type/No. of rules )@ E t "E £ © ur )r 1t t "v v © v xd )r @ @ E p© E a x@ t © E £ xr r© D a )D ¥ F HG r 1t )© @ d a t "E v © D t 3@ t r D © E )b )d @ a x£ p© @ v pt t © "t "E )@ p© E )£ pt Fig. <ref type="figure">13</ref>. The total memory occupied by EGT-PC used with synthetic databases. The number of entries is changed between Ù { { { and ` { 3Ó { { . One memory word is ¡ { bits.</p><p>as in <ref type="bibr" target="#b3">[4]</ref>. We are working on the use of multibit tries, compressed versions of the lists, and the use of wide words to further reduce the space and time of EGT-PC. Our paper leaves open the issue of modifying other 2 field algorithms such as <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b0">[1]</ref> to achieve better performance. The lack of standardized comparisons has led us to place all the code we implemented on a public repository <ref type="bibr" target="#b15">[16]</ref>. As others tinker with these algorithms, we believe that even better algorithms will be found and the state of the art will improve further. The use of packet classification is not confined to routers: from personal firewalls to web load balancing using URLs, better and open source code for classification can help improve a number of applications in software and hardware.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.<ref type="bibr" target="#b3">4</ref>. Prefix Distribution in the IP source field.Prefix length is represented on the horizontal axis while the percentage of entries with a given prefix length is given on the vertical axis. The graphs have a maximum on the lengths of , ` , u and ¡ { .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Extending two dimensional schemes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 7 .</head><label>7</label><figDesc>Fig.7. Improving the search cost with the use of jump pointers in the extended grid of tries. The tries are generated using the database in Figure1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Fig.8.Reducing the time of the trie traversal by applying path compression to the tries in Figure7.The tries are generated using the database in Figure1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>and Figure 9 are for Q SR UT HV XW `Y ÅB a :¤ x uR W `AE o yt 3E , Y `m CÇ C 1} wo ha x and Q SR UT HV W `Y B t :¤ x uR W `AE o yt 3E , Y m Ç C 1} o ¯t .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>.41.101, TCP, 23, 1025) matches e , and is therefore blocked. The packet (128.252.169.16, 128.111.41.101, TCP, 79, 1025), on the other hand, doesn't match e .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Fig. 1. A simple example with ` rules on five fields.</figDesc><table><row><cell>V z</cell><cell>e gR z %l  §</cell><cell>e gR 3z l )</cell><cell>e gR z l )G</cell><cell>e gR z %l I</cell><cell>e gR z %l x</cell><cell>vT Hf P 1#</cell><cell>4</cell></row><row><cell>e</cell><cell>E E )E xs</cell><cell>t t )t s</cell><cell>t "E</cell><cell>s</cell><cell>g i</cell><cell>1} {W</cell><cell></cell></row><row><cell>e  §</cell><cell>E E )E xs</cell><cell>t t )t s</cell><cell>E pt</cell><cell>t 3E</cell><cell>g i</cell><cell>1} {W</cell><cell></cell></row><row><cell>e</cell><cell>E E )E xs</cell><cell>t "E 1s</cell><cell>s</cell><cell>t 3E</cell><cell>f vT gi</cell><cell>1} {W  §</cell><cell></cell></row><row><cell>e G</cell><cell>E E )E xs</cell><cell>t "E 1s</cell><cell>s</cell><cell>E t</cell><cell>f vT gi</cell><cell>1} {W</cell><cell></cell></row><row><cell>e I</cell><cell>E E )E xs</cell><cell>t "E 1s</cell><cell>t "E</cell><cell>t )t</cell><cell>f vT gi</cell><cell>1} {W  §</cell><cell></cell></row><row><cell>e</cell><cell>E xs</cell><cell>t t )t s</cell><cell>t "E</cell><cell>E t</cell><cell>g i</cell><cell>1} {W</cell><cell></cell></row><row><cell>e</cell><cell>E xs</cell><cell>t t )t s</cell><cell>t "E</cell><cell>t 3E</cell><cell>g i</cell><cell>1} {W</cell><cell></cell></row><row><cell>e h</cell><cell>E xs</cell><cell>t s</cell><cell>s</cell><cell>s</cell><cell>f vT gi</cell><cell>1} {W</cell><cell></cell></row><row><cell>e</cell><cell>s</cell><cell>E pt s</cell><cell>s</cell><cell>s</cell><cell>f vT gi</cell><cell>1} {W U</cell><cell></cell></row><row><cell>e h</cell><cell>s</cell><cell>E xs</cell><cell>s</cell><cell>E t</cell><cell>g i</cell><cell>1} {W</cell><cell></cell></row><row><cell>e  §</cell><cell>s</cell><cell>s</cell><cell>s</cell><cell>s</cell><cell>g i</cell><cell>1} {W G</cell><cell></cell></row><row><cell>e  §  §</cell><cell>s</cell><cell>s</cell><cell>s</cell><cell>s</cell><cell>f vT gi</cell><cell>1} {W I</cell><cell></cell></row><row><cell>e gR 3z l 1 § ~ e gR z %l</cell><cell></cell><cell>E E )E xs</cell><cell></cell><cell>E 1s</cell><cell></cell><cell></cell><cell>s</cell></row><row><cell>t )t t s</cell><cell cols="2">t t 3E E )E pt t )t "E )E pt t so yT</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>c qd gf B ¶i qT while</figDesc><table><row><cell>xW U rx { rY 3</cell><cell>No. of Rules</cell><cell>e qT</cell><cell>Q SR UT HV XW `Y ¹B ´a</cell><cell>Q ÈR T HV W `Y wB t</cell><cell>F Á</cell><cell>vF °Á</cell><cell>c ed gf</cell><cell>c qd gf B Éi qT</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>p© {r d b Fig.10. The total memory occupied by both EGT and EGT-PC used with real life databases. The size is in memory words. One memory word is ¡ { bits.</figDesc><table><row><cell>xW U 1x 1Y 3</cell><cell>No. of Rules</cell><cell>e qT</cell><cell>Q SR UT HV XW `Y wB a</cell><cell>Q ÈR T HV W `Y wB t</cell><cell>F °Á</cell><cell>PF Á</cell><cell>c qd gf</cell><cell>c qd gf B Éi qT</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Fig.<ref type="bibr" target="#b11">12</ref>. The total number of memory accesses for a worst case search for EGT-PC for synthetic databases. The number of entries is changed between Ù { { { and ` { 3Ó { { . One memory access is one word and one word is ¡ { bits.</figDesc><table><row><cell>¥ ËF g §</cell><cell>d r© E E )E v )@</cell><cell>t "E p© E E )E £ v</cell><cell>t d r© E E E t )t ~a</cell><cell>@ E p© E )E E t d d</cell><cell>t "E )E p© E E E 4 {</cell></row><row><cell>¥ ËF v</cell><cell>D xr</cell><cell>£ )@</cell><cell>£ b</cell><cell>£ )b</cell><cell>£ )D</cell></row><row><cell>¥ ËF G</cell><cell>t "E )v</cell><cell>t "E pt</cell><cell>t 3E E</cell><cell>t 3E £</cell><cell>t )t "D</cell></row><row><cell cols="2">Database Type/No.of rules d r© E E E ¥ F  § v )d p© v £ xd</cell><cell>t "E p© E E )E t t ~a X© v a a</cell><cell>t 3d p© E E )E t 3d D © ~t 3£ pt</cell><cell>@ E © E )E E t "£ t © v )£ a</cell><cell>t "E )E p© E )E E 4</cell></row><row><cell>¥ F</cell><cell>d d p© b</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The RFC code is based on code graciously supplied to us by Pankaj Gupta</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Our databases are different from those in<ref type="bibr" target="#b0">[1]</ref> because those databases were largely edge databases as opposed to core databases. Our synthetic generation methodology is also very different from<ref type="bibr" target="#b0">[1]</ref> in that we provide a simpler and more realistic model for generating large ISP classifiers.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The scheme in<ref type="bibr" target="#b10">[11]</ref> reduces classification to linear search on a<ref type="bibr" target="#b5">6</ref> -bit vector which can be sped up by using a wide memory word</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>rules e f § © e © " ' © e hg . Each rule e i is an array of values, where e ji x R ¦ is a specification on the R -th header field. The R -th header field is sometimes referred to as the R -th dimension. The value e i R ¦ specifies what the R -th header field of a packet must contain in order for the packet to match rule k . These specifications often have (but need not be restricted to) the following forms: exact match, for example "source address must equal 128.252.169.16"; prefix match, like "destination<ref type="bibr" target="#b3">4</ref> However, a linear increase in the memory space that it is used may be obtained if the number of distinct prefixes in the database scale as well with the the number of rules in the database.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>² ´³ ¶µ means that ² is either an exact match or a prefix of µ .</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Scalable packet classification</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baboescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ACM Sigcomm&apos;01</title>
		<meeting>of ACM Sigcomm&apos;01</meeting>
		<imprint>
			<date type="published" when="2001-09">september 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Space decomposition techniques for fast layer-4 switching</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Buddhikot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of PHSN</title>
		<meeting>of PHSN</meeting>
		<imprint>
			<date type="published" when="1999-08">aug 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A software architecture for next generation routers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Decasper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Dittia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Plattner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Sigcomm &apos;98</title>
		<meeting>of ACM Sigcomm &apos;98</meeting>
		<imprint>
			<date type="published" when="1998">sept 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Hardware-based internet protocol prefix lookups</title>
		<author>
			<persName><forename type="first">W</forename><surname>Eatherton</surname></persName>
		</author>
		<editor>Eatherton, Will</editor>
		<imprint>
			<date type="published" when="1999-05">may 1999</date>
		</imprint>
		<respStmt>
			<orgName>Washington University Electrical Engineering Department, MS thesis</orgName>
		</respStmt>
	</monogr>
	<note>Hardware-Based Internet Protocol Prefix Lookups</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Tradeoffs for packet classification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Infocom</title>
		<meeting>of Infocom</meeting>
		<imprint>
			<date type="published" when="2000-03">march 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Packet classification on multiple fields</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ACM Sigcomm&apos;99</title>
		<meeting>of ACM Sigcomm&apos;99</meeting>
		<imprint>
			<date type="published" when="1999-09">september 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Packet classification using hierarchical intelligent cuttings</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of Hot Interconnects VII</title>
		<meeting>of Hot Interconnects VII</meeting>
		<imprint>
			<date type="published" when="1999-08">august 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Algorithms for packet classification</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network Special Issue</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2001-03">march 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Ipma statistics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Inc</surname></persName>
		</author>
		<ptr target="http://nic.merit.edu/ipma" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Classipi:an architecture for fast and flexible packet classification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network Spec. Issue</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">High speed policy-based packet forwarding using efficient multi-dimensional range matching</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">V</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stidialis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Sigcomm &apos;98</title>
		<meeting>of ACM Sigcomm &apos;98</meeting>
		<imprint>
			<date type="published" when="1998">sept 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Cam vendors consider algorithmic alternatives</title>
		<author>
			<persName><forename type="first">C</forename><surname>Matsumoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EETimes</title>
		<imprint>
			<date type="published" when="2002-05">may 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<ptr target="http://www.memorymemory.com" />
	</analytic>
	<monogr>
		<title level="j">Memory-memory</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Locality and route caches</title>
		<author>
			<persName><forename type="first">C</forename><surname>Partridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NSF Workshop</title>
		<meeting>NSF Workshop</meeting>
		<imprint>
			<date type="published" when="1999-02">feb 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fast firewall implementation for software and hardware based routers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ICNP</title>
		<meeting>of the ICNP</meeting>
		<imprint>
			<date type="published" when="2001-11">2001. november 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Packet classification repository</title>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Baboescu</surname></persName>
		</author>
		<ptr target="http://ial.ucsd.edu/classification" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast and scalable layer 4 switching</title>
		<author>
			<persName><forename type="first">V</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ACM Sigcomm&apos;98</title>
		<meeting>of ACM Sigcomm&apos;98</meeting>
		<imprint>
			<date type="published" when="1998-09">september 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Packet classification using tuple space search</title>
		<author>
			<persName><forename type="first">V</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ACM Sigcomm&apos;99</title>
		<meeting>of ACM Sigcomm&apos;99</meeting>
		<imprint>
			<date type="published" when="1999-09">september 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A modular approach to packet classification: Algorithms and results</title>
		<author>
			<persName><forename type="first">T</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A novel cache architecture to support layer-four packet classification at memory access speeds</title>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Infocom, mar</title>
		<meeting>of Infocom, mar</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
