<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Perfectly Concealing Quantum Bit Commitment from any Quantum One-Way Permutation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Paul</forename><surname>Dumais</surname></persName>
							<email>dumais@iro.umontreal.ca</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">Université de Montréal</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dominic</forename><surname>Mayers</surname></persName>
							<email>mayers@research.nj.nec.com</email>
							<affiliation key="aff1">
								<orgName type="institution">NEC Research Institute</orgName>
								<address>
									<settlement>Princeton</settlement>
									<region>N-J</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Louis</forename><surname>Salvail</surname></persName>
							<email>salvail@brics.dk</email>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">BRICS †</orgName>
								<orgName type="department" key="dep2">Dept. of Computer Science</orgName>
								<orgName type="institution">University of Århus</orgName>
								<address>
									<settlement>Århus</settlement>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Perfectly Concealing Quantum Bit Commitment from any Quantum One-Way Permutation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3995E2097A4198BF2464FAAACD258480</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show that although unconditionally secure quantum bit commitment is impossible, it can be based upon any family of quantum one-way permutations. The resulting scheme is unconditionally concealing and computationally binding. Unlike the classical reduction of Naor, Ostrovski, Ventkatesen and Young, our protocol is non-interactive and has communication complexity O(n) qubits for n a security parameter.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The non-classical behaviour of quantum information provides the ability to expand an initially short and secret random secret-key shared between a pair of trusted parties into a much longer one without compromising its security. The BB84 scheme was the first proposed quantum secret-key expansion protocol <ref type="bibr" target="#b2">[3]</ref> and was shown secure by Mayers <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b13">14]</ref>. Secret-key expansion being incompatible with classical information theory indicates that quantum cryptography is more powerful than its classical counterpart. However, quantum information has also fundamental limits when cryptography between two potentially collaborative but untrusted parties is considered. Mayers <ref type="bibr" target="#b12">[13]</ref> has proven that any quantum bit commitment scheme can either be defeated by the committer or the receiver as long as both sides have unrestricted quantum computational power. Mayers' general result was built upon previous works of Mayers <ref type="bibr" target="#b10">[11]</ref> and Lo and Chau <ref type="bibr" target="#b8">[9]</ref>.</p><p>However, the no-go theorem does not imply that quantum cryptography in the two-party case is equivalent to complexity-based classical cryptography. For example, quantum bit commitment schemes can be built from physical assumptions that are independent of the existence of one-way functions <ref type="bibr" target="#b15">[16]</ref>. Moreover, bit commitment is sufficient for quantum oblivious transfer <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b18">19]</ref> which would be true in the classical world only if one-way functions imply trapdoor one-way functions <ref type="bibr" target="#b7">[8]</ref>. The physical assumption addressed in <ref type="bibr" target="#b15">[16]</ref> restricts the size of the entanglement the adversary's quantum computer can deal with. Implementing any successful attack was shown, for a particular protocol with security parameter n, to require a Ω(n)-qubits quantum computer. However, such a physical assumption says nothing about the complexity of the attack. In this paper, we construct an unconditionally concealing quantum bit commitment scheme which can be attacked successfully only if the adversary can break a general quantum computational assumption.</p><p>We show that similarly to the classical case <ref type="bibr" target="#b14">[15]</ref>, unconditionally concealing quantum bit commitment scheme can be based upon any family of quantum one-way permutations. This result is not the direct consequence of the classical construction proposed by Noar, Ostrovsky, Ventkatesen and Young (NOVY) <ref type="bibr" target="#b14">[15]</ref>. One reason is that NOVY's analysis uses classical derandomization techniques (rewinding) in order to reduce the existence of an inverter to a successful adversary against the binding condition. In <ref type="bibr" target="#b17">[18]</ref>, it is shown that such a proof fails completely in a quantum setting: if rewinding was possible then no quantum one-way permutation would exist. Therefore, in order to show that NOVY's protocol is conditionally binding against the quantum computer, one has to provide a different proof.</p><p>We present a different construction using quantum communication in order to enforce the binding property. In addition, whereas one NOVY's commitment requires Ω(n) rounds (in fact n -1 rounds) of communication for some security parameter n, our scheme is non-interactive. Whether or not this is possible to achieve classically is still an open question. In addition, the total amount of communication of our scheme is O(n) qubits which also improves the Ω(n 2 ) bits needed in NOVY's protocol, as far as qubits and bits may be compared. Since unconditionally concealing bit commitment is necessary and sufficient for Zero-Knowledge arguments <ref type="bibr" target="#b4">[5]</ref>, using our scheme gives implementations requiring few rounds of interaction with provable security based upon general computational assumptions. Perfectly concealing commitment schemes are required for the security of several applications (as in <ref type="bibr" target="#b4">[5]</ref>). Using them typically forces the adversary to break the computational assumption before the end of the opening phase, whereas if the scheme was computationally concealing the dishonest receiver could carry out the attack as long as the secret bit remains relevant. Any secure application using NOVY as a sub-protocol can be replaced by one using our scheme instead thus improving communication complexity while preserving the security.</p><p>This work provides motivations for the study of one-way functions in a quantum setting. Quantum one-way functions and classical one-way functions are not easily comparable <ref type="bibr" target="#b5">[6]</ref>. On the one hand, Shor's algorithm <ref type="bibr" target="#b16">[17]</ref> for factoring and extracting discrete logs rules out any attempt to base quantum one-wayness upon those computational assumptions. This means that several flexible yet useful classical one-way functions cannot be used for computationally based quantum cryptography.</p><p>On the other hand, because the quantum computer evaluates some functions more efficiently than the classical one, some quantum one-way functions might not be classical one-way since classical computers could even not be able to compute them in the forward direction. This suggests that quantum cryptography can provide new foundations for computationally based security in cryptography.</p><p>Organization. First, we give some preliminaries and definitions in Sect.2. Therein, we define the model of computation, quantum one-way functions, and the security criteria for the binding condition. In Sect. 3, we describe our perfectly concealing but computationally binding bit commitment scheme. In Sect. 4, we show that our scheme is indeed unconditionally concealing. Then we model the attacks against the binding condition in Sec. 5. Section 6 reduces the existence of a perfect inverter for a family of one-way permutations to any perfect adversary against the binding condition of our scheme. In Sect. 7, we extend the reduction by showing that any efficient adversary to the binding condition implies an inverter for the family of one-way permutations working efficiently and having good probability of success.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>After having introduced the basic quantum ingredients, we define quantum oneway functions and the attacks against the binding condition of computationally binding quantum commitment schemes. We assume the reader familiar with the basics of quantum cryptography and computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Quantum Encoding</head><p>In the following, we denote the m-dimensional Hilbert space by H m . The basis {|0 , |1 } denotes the computational or rectilinear or "+" basis for H 2 . When the context requires, we write |b + to denote the bit b in the rectilinear basis. The diagonal basis, denoted "×", is defined as i P i = 1 1 m for 1 1 m denoting the identity operator in H m . Each projection or equivalently each index i ∈ {1, . . . , m} is a possible classical outcome for M. In the following, we write</p><formula xml:id="formula_0">{|0 × , |1 × } where |0 × = 1 √ 2 (|0 + |1 ) and |1 × = 1 √ 2 (|0 -|1</formula><formula xml:id="formula_1">P 0 + = |0 0|, P 1 + = |1 1|, P 0 × = |0 × 0| and P 1 × = |1 × 1|</formula><p>for the projections along the four BB84 states. We also define for any y ∈ {0, 1} n the projection operators P y + n = ⊗ n i=1 P yi + and P y × n = ⊗ n i=1 P yi × . Since the basis + n in H 2 n is the computational basis, we also write P y = P y + n . In order to simplify the notation, in the following we write θ(0) = + and θ(1) = ×. For any w ∈ {0, 1}, we denote by M θ(w) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Model of Computation and Quantum One-Wayness</head><p>Quantum one-way functions are defined as the natural generalization of classical one-way functions. Informally, a quantum one-way function is a classical function that can be evaluated efficiently by a quantum algorithm but cannot be inverted efficiently and with good probability of success by any quantum algorithm. An algorithm for inverting a one-way function is called an inverter. In this paper, we model inverters (and adversaries against the binding condition) by quantum circuits built out of the universal set of quantum gates UG = {CNot, H, R Q }, where CNot denotes the controlled-not, H the one qubit Hadamard gate, and R Q is an arbitrary one qubit non-trivial rotation specified by a matrix containing only rational numbers <ref type="bibr" target="#b0">[1]</ref>. A circuit C executed in the reverse direction is denoted</p><formula xml:id="formula_2">C † . The composition of two circuits C 1 , C 2 is denoted C 1 •C 2 .</formula><p>If the initial state before the execution of a circuit C is |Φ , the final state after the execution is C|Φ . To compute a deterministic function f : {0, 1} n → {0, 1} m(n) , we need a circuit C n on l(n) qubits and we must specify n ≤ l(n) input qubits and m(n) ≤ l(n) output qubits. The classical input x is encoded in the state |x of the n input qubits. The other qubits, i.e. the non input qubits, are always initialized in the fixed state |0 . The random classical output of the circuit C n on input x ∈ {0, 1} n is defined as the classical outcome of M m(n) on the m(n) output qubits at the end of the circuit. A family C = {C n } ∞ n=1 is an exact family of quantum circuits for the family of deterministic functions</p><formula xml:id="formula_3">F = {f n : {0, 1} n → {0, 1} m(n) } ∞ n=1 if the the classical output of the circuit C n on input |x ⊗ |0 ∈ H 2 l(n) produces</formula><p>with certainty f n (x) as output. This definition can be generalized the obvious way in order to cover the non exact case and families of random functions.</p><p>The complexity of the circuit C n is simply the number C n U G of elementary gates in UG contained in C n . Finally, the family C is uniform if, given 1 n as input, there exists a (quantum) Turing machine that produces C n ∈ C in (quantum) polynomial time in n. The family C is non-uniform otherwise. Our results hold for both the uniform and the non-uniform cases. The following definition is largely inspired by Luby's definitions for classical one-way functions <ref type="bibr" target="#b9">[10]</ref>. Let x n be a uniformly distributed random variable over {0, 1} n .</p><formula xml:id="formula_4">Definition 1 A family of deterministic functions F = {f n : {0, 1} n → {0, 1} m(n) |n &gt; 0} is R(n)-secure quantum one-way if</formula><p>there exists an exact family of quantum circuits C = {C n } n&gt;0 for F such that for all n &gt; 0, C n ≤ poly(n) and for all family of quantum circuits C -1 = {C -1 n } n&gt;0 and for all n sufficiently large, it is always the case that</p><formula xml:id="formula_5">C -1 n U G /S(n) ≥ R(n) where S(n) = Pr f n (C -1 n (f n (x n ))) = f n (x n ) .</formula><p>Each family of quantum circuits C -1 is called an inverter and the mapping S(n) is called its probability of success.</p><p>Note that whenever f n is a permutation, S(n) can be written as</p><formula xml:id="formula_6">S(n) = Pr f n (C -1 n (y n )) = y n where y n is a uniformly distributed random variable in {0, 1} n .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The Binding Condition</head><p>In a non interactive bit commitment scheme, an honest committer A for bit w starts with a system </p><formula xml:id="formula_7">H All = H Keep ⊗ H Open ⊗ H Commit in</formula><formula xml:id="formula_8">(w) = Tr A (|Ψ w Ψ w |), where A's Hilbert space is H A = H Keep ⊗ H Open . Once the system H Commit is sent away to B, A has only access to ρ A (w) = Tr B (|Ψ w Ψ w |), where B's Hilbert space is H B = H Commit .</formula><p>To open the commitment, A needs only to send the system H Open together with w. The receiver B then tests the value of w by measuring the system H Open ⊗ H Commit with some measurement that is fixed by the protocol in view of w. He obtains the outcome w = 0, w = 1, or w =⊥ when the value of w is rejected.</p><p>An attack of the committer Ã must start with the state |0 of some system w , w = 0, 1, which respectively maximize the probability that the bit w = 0 and w = 1 is unveiled with success. Therefore, any attack can be modeled by triplets of quantum circuits {(C n , O n 0 , O n 1 )} n&gt;0 . The efficiency of an adversary is determined by 1) the total number of elementary gates</p><formula xml:id="formula_9">H All = H Extra ⊗ H A ⊗ H Commit . A quantum circuit C n that</formula><formula xml:id="formula_10">T (n) = C n U G + O n 0 U G + O n 1 U G in the three circuits C n , O n</formula><p>0 and O n 1 and 2) the probabilities S w (n), w = 0, 1, that he succeeds to unveil w using the associated optimal circuit O n w . The definition of S w (n) explicitly requires that the value of w, which the adversary tries to open, is chosen not only before the execution of the measurement on H Open ⊗ H Commit by the receiver but also before the execution of the circuit O n w by the adversary. In the classical world, one can always fix the adversary's committed bit by fixing the content of his random tape, that is, we can require that either the probability to unveil 0 or the probability to unveil 1 vanishes, for every fixed value of the random tape. This way of defining the security of a bit commitment scheme does not apply in the quantum world because, even if we fix the random tape, the adversary could still introduce randomness in the quantum computation. In particular, a quantum committer can always commit to a superposition of w = 0 and w = 1 by preparing the following state</p><formula xml:id="formula_11">|Ψ (c 0 ) = √ c 0 |0 A ⊗ |Ψ 0 + √ 1 -c 0 |1 A ⊗ |Ψ 1 ,<label>(1)</label></formula><p>where |Ψ 0 and |Ψ 1 are the honest states generated for committing to 0 and 1 respectively and |0 A and |1 A are two orthogonal states of H Extra , an extra ancilla kept by A. In this case, for both value of w ∈ {0, 1}, the opening circuit O n w can put H Open into a mixture that will unveil w successfully with some non zero probability. So we have S 0 (n), S 1 (n) &gt; 0. The fact that the binding condition S 0 (n) = 0 ∨ S 1 (n) = 0 is too strong was previously noticed in <ref type="bibr" target="#b12">[13]</ref>. We propose the weaker condition S 0 (n) + S 1 (n) -1 ≤ (n) where (n) is negligible (i.e. smaller than 1/poly(n) for any polynomial p(n)). For classical applications, this binding condition (with (n) = 0) is as good as if the commiter was forced to honestly commit a random bit (with the bias of his choice) and only had the power to abort in view of the bit. The power of this binding condition for quantum applications is unclear, but we think it is a useful condition even in that context.</p><p>We now extend this binding condition to a computational setting. It is convenient to restrict ourselves to the cases where O n 0 is the identity circuit. We can adopt this restriction without lost of generality because any triplet (C n , O n 0 , O n 1 ) can easily be replaced by the three quantum circuits (C n</p><formula xml:id="formula_12">0 , 1 1, U n 0,1 ), where C n 0 = (O n 0 ⊗ 1 1 Commit ) • C n and U n 0,1 = O n 1 • (O n 0 ) † , without chang- ing the adversaries strategy. The difference in complexity between applying (C n , O n 0 , O n 1 ) and (C n 0 , 1 1, U n 0,1 ) is only ∆T (n) = O n 0 U G .</formula><p>Therefore, the adversary is completely determined by the pair (C n 0 , U n 0,1 ) where C n 0 acts on all registers in H All , and U n 0,1 is restricted to act only in</p><formula xml:id="formula_13">H Extra ⊗ H Keep ⊗ H Open .</formula><p>Definition 2 An adversary Ã = {(C n 0 , U n 0,1 )} n for the binding condition of a quantum bit commitment scheme is (S(n), T (n))-successful if for all n ∈ N,</p><formula xml:id="formula_14">U n 0,1 U G + C n 0 U G ≤ T (n) and S 0 (n) + S 1 (n) -1 = S(n).</formula><p>An adversary with S(n) = 1 is called a perfect adversary.</p><p>Any (0, T (n))-successful adversary does not achieve more than what an honest committer is able to do. In order to cheat, an adversary must be (S(n), T (n))successful for some non-negligible S(n) &gt; 0. The security of a quantum bit commitment scheme is defined as follow: Definition 3 A quantum bit commitment scheme is R(n)-binding if there exists no (S(n), T (n)-successful quantum adversary against the binding condition that satisfies T (n)/S(n) ≤ R(n). A quantum bit commitment scheme is perfectly concealing (statistically concealing) if the systems received for the commitments of 0 and 1 are identical (resp. statistically indistinguishable).</p><p>It is easy to verify that if a R(n)-binding classical bit commitment scheme (satisfying the classical definition) allows to implement a cryptographic task securely, then using a R(n)-binding quantum bit commitment scheme instead would also provide a secure implementation.</p><p>The scheme we describe next will be shown to be perfectly concealing and Ω(R(n))-binding whenever used with a R(n) 2 -secure family of one-way permutations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Scheme</head><p>Let Σ = {σ n : {0, 1} n → {0, 1} n |n &gt; 0} be a family of one-way permutations. The commitment scheme takes, as common input, a security parameter n ∈ N and the description of family Σ. The quantum part of the protocol below is similar to the protocol for quantum coin tossing described in <ref type="bibr" target="#b2">[3]</ref>. Given Σ and n, the players determine the instance σ n : {0, 1} n → {0, 1} n ∈ Σ. A sends through the quantum channel σ n (x) for x ∈ R {0, 1} n polarized in basis θ(w) n where w ∈ {0, 1} is the committed bit. B then stores the received quantum state until the opening phase. It is implicit here that B must protect the received system commitΣ,n(w)</p><formula xml:id="formula_15">1. A picks x ∈R {0, 1} n , computes y = σn(x) for σn ∈ Σ, 2. A sends the quantum state |σn(x) θ(w) n ∈ HCommit to B.</formula><p>H Commit H 2 n against decoherence until the opening phase. The opening phase consists only for A to unveil all her previous random choices allowing B to verify the consistency of the announcement by measuring the received state. So, H Open H 2 n is only used to store classical information. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Concealing Condition</head><p>In this section, we show that every execution of commit Σ,n conceals w perfectly.</p><p>Let ρ w for w ∈ {0, 1} be the density matrix corresponding to the mixture sent by A when classical bit w is committed. Since σ n is a permutation of the elements in the set {0, 1} n , we get</p><formula xml:id="formula_16">ρ 0 = x∈{0,1} n 2 -n |x + n x| = 2 -n 1 1 2 n = x∈{0,1} n 2 -n |x × n x| = ρ 1 (2)</formula><p>where 1 1 2 n is the identity operator in H 2 n . The following lemma follows directly from (2).</p><p>Lemma 1. Protocol commit Σ,n (w) is perfectly concealing.</p><p>Proof: The quantum states ρ 0 and ρ 1 are the same. It follows that no quantum measurement can distinguish between the commitments of 0 and 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">The Most General Attack</head><p>Here we describe the most general adversary Ã = {(C n 0 , U n 0,1 )} n≥n0 against the binding condition of our scheme. We shall prove that any such attack can be used to invert the one-way permutation in subsequent sections.</p><p>The adversary doesn't necessarily know which value will take y on the receiver's side after the measurement M θ(w) n on H Commit associated with the opening of w. He computes x ∈ {0, 1} n using O n w , announces (x, w) and hopes that σ n (x) = y. So we have that H Open H 2 n is used to encode x ∈ {0, 1} n . We separate the entire system in three parts: the system H Commit that encodes y, the system H Open that encodes x, and the remainder of the system that we conveniently denote all together by H Keep (thus including for simplicity register H Extra ). We easily obtain that the states | Ψ n w = C n w |0 , w = 0, 1, can be written in the form</p><formula xml:id="formula_17">| Ψ n 0 = x,y∈{0,1} n |γ x,y 0 Keep ⊗ |x Open ⊗ |y Commit + n = C n 0 |0<label>(3)</label></formula><p>with x,y |γ x,y 0 2 = 1, and is applied on the system H Keep ⊗ H Open .</p><formula xml:id="formula_18">| Ψ n 1 = x,y∈{0,1} n |γ x,y 1 Keep ⊗ |x Open ⊗ |y Commit × n = U n 0,1 | Ψ n 0<label>(4)</label></formula><p>Next section restricts the analysis to the case where an adversary A can open both w = 0 and w = 1 with probability of success p w = 1. Such an adversary is called a perfect adversary. We show that any perfect adversary can invert efficiently σ n (x) for any x ∈ {0, 1} n . In Sect. 7 we generalize the result to all imperfect but otherwise good adversaries. We show that any polynomial time adversary for which p 0 + p 1 ≥ 1 + 1 poly(n) can invert σ n (x) for x ∈ R {0, 1} n efficiently and with non-negligible probability of success.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Perfect attacks</head><p>In this section, we prove that any efficient perfect adversary A = {(C n 0 , U n 0,1 )} n against the binding condition can be used to invert efficiently the one-way permutation with probability of success 1. In the next section, we shall use a similar technique for the case where the attack is not perfect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By definition, a perfect adversary</head><formula xml:id="formula_19">A is (1, T (n))-successful, that is: S 0 (n) = S 1 (n) = 1. We obtain that |γ x,y w = 0 if σ n (x) = y: |Ψ n 0 = x∈{0,1} n |γ x 0 Keep ⊗ |x Open ⊗ |σ n (x) Commit + n = C n 0 |0<label>(5)</label></formula><p>where |γ x 0 corresponds to |γ</p><p>x,σn(x) 0 and x |γ x 0 2 = 1, and</p><formula xml:id="formula_20">|Ψ n 1 = x∈{0,1} n |γ x 1 Keep ⊗ |x Open ⊗ |σ n (x) Commit × n = U n 0,1 |Ψ n 0 (<label>6</label></formula><formula xml:id="formula_21">)</formula><p>where |γ x 1 corresponds to |γ</p><p>x,σn(x) 1</p><p>and x |γ x 1 2 = 1. Any pair of 0-state and 1-state satisfying ( <ref type="formula" target="#formula_19">5</ref>) and ( <ref type="formula" target="#formula_20">6</ref>) is called a perfect pair. Any perfect adversary </p><formula xml:id="formula_22">A = {(C n 0 , U n 0,</formula><formula xml:id="formula_23">. U n 0,1 |Φ n 0 (u) = |γ σ -1 (u) Keep ⊗ |σ -1 n (u) Open ⊗ |u Commit × n .</formula><p>On input y ∈ {0, 1} n , the inverter creates the state |Ψ n 0 , then applies the circuit W n , then the circuit U n 0,1 , and finally measures the register H Open to obtain σ -1 n (y). We now prove these three properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Proof of Properties 1 and 3</head><p>First we write the state |Ψ n 0 using the basis × n for the register H Commit H 2 n . We get</p><formula xml:id="formula_24">|Ψ n 0 = 2 -n/2 u,v∈{0,1} n (-1) u v |γ σ -1 n (v) 0 Keep ⊗ |σ -1 n (v) Open ⊗ |u Commit × n</formula><p>from which we easily obtain, after the change of variable σ -1 n (v) → x,</p><formula xml:id="formula_25">|Φ n 0 (u) = 2 -n/2 x∈{0,1} n (-1) u σn(x) |γ x 0 Keep ⊗ |x Open ⊗ |u Commit × n . (<label>7</label></formula><formula xml:id="formula_26">)</formula><p>Property 1 follows from <ref type="bibr" target="#b6">(7)</ref>. Note that the states |Φ n 0 (u) can be mapped one into the other by a unitary mapping, a conditional phase shift which depends on u and x. Because (6) can be rewritten as</p><formula xml:id="formula_27">|Ψ n 1 = u∈{0,1} n |γ σ -1 (u) 1 Keep ⊗ |σ -1 (u) Open ⊗ |u Commit × n</formula><p>, it follows that, for all u ∈ {0, 1} n , we have</p><formula xml:id="formula_28">U n 0,1 |Φ n 0 (u) = U n 0,1 P u,× Commit |Ψ n 0 = P u,× Commit U n 0,1 |Ψ n 0 = P u,× Commit |Ψ n 1 = |γ σ -1 (u) Keep |σ -1 n (u) Open |u Commit × n .</formula><p>which concludes the proof of property 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Proof of Property 2</head><p>A simple comparison of ( <ref type="formula" target="#formula_19">5</ref>) and ( <ref type="formula" target="#formula_25">7</ref>) suggests what needs to be done to obtain 2 n/2 |Φ n 0 (y) efficiently starting from |Ψ n 0 . Assume the input register</p><formula xml:id="formula_29">H Y = H 1 Y ⊗ . . . ⊗ H n Y H 2 n</formula><p>is in the basis state |y . The first step is to add the phase (-1) y σn(x) in front of each term in the sum of <ref type="bibr" target="#b4">(5)</ref>. Note that, for every y ∈ {0, 1} n , this is a unitary mapping on H Keep ⊗ H Open ⊗ H Commit . It is sufficient to execute a circuit ⊕1 which, for each i ∈ {1, . . . , n}, acts on the corresponding pair of qubits in H 2 for i ∈ {1, . . . , n}. Finally the third circuit executes the Hadamard transform H n on H Commit which maps the + n basis into the × n basis (it is simply n Hadamard gates H ∈ UG) . The composition of ⊕n with these three circuits is the circuit W n shown in Fig. <ref type="figure">1</ref>. This circuit allows to generate any 2 n/2 |Φ n 0 (y) for y ∈ {0, 1} n . Moreover, it is easy to verify that W n U G = U σn U G + 5n. The following is a</p><formula xml:id="formula_30">H i Y ⊗ H i Commit . The circuit ⊕1 maps each state |y i ⊗ |σ n (x) i , i = 1, . . . , n, into (-1) (yi σn(x)i) (|y i ⊗|σ n (x) i ). It can easily be implemented as ⊕1 = (H ⊗ 1 1 Commit ) • CNot • (H ⊗ 1 1 Commit )</formula><formula xml:id="formula_31">H Y H Commit H Open n U¡ n n H n Fig. 1. Transformation Wn.</formula><p>straightforward consequence of these three properties, the definition of W n and the above discussion: Lemma 2. If there exists a (1, T (n))-successful adversary against commit Σ,n then there exists an adversary against Σ with time-success ratio</p><formula xml:id="formula_32">R(n) ≤ T (n) + U σn U G + 5n.</formula><p>It follows that the adversary against Σ has about the same complexity than the one against the binding condition of commit Σ,n . In the next section, we show that the same technique can be applied to the case where the adversary does not implement a perfect attack against commit Σ,n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">The General Case</head><p>In this section, we are considering any attack that yields a non-negligible success probability to a cheating committer. In terms of Definition 2, such an adversary Ã = {(C n 0 , U n 0,1 )} n must be ( (n), T (n))-successful for some (n) ≥ 1/poly(n) ≥ 0. In order for the attack to be efficient, T (n) must also be upper bounded by some polynomial.</p><p>In general, the 0-state | Ψ n 0 and 1-state | Ψ n 1 of adversary Ã can always be written as in ( <ref type="formula" target="#formula_17">3</ref>) and ( <ref type="formula" target="#formula_18">4</ref>) respectively. In this general case, the probability of success of unveiling the bit w, i.e. the probability of not being caught cheating, is the probability of the event Ã announces a value x and the outcome of B's measurement happens to be σ n (x). One can see easily that this probability is given by :</p><formula xml:id="formula_33">S Ã w = S Ã w (n) = v |γ v,σn(v) w 2 . (<label>8</label></formula><formula xml:id="formula_34">)</formula><p>If the adversary Ã is ( (n), T (n))-successful then</p><formula xml:id="formula_35">S Ã 0 + S Ã 1 ≥ 1 + (n).<label>(9)</label></formula><p>In that setting, our goal is to show that from such an adversary Ã, σ -1 n (y) can be computed similarly to the perfect case and with probability of success at least 1/poly(n) whenever y ∈ R {0, 1} n and (n) -1 is smaller than some positive polynomial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">The Inverter</head><p>Compared to the perfect case, the inverter for the general case will involve an extra step devised to produce a perfect |Ψ n 0 from the initial and imperfect 0-state | Ψ n 0 . Although this preprocessing will succeed only with some probability, any ( 1 p(n) , T (n))-successful adversary can distill |Ψ n 0 from | Ψ n 0 efficiently and with good probability of success. From |Ψ n 0 , the inverter then proceeds the same way as in the perfect case.</p><p>The distillation process involves a transformation T n acting in H Open ⊗ H Commit ⊗ H T where H T H 2 n is an extra register. We define T n as:</p><formula xml:id="formula_36">T n : |x Open |y Commit |a T → |x Open |y Commit |σ n (x) ⊕ y ⊕ a T .<label>(10)</label></formula><p>Clearly, one can always write</p><formula xml:id="formula_37">T n (| Ψ n 0 All ⊗ |0 T ) = σn(x) =z |γ x,z 0 Keep |x Open |z Commit |σ n (x) ⊕ z T + x |γ x,σn(x) 0 Keep |x Open |σ n (x) Commit |0 T .<label>(11)</label></formula><p>Upon standard measurement of register H T in state |0 , the adversary obtains the quantum residue (by tracing out the ancilla):</p><formula xml:id="formula_38">|Ψ n 0 = x |γ x 0 Keep ⊗ |x Open ⊗ |σ n (x) Commit<label>(12)</label></formula><p>where Keep , with probability</p><formula xml:id="formula_39">|γ x 0 Keep = 1 S Ã 0 |γ x,σn(x)</formula><formula xml:id="formula_40">S Ã 0 = v |γ v,σn(v) 0 2 = | Ψ n 0 | Ψ n 0 | 2 .</formula><p>It is easy to verify that T n can be implemented by a quantum circuit of O( U σn U G ) elementary gates. On input y ∈ R {0, 1} n , the inverter then works exactly as in the perfect case. In Fig. <ref type="figure">2</ref>, the quantum circuit for the general inverter I Ã n (y) is shown. The input quantum register is H Y and the output register is H Open . The output is the outcome of the standard measurement M n applied to the output register H Open which hopefully contains x = σ -1 n (y). The</p><formula xml:id="formula_41">H Y H Commit H Open H T H Keep C n 0 T n n W n U n 0,1 n</formula><p>Fig. <ref type="figure">2</ref>. The inverter I Ã n (y), y ∈ {0, 1} n obtained from adversary Ã = (C n 0 , U n 0,1 ).</p><p>following lemma is straightforward and establishes the efficiency of the inverter in terms of the efficiency of Ã's against commit Σ,n :</p><formula xml:id="formula_42">Lemma 3. If Ã is (•, T (n))-successful then I Ã n (y) U G ∈ O(T (n) + U σn U G ).</formula><p>It should be noted that gates ⊕ n and H n appearing in circuit W n are not taken into account in the statement of Lemma 3. The reason is that none of them influence the final outcome since they commute with the final measurement in H Open . They have been included in W n to help the reader with the analysis of the success probability described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Analysis of the Success Probability</head><p>Let Ã = {(C n 0 , U n 0,1 )} n&gt;0 be any ( (n), •)-successful adversary for some (n) &gt; 0 thus satisfying S Ã 0 + S Ã 1 ≥ 1 + (n). Let P x Open be the projection operator P x applied to register H Open . We recall that P </p><p>which have the property, using <ref type="bibr" target="#b7">(8)</ref>, that S Ã 0</p><formula xml:id="formula_44">= P 0 | Ψ n 0 2 and S Ã 1 = P 1 | Ψ n<label>1</label></formula><p>2 . Next lemma relates the success probability to projections P 0 and P 1 .</p><p>Lemma 4. The probability of success p s of inverter I Ã n (y) satisfies</p><formula xml:id="formula_45">p s = P 1 U n 0,1 P 0 | Ψ n 0 2 .</formula><p>Proof: We recall that the probability of success is defined in terms of a uniformly distributed input y. We will first compute the probability p s (y) that the inverter succeeds on input y ∈ {0, 1} </p><formula xml:id="formula_46">(y) = S Ã 0 2 n P σ -1 n (y) Open P y,× Commit U n 0,1 |Ψ n 0 2 = 2 n P σ -1 n (y) Open P y,× Commit U n 0,1 P 0 | Ψ n 0 2</formula><p>. Averaging over all values of the uniformly distributed variable y we obtain:</p><formula xml:id="formula_47">p s = y∈{0,1} n 2 -n p s (y) = y∈{0,1} n P σ -1 n (y) Open ⊗ P y,× Commit U n 0,1 P 0 | Ψ n 0 2 =   y∈{0,1} n P σ -1 n (y) Open ⊗ P y,× Commit   U n 0,1 P 0 | Ψ n 0 2 = P 1 U n 0,1 P 0 | Ψ n 0 2<label>(14)</label></formula><p>where ( <ref type="formula" target="#formula_47">14</ref>) is obtained from the fact that {P x Open ⊗ P σn(x),× Commit } x∈{0,1} n is a set of orthogonal projections and from Pythagoras theorem.</p><p>We are now ready to relate the probability of success for the inverter given a good adversary against the binding condition of commit Σ,n . Lemma 5. Let I Ã n be the inverter obtained from a (S Ã 0</p><formula xml:id="formula_48">+ S Ã 1 -1, •)-successful adversary Ã with S Ã 0 +S Ã 1 ≥ 1+ (n) for (n) &gt; 0 for all n &gt; 0.</formula><p>Then the success probability p s to invert with success a random image element satisfies</p><formula xml:id="formula_49">p s ≥ ( S Ã 1 -1 -S Ã 0 ) 2 .</formula><p>Proof: Using lemma 4, we can write</p><formula xml:id="formula_50">p s = P 1 U n 0,1 P 0 | Ψ n 0 2 = P 1 U n 0,1 (1 1 Ã -P ⊥ 0 )| Ψ n 0 2 = P 1 U n 0,1 | Ψ n 0 -P 1 U n 0,1 P ⊥ 0 | Ψ n 0 2 = P 1 | Ψ n 1 -P 1 U n 0,1 P ⊥ 0 | Ψ n 0 2 .</formula><p>Using the triangle inequality and S Ã 1 &gt; 1 -S Ã 0 , we are led to</p><formula xml:id="formula_51">p s ≥ P 1 | Ψ n 1 -P 1 U n 0,1 P ⊥ 0 | Ψ n 0 2 ≥ P 1 | Ψ n 1 -P ⊥ 0 | Ψ n 0 2 = S Ã 1 -1 -S Ã 0 2 .</formula><p>From Lemma 5 and a few manipulations, we conclude that S Ã 0 + S Ã 1 &gt; 1 + (n) implies that p s &gt; (n) 2 /4. In addition, if (n) ∈ Ω( 1 poly(n) ) and T (n) ∈ O(poly(n)) then the inverter works in polynomial time with probability of success in Ω(1/poly(n) 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>The concealing condition is established unconditionally by Lemma 1. Lemmas 3 and 5 imply that any (S(n), T (n))-successful adversary against commit Σ,n can invert the family of one-way permutations Σ with time-success ratio roughly T (n)/S(n) 2 . We finally obtain: Theorem 1. Let Σ be a R(n)-secure family of one-way permutations. Protocol commit Σ,n is unconditionally concealing and R (n)-binding where R (n) ∈ Ω( R(n)).</p><p>Our reduction produces only a quadratic blow-up in the worst case between the time-success ratio of the inverter and the time-success ratio of the attack. Compared to NOVY's construction, the reduction is tighter by several degrees of magnitude. If Σ is T (n)/S(n)-secure with 1 S(n) ∈ O( T (n)) then the reduction is optimal.</p><p>In order for the scheme to be practical, the receiver should not be required to store the received qubits until the opening phase. It is an open question whether or not our scheme is still secure if the receiver measures each qubit π i upon reception in a random basis θ i ∈ R {+, ×}. The opening of w ∈ {0, 1} being accepted if each time θ i = θ(w), the announced x ∈ {0, 1} n is such that [σ n (x)] i = ỹi . That way, the protocol would require similar technology than the one needed for implementing the BB84 quantum-key distribution protocol <ref type="bibr" target="#b1">[2]</ref>.</p><p>It is also not clear how to modify the scheme in order to deal with noisy quantum transmissions. Another problem linked to practical implementation is the lack of tolerance to multi-photon pulses. If for x, w ∈ {0, 1}, the quantum state |φ x θ(w) ⊗ |φ x θ(w) is sent instead of |φ x θ(w) then commit Σ,n is no more concealing. Moreover, it is impossible in practice to make sure that only one qubit per pulse is sent.</p><p>Our main open problem is the finding of candidates for families of quantum one-way permutations or functions. If a candidate family of quantum one-way functions was also computable efficiently on a classical computer then classical cryptography could provide computational security even against quantum adversaries. It would also be interesting to find candidates one-way functions that are not classical one-way. Quantum cryptography could then provide a different basis for computational security in cryptography.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>openΣ,n(w, x) 1. A announces w and x to B, 2. B measures ρB with measurement M θ(w) n thus providing the classical outcome ỹ ∈ {0, 1} n , 3. B accepts if and only if ỹ = σn(x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>with x,y |γ x,y 1 2 = 1 .</head><label>11</label><figDesc>In the following, we shall refer to states | Ψ n 0 and | Ψ n 1 as the 0-state and the 1-state of the attack respectively. The transformation U n 0,1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>the state |x θ is defined as ⊗ n i=1 |x i θi . An orthogonal (or Von Neumann) measurement of a quantum state in H m is described by a set of m orthogonal projections M = {P i } m i=1 acting in H m thus satisfying</head><label></label><figDesc>). The states |0 , |1 , |0 × and |1 × are the four BB84 states. For any x ∈ {0, 1} n and θ ∈ {+, ×} n ,</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>n the Von Neumann measurement {P y θ(w) n } y∈{0,1} n . We denote by M n for n ∈ N, the Von Neumann measurement in the computational basis applied on an n-qubit register. Finally, in order to indicate that |φ ∈ H 2 r is the state of a quantum register H R H 2 r we write |φ R . If H R H 2 r and H S H 2 s are two quantum registers and |φ = x∈{0,1} r y∈{0,1} s γ x,y |x ⊗ |y ∈ H 2 r ⊗ H 2 s then we write |φ RS = x∈{0,1} r y∈{0,1} s γ x,y |x R ⊗|y S to denote the state of both registers H R and H S . Given any transformation U R that acts on a register H R and any state |φ ∈ H R ⊗ H Others , where H Others corresponds to other registers, we define U R |φ</figDesc><table><row><cell>def = (U R ⊗ 1 1 Others ) |φ . We use the same notation when U R denotes a projection operator.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>the initial state |0 , executes a quantum circuit C n,w on |0 returning the final state |Ψ w ∈ H All and finally sends the subsystem H Commit to B in the reduced state ρ B</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>acts on H All is executed to obtain a state | Ψ and the subsystem H Commit is sent to the receiver. Later, any quantum circuit O n which acts on H Extra ⊗ H Keep ⊗ H Open can be executed before sending the subsystem H Open to the verifier. The important quantum circuits which act on H Extra ⊗H Keep ⊗H Open are the quantum circuits O n</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>1 )} n generates a perfect pair for all n &gt; 0. Let P u,+ Commit and P u,× Commit be the projection operators P u + n and P u × n respectively, acting upon register H Commit . We assume that we have an input register H Y H 2 n initialized in the basis state |y on input y. The states |Φ n 0 (u) = P u,× Commit |Ψ n 0 , u ∈ {0, 1} n , play an essential role in the mechanisms used by the inverter. These states have three key properties for every u ∈ {0, 1} n : 1. |Φ n 0 (u) = 2 -n/2 , 2. there exists a simple circuit W n on H Y ⊗ H Open ⊗ H Commit which, if u is encoded in register H Y , unitarily maps |Ψ n 0 into 2 n/2 |Φ n 0 (u) , and 3</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>where each H is applied to register H i Y and where register H i Commit encodes the control bit of the CNot gate. We denote by ⊕n the complete quantum circuit acting in H Y ⊗ H Commit and applying ⊕1 to each pair i ∈ {1, . . . , n} of qubits |y i ⊗ |σ n (x) i ∈ H i Y ⊗ H i Commit . The second step is to set the register H Commit which contains the state |σ n (x) + n into the new state |y × n . For this we use the composition of three circuits. The first circuit U σn : |x Open ⊗|u Commit → |x Open ⊗|u⊕σ n (x) Commit sets the quantum register H Commit into the new state |0 + n . Note that U σn is the quantum circuit that is guaranteed to compute σ n (x) efficiently. The second circuit is ⊕ n : |y Y ⊗ |u Commit → |y Y ⊗ |y ⊕ u Commit which sets H Commit into the state |y + n by simply applying a CNot between registers H i Commit , H i Y</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>y,+ Commit and P y,× Commit are the projection operators P y + n and P y × n respectively, acting upon register H Commit . We now define the two projection operators:</figDesc><table><row><cell>P 0 =</cell><cell>x∈{0,1} n</cell><cell>P x Open ⊗ P</cell><cell>σn(x),+ Commit and P 1 =</cell><cell>x∈{0,1} n</cell><cell>P x Open ⊗ P</cell><cell>σn(x),× Commit</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>n . Assume that right after gate T n , the register H T is observed in state |0 . The registers H All ⊗ H Y have now collapsed to the state |y Y ⊗ |Ψ n 0 where |Ψ n 0 is the state P 0 | Ψ n 0 after renormalization. Note that |Ψ n 0 is a perfect 0-state. This event has probability P 0 | Ψ0 2 = S Ã 0 to happen according to (12). Next the circuit W n , with y encoded in H Y , unitarily maps the state |Ψ n 0 into the state 2 n/2 |Φ n Open is measured and the probability of success given the initial state |Ψ n 0 is 2 n/2 P</figDesc><table><row><cell>0 (y) = 2 n/2 P y,× Commit |Ψ n 0 (see 0,1 returns the state 2 n/2 P y,× Sect. 6). Then the circuit U n Commit U n 0 . Finally, 0,1 |Ψ n the register H σ -1 n (y) Open P y,× Commit U n 0,1 |Ψ n 0 2 . Using (12), we get that p s</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. Thanks to Ivan Damgård for several enlightening discussions and to Peter Høyer for helping with the circuitry. Thanks also to Alain Tapp for helpful comments on earlier drafts.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported by a NSERC grant, part of this work was done while visiting BRICS and McGill SOCS. Part of this work was done while visiting BRICS and NEC Tsukuba Laboratory, Japan. Supported by the Thomas B. Thriges Center for KvanteInformatik (CKI). † Basic Research in Computer Science of the Danish National Research Foundation.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Elementary Gates for Quantum Computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Barenco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cleve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Divincenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Margolus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sleator</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Weinfurter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review A</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="3457" to="3467" />
			<date type="published" when="1995-11">November 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Experimental Quantum Cryptography</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bessette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Salvail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smolin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="28" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Quantum Cryptography: Public Key Distribution and Coin Tossing</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Computers, Systems, and Signal Processing</title>
		<meeting>the IEEE International Conference on Computers, Systems, and Signal Processing<address><addrLine>Bangalore, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984-12">December 1984</date>
			<biblScope unit="page" from="175" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Practical Quantum Oblivious Transfer</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-H</forename><surname>Skubiszewska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology : CRYPTO &apos;91 : Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992-08">August 1992</date>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="362" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Minimum Disclosure Proofs of Knowledge</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="156" to="189" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-12">December 1998</date>
		</imprint>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Two-Bit Gates Are Universal For Quantum Computation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Divincenzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review A</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1015" to="1022" />
			<date type="published" when="1995-02">February 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Limits on Provable Consequences of One-Way Permutations</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty First Annual ACM Symposium on Theory of Computing</title>
		<meeting>the Twenty First Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
			<biblScope unit="page" from="44" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Is quantum Bit Commitment Really Possible?</title>
		<author>
			<persName><forename type="first">H.-K</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Chau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review Letters</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="3410" to="3413" />
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Pseudorandomness and Cryptographic Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Mayers</surname></persName>
		</author>
		<ptr target="http://xxx.lanl.gov/abs/quant-ph/9603015" />
		<title level="m">The Trouble With Quantum Bit Commitment</title>
		<imprint>
			<date type="published" when="1996-03">March 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Quantum Key Distribution and String Oblivious Transfer in Noisy Channels</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mayers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology : CRYPTO &apos;96 : Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996-08">August 1996</date>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="343" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Unconditionally Secure Quantum Bit Commitment is Impossible</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mayers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review Letters</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="3414" to="3417" />
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Mayers</surname></persName>
		</author>
		<ptr target="http://xxx.lanl.gov/abs/quant-ph/9802025" />
		<title level="m">Unconditional Security in Quantum Cryptography</title>
		<imprint>
			<date type="published" when="1998-02">February 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Perfect Zero-Knowledge Arguments For NP Using Any One-Way Permutation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ventkatesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="87" to="108" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Quantum Bit Commitment From a Physical Assumption</title>
		<author>
			<persName><forename type="first">L</forename><surname>Salvail</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology : CRYPTO &apos;98 : Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998-08">August 1998</date>
			<biblScope unit="volume">1462</biblScope>
			<biblScope unit="page" from="338" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Algorithms for Quantum Computation: Discrete Logarithms and Factoring</title>
		<author>
			<persName><forename type="first">P</forename><surname>Shor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual IEEE Symposium on Foundations of Computer Science</title>
		<meeting>the 35th Annual IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="124" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Graaf</surname></persName>
		</author>
		<title level="m">Torwards a Formal Definition of Security for Quantum Protocols</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
		<respStmt>
			<orgName>Département d&apos;informatique et de recherche opérationelle, Université de Montréal</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Security of Quantum Protocols Against Coherent Measurements</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-seventh Annual ACM Symposium on Theory of Computing</title>
		<meeting>the Twenty-seventh Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1995-05">May 1995</date>
			<biblScope unit="page" from="67" to="75" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
