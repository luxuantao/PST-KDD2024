<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Defeating Memory Corruption Attacks via Pointer Taintedness Detection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shuo</forename><surname>Chen</surname></persName>
							<email>shuochen@crhc.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Center for Reliable and High-Performance Computing</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>1308 W. Main Street</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jun</forename><surname>Xu</surname></persName>
							<email>junxu@csc.ncsu.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">North Carolina State University Raleigh</orgName>
								<address>
									<postCode>27695</postCode>
									<region>NC</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nithin</forename><surname>Nakka</surname></persName>
							<email>nakka@crhc.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Center for Reliable and High-Performance Computing</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>1308 W. Main Street</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zbigniew</forename><surname>Kalbarczyk</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Reliable and High-Performance Computing</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>1308 W. Main Street</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ravishankar</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
							<email>iyer@crhc.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Center for Reliable and High-Performance Computing</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>1308 W. Main Street</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Defeating Memory Corruption Attacks via Pointer Taintedness Detection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">007A8229048F7717A239B66ADADE4AB1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Security</term>
					<term>Attack</term>
					<term>Vulnerability</term>
					<term>Taintedness</term>
					<term>Hardware Design</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Most malicious attacks compromise system security through memory corruption exploits. Recently proposed techniques attempt to defeat these attacks by protecting program control data. We have constructed a new class of attacks that can compromise network applications without tampering with any control data. These non-control data attacks represent a new challenge to system security. In this paper, we propose an architectural technique to defeat both control data and non-control data attacks based on the notion of pointer taintedness. A pointer is said to be tainted if user input can be used as the pointer value. A security attack is detected whenever a tainted value is dereferenced during program execution. The proposed architecture is implemented on the SimpleScalar processor simulator and is evaluated using synthetic programs as well as real-world network applications. Our technique can effectively detect both control data and noncontrol data attacks, and it offers better security coverage than current methods. The proposed architecture is transparent to existing programs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Most malicious attacks, viruses, and worms exploit lowlevel programming errors to compromise the security of target systems. Well-known examples include the Morris Worm that exploited a buffer overflow vulnerability in fingerd, the Code Red Worm that exploited a buffer overflow in Internet Information Service (IIS), and the format string attack against the WU-FTP daemon. A wide spectrum of programming errors allow attackers to mount memory corruption attacks, including buffer overflow, heap corruption (such as heap buffer overflow and double free), integer overflow, format string, and LibC globbing vulnerabilities. Our survey indicates that this type of vulnerability accounts for 67% of CERT advisories in the years 2000-2003 <ref type="bibr" target="#b7">[8]</ref>.</p><p>Several means have been proposed to defeat security attacks. Type-safe languages, compiler analyses, and formal methods have been adopted to prevent programmers from writing insecure software. But despite substantial research and investment, the state of the art is far from perfect, and as a result, security vulnerabilities are constantly being discovered in the field. The most direct counter-measure against vulnerabilities in the field is security patching. Patching, however, is reactive in nature and can only be applied to known vulnerabilities. The long latency between bug discovery and patching allows attackers to compromise many unpatched systems. An alternative to patching is runtime vulnerability masking that can stop ongoing attacks. Compiler and library interception techniques have been proposed to mask security bugs, usually by terminating a vulnerable application upon the detection of an attack. These techniques have been successful in defeating a number of specific types of attacks, in particular stack buffer overflow <ref type="bibr" target="#b4">[5]</ref> <ref type="bibr" target="#b10">[11]</ref> and format string attacks <ref type="bibr" target="#b5">[6]</ref>.</p><p>Recently, processor architecture mechanisms-noexecute page-protection (NX) processors developed by AMD and Intel <ref type="bibr" target="#b12">[13]</ref>, Secure Program Execution <ref type="bibr" target="#b17">[18]</ref>, and Minos <ref type="bibr" target="#b6">[7]</ref>-have been proposed to thwart most types of memory corruption attacks. The key assumption made in these proposals is that, in order to launch a successful memory corruption attack, the attacker must either change control data (code pointers) that are subsequently loaded into the processor's program counter register (PC), or execute malicious code supplied by attackers. Examples of control data include function pointers and return addresses. In this paper, we refer to these techniques as control-flow integrity based protections.</p><p>We examined a number of vulnerabilities in major network applications, and found that these applications can also be compromised by corrupting non-control data. Noncontrol data include integers representing user identity, server configuration strings, and pointers to user input data. We show that many non-control data attacks result in the same severity of security compromises as the control data attacks, usually the possession of root privileges. Since these attacks do not corrupt control data, existing architectural protection mechanisms are not able to detect the attacks. Hence, non-control data attacks represent a challenge to defeating memory corruption attacks. In this paper, we propose a processor architecture level technique that can defeat both control data and non-control data memory corruption attacks.</p><p>The basis of our technique is the notion of pointer taintedness, which we initially introduced in <ref type="bibr" target="#b9">[10]</ref> to formally reason about many types of memory vulnerabilities in software using a static program analysis technique. 1 A pointer is said to be tainted if the pointer value comes directly or indirectly from user input. A tainted pointer allows the user to specify the target memory address to read, write, or transfer control to, which can lead to system security compromise. The attacker's ability to specify a malicious pointer value is crucial to the success of memory corruption attacks.</p><p>We proposed in <ref type="bibr" target="#b9">[10]</ref> an extended memory model in which each memory location (and each register) is associated with a Boolean property taintedness to indicate whether the data in this location (and this register) are derived from user input. The same memory model is employed to implement the runtime defense mechanism discussed in this paper. Any data received from external sources are marked tainted. External data sources include network, file system, keyboard, command line arguments, and environmental variables. Load, store, and ALU instructions are responsible for propagating taintedness from register to register, memory to register, and register to memory. Anytime a data word that has tainted bytes is used for memory access or control flow transfer, an alert is raised and the application process is terminated.</p><p>The proposed architecture is transparent to the application, and thus existing applications can run without recompilation or relinking. For example, precompiled SPEC 2000 benchmark applications are able to run on the simulated architecture without generating any false alerts. This is an important advantage over compiler-based pointer protection methods, such as PointGuard <ref type="bibr" target="#b5">[6]</ref>, that need to statically identify all data variables that can be used as pointers. Accurate pointer type analysis has proven to be a hard problem in practice. The proposed architecture requires no source code access or compile-time type information. Our technique is prototyped as an enhanced SimpleScalar processor simulator <ref type="bibr" target="#b19">[20]</ref>.</p><p>Attacks that overwrite both control and non-control data against a number of real-world network applications are used to evaluate the effectiveness of the proposed defense technique. The accurate detection of all these attacks shows the strength of our approach and indicates a significant improvement in security coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Both static compiler analysis and runtime detection techniques have been developed to defeat memory 1 The notion of taintedness has been proposed in Perl and other previous literature such as <ref type="bibr" target="#b11">[12]</ref> and <ref type="bibr" target="#b20">[21]</ref>. Tainted data is defined as data coming from external input. The novelty of our work is to view the root cause of most memory corruption attacks to be tainted pointers. corruption attacks. Generic static techniques such as SPLINT <ref type="bibr" target="#b11">[12]</ref> and Extended Static Checking <ref type="bibr" target="#b8">[9]</ref> can check if the specified security properties are satisfied in program code. Domain-specific code analysis techniques are designed to uncover specific types of vulnerabilities, such as buffer overflow vulnerability <ref type="bibr" target="#b22">[23]</ref> and format string vulnerabilities <ref type="bibr" target="#b20">[21]</ref>. Although static code analysis techniques are helpful in finding security vulnerabilities, their scalability, analysis granularity and dependency on application-specific knowledge have lead to significant false positive and false negative rates. Runtime techniques defeat security attacks in the field. Earlier techniques provided protection against specific types of attacks. Representative techniques include StackGuard <ref type="bibr" target="#b10">[11]</ref> and Libsafe <ref type="bibr" target="#b4">[5]</ref> to defeat stack buffer overflow attacks, and FormatGuard <ref type="bibr" target="#b5">[6]</ref> to defeat format string attacks. Defensive techniques which randomize process memory layout to defeat security attacks are proposed <ref type="bibr" target="#b1">[2]</ref>[4] <ref type="bibr" target="#b23">[24]</ref>. Although the principle is generic against most memory corruption attacks, there are still barriers in the implementation and deployment. Randomizing the address of every object, especially objects in the static data segment, is a challenging issue that requires further research. In addition, the deployment of these techniques on 32-bit architectures has been shown to suffer from low entropy<ref type="foot" target="#foot_0">2</ref> -they cannot provide more than 16-20 bits of entropy, which is not sufficient to defeat brute-force attacks <ref type="bibr" target="#b18">[19]</ref>.</p><p>Advances in computer architecture research have resulted in a number of techniques that are considered generic against all types of memory corruption attacks. Secure Program Execution <ref type="bibr" target="#b17">[18]</ref> and Minos <ref type="bibr" target="#b6">[7]</ref> are techniques to protect control data integrity. While effective in defeating control data attacks, these techniques are unable to defeat non-control data attacks.</p><p>The notion of taintedness was first proposed in the Perl programming language as a security feature. Inspired by this, static detection techniques SPLINT <ref type="bibr" target="#b11">[12]</ref> and CQUAL <ref type="bibr" target="#b20">[21]</ref> apply taintedness analysis to guarantee that user input data is never used as the format string argument in printflike functions. In <ref type="bibr" target="#b9">[10]</ref>, we analyzed many categories of security vulnerabilities and concluded that their common root cause is the taintedness of pointers. A memory model and the algorithm used to detect pointer taintedness were initially provided in the paper as a rewriting logic framework to formally reason about security vulnerabilities in programs. Secure Program Execution <ref type="bibr" target="#b17">[18]</ref> and Minos <ref type="bibr" target="#b6">[7]</ref> techniques, which were proposed more recently, rely on the definitions of spuriousness and integrity of data. We believe these definitions bear certain similarities to taintedness. Their memory models and algorithms are also similar to what we proposed in <ref type="bibr" target="#b9">[10]</ref>. However, a fundamental difference is that they do not detect the taintedness of pointers in general, but only the taintedness of control data. They view control data taintedness as the result of memory corruptions, rather than the root cause of memory corruptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Pointer Taintedness Based Attacks</head><p>We analyze the 107 CERT advisories from 2000 through 2003. Figure <ref type="figure">1</ref> shows a breakdown of the leading programming vulnerabilities. Buffer overflow results from writing to an unchecked buffer; format string vulnerabilities result from incorrect invocations of printflike functions; integer overflow results from interpreting extremely large signed integers as negatives; heap corruption results from corruption of the heap structure or freeing a buffer twice; and globbing vulnerabilities result from an incorrect invocation of LibC function glob(). These categories collectively account for 67% of the advisories. Although attacks exploiting these different types of vulnerabilities have different appearances, we observe a common characteristic among them: the attack must first taint a pointer and then trick the victim program into dereferencing that pointer. The attacker's ability to specify a pointer value is a crucial requirement for the success of a memory corruption attack.</p><p>Figure <ref type="figure">2</ref> presents examples of stack buffer overflow attack, heap corruption attack, and format string attack, illustrating how pointer taintedness enables these attacks. Stack buffer overflow attack. Each function frame consists of the return address, the frame pointer, and the local stack variables of the function. Function exp1() defines a stack buffer buf with 10 bytes, which is located a few words before the return address and the frame pointer. The subsequent scanf() call can read an arbitrarily long input supplied by the user. When the user input data (i.e., tainted data) overrun the buffer buf, the memory locations of the frame pointer and the return address are tainted by the input data (shown as the grey area). The tainted return address is used when function exp1() returns. The control flow of the program is therefore diverted to an attackerspecified location, usually the entry of malicious code the attacker wants to execute. More details about stack buffer overflow attacks can be found in <ref type="bibr" target="#b0">[1]</ref>. Programming errors, such as heap buffer overflow and double free, allow malicious users to corrupt the forward and backward links (i.e., pointers) in this list. In function exp2(), the buffer buf with 8 bytes is allocated on the heap, followed by a free memory chunk (chunk B). The beginning few bytes of each free chunk are used as the forward link (fd) and the backward link (bk) of the doublelinked list. In this case, since free chunks A, B, and C are in the list: B-&gt;fd=A, B-&gt;bk=C. The scanf() call allows an attacker to overflow buf, causing B-&gt;fd and B-&gt;bk to be tainted. When buf is to be freed later, memory chunk B is taken out of the doubly linked list, during which the assignment B-&gt;fd-&gt;bk=B-&gt;bk is executed. Since both B-&gt;fd and B-&gt;bk are tainted pointers, the attacker can write an arbitrary word to an arbitrary memory location. Traditionally, the attacker exploits this vulnerability to overwrite control data, such as return addresses, function pointers, and GOT entries<ref type="foot" target="#foot_1">3</ref> in order to execute malicious binaries supplied by the attacker. A more detailed explanation of heap corruption attacks can be found in <ref type="bibr" target="#b2">[3]</ref>.</p><p>Format string attack. Format string attacks exploit the vulnerabilities caused by incorrect invocations of printflike functions, such as printf, sprintf, and syslog. Function exp3() contains such a vulnerability where the user input buffer buf is used as the first argument of printf, although the correct invocation should be printf("%s",buf). Because buf is filled in the recv() call, the data in buf are tainted. For example, an attacker can send a string abcd%x%x%x%n to overwrite the memory location 0x64636261, corresponding to the leading four bytes of the input string "abcd". The internal mechanism of the format string attack is as follows: vfprintf() is a child function of printf(), which has two pointers: fmt is the format string pointer to sweep over the format string (buf in our example), and ap is the argument pointer to scan through the argument list corresponding to the format directives (e.g., %x, %d and %n). When fmt points to the format directive %n, an integer count is written to the location pointed by *ap, i.e., *ap=count. The attacker embeds %x directives in order to precisely move pointers ap and fmt so that when fmt points to %n, ap happens to move into the tainted region, pointing to the word 0x64636261. Therefore, the statement *ap=count is effectively *0x64636261=count, allowing the attacker to specify an arbitrary location to write. The root cause of the attack, again, is the pointer taintedness: 0x64636261 is a tainted word that is dereferenced as a pointer. The format string attack is also explained in a publicly available article <ref type="bibr" target="#b21">[22]</ref>.</p><p>The above examples show that pointer taintedness is a common root cause of many memory corruption attacks. This suggests an opportunity for defeating such attacks: preventing tainted data from being dereferenced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Architectural Support for Pointer Taintedness Detection</head><p>This section presents the design and implementation of the architecture for pointer taintedness detection. Briefly, we extend the existing memory system by adding an additional taintedness bit to each byte, in order to implement the memory model we proposed in <ref type="bibr" target="#b9">[10]</ref>. The taintedness bit is set whenever data from input devices is copied into the memory. Within the processor execution engine, the taintedness bit is propagated when tainted data are used for an operation. Whenever a tainted word is used as an address value for memory access (data or code accesses), an exception is raised by the processor. The operating system then handles the exception and stops the current process to defeat the ongoing attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Extended Memory Architecture</head><p>The memory system architecture is extended to support the notion of taintedness. A taintedness bit is associated with each byte in memory. When a memory word is accessed by the processor, the taintedness bits are passed through the memory hierarchy together with the actual memory words. L2 and L1 caches and data storage within the processor (registers and buffers) are also extended with the additional taintedness bits.</p><p>The detection mechanism is designed on top of the extended memory model. Although the underlying principle is general enough to be applicable to other architectures, the discussion is given in the context of SimpleScalar RISC architecture. Figure <ref type="figure" target="#fig_0">3</ref> gives the enhancements of the pointer taintedness detection mechanism implemented as extensions of SimpleScalar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Taintedness Tracking</head><p>When a program performs operations using its data from memory, the taintedness bit should be propagated. The processor pipeline is modified to track taintedness. In general, any CPU operation that uses tainted data as source should produce tainted result. This mechanism is similar to the ones proposed in <ref type="bibr" target="#b6">[7]</ref> and <ref type="bibr" target="#b17">[18]</ref>.</p><p>We distinguish between memory operations and ALU operations. A memory load operation moves data from memory to processor register, and a store operation moves data from processor register to memory. Corresponding to the one-bit extension to each memory byte, the processor registers are also extended to include one taintedness bit for each byte. For each load instruction, the data bits as well as the taintedness bits are copied from memory to register along the load path. Similarly, store instructions write normal data bytes as well as taintedness bits to the memory along the store path.</p><p>Register File  ALU instructions are responsible for propagating taintedness between registers. The propagation is implemented by the ALU taintedness tracking logic (shown as a shaded area in Figure <ref type="figure" target="#fig_0">3</ref>). With the few exceptions noted below, the ALU taintedness works as follows: for operations with two source operands, the taintedness bits of a resultant register are obtained by the bitwise OR of the corresponding taintedness bits in the source operand registers. For example, after executing ADD R1,R2,R3, R1 is tainted if and only if R2 is tainted or R3 is tainted.</p><p>The following exceptional cases require special handling. (1) Shift instructions cause taintedness to propagate within the operand register. If a byte in the operand register is tainted, then the taintedness bit of its adjacent byte along the direction of shifting is set to 1. (2) The taintedness bits of any byte AND-ed with an untainted zero are cleared, because the resulting byte value is constant 0, regardless of user input. (3) The compiler idiom XOR R1,R2,R2 is frequently used to assign constant 0 to the target register R1. The taintedness bits in R1 are cleared as a result. This idea is borrowed from previous techniques <ref type="bibr" target="#b6">[7]</ref> and <ref type="bibr" target="#b17">[18]</ref>. (4) Compare instructions are used for data range checking. If a tainted register R1 is compared with some untainted data in R2, the taintedness bits in R1 are cleared after the operation. The rationale is that programmers often write input validation code to check certain safety properties. The validation code is in the form of compare instructions. For application compatibility, any data that undergoes validation is trusted after such an operation. This could potentially lead to missed detection (a.k.a. false negatives). For example, in situations in which the program does check user input values but the check algorithm is flawed. The false negative scenarios are discussed in Section 5.3.</p><p>Table <ref type="table" target="#tab_3">1</ref> summarizes the taintedness tracking logic. The ALU taintedness tracking logic consists of a multiplexer (MUX) selecting from four sources of input based on the opcode of the current instruction. These multiplexer inputs correspond to the five types of ALU instructions listed above. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Shift instruction</head><p>If a byte in the operand is tainted, the taintedness bit of its adjacent byte along the direction of shifting is set to 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AND instruction</head><p>Untaint each byte AND-ed with an untainted zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XOR R1,R2,R2</head><p>Taintedness of R1 = 0000.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compare instruction</head><p>Untaint every byte in the operands of the compare instruction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Attack Detection</head><p>In general, whenever a tainted data value is used for memory access, an alert should be raised. The proposed detection mechanism is described using the instruction set architecture of the SimpleScalar processor simulator. In SimpleScalar, only the load/store instructions and the jump instruction JR (i.e., jump to the address in a register) can dereference a pointer, which is stored in a register. The jump pointer taintedness detector is placed after the ID/EX (instruction decode/execution) stage when the jump target register value is available. The four taintedness bits in the target register are OR-ed. If any byte in the word is tainted, the output of the OR-gate is 1 and the instruction is marked as malicious. The detector of tainted pointers for load/store instructions is placed after the EX/MEM (execute/memory) stage; here the four taintedness bits of the address word are inputted into an OR-gate, and the instruction is marked as malicious if the output of the gate is 1 and the instruction opcode is load or store. The actual security exception is raised in the pipeline's retirement stage. Retirement of an instruction marked as malicious causes the pipeline to raise a security exception. The operating system can then terminate the process and stop the ongoing intrusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Taintedness Initialization</head><p>Any data received from an external device that can potentially be controlled by a malicious user are considered tainted, e.g., input coming from network, file system, keyboard, command line arguments, and environmental variables. All such data are passed from an external source to the program buffer through operating system calls. The system call implementations are modified to mark every byte in the buffer as tainted when it is returning from kernel space to user space. This can be implemented by adding every word in the buffer to a special register RT. The value of RT is always 0, but every taintedness bit of RT is 1. In the current implementation, we modify the system call module of the SimpleScalar simulator for this purpose. In particular, all data delivered to the application through the SYS_READ (local I/O) and SYS_RECV (network I/O) are marked as tainted. These two system calls are invoked by most input functions in C library, such as scanf(), fread(), recv(), and recvfrom().</p><p>In summary, three subsystems in the SimpleScalar simulator are modified to implement the algorithm: (1) The memory subsystem is extended with the taintedness bits in the memory, the cache, and the register file. (2) The original system call implementation is modified so that SYS_READ and SYS_RECV mark every byte in the receiving buffer as tainted. (3) The instruction pipeline is extended to implement taintedness calculation, propagation, and detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Evaluation</head><p>The proposed architecture has the following properties:</p><p>(1) high coverage in detecting attacks tampering with both control and non-control data; (2) transparency to applications, i.e., the detection does not rely on any internal knowledge on the applications, e.g., buffer sizes, variable upper bounds, or program semantics; (3) no known false positives; and (4) very small space overhead and performance overhead. These properties are evaluated by running synthetic programs, real network applications, and SPEC benchmarks on the proposed architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Security Protection Coverage</head><p>The pointer taintedness detection technique provides a significant improvement in security coverage by protecting applications from both control data attacks and non-control data attacks. The security coverage of existing control-flow integrity based protections was evaluated against control data attacks only. This section shows that non-control data attacks do exist and can cause the same level of security compromise in many real applications. For a fair comparison, we employ several applications that were previously used to assess the existing techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1.">Synthetic Vulnerable Programs</head><p>The effectiveness of the proposed approach is first demonstrated on a number of synthetic functions that are vulnerable to stack buffer overflow, heap corruption, and format string attacks respectively. These functions and attacks were illustrated earlier in Figure <ref type="figure">2</ref>.</p><p>Detection of stack buffer overflow. When a string of "a" characters of 24 bytes is passed to exp1() running on our architecture, an alert is raised at the return instruction (i.e., JR $31 on SimpleScalar) of exp1(), which indicates that the return address is tainted as 0x61616161, corresponding to four "a" characters in the input.</p><p>Detection of heap corruption. Function exp2() contains a heap overflow vulnerability. An attack is launched by inputting 12 "a" characters to the 8-byte buffer. When the buffer is freed, a load-word instruction LW $3,0($3), which is in function free(), raises an alert. As described in Section 3, a statement executed in free() is B-&gt;fd-&gt;bk=B-&gt;bk. When the alert is generated, register $3 equals B-&gt;fd, which is a tainted word 0x61616161 due to the buffer overflow condition. Because the detected instruction attempts to dereference register $3 (i.e., the 0($3) indirect addressing mode) when its value is tainted, the alert is raised.</p><p>Detection of format string attack. The effectiveness of detecting format string attacks is demonstrated by function exp3(). The function receives the string abcd%x%x%x%n from the socket. When printf() is called, a store-word instruction SW $21,0($3) in vfprintf() raises an alert. This store instruction is compiled from the statement *ap=count described in Section 3, where the value of ap is in register $3 and the value of count is in register $21. When the alert is raised, the value of register $3 in 0($3) dereference is 0x64636261, corresponding to the first four bytes of the input string, "abcd".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2.">Real-World Network Applications</head><p>The three examples discussed in the previous section demonstrate that pointer taintedness detection can defeat many types of memory corruption attacks. This section presents results from testing real-world attacks against network applications running on the SimpleScalar augmented with pointer taintedness detection capability. In addition, the SimpleScalar processor simulator is extended to support network socket applications. The enhancement allows us to run many real-world network server applications. Both control data attacks and non-control data attacks are used for the evaluations. The pointer taintedness detection technique succeeds in defeating both types of attacks.</p><p>WU-FTPD format string attack. Washington University FTP Daemon (WU-FTPD) is one of the most widely used FTP servers. The Site Exec Command Format String Vulnerability <ref type="bibr" target="#b13">[14]</ref> is a vulnerability in WU-FTPD allowing attackers to overwrite an arbitrary memory location. <ref type="foot" target="#foot_2">4</ref> We constructed a non-control data attack, in which the format string vulnerability is exploited to overwrite an integer word representing the ID of the login user. This is sufficient to escalate the attacker's privilege to the root privilege, offering the attacker a full control on the file /etc/passwd so that he/she can upload a different version of this file. After writing a malicious entry such as "alice:x:0:0::/home/root:/bin/bash" in the new version, the attacker leaves a backdoor to login later as Alice, who possesses root privileges. Since the attack does not corrupt any control data, it is not detectable by existing techniques.</p><p>WU-FTPD runs on the proposed architecture. Table <ref type="table" target="#tab_4">2</ref> shows the attack/detection steps. When the FTP server is ready to accept user input, the attacker (the FTP client) first authenticates to the server using USER and PASS commands, then issues a SITE EXEC command to exploit the vulnerability. The target integer word representing the user ID is located in the address 0x1002bc20, so the command used to overwrite this word is:</p><p>site exec \x20\xbc\x02\x10%x%x%x%x%x%x%n Immediately after the attack sends the malicious SITE EXEC command, the pointer taintedness detector raises an alert indicating that the instruction SW $21,0($3) dereferences a tainted value in register $3. The value of the register is 0x1002bc20, the same as the one specified by the attacker as the target address to overwrite. The FTP server is stopped when the alert is raised, which effectively prevents the attack from succeeding. NULL HTTPD heap corruption attack. Null HTTPD is a multithreaded web server for Linux. A heap overflow vulnerability has been reported in this application <ref type="bibr" target="#b13">[14]</ref>. This vulnerability is triggered when an attacker sends a POST command with a negative Content-Length field in its HTTP header. Due to misinterpretation of the negative number, the size of a heap buffer is incorrectly calculated, resulting in the possibility of a buffer overflow attack. <ref type="foot" target="#foot_3">5</ref>Known attack programs overwrite control data when the overflowed heap buffer is freed, hijacking the control flow of the HTTP server. We found an effective non-control data attack that only corrupts the CGI-BIN path configuration. In HTTP servers with CGI (Common Gateway Interface) support, a CGI-BIN path specifies the root directory of executables that are allowed to be run through HTTP requests. The attack overwrites this path configuration to "/bin" so that the command shell executable /bin/sh can be started by the attacker with root privileges on the server. Thus, the attacker gets a completely unrestricted command shell. This attack is undetectable by the control data protection techniques because only CGI-BIN is a plain-text string.</p><p>In our experiment, the server runs on the proposed architecture. A hypothetical attacker attempts to overwrite CGI-BIN configuration by tainting the heap doubly linked list. Our architecture raises an alert when function free() is being invoked, because register $3 is tainted when an instruction LW $3,0($3) inside free() is about to run. GHTTPD stack overflow attack. Another HTTP server, GHTTPD, has a stack buffer overflow vulnerability in its logging function <ref type="bibr" target="#b15">[16]</ref>. The vulnerable function contains a 200-byte stack buffer, which is used to accommodate the HTTP request received from the client. A traditional way to attack is to send an HTTP request longer than 200 bytes, overwriting the return address following the buffer in order to run malicious code embedded in the HTTP request.</p><p>We constructed a non-control data attack by corrupting a pointer to the URL in the HTTP request. A security policy of the HTTP protocol requires any URL containing a substring "/.." be rejected, to prevent users from accessing files outside the predefined HTML and CGI root directories. We exploit the vulnerability to change the URL pointer to point to an illegitimate URL string containing "/.." after the policy is checked.</p><p>GHTTPD runs on the proposed architecture while the devised attack is launched. When the server is ready, a malicious request GET AAAAAAA….AAAAAAAA \x94\x3e\xff\x7f↵↵/cgi-bin/../../../../bin/sh is sent to the server. The first part of the request AAAAAAA…AAAAAA \x94\x3e\xff\x7f is parsed as a URL. However, due to the buffer overflow vulnerability, the last four bytes overwrite the pointer of the URL to 0x7fff3e94, which is the address of the second part of the string, /cgi-bin/../../../../bin/sh. Without the protection provided by our architecture, this would force the server to run /bin/sh with root privileges. Our mechanism effectively stops the attack when the tainted URL pointer is dereferenced in a load-byte instruction (i.e., LB).</p><p>Traceroute double free attack. Certain versions of LBNL traceroute are vulnerable to an attack involving free()-ing of a heap buffer not allocated by malloc() <ref type="bibr" target="#b16">[17]</ref>. When traceroute is executed with the arguments "-g x -g y", savestr() is called twice to parse arguments "-g x" and "-g y". Savestr() reduces calls to malloc() by preallocating heap space and performs self buffer management when it is invoked subsequently. After "-g x" is parsed and savestr() is called, the pointer to the block used by savestr() is released using free(). When "-g y" is interpreted, savestr() is called again, and the result is written to the block of already freed memory. Like for "-g x", free() is called, but this time on a region that has already been released in the first free() call. Traceroute crashes because free() is using an invalid pointer in an invalid malloc() header. A malicious user can take over traceroute using the double free attack method: it corrupts pointers used by malloc/free, then forces traceroute to overwrite critical program data or execute malicious code.</p><p>In our experiment, we use the command line traceroute -g 123 -g 5.6.7.8. Without our detection mechanism, this results in a successful takeover. Due to our detection mechanism, an alert is generated at a store-word instruction inside free() because 0x333231 is a tainted value when it is dereferenced as a pointer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Evaluation of False Positives</head><p>Along with system security, a crucial criterion of defensive systems is the false positive rate, i.e., the likelihood that the system raises an alert when there is no attack.</p><p>The network applications discussed in Section 5.1 run smoothly on the proposed architecture without generating any alert when there is no attack. In order to more thoroughly evaluate the false positive rate of the architecture on real applications, we run six integer applications from SPEC 2000, of which only their binary executables are available. These applications are BZIP2, GCC, GZIP, MCF, PARSER and VPR, and the default test cases are provided by SPEC 2000. Since none of the test cases is a malicious attack, no alert should be generated during the execution of these programs. Table <ref type="table" target="#tab_5">3</ref> shows the results of this test: the total size of these programs is 6586KB, the total number of input bytes during the execution of the benchmarks is 2186KB, and the total number of instructions executed is 15,139 million. During the execution of these programs, not a single alert is raised. This experiment is a good indicators that one can expect very few (or even no) false positive when the proposed technique is deployed in real systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">False Negative Scenarios</head><p>False negative scenarios of a defensive technique are the situations where an attack escapes detection. Although pointer taintedness architecture detects a larger set of memory corruption attacks than existing control-flow integrity based protections, it does not provide 100% security coverage. This section shows some synthetic cases where certain degree of damage can be done to the system running on top of the proposed architecture.</p><p>Integer overflow attacks resulting in an out-ofboundary array index. Integer overflow is often due to a programmer's misinterpretations of signed, unsigned, long and short integers. When a programmer converts integers between these types, the resulting values can be inconsistent with the programmer's expectations. Table <ref type="table" target="#tab_6">4</ref>(A) shows a vulnerable function where an unsigned integer ui is assigned to a signed integer i. Lines 2 and 3 perform an array index boundary check to ensure that i does not exceed the array size. This comparison statement untaints i because it has been boundary checked. However, an attacker can input a very large unsigned integer ui to the function. When ui is assigned to the signed integer i, i becomes negative. Line 4 uses i as the array index, allowing the attacker to overwrite any memory address lower than the address of array. Neither our technique nor the existing control data protection techniques stop integer overflow attacks from corrupting memory. The integer overflow vulnerability differs from other memory corruption vulnerabilities because the integer value is intended to be the array index, while in other vulnerabilities, the values being dereferenced are not supposed to be pointer values: they can be embedded in FTP command, HTTP request, and IP address. To defeat the attack, the bound check must be implemented correctly. Unfortunately, it is very difficult, if not impossible, on the hardware level, to transparently perform the check without knowledge of application semantics. Buffer overflow attacks corrupting critical flags. Table <ref type="table" target="#tab_6">4</ref>(B) depicts user authentication functionality, where a flag auth is defined to indicate whether a user is authenticated. After Line 3 sets this flag by calling do_auth(), the buffer overflow vulnerability in Line 4 can be exploited to overwrite the authenticated flag to 1. Line 5 grants access to the user according to the auth flag, and therefore an attacker can get the access without successful authentication. This attack cannot be detected by our technique, as the attack simply overflows a buffer to corrupt an integer following it, and no pointer tainted during the attack. shows that such a vulnerability could allow the attacker to get private information from memory data regions such as the stack. Function leak() defines an integer secret_key on the stack. A user input buffer buf is passed to printf() as the format argument. We have shown that if the attacker sends abcd%x%x%x%n to the buffer, an alert is raised because the %n directive attempts to dereference a tainted pointer. However, if the input is %x%x%x%x, the attacker can read the top four words on the stack, including the secret_key. Such an information leak attack can be used for future security compromises not based on memory corruptions, for example, attacks to steal user passwords and secret random seeds.</p><p>Despite these false negative scenarios, the technique proposed in this paper substantially improves security coverage because (1) we can effectively defeat most attacks corrupting both control data and non-control data, (2) the false negative scenarios are in general not defeatable by any generic runtime detection technique that we are aware of, and (3) the false negative scenarios are rare in the real world.</p><p>Effectively exploiting buffer overflow vulnerabilities without corrupting any pointer is also challenging for attackers, because only a limited number of words following the buffer can be overwritten. For stack overflow, the critical flag must be in the same frame as the buffer being overrun. For heap overflow, this limit is guarded by the locations of the free-chunk links following the buffer. Once the overflowed data exceeds the limit, our technique raises an alert because the return address or the links are tainted. Our technique cannot prevent information leak damage in format string attacks, but we expect their severity to be much lower than for memory corruptions.</p><p>One direction that can potentially reduce the false negative rate is to sacrifice the transparency of the proposed taintedness detection architecture. We can ask the programmer to annotate important data structures that should never be tainted. The annotated data can then be monitored by our architecture. Then, whenever an annotated structure becomes tainted, an alert is raised.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Architectural Overhead</head><p>Area overhead. The proposed method will incur some area overhead in a microprocessor and in the overall memory system. Within the processor, the data path between pipeline stages needs to be expanded to accommodate the taintedness bit for each byte of data. The internal physical registers, buffers, and other data structures should be expanded, as should the data bus between the processor, caches, and physical memory banks. Physical memory banks should also increase in width to accommodate the taintedness bit.</p><p>Performance overhead. The proposed detection mechanism should not cause slowdown or longer cycle time in the pipeline of a modern processor. This is because the propagation of the taintedness bits through load, store, and ALU operations are not on the critical path of these operations. For example, in executing add r1, r2, r3, the taintedness tracking algorithm need only perform a logic OR operation, which can be carried out in parallel with the add operation. In fact, the logic OR operation takes less time than the add operation to complete, so the taintedness tracking algorithm will not increase clock cycle time for the ALU pipeline stage. For load and store operations, the taintedness bit is directly copied from source to destination and therefore can be performed at wire speed. At the retirement stage, the processor checks whether a memory access (load/store or control flow transfer instructions) uses tainted address values, which is a single bit operation. Again, the checking is simpler than the normal operations required for instruction retirement. Based this analysis, we believe that the operations for the pointer taintedness algorithm do not add pipeline stages or increase cycle time.</p><p>Software processing overhead. The operating system kernel requires changes. In particular, the kernel should mark data originating from input system calls as tainted. This can be done before the operating system passes such data back to user space. If we assume that tainting a byte requires an additional instruction, the percentage of additional instructions executed by a SPEC benchmark program is between 0.002% and 0.2% based on the data in Table <ref type="table" target="#tab_5">3</ref>. Since our current prototype is based on a processor simulator, the discussed operating system enhancement is implemented via system call interception. Actual modification of the operating system requires further investigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>The majority of security vulnerabilities are due to lowlevel programming errors that allow attackers to corrupt memory. Protections based on control-flow integrity have recently been developed to defeat most memory corruption attacks. These techniques are based on the assumption that a successful memory corruption attack usually requires corrupting control data. We found a number of non-control data attacks that can compromise the security of major network applications. These attacks cannot be detected by existing techniques.</p><p>This paper proposes a protection technique to defeat both control data and non-control data attacks. We observe that tainting a pointer is a critical step in memory corruption attacks. Accordingly, we have developed a pointer taintedness detection architecture to defeat most memory corruption attacks. We present the hardware design of the proposed technique, and implement a prototype in the SimpleScalar processor simulator. Based on an extensive evaluation using both synthetic and realworld network applications, and the SPEC benchmarks, we conclude the following: The proposed architecture provides a substantial improvement in security coverage; a near-zero false positive rate can be expected when the architecture is deployed; despite some synthetic false negative scenarios, running programs on the proposed architecture minimizes the chances of a successful attack; the incurred architectural overhead is likely to be low; and the approach is transparent to existing applications, i.e., applications can run without recompilation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Architecture Design of Pointer Taintedness Tracking and Detection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Free memory chunks are organized by the heap manager as a doubly linked list.</figDesc><table><row><cell cols="2">Stack Buffer Overflow void exp1() {</cell><cell></cell><cell cols="3">Low address</cell><cell></cell><cell></cell><cell cols="2">Stack grows</cell><cell></cell><cell cols="2">High address</cell><cell></cell><cell></cell></row><row><cell>}</cell><cell>char buf[10]; scanf("%s",buf);</cell><cell></cell><cell></cell><cell></cell><cell cols="2">buffer buf 10 bytes</cell><cell>…</cell><cell>Frame pointer</cell><cell>Return addr.</cell><cell>…</cell><cell></cell><cell></cell><cell cols="2">Tainted Data</cell></row><row><cell cols="2">Heap Corruption Attack void exp2() {</cell><cell cols="2">Low address</cell><cell></cell><cell></cell><cell>p</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">High address</cell></row><row><cell></cell><cell>char * buf;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>}</cell><cell>buf = malloc(8); scanf("%s",buffer); free(p)</cell><cell>Forward link</cell><cell>Backward link</cell><cell>Free Chunk A</cell><cell>…</cell><cell cols="2">Allocated buffer buf 8 bytes</cell><cell>…</cell><cell>Forward link</cell><cell>Backward link</cell><cell>Free Chunk B</cell><cell>…</cell><cell>Forward link</cell><cell>Backward link</cell><cell>Free Chunk C</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Tainted Data</cell><cell></cell><cell cols="3">unallocated space</cell><cell></cell><cell cols="4">Tainted unallocated space</cell></row><row><cell cols="2">Format String Attack void exp3(int s) { recv(s,buf,100,0); printf(buf); } char buf[100];</cell><cell></cell><cell cols="2">Low address</cell><cell>…</cell><cell>0x64636261</cell><cell cols="5">Stack grows %x %x %x %n High address …</cell><cell></cell><cell cols="3">User input abcd%x%x%x%n</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">initial ap</cell><cell></cell><cell>ap</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Tainted Data</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">initial fmt</cell><cell></cell><cell></cell><cell cols="2">fmt</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>Figure 2: Examples of Stack Buffer Overflow, Heap Corruption and Format String Attacks Heap corruption attack.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Taintedness Propagation by ALU Instructions</figDesc><table><row><cell>ALU Instruction Type</cell><cell>Taintedness Propagation</cell></row><row><cell>ALU instructions except shift,</cell><cell>Tainedness of R1 =</cell></row><row><cell>compare, and AND, e.g., op</cell><cell>(Taintedness of R2) or</cell></row><row><cell>R1,R2,R3</cell><cell>(Taintedness of R3).</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Attacking WU-FTPD on the Proposed Architecture</figDesc><table><row><cell>FTP Server</cell><cell cols="2">220 FTP server (Version wu-2.6.0(60) Mon Nov 29</cell></row><row><cell></cell><cell>10:37:55 CST 2004) ready.</cell><cell></cell></row><row><cell>FTP Client</cell><cell>user user1</cell><cell></cell></row><row><cell>FTP Server</cell><cell cols="2">331 Password required for user1 .</cell></row><row><cell>FTP Client</cell><cell cols="2">pass xxxxxxx (the correct password of user1)</cell></row><row><cell>FTP Client</cell><cell cols="2">site exec \x20\xbc\x02\x10%x%x%x%x%x%x%n</cell></row><row><cell>Alert</cell><cell>44d7b0: sw $21,0($3)</cell><cell>$3=0x1002bc20</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Test False Positive Rate Using SPEC 2000 Benchmark Programs</figDesc><table><row><cell></cell><cell>BZIP2</cell><cell>GCC</cell><cell>GZIP</cell><cell>MCF</cell><cell>PARSER</cell><cell>VPR</cell><cell>Total</cell></row><row><cell>Program size</cell><cell>321KB</cell><cell>4184KB</cell><cell>485KB</cell><cell>304KB</cell><cell>595KB</cell><cell>697KB</cell><cell>6586KB</cell></row><row><cell>Total number of input bytes</cell><cell>1048KB</cell><cell>77.7K</cell><cell>282KB</cell><cell>39.2KB</cell><cell>743.0KB</cell><cell>6.4KB</cell><cell>2186KB</cell></row><row><cell>Total number of instructions</cell><cell>5,951M</cell><cell>110M</cell><cell>6,926M</cell><cell>1,653M</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>False Negative Scenarios</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Format string attacks causing information leaks.</head><label></label><figDesc>Although our technique prevents the attacker from overwriting data through a format string attack, Table4(C)</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>In this context, the term entropy means the randomness of the address of each program element. Higher entropy implies that an attacker has more difficulty guessing the correct memory layout.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The GOT entry is a function pointer. Usually, in position-independent code, e.g., shared libraries, all absolute symbols must be located in the GOT, leaving the code position-independent. A GOT lookup is performed to decide the callee's entry when a library function is called.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>This vulnerability (with this application) was also chosen in assessing Secure Program Execution and Minos, where the control data attack published in<ref type="bibr" target="#b13">[14]</ref> was used to test the security coverage.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>This vulnerability (with this application) was chosen in assessing the Secure Program Execution technique.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work is supported in part by a grant from Motorola Inc. as part of Motorola Center for Communications, in part by NSF ACI CNS-0406351, and in part by MURI Grant N00014-01-1-0576. We thank Fran Baker for her careful reading of an early draft of this manuscript.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Smashing the Stack for Fun and Profit</title>
		<author>
			<persName><forename type="first">Aleph</forename><surname>One</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="1996-11">Nov. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">PaX Address Space Layout Randomization (ASLR)</title>
		<ptr target="http://pax.grsecurity.net/docs/aslr.txt" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Once upon a free(</title>
		<author>
			<persName><surname>Anonymous</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Address Obfuscation: An Efficient Approach to Combat a Broad Range of Memory Error Exploits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bhatkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Duvarney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Security Symposium</title>
		<meeting><address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-08">August 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Transparent Run-Time Defense Against Stack Smashing Attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Baratloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Annual Technical Conference</title>
		<meeting>USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">FormatGuard: Automatic Protection From printf Format String Vulnerabilities</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kroah-Hartman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10 th USENIX Security Symposium</title>
		<meeting><address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-08">August 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Control Data Attack Prevention Orthogonal to Memory Model</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Crandall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">T</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName><surname>Minos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture</title>
		<meeting><address><addrLine>Portland, Oregon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-12">December 2004</date>
		</imprint>
	</monogr>
	<note>To appear in the 37th</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Cert</forename><surname>Cc</surname></persName>
		</author>
		<ptr target="http://www.cert.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Improving Computer Security Using Extended Static Checking</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chess</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Formal Reasoning of Various Categories of Widely Exploited Security Vulnerabilities Using Pointer Taintedness Semantics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pattabiraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19 th IFIP International Information Security Conference</title>
		<meeting><address><addrLine>SEC; Toulouse, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-08-23">2004. August 23-26, 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic Detection and Prevention of Buffer-Overflow Attacks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th USENIX Security Symposium</title>
		<meeting><address><addrLine>San Antonio, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-01">January 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Improving Security Using Extensible Lightweight Static Analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Larochelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Software</title>
		<imprint>
			<date type="published" when="2002-02">Jan/Feb 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Changes to Functionality in Microsoft Windows XP Service Pack 2 (Part 3: Memory Protection Technologies)</title>
		<author>
			<persName><forename type="first">Microsoft</forename><surname>Technet</surname></persName>
		</author>
		<ptr target="http://www.microsoft.com/technet/prodtechnol/winxppro/maintain/sp2mempr.mspx" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Wu-Ftpd Remote Format String Stack Overwrite Vulnerability</title>
		<ptr target="http://www.securityfocus.com/bid/1387" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Null HTTPd Remote Heap Overflow Vulnerability</title>
		<ptr target="http://www.securityfocus.com/bid/5774" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Function Buffer Overflow Vulnerability</title>
		<ptr target="http://www.securityfocus.com/bid/5960" />
		<imprint/>
	</monogr>
	<note>Ghttpd Log(</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">LBNL Traceroute Heap Corruption Vulnerability</title>
		<ptr target="http://www.securityfocus.com/bid/1739" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Secure Program Execution via Dynamic Information Flow Tracking</title>
		<author>
			<persName><forename type="first">G</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting><address><addrLine>Boston, Massachusetts</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-10">October 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the Effectiveness of Address Space Randomization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer and Communications Security (CCS)</title>
		<meeting><address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-10">Oct. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<title level="m">The SimpleScalar Tool Set, Version 2.0</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Detecting Format String Vulnerabilities with Type Qualifiers</title>
		<author>
			<persName><forename type="first">U</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Talwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10 th USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Format String Attacks</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Newsham</surname></persName>
		</author>
		<ptr target="http://muse.linuxmafia.org/lost+found/format-string-attacks.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A First Step Towards Automated Detection of Buffer Overrun Vulnerabilities</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed System Security Symposium</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Transparent Runtime Randomization for Security</title>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 22nd Symposium on Reliable and Distributed Systems (SRDS)</title>
		<meeting>of 22nd Symposium on Reliable and Distributed Systems (SRDS)<address><addrLine>Florence, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06-08">Oct. 6-8, 2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
