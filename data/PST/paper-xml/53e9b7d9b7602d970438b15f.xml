<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">From Design to Analysis Models: a Kernel Language for Performance and Reliability Analysis of Component-based Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Vincenzo</forename><surname>Grassi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Università di Roma &quot;Tor Vergata&quot;</orgName>
								<address>
									<postCode>00133</postCode>
									<settlement>Roma</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Raffaela</forename><surname>Mirandola</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Università di Roma &quot;Tor Vergata&quot;</orgName>
								<address>
									<postCode>00133</postCode>
									<settlement>Roma</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Antonino</forename><surname>Sabetta</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Università di Roma &quot;Tor Vergata&quot;</orgName>
								<address>
									<postCode>00133</postCode>
									<settlement>Roma</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">From Design to Analysis Models: a Kernel Language for Performance and Reliability Analysis of Component-based Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5003E78FE66C048BEB401FB5356391C3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>To facilitate the use of non-functional analysis results in the selection and assembly of components for component-based systems, automatic prediction tools should be devised, to predict some overall quality attribute of the application without requiring extensive knowledge of analysis methodologies to the application designer. To achieve this goal, a key idea is to define a model transformation that takes as input some "design-oriented" model of the component assembly and produces as a result an "analysis-oriented" model that lends itself to the application of some analysis methodology. However, to actually devise such a transformation, we must face both the heterogeneous design level notations for component-based systems, and the variety of nonfunctional attributes and related analysis methodologies we could be interested in. In this perspective, we define a kernel language whose aim is to capture the relevant information for the analysis of non-functional attributes of component-based systems, with a focus on performance and reliability. Using this kernel language as a bridge between design-oriented and analysis-oriented notations we reduce the burden of defining a variety of direct transformations from the former to the latter to the less complex problem of defining transformations to/from the kernel language. The proposed kernel language is defined within the MOF (Meta-Object Facility) framework, to allow the exploitation of MOFbased model transformation facilities.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>It has been widely argued that the analysis of non-functional attributes (e.g. performance or reliability) should be performed from the design phase of software systems, before their actual implementation, to reduce the costs of late problem fixing <ref type="bibr" target="#b21">[21]</ref>.</p><p>In this paper we focus on software systems built according to a component-based development (CBD) approach. According to CBD, a software system is an assembly of pre-existing, independently developed components, with the focus of system development shifting from custom design and implementation to the selection, composition and coordination of components <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b23">23]</ref>. Hence, the application of the above argument to CBD means that the analysis of non-functional attributes of a component assembly should be performed before actually assembling the components, to drive the selection of the components themselves and of the possible ways of composing and coordinating them, as also argued in <ref type="bibr">[7 (chapts. 8 and 9)</ref>].</p><p>An obvious implication for the introduction of non-functional analysis from the design phase of software systems is that it must be based on predictive analysis methodologies applied to some suitable system model. In this respect one of the main problems to be faced could be represented by the lack of sufficient expertise of the application designers in non-functional analysis methodologies. To overcome this problem, supporting tools have been recently proposed, whose key idea is to define a model transformation that takes as input some "design-oriented" model of the software system (plus some additional information related to the non-functional attributes of interest) and (almost) automatically generates an "analysis-oriented" model, that lends itself to the application of some analysis methodology <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">9]</ref>. Most of these proposals assume a UML notation for the designoriented model <ref type="bibr" target="#b26">[26]</ref>, and generate as output a variety of analysisoriented models, spanning queueing networks, Petri nets, Markov processes, simulation models.</p><p>However, to apply this approach in a CBD context, we have to face an additional problem caused by the foreseeable heterogeneity of the notations used by independent component providers to describe the component characteristics that could be relevant for the analysis of non-functional attributes. Moreover, the components assembler (that in CBD is generally distinct from the component designer and provider) could use yet another different notation to model the interaction infrastructure and the "glue logic" used to assemble the selected components. This heterogeneity in the design-oriented source models must also be paired with the different analysis-oriented target models one could be interested in. As a consequence, if we have N different notations used to model components and their composition, and M different target notations, we should devise N•M different model transformations.</p><p>To reduce the complexity of this task we propose in this paper a kernel language whose aim is to capture the relevant information for the analysis of non-functional attributes of component-based systems, with a focus on performance and reliability attributes, abstracting away unnecessary details. In this way, the direct transformation from source to target models can be split in a two-step transformation from the source model to an intermediate model expressed using this kernel language, and then from the intermediate model to the target model. We call this language KLAPER (Kernel LAnguage for PErformance and Reliability analysis). The advantage of using KLAPER is that we have to devise only N+M instead of N•M transformations. An additional advantage is that they could also be possibly simpler to devise than the direct transformations, as the intermediate model is likely to result "closer" to both the source and target models.</p><p>To take advantage of the current state of the art in the field of model transformation methodologies, we have defined KLAPER as a MOF (Meta-Object Facility) metamodel <ref type="bibr" target="#b14">[14]</ref>, where MOF is the metamodeling framework proposed by the OMG for the management of models and their transformations within the MDA (Model Driven Architecture) approach to software design <ref type="bibr" target="#b13">[13]</ref>. According to MOF, a (meta)model is basically represented as a constrained directed labeled graph, where a given metamodel defines the "syntactic rules" to build legal models.</p><p>Hence, we can use the MOF facilities to devise transformations to/from KLAPER models, provided that a MOF metamodel exists for the corresponding source/target model. These transformations can be defined as a set of rules that map elements of the source metamodel onto elements of the target metamodel.</p><p>The rest of the paper is organized as follows. In section 2 we briefly review related work. In section 3 we present the MOF metamodel of KLAPER, and its underlying basic concepts. Moreover, we also outline in this section a KLAPER-based transformation methodology from heterogeneous design models to analysis models. Then, to illustrate the role played by KLAPER in this methodology, we present in sections 4 through 6, a complete transformation path from design models to reliability or performance analysis models, using for this purpose a simple example of component-based application. In presenting this path, we do not give complete MOF-based rules for the transformations to/from KLAPER models, but simply outline how they could be devised. We are currently working toward their complete definition. Hence, in section 4 we present the selected example of a component-based application and its heterogeneous design model, expressed using two different notations (UML <ref type="bibr" target="#b26">[26]</ref> and OWL-S <ref type="bibr" target="#b17">[17]</ref>). In section 5 we outline transformations from design models to a KLAPER intermediate model. Then, in section 6 we deal with the transformation from a KLAPER intermediate model to analysis-oriented models, considering for this purpose discrete time Markov processes and extended queueing network models. Finally, section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>A first language to be mentioned for design-oriented models for CBD, is of course UML, because of its de facto standard status for software design, from both the industrial and academic perspective. Besides its use to model the functional aspects of an application design, UML has been also extended to model performance or reliability characteristics. Regarding performance characteristics, a standard extension has been defined (UML Profile for Performance, Schedulability and Time (SPT) <ref type="bibr" target="#b27">[27]</ref>). Regarding reliability characteristics, some UML extensions have been proposed (for example the Reliability Profile (RE) proposed in <ref type="bibr" target="#b6">[6]</ref>). Recently, a general framework for the UML specification of Quality of Service characteristics (QoS) has been standardized <ref type="bibr" target="#b28">[28]</ref>. However, other languages are emerging, tailored to specific CBD domains, to support the specification, selection and composition of components. For example, in the field of Web Services based development examples are the BPEL4WS <ref type="bibr" target="#b1">[1]</ref>, OWL-S <ref type="bibr" target="#b17">[17]</ref> and WSOL <ref type="bibr" target="#b24">[24]</ref> languages, some of which also have a relevant industrial support. These languages, even if they are mainly concerned with the functional aspects of components and services composition, also give the possibility of specifying some quality parameters (e.g. response time). Other languages which can be related to CBD are the Architecture Description Languages (ADLs) defined within the Software Architecture based approaches to software design, and built around the "componentconnector" model <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b12">12]</ref>.</p><p>Regarding model transformations, in recent years there has been a great interest in methodologies for the generation of analysis-oriented target models (including performance and reliability models) starting from design-oriented source models, possibly augmented with suitable annotations. In particular, several proposals have been presented concerning the direct generation of performance analysis models. Each of these proposals focuses on a particular type of source design-oriented model (spanning UML, Message Sequence Chart (MSC), Use Case Maps (UCM), formal language as AEmilia, ADL languages as Acme <ref type="bibr" target="#b22">[22]</ref>) and a particular type of target analysis-oriented model (spanning simulation models (SIM), Petri nets (PN), queueing networks (QN), layered queueing network (LQN) stochastic process algebras (SPA), Markov processes (MP) (see <ref type="bibr" target="#b2">[2]</ref> for a thorough overview of these proposals).</p><p>On the other hand, to the best of our knowledge, few proposals have been presented for the generation of reliability models. All the proposals we are aware of start from UML models with proper annotations, and generate reliability models such as fault trees (FT) <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b11">11]</ref>, Markov processes <ref type="bibr" target="#b11">[11]</ref> and Bayesian models <ref type="bibr" target="#b5">[5]</ref>.</p><p>The idea of defining a kernel language to reduce the complexity of a direct transformation from M different source metamodels to N different target metamodels has been already considered by other authors, for example in <ref type="bibr" target="#b4">[4]</ref>, where (in a different context from non-functional analysis of component-based systems) the kernel language is called a "pivot metamodel". A MOF compliant kernel language specifically related to performance analysis has been proposed in <ref type="bibr">[18]</ref>, with the goal of specifying intermediate models between design-oriented UML models with SPT annotations and performance models. The transformations from UML to an intermediate model and from it to different performance models (spanning layered queueing networks, extended queueing networks and stochastic Petri nets) are also briefly outlined in <ref type="bibr">[18]</ref>. With respect to the kernel language of [18], KLAPER is intended to serve as intermediate language also for reliability and, possibly joint performance-reliability (performability) analysis, starting from heterogeneous design notations.</p><p>Finally, regarding the possibility of exploiting MOF-based tools to support model transformations from/to KLAPER models, work is currently under way within the OMG toward the standardization of the QVT (Query/Views/Transformation) model transformation language <ref type="bibr" target="#b15">[15]</ref>. Other model transformation frameworks, which are to a large extent MOF compliant, have been also proposed <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b29">29]</ref>. In this paper, however, we do not present the actual implementation within these frameworks of KLAPER-based transformations, but we only outline them.</p><p>Of course, the exploitation of such frameworks is possible as long as the MOF metamodels of the target/source models have been defined. For design-oriented models, this is certainly the case for UML. In the case of the above mentioned languages for Web Services based development, they are actually defined as XML-based languages. However, tools already exist that automatically transform XML schemas into their equivalent MOF metamodel <ref type="bibr" target="#b32">[32]</ref>. Regarding the target analysis-oriented models, most of them (e.g. Petri nets, queueing networks, Markov processes) can be represented as special types of labeled directed graphs. Hence, the definition of their MOF metamodels is relatively straightforward. However, differently from designoriented models, no commonly agreed-on metamodel exists for these models yet. Metamodels for execution Graphs and Extended Queueing Networks have been proposed in <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b31">31]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MOF-BASED KLAPER METAMODEL</head><p>Figure <ref type="figure">1</ref> shows the structure of the KLAPER MOF metamodel, while figure 2 reports the list of attributes and associations for the relevant KLAPER metaclasses. The details of the MOF specification are reported in Appendix 1.</p><p>The idea underlying KLAPER is to provide support for the modeling of a system as an assembly of interacting resources, where a resource denotes something that may offer services (and possibly requires others), thus encompassing both software components and physical resources like processors, communication links or other devices like printers and sensors. Moreover, KLAPER maintains the visibility, also at its level of intermediate language, of the original system architecture as an assembly of components, preserving the "identity" of each resource. In such a way it is possible to support the generation of analysis-oriented models that lend themselves to the application of compositional techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Behavior</head><p>Step  The use of this unifying concept of resource allows us to keep the language simple. We do not introduce an explicit distinction between logical and physical resources, or between active or passive resources, differently from other performance-oriented languages (e.g. the SPT UML profile <ref type="bibr" target="#b27">[27]</ref> or the CSM language [18]).</p><p>A scheduling policy and a multiplicity (number of concurrent requests that can be served in parallel) can be associated with a resource to possibly model access control policies for the services offered by that resource. Each offered service is characterized by its formal parameters that can be instantiated with actual values by other resources requiring that service, and by its behavior modeling the activities that will be performed by the resource to carry out the service task. More than one behavior can be associated with a service to model possible different ways of carrying it out (e.g. with different QoS). We point out that both the formal parameters and their corresponding actual parameters are intended to represent a suitable abstraction (for the analysis purposes) of the "real" service parameters. For example, a "real" list parameter for some list processing software component could be abstractly represented as an integer valued random variable, where the integer value represents the list size, and its probability distribution provides information about the likelihood of different sizes in a given analysis scenario. We explicitly introduce service parameters to better support compositional and parametric analysis.</p><p>A behavior is characterized by a set of used services and consists of a sequence of steps to be performed. The set of used services may be empty in two different cases: for "simple services" that do not require other resources to carry out their own task, and for "composite services" that do require other resources, which however have not been selected yet. The former case could correspond, for example, to physical resources like processors or networks. The latter case allows us to build KLAPER models of single complex resources, before they are assembled with the resources they require.</p><p>To support performance or reliability analysis, each KLAPER service provides information about its execution time or failure characteristics, at two different levels. The speedAttr and failAttr attributes of a service allows us to specify set of parameters that provide an overall characterization of the service execution time or failure probability. Then, the internalExecTime and internalFailProb attributes of each service behavior step specify (according to a stochastic setting) the execution time or failure probability of that single step. Both the internalExecTime and internalFailProb attributes are specified as function of the service speedAttr and failAttr attributes. We point out that this information concerns only the internal service characteristics; it does not take into account possible delays or failures caused by the use of other required services.</p><p>Each step in a behavior models either some "standard" control rule used to regulate the control flow from step to step, or some resource activity. In the latter case, a step can model either an internal activity (an activity performed by the same resource offering the service) or a set of service calls (a set of requests for services offered by external resources), where each service call is characterized by an ordered set of actual parameters, and possibly by the associated called service.</p><p>An "AND" or "OR" completion model can be specified for the set of service calls included within a single step: in the AND case all the service calls must be completed before passing the control to the next step, while at least one must be completed in the OR case (this information could be useful, for example, in the modeling of fault-tolerant systems). The calledService associations from a service call to the called service is not specified when the required resource offering the called service have not been selected. If it is specified (meaning that the set of required resources have been selected and assembled) it provides the necessary link for calculating the overall time needed to complete that step or its overall reliability, taking into account, respectively, the execution time (plus the possible access delay) or the reliability of the called service, besides the internal execution time or reliability.</p><p>Besides being associated with a service, as described so far, a behavior can also be associated with a workload, as depicted in figure <ref type="figure">1</ref>. A workload is intended to model the intensity of the demand addressed to a given system, with the associated behavior modeling the type of such demand. Hence, while the behavior associated with a service is of reactive type, activated only when that service is invoked, the behavior associated with a workload is of proactive type, modeling the demand injected into a system (assembly of resources).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">A KLAPER-based Transformation Path</head><p>Following the idea discussed in the introduction, KLAPER can be used to build an intermediate model that acts as a bridge between design-oriented and analysis-oriented models, as shown in figure <ref type="figure" target="#fig_1">3</ref> . Hence, a KLAPER-based transformation methodology can be outlined as follows:</p><p>Step 1. From design models to KLAPER model</p><p>Step Exploit design assembly information to "connect" the KLAPER models built at step 1.1</p><p>Step 2. From KLAPER model to analysis models For each target analysis notation Translate the KLAPER model obtained in step 1.2 to a performance/reliability model</p><p>In step 1 we distinguish a pre-assembly time case (step 1.1) from an assembly time case (step 1.2): in the former case information about how the selected resources and services are assembled is not yet available, while this information is available in the latter case. Hence at step 1.1 we can only map models of isolated elements of a component-based system onto corresponding KLAPER models. The main missing elements in the resulting models concern the usedService and calledService associations for each resource offered service, that depend on how the single elements are assembled. Of course, without these associations, we cannot use the KLAPER model to carry out any analysis of the overall assembly. At assembly time this information becomes available. Using it, we can specify all the needed usedService and calledService associations, so getting a complete assembly model. From this model, we can generate a performance, reliability or performability model expressed in some machine interpretable notation (step 2), and then we can solve it using suitable solution methodologies.</p><p>In the next sections (section 4 through section 6) we illustrate this transformation path by means of a simple example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">AN EXAMPLE OF A COMPONENT-BASED SYSTEM</head><p>The example is built around a software component that offers a search service for an item in a list. To carry out this service, the component requires a sort service offered by some other component, to possibly sort the list before performing the search. In this example we assume that both these components are described (in some component repository) using the OWL-S language <ref type="bibr" target="#b17">[17]</ref>.</p><p>OWL-S is a XML-based language proposed to support the automatic discovery and composition of components and services. Hence, it is a good candidate as a description language for web accessible components.</p><p>In OWL-S, the structure and behavior of a service offered by a component (where a software component is a "resource" in the OWL-S vocabulary) is modeled using a "service model" based on the process construct. Other service characteristics (including for example its QoS attributes) are described in a separate "service profile". For the sake of simplicity, in figures 3 and 4 we only show the service models of the two services.</p><p>Figure <ref type="figure" target="#fig_2">4</ref> shows that the search service has three parameters, with the former two used to receive the list and the item to be searched, respectively, while the third is used to return the search result. The sort service (fig. <ref type="figure" target="#fig_3">5</ref>) has two parameters used to receive and return the list to be sorted, respectively. The search service is modeled as a "composite process", since it can possibly call (depending on whether the input list is already sorted) an external sort service. On the other hand, figure <ref type="figure" target="#fig_3">5</ref> shows that the sort service is modeled as an "atomic process" since it only implements some sort algorithm, without requiring the services of other components. Note that the model of the composite search service does not include an explicit representation of the service internal operations to perform the search on the sorted list. This is due to the fact that in OWL-S a composite service can only be represented as a composition of other "external" services. We assume that the service internal operations and their characteristics (e.g. QoS related attributes like their processing time or failure probability) are described in the "service profile" (not shown in this example).</p><p>&lt;!--The Search service --&gt; &lt;process:CompositeProcess rdf:ID="#Search"&gt; &lt;process:composedOf&gt; &lt;process:components rdf:parseType="Collection"&gt; &lt;If-Then-Else&gt; &lt;ifCondition rdf:resource="#ListIsNotSorted"/&gt; &lt;then rdf:resource="#Sort"/&gt; &lt;/If-Then-Else&gt; &lt;/process:components&gt; &lt;/process:composedOf&gt; &lt;process:hasInput&gt; &lt;process:Input rdf:ID="ListToSearch"&gt; &lt;process:parameterType rdf:resource="#ListOfItems"/&gt; &lt;/process:Input&gt; &lt;/process:hasInput&gt; &lt;process:hasInput&gt; &lt;process:Input rdf:ID="ItemToSearch"&gt; &lt;process:parameterType rdf:resource="#ListItem"/&gt; &lt;/process:Input&gt; &lt;/process:hasInput&gt; &lt;process:hasOutput&gt; &lt;process:UnConditionalOutput rdf:ID="SearchResults"&gt; &lt;process:parameterType rdf:resource="#boolean"/&gt; &lt;/process:UnConditionalOutput&gt; &lt;/process:hasOutput&gt; &lt;/process:CompositeProcess&gt; &lt;!--The Sort process --&gt; &lt;process:AtomicProcess rdf:ID="#Sort"&gt; &lt;process:hasInput&gt; &lt;process:Input rdf:ID="ListToSort"&gt; &lt;process:parameterType rdf:resource="#ListOfItems"/&gt; &lt;/process:Input&gt; &lt;/process:hasInput&gt; &lt;process:hasOutput&gt; &lt;process:UnConditionalOutput rdf:ID="SortedList"&gt; &lt;process:parameterType rdf:resource="#ListOfItems"/&gt; &lt;/process:UnConditionalOutput&gt; &lt;/process:hasOutput&gt; &lt;/process:AtomicProcess&gt; After retrieving the two components according to some preliminary selection criterion, who assembles them has to select a suitable way of connecting them. We assume that the two components are assembled according to a synchronous clientserver pattern, and that the model of this pattern (a "connector" in the Software Architecture terminology <ref type="bibr" target="#b3">[3]</ref>) is described using a UML notation. Figure <ref type="figure" target="#fig_4">6 depicts a (simplified)</ref> <ref type="foot" target="#foot_0">1</ref> UML model for the Remote Procedure Call (RPC) connector implementing this pattern, extended with UML SPT and RE annotations for performance and reliability related information <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b27">27]</ref> (to reduce the visual clutter, we only partially specify this latter information). Figure <ref type="figure" target="#fig_4">6</ref>(a) depicts the collaboration template used to model the connector "interface", while fig. <ref type="figure" target="#fig_4">6</ref>(b) depicts the sequence diagram modeling its dynamics.</p><p>From the SPT and RE annotations of figure <ref type="figure" target="#fig_4">6</ref> we can see that the stub and skeleton components are assumed to be perfectly reliable (i.e. the software code that implements them is bugfree), and that their computational and communication effort (explicitly depicted only for the stub component) is proportional to the exchanged parameters size. To model the actual component assembly, the system assembler will bind as actual parameters the "search" and "sort" services to the two template collaboration formal parameters "client" and "server", and the "ListToSort" and "SortedList" parameters to the two template formal parameters "InParms" and "OutParms".</p><p>Moreover, to carry out performance or reliability analysis of this component assembly, the system assembler must also specify possible computing and communication resources used to support the service execution and a suitable deployment of the assembly components to these resources. Also in this case we assume that this information is provided using a UML model. Fig. <ref type="figure">7</ref>(a) depicts the assembly of the two services, through their binding to the RPC connector parameters, while fig. <ref type="figure">7(b</ref>) depicts a possible deployment diagram. Also this diagram is augmented with SPT and RE annotations. From these annotations, we see for example that the cpu1 node executes operations at a speed given by its SPT PArate attribute. This performance information is used also to provide reliability related information (RE REfailprob attribute) since the cpu1 node can fail, with respect to a given processing request, because of a failure occurrence during the time interval needed to complete it (expressed as nop/PArate, where nop is the number of operations to be executed). The failure can occur according to an exponential distribution with parameter l.</p><p>As a result, we get a heterogeneous design model, where the UML language is used to model the software components interaction pattern and their deployment on the physical resources that support the service execution, while the OWL-S language is used to model the internal services behavior and their performance related characteristics (with the latter not shown in this example). We base this transformation on a direct mapping from the OWL-S resource and service concepts <ref type="bibr" target="#b17">[17]</ref> onto the KLAPER resource and service concepts. Then, for each OWL-S service, we define a mapping from its Service Model onto the KLAPER Behavior and from its Service Profile attributes to suitable KLAPER attributes. The mapping from the OWL-S Service Model onto the KLAPER Behavior could require a transformation from a deterministic to a corresponding stochastic setting, since KLAPER is based on a stochastic behavior model. On the other hand, regarding the mapping of OWL-S Service Profile attributes onto KLAPER attributes (e.g. the KLAPER internalFailAttr and internalExecTimeAttr), the definition of an OWL-S ontology for QoS attributed would be helpful. An initial proposal for this ontology can be found in <ref type="bibr" target="#b25">[25]</ref>. If the provided OWL-S model does not contain useful information to assign a value to the KLAPER service attributes, our assumption is that they are left unspecified, thus providing a placeholder that must be filled in using appropriate values, to carry out some meaningful analysis.</p><p>Figures <ref type="figure">8</ref> and<ref type="figure">9</ref> depict the KLAPER models of the search and sort components (partially) modeled in figures 4 and 5 , respectively, obtained following the transformation rules outlined above. Note that in both figures the "list" formal parameter has Integer type, with the underlying assumption that it actually represents the list size, since this is the only information we are interested in for the analysis purposes.</p><p>Regarding the search component (figure <ref type="figure">8</ref>), the OWL-S If-Then control construct has been mapped onto a Branch construct, whose branching probabilities should represent the frequency of the cases where the If condition (sorted list) holds true or false, respectively. If the OWL-S Service Model published by the component provider does not give enough information to realize this deterministic-to-stochastic mapping, the KLAPER branching probabilities are left unspecified, and must be specified to get a complete KLAPER model. Then, the required sort service specified in the "composedOf" section of the OWL-S search component has been mapped onto a KLAPER ServiceCall step. The internalFailProb attribute of this step is set equal to zero, meaning that the call of a software service is assumed to be perfectly reliable (a failure in this step can only "indirectly" occur if the called service fails). Finally, the KLAPER search service behavior also includes a ServiceCall step addressed to a processing resource. This step (for which no corresponding element can be found in the OWL-S service profile) has been inserted to explicitly model the internal operations to search the list (that are not modeled in the OWL-S service profile, as pointed out in section 4). This step requires the execution of log(n) operations to a cpu resource, where n is the list size. Moreover, the internalFailProb attribute of this step is an expression representing the reliability of the code that implements the search operations. 2 Note that all the actual 2 We are assuming that the values assigned to attributes like parameters used in the service calls of this component are defined as functions of the "list" formal parameter, thus allowing a parametric analysis with respect to the list size. Analogously, the behavior of the KLAPER model for the sort component (figure <ref type="figure">9</ref>) only includes a ServiceCall step addressed to a processing resource, modeling the component internal operations to sort the list. Indeed, we can see from its OWL-S model that this component does not require the services of any other resource.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Step 1.1: Transformation from UML to KLAPER (Pre-assembly Time Case)</head><p>We refer to UML models of (parts of) component-based systems largely inspired by the basic concepts expressed in the UML-RT Profile <ref type="bibr" target="#b19">[19]</ref>, most of which have been also incorporated in the recent UML 2.0 specification <ref type="bibr" target="#b26">[26]</ref>. Hence, we assume that each software component is modeled as a UML 2.0 component, with its associated set of provided and required interfaces. The internal behavior of a component is described by a UML state machine or activity diagram. The interactions among components occur according to "interaction protocols" modeled as UML collaborations. The physical devices of some supporting platform are modeled as UML nodes, and the mapping of components onto these nodes is modeled by deployment diagrams. Component use cases are modeled using UML sequence or activity diagrams.</p><p>Mapping this UML model elements onto KLAPER elements is relatively straightforward, as outlined in the following.</p><p>The basic idea is to map UML components, nodes and collaborations (with the latter modeling interaction protocols) onto KLAPER resources. Each of these three mappings is further refined as follows. In the case of UML components, the corresponding KLAPER resource offered and required services are derived from the component provided and required interfaces, and for each KLAPER offered service its associated behavior is derived from the UML component state machine or activity diagram. In the case of UML nodes, the corresponding KLAPER resource offers a simple (i.e. not requiring the services of other resources) service, whose behavior consists, besides the Start and End steps, of a single InternalActivity step (modeling, for example, a processing activity for a cpu-type node). In the case of UML collaborations, the corresponding KLAPER resource offers an "interaction service" (and possibly requires other services, like processing or communication), whose associated behavior is derived from the UML diagram modeling the collaboration dynamics.</p><p>Then, we map the UML diagrams modeling component use cases onto suitable KLAPER workloads, with their associated behaviors derived from the UML diagrams (e.g. sequence diagrams) modeling the use case dynamics.</p><p>For all the above outlined mappings, the attributes of KLAPER modeling elements are mainly derived from information expressed by the SPT or RE annotations included in the UML models.</p><p>Figures 10, 11 and 12 depict KLAPER models obtained from the UML models of figures 6 and 7, according to the guidelines outlined above.</p><p>Figures <ref type="figure">10</ref> and<ref type="figure" target="#fig_7">11</ref> depict the KLAPER resources used to model physical devices like the cpu1 and net1-2 nodes. Both these nodes are modeled as resources offering simple services consisting of an internal activity only. The formal parameter for internalFailProb or the amout of processing request are derived from information expressed in the OWL-S "service model" associated with a service. their offered service represents the number of operations to be executed or the number of bytes to be transmitted, respectively. In the case of the cpu1 model, the service failAttr attribute represents the hardware failure rate of the physical device (l), while the internal activity internalFailProb attribute represents the probability of a failure during the execution of an operation request. This information is derived from the RE annotations in the deployment diagram of figure <ref type="figure">7(b)</ref>.</p><p>Finally, figure <ref type="figure" target="#fig_8">12</ref> depicts the KLAPER model of the RPC connector. It is derived from the UML model of figure <ref type="figure" target="#fig_4">6</ref>. As a general rule to realize this mapping, we have mapped each PAstep labeled as PAdemand in the UML diagram onto a KLAPER ServiceCall step addressed to a cpu-type resource, and each PAstep labeled as a "network" PAextop to a KLAPER ServiceCall step addressed to a network-type resource. Moreover, we have mapped each service request (e.g. a message in a UML sequence diagram) addressed to some component onto a ServiceCall step addressed to a resource of suitable type. As a result, the RPC behavior consists of service calls addressed to processing and communication resources, modeling the processing activities at the two interaction endpoints (e.g. for parameters marshaling/unmarshaling) and the communication activity needed to transport the exchanged messages through the interconnection network. Note that all the internalFailProb attributes of these steps are set equal to zero, meaning that the internal software code implementing them is assumed as perfectly reliable. These steps can fail only if the required physical device fails. Moreover, the RPC connector also includes a synchronous service call step addressed to an "unspecified" service. This step will be completely specified at assembly time, when it will be associated with the server side of the client-server collaboration. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Step 1.2: Transformation from OWL-S or UML Models to KLAPER Models (Assembly Time Case)</head><p>As pointed out in section 3.1, when assembly information becomes available we can specify all the needed usedService and calledService associations, so getting a complete KLAPER assembly model. For this purpose, we can proceed by visiting the behavior associated with each service in the KLAPER resource models, searching for ServiceCall steps. For each such step, we distinguish two cases, that is whether it models a request addressed to a physical device (like a processor or a network link) or to a software component.</p><p>In the former case, we use deployment information provided by the source design model to create calledService and usedService associations from, respectively, the ServiceCall step and the Behavior it belongs to, to the offered service of the KLAPER resource modeling that physical device.</p><p>In the latter case, we know from the assembly model whether the request is mediated by some connector. If this is not the case, then we proceed similarly to requests addressed to physical devices. Otherwise, our goal is to make explicit in the KLAPER model the resource consumption due to the use of that connector. For this purpose, the general idea is to transform the service request to a software component into a service request addressed to the KLAPER resource modeling the connector, which in turn will "forward" it to the software component. How to actually implement this general idea depends on the type of connector used in the components assembly. Figure <ref type="figure" target="#fig_9">13</ref> partially shows the result of this further transformation, regarding the "client side" (search service) of an RPC connector. The call to the sort service has been actually mapped onto a call to the RPC service, represented by the calledService association with the RPC service. In turn, the RPC service will call the sort service (modeled by its formerly "unspecified" service call step). Since both these calls have their isSynch attribute set to true, the service request initiated by the search components will be completed only when the result, by way of the RPC connector, will return to the search component. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">KLAPER MODEL TO ANALYSIS MODEL TRANSFORMATION</head><p>As pointed out in section 2, no commonly agreed-on MOF metamodel still exists for analysis-oriented models. To illustrate possible transformations from KLAPER models to analysis models, we first define two possible MOF metamodels for discrete time Markov processes (DTMP) and extended queueing networks (EQN), and then outline the corresponding transformations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">From KLAPER to DTMP</head><p>Figure <ref type="figure" target="#fig_10">14</ref> depicts the MOF metamodel (mofDTMP) for a reliability analysis-oriented DTMP. In a model built using mofDTMP, an End state (if present) is an absorbing state representing the successful completion of the modeled system activity, while a Fail state is an absorbing state representing the occurrence of a failure that prevents the activity continuation. A set of formal parameters can be associated with the Start state of the model, to allow the specification of parametric expressions for the transition probabilities. Using this model, the reliability of the modeled system can be calculated as the probability of not being absorbed into the Fail state. In this respect, we could use, for example, the solution methodology presented in <ref type="bibr" target="#b30">[30]</ref>.</p><p>The transformation of a KLAPER model of a component-based system into a mofDTMP model is straightforward. For each offered service included in the KLAPER model we build a separate mofDTMP model. In this construction, we map each service behavior step onto a different state of the mofDTMP model. Moreover, we add a Fail state to the mofDTMP model. The formal parameters of the KLAPER service are mapped onto the formal parameters associated with the Start state of the mofDTMP model. Regarding the mofDTMP transitions, they are basically derived from the predecessor-successor relationships among steps of the KLAPER service behavior. Moreover, for each step where a failure can occur (i.e. a ServiceCall step or a step whose InternalFailProb attribute has a value different from zero) we add a transition from the corresponding state in the mofDTMP model to the Fail state. The transProb attribute of each mofDTMP transition is derived from information provided by the KLAPER model, like the branching probabilities associated with Branch steps or the step failure probabilities. In this respect, we note that the failure probability of a KLAPER ServiceCall step depends also on the failure probability of the called service. If this information is not known (e.g. when we are dealing with a preassembly time KLAPER model of an offered service, where the calledService associations are not specified), the corresponding mofDTMP transition probability must be left unspecified. Otherwise, to calculate the transition probability we must first solve the reliability model of the called service. Figure <ref type="figure" target="#fig_12">15</ref> shows the overall mofDTMP model of our component-based system example. In this figure, we can see as many mofDTMP models as the offered services in the overall KLAPER model of the system (for the sake of clarity, we have specified in italic the service each mofDTMP model refers to). For each mofDTMP model, we show in figure <ref type="figure" target="#fig_12">15</ref> its formal parameters while, for the sake of simplicity, we show the state transition diagram for only two models. The pFailn labels associated with some state transitions are placeholders for transition probabilities that depend on the failure probability of a called service. We have also included in this figure dashed arrows to graphically show which mofDTMP model these transition probabilities depend on. For example, the transition probabilities from state 3 of the search model depend on the cpu1 model (this dependence follows from the calledService association between the serviceCall step of the KLAPER search service model and the cpu1 processing service). This means that we must first solve the cpu1 mofDTMP model (calculating its absorbing probability into the Fail state), before building a completely specified search mofDTMP model. In figure <ref type="figure" target="#fig_12">15</ref> we also depict beside each dashed arrow the actual parameters that must be used to solve the model it points to. Note that in some cases we have to solve the same model twice with two different actual parameters, as depicted for example besides the arrow from the RPC to the cpu1 model, corresponding to the two calls of the cpu1.processing service in the RPC behavior.</p><p>In this way, we can compositionally calculate the reliability of the service offered by a component assembly (in this example, the search service), from the reliabilities of the assembled components and physical devices.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">From KLAPER to EQN</head><p>For performance analysis we apply an approach based on the Software Performance Engineering (SPE) framework <ref type="bibr" target="#b21">[21]</ref> Each Node in the EG metamodel is characterized by attributes such as name, time-demand, resource-type and service-name (demand vector). The node type (control, basic, …) derives directly from the EG terminology <ref type="bibr" target="#b21">[21]</ref>. The transfer of control is modeled through simple predecessor/successor associations or by way of more complex Control nodes modeling, for example, the possibility of selecting among different successors (branch) or the repetition of a certain number of nodes (loop). The proposed EQN metamodel is similar to the one proposed by Smith et al. <ref type="bibr" target="#b20">[20]</ref> and is based on the widely used notation for EQN presented in <ref type="bibr" target="#b10">[10]</ref>. As an additional feature, we have tried to maintain in this metamodel the separation of concerns between SM and MM typical of the SPE approach. To this end we define a EQN as composed by, on one side, a set of Routing Chains modeling the workload and, on the other side, as a set of centers modeling the different kind of EQN centers. For the sake of simplicity we omit here a complete definition of the Routing chain metaclass. <ref type="foot" target="#foot_1">3</ref> We only model its relationship with EGs, showing that a routing chain is derived from an EG <ref type="bibr" target="#b21">[21]</ref>. The connection between these two sides of an overall EQN model is represented through the Demand association that links the different resource demands of a single EG node to the related EQN centers. A center in a EQN can be Active (with attributes such as Number of servers, Scheduling discipline, service-rate, service-distribution), Passive (whose attributes are the Token number and the service discipline) or Special modeling for example, the source or the sink of a workload, or parallel thread of execution (Fork and Join). Each Special node is, in turn, characterized by suitable attribute; the source node attributes, for example, are the arrival rate and the arrival process distribution.</p><p>The transformation from a KLAPER model to a performance model based on EG and EQN consists of several steps. At first, each KLAPER resource that does not offer any service is mapped onto an EQN Passive center. On the other hand, for each KLAPER resource offering some service, if its service behavior does not contain any ServiceCall step then it is mapped onto a EQN Active center with corresponding name and attributes, while if it contains at least one ServiceCall step it is modeled through a suitable EG. The rationale for this mapping is that the former case typically corresponds to the model of a physical device, while the latter to the model of a software component.</p><p>Regarding the KLAPER models of software components, the behavior of each offered service is mapped onto an EG where each behavior Step is mapped onto a suitable EG Node. For this mapping, a direct correspondence exists between most of the KLAPER Control Steps and the EG Control Nodes. Such a correspondence does not exist only for the EG Split and loop nodes. However, the Split node can be obtained by the mapping of a KLAPER Fork step without a direct connection with a Join step, while the loop node can be used to explicitly model the repetition attribute of a KLAPER Step.</p><p>On the other hand, Internal Activity and ServiceCall KLAPER steps are mapped onto Basic EG nodes. The Service Call parameters are included in the Node attributes modeling the resource/service demands.</p><p>Besides, it is necessary to explicitly model the contention for the access to a software component modeled as a KLAPER resource with finite capacity. This can be achieved by introducing a pair of acquire and release nodes in the EG before and after the node(s) modeling the service offered by that component. This explicit modeling is not necessary for physical devices where the contention is directly modeled by the EQN center semantics.</p><p>The Workload of a KLAPER model is mapped onto different EQN elements, depending on whether it is an open or closed workload. In the former case, it is mapped onto a pair of Source-Sink EQN centers, whose attributes are derived from the workload ArrivalProcess attributes, while in the latter case, a number of jobs equal to the population attribute is placed on the EQN center derived from the initialResource attribute of the workload.   Figures 18 and 19 depict the EG and the EQN obtained from the assembly time KLAPER model of the considered example. The EG in figure 18 is represented using the standard graphics for its nodes <ref type="bibr" target="#b21">[21]</ref>. Note that this EG is actually a "reduced" EG, obtained by applying appropriate reduction rules to the EG directly derived from the KLAPER model by the mapping outlined above <ref type="bibr" target="#b21">[21]</ref>. In particular, the "sort" node aggregates the service demand addressed to the "network" and "cpu2" centers, because of the invocation of the sort service.</p><p>The final step to build an EQN model is the EQN parameterization consisting in the construction of the routing chains modeling the EQN dynamics. Roughly speaking, we build a different routing chain for each separate EG in the KLAPER assembly time model. The service requests of the routing chain jobs are determined through the Demand association between EG nodes and EQN centers, while the job routing stems from the transfer of control in the EG. In figure <ref type="figure" target="#fig_16">19</ref> the continuous and dashed arrows depict the two different routings modeling the execution of the search service with or without a call to the sort service, respectively. Both these routings belong to the single routing chain derived from the EG of figure <ref type="figure" target="#fig_15">18</ref>.</p><p>methodologies and tools". The authors would like to thank Dorina Petriu for insightful discussions about this topic.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Attributes and associations of the main KLAPER metaclasses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: KLAPER-based transformations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The OWL-S service model of the search s e r v i c e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The OWL-S service model of the sort s e r v i c e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: UML model of the RPC connector</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure 7: UML model of the Search-Sort assembly and of its underlying platform 5. STEP 1: DESIGN MODEL TO KLAPER MODEL TRANSFORMATION 5.1 Step 1.1: Transformation from OWL-S to KLAPER (Pre-assembly Time Case)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: KLAPER model of the search component</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 11 :</head><label>11</label><figDesc>Figure 10: KLAPER model of a cpu-type physical d e v i c e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: KLAPER model of the RPC connector</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: assembly time model of the search c o m p o n e n t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: The mofDTMP metamodel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: mofDTMP model of the search-sort e x a m p l e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 16 :Figure 17 :</head><label>1617</label><figDesc>Figure 16: The EG MOF metamodel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>(k log(l)), cpu</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 18 :</head><label>18</label><figDesc>Figure 18: EG modeling the search-sort example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 19 :</head><label>19</label><figDesc>Figure 19: EQN for the search-sort example, with an open workload.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Figure 1: Structure of the KLAPER MOF metamodel</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">Resource</cell><cell>resource 1</cell></row><row><cell></cell><cell></cell><cell cols="3">offeredService 0..*</cell><cell>0..1</cell><cell>called Service</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Service</cell><cell>0..*</cell></row><row><cell></cell><cell></cell><cell></cell><cell>1</cell><cell></cell><cell>used Service</cell></row><row><cell></cell><cell>0..1</cell><cell></cell><cell>1..*</cell><cell cols="2">behavior</cell></row><row><cell>Workload</cell><cell></cell><cell>0..1</cell><cell></cell><cell></cell><cell>0..*</cell></row><row><cell></cell><cell cols="2">nestedBehavior</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>successor</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>0..*</cell><cell></cell><cell cols="2">1..*</cell></row><row><cell></cell><cell></cell><cell>0..*</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>predecessor</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0..*</cell><cell>0..*</cell></row><row><cell>Start</cell><cell>End</cell><cell>Control</cell><cell cols="3">InternalActivity</cell><cell>ServiceCall</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>{ordered}</cell><cell>actual</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0..*</cell><cell>Param</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>ActualParam</cell></row><row><cell>Branch</cell><cell>Fork</cell><cell>Join</cell><cell cols="2">Acquire</cell><cell>Release</cell></row><row><cell cols="6">Resource: attributes: name, type, capacity, schedulingPolicy, description; associations: offeredService. Service: attributes:name, formalParams, speedAttr, failAttr, description; associations: behavior, resource. Behavior : associations: usedService, step, workload. Step : attributes: name, repetition, /internalExecTime, /internalFailProb, completionModel; associations: successor, predecessor, nestedBehavior, serviceCall. Branch : attributes: branchProbs. Acquire : attributes : resourceUnits; associations: resource Release : attributes: resourceUnits; associations:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>resource ServiceCall: attributes: resourceType, serviceName, isSynch; associations: step, actualParam, calledService; ActualParam : attributes: value. Workload : attributes: workloadType, arrivalProcess, population, initialResource; associations: behavior.</head><label></label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For example, we implicitly assume a static binding between the client and the server, that does not require the intervention of services like a Name Service.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>In the EQN terminology a routing chain is a set of job classes characterized by routing rules and service demands<ref type="bibr" target="#b10">[10]</ref>. Each job that circulates in a EQN belongs to a specific routing chain.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>The definition of automatic transformation tools from design models of component-based application to analysis models is a crucial issue for the effective introduction of early non-functional analysis in CBD. Toward this end, we have presented KLAPER, a kernel language whose main goal is to act as a bridge between design models of component-based applications, possibly based on heterogeneous notations, and performance or reliability analysis models. Besides presenting the language, we have also illustrated, through a simple example, the feasibility of mappings from design models onto KLAPER models and from KLAPER models onto analysis models.</p><p>We have defined KLAPER as a MOF metamodel, to exploit MOF-based model transformation frameworks. Moreover, the definition of KLAPER as a MOF metamodel facilitates the integration of KLAPER-based analysis tools within the MDA approach to software design, where MOF plays a key role in the definition of the design model transformations that are at the basis of this approach.</p><p>We are currently working towards the complete definition of KLAPER-based model transformation rules and their implementation in a model transformation framework, following the guidelines outlined in this paper. The definition of these rules will also help us in refining the KLAPER specification itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>Work partially supported by the MIUR-FIRB project "PERF: Performance evaluation of complex systems: techniques,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX 1</head><p>In this appendix we present the specification of the KLAPER MOF-based metaclasses. For the sake of brevity, we omit the specification of some "leaf" metaclasses (e.g. CompletionModel, InternalExecTime). .*] (speedAttr and failAttr are used to specify the basic parameters characterizing, respectively, the resource "speed" and the resource internal 4 failure probability in carrying out this service; in the simplest case, both speedAttr and failAttr may have multiplicity equal to one, and their type could be a simple renaming for the Real numeric type, expressing, for example, the number of operations and the number of failures per unit time for this service. In more complex cases, the multiplicity could be greater than one (e.g. to describe some multiparameter probability distribution), and the SpeedAttr and FailAttr types could specify additional information (such as the time scale used in the definition of these parameters)).   pre-assembly models (since it is used to represent the "service instance" that will actually be called and that is still unknown before the assembly is defined). </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Business Process Execution Language for Web Services Version 1.1</title>
		<author>
			<persName><forename type="first">T</forename><surname>Andrews</surname></persName>
		</author>
		<ptr target="http://www.ibm.com/developerworks/library/ws-bpel/" />
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Modelbased performance prediction in software development: a survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Balsamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Di Marco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Inverardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Simeoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="295" to="310" />
			<date type="published" when="2004-05">May 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Software Architectures in Practice</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The ATL transformation-based model management framework</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bezivin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Breton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dupé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
		<idno>no. 03.08</idno>
		<imprint>
			<date type="published" when="2003-09">Sept. 2003</date>
		</imprint>
		<respStmt>
			<orgName>IRIN, Univ. de Nantes</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Res. Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Early reliability assessment of UML based software models</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cortellessa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cukic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gunel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bharadwaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Workshop on Software and Performance (WOSP&apos;02)</title>
		<meeting>3rd Int. Workshop on Software and Performance (WOSP&apos;02)<address><addrLine>Rome (Italy)</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">July 24-26, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Towards a UML profile for QoS: a contribution in the reliability domain</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cortellessa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pompei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int. Workshop on Software and Performance (WOSP&apos;04)</title>
		<meeting>4th Int. Workshop on Software and Performance (WOSP&apos;04)</meeting>
		<imprint>
			<date type="published" when="2004-01">Jan. 2004</date>
			<biblScope unit="page" from="197" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">Building Reliable Component-Based Software Systems</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Crnkovic</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Larsson</surname></persName>
		</editor>
		<imprint>
			<publisher>Artech House</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A XML-based method for the prediction of software reliability</title>
		<author>
			<persName><forename type="first">A</forename><surname>D'ambrogio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Iazeolla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mirandola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. the 6th IASTED Int. Conf. Software Engineering and Applications</title>
		<meeting>the 6th IASTED Int. Conf. Software Engineering and Applications<address><addrLine>Cambridge, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
			<biblScope unit="page" from="234" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Packaging Predictable Assembly</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Hissam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Component Deployment (CD 2002)</title>
		<meeting>Component Deployment (CD 2002)</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="108" to="124" />
		</imprint>
	</monogr>
	<note>LNCS 2370</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Lavenberg</surname></persName>
		</author>
		<title level="m">Computer Performance Modeling Handbook</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Leangsuksun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shen</surname></persName>
		</author>
		<title level="m">Reliability Modeling Using UML&quot; Proceeding of 2003 Int. Conf. on Software Engineering Research and Practice</title>
		<meeting><address><addrLine>Las Vegas, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">June 23-26, 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A classification and comparison framework for software architecture description languages</title>
		<author>
			<persName><forename type="first">N</forename><surname>Medvidovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="70" to="93" />
			<date type="published" when="2000-01">Jan. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">MDA Guide Version 1.0.1&quot; OMGDocument omg</title>
		<idno>03-06-01</idno>
		<ptr target="www.omg.org/docs/omg/03-06-01.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Meta Object Facility (MOF) 2.0 Core Specification</title>
		<idno>ptc/03-10-04</idno>
		<ptr target="www.omg.org/docs/ptc/03-10-04.pdf" />
	</analytic>
	<monogr>
		<title level="m">OMG Adopted Specification</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Query/Views/Transformations RFP</title>
		<idno>OMG Document ad/2002-04-10</idno>
		<ptr target="www.omg.org/docs/ad/02-04-10.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">UMT UML model tranformation tool</title>
		<author>
			<persName><forename type="first">J</forename><surname>Oldevik</surname></persName>
		</author>
		<ptr target="http://umt-qvt.sourceforge.net/docs/UMT_documentation_v08.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">OWL-S: Semantic Markup for Web Services&quot; White Paper, The OWL Services Coalition</title>
		<ptr target="www.daml.org/services/owl-s/1.0/owl-s.pdf" />
		<imprint>
			<date type="published" when="2003-11">Nov. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Metamodel for Generating Performance Models from UML Designs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Petriu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woodside</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. &lt;&lt;UML&gt;&gt;2004</title>
		<meeting>&lt;&lt;UML&gt;&gt;2004<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-10">Oct. 2004</date>
			<biblScope unit="volume">3273</biblScope>
			<biblScope unit="page" from="41" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Using UML for Modeling Complex Real-Time Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Selic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<ptr target="www-106.ibm.com/developerworks/rational/library/content/03July/1000/1155/1155_umlmodeling.pdf" />
		<imprint>
			<date type="published" when="1998-03">March 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Performance Model Interchange Format (PMIF 2.0): XML Definition and Implementation</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">U</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Llado</surname></persName>
		</author>
		<ptr target="www.perfeng.com/" />
		<imprint>
			<date type="published" when="2004-03">March 2004</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Performance solutions: A Practical Guide to Creating Responsive, Scalable Software</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">U</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Architecture-based performance analysis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Spitznagel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1998 Conf. on Software Engineering and Knwoledege Engineering</title>
		<meeting>1998 Conf. on Software Engineering and Knwoledege Engineering</meeting>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Component Software: Beyond Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szyperski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Web Service Offerings Language (WSOL) and Web Service Composition Management (WSCM)</title>
		<author>
			<persName><forename type="first">V</forename><surname>Tosic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pagurek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Esfandiari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2002)</title>
		<meeting><address><addrLine>Seattle, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
	<note>position paper at the Workshop on Object-Oriented Web Services -OOWS</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<author>
			<persName><forename type="first">H.-L</forename><surname>Truong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Fahringer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Performance Analysis, Data Sharing and Tools Integration in Grids: New Approach based on Ontology&quot; Int. Conf. on Computational Science (ICCS 2004)</title>
		<meeting><address><addrLine>Poland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-06">June 2004</date>
			<biblScope unit="volume">3038</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Superstructure Specification&quot; OMG Adopted Specification</title>
		<idno>ptc/03-08-02</idno>
		<ptr target="www.omg.org/docs/ptc/03-08-02.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">UML Profile for Schedulability, Performance, and Time Specification</title>
		<idno>ptc/02-03-02</idno>
		<ptr target="www.omg.org/docs/ptc/02-03-02.pdf" />
	</analytic>
	<monogr>
		<title level="m">OMG Adopted Specification</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">UML Profile for Modeling Quality of Service and Fault Tolerance Characteristics and Mechanisms</title>
		<idno>ptc/04-09-012</idno>
		<ptr target="www.omg.org/docs/ptc/04-09-01.pdf" />
	</analytic>
	<monogr>
		<title level="m">OMG Adopted Specification</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Designing the automatic transformation of visual languages</title>
		<author>
			<persName><forename type="first">D</forename><surname>Varrò</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varrò</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pataricza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="205" to="227" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An architecture-based software reliability model</title>
		<author>
			<persName><forename type="first">W.-L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Pacific Rim Int. Symposium on Dependable Computing</title>
		<meeting>IEEE Pacific Rim Int. Symposium on Dependable Computing<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-12">Dec. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A Performance Model Interchange Format</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">U</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">XML Schema to Ecore Mapping</title>
		<ptr target="http://dev.eclipse.org" />
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
