<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Retrieving Top-k Prestige-Based Relevant Spatial Web Objects</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xin</forename><surname>Cao</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Gao</forename><surname>Cong</surname></persName>
							<email>gaocong@ntu.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Retrieving Top-k Prestige-Based Relevant Spatial Web Objects</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D5BD039C953ABE91CD15785A7BADC056</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The location-aware keyword query returns ranked objects that are near a query location and that have textual descriptions that match query keywords. This query occurs inherently in many types of mobile and traditional web services and applications, e.g., Yellow Pages and Maps services. Previous work considers the potential results of such a query as being independent when ranking them. However, a relevant result object with nearby objects that are also relevant to the query is likely to be preferable over a relevant object without relevant nearby objects.</p><p>The paper proposes the concept of prestige-based relevance to capture both the textual relevance of an object to a query and the effects of nearby objects. Based on this, a new type of query, the Location-aware top-k Prestige-based Text retrieval (LkPT) query, is proposed that retrieves the top-k spatial web objects ranked according to both prestige-based relevance and location proximity.</p><p>We propose two algorithms that compute LkPT queries. Empirical studies with real-world spatial data demonstrate that LkPT queries are more effective in retrieving web objects than a previous approach that does not consider the effects of nearby objects; and they show that the proposed algorithms are scalable and outperform a baseline approach significantly.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Studies suggest that at least some 20% of all web queries have local intent, meaning that the queries target local content. In step with the web being used increasingly by mobile users, this percentage can be expected to increase. Next, geo-positioning is increasingly available for mobile devices, e.g., by means of built-in GPS receivers. This enables web users who query for local content to provide their locations to services. Search engines already recognize local intent, and specialized services, e.g., maps and yellowpage services, that target local content continue to proliferate. For example, travel sites such as TripAdvisor and TravellersPoint offer services that enable users to find hotels with particular facilities and located in particular regions.</p><p>Several proposals already exist for the querying for geo-located web content, termed spatial web objects. A location-aware keyword query takes a location and specified keywords as arguments and returns web objects that are ranked according to both spatial proximity and text relevance relative to the query. Some proposals <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b21">21]</ref> view keywords as Boolean predicates, filtering out web objects that do not contain the keywords and ranking the remaining objects based on their spatial proximity to the query. Other proposals <ref type="bibr">[7,</ref><ref type="bibr" target="#b8">8]</ref> combine spatial proximity and textual relevance using a linear ranking function.</p><p>Existing work treats objects as independent when ranking them for a given query. However, spatial web objects are not independent. A relevant object whose nearby objects are also relevant to the query is preferable when compared to a relevant object without relevant nearby objects. One reason is that if the object a user chooses to visit does not work out then there are other nearby relevant objects. Another is that a user may intend to visit several objects (e.g., to compare prices). For example, a user may prefer to visit a location with many restaurants or shops instead of a location with only one restaurant or shop.</p><p>A preference for clusters of relevant objects may explain the phenomenon that similar businesses tend to co-locate. For example, car dealerships tend to co-locate. We speculate that they benefit from the spatial proximity: together, they attract more customers to such an extent that this compensates for the increased competition.</p><p>It is the objective of this paper to support this phenomenon in spatial web search. This is done by developing a notion of object "prestige" that takes into account the presence of nearby objects that are also relevant to a query. This notion of prestige is then used for the ranking of the query results.</p><p>We believe that this is the first study on supporting this interobject relationship in location-aware keyword querying. However, in non-spatial web search, inter-document relationships have been exploited to improve effectiveness of document retrieval. For example, a PageRank-like algorithm is applied to the document similarity graph (built based on document similarity rather than web links), thus significantly improving the effectiveness of document retrieval <ref type="bibr" target="#b18">[18]</ref> and question answers <ref type="bibr" target="#b9">[9]</ref>.</p><p>A further benefit of supporting this notion of prestige is that even if the description of an object does not contain the query terms, the object can still be identified as relevant. This occurs if the object has a text description that matches those of nearby objects that in turn contain the query terms. For example, consider a query for "spring roll" and two close objects with descriptions "best Chinese restaurant in Boston" and "Chinese restaurant offering spring rolls." The two descriptions are similar, and the latter contains the query term. So although the first object's description does not contain the query term, the object is identified as relevant to the query.</p><p>To illustrate the effect of supporting prestige-based object relevance, consider the query "shoes" at location P in Figure <ref type="figure">1</ref>. Circles represent shops selling shoes or jeans, with centers representing locations and areas representing relevance to the query. Existing spatial keyword search techniques (e.g., <ref type="bibr" target="#b8">[8]</ref>) rank R5 as the top-1 result since R5 is relevant and closest to P. However, R4 is more attractive because it has more nearby shops that are relevant to the query and also is close to the query location.</p><p>Figure <ref type="figure">1</ref>: Prestige propagation example In our proposal for prestige-based relevance (denoted as PR) of objects to queries, the PR score of an object is affected by the PR scores of its neighbors. This motivates us to employ a PageRanklike random walk mechanism for the propagation of prestige. Conceptually, given the example query above, the PR scores of the objects are computed as follows: We build a graph with the objects as the nodes. Two nodes are connected by an edge if the objects are close and their text descriptions are similar. Myriads of random surfers are initially placed at the nodes that contain the query term "shoes" (i.e., R4, R5, R6, R7). The number of random surfers at a node is proportional to the textual relevance between the node and the query, which is the initial prestige-based relevance of the node. At each step, each random surfer either moves to an adjacent node following a link in the graph with a certain walking probability (depending on the distance between the nodes), or it randomly jumps to the initial set of nodes containing "shoes" without following any link, again with a certain probability (depending on the well-known damping factor <ref type="bibr" target="#b5">[5]</ref>). The expected percentage of surfers at each node eventually converges, and the converged percentage of surfers at a node represents the PR score of the node.</p><p>The concept of PR is inspired by the concept of personalized PageRank <ref type="bibr" target="#b16">[16]</ref>, where a subset of web pages share the initial prestige uniformly (rather than all web pages as in PageRank), and its applications to keyword search in Entity-Relation graphs <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b6">6]</ref>.</p><p>The above random walk process has unique features that render a direct application of PageRank <ref type="bibr" target="#b5">[5]</ref> inadequate. PageRank is used to compute the objects' global importance, which is queryindependent, and it has no preferences for any particular nodes. Our problem is very different: each query has a set of preference objects based on the initial relevance scores, and thus random surfers start from this set of objects and jump to them. For example, given a "jeans" query at point P, R1 is the best result rather than R4, which is best if the query is for "shoes."</p><p>We propose a new type of query, called the Location-aware top-k Prestige-based Text retrieval (LkPT) query, that takes into account both location proximity and prestige-based text relevance (PR). The query retrieves a list of k objects ranked according to their spatial distances and PR scores with respect to the query.</p><p>The LkPT query is expensive to compute, especially due to the PR scores. A straightforward approach to computing the LkPT query is to adapt the algorithms for computing Personalized PageRank Vectors (PPVs) <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b16">16]</ref> to computing the PR scores of all objects in the spatial object graph, to use an R-tree for comput-ing spatial distances, and then to combine the two scores. However, this solution is expensive. First, it is expensive to compute PR scores for a large graph at query time using existing algorithms for PPVs. Second, it is impractical to pre-compute PPVs for each node in terms of either pre-computation time or the storage requirements <ref type="bibr" target="#b16">[16]</ref>-|V | 2 space is needed to store the PPVs for all objects. Third, it is a waste to compute the spatial distance and PR scores of all objects and then rank them to find the top-k results.</p><p>We note that the spatial object graph has unique properties that render it different from the web link graph <ref type="bibr" target="#b16">[16]</ref> and the entityrelation graph <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b6">6]</ref>.</p><p>• Similar spatial objects often co-locate geographically. For example, shops often co-locate, as do, e.g., bars. Therefore, spatial objects tend to naturally form subgraphs. • The number of nodes in a subgraph is constrained by geography. Thus, subgraphs will be of relatively modest size.</p><p>Properties like these enable us to develop approaches that speed up PR scoring. We propose two novel algorithms for the efficient computation of the LkPT query.</p><p>ES-EBC (Early stop extended bookmark coloring): We prove that if the distance between a node and the query point exceeds a certain threshold, the node will not affect the PR scoring of the topk objects. Therefore, we need only consider nearby nodes when propagating PR, which speeds up the PR scoring substantially. We also show how to estimate lower and upper bounds on the PR score of each object in each iteration during scoring. Utilizing these bounds, we derive conditions for when further iterations will not change the ranking order of the top-k objects and we stop iterating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S-EBC (Subgraph-based extended bookmark coloring):</head><p>We propose an approximate solution to PR scoring with performance guarantees. We organize spatial objects and their text descriptions using the external memory IR-tree <ref type="bibr" target="#b8">[8]</ref>. Hence, the spatial objects are grouped into subgraphs based on their locations, with each subgraph corresponding to a leaf node of the IR-tree. We prove that the PR scores of the nodes in a subgraph can be computed by PR propagation within the subgraph and contributions from the border objects that connect the subgraph with other subgraphs. This enables PR scoring w.r.t. subgraphs rather than on the whole graph. Next, we propose a novel approach to estimating an upper bound on the PR scores of the objects in each subgraph. This bound together with the distance of a subgraph to the query is used to choose which subgraphs to process and in which order.</p><p>Empirical studies with real data offer insight into the effectiveness of LkPT queries and the efficiency of the proposed algorithms.</p><p>The rest of the paper is organized as follows. Section 2 defines the LkPT query. Section 3 details the proposed algorithms. In Section 4, we report on the empirical studies. Section 5 concludes, and an appendix offers a variety of additional detail. Let Dist(Q, o) denote the Euclidean distance between the locations of query Q and object o, and let Sim(Q, o) denote the relevance between the keyword component of query Q and the text description of object o. We use the Vector Space Model <ref type="bibr" target="#b23">[23]</ref>, one of the most popular ranking functions, for computing Sim(Q, o), while using the TF-IDF weighting scheme to represent the text descriptions of objects (details are in Appendix A).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PROBLEM DEFINITION</head><p>To compute the PR scores of objects, we define a weighted, undirected graph G = (V, E) over D, where each node in V corresponds to a spatial object and edge set E includes an edge oi, oj iff the following two conditions are satisfied: 1) Dist(oi, oj) ≤ λ and 2) Sim(oi, oj) ≥ ξ, where λ and ξ are threshold parameters. The weight of edge oi, oj in E is Dist(oi, oj). Prestige-Based Relevance (PR). The final PR vector p fulfills the following equation:</p><formula xml:id="formula_0">p = (1 -α)C T p + α uQ, uQ = [v1, ..., v |D| ] T , vi = Sim(Q, oi), 1 ≤ i ≤ |D|, (<label>1</label></formula><formula xml:id="formula_1">)</formula><p>where C is the normalized adjacency matrix of graph G such that j∈V C(b, j) = 1, where C(b, j) represents the normalized weight from node b to node j; and column vector uQ is the initial PR vector in which each element is the relevance of an object.</p><p>Parameter α represents the probability of a random surfer jumping to the set of initially relevant spatial objects (vi &gt; 0) instead of following the edges in the graph. Interestingly, parameter α can be used to balance the relevance of an object and the effect of its relevant neighbors, i.e., the parameter allows for tuning according to user-specific requirements. In particular, smaller values of α favor objects with nearby relevant objects, while larger values of α favor objects with high initial PR scores.</p><p>To understand the random walk process for each object b, its PR score p(b) can be rewritten as follows:</p><formula xml:id="formula_2">p(b) = α uQ(b) + (1 -α) j∈V C(j, b) p(j), (<label>2</label></formula><formula xml:id="formula_3">)</formula><p>where uQ(b) is the initial PR score of b.</p><p>The iterative computation diffuses the PR score of each object across the graph. In the beginning, each object gets its initial PR score according to its text relevance to the query. At each step, an α fraction of the PR score is held by each node, while the remaining (1 -α) flows by following the links of the graph. This propagation continues until all the prestige is distributed cross the graph. The final PR scores take into account both the original relevance scores and the effect of neighbor nodes.</p><p>The PR vector is inspired by the of personalized PageRank vector (PPV) <ref type="bibr" target="#b16">[16]</ref> of preference vector uQ. In the original PPV <ref type="bibr" target="#b16">[16]</ref>, a set of preferred objects in the preference vector are assigned uniform initial scores, while we assign an initial score to an object that is in proportion to its text relevance to the query. LkPT Query Definition. Intuitively, an LkPT query retrieves k objects from database D ranked according to a combination of their distances to the query location and their PR scores for the query. Formally, given a query Q = (ψ, µ), where Q.ψ is a location descriptor and Q.µ is a set of keywords, the objects returned are ranked according to a ranking function f (Dist(Q, o), Pr(Q, o)), where Dist(Q, o) is the Euclidian distance between Q and o and Pr(Q, o) is the PR score of o with respect to Q. An LkPT query becomes an LkT query <ref type="bibr" target="#b8">[8]</ref> in the extreme case of α = 1 (Equation 2), i.e., we disregard the effects of nearby relevant objects. Problem Statement. We address the problem of efficiently answering LkPT queries.</p><p>The paper's proposals are applicable to a wide range of ranking functions that are monotone with respect to the distance proximity Dist(Q, o) and the PR score Pr(Q, o). We follow existing work <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b20">20]</ref> and use a linear combination of the normalized factors for ranking an object o with respect to a query Q:</p><formula xml:id="formula_4">RS(Q, o) = (1 -β)(1 -Pr(Q, o)) + β Dist(Q, o) maxD (<label>3</label></formula><formula xml:id="formula_5">)</formula><p>where β ∈ (0, 1) is used to balance the PR score and the location proximity; Euclidian distance Dist(Q, o) between query Q and object o is normalized to a value between 0 and 1 by a constant maxD, which can be the maximum distance between two objects in D or the maximum distance that can be accepted by the users; and Pr(Q, o) is the PR score of object o w.r.t. query Q and usually takes a value between 0 and 1. This function computes the ranking score of each object given an LkPT query. Note that parameter β allows to set the preference between the PR score and the location proximity at query time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROPOSED SOLUTIONS 3.1 Baseline Algorithm</head><p>As a baseline, we present an improvement of the straightforward solution mentioned in the introduction.</p><p>In the straightforward solution, we compute PR scores for all objects and the distances between all objects and the query, upon which we rank the objects based on the combined scores. We focus on computing the costly PR scores.</p><p>We choose to adapt the bookmark-coloring algorithm (BCA) <ref type="bibr" target="#b4">[4]</ref>, an elegant algorithm for computing PPVs, to computing the PR scores. We first extend the in-memory BCA algorithm to work in secondary memory. We read the graph in large blocks that each exploit the memory available, and do the iterative propagation in a per-block manner. The computation stops when the termination condition for the graph is met. A block is likely to be read and written multiple times since it may receive PR scores from other blocks that need to be distributed. Second, we BCA, which works on unweighed graph for a single preferred object, to support PR score computation for a general preference vector uQ on a weighted graph.</p><p>Algorithm 1 details the resulting Extended BCA (EBC) algorithm. Let p denote the PR score that each object already has, let q denote the PR score that each object needs to distribute, and let outPR be the vector of the sum of the PR scores that need to be distributed in each graph block.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 EBC(Q)</head><p>Input: query Q Output: The PR score of each object 1: compute the text relevance of each object to Q and compute u Q 2: q ← u Q , p ← 0, outPR ← 0 3: blockQueue ← NewPriorityQueue() 4: for each object b do outPR(b.block) ← outPR(b.block) + q(b) 5: for each block bg do blockQueue.Enqueue(bg) 6: while q 1 ≥ ε do 7: bg i = blockQueue.Dequeue() 8: read the graph block bg i 9: outPR(bg i ) ← 0 10: Queue ← NewQueue() 11: for each object n s.t. n ∈ bg i and q(n) &gt; 0 do 12:</p><p>Queue.Enqueue(n) 13: while not Queue.Empty() do 14:</p><p>b ← Queue.Dequeue()</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15:</head><p>if q(b) &gt; then 16:</p><formula xml:id="formula_6">p(b) ← p(b) + α q(b)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>17:</head><p>for each out-neighbor j of b do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>18:</head><p>if q(j) = 0 and j ∈ bg i then Queue.Enqueue(j) <ref type="bibr" target="#b19">19</ref>:</p><formula xml:id="formula_7">outV ← (1 -α)C(b, j) q(b) 20: q(j) ← q(j) + outV 21: if j / ∈ bg i then</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>22:</head><p>outPR(j.block) ← outPR(j.block) + outV</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:</head><p>q(b) ← 0 24: blockQueue.Update()</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>25: return p</head><p>We compute the text relevance of each object to the query Q using an inverted list index and then construct the preference vec-tor uQ according to Equation 1 (line 1). We use a priority queue blockQueue whose key is the accumulated outgoing PR score that needs to be propagated in each block (lines 4-5). In each graph block, we modify the propagation mechanism of BCA to accommodate edge weights and multiple objects in the preference vector.</p><p>We use a queue Queue to store the objects that have PR scores that need to be distributed (lines <ref type="bibr" target="#b10">[10]</ref><ref type="bibr" target="#b11">[11]</ref><ref type="bibr" target="#b12">[12]</ref>. Specifically, for the PR q(b) that needs to be distributed at an object b, we assign α q(b) to b (line 16) and (1 -α) q(b) to its neighbors according to the edge weights (lines <ref type="bibr" target="#b17">[17]</ref><ref type="bibr" target="#b18">[18]</ref><ref type="bibr" target="#b19">[19]</ref><ref type="bibr" target="#b20">[20]</ref>. We update the PR score that needs to be distributed for each block (lines <ref type="bibr" target="#b21">[21]</ref><ref type="bibr" target="#b22">[22]</ref>.</p><p>When the PR score of each object that needs to be distributed is smaller than the propagation threshold , we stop the propagation within a block (line 15). When the PR score to be distributed is smaller than the tolerance threshold ε (line 6), we stop the propagation over the graph and return PR vector p, each element of which represents the PR score Pr(Q, o) of object o. We thus use ε and as the termination conditions, as in BCA <ref type="bibr" target="#b4">[4]</ref> and its variant <ref type="bibr" target="#b13">[13]</ref>.</p><p>This method is inefficient because it computes PR scores and distances for all objects. The PR scores of objects are inter-dependent and need to be computed together, while the distance scores can be computed individually. Thus, inspired by the Threshold algorithm <ref type="bibr" target="#b11">[11]</ref>, we develop two improved baseline algorithms that avoid unnecessary distance score computations. These two algorithms are covered in Appendix B.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Early Stop EBC Algorithm (ES-EBC)</head><p>PR scores are much more costly to compute than distances because they require iterations over possibly large graphs. We thus proceed to propose two new techniques for speeding up the computation of PR scores. First, we show how to stop the iterative PR score computation early, using a new stopping condition (Theorem 1). Second, we show how to disregard objects further away from the query than a certain distance (Theorem 2). All proofs are found in Appendix C.</p><p>As before, let p denote the vector of the PR score that each object already has, and let q denote the vector of the outgoing PR score that each object needs to distribute. </p><formula xml:id="formula_8">pi(b) ≤ p(b) ≤ pi(b) + α 2 max( qi) + (1 -α) qi 1,</formula><p>where max( qi) is the maximum element in qi in the i-th iteration, and</p><formula xml:id="formula_9">• 1 is the 1-norm.</formula><p>Lemma 2 follows previous work <ref type="bibr" target="#b13">[13]</ref>. The current ranking score CRS(b) of an object b is computed according to Equation 3 at the current (i-th) iteration of PR scoring. We estimate lower and upper bounds on the ranking score for each object in the i-th iteration as follows:</p><formula xml:id="formula_10">Upper(b) = CRS(b) Lower(b) = CRS(b) -(1-β)(α 2 max( qi) + (1-α) qi 1)<label>(4)</label></formula><p>The upper bound holds because the distance between an object and the query is constant, while its PR score increases in each iteration (Lemma 1). We obtain the lower bound based on Lemma 2 and Equation <ref type="formula" target="#formula_4">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THEOREM 1. Let priority queue Lr record the current top-(k+ 1) objects seen, the key being the objects' PR scores. It is guaranteed that the top-k objects have been found if the k-th and the</head><p>(k + 1)-st objects, represented by Lr(k) and Lr(k + 1), respectively, satisfy the following condition:</p><p>Upper(Lr(k)) &lt; Lower(Lr(k + 1))</p><p>The PR score computation stops iterating when the condition in Theorem 1 is satisfied, i.e., the current top-k objects all have smaller final ranking scores than those of all other nodes. THEOREM 2. Given a query Q, a set of candidate objects C, and a spatial cell Ωi, objects contained in Ωi can be disregarded during propagation if the following is satisfied:</p><formula xml:id="formula_11">minDist(Q, Ωi) &gt; λ log 1-α outC(Ωi) + Dist(Q, os),</formula><p>where minDist(Q, Ωi) is the minimum distance between Q and Ωi, λ is the distance threshold used when building the object graph; α and are as explained in Algorithm 1; os is the object in C furthest away from query Q; and outC(Ωi) stores the aggregated PR score that needs to be distributed in Ωi.</p><p>The condition stated in Theorem 2 guarantees that the objects in cell Ωi will neither become top-k results nor affect the PR scores of the top-k results. Thus, the objects in the cell can be disregarded during the propagation of scores.</p><p>The algorithm that exploits the early stopping conditions first divides the graph into blocks according to the locations of the spatial objects such that each block fits into memory. Each block is further divided into a grid of spatial cells. Then nearest neighbors are retrieved incrementally <ref type="bibr" target="#b14">[14]</ref> using the R*-tree <ref type="bibr" target="#b3">[3]</ref>. For each nearest neighbor object o, the block graph containing o is read cell by cell: for each cell the algorithm checks whether it can be pruned according to Theorem 2; if it cannot, it reads the part of the graph corresponding to the cell. Then it iterates in the block to get the local PR scores for the objects in the block.</p><p>The algorithm keeps track of the current top-(k + 1) objects. When the ranking score of the k-th object is smaller than the lower bound (the minimum possible) ranking score of the current nearestneighbor object o, i.e., ∆ = β Dist(Q,Lr (k)) maxD ), the nearest-neighbor retrieval stops because no unseen object has a lower ranking score than has object o (since unseen objects no closer to the query than o) and thus cannot be a top-k object.</p><p>This way, we obtain a set of candidate top-k objects. However, these do not necessary constitute the final result since PR scores were only propagated inside a block. We need to propagate the PR scores across blocks while still using Theorems 1 and 2. Additional explanations and pseudo-code are available in Appendix B.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Subgraph-Based EBC Algorithm (S-EBC)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Overview of the Algorithm</head><p>Recall that the baseline and ES-EBC algorithms need to propagate PR scores on the whole graph. To compute PR scores within some selected subgraphs, we develop several techniques.</p><p>First, we show that PR scores can be computed by the combination of two parts: the PR score propagation within a subgraph and the PR contributed by the propagations from other subgraphs, which can be computed from pre-computed distribution vectors of the border nodes that connect the subgraph with other subgraphs (see Section 3.3.2). This enables us to compute PR scores with respect to a subgraph.</p><p>Second, we propose an approach to identifying the subgraphs that need to be checked to find the top-k results, thus avoiding checking all subgraphs. This is enabled by a novel approach to estimating upper bound PR scores of objects in a subgraph, given a query.</p><p>Specifically, we organize the spatial objects by extending the external memory IR-tree <ref type="bibr" target="#b8">[8]</ref>. The spatial objects are grouped into subgraphs so that each subgraph corresponds to a leaf node of the IR-tree. We enrich the nodes of the tree with pre-computed information (see Section 3.3.3) and show that by utilizing this information, we can compute an upper bound PR score at each node for a query.</p><p>The upper bound PR scores together with the distance of a subgraph to the query are used to choose which subgraphs to process at query time. If the best estimated ranking score of nodes in a subgraph exceeds (the smaller a score, the better) the score of the k-th object, the subgraph cannot contribute to the top-k results and can be pruned.</p><p>Based on this, we propose an approximate algorithm with performance guarantees for answering LkPT queries (see Section 3.3.4). The approximation occurs because we do not process all subgraphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Subgraph-Based PR Scoring</head><p>We present a decomposition method that enables us to compute PR scores with regard to subgraphs.</p><p>Assume that we have already partitioned the graph G into m subgraphs G1, ..., Gm (to be discussed in Section 3.3.3). Let border (Gi) be the set of border objects of Gi that connect Gi with other subgraphs. Also, let H be the set of the border objects of all subgraphs, i.e., H = i∈ <ref type="bibr">[1,m]</ref> border (Gi).</p><p>For each border object b, we pre-compute and store a vector GP b that describes how to distribute the unit initial PR score from b over the whole graph. Note that the number of border objects is much smaller than the number of objects in the database. In a vector Pr b , most of the elements are 0 since in spatial graphs, a node b usually only affects the objects in nearby subgraphs. We do not need to store the value 0.</p><p>We proceed to show that the PR score vector of an object, which is assigned the unit initial PR score, can be computed by propagation within its subgraph together with the propagations contributed by the border nodes, which we capture in pre-computed PR score vectors of border nodes. We denote the PR scores computed within a subgraph as the local PR scores ( LP), and we denote the PR scores on the whole graph as the (global) PR scores ( Pr). We have the following lemma and theorem: LEMMA 3. Given a node b and a subgraph Gi containing object b, we can compute the PR score vector of b as follows:</p><formula xml:id="formula_12">Pr b = LPr b + h∈border (G i ) AP b (h) • Pr h ,</formula><p>where AP b (h) is the accumulated PR score of border node h during the local propagation within subgraph Gi. THEOREM 3. Given a query Q, its PR score vector is computed as:</p><formula xml:id="formula_13">PrQ = m j=1 o∈G j Sim(Q, o)( LPro + h∈border (G j ) APo(h) • Pr h ) Sim(Q, o)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>is the similarity of query Q and the description of object o according to the vector space model (Appendix A).</head><p>Theorem 3 allows us to decompose the computation of PR scoring. Given a query Q and a subgraph, we compute the text relevance to Q of each object in the subgraph. We distribute these scores following the links within the subgraph: when we reach a border node, the node accumulates the value distributed to it; if we meet a non-border node in the subgraph, we increase its PR score by a portion of the scores and distribute the rest to its outneighbors, as in Algorithm 1. Having processed all subgraphs (i.e., we distribute PR scores within each subgraph), we use the global PR vector of each border object in a subgraph to update the PR scores for all the objects according to Theorem 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Indexing and Ranking Score Estimation</head><p>To efficiently process an LkPT query, we need to organize the spatial objects into subgraphs. We proceed to briefly introduce the index structure used for organizing objects and then focus on how to estimate an upper bound PR score for each node for a single-term as well as a multi-term query. Index structure-IR-tree. We extend the IR-tree <ref type="bibr" target="#b8">[8]</ref> index structure to organize spatial objects and capture the pre-computed information needed for upper bound estimation. It is also used to partition the graph.</p><p>A leaf node L in the IR-tree contains a number of entries of the form o, o.µ , where o is the identifier of an object and o.µ is the bounding rectangle of the object. A leaf node corresponds to a subgraph and contains a pointer to the subgraph at the node and the global PR score vector of the border objects of the subgraph.</p><p>A non-leaf node R contains a number of entries of the form cp, Ω , where cp points to a child node and Ω is the minimum bounding rectangle of all rectangles of entries in the child node.</p><p>Each node contains a pointer to an inverted file that describes the objects in the subtree rooted at the node. The inverted file for a node X contains: 1) A vocabulary of all distinct terms in the text descriptions of the objects in the subtree rooted at X. 2) A set of posting lists, each of which relates to a term t. Each posting list is a sequence of pairs cp, wtcp,t , where cp is a child of X and wtcp,t is the upper bound PR score of objects in the subtree rooted at cp for term t.</p><p>It is challenging to develop an effective approach to estimating the upper bound PR score of a node even for a single-keyword query (i.e., wtcp,t), much less a multi-keyword query. It is computationally prohibitive to pre-compute the exact PPVs for each object <ref type="bibr" target="#b16">[16]</ref>, and this also holds for PR score vectors since they need similar computation. Note that the purpose of pre-computing and storing the upper bounds is that we can then utilize them to prune the search space at query time for an LkPT query (this will become clear shortly). Upper bound PR score for single-keyword queries. We first consider a leaf node; it is straightforward to derive an upper bound for a non-leaf node from those of its child nodes. We estimate the upper bound for a leaf node by the sum of the upper bound PR scores from the propagation within the node and the maximum contribution from other subgraphs. Let L be a leaf node that corresponds to a subgraph Gi. Let maxGPr(t, L) denote the estimated upper bound PR score of the objects in L for (query) term t. To estimate maxGPr(t, L), we need the initial PR score of a subgraph Gi for a query term t, denoted as IPS(t, Gi). DEFINITION 1. The initial PR score of Gi for t is computed as follows:</p><formula xml:id="formula_14">IPS(t, Gi) = o∈G i Sim(t, o)</formula><p>Here, Sim(t, o) is the similarity between term t and the description of object o according to the Vector Space Model (Appendix A).</p><p>We first present a lemma on how to estimate a maximum local PR score within a subgraph Gi given a query term t. This is the PR score without considering the effects of other subgraphs. LEMMA 4. The maximum local PR score maxLPr(t, Gi) can be estimated as: We can now explain the weight wtcp,t in the inverted file. At a leaf node X, the upper bound of each object cp is computed as Sim(cp.ψ, t) (defined in Appendix A); At the parent node X of a leaf node, wtcp,t = maxGPr(t, Gcp) (computed according to Theorem 4). For other nodes, wtcp,t is the largest PR score among the child nodes of cp, i.e., max R∈cp.children() wtt,R. Upper bound PR score for multi-keyword queries. Based on the pre-computed upper bound PR score for a single keyword query, we propose an approach to estimating the upper bound PR score for a multi-keyword query.</p><formula xml:id="formula_15">maxLPr(t, Gi) = 1 + α -α 2 2 -α max o∈G i (Sim(t, o)) + 1 -α 2 -α IPS(t,</formula><p>LEMMA 5. Given a subgraph Gi, we compute its initial PR score (IPS) for a query Q as follows:</p><formula xml:id="formula_16">IPS(Q, Gi) = t∈Q.ψ G i .ψ w Q.ψ,t W Q.ψ IPS(t, Gi),</formula><p>where w Q.ψ,t and W Q.ψ are defined in Appendix A and IPS(t, Gi) is computed according to Definition 1.</p><p>Lemma 5 provides a way of computing the initial PR scores of a query Q in a subgraph Gi. We proceed to present how to estimate the upper bound PR score of each node in the IR-tree for a query Q.</p><p>DEFINITION 2. Given a query Q and a node X in an IR-tree, the largest possible PR score of objects in X, maxPr(Q, X), is defined as:</p><formula xml:id="formula_17">maxPr(Q, X) = t∈Q.ψ X.ψ w Q.ψ,t W Q.ψ maxGPr(t, X),</formula><p>where w Q.ψ,t and W Q.ψ are defined in Appendix A. THEOREM 5. Given a query Q and a leaf node X that encloses a set of objects XO = {o1, . . . , om}, the following holds:</p><formula xml:id="formula_18">∀o ∈ XO; (maxPr(Q, X) ≥ Pr(Q, o))</formula><p>We proceed to present the minimum spatial-PR score distance, minRS, which is needed for the query processing. Given a query Q and a node X in the IR-tree, the metric minRS offers a lower bound on the actual spatial-PR score distance between query Q and the objects in node X. This bound can be used to order and efficiently prune the search space in the index. DEFINITION 3. Given a query Q and a node X, the minimum spatial-PR distance, denoted by minRS(Q, X), is defined as:</p><formula xml:id="formula_19">minRS(Q, X) = (1-β)(1-maxPr(Q, X))+β</formula><p>Dist(Q.µ, X.Ω) maxD Here, maxPr(Q, X) is the upper bound PR score of objects in X for query Q (cf. Definition 2). THEOREM 6. Given a query Q and a node X whose rectangle encloses a set of objects XO = {o1, . . . , om}, the following is true:</p><formula xml:id="formula_20">∀o ∈ XO; (minRS(Q, X) ≤ RS(Q, o))</formula><p>The extended IR-tree used in this paper and the original IRtree <ref type="bibr" target="#b8">[8]</ref> share a similar data structure. However, the inverted files in the two indexes store different contents. The novelty of the extended IR-tree is its approach to estimating upper bound PR scores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">Subgraph-Based EBC Algorithm (S-EBC)</head><p>We proceed to describe the S-EBC algorithm that exploits the techniques just presented.</p><p>The main idea is to choose subgraphs that are more likely to contain top-k results for a query Q and then compute the PR scores in the selected subgraphs. For a node X in the IR-tree, we estimate its largest possible PR score according to Definition 2, and we compute its distance to the query. Thus, we can compute the smallest possible ranking score (minRS(X, Q) in Definition 3; the smaller the score, the better).</p><p>We use a priority queue queue to keep track of the nodes that have yet to be visited; the smallest possible ranking score is used as the key. When the head of the queue is a leaf node, i.e., its corresponding subgraph Gi has the lowest possible ranking score, we process the subgraph using the approach from Section 3.3.2. When the propagation within the subgraph completes, we have a local PR score for each object in Gi, and we use the PR scores held by the subgraph's border objects to update the global PR scores of all the objects (for object o, according to Theorem 3).</p><p>We proceed to process the next subgraph using the priority queue. The processing continues until the smallest possible ranking score of the unvisited head node of the priority queue exceeds the ranking score of the current k-th result; we can then stop since no unvisited object can become a top-k result.</p><p>It is guaranteed that the unprocessed subgraphs (leaf nodes) do not contain top-k objects. However, they may affect the PR scores of the current top-k objects. To ensure this effect is within a certain bound, some postprocessing is needed. When building an IRtree, we append the following pre-computed information to each leaf node (subgraph Gi) of the IR-tree: a set of the IDs of the subgraphs that affect Gi, denoted by Gi.N ear and a factor describing the maximum possible effect of a subgraph on an object in Gi (e.g., for a subgraph Gj, the factor is max bn∈border(G j ),b∈G i ( Pr bn (b)), according to Theorem 4).</p><p>In the postprocessing, we find the set SS of subgraphs containing the current top-k objects. For each subgraph Gi in SS, we then find Gi.N ear, the set of subgraphs that affect the PR scores of objects in Gi. For each subgraph Gj in Gi.N ear, if it is not yet processed, we compute its maximum possible effect on an object in Gi, denoted by maxEF(Gj, Gi), according to Theorem 7. We sort the subgraphs in Gi.N ear in ascending order of maxEF(Gj, Gi), and we then find the m-th subgraph for which SumErr = j=[1,m-1] maxEF(Gj, Gi) &lt; σ and SumErr + maxEF(Gm, Gi) ≥ σ.</p><p>Then starting from the m-th subgraph, for each subgraph in the sorted Gi.N ear, we do local propagation and update the PR scores of objects. We then update the list of the current top-k objects. If new objects are in the top-k and their corresponding subgraphs are not in SS, we include these subgraphs in SS and repeat the above steps until we have processed all subgraphs in SS. The postprocessing ensures that the maximal possible error in the ranking score of each top-k object is smaller than the error bound σ. THEOREM 7. Given a query Q, the maximum possible PR score that subgraph Gj can propagate to an object in Gi is:</p><formula xml:id="formula_21">maxEF(Gj, Gi) = IPS(Q, Gj) max bn∈border(G j ),b∈G i ( Pr bn (b))</formula><p>Pseudo-code and further explanations are given in Appendix B.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXPERIMENTAL STUDY 4.1 Experimental Settings</head><p>Algorithms. In addition to the two proposed algorithms, ES-EBC and S-EBC, we compare with the two baseline approaches in Appendix B.1. As Baseline 1 outperforms Baseline 2 significantly, we only report results for Baseline 1 and refer to this as "Baseline." Data and queries. We use three datasets that are real or based on real datasets. Table <ref type="table" target="#tab_1">1</ref> shows some properties ff the datasets; additional descriptions are provided in Appendix D. Hotel is a small dataset while GN is much bigger. The objects in both datasets have short descriptions. Web is a medium-sized dataset whose objects have long descriptions. We evaluate our approaches on these three different datasets. We generate 4 query sets, in which the number of keywords is 1, 2, 3, and 4, respectively, in the space of GN, and we generate 4 similar query sets for the space of Spam and Hotel. Each set comprises 200 queries, and each query is randomly generated. We report average costs of the queries in each query set. Setup. The IR-tree index structure is disk resident, and the page size is 16KB. The number of children of a node in the IR-tree is computed given the fact that each node occupies a page. This translates to 400 children per node in our implementation. The default values for parameters are as follows: k is 10, the number of query keywords is 2, α is 0.5 (Equation <ref type="formula" target="#formula_2">2</ref>), and β is 0.5 (Equation <ref type="formula" target="#formula_4">3</ref>) for all algorithms. S-EBC needs an extra parameter σ (to control its error bound; Section 3.3.4) that is set to 0.0001. Two threshold parameters for building graphs λ and ξ (Section 2) are set at 2 km and 0.5, respectively.</p><p>All algorithms were implemented in VC++, and run on an Intel(R) Core(TM)2 Duo CPU T7500 @2.66GHz with 2GB RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Experimental Results</head><p>The reported results are on GN if not stated otherwise. Varying k in LkPT. Figure <ref type="figure">2</ref> show the results of varying k when using the default settings for the other parameters.. Note that the y-axis uses a logarithmic scale.</p><p>We can see that ES-EBC and S-EBC significantly outperform (by an order of magnitude) the baseline for all values of k. ES-EBC performs better than the baseline due to the early stopping of propagation and punning of cells during score propagation. S-EBC outperforms the other two methods since it computes PR scores w.r.t. selected subgraphs rather than the whole graph as do the other two methods. As expected, the runtimes of all the approaches increase slightly with increasing k. Varying the number of keywords. Figure <ref type="figure" target="#fig_2">3</ref> shows that ES-EBC and S-EBC outperform the baseline for different numbers of keywords. All algorithms need more time as the number of keywords increases since they need to process more words. Varying α. Figure <ref type="figure">4</ref> shows that ES-EBC and S-EBC significantly outperform the baseline for all values of α. We also note that the Recall that parameter α can balance the relevance of an object versus the effect of its relevant neighbors. In particular, smaller values of α favor nodes with nearby relevant nodes, while larger values of α favor nodes with high initial PR scores. At one extreme, when α = 1, the LkPT query is essentially the same as LkT query <ref type="bibr" target="#b8">[8]</ref> that does not consider the effect of nearby relevant objects. Hence, we can see the overhead of considering the inter-relationships between objects by comparing with the runtime at α = 1 Varying β. Figure <ref type="figure">5</ref> shows the results. Parameter β in Equation <ref type="formula" target="#formula_4">3</ref>allows users to set their preferences between the PR score and spatial proximity. A large β means that the spatial distance is more important, while a small β means that the PR score is more important.</p><p>As expected, ES-EBC and S-EBC perform better for larger βthey benefit from spatial proximity being given higher weight. When spatial proximity is given very low weight, ES-EBC nearly cannot prune any cell, and S-EBC nearly cannot prune any subgraph and needs process the entire IR-tree. Scalability. To evaluate scalability, we generate 5 datasets containing from 2 to 10 million data points: we generate new locations by copying the locations in GN to nearby locations while maintaining the real distribution of the objects; and for each new location, a document is selected at random from the text descriptions of the objects in GN. Figure <ref type="figure" target="#fig_3">6</ref> shows that ES-EBC and S-EBC scale linearly with the size of the dataset, but that Baseline does not scale.</p><p>Summary on other experiments. The following experiments are included in Appendix D: Experiments on Web and Hotel. The results on the two datasets are consistent with those on GN. Varying the parameters for building graphs. When we increase λ or re- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>We briefly cover the most closely related work; Appendix E offers additional coverage. Spatial Keyword Search. Local search services, such as Google Maps and Yahoo! Local, allow the retrieval of local commercial content, e.g., relating to shops and restaurants, for a given query consisting of a location and a set of keywords. However, the algorithms used are not available. Similar applications include online yellow pages, online travel websites, and hotel search websites. Recent studies <ref type="bibr">[7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b22">22]</ref> on geographical retrieval address the problem of spatial keyword search. No existing work on spatial keyword search takes into account the inter-relationships among spatial objects. Personalized PageRank. Jeh and Widom <ref type="bibr" target="#b16">[16]</ref> propose the PPV concept and remark that pre-computing and storing all PPVs is impractical, as is computing PPVs at query time, since the computation of PPV needs an iterative computation over the web graph. Several algorithms <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b16">16]</ref> have been proposed to compute the personalized PageRank vector (PPV). However, Langville and Meyer <ref type="bibr" target="#b19">[19]</ref> write in a well-known survey "If the holy grail of realtime personalized search is ever to be realized, then drastic speed improvements must be made, perhaps by innovative new algorithms." PPVs are also used for keyword queries in entity-relation graphs <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b6">6]</ref>, as surveyed in Appendix E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>We propose a new type of query, the LkPT query, that retrieves the top-k spatial web objects ranked according to both location proximity and so-called prestige-based relevance that considers both the text relevance of an object to a query and the presence of nearby objects that are relevant to the query. We develop two baseline algorithms and propose two new algorithms to process the LkPT query. Results of empirical studies on real data demonstrate the effectiveness of LkPT the query and the efficiency of the new algorithms.</p><p>In future research, it is of interest to provide support for updates, as well as to consider the effect of nearby objects on rankings for other types of queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. VECTOR SPACE MODEL</head><p>The vector space model is defined as follows.</p><formula xml:id="formula_22">Sim(Q.ψ, o.ψ) = t∈Q.ψ o.ψ w Q.ψ,t w o.ψ,t W Q.ψ W o.ψ</formula><p>, where</p><formula xml:id="formula_23">w Q.ψ,t = ln(1 + |D| ft ), w o.ψ,t = 1 + ln(tf t,o.ψ ) W Q.ψ = t w 2 Q.ψ,t , W o.ψ = t w 2 o.ψ,t<label>(5)</label></formula><p>Here ft is the number of objects whose text descriptions contain the term t, and tf t,o.ψ is the frequency of term t in o.ψ. w o.ψ,t corresponds TF and w Q.ψ,t corresponds to IDF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. ALGORITHMS B.1 The Two Baseline Algorithms</head><p>Baseline 1: This algorithm computes PR scores of all objects and uses an R*-tree to incrementally compute the nearest neighbor in a second stage. When computing the PR scores, the algorithm obtains a list LPR that ranks the objects involved in ascending order of their scores. The algorithm then incrementally finds nearest neighbors <ref type="bibr" target="#b14">[14]</ref> using the R*-tree and checks the PR scores of the objects in LPR, until further objects will not become top-k results.</p><p>The tricky part is when to stop finding nearest neighbors. The algorithm maintains the minimum PR score in LPR, denoted by minPR, that has not been "seen" so far, and it maintains the combined ranking score (defined in Equation <ref type="formula" target="#formula_4">3</ref>) of the current k-th object, denoted by ξ.</p><p>For a newly "seen" object with spatial distance d , if the combined score (the lower the score, the better) computed from d and the current minPR exceeds ξ, the algorithm stops since it is guaranteed that all "unseen" objects will not have lower scores than the current k-th object (and thus cannot be in the result). Baseline 2. This algorithm computes the PR scores of all objects, thus obtaining a list LPR that ranks them in ascending order of their scores. The list is then scanned to compute the spatial proximity to the query until further scanning will not generate top-k results.</p><p>During the scan, the algorithm keeps track of the combined ranking score of the current k-th object, denoted by ξ. For a new object o, if its PR score exceeds ξ, the algorithm stops since all objects after o in LPR will have a score that exceeds ξ; otherwise, we retrieve its location, compute its combined ranking score (Equation <ref type="formula" target="#formula_4">3</ref>), and compare with ξ to update ξ if needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Pseudo-Code of ES-EBC</head><p>The pseudo-code of Early Stop EBC (ES-EBC) is shown in Algorithm 2. The variables p, q, and outPR are as in Algorithm 1. We use a priority queue Lr with the ranking score as its key to keep track of the current top-(k + 1) objects, and we use a vector L d to store the distances of the objects to the query.</p><p>We use an R*-tree index to incrementally find the next nearest object b to query Q (line 7). Termination occurs when the smallest possible ranking score (its distance to query) of the next object is larger than the current ranking score of the k-th object (lines 8-10).</p><p>We check whether the graph block containing b can be pruned according to Theorem 2 (lines 11-13). If the block graph bgi cannot be pruned, we do the propagation within the block using the same propagation mechanism as in lines 8-23 of Algorithm 1, and maintain the top-(k + 1) objects.</p><p>If object o is a nearest neighbor that has been accessed (i.e., L d (o) &gt; 0), we compute its ranking score and update Lr (lines <ref type="bibr" target="#b16">[16]</ref><ref type="bibr" target="#b17">[17]</ref><ref type="bibr" target="#b18">[18]</ref>.</p><p>After we find the set of candidate top-k objects, the algorithm proceeds to propagate the outgoing PR of each block in the graph (lines 19-34). When the upper bound of the k-th object is smaller than the lower bound of the (k + 1)-st object (line 32), we will stop the propagation and return the top-k objects in Lr according to Theorem 1. Note that although Theorem 2 is used in line 13, it is also applied in line 25 to prune block graphs since outPR(gbi) can be changed with the propagation. 19: blockQueue ← NewPriorityQueue() 20: for each block bg do 21: blockQueue.Enqueue(bg) 22: while q 1 ≥ ε do 23: bg i = blockQueue.Dequeue() 24: Os ← the furthest object in the current top-k 25:</p><formula xml:id="formula_24">Algorithm 2 ES-EBC (rtreeIndex, k, Q) Input: query Q, R*-tree rtreeIndex, result size k Output: top-k objects Lr 1: compute the text relevance of each object to Q and u Q 2: q ← u Q , p ← 0, L d ← 0, outPR ← 0 3: for each object b do 4: outPR(b.block) ← outPR(b.block) + q(b) 5: Lr ← NewPriorityQueue(); Initialize Lr with k + 1 objects whose key values are ∞ 6: while true do 7: b ← rtreeIndex.NextNearestNeighbor(Q) 8: L d (b) ← Dist(Q, b) 9: if CRS(Lr(k)) ≤ β * L d (b) maxD then 10: break 11: bg i ← b.block 12: Os ← furthest object in the current top-k 13: pruneDist ← λ log 1-α outPR(bg i ) + L d (Os) 14: if bg i is not processed AND Dist(Q, bg i ) &lt; pruneDist then</formula><formula xml:id="formula_25">pruneDist ← λ log 1-α outPR(bg i ) + L d (Os) 26: outP R(bg i ) ← 0 27: if Dist(Q, bg i ) &lt; pruneDist then 28:</formula><p>do propagation on bg i as in lines 8-23 of Algorithm 1 29: </p><formula xml:id="formula_26">for each object o s.t. o ∈ bg i and L d (o) &gt; 0 do 30: CRS(o) ← (1 -β) * (1 -p(o)) + β * L d (o) maxD 31: update Lr with o and CRS(o) 32: if CRS(Lr(k)) &lt; CRS(Lr(k + 1)) -(1 -β) * (α 2 max( q) + (1 -α) q 1 )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3 Pseudo-Code of S-EBC</head><p>The pseudo-code of Subgraph-based EBC (S-EBC) is given in Algorithm 3.</p><p>We use p to store the current PR score of each object, s to store the accumulated PR score (to be distributed) of the border nodes, and a priority queue queue to keep track of the nodes to be visited (lines 1-3).</p><p>In each step, we dequeue a node X from queue. If the minimum possible ranking score spRS of this node exceeds the ranking score of the current k-th object, we terminate the algorithm and return the results (lines 7-8).</p><p>If the node is a non-leaf node, we compute the smallest possible ranking score for each of its child nodes and enqueue them in queue (lines <ref type="bibr" target="#b10">[10]</ref><ref type="bibr" target="#b11">[11]</ref><ref type="bibr" target="#b12">[12]</ref>. Otherwise, we process the subgraph corresponding to the leaf node X by doing the PR score propagation within the subgraph and accumulating the PR scores for border objects (lines 17-27).</p><p>In lines 28-32 the global PR score vectors of border objects are used to distribute the accumulated PR scores at the border objects. We update the rankings of all the objects that have been accessed (lines 33-35) because the propagation in the current subgraph Gi may increase the PR of the objects in other subgraphs. To ensure that the maximal possible error in the ranking score of each top-k object is smaller than the error bound σ, we do postprocessing as discussed in Section 3.3.4 (line 36). </p><formula xml:id="formula_27">q ← u(G i )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>17:</head><p>while q 1 ≥ ε do  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:</head><p>for each out-neighbor j of b do 24: Lemma 1 holds because in each PR scoring iteration, a node will increase its current PR score. The proof of Lemma 2 follows from related work <ref type="bibr" target="#b13">[13]</ref>.</p><formula xml:id="formula_28">q(j) ← q(j) + (1 -α)C(b, j) q(b) 25: CRS(b) ← (1 -β)(1 -p(b)) + β Dist(Q,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 1</head><p>Given a query Q, we have RS(Q, Lr(k + 1)) ≥ Lower(Lr(k + 1)) and RS(Q, Lr(k)) ≤ Upper(Lr(k)).</p><p>Together with the condition in the theorem, we also have that RS(Q, Lr(k)) &lt; RS(Q, Lr(k + 1)). Consider an object m in Lr <ref type="bibr">[1, k -1]</ref> and an object n not in Lr. Because CRS(m) ≤ CRS(Lr(k)) ≤ CRS(Lr(k + 1)) ≤ CRS(n) and because of Equation <ref type="formula" target="#formula_10">4</ref>, we have Upper(m) ≤ Upper(Lr(k) &lt; Lower(Lr(k+ 1)) ≤ Lower(n). Thus, we have RS(Q, m) &lt; RS(Q, n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 2</head><p>According to the triangle inequality, we have Dist(os, Ωi) ≥ |Dist(Q, Ωi) -Dist(Q, os)|. Hence, the minimum number of edges in the path from Os to gb is |Dist(Q,Ω i )-Dist(Q,os)| λ .</p><p>In each propagation, an object will distribute the fraction (1 -α) of it PR score to other objects by following its out-edges. Therefore, it follows that an upper bound on the effect of Ωi on os is</p><formula xml:id="formula_29">outPR(Ωi)(1 -α) |Dist(Q,gb)-Dist(Q,os )| λ</formula><p>. If the upper bound is smaller than , the effect of graph block Ωi on os can be ignored (the effect on other objects in C is even smaller). From the inequality relationship between the upper bound and , when a block graph is far away, we can get:</p><formula xml:id="formula_30">Dist(Q, Ωi) &gt; λ log 1-α outPR(Ωi) + Dist(Q, os),</formula><p>which complete the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Lemma 3</head><p>We have that Pr </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 3</head><p>Similar to the linearity property of PPV <ref type="bibr" target="#b16">[16]</ref>, the linearity property also holds for the PR score vector. Hence, we can compute PrQ as follows:</p><formula xml:id="formula_31">PrQ = O∈D Sim(Q, O) PrO</formula><p>According to Lemma 3, we obtain:</p><formula xml:id="formula_32">PrQ = m j=1 O∈G j Sim(Q, O) PrO = m j=1 O∈G j Sim(Q, O)( LPO + h∈border (G j ) APO(h) • Pr h ) Proof of Lemma 4</formula><p>The largest PR score is generated in the following situation: One node has the largest initial PR maxO∈G i (Sim(t, O)). It distributes this value, and its out-neighbors gain at most IPS(t, Gi)α maxO∈G i (Sim(t, O)) PR; then the out-neighbors propagate at most (1 -α) (IPS(t, Gi) -α maxO∈G i (Sim(t, O))) to the node, and the node keeps the fraction α of this value, and it distributes the fraction (1 -α). In the next propagation, the out-neighbors send back (1 -α) 3 (IPS(t, Gi) -α maxO∈G i (Sim(t, O))). This process continues until no PR needs to be propagated. The total PR the node finally holds is:</p><formula xml:id="formula_33">maxLPr(t, Gi) = α max O∈G i (Sim(t, O)) + α(((1 -α) + ...+ (1 -α) 2n+1 + ...)(IPS(t, Gi) -α max O∈G i (Sim(t, O)))) =α max O∈G i (Sim(t, O)) + α * (1 -α) 1 -(1 -α) 2 (IPS(t, Gi) -α max O∈G i (Sim(t, O)))) = 1 + α -α 2 2 -α max O∈G i (Sim(t, O)) + 1 -α 2 -α IPS(t, Gi)</formula><p>Proof of Theorem 4</p><p>According to Lemma 3, the largest PR score from the propagation within Gi is maxLPr(t, Gi).</p><p>We next consider the effect of other subgraphs. The maximum effect of subgraph Gj on Gi occurs if a certain border node in Gj gets the initial prestige IPS(t, Gi). This is because all the effect of Gj on Gi is from border nodes. Each global PR vector of a border node in Gj describes its effect on nodes in Gi. We find the largest value from all the global PR vectors of border nodes, i.e., max bn∈border(G j ),b∈G i ( Pr bn (b)), and this is the maximum possible PR that can be propagated from Gj to a node in Gi.</p><p>Combining the two parts completes the proof.</p><p>Proof of Lemma 5 </p><formula xml:id="formula_34">IPS(Q, Gi) = O∈G i Sim(Q, O) = O∈G i t∈Q.ψ O.ψ w Q.ψ,t w O.ψ,t W Q.ψ W O.ψ = t∈Q.ψ G i .ψ O∈G i w Q.ψ,t w O.ψ,t W Q.ψ W O.ψ = t∈Q.ψ G i .ψ w Q.ψ,t W Q.ψ O∈G i w O.ψ</formula><formula xml:id="formula_35">IPS(Q, Gi) = t∈Q.ψ G i .ψ w Q.ψ,t W Q.ψ O∈G i Sim(t, O) = t∈Q.ψ G i .ψ w Q.ψ,t W Q.ψ IPS(t, Gi)</formula><p>Proof of Theorem 5 Given any object o ∈ XO and any term t, it holds true that maxGPr(t, X) ≥ Pr(t, o). Therefore,</p><formula xml:id="formula_36">maxPr(Q, X) = t∈Q.ψ X.ψ w Q.ψ,t W Q.ψ maxGPr(t, X) ≥ t∈Q.ψ o.ψ w Q.ψ,t W Q.ψ Pr(t, o) = Pr(Q, o)</formula><p>Proof of Theorem 6 Given any object o ∈ XO, we know that maxPr(Q, X) ≥ Pr(Q, o), according to Theorem 5. Because o is contained in the region X.Ω, we have Dist(Q.µ, X.Ω) ≤ Dist(Q, o). Hence we get minRS(Q, X) ≤ RS(Q, o).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 7</head><p>It holds that the maximum possible effect of Gj on Gi is a factor of max bn∈border(G j ),b∈G i ( Pr bn (b)). Multiplied by the total pres-tige of Gj, we can get the maximum PR that Gj can propagate to an object in Gi.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. SUPPLEMENTARY EXPERIMENTS D.1 Additional Dataset Details</head><p>Dataset GN is from the U.S. Board on Geographic Names (geonames.usgs.gov). An object is a location with a geographic name. Dataset Web is generated from two datasets. One is WEBSPAM-UK2007<ref type="foot" target="#foot_0">1</ref> that consists of a large number of web documents; the other is a spatial dataset containing the tiger Census blocks in Iowa, Kansas, Missouri, and Nebraska (www.rtreeportal.org). We randomly combine web documents and spatial objects to get the Web dataset. Dataset Hotel contains spatial objects that represent hotels in the US (www.allstays.com). Each object has a location and a set of words that describe the hotel (e.g., restaurant, pool).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.2 Experiments on Web and Hotel</head><p>Due to space limitations, we only give the results when varying k and the number of keywords. Figures <ref type="figure">7</ref><ref type="figure">8</ref><ref type="figure">9</ref><ref type="figure">10</ref>show that ES-EBC and S-EBC significantly outperform the baseline on the two datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.3 Space Requirements</head><p>Table <ref type="table" target="#tab_5">2</ref> shows the total sizes of the index structures used by each method for data set GN. Baseline and ES-EBC use the same indexes (inverted list and R*-tree) and object graph. S-EBC needs more disk space to store the PR vectors for border objects and the inverted lists in non-leaf nodes. The inverted files in the leaf nodes of the IR-tree are roughly the inverted file used in the baseline approach.</p><p>Baseline ES-EBC S-EBC 201 201 1423 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.4 Effectiveness</head><p>To study the utility of LkPT queries, we compare with the LkT query <ref type="bibr" target="#b8">[8]</ref>. The difference between LkPT and LkT <ref type="bibr" target="#b8">[8]</ref> is that the former considers the effect of nearby relevant objects, while the latter does not. The utility of LkPT queries. The lack of a publicly available test data, including both annotated resources and relevant queries, renders the comparison of the different approaches particularly challenging. To enable comparison, we collected a real spatial data set from the region of Aalborg, Denmark using a local Yellow Page service (www.degulesider.dk), where each object has category (e.g., restaurant, hotel) and a description; we geocoded the objects using the Google Maps API. The dataset contains 4,951 objects with a total of 39,505 descriptive words. This dataset has the benefit that we can find expert annotators for it.</p><p>We randomly generate 50 locations in the space and ask annotators to choose keywords for each, thus obtaining 50 queries.</p><p>To evaluate the quality of query results, we use a well-known metric, the nDCG <ref type="bibr" target="#b15">[15]</ref>. The top 5 objects returned by ES-EBC, S-EBC, and LkT <ref type="bibr" target="#b8">[8]</ref> are merged into a single list, shuffled, and then given to three annotators for judgment. Numerical scores of 0, 1, 2, and 3 are collected and averaged to reflect the annotators' opinions as to whether an object belongs in the top 5.</p><p>In LkPT (ES-EBC and S-EBC), α and β are set as to their default value of 0.5, and in LkT <ref type="bibr" target="#b8">[8]</ref>, the parameter that balances distance and text relevance (corresponding to β in LkPT) is set to 0.5.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. ADDITIONAL RELATED WORK</head><p>Spatial Keyword Search: Zhou et al. <ref type="bibr" target="#b22">[22]</ref> and Chen et al. <ref type="bibr">[7]</ref> handle the problem of retrieving web documents relevant to a keyword query within a pre-specified spatial region. The query processing there occurs in two stages: One type of indexing (e.g., inverted list) is used to filter web document in the first stage, and then another index (e.g., R-tree) is employed in the second stage. Felipe et al. <ref type="bibr" target="#b10">[10]</ref> propose a hybrid index structure that smartly integrates the R-tree with signature files. The hybrid index structure enables to utilize both spatial information and text information to prune the search space at query time. However, this proposal is limited by its use of signature files (e.g., the number of false matches is linear in the collection size and there is no sensible way of using signature files for handling ranking queries <ref type="bibr" target="#b23">[23]</ref>).</p><p>A hybrid index structure that combines the R*-tree and bitmap indexing is developed to process a new type of query called the m-closest keyword query <ref type="bibr" target="#b21">[21]</ref> that returns the closest objects containing at least m keywords. This index structure exhibits the same problems as does the signature-file based indexing <ref type="bibr" target="#b10">[10]</ref>.</p><p>The hybrid index structure called the IR-tree <ref type="bibr" target="#b8">[8]</ref> integrates the R-tree and inverted files to enable the efficient processing of the location-aware top-k ranking query by utilizing both location and text information to prune the search space.</p><p>Personalized PageRank: In contrast to PageRank <ref type="bibr" target="#b5">[5]</ref> that computes the global importance of nodes in a graph, personalized PageRank <ref type="bibr" target="#b16">[16]</ref> allows users to favor a set P of preferred nodes. The nodes in the preference set make a unit preference vector u where u(p) = 1/|P | if p ∈ P and u(p) = 0 if p / ∈ P , rather than distributing the unit preference score uniformly over all nodes in PageRank.</p><p>Several algorithms <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b16">16]</ref> have been proposed to compute the personalized PageRank vector (PPV). Jeh and Widom propose a remarkable Hub Decomposition algorithm <ref type="bibr" target="#b16">[16]</ref> that pre-computes the partial vectors for the nodes in a hub set of top-ranked pages. This algorithm can only compute the PPVs of the nodes in the hub set. To process the LkPT query, we need to pre-compute PR for every node, which renders the Hub Decomposition algorithm impractical in our problem.</p><p>Fogaras et al. <ref type="bibr" target="#b12">[12]</ref> propose a fingerprint-based algorithm that simulates random walks. The idea is to compute and store short random walks from each node in order to compute PPVs at query time. This works well to compute random walks from every node in the graph. However, this cannot be applied to computing a random walk from an arbitrary node, which is prohibitive at query time. This renders the proposal impractical for computing the PR scores in our problem.</p><p>More recently, Berkhin proposes a bookmark-coloring algorithm (BCA) <ref type="bibr" target="#b4">[4]</ref> that perhaps fits the best with our problem among the existing algorithms for computing PPVs. Its main idea is to diffuse scores in preference vector across the graph. A unit amount of score (called paint) is injected into a selected node (the bookmark node); a fraction of the paint is held by this node, and the rest flows by following the links of the graph. This propagation continues until the paint is distributed over the whole graph. In practice, the algorithm terminates when the paint to be distributed is smaller than a threshold.</p><p>PPVs are also ised for keyword queries in entity-relation graphs. In ObjectRank <ref type="bibr" target="#b1">[1]</ref>, a PPV for each keyword in a graph database is pre-computed. However, it is impractical to pre-compute the PPVs for each keyword when the vocabulary size is large <ref type="bibr" target="#b6">[6]</ref>.</p><p>Chakrabarti <ref type="bibr" target="#b6">[6]</ref> apply and extend PPVs to the keyword query on entity-relation graphs. This work is novel in how it chooses a set of nodes as hub nodes based on query logs; and it adopts the approach of Fogaras et al. <ref type="bibr" target="#b12">[12]</ref> to store approximate PPVs in the form of fingerprints. Block PageRank: There is a large body of work on global PageRank computation. Some works consider computations of global PageRank values over subgraphs (e.g., <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b17">17]</ref>). The problem of computing global PageRank is different from computing Prestigebase Relevance, and these proposals are therefore not directly applicable to our problem.</p><p>A final note is that two works <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b18">18]</ref> that employ the PageRank algorithm to do propagation on document similarity graphs focus on effectiveness without considering efficiency issues.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Let</head><label></label><figDesc>D be a set of spatial objects. Each object o in D has a text description o.ψ and a location o.µ. Similarly, a Location-aware top-k Prestige-based Text retrieval (LkPT) query Q = ψ, µ has a location Q.µ and a set of keywords Q.ψ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>LEMMA 1 .LEMMA 2 .</head><label>12</label><figDesc>Let pi(b) denote the PR score of object b in the i-th iteration during PR scoring. Then pi(b) ≤ pi+1(b). Given an object b, the final PR value p(b) of b and the value pi(b) of b in the i-th iteration fulfill the following:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 2: Varying k</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 4: Varying α</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>15 :</head><label>15</label><figDesc>do propagation on bg i as in lines 8-23 of Algorithm 1 16: for each object o s.t. o ∈ bg i and L d (o) &gt; 0 do 17: CRS(o) ← (1 -β) * (1 -p(o)) + β * L d (o) maxD 18: update Lr with o and CRS(o)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>18 :</head><label>18</label><figDesc>Pick an object b in G i 19: if b ∈ border(G i ) then 20: s(b) ← s(b) + q(b) 21:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>else 22 :</head><label>22</label><figDesc>p(b) ← p(b) + α q(b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>b) maxD 26: update the position of b in Lr 27: q(b) ← 0 28: for each object o in border(G i ) do 29: read the global PR vector GP o of object o 30:p ← p + s(o) GP o 31: CRS(o) ← (1 -β)(1 -p(o)) + β Dist(Q,o) maxD 32:update the position of o in Lr33:for each node o in seenObjects do 34:CRS(o) ← (1 -β)(1 -p(n)) + β Dist(Q,o) maxD 35: update the position of o in Lr 36: do the postprocessing 37: return Lr C. PROOFS OF LEMMAS, THEOREMS Proofs of Lemmas 1 and 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>b = Pr b (Gi) + Pr b (G -Gi), where Pr b (Gi) represents the distribution to nodes excluding the border nodes in Gi, and Pr b (G -Gi) represents the distribution to the rest nodes. When we finish distributing the PR in subgraph Gi, all the border nodes in Gi hold their accumulated PR scores that have not yet distributed to other subgraphs. The nodes in other subgraphs (G -Gi) are affected by these border nodes, and thus Pr b (G -Gi) = h∈border (G i ) AP b (h) • Pr h (G -Gi). The PR scores of the nodes in Gi come from two parts: the PR distribution within Gi, and the distribution of the accumulated PR scores of the border nodes in Gi. Hence, we have Pr b (Gi) = LP b + h∈border (G i ) AP b (h) • Pr h (Gi). We get the proof by adding Pr b (Gi) and Pr b (G -Gi).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :Figure 9 :Figure 10 :</head><label>7910</label><figDesc>Figure 7: Varying k (Web)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 11: Varying threshold λ (Hotel)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Gi)Here, maxo∈G i (Sim(t, o)) is the largest initial PR score in subgraph Gi for term t.Based on this lemma, we get the following theorem.THEOREM 4. We estimate maxGPr(t, Gi), the global upper bound PR score of an object in Gi for t, as follows: maxGPr(t, Gi) = maxLPr(t, Gi)+ Gi) is computed according to Definition 1, and IPS(t, Gj)• max bn∈border(G j ),b∈G i ( Pr bn (b)) represents the maximum possible PR score that can be propagated from Gj to a node in Gi.</figDesc><table><row><cell>j =i</cell><cell>IPS(t, Gj) •</cell><cell>max bn∈border(G j ),b∈G i</cell><cell>( Pr bn (b))</cell></row><row><cell>IPS(t,</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Dataset properties</figDesc><table><row><cell>Property</cell><cell>Hotel</cell><cell>Web</cell><cell>GN</cell></row><row><cell>Total number of objects</cell><cell>20,790</cell><cell>579,727</cell><cell>1,868,821</cell></row><row><cell>Total number of unique words</cell><cell>602</cell><cell>2,899,175</cell><cell>222,409</cell></row><row><cell>Total number of words</cell><cell cols="3">80,845 249,132,883 18,374,228</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>Index structure sizes (MB)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3</head><label>3</label><figDesc>depicts the results. Both ES-EBC and S-EBC perform significantly better than LkT queries that do not take into account the effects of nearby relevant objects. The approximate S-EBC algorithm performs slightly worse than ES-EBC.</figDesc><table><row><cell></cell><cell cols="2">ES-EBC S-EBC LkT [8]</cell></row><row><cell>nDCG@5</cell><cell>0.8873</cell><cell>0.8524 0.7061</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 :</head><label>3</label><figDesc>Effectiveness of different algorithmsD.5 Effects of Parameters on Graph BuildingFigures11 and 12show the runtime when we vary λ and ξ on Hotel. The runtime increases as we increase λ or decrease ξ. The reason is that the graphs become denser, making it take longer to propagate PR scores.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>barcelona.research.yahoo.net/webspam/datasets/uk2007</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The research was conducted when the authors were employed at Aalborg University, Denmark. C. S. Jensen is an Adjunct Professor at University of Agder, Norway.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Objectrank: authority-based keyword search in databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Balmin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="564" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Local approximation of pagerank and reverse PageRank</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Bar-Yossef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-T</forename><surname>Mashiach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="279" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The R*-tree: an efficient and robust access method for points and rectangles</title>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-P</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="322" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bookmark-coloring algorithm for personalized PageRank computing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Berkhin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internet Math</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="62" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The anatomy of a large-scale hypertextual web search engine</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Page</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Netw. ISDN Syst</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1-7</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dynamic personalized PageRank in entity-relation graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">www</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="571" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient query processing in geographic web search engines</title>
		<author>
			<persName><forename type="first">Y.-Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Suel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Markowetz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="277" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient retrieval of the top-k most relevant spatial web objects</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="337" to="348" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Finding question-answer pairs from online forums</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-I</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="467" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Keyword search on spatial databases</title>
		<author>
			<persName><forename type="first">I</forename><surname>De Felipe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rishe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="656" to="665" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal aggregation algorithms for middleware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lotem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="614" to="656" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Towards scaling fully personalized pagerank: Algorithms, lower bounds, and experiments</title>
		<author>
			<persName><forename type="first">D</forename><surname>Fogaras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rácz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Csalogány</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sarlós</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internet Math</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="333" to="358" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast algorithms for top-k personalized PageRank queries</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pathak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1225" to="1226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Distance browsing in spatial databases</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Hjaltason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="265" to="318" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Cumulated gain-based evaluation of IR techniques</title>
		<author>
			<persName><forename type="first">K</forename><surname>Järvelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kekäläinen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOIS</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="422" to="446" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Scaling personalized web search</title>
		<author>
			<persName><forename type="first">G</forename><surname>Jeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="271" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Exploiting the block structure of theweb for computing PageRank</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Kamvar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Haveliwala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Golub</surname></persName>
		</author>
		<idno>2003-17</idno>
		<imprint/>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Pagerank without hyperlinks: structural re-ranking using links induced by language models</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kurland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="306" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Deeper inside PageRank</title>
		<author>
			<persName><forename type="first">A</forename><surname>Langville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internet Math</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="335" to="380" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Indexing and ranking in Geo-IR systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Andrade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GIR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="31" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Keyword search in spatial databases: Towards searching by document</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Chee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mondal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kitsuregawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="688" to="699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Hybrid index structures for location-based web search</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-Y</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Inverted files for text search engines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comp. Surv</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
