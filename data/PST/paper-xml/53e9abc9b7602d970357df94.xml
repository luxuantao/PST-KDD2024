<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Finding Maximal k-Edge-Connected Subgraphs from a Large Graph</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rui</forename><surname>Zhou</surname></persName>
							<email>rzhou@swin.edu.au</email>
							<affiliation key="aff0">
								<orgName type="institution">Swinburne University of Technology Melbourne</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chengfei</forename><surname>Liu</surname></persName>
							<email>cliu@swin.edu.au</email>
							<affiliation key="aff1">
								<orgName type="institution">Swinburne University of Technology Melbourne</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jeffrey</forename><surname>Xu</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">The Chinese University of Hong</orgName>
								<address>
									<settlement>Kong Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Weifa</forename><surname>Liang</surname></persName>
							<email>wliang@cs.anu.edu.au</email>
							<affiliation key="aff2">
								<orgName type="institution">The Chinese University of Hong</orgName>
								<address>
									<settlement>Kong Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Baichen</forename><surname>Chen</surname></persName>
							<email>baichen@cs.anu.edu.au</email>
							<affiliation key="aff3">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Australian National University</orgName>
								<address>
									<settlement>Canberra</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jianxin</forename><surname>Li</surname></persName>
							<email>jianxinli@swin.edu.au</email>
							<affiliation key="aff4">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Australian National University</orgName>
								<address>
									<settlement>Canberra</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Finding Maximal k-Edge-Connected Subgraphs from a Large Graph</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4E002D57787E30CC7448739597D10211</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:03+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we study how to find maximal k-edge-connected subgraphs from a large graph. k-edge-connected subgraphs can be used to capture closely related vertices, and finding such vertex clusters is interesting in many applications, e.g., social network analysis, bioinformatics, web link research. Compared with other explicit structures for modeling vertex clusters, such as quasi-clique, k-core, which only set the requirement on vertex degrees, k-edge-connected subgraph further requires high connectivity within a subgraph (a stronger requirement), and hence defines a more closely related vertex cluster.</p><p>To find maximal k-edge-connected subgraphs from a graph, a basic approach is to repeatedly apply minimum cut algorithm to the connected components of the input graph until all connected components are k-connected. However, the basic approach is very expensive if the input graph is large. To tackle the problem, we propose three major techniques: vertex reduction, edge reduction and cut pruning. These speed-up techniques are applied on top of the basic approach. We conduct extensive experiments and show that the speed-up techniques are very effective.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Graphs are used to express the relationships of different objects for a wide range of applications. In social network analysis, individuals can be represented by vertices, and their friendship relations can be represented by edges. In bioinformatics, graphs can be used to model protein interactions and gene coexpressions. In web data management, web pages and their links can be considered as vertices and edges respectively. The common theme of these modelings is to represent an entity as a vertex (or node), and the relationship between two entities as an edge. As a result, many real-life problems can be transformed into mathematical problems on a graph, and then can be tackled with elegant solutions on the shelf.</p><p>In graph theory, connectivity is a fundamental subject. It has applications in a variety of traditional areas, such as network reliability analysis <ref type="bibr" target="#b7">[8]</ref>, VLSI chip design <ref type="bibr" target="#b13">[14]</ref>, transportation planning <ref type="bibr" target="#b2">[3]</ref>. A k-edge-connected graph is a connected graph that cannot be disconnected by removing less than k edges, similarly, a k-vertex-connected graph is a connected graph that cannot be disconnected by removing less than k vertices. We only focus on edge connectivity in this paper, because k-vertex-connectivity can be reduced to k-edge-connectivity, so k-connected is short for k-edgeconnected from now on.</p><p>On new types of data, finding k-connected subgraphs may be interesting as well. For example, in social network analysis, a k-connected subgraph could approximately model a community, here, k can be defined by a user to express how close the relationships are between members within a community. Different users may be interested in different k's. Efficiently discovering k-connected subgraphs helps users identify those closely related individuals, and such information could be useful for social behavior mining <ref type="bibr" target="#b1">[2]</ref>, viral marketing <ref type="bibr" target="#b3">[4]</ref>, etc. In computational biology, a k-connected subgraph could model a set of genes within the same functional module <ref type="bibr" target="#b25">[26]</ref>, here vertices represent the genes and edges represent coexpression relationships between the genes. A high-connected subgraph from a gene coexpression graph is likely to capture a functional gene cluster. Finding such subgraphs may assist biologists to analyze gene microarrays and develop reasonable conjectures before experiments. For a web-link graph, a high-connected subgraph may be a collection of web pages talking about a certain topic or discussing related topics. Such subgraphs may be useful for entity association mining from web pages or building a knowledge database based on web pages.</p><p>In a word, a k-connected subgraph captures a vertex cluster, where vertices within the cluster are closely related. There are some other defined structures playing a similar role, e.g., clique, quasi-clique (defined on vertices <ref type="bibr" target="#b29">[30]</ref> or edges <ref type="bibr" target="#b0">[1]</ref>), k-core <ref type="bibr" target="#b23">[24]</ref>, k-plex <ref type="bibr" target="#b22">[23]</ref>, etc. A clique defines a structure where every vertex is connected to the other vertices within the structure. Quasi-clique is a relaxed form of clique, and it asks a vertex to connect with other vertices no less than a predefined percentage, e.g., in a n-vertex γquasi-clique, each vertex is connected to at least ⌈γ • (n -1)⌉ other vertices. In a k-core, each vertex is connected to at least k other vertices. Similarly, in a n-vertex k-plex, each vertex is connected to at least (nk) vertices. After all, in presence of these existing explicit structures, why do we need to study k-connected subgraphs? We explain it in the next paragraph.</p><p>Firstly, cliques are too strong, because, in many real scenarios, it is unlikely that every entity would have a link to every other entity within the cluster. On the other hand, quasi-clique, k-core, k-plex are sort of weak in some situations. For example, in Fig. <ref type="figure" target="#fig_0">1</ref> (a), an 8-vertex graph is a 3/7-quasi-clique (defined on vertices), because each vertex is connected to at least three of the other vertices in the graph. Fig. <ref type="figure" target="#fig_1">1 (b</ref>) is also a 3/7-quasi-clique. Comparing Fig <ref type="figure" target="#fig_1">1 (a)</ref> and <ref type="bibr">Fig 1 (b)</ref>, they are both 3/7-quasi-cliques, having the same number of vertices and edges, and the same degree on each vertex. However, it is more appropriate to say: Fig. <ref type="figure" target="#fig_0">1</ref> (a) contains one vertex cluster while Fig. <ref type="figure" target="#fig_1">1 (b</ref>) contains two vertex clusters. In Fig. <ref type="figure" target="#fig_1">1 (c</ref>), the whole graph is a 5-core, because each vertex is connected to at least five other vertices. Its subgraph {A,B,C,D,E,F} (in a dashed rectangle) is also a 5-core. Comparing Fig. <ref type="figure" target="#fig_1">1 (c</ref>) and its subgraph {A,B,C,D,E,F}, they are both 5-cores, but Fig. <ref type="figure" target="#fig_0">1</ref> (c) should be considered as two vertex clusters. k-plex is similar to k-core, and has a similar problem.</p><p>The above discussion reminds us that connectivity in a subgraph is not negligible. Unfortunately, most existing defined structures are based on node degrees, ignoring the connectivity within the defined subgraph. It is well-known that checking connectivity is more expensive than checking node degrees. As a result, an efficient approach to discover k-connected subgraph is highly sought after. In this paper, we aim to find all maximal k-connected subgraphs, that is, k-connected subgraphs not contained in other kconnected subgraphs (a formal definition will be given in Section 2), otherwise (if not maximal) we can find too many k-connected subgraphs.</p><p>To guarantee the resulting subgraphs are k-connected, cut-based processing steps are unavoidable. A basic approach is to repeatedly run a minimum cut algorithm on the connected components of the input graph, and decompose the connected components if a less-than-k cut can be found, until all connected components are k-connected. Such solution is acceptable on smaller graphs, but is very expensive on large graphs. To tackle the problem, we design a set of speed-up methods. On one hand, we try to reduce the size of graph so that any cut algorithm can run faster on smaller graphs. This includes vertex reduction and edge reduction. On the other hand, we introduce some pruning conditions with which we can tell directly whether a connected component is k-connected or not.</p><p>We summarize our contributions as follows:</p><p>• We show that k-connected subgraphs may be a better means to model node clusters, compared with some existing models, such as k-cores and quasi-cliques.</p><p>• We propose a basic minimum-cut-based approach to find maximal k-connected subgraphs. More impor- • We conduct extensive experiments to test the algorithm performance when applying node reduction, edge reduction and cut pruning on top of the basic approach. The experiment results confirm that the speedup methods are very effective.</p><p>Here is a roadmap of this paper. In Section 2, we provide a formal definition of the problem, and introduce some necessary notations. In Section 4, we introduce vertex reduction and show its correctness. Edge reduction is introduced in Section 5. In Section 6, we introduce how to avoid cutting a connected component and how to cut a connected component into two halves earlier. Experiment results are shown in Section 7. Related works and conclusions are in Section 8 and Section 9 respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>We model networked data as a simple, unweighted, undirected graph G = (V, E), where V is a set of vertices and E is a set of edges between vertices. Normally, V represents entities and E represents the relationships between entities. In real world, there may be different types of relationships between two entities, but in this paper, we do not distinguish the types of relationships. That means, as long as two entities are related, no matter how many types of relations there are, we consider the two entities are connected by a single edge.</p><p>A graph G is k-connected (short for k-edge-connected) if the removal of any up to k -1 edges does not make G disconnected, and there exists an edge set Ecut with |Ecut| = k whose removal will make G disconnected. The edge set Ecut is called the cutset of a minimum cut. Note that G may have more than one minimum cut.</p><p>A graph Gs = (Vs, Es) is called an induced subgraph of a graph G = (V, E), when Vs ⊆ V , Es ⊆ (Vs × Vs) ∩ E, and for any two vertecies x, y ∈ Vs, edge (x, y) ∈ Es if and only if (x, y) ∈ E. Usually, an induced subgraph with vertex set Vs from G is denoted as G</p><formula xml:id="formula_0">[Vs]. A subgraph Gs = (Vs, Es) is a maximal k-connected sub- graph of G, if there does not exist another k-connected sub- graph G ′ s = (V ′ s , E ′ s ), such that Vs ⊆ V ′ s and E ′ s ⊆ Es.</formula><p>Apparently, it implies that a maximal k-connected subgraph is an induced subgraph.</p><p>The problem we will study in this paper is, given a graph G and a user-specified integer k, how to find all maximal k-connected subgraphs from G efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">BASIC APPROACH</head><p>In this section, we give a basic approach to find all maximal k-connected subgraphs. Important speed-up techniques will be introduced in Section 4, 5 and 6.</p><p>The idea of the basic approach is to repeatedly apply any minimum cut algorithm to the graph until each connected component is either a single vertex or a k-connected subgraph. Algorithm 1 describes the process. Throughout the process, R0 stores the intermediate results for the graph decomposition, i.e. the produced connected components. If a produced connected component G1 is at least k-connected, it will be added into the result set R (line 8); otherwise, G1 will be decomposed into two pieces {G2, G3} and added into R0 for later inspection (line 5-6). Theorem 1 guarantees the correctness of the algorithm.</p><p>Theorem 1. Given a graph G and a connectivity threshold k, Algorithm 1 correctly finds all maximal k-connected subgraphs from G.</p><p>Proof. Obviously, all subgraphs in the result set R are k-connected. We need to show each of them is maximal as well. Suppose a graph G0 = (V0, E0) ∈ R is not maximal, then there must be a maximal k-connected subgraph Gmax = (Vmax, Emax) such that V0 ⊂ Vmax, and there must also exist a cut in a certain loop produced by the step 3, which separates a vertex (or some vertices) in Vmax away from V0. However, such a cut cannot exist, because G[Vmax] is supposed to be k-connected. As a result, G0 should be maximal.</p><p>To show Algorithm 1 has found "all" maximal k-connected subgraphs: let (v1, v2) be an edge in a k-connected subgraph, since v1 and v2 are k-connected, (v1, v2) cannot be removed in the first loop (line 3-9) in Algorithm 1. Similarly, (v1, v2) cannot be removed in later loops. As a result, (v1, v2) will not be removed by Algorithm 1. This completes the proof of the "all" part. The theorem thus is correct.</p><p>In Algorithm 1, the critical step is Step 3, i.e. performing a cut-based algorithm on a graph. In fact, it is likely that the cut-based algorithm cannot be avoided because kconnectivity needs to be guaranteed on the resulting subgraphs. As a result, if we can speed up the cut-step (Step 3), the k-connected subgraph discovery process can be accelerated. It is obvious that a fast minimum cut algorithm is preferred for Step 3. However, in this paper, most of the time, we constrain ourselves to a general minimum cut algorithm, because we aim to design a framework to accommodate any minimum cut algorithm, not a particular one. As such, if a novel minimum cut algorithm would be found, it could then be plugged into our framework without any modification. In case, users feel overwhelmed by the number of minimum cut algorithms to choose from, we suggest one minimum cut algorithm and explain the reason in Section 6. Given a general minimum cut algorithm, we briefly discuss some ideas to accelerate the cut algorithm on graph G1, the details will be unfolded in Section 4, 5, 6:</p><p>• Reduce the size of G1: The performance of most minimum cut algorithms are affected by the size of the graph, i.e. the number of vertices and the number of edges. Therefore, it is desirable if we can safely reduce the size of G1 without affecting its connectivity, or exactly speaking without affecting the k-connectivity of those maximal k-connected subgraphs of G1. Consequently, we can run a cut algorithm on a smaller graph but produce the same result. Vertex reduction and edge reduction will be introduced in Section 4 and Section 5 respectively.</p><p>• Avoid performing the cut algorithm: Some readers may have noticed that an unpromising connected component (with no k-connected subgraph inside) may be found earlier, no need to be cut into a few single vertices. For example, if a simple graph G1 = (V1, E1) has no more than k vertices (|V1| ≤ k), G1 is at most (k -1)-connected (when G1 is a clique), and cannot be k-connected. So G1 can be disregarded earlier. Such speed-up tricks will be elaborated in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">VERTEX REDUCTION</head><p>In this section, we aim at reducing the number of vertices to speed up the basic minimum cut operation so that the whole discovery process can be accelerated. The idea is that if a subgraph Gs is k-connected we can safely contract the subgraph Gs into a new vertex vnew and the size of the original graph is reduced accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Contracting a k-connected subgraph</head><p>We will introduce the contraction process first and explain why this procedure is safe afterwards. Assume we have got a k-connected subgraph Gs = (Vs, Es), the contraction of Gs is as follows: (1) all vertices in Vs are replaced with a new vertex vnew; <ref type="bibr" target="#b1">(2)</ref> all edges between vertices belonging to Vs (not only those in Es) will disappear, e.g., any edge (v1, v2) will be disregarded if v1, v2 ∈ Vs; (3) an edge between a vertex in Vs and a vertex in V \Vs will remain in the result graph but with one end-vertex modified, e.g., any edge (v1, v2) will become (vnew, v2) if v1 ∈ Vs and v2 ∈ V \Vs. Note that the result graph may be a multiple graph, even though the original graph is simple, e.g., there are two edges (v1, v3), (v2, v3), let Vs = {v1, v2} and v3 ∈ V \Vs, after the contraction, there will be two edges between vnew and v3.</p><p>The following theorem guarantees that k-connectivity is consistent in the contracted graph and the original graph.</p><formula xml:id="formula_1">Theorem 2. Given a graph G = (V, E), let Gs = (Vs, Es) be a k-connected subgraph of G, let G ′ = (V ′ , E ′ ) be the graph produced from G by contracting Gs into a vertex vnew, for any vertex v ∈ V , we define image(v) ∈ V ′ as: (1) image(v) = vnew, if v ∈ Vs; (2) image(v) = v, if v ∈ V \Vs (remains the same), then we have: for any vertices v1, v2 ∈ V , v1, v2 are k-connected in G, if and only if either image(v1) = image(v2) = vnew or image(v1) and image(v2) are k-connected in G ′ .</formula><p>Proof. proof of "only if", given v1, v2 are k-connected in G:</p><p>Case (1): v1, v2 ∈ Vs, then obviously we have image(v1) = image(v2) = vnew.</p><p>Case (2): Without loss of generality, let v1 ∈ Vs, v2 ∈ V \Vs, i.e. image(v1) = vnew, image(v2) = v2, since v1, v2 are k-connected in G, there are k distinct paths between v1 and v2 in G, denoted as {p1, ..., p k }. Given one of these paths pi, let v last be the last vertex on pi from v1 to v2 satisfying image(v last ) = vnew and let p ′ i = pv last →v 2 denote the segment of pi from v last to v2 in G, it is not difficult to see that p ′ i is also a path from vnew to v2 in G ′ . Given that p ′ i is part of pi, together with that {p1, ..., p k } are distinct paths, we have {p ′ 1 , ..., p ′ k } are distinct paths from vnew to v2 in G ′ . As a result, vnew, v2 (or equally image(v1), image(v2)) are k-connected in G ′ .</p><p>Case (3): v1, v2 ∈ V \Vs, i.e. image(v1) = v1, image(v2) = v2. Since v1 and v2 are k-connected in G, again there are k distinct paths between them in G, denoted as {p1, ..., p k }. Given one of these paths pi, let v f irst and v last be the first and last vertices on pi from v1 to v2 satisfying image(v f irst ) = vnew and image(v last ) = vnew (here, v f irst , v last may be the same vertex.), let pv 1 →v f irst be a segment of pi from v1 to v f irst in G, pv last →v 2 be a segment of pi from v last to v2 in G, we can obtain p ′ i = pv 1 →v f irst + pv last →v 2 by concatenating the two segments pv 1 →v f irst and pv last →v 2 at v f irst and</p><formula xml:id="formula_2">v last . It is not difficult to see that p ′ i is a path from v1 to v2 in G ′ . Similarly, since {p1, ..., p k } are distinct paths, we have {p ′ 1 , ..., p ′ k } are distinct paths in G ′ . As a result, v1, v2 (or equally image(v1), image(v2)) are k-connected in G ′ .</formula><p>Note that, for a path pi, v f irst , v last may not always exist. If so, let p ′ i = pi and the other parts of the proof remain the same.</p><p>Proof of "if", given either image(v1) = image(v2) = vnew or image(v1) and image(v2</p><formula xml:id="formula_3">) are k-connected in G ′ : Case (1): image(v1) = image(v2) = vnew, then obviously v1, v2 ∈ Vs. As Gs is a k-connected subgraph, v1, v2 is k-connected in G.</formula><p>Case (2): Without loss of generality, let v1 ∈ Vs, v2 ∈ V \Vs, i.e. image(v1) = vnew, image(v2) = v2, since vnew and v2 are k-connected in G ′ , there are k distinct paths from vnew to v2 in G ′ . Recall that vnew in G ′ actually represents multiple vertices in G, as a result, there are k distinct paths from subgraph Gs to v2. We denote the starting vertices of these k distinct paths as {v1, ..., vk }, here {v1, ..., vk } ⊆ Vs and image(v1)</p><formula xml:id="formula_4">= ... = image(v k ) = vnew. Note that vi, vj (i ∈ [1, k], j ∈ [1, k], i = j)</formula><p>may be the same vertex. Now we will prove v1, v2 is k-connected in G by contradiction. Suppose there exists a cut Ecut (|Ecut| &lt; k) of G separating v1 and v2 into two components G1 = (V1, E1), G2 = (V2, E2) with v1 ∈ V1, v2 ∈ V2, (1) if {v1, ..., vk } ⊆ V1, then |Ecut &lt; k| contradicts that there are k distinct paths from {v1, ..., vk } to v2; (2) otherwise, let vi be a vertex separated into V2 by Ecut, given Gs is k-connected and v1, vi ∈ Vs, we have v1 and vi are k-connected, which also contradicts the existence of Ecut with |Ecut &lt; k|. Therefore, v1 and v2 are k-connected in G.</p><p>Case (3): v1, v2 ∈ V \Vs, i.e. image(v1) = v1, image(v2) = v2. Since v1, v2 are k-connected in G ′ , there are k distinct paths from v1 to v2 in G ′ , denoted as {p1, ..., p k }. If all these paths do not pass vnew, obviously, {p1, ..., p k } are also distinct paths from v1 to v2 in G and the proof is over. Otherwise, suppose the first t (t ∈ [1, k]) paths pass vertex vnew, construct the following graph Gt = (Vt = Vs ∪Vp, Et = Es ∪ Ep) by combining Gs and paths {p1, ..., pt}, here Vp denotes the vertices on paths {p1, ..., pt}, Ep denotes the edges on paths {p1, ..., pt}. According to case (2), for any vertex v ∈ Vs, v1, v are t-connected in Gt, similarly v2, v are also t-connected in Gt. From Lemma 1, we have v1, v2 are tconnected in Gt, i.e. there are t distinct paths in Gt from v1 to v2. These t distinct paths, together with {pt+1, ..., p k }, form k distinct paths from v1 to v2 in G. Therefore, v1, v2 are k-connected in G. With Theorem 2, we can safely proceed to deal with the contracted graph, but now the problem is how to discover a few k-connected subgraphs in advance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Finding a few k-connected subgraphs (not necessarily maximal)</head><p>We propose three methods to initially discover a few kconnected subgraphs. Intuitively, the more and the larger these discovered k-connected subgraphs are, the better the reduction effect can be achieved. However, it may take more time to discover more and larger k-connected subgraphs, and thus degrade the overall performance. It is unlikely to know a reasonable trade-off between the two aspects in advance. In our design, we put method efficiency at the first place, and the size of the initially discovered subgraphs at second due to the following reasons:</p><p>• It is difficult to find a maximal k-connected subgraph by expanding an existing k-connected subgraph<ref type="foot" target="#foot_0">1</ref> . We will give an example to show this in section 4.2.3. Consequently, it may not be worth the effort to find as many and as large k-connected subgraphs as possible, since finding these temporary subgraphs does not provide a shortcut to finding maximal k-connected subgraphs.</p><p>• To find k-connected subgraphs is only a subprocedure to reduce the number of vertices. It does not need to be perfect, but needs to be fast. So fast methods with reasonable quality are sufficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Using materialized views</head><p>If there are some precomputed maximal k ′ -connected subgraphs, as either materialized views or historical query results, we may use them as the bases to explore a few kconnected subgraphs. </p><formula xml:id="formula_5">• Case 1: If a maximal k ′ -connected subgraph G ′ has k ′ ≥ k, obviously G ′ is also k-connected,</formula><formula xml:id="formula_6">• Case 2: If a maximal k ′ -connected subgraph G ′ has k ′ &lt; k, then G ′ may contain induced subgraphs which are k-connected. In such case, if G ′ = (V ′ , E ′ ) is not very large (e.g., |V ′ | + |E ′ | ≤ B,</formula><p>where B is a predefined bound), we can find all maximal k-connected subgraphs from G ′ directly; otherwise, further vertex reduction and edge reduction can be performed on G ′ . Note that if we have got all maximal k ′ -connected subgraphs (when k ′ &lt; k), we can start from these k ′ -connected subgraphs without resorting to the original graph, because a k-connected subgraph is also k ′connected and must be subsumed in one of those maximal k ′ -connected subgraphs (Lemma 2).</p><p>Lemma 2. For a given graph, its maximal k-connected subgraphs are disjoint, i.e. If G1 = (V1, E1), G2 = (V2, E2) are two maximal k-connected subgraphs of the same graph G and G1 = G2, we have V1 ∩ V2 = ∅.</p><p>Proof. We prove the lemma by contradiction. Suppose</p><formula xml:id="formula_7">V1 ∩ V2 = ∅ and let v ∈ V1 ∩ V2, construct a new induced graph G[V1 ∪ V2], then for any two vertices v1, v2 ∈ V1 ∪ V2, if v1, v2 ∈ V1 or v1, v2 ∈ V2, obviously v1, v2 are k-connected in G[V1 ∪ V2] since G1, G2 are k-connected and G1, G2 are subgraphs of G[V1∪V2]; otherwise, without loss of generality, let v1 ∈ V1, v2 ∈ V2, from v1, v ∈ V1, we have v1, v are k- connected in G[V1 ∪ V2], similarly v2, v are also k-connected in G[V1 ∪ V2]. According to Lemma 1, v1, v2 are k-connected in G[V1 ∪ V2]. As a result, G[V1 ∪ V2] is k-connected, but this contradicts that G1, G2 are maximal k-connected subgraphs. Consequently, we have V1 ∩ V2 = ∅.</formula><p>In summary, as long as there is a precomputed maximal k ′ -connected subgraph G ′ (no matter k ′ is larger or smaller than k), we can use G ′ to help discover maximal k-connected subgraphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Using vertices with high degrees</head><p>The second method to find a few k-connected subgraphs is a heuristic method. It is inspired by the idea of work <ref type="bibr" target="#b6">[7]</ref>, which uses H*-graphs (comprised of vertices with higher degrees<ref type="foot" target="#foot_1">2</ref> ) of an original graph to initially find some cliques, and then expands these cliques to find a portion of maximal cliques from the original graph.</p><p>Similarly, we can discover some initial k-connected subgraphs using vertices with high degrees. To be specific, we can load into memory the vertices with degrees above a certain level, e.g., (1 + f ) • k where f &gt; 0, and find k-connected subgraphs using these "popular" vertices. The smaller f we choose, the more likely we can discover some k-connected subgraphs, but, at the same time, the more time we will spend on finding these initial k-connected subgraphs, because more nodes and edges need to be loaded into memory. In the implementation, given a memory pool to hold the vertices and edges, we can choose an f as small as possible on the condition that the memory pool does not overflow if we load all vertices with degree higher than (1 + f ) • k.</p><p>In fact, the heuristic method introduced in this section is reciprocal to the method using materialized views. At the beginning, a system has no materialized views, so some initial k-connected subgraphs could be discovered from scratch using the method in this subsection. As the system runs on, more and more materialized views will be available, and the materialized view based method will play a more important role since it is usually more efficient than finding initial k-connected subgraphs from scratch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Expanding existing k-connected subgraphs</head><p>The third method does not discover k-connected subgraphs from scratch. It takes existing k-connected subgraphs (possibly produced by the first and second methods) as input, and quickly expand the existing k-connected subgraphs in order to find larger ones. The expanding idea is: let a given k-connected subgraph be a core, let the core absorb neighbor vertices while keeping itself k-connected, stop the absorbing process when the core is not growing fast any more. Here, a neighbor vertex is a vertex not in the core, but is incident on an edge which has the other end in the core. Algorithm 2 illustrates the expanding process. The algorithm steps are self-explained. In step 4, the new G ′ s is guaranteed to be k-connected by Lemma 3. In step 5, θ ∈ [0, 1) is a userdefined threshold. The larger θ is defined, the larger G ′ s will be obtained and accordingly the more time the expanding process will take.</p><formula xml:id="formula_8">Lemma 3. Given a simple graph G, let Gs = (Vs, Es) be a k-connected subgraph of G, let Vn be a set of neighbor vertices of Gs in G, then induced subgraph G[Vs ∪ Vn] is k- connected if and only if ∀v ∈ Vn, deg(v) ≥ k in G[Vs ∪ Vn].</formula><p>Proof. The "only if" part is obvious. We now prove the "if" part. Firstly, according to Theorem 2, we can safely Algorithm 2 Expanding a k-connected subgraph Input: a k-connected subgraph Gs = (Vs, Es); Output: a larger k-connected subgraph G ′ s (G ′ s may stay the same as Gs.);</p><formula xml:id="formula_9">1: G ′ s ← Gs; 2: repeat 3: let all neighbor vertices of subgraph G ′ s = (V ′ s , E ′ s ) be V neighbor , generate an induced subgraph G[V ′ s ∪ V neighbor ] from the original graph; 4:</formula><p>repeatedly remove vertices with degree less than k from G[V ′ s ∪ V neighbor ] and assign the result graph as the new G ′ s (to be used in the next loop), let the vertices removed in this step be ∆V neighbor ; 5: until ∆V neighbor /V neighbor &gt; θ 6: return G ′ s ;</p><p>a v e r t e x r e p r e s e n t i n g a k -c o n n e c t e d s u b g r a p h </p><formula xml:id="formula_10">G ′ [Vs ∪ Vn] is k-connected. Fi- nally, from the "if" part of Theorem 2, we have G[Vs ∪ Vn] is k-connected.</formula><p>The expanding process is heuristic. It looks one step forward and tries to recruit closely related vertices. Basically, it manages to find a relatively large k-connected subgraph with affordable time budget. Interestingly, looking several steps ahead may not be better, because a comparable efficient algorithm is not obvious. Furthermore, it is unlikely to find a maximal k-connected subgraph by straightforwardly expanding an existing k-connected subgraph. Fig. <ref type="figure" target="#fig_2">2</ref> shows an example. Starting from the initial vertex representing a contracted 2-connected subgraph, it is not until we see the whole graph that we can find the maximal 2-connected subgraph.</p><p>Note that k-subgraphs discovered using materialized views according to Case 2 (from k ′ -connected subgraphs, k ′ &lt; k) do not need to be expanded any more, because they are </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EDGE REDUCTION</head><p>After contracting k-connected subgraphs into single vertices (in Section 4), the resulting connected components will usually be very dense. In order to efficiently cut the resulting connected components further, it is desirable to use a method not degraded by the large number of edges. In this section, we propose an iterative method based on edge reduction. We first introduce the idea, and then give theoretical foundations and algorithmic solutions for each step. To make the steps clear, we use a running example throughout the whole section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Reduction Idea</head><p>The reduction idea is to remove vertices by inspecting a sparser subgraph. The reduction includes three steps:</p><p>1. Keep the vertex set unchanged and only remove the edges. A graph G(V, E) will be reduced into G ′ (V, E ′ ), where E ′ ⊆ E and |E ′ | ≤ i(|V | -1) (here i ≤ k). We can guarantee that, if any two vertices in G are kconnected, then they are i-connected in G ′ .</p><p>2. With the above property, we know that all vertices in a k-connected subgraph Gs(Vs, Es) from G are pairwise i-connected in G ′ . Therefore, by discovering iconnected components from G ′ , we can obtain a vertex superset V ′ s of Vs, satisfying any two nodes in V ′ s are i-connected in G ′ . We can guarantee that Vs ⊆ V ′ s .</p><p>3. Using V ′ s , we can get a smaller induced subgraph G[V ′ s ] from G. Thereafter, we may either apply Algorithm 1 on G[V ′ s ] directly or repeat the reduction process again on G[V ′ s ] using another i ′ (here i &lt; i ′ ≤ k).</p><p>Readers are not required to fully understand the three steps at this stage, just need to know the rough picture. We will explain each step in detail in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Theoretical Foundation for Step One</head><p>The initiative is to reduce the size of edges in G so that a minimum cut algorithm can be faster. For instance, in the extreme case, |E| is in the size of |V | 2 . After the reduction, |E ′ | is in the size of i|V | (i &lt; k), at a lower order. The complexity of a typical minimum cut algorithm, due to Stoer and Wagner <ref type="bibr" target="#b26">[27]</ref>, will be reduced from</p><formula xml:id="formula_11">O(|V | 3 ) to O(|V | 2 log |V |), recall the complexity of the algorithm is O(|E||V | + |V | 2 log |V |).</formula><p>It is obvious that this reduction is especially important when input graph G is dense. Now we come to two questions: (a) Is the edge reduction safe? (b) How to do the reduction?</p><p>For the question (a), Lemma 4 can guarantee that: if any two vertecies in G are k-connected, then they are i-connected in G ′ . For the question (b), G ′ (V, E ′ ) can be constructed according to the description of Gi in Lemma 4. The set of spanning forests can be found in O(|E| + |V |) time, due to Nagamochi and Ibaraki <ref type="bibr" target="#b14">[15]</ref>.</p><formula xml:id="formula_12">Lemma 4. For a graph G = (V, E), simple or multiple, let F1 = (V, E1) be a spanning forest in G and Fi = (V, Ei) be a spanning forest in G -E1 ∪ E2 ∪ • • • ∪ Ei-1, for i = 2, 3, • • • , |E|, where possibly Ei = Ei+1 = • • • = E |E| = ∅ for some i. Then if an induced subgraph G[Vs] (Vs ⊆ V ) of G is k-connected, then, for any i &lt;= k, any two distinct vertices x, y ∈ Vs is i-connected in Gi = (V, E1 ∪ E2 ∪ • • • ∪ Ei).</formula><p>Proof. For any two distinct vertices x, y ∈ Vs, considering that the local edge-connectivity between x, y in G is no less than the local edge-connectivity between x, y in</p><formula xml:id="formula_13">G[Vs], given G[Vs] is k-connected, we have λ(x, y; G) ≥ k.</formula><p>Here λ(x, y; G) denotes the edge-connectivity between vertices x, y in G. According to lemma 2.1 in <ref type="bibr" target="#b15">[16]</ref>, λ(x, y; Gi) ≥ min{λ(x, y; G), i}, combining with λ(x, y; G) ≥ k ≥ i, we have λ(x, y; Gi) ≥ i.</p><p>We use an example to illustrate the process. See Fig. <ref type="figure" target="#fig_3">3</ref>, Ga is the original graph, let k = 5, so G[{A, B, C, D, E, F }] is a maximal 5-connected subgraph. After reduction step one, G b is the reduced graph using i = 3. G b can be denoted as G3(V, E1 ∪ E2 ∪ E3). Precisely speaking, E1 is the outer circle except the edge CD, E2 = {F A, F B, F C, F D, AE}, E3 = {AC, AD, BD, BE}. E1 is a spanning tree in Ga, E2 is a spanning tree in Ga -E1, E3 is a spanning tree in Ga -E1 ∪ E2, and E1, E2, E3 are all spanning forests. Since Ga, Ga -E1 and Ga -E1 ∪ E2 are all connected, the spanning forests happen to be spanning trees. It is not difficult to verify that any two nodes from {A, B, C, D, E, F } are 3-connected in G b .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">The Problem and Algorithmic Solutions for Step Two</head><p>As to the second step, after G ′ = (V, E ′ ) is obtained from the first step, we want to find all i-connected components in G ′ . An i-connected component is a set of vertices, and any two vertices in the set are i-connected in G ′ . Suppose Gs = (Vs, Es) is a maximal k-connected subgraph in G, then all the vertices in Vs fall into a certain i-connected component in G ′ , denoted as V ′ s . Obviously, Vs ⊆ V ′ s . The problem now is to find all these i-connected components from G ′ . In other words, i-connectivity on G ′ = (V, E ′ ) is an equivalence relation on V , and we want to all non-singleton equivalence classes from V with respect to this equivalence relation.</p><p>A straightforward method is to find edge-connectivity for all vertex pairs in G ′ , and then divide the vertices into groups. Lemma 1 guarantees the correctness. Naively, this process needs n 2 minimum s-t cut computation. Gomory and Hu <ref type="bibr" target="#b8">[9]</ref> showed that n -1 minimum s-t can do the job. Their algorithm computes a weighted cut-tree T from G ′ , known as the Gomory-Hu tree, with the property that the edge connectivity between any two vertices s and t in G ′ exactly equals the weight of the lightest edge in the unique s-t path in T . Furthermore, the partition of the vertices produced by removing this edge from T produces a minimum s-t cut to the graph G ′ .</p><p>Among the candidate algorithms, one algorithm that is specially suitable to solve the problem is due to Hariharan et al. <ref type="bibr" target="#b10">[11]</ref>. Their algorithm uses a graph and a userspecified k as input. The output of the algorithm is a tree T whose nodes represent k-connected components. To introduce more, the output is a weighted tree T whose nodes are vertex sets V1, V2, • • • , V l , a partition of V , with the property that the connectivity in G ′ between any two vertices s ∈ Vi and t ∈ Vj, for i = j, is equal to the weight of the lightest edge on the path between Vi and Vj in T . Also, two vertices s and t belong to the same Vi for any i if and only if they are at least k-connected in G ′ . The complexity of the algorithm is Õ(|E| + k 3 |V |).</p><p>Return to the example in Fig. <ref type="figure" target="#fig_3">3</ref>, on the reduced graph G b , vertices A, B, C, D, E, F are pairwise 3-connected. They are in the same 3-connected component. Other vertices like G, H, I are singleton 3-connected components, and can be safely pruned. As a result, the only 3-connected equivalent class we can find from G b is {A, B, C, D, E, F }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">An Example for Step Three</head><p>As to step three, apparently, if</p><formula xml:id="formula_14">Vs ⊆ V ′ s , then G[Vs] is a subgraph of G[V ′ s ].</formula><p>We are safe to deal with G[V ′ s ], a smaller graph compared to G, since G[V ′ s ] have filtered part of the vertices from the original graph G. In the example in Fig. <ref type="figure" target="#fig_3">3</ref>, the maximal k-connected subgraph has vertex set Vs is {A, B, C, D, E, F }, and the corresponding superset</p><formula xml:id="formula_15">V ′ s in G b is also {A, B, C, D, E, F }. G[V ′</formula><p>s ] and G[Vs] happen to be the same. After we get G[V ′ s ], we can either run Algorithm 1 to find the real results or repeat the reduction on G[V ′ s ]. In this example, G[V ′ s ] will not be further reduced, if we repeat the reduction with i ′ = 4 or 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">A Pitfall of Using Graph Reduction</head><p>In the second reduction step, suppose we have got Gi (i ≤ k) according to Lemma 4, some readers may ask whether we can perform Algorithm 1 on Gi to firstly obtain a set of induced i-connected subgraphs, and find induced subgraphs from G with the vertices in those i-connected subgraphs. For example, let</p><formula xml:id="formula_16">G ′ s = (V ′ s , E ′ s ) be an induced i-connected subgraph in Gi, is it safe to use G[V ′</formula><p>s ] as the input for further computation? In other words, given Gs = (Vs, Es) as a maximal k-connected subgraph in G, does it mean there must exist an induced i-connected subgraph</p><formula xml:id="formula_17">G ′ s = (V ′ s , E ′ s ) in Gi satisfying Vs ⊆ V ′ s ?</formula><p>Unfortunately, the answer is no. Refer to Gc in Fig. <ref type="figure" target="#fig_3">3</ref></p><formula xml:id="formula_18">, an induced 3-connected subgraph of G3 is G[{A, B, D, E, F }].</formula><p>Here, vertex C is cut off from the graph, because after vertex H is cut off from the graph, C is no longer 3-connected to vertices {A, B, D, E, F }. Consequently, in reduction step two, finding i-connected components cannot be replaced with finding induced i-connected subgraphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CUT OPTIMIZATION</head><p>Given a connected component, there are several cases when we do not need to run a minimum cut algorithm on the connected component. We can tell whether the connected component is k-connected or not by inspecting its vertex degrees. This can dramatically improve the algorithm performance. We first list the cases and then explain the rationale afterwards. Let G1(V1, E1) be a connected component, ∆(G1), δ(G1) be the maximum and minimum vertex degree in G1, v be a vertex in G1.</p><p>1. When G1 is simple and |V1| ≤ k, i.e. a connected component has no more than k vertices, the component does not have induced k-connected subgraphs, and hence can be disregarded.</p><p>2. When ∆(G1) &lt; k, i.e. the maximum degree of the vertices in the connected component G1 is less than k, it reflects that the component does not have induced k-connected subgraphs.</p><p>3. If a vertex v in G1 has deg(v) &lt; k, vertex v can be disregarded from the component. G1[V1 -{v}] may still have induced k-connected subgraphs.</p><p>4. If δ(G1) ≥ k, and δ(G1) ≥ ⌊|V1|/2⌋, then the connected component G1 is k-connected. We do not need to apply the minimum cut algorithm on G1.</p><p>We now explain the rationale behind those optimizations.</p><p>• For (1), if component G1 is simple, in any induced subgraph Gs(Vs, Es) from G, separating a node v from Gs requires to remove at most |Vs| -1 edges. (Here, |Vs| -1 ≤ |V1| -1 &lt; k, because G1 is simple and |V1| ≤ k.) In other words, there exists a cut set Ecut for Gs with |Ecut| &lt; k. As a result, κ(Gs) &lt; k. There is no induced k-connected subgraph in G1.</p><p>• As to (2), in any induced subgraph Gs(Vs, Es), separating a node v from Gs requires to remove at most ∆(G1) edges. Since ∆(G1) &lt; k, we have κ(Gs) &lt; k for a similar reason as (1). Note that (2) also holds for multiple graphs, if G1 is a simple graph, (1) is a special case of (2).</p><p>• For (3), the rationale is obvious, removing v is a special light-weighted cut.</p><p>• Finally, ( <ref type="formula">4</ref>) is supported by Theorem 1 in <ref type="bibr" target="#b4">[5]</ref>. We rephrase the theorem as Lemma 5 for easy reference.</p><p>According to Lemma 5 and δ(G1) ≥ k, we know G1 is k-connected if the conditions in (4) are satisfied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5. Let δ(G) be minimum degree among all vertices in</head><formula xml:id="formula_19">G(V, E), if δ(G) ≥ ⌊|V |/2⌋, then κ(G) = δ(G).</formula><p>All the above four optimizations are designed to avoid performing the minimum cut algorithm in line 3 in Algorithm 1. Condition checks (e.g., checking |V1| ≤ k, ∆(G1) &lt; k ) and variable maintenance (e.g., updating |V1|, ∆(G1), δ(G1), deg(v)) can be done together in O(|V | + |E|) time.</p><p>A careful reader may have found that it is not a must to find a minimum cut in line 3 in Algorithm 1: randomly choose a vertex v, and let A = {v}; 2: while A = V do 3: add into A the most tightly connected vertex from V ; 4: end while 5: merging the last two vertices added into A; 6: return the edge set E ′ cut between the last added vertex v last and the rest vertices V -{v last }; algorithm for our problem then? We suggest the minimum cut algorithm due to Stoer and Wagner <ref type="bibr" target="#b26">[27]</ref>, denoted by the SW algorithm, which provides an early-stop property, and is also reasonably efficient and easy to implement.</p><p>We give the SW algorithm in Algorithm 3 and 4 and introduce it briefly. Algorithm 3 is the outer loop, runs |V |-1 times, because after each loop, |V | will be decreased by 1, for the reason that two vertices are merged into one after each loop (see line 5 in Algorithm 4). In each loop from line 2 to line 8 in Algorithm 3, it finds a new min-cut for the current graph (line 3), and compares with the current cut. A smaller cut will be recorded. At the end of this algorithm, the recorded cut will be the minimum cut. The key steps are in Algorithm 4. It first selects a seed vertex, and repeatedly take out other vertices from |V | to join the seed vertex. In each round, the vertex having the highest connectivity with the seed set is selected and removed from |V |. In the end, the cut of the phase is the edge set E ′ cut between the last added vertex v last and the rest vertices V -{v last }. The last two vertices added into the seed set will be merged before the current procedure return to the main loop.</p><p>The SW algorithm solves the minimum cut problem using |V | - Finally, we give a combined algorithm in Algorithm 5 to incorporate all speed-up techniques in an overall framework. In Algorithm 5, we restrict ourselves to apply each reduction technique once. The order of the reduction techniques is carefully organized. However, we need to stress that Algorithm 5 is not the only acceptable solution. Each reduction technique may be applied multiple times and the order of some reduction techniques can be exchanged. For example, cut pruning check can be applied every time after a connected component is updated. We can also perform vertex reduction using available k-connected subgraphs first, and then expanding the resulting contracted vertices. Apparently, it is difficult to give an optimal algorithm that best organizes the speed-up techniques, because the effect of speed-up techniques is data-dependent. Nevertheless, Algorithm 5 is still valuable to provide a guideline on how to combine all the speed-up techniques in one framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTS</head><p>In this section, we report the performance of the basic algorithm and the performance of applying different speed-up techniques on top of the basic algorithm. The results show that the speed-up techniques can improve the performance significantly. All experiments are done on a desktop with </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Datasets</head><p>We use three datasets to test the algorithms, Epinions social network (soc-Epinions1) <ref type="bibr" target="#b19">[20]</ref>, Arxiv GR-QC collaboration network (ca-GrQc) <ref type="bibr" target="#b12">[13]</ref>, and Gnutella peer-to-peer network (p2p-Gnutella08) <ref type="bibr" target="#b20">[21]</ref>. Epinions social network is a who-trust-whom online social network of a general consumer review site (www.Epinions.com). Members of the site decide whether to trust each other. Arxiv GR-QC (General Relativity and Quantum Cosmology) collaboration network is from the e-print arXiv and it covers scientific collaborations between authors according to papers submitted to General Relativity and Quantum Cosmology category. Papers are from January 1993 to April 2003. Gnutella peer-to-peer network data is a snapshot of peer-to-peer file-sharing network in <ref type="bibr">August 8, 2002.</ref> All the above datasets are in Stanford Large Network Dataset Collection<ref type="foot" target="#foot_2">3</ref> . We give the details of each dataset in terms of number of vertices, edges, and average degrees in Table <ref type="table" target="#tab_4">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Effect of Cut Pruning</head><p>In this section, we report the effect of cut pruning (introduced in Section 6) solely without applying vertex reduction and edge reduction. Fig. <ref type="figure" target="#fig_5">4</ref> shows the result. We compare the basic approach (Naive) and the basic approach with cut pruning (NaiPru) on p2p network data and collaboration network data. On both datasets, the pure basic algorithm is rather slow, while after cut pruning, the performance is improved dramatically. When k becomes larger, the performance of NaiPru is improving as well. The reason is that when k is larger, more connected components can be pruned. In the following experiments, cut pruning is applied by default so that the baseline approach is not too slow. Cut pruning is orthogonal to vertex reduction and edge reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Effect of Vertex Reduction</head><p>In this section, we report the effect of vertex reduction. We test the result on two relatively large datasets collaboration network and Epinions network. Four variant approaches using vertex reduction are tested and compared with the NaiPru approach. Table <ref type="table" target="#tab_5">2</ref> gives the details of the approaches. Fig. <ref type="figure" target="#fig_9">5</ref> shows the experiment results. On collaboration network data, all four approaches have improved the performance significantly (note that the y-axis is in logarithmic scale, so looks not that impressive). Most of the time, expanding process can further improve the performance, especially when k is not large, because it is likely to find larger k-connected subgraphs using expansion. When k is large,   together with the expanding method in Section 4.2.3 e.g., k = 25, the NaiPru approach is also acceptable, while the vertex reduction effect is not obvious. The reason is that the resulting connected components are already of a small size. On Epinions network data, the expanding process is always effective. The reason is that edges of Epinions network are not evenly distributed. There exists a large cluster, and thus it is very likely to find a larger k-connected subgraph by expanding a k ′ -connected subgraph (k ′ &gt; k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Effect of Edge Reduction</head><p>In this section, we test the effectiveness of edge reduction. As mentioned in Section 5, we can reduce edge iteratively. However, the iteration steps should not be too many, otherwise extra cost will overwhelm the inherent subgraph discovery cost. We compare three approaches with NaiPru, denoted as Edge1, Edge2 and Edge3. Edge1 preforms edge reduction once. Edge2 reduces the graph using a k ′ (k ′ &lt; k) firstly, and then k. To generalize the case, we set k ′ = k/2. Similarly, Edge3 reduces the graph in three steps, k/3, 2k/3 and then k. Unlike vertex reduction, we did not test k = 6 for the collaboration network, neither k = 25 for the Epinions network. We want to test the case when k is enough large so that approach Edge3 makes sense. From Fig. <ref type="figure" target="#fig_7">6</ref>, we find that, on the network data, Edge1 is usually the best speed-up choice; when k = 20, Edge2 is slightly better than Edge1. The reason may be that the first step k/3 can effectively reduce the size of the graph. For all k's, Edge3 is the worst choice, even worse than ignoring edge reduction. This confirms that too much edge reduction is even more expensive. On the Epinions data, the result is similar. Edge1 is always better than the other approaches.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Effect of All Speed-up Techniques</head><p>In this section, we report the effect of all the combined speed-up techniques. The BasicOpt approach in this section stands for an approach after applying both vertex reduction and edge reduction on top of the NaiPru method. As to vertex reduction, if there is no materialized views, HeuExp will be used to achieve the largest reduction probability; oth-  erwise ViewExp will be used to use materialized views to support vertex reduction. Edge reduction is iterated once in BasicOpt, because most of time, one edge-reduction iteration is the best, though sometimes not as good as twice. On both collaboration network data and Epinions social network data, the BasicOpt approach is up to 10 times faster than the NaiPru approach. Further combining with Fig. <ref type="figure" target="#fig_5">4</ref>, BasicOpt is better than the Naive approach in order of magnitudes.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Graph connectivity is a fundamental subject in graph theory. Graph connectivity is closely related to minimum cut, since the minimum cut gives the graph connectivity. A large number of have been done on the design of minimum-cut algorithm <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b26">27]</ref>. However, these works focus on the global connectivity, i.e. the connectivity of the whole graph, while, in this paper, we aim to find a subgraph with connectivity guarantee. The most similar work to ours is <ref type="bibr" target="#b10">[11]</ref>, where an algorithm is given to find all pairs of vertices, each of which has a connectivity no less than k, but again, the connectivity is defined on the global graph, not constrained on a local subgraph. In other works, Yan et al. <ref type="bibr" target="#b28">[29]</ref> proposed to find frequent connected subgraphs from a large graph and connectivity is a constraint. Skygraph <ref type="bibr" target="#b17">[18]</ref> proposed to find all maximal connected subgraphs from a given graph. It does not have the k-edge-connected requirement, and hence algorithms are in a progressive manner and cannot be adapted to our problem. Karypis and Kumar <ref type="bibr" target="#b11">[12]</ref> developed a coarsening heuristic for a large graph. The aim is to reduce the input graph scale, similar to our graph reduction, but the techniques are different. Finally, in presence of many deterministic min-cut algorithms, Chekuri et al. <ref type="bibr" target="#b5">[6]</ref> showed the algorithms in <ref type="bibr" target="#b9">[10]</ref> and <ref type="bibr" target="#b14">[15]</ref> are fast in practice, and may be good candidates to resort to.</p><p>On the other hand, works on extracting subgraphs from a given graph can be divided into two categories: explicit and implicit. In explicit works, such as, quasi-clique <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b0">1]</ref>, k-core <ref type="bibr" target="#b23">[24]</ref>, k-plex <ref type="bibr" target="#b22">[23]</ref>, a structure with certain property is predefined, and then the rest work is to design efficient algorithms to discover all the subgraphs with the structure requirement. In implicit works, some propose objective functions first, such as modulariy <ref type="bibr" target="#b16">[17]</ref>, normalized cut <ref type="bibr" target="#b24">[25]</ref>, and then partition the graph into a number of parts, here a good partition usually maximizes or minimizes the objective functions; Some works define neighbourhood distance, such as propinquity <ref type="bibr" target="#b30">[31]</ref>, structure closeness <ref type="bibr" target="#b27">[28]</ref>, and then group nearby nodes within a distance threshold around a given node to form a group; Some borrow the idea of Markov Clustering <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b18">19]</ref> to repeat random walk for a few rounds until self-organized clusters turn up. Different from the implicit models, the maximal k-connected subgraphs we aim to find is explicitly defined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSIONS AND FUTURE WORK</head><p>In this paper, we have discussed how to find maximal kedge-connected subgraphs from large graphs. We have proposed a basic cut-based approach and develop several important speed-up techniques: vertex reduction, edge reduction and optimizing the cut algorithm. We have conducted extensive experiments to test the performance of the speed-up techniques. Compared with the basic approach, experimental results show that using speed-up methods can dramatically improve the performance. Vertex reduction is very effective when there are suitable materialized views, because the size of the original graph can be reduced significantly. The effect of edge reduction is moderate, not remarkable, because after discovering the k-connected components, we still need to find maximal k-connected subgraphs from those k-connected components.The cut pruning is very effective, and it is also easy to implement. One direction for future work is to design external memory algorithms to find maximal k-connected subgraphs from massive graphs, because some real graphs are too large to fit into memory.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Compare k-connected subgraph with other structures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 1 .</head><label>1</label><figDesc>Given a graph G = (V, E) and three vertices {va, v b , vc} ⊆ V , if va, v b are k-connected and v b , vc are k-connected, then va, vc are k-connected.Proof. We prove the lemma by contradiction. Suppose va, vc are not k-connected, there must exist a cut Ecut separating G into two components G1 = (V1, E1), G2 = (V2, E2) with |Ecut| &lt; k. Without lose of generality, assume va ∈ V1 and vc ∈ V2, since V = V1 ∪ V2 and V1, V2 are disjoint, v b must be in either V1 or V2. If v b ∈ V1, the existence of Ecut contradicts that v b , vc are k-connected, otherwise the existence of Ecut contradicts that v b , va are k-connected.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Expanding the graph to the end</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The example of graph reduction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Cut Pruning</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Edge Reduction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Vertex Reduction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The Combined Effect</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1. Any cut E ′ cut with |E ′ cut | &lt; k can be used to cut G1, and guarantees the correctness of the algorithm. So what is a desirable min-cut</figDesc><table><row><cell cols="4">Algorithm 3 MinimumCut(G)</cell><cell></cell><cell></cell></row><row><cell cols="6">Description: find a minimum cut for graph G</cell></row><row><cell cols="3">Input: a graph G(V, E);</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Output:</cell><cell>a</cell><cell cols="2">min-cut</cell><cell>edge</cell><cell>set</cell></row><row><cell>Ecut;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">1: initialize Ecut = V ;</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">2: while |V | &gt; 1 do 3: E ′ cut = MinimumCutPhase(G); 4: if |Ecut| &gt; |E ′ cut | then 5: Ecut = E ′ cut ;</cell><cell></cell></row><row><cell>6:</cell><cell>end if</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">7: end while</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">8: return Ecut</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Algorithm 4 MinimumCutPhase(G)</cell><cell></cell></row><row><cell cols="6">Description: find an s-t cut and merge two vertices</cell></row><row><cell cols="3">Input: a graph G(V, E)</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Output:</cell><cell>the</cell><cell>edge</cell><cell>set</cell><cell>incident</cell><cell>on</cell></row><row><cell>v last ;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1 minimum s-t cut computations. A s-t cut is the minimum cut for graph G, which can separate vertex s, t into two different connected components. The global minimum cut is the lowest value among the |V | -1 s-t cuts. Return to our problem, if any Ec among these |V | -1 cuts satisfying |Ec| &lt; k, we can stop finding other s-t cuts on G1 and separate G1 into two connected components safely using Ec. We refer this property as early-stop property. Furthermore, the SW algorithm has good theoretical complexity at O(|E||V | + |V | 2 log |V |). It is not a flow-based algorithm, and is easy to implement.</figDesc><table><row><cell cols="4">Algorithm 5 Combined Algorithm</cell></row><row><cell cols="4">Input: a graph G, connectivity threshold k;</cell></row><row><cell cols="2">Output:</cell><cell cols="2">a set of maximal k-connected subgraphs</cell></row><row><cell>R;</cell><cell></cell><cell></cell></row><row><cell cols="4">1: if there are maximal k ′ -connected subgraphs, k ′ ∈</cell></row><row><cell></cell><cell cols="3">{k1, ..., kn} then</cell></row><row><cell>2:</cell><cell cols="2">let k = max i∈[1,n]</cell><cell>{ki|ki &lt; k} ;</cell></row><row><cell>3:</cell><cell cols="3">set the maximal k-connected subgraphs as R0, the</cell></row><row><cell></cell><cell cols="3">initial set of connected components;</cell></row><row><cell>4:</cell><cell cols="2">let k = min i∈[1,n]</cell><cell>{ki|ki &gt; k} ;</cell></row><row><cell>5:</cell><cell cols="3">set the maximal k-connected subgraphs as initially</cell></row><row><cell></cell><cell cols="3">discovered k-connected subgraphs V0;</cell></row><row><cell cols="2">6: else</cell><cell></cell></row><row><cell>7:</cell><cell cols="3">use the heuristic method in Section 4.2.2 to find a few</cell></row><row><cell></cell><cell cols="3">k-connected subgraphs V0;</cell></row><row><cell cols="2">8: end if</cell><cell></cell></row><row><cell cols="4">9: expand V0 to find larger k-connected subgraphs accord-</cell></row><row><cell></cell><cell cols="3">ing to Section 4.2.3;</cell></row><row><cell cols="4">10: perform vertex reduction to R0 using V0;</cell></row><row><cell cols="4">11: perform edge reduction to R0;</cell></row><row><cell cols="4">12: for each component G1(V1, E1) (|V1| = 1) in R0 do</cell></row><row><cell>13:</cell><cell cols="3">if G1 can be pruned without evaluating minimum cut</cell></row><row><cell></cell><cell>then</cell><cell></cell></row><row><cell>14:</cell><cell cols="3">R0 := R0 -{G1};</cell></row><row><cell>15:</cell><cell>else</cell><cell></cell></row><row><cell>16:</cell><cell cols="3">if there exists any cut (not necessarily a minimum</cell></row><row><cell></cell><cell cols="3">cut) with cutset Ecut satisfying |Ecut| &lt; k then</cell></row><row><cell>17:</cell><cell cols="3">cut G1 into G2, G3 by removing Ecut;</cell></row><row><cell>18:</cell><cell cols="3">R0 := R0 ∪ {G2, G3} -{G1};</cell></row><row><cell>19:</cell><cell cols="2">else</cell></row><row><cell>20:</cell><cell cols="3">R := R ∪ {G1};</cell></row><row><cell>21:</cell><cell cols="2">end if</cell></row><row><cell>22:</cell><cell cols="2">end if</cell></row><row><cell cols="2">23: end for</cell><cell></cell></row><row><cell cols="3">24: return R;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">: Datasets</cell><cell></cell></row><row><cell></cell><cell>vertices</cell><cell>edges</cell><cell>avg degree</cell></row><row><cell>Gnutella P2P network</cell><cell>6301</cell><cell>20777</cell><cell>3.30</cell></row><row><cell>Collaboration network</cell><cell>5242</cell><cell>28980</cell><cell>5.53</cell></row><row><cell>Epinions network</cell><cell>75879</cell><cell>508837</cell><cell>6.71</cell></row><row><cell cols="4">Intel(R) Core(TM) 2 Duo CPU E6550 at 2.33GHz and 3GB</cell></row><row><cell cols="4">RAM. The operating system is Windows XP, and code is</cell></row><row><cell>written in Java.</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>The Meanings of the Approaches</figDesc><table><row><cell>HeuOly</cell><cell>use only the heuristic method in Section 4.2.2</cell></row><row><cell></cell><cell>to find a number of k-connected subgraphs,</cell></row><row><cell></cell><cell>and then do vertex reduction using</cell></row><row><cell></cell><cell>these subgraphs;</cell></row><row><cell>HeuExp</cell><cell>use the heuristic method in Section 4.2.2</cell></row><row><cell></cell><cell>and the expanding method in Section 4.2.3 to</cell></row><row><cell></cell><cell>find a number of k-connected subgraphs, and</cell></row><row><cell></cell><cell>then do vertex reduction</cell></row><row><cell cols="2">ViewOly use only the materialized views (Section 4.2.1)</cell></row><row><cell></cell><cell>to find a number of k-connected subgraphs,</cell></row><row><cell></cell><cell>and then do vertex reduction using</cell></row><row><cell></cell><cell>these views;</cell></row><row><cell cols="2">ViewExp use the the materialized views (Section 4.2.1)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>There may be a brilliant method to achieve this, but, at the current stage, the problem is open.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This is a rough idea, interested readers could refer to the paper for a more accurate definition of H*-graph.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://snap.stanford.edu/data/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work is supported by the grant of Australian Research Council Discovery Project No. DP120102627 and the grant of Research Grants Council of the Hong Kong SAR, China, No. 419109. We would like to thank anonymous reviewers for their helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Massive quasi-clique detection</title>
		<author>
			<persName><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G C</forename><surname>Resende</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LATIN</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="598" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mining newsgroups using networks arising from social behavior</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajagopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on World Wide Web, WWW &apos;03</title>
		<meeting>the 12th international conference on World Wide Web, WWW &apos;03<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="529" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Iida</surname></persName>
		</author>
		<title level="m">Transportation Network Analysis</title>
		<imprint>
			<publisher>John Wiley &amp; Sons, Inc., USA</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Social ties and word-of-mouth referral behavior</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Reingen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Consumer Research: An Interdisciplinary Quarterly</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="350" to="362" />
			<date type="published" when="1987-12">December 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A graph-theoretic approach to a communications problem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Chartrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="778" to="781" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Experimental study of minimum cut algorithms</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chekuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="324" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Finding maximal cliques in massive networks by h*-graph</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="447" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The Combinatorics of Network Reliability</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Colbourn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Oxford University Press, Inc</publisher>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multi-terminal network flows</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Gomory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Society for Industrial and Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="551" to="570" />
			<date type="published" when="1961">1961</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A faster algorithm for finding the minimum cut in a graph</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Orlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="165" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient algorithms for computing all low s-t edge connectivities and related problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kavitha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Panigrahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="127" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A fast and high quality multilevel scheme for partitioning irregular graphs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Sci. Comput</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="359" to="392" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Graph evolution: Densification and shrinking diameters</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Knowl. Discov. Data</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="2007-03">March 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Connection autonomy in simd computers: a vlsi implementation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maresca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="302" to="320" />
			<date type="published" when="1989-10">October 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Computing edge-connectivity in multigraphs and capacitated graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Nagamochi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ibaraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Discrete Math</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="54" to="66" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A linear-time algorithm for finding a sparse k-connected spanning subgraph of a k-connected graph</title>
		<author>
			<persName><forename type="first">H</forename><surname>Nagamochi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ibaraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5&amp;6</biblScope>
			<biblScope unit="page" from="583" to="596" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Finding and evaluating community structure in networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Girvan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review E</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="page">26113</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Skygraph: an algorithm for important subgraph discovery in relational graphs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lyritsis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Manolopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Min. Knowl. Discov</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="76" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Computing communities in large networks using random walks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Latapy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="191" to="218" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Trust management for the semantic web</title>
		<author>
			<persName><forename type="first">M</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="351" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Mapping the gnutella network: Properties of large-scale peer-to-peer systems and implications for system design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ripeanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">T</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Iamnitchi</surname></persName>
		</author>
		<idno>cs.DC/0209028</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scalable graph clustering using stochastic flows: applications to community discovery</title>
		<author>
			<persName><forename type="first">V</forename><surname>Satuluri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="737" to="746" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A graph-theoretic generalization of the clique concept</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Seidman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Mathematical Sociology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="139" to="154" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Network structure and minimum degree</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Seidman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Networks</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="269" to="287" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Normalized cuts and image segmentation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="888" to="905" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Protein complexes and functional modules in molecular networks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Spirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Mirny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The National Academy of Sciences</title>
		<meeting>The National Academy of Sciences</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="12123" to="12128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A simple min-cut algorithm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stoer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="585" to="591" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Scan: a structural clustering algorithm for networks</title>
		<author>
			<persName><forename type="first">X</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yuruk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A J</forename><surname>Schweiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="824" to="833" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Mining closed relational graphs with connectivity constraints</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">J</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="324" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Out-of-core coherent closed quasi-clique mining from large dense graph databases</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Parallel community detection on large networks with propinquity dynamics</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="997" to="1006" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
