<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">AUTONOMIA: An Autonomic Computing Environment*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xiangdong</forename><surname>Dong</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Salim</forename><surname>Hariri</surname></persName>
							<email>hariri@ece.arizona.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lizhi</forename><surname>Xue</surname></persName>
							<email>lzxue@ece.arizona.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Huoping</forename><surname>Chen</surname></persName>
							<email>hpchen@ece.arizona.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ming</forename><surname>Zhang</surname></persName>
							<email>mingz@ece.arizona.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sathija</forename><surname>Pavuluri</surname></persName>
							<email>pavuluri@ece.arizona.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Soujanya</forename><surname>Rao</surname></persName>
							<email>soujanya@ece.arizona.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<author>
							<persName><surname>Tucson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">Autonomic Computing Laboratory</orgName>
								<orgName type="institution">University of Arizona</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">AUTONOMIA: An Autonomic Computing Environment*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">10173CFE8E717615FF78F2DB362B29E4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The prolifeation of Internet technologies, services and devices, have made the current networked system designs, and management tools incapable of designing reliable, secure networked systems and services. In fact, we have reached a level of complexity, heterogeneity, and a rapid change rate that our information infiastructure is becoming unmanageable and insecure. This had led researchers to consider alternative designs and management techniques that are based on strategies used by biological systems to deal with complexity, heterogeneity and uncertainty. The approach is referred to as autonomic computing. An autonomic computing system is the system that has the capabilities of being sevdefining, self-healing, self-configwing, self-optimizing, etc. In this paper, we present our approach to implement an autonomic computing infastructure, Autonomia that provides dynamically programmable control and management services to support the development and deployment of smart (intelligent) applications. The A UTONOMIA environment provides the application developers with all the tools required to specifj, the appropriate control and management schemes to maintain any quality of service requirement or application attribute/firnctionality (e.g., perjormance, fault, security,  etc.)  and the core autonomic middleware services to maintain the autonomic requirements of a wide range of network applications and services. We have successfully implemented a proof-of-concept prototype system that can support the self-configuring, self-deploying and selfhealing of any networked application.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The wide deployment of Internet technology has resulted in exponential growth in Internet application services (e.g., content hosting for data with web-based access, shared payroll applications, firewall-based security services, email and shared file services). The management and control of these application services is a challenging research problem due to the huge amount of data that needs to be collected and coordinated, the heterogeneity and the independence of resources and components <ref type="bibr">[IO]</ref> required by these services and the fact that they run under different organizations and administration policies.</p><p>Further this problem is exacerbated with the proliferation of computer devices that has grown at exponential rates. In addition, demand is already outpacing supply when it comes to managing complex, and even simple computer systems. As access to information becomes omnipresent through PC's, handheld and wireless devices, the stability of current infrastructure, systems, and data is at an increasingly greater risk to suffer outages and general disrepair. In the process, the systems have become increasingly difficult to use. This complexity has led to a situation where the cost to manage such systems is actually a lot more than the actual systems themselves [3]. Consequently, the growing complexity of the IT infrastructure threatens to The work presented here was supported by the National Science Foundation via grants numbers ACI 9984357 (CA-REERS), EIA 0103674 (NGS) and by DOE ASCVASAP (Caltech) via grant number PC295251.</p><p>undermine the very benefits information technology aims to provide.</p><p>A potential solution to these challenging research problems can be drawn from biological systems which have been very successful in controlling and managing complex, interactive, constrained systems. This solution approach is known as the Autonomic Computing that calls for designing distributed information systems that can automatically configure, deploy, secure, tolerate faults, optimize, and anticipate loads by themselves without the manual involvement of human administrators.</p><p>In this paper, we present an autonomic architecture to achieve automated control and management of networked applications and their infrastructure. We have successfully implemented a proof-of-concept prototype, referred to as AUTONOMIA, that implements two important properties of autonomic systems: self-configuring and self-healing.</p><p>The organization of this paper is as follows. In Section 2, we give a brief overview of autonomic computing and its main properties. In Section 3, we present a brief overview of related approaches and techniques. In Section 4, we give an overview of our approach to implement an autonomic computing system. In Section 5, we present in W h e r detail our implementation approach and the technologies used to implement the proof-of-concept prototype "AUTONOMIA". In Section 6, we conclude the paper and discuss our future research activities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Autonomic Computing: The next era of computing</head><p>IBM has recently launched a major research effort toward the development of autonomic computing systems and services [3]. The basic approach is to build computing systems that are capable of managing themselves; that can anticipate their workloads and adapt their resources to optimize their performance. This approach has been inspired by the human autonomic nervous system that has the ability to self-configure, self-tune and even repair themselves without any human conscience involvement.</p><p>The concept of developing the next era of computing systems is driven by the convergence between the biological systems and the digital computing systems. To demonstrate the inefficiency of our approach to build the next generation of networked systems, just imagine if we apply our current design and management tools of distributed systems to implement the human central nervous system. That means, when a person jogs, helsh needs to continuously monitor and adjust as appropriate the heart rate, the body temperature, blood pressure, send appropriate messages to selected areas of human body, etc. It is clear that it is almost impossible to do all these functions while a person is jogging; the person needs to focus on jogging rather than monitoring and adjusting a wide range of neurons and their systems.</p><p>Paul Hom [l] in his pioneering article on autonomic computing has identified a set of eight key elements or characteristics that form the criteria for a system to be classified as being an Autonomic Computing system. While the defintion of autonomic computing will likely transform as contributing technologies mature, the following list suggests eight defining characteristics of an autonomic system: Self-Defining, Self-Protecting, Self-Optimizing, Self-Healing, Self-Configuring, Contextually Aware, Open and Anticipatory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Related Works</head><p>There are several projects that are aimed at developing high performance programming models to develop large-scale distributed applications (Grid computing) that seamlessly allocate and obtain resources from the Grid infrastructure. Javelin of UCSB In this paper, we present our approach to develop an autonomic computing infrastructure that supports complete control and management service in our prototype system, which we refer to as Autonomiu. Autonomiu will essentially provide dynamic programmable control and management services to support the development and deployment of smart applications, automate performance and fault tolerant support for smart applications, provide automated deployment, registration, discovery of components, allow automated configuration of applications and system resources and finally provide a secure, open computing environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Autonomia Design Approach</head><p>The objective of this project is to automate deployment of mobile agents that have self-manageable attributes. The architecture of Autonomia is based on two previous projects: Adaptive Distributed Virtual Computing Environment (ADViCE) and CATALINA -A</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proactive Application Control and Management System</head><p>The Autonomia environment provides application developers with all the tools required to specify the appropriate control and management schemes, deploy and  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Application Management Editor (AME)</head><p>It provides application developers with the services required for specifying an application's autonomic requirements (e.g. self-optimizing and self-healing) and also specifies the appropriate autonomic schemes to maintain the application requirements. The main hnctions of the editor are controlling the application editor workplace and storing the application management requirements in the component repository.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Autonomic Middleware Service (AMs)</head><p>Once the application management requirements are defined using the AME, the next step is to utilize the A M s services to build the appropriate application execution environment that can dynamically control the allocated resources to maintain the application requirements during application execution.</p><p>In what follows, we highlight how this architecture can achieve self-healing and optimizing properties for a given networked system or application.</p><p>Our methodology to achieve self-control and management of any functionality or property of an application service is based on three procedures: Monitoring, Analysis and Verification, and Adaptation procedures 1. Self Healing For each fault type (system, component or agent), we will have a software agent (fault handler) that is responsible for executing the procedures. During the monitoring phase, the appropriate fault handler focuses on detecting faults once they occur. For example, for component fault detection, an agent continuously monitors the execution of the component and its consumption of CPU time. Once the component stops its execution, its execution status will be detected by the fault handler, which executes the next procedure (Analysis and Verification). Then the self-healing handler will analyze and verify it in order to identify the fault type and what it is required to recover from that fault. Once that is done, the fault handler, will select and run the appropriate recovery procedure (Adaptation procedure). In case of host failure, the fault handler will consult with the Application Delegated Manger (ADM) to identify another machine to run all the affected components by the host failure.</p><p>2. Self Optimizing Handier In a similar approach as in self-healing, there will be a software agent that we refer to as the Self-optimizing Handler that is responsible to optimize the application as well as system performance at runtime. The selfoptimization handler selects the appropriate mechanism to optimize application performance (by migrating application components, re-mapping the application components to resources, etc.), change the overall resource allocation and load balancing, just to name a few.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Autonomia Implementation Approach</head><p>In this section we discuss in detail our implementation of the main modules of Autonomia and focus on the implementation of the self-healing functionality of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Mobile Agent System</head><p>The mobile agent system (MAS) for Autonomia is designed to provide mobile agents a uniform execution environment independent of the underlying hardware architecture and operating system. It provides functions to receive agents, start execution of agents, monitor execution state of agents, and transfer agents from host to host. It also provides facilities to enable Autonomia to keep track of the joining and withdrawal operations of hosts in the environment. In the mobile agent system, we define a component -Agent Transport Protocol, to act as the access point of the MAS. It is in charge of receiving agents from other remote hosts, either agent enabled or non-agent systems, and sending agents to other agentenabled hosts.</p><p>Our mobile agent system is based on JavdJini technologies. The appropriateness of using Jini technologies was discussed in [15][ 171. The component Agent Transport Protocol (ATP) is implemented as a Jini service, which implements the interface AgentProtocolInterface that defines the behaviors of the protocol. During the installation of a mobile agent system, its Agent Transport Protocol is published with a Jini Lookup Service -Resource Repository (RR), through which the clients can query the host. To publish the service, a Jini service item of the Agent Transport Protocol is created. After registration, the proxy of the Agent Transport Protocol service as well as the host information is uploaded to RR. Meanwhile, a unique service ID is assigned to the Agent Transport Protocol service. We use this ID as the mobile agent system identifier. A Jini Lease Renewal Manager is used in the mobile agent system, which keeps renewing the lease of the registration with the RR. When a client wants to send agents to a host, it queries the Resource Repository for the proxy of the mobile agent system on that host. In our implementation, the proxy of the Agent Transport Protocol service is a Java RMI stub. Our implementation of the Mobile Agent System uses multithread programming. For each agent, MAS spawns a new thread to activate it. Thus the MAS has control of these threads and is capable of detecting their status by polling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Application Management Editor (AME)</head><p>A user can develop an application by selecting components from a well-defmed library or libraries of components that are registered in the Component Repository (see Figure <ref type="figure">l</ref>), and how the components are interconnected; the application development involves constructing application flow graphs from the components registered in the component repository. In addition to developing the application flow graph, the AME enables the user to specify the management requirements for each component that are needed to control and manage the required autonomic properties for that component.</p><p>For each application to be registered in Autonomia environment, an Application Service Template (AST) is created and stored in the component repository. The AST provides a uniform format for representing all the management and control attributes associated with that application using an application template class. The control and management information is stored in the application template class and consists of name, description, dependencies (properties of every application template object), attributes (lists all application-specific properties), fault tolerance, security, monitoring techniques, and monitoring parameters. The AST is described using the Extensible Makeup Language (XML).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Autonodc Middleware Service</head><p>The A M s provides the core autonomic management services required to achieve an autonomic computing environment. The services offered by the Ah4S are implemented using mobile agents. The main services offered by the AMs are Component Repository, Resource Repository, JavaSpaces, JMS, and the Fault and Security Performance Handlers. Furthermore, each AMs service can be implemented using one or more algorithms that can be selected dynamically at runtime based on the current application state as well as the system state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1.">Component Repository (CR). Component</head><p>Repository is a Jini Lookup Service named "Components". It contains a collection of components that are currently available to the users to develop their applications. A component registers with the CR if it wants to provide its service to an application. The registration information cannot stay in the CR infinitely. A lease indicating the duration of the component registration is returned to the component provider when the component registers with the CR. The component provider needs to renew the registration before its lease expires if it wants to continue to provide its component service. A component will be eliminated from the CR if it stops renewing the lease.</p><p>In our implementation, components are implemented as Jini Services. For each component, there is a corresponding service wrapper class that is responsible for publishing the component as a Jini service. The components developed by different component providers can be published in our environment at any time and plugged in anywhere. They can be deployed to the appropriate hosts automatically without pre-installing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="53.2.">Resource Repository (RR).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Resource</head><p>Repository is a Jini Lookup Service, named "Resources".</p><p>It keeps track of all host registrations that are currently registered in the environment. The registration is made for a specific time period and a lease is returned to the host. Resources can be added or discovered in a similar approach to the component publishing and discovering techniques that were discussed in the previous subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3.">Control and Data Message Center. There are two message centers: Control and Management Message</head><p>Center and Data Message Center, which were implemented using JavaSpaces and Java Message Service (JMS) respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Application Delegated Manager</head><p>The Application Delegated Manager plays the role of a broker between components and resources. In addition, the ADM will have the responsibility of supervising the application execution at runtime to make sure we achieve all the required autonomic properties identified in the application service template as discussed in the Application Management Editor subsection. The main fbnctions of ADM can be outlined as follows:</p><p>Maintain an up-to-date list of resources as well as available components that can participate in executing a given application. Select the set of resources that can meet the autonomic requirements of an application. 0 Dispatch the appropriate number of mobile agents to deploy, configure, perform on-line monitoring, analysis, and adaptation when the application cannot meet its requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Fault handler</head><p>There are three types of fault handlers: System Fault Handler, Component Fault Handler and Agent Fault Handler. They deal with system fault, component fault and agent faults, respectively. These handlers are created by the ADM and they share the component deployment information. The ADM registers with the Coordinate Space (CS) that it is interested in the presence of the fault entries in the Coordinate Space. The fault handlers are designated as event listeners once the fault entries appear. In the next subsections, we discuss the fault-detection and recovery schemes adopted to achieve self-healing. We also show the dumpscreens of our proof-of-concept prototype implemented based on Autonomia architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.1.">Fault Detection and Recovery Scheme. This</head><p>implementation has the capability to handle three different kinds of faults defined as Component fault, Agent System fault and Node fault. In our environment, the ADM creates a Node Fault Handler, Component Fault Handler, and Agent Fault Handler, which register with the JavaSpaces their interest in the presence of the node fault entry, the component fault entry and the agent fault entry, respectively. The JavaSpaces will notify the appropriate fault handler when a fault entry is written in the space. Then, the fault handler will spawn a thread to recover that fault using checkpointinglmigrating mechanism [25].</p><p>In Autonomia, whenever a fault is detected, the corresponding fault entry is created and is then written to the JavaSpaces. The lease of staying in the JavaSpaces for the entry is renewed by a global Lease Renewal Manager service. Any fault entry should stay in the JavaSpaces until a fault handler takes it out and deals with the fault even after their creators have crashed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.2">Component fault detection and recovery.</head><p>Here we will focus on component fault detection and recovery mechanisms to illustrate the key aspect of our implementation of the self-healing property.</p><p>Our recovery scheme is based on rolling back the application execution to a previous error-free state that we refer to as a checkpoint state. In our implementation, the checkpoint data is written to JavaSpaces as a checkpoint entry object. When a component is failed and needs to be component to resume its execution, all what it needs are migrated to another host. The mobile agent will not only the checkpoint parameters and the executable file for the deploy the component to the selected host, but it also selected computing platform. Consequently, if a downloads its related checkpoint data entry from the component needs to resume its execution on another JavaSpaces. To enable components to migrate and resume machine, its proxy will fetch the checkpoint entry from execution on heterogeneous computing resources, we the JavaSpaces and the checkpoint parameters in order to store the checkpoint data as a set of parameters. For any resume its execution from the latest checkpoint. Figure <ref type="figure">2</ref> shows the main steps involved in detecting and recovery from a component failure. The component periodically writes the check pointing parameters to the JavaSpaces (step 1 of Figure <ref type="figure">2</ref>). When a component fails, the agent detects its failure by intercepting the return value from the component execution and then reports a component fault entry to the JavaSpaces (step 3 of Figure <ref type="figure">2</ref>). The registration of a fault entry will then trigger an event message that is sent to the appropriate component fault handler (step 4 of Figure <ref type="figure">2</ref>). The fault handler will attempt to process all the component fault entries currently stored in the JavaSpaces. To guarantee an atomic processing of the recovery procedure, it is executed as a transaction. Under the recovery transaction shown in Figure <ref type="figure">3</ref>, the component fault handler takes out one component fault entry at a time and then creates a new mobile agent with the same agent ID in the fault entry. In steps 5 and 6, the fault handler searches the Deploy information and Resource Repository for a suitable host other than the old one and gets the appropriate proxy of the mobile agent system for the selected host. In Step 7, the agent is dispatched to the selected host. In Steps 8 and 9, the MAS on the new host will read the checkpoint information from the JavaSpaces and resumes the component execution. If the dispatch fails on the selected host, the handler interacts with all other available hosts until the recovery transaction is successful. Then the recovery transaction commits and the component fault entry is removed from the JavaSpaces. The new location of the component will be recorded in the deployment information table. If no host can accept the agent, the transaction is aborted, and the component fault entry is left in the JavaSpaces. The self-healing procedures associated with host and agent failures follow similar steps to those shown in Figure <ref type="figure">2</ref>.</p><p>In what follows, we show a few dump screens from our current implementation prototype of Autonomia system. In the execution environment, there are four workstations, three of them called Catalinal, Catalina2 and Catalina3 running WindowsXP, and the fourth one called Nimue running RedHat Linux 7. The Agent System browser in Figure <ref type="figure">4</ref> shows that there are two mobile agent systems, alpha and beta, that are currently running and monitoring the execution of the components on Catalinal and Nimue, respectively. In this experiment, we show how Autonomia can achieve selfhealing for component running a matrix multiplication (MM). The MM component is running on Catalina 2.</p><p>All the component executables are stored in the Code base repository that is running an HTTP server to process client requests to download the appropriate code to any machine. The Jini services, Lookup Service, JavaSpaces, Transaction Manager Service, as well as the ADM are running on Catalina 3. Then, the proxy of the MM component that is running on Catalinal multiplies two matrices. The online monitoring of that component execution is performed by the mobile agent system alpha, which writes the checkpoint parameters to JavaSpaces after the multiplication of a given set of rows as shown in Figure <ref type="figure">5</ref> . In Figure <ref type="figure">5</ref>, we show the partial multiplication results after completing two rows of multiplications. Let us assume that after two rows of multiplication, Catalinal failed. The System Fault Handler will detect the system failure and it migrates the MM component to the MAS beta where it resumes its execution at Nimue (Linux) fiom that of the failed host (WindowsXP). Figure <ref type="figure" target="#fig_4">6</ref> shows that the matrix multiplication restarts on Nimue fiom where it stopped due to the host failure; i.e. it restarts execution of the matrix multiplication from row 2 rather than starting fiom the beginning.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and Related Works</head><p>In this paper, we presented a novel architecture to implement an autonomic computing environment (Autonomia). Our implementation approach and services will make the control and management of large-scale parallel and distributed applications autonomic. We discussed in detailed OUT implementation approach in general to Autonomia and showed how we can achieve the self-healing when components, agents, and or systems fail. We are currently implementing other autonomic attributes to make our environment self-optimizing and self-protecting .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>[</head><label></label><figDesc>61[271.    confgure the required software and hardware resources, run application, provide on-line monitoring and management to maintain desired autonomicity. The architecture of Autonomia is shown in Figure1. The main modules include Application Management Editor (AME), Application Delegated Manager, Autonomic Middleware Services (AMs), Java Space and Java Message Service. In this subsection, we will briefly discuss the functionality of the AME and the AMs. The other modules will be discussed further in the implementation section.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>- 7 IFigure 1 :</head><label>71</label><figDesc>Figure 1 : AUTONOMIA system architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: Component Fault Recovery</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: MM proxy resumes component execution from row 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>[ I l l , Charlotte [22] of</head><label></label><figDesc>NYU, and B a y a d a n [</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>20] of MI", allow clients</head><label></label><figDesc>to define components as Java Applets to be used in applications. Project Ninflet [</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>12][23] intends to hamess</head><label></label><figDesc></figDesc><table><row><cell>abundant idle computing power into a seamlessly</cell></row><row><cell>integrated global as well as local parallel distributed</cell></row><row><cell>computing environment. Another approach at University</cell></row><row><cell>of Columbia aims at automating legacy systems and</cell></row><row><cell>assembling autonomic systems of systems</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>[4]. Other research projects like Recovery Oriented Computing (ROC) have emphasized the recovery and reliability of systems rather than performance [5][7], in which systems</head><label></label><figDesc></figDesc><table><row><cell>use excess computing, memory, storage, and other</cell></row><row><cell>resources to improve the over-all system behavior and</cell></row><row><cell>reliability.</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Paul</forename><surname>Hom</surname></persName>
		</author>
		<ptr target="http://researchweb.watson.ibm.com/autonomic/" />
		<title level="m">Autonomic Computing: IBM&apos;s perspective on the State of Information Technology</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Autonomic Distributed Computing in Scientific Applications</title>
	</analytic>
	<monogr>
		<title level="m">Intemational Workshop on Future Directions in Distributed Computing</title>
		<meeting><address><addrLine>Bertinoro, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Giuseppe Valetto: An Approach to Autonomizing Legacy Systems</title>
		<author>
			<persName><forename type="first">Gail</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phil</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Kc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janak</forename><surname>Parekh</surname></persName>
		</author>
		<imprint>
			<publisher>IBM Almaden Institute Symposium</publisher>
			<biblScope unit="page">412002</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Recovery Oriented Computing (ROC): Motivation, Definition, Techniques, and Case Studies</title>
		<author>
			<persName><forename type="first">David</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Brown</surname></persName>
		</author>
		<idno>UCBIICSD- 02-1 175</idno>
		<imprint>
			<date type="published" when="2002-03-15">March 15. 2002</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">CATALINA: A Smart Application Control and Management</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Salim Hariri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yonhee</forename><surname>Raghavendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rinda</forename><forename type="middle">P</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><surname>Nellipudi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Active Middleware Services Conference</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Embracing Failure: A Case for Recovery-Oriented Computing (ROC). 200 1 High Performance Transaction Processing Symposium</title>
		<author>
			<persName><forename type="first">A</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-10">October 2001</date>
			<pubPlace>Asilomar, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Design and Analysis of a Proactive Application Management System</title>
		<author>
			<persName><forename type="first">Si</forename><forename type="middle">S</forename><surname>Hariri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Djunaedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of NOMS2M</title>
		<meeting>of NOMS2M</meeting>
		<imprint>
			<date type="published" when="2000-04">April 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Checkpointing and Recovery-Rollback for Distributed Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Koa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Toueg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="23" to="31" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Statistical Prediction of Task Execution Times through Analytic Benchmarking for Scheduling in a Heterogeneous Environment</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Iverson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ozguner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Potter</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Eighth Heterogeneous Computing Workshop (HCW&apos;99</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Javelin: Parallel Computing on the Intemet. Future Generation Computer Systems</title>
		<author>
			<persName><forename type="first">I I]</forename><surname>Michael 0. Neary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bemd</forename><forename type="middle">0</forename><surname>Christiansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Cappello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><forename type="middle">E</forename><surname>Schauser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="0999-10">October I 999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">I31 Michael 0. Neary, Alan Phipps, Steven Richman, and Peter Cappello, Javelin 2.0 Java-Based Parallel Computing on the Intemet</title>
		<author>
			<persName><forename type="first">Hiromitsu</forename><surname>Takagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nakada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. of the ACM 1998 Workshop on Java for High Performance Network Computing</title>
		<meeting>of the ACM 1998 Workshop on Java for High Performance Network Computing</meeting>
		<imprint>
			<date type="published" when="1998">1998. 2000</date>
		</imprint>
	</monogr>
	<note>Euro-Par</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Process Introspection: A Checkpoint Mechanism for High Performance Heterogeneous Distributed Systems</title>
		<author>
			<persName><forename type="first">Adam</forename><forename type="middle">J</forename><surname>Ferrari</surname></persName>
		</author>
		<idno>CS-96-15</idno>
		<imprint>
			<date type="published" when="1996-10-10">October 10, 1996</date>
			<pubPlace>Charlottesville, VA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Virginia</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Toward a Common Component Architecture for High-Performance Scientific Computing</title>
		<author>
			<persName><forename type="first">Nathalie</forename><surname>Furmento</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Mcgough</surname></persName>
		</author>
		<ptr target="http://java.sun.com/producWjinil" />
	</analytic>
	<monogr>
		<title level="m">IEEE Intemational Conference on Cluster Computing, 200 I</title>
		<imprint>
			<date type="published" when="1999">1999. 2001. 19</date>
			<biblScope unit="page">81</biblScope>
		</imprint>
	</monogr>
	<note>Proc. of the 8th High Performance Distributed Computing</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Bayanihan: Building and Studying Web-Based Volunteer Computing Systems Using Java. [2 11 F.Cristian, Understanding Fault Tolerant Distributed System</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">G</forename><surname>Luis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satoshi</forename><surname>Sarmenta</surname></persName>
		</author>
		<author>
			<persName><surname>Hirano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communication on ACM</title>
		<imprint>
			<biblScope unit="volume">0134</biblScope>
			<date type="published" when="1991">199 1</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Metacomputing on the Web</title>
		<author>
			<persName><forename type="first">A</forename><surname>Baratloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karaul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Kedem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wyckoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charlotte</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. Of the 9&quot; Intemational Conference on Parallel and Distributed Computing Systems</title>
		<meeting>Of the 9&quot; Intemational Conference on Parallel and Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Ninflet: A Migratable Parallel Objects Framework [24] Michael 0. Neary, Alan Phipps, Steven Richman, and Peter Cappello, Javelin 2.0: Java-Based Parallel Computing on the Intemet</title>
		<author>
			<persName><forename type="first">Hiromitsu</forename><surname>Takagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nakada</surname></persName>
		</author>
		<idno>Euro-Par 2000</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Optimizing Heterogeneous Component Migration in the Gardens Virtual Cluster Computer</title>
		<author>
			<persName><forename type="first">A</forename><surname>Beitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Roe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Heterogeneous Computing Workshop</title>
		<imprint>
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An Infrastructure for Network Computing with Java Applets</title>
		<author>
			<persName><forename type="first">A</forename><surname>Baratloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karaul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Karl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zvi</surname></persName>
		</author>
		<author>
			<persName><surname>Kedem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM workshop on Java for High Performance Network Computing</title>
		<meeting>ACM workshop on Java for High Performance Network Computing</meeting>
		<imprint>
			<date type="published" when="1998-02">February 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Design and Evaluation of a Virtual Distributed Computing Environment</title>
		<author>
			<persName><forename type="first">H</forename><surname>Topcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hariri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Bing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Valente</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Joumal of Networks, Software Tools and Applications(C1uster Computing)</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
