<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A discrete gravitational search algorithm for solving combinatorial optimization problems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013-09-25">25 September 2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Mohammad</forename><forename type="middle">Bagher</forename><surname>Dowlatshahi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Shahid Bahonar University of Kerman</orgName>
								<address>
									<settlement>Kerman</settlement>
									<country key="IR">Iran</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hossein</forename><surname>Nezamabadi-Pour B,⇑</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering</orgName>
								<orgName type="institution">Shahid Bahonar University of Kerman</orgName>
								<address>
									<settlement>Kerman</settlement>
									<country key="IR">Iran</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mashaallah</forename><surname>Mashinchi</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Statistics</orgName>
								<orgName type="institution">Shahid Bahonar University of Kerman</orgName>
								<address>
									<settlement>Kerman</settlement>
									<country key="IR">Iran</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A discrete gravitational search algorithm for solving combinatorial optimization problems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2013-09-25">25 September 2013</date>
						</imprint>
					</monogr>
					<idno type="MD5">0992138F5529B07DA076AC7DF22938BE</idno>
					<idno type="DOI">10.1016/j.ins.2013.09.034</idno>
					<note type="submission">Received 22 November 2011 Received in revised form 11 May 2013 Accepted 13 September 2013</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Metaheuristics Gravitational search algorithm Combinatorial optimization Traveling salesman problem Path re-linking</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Metaheuristics are general search strategies that, at the exploitation stage, intensively exploit areas of the solution space with high quality solutions and, at the exploration stage, move to unexplored areas of the solution space when necessary. The Gravitational Search Algorithm (GSA) is a stochastic population-based metaheuristic that was originally designed for solving continuous optimization problems. It has a flexible and well-balanced mechanism for enhancing exploration and exploitation abilities. In this paper, a Discrete Gravitational Search Algorithm (DGSA) is proposed to solve combinatorial optimization problems. The proposed DGSA uses a Path Re-linking (PR) strategy instead of the classic way in which the agents of GSA usually move from their current position to the position of other agents. The proposed algorithm was tested on a set of 54 Euclidean benchmark instances of TSP with sizes ranging from 51 to 2392 nodes. The results were satisfactory and in the majority of the instances, the results were equal to the best known solution. The proposed algorithm ranked ninth when compared with 54 different algorithms with regard to quality of the solution.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Combinatorial optimization problems arise in many areas of computer science and other disciplines such as artificial intelligence, operations research, bioinformatics and electronic commerce, and typically involve finding the best possible grouping, ordering or assignment of a finite set of objects satisfying certain conditions or constraints. Algorithms for solving these problems may be classified as either ''complete'' or ''approximate'' <ref type="bibr" target="#b6">[7]</ref>. Complete algorithms obtain optimal solutions and guarantee their optimality in a bounded time for every finite size instance of a combinatorial optimization problem. However, it has been shown that for combinatorial optimization problems that are NP-hard, no polynomial time algorithm exists unless P = NP <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b28">29]</ref>. Therefore, complete algorithms for combinatorial optimization problems often need exponential computation time and this makes them impractical for most real-world applications. Thus, approximate algorithms to solve NP-hard combinatorial optimization problems have been receiving increasing attention. In approximate methods, the guarantee of finding exact optimal solutions is sacrificed for the sake of obtaining good solutions in a significantly reduced amount of time <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b41">42]</ref>.</p><p>Approximate algorithms can be categorized into three important classes: approximation algorithms, problem specific heuristics, and metaheuristics. Approximation algorithms, unlike problem specific heuristics and metaheuristics, provide provable solution quality and provable run-time bounds for finding a non-optimal solution. Problem specific heuristics are problem dependent and are designed for a particular problem whereas metaheuristics represent more general approximate algorithms and are applicable to a large variety of optimization problems. Metaheuristics solve problems that are believed to be hard by exploring the large solution space and achieve this goal by effectively reducing the size of this space and exploiting the reduced space efficiently <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b41">42]</ref>. This class of algorithms includes, but is not restricted to, Ant Colony Optimization (ACO) <ref type="bibr" target="#b9">[10]</ref>, Evolutionary Computation (EC) such as Genetic Algorithms (GA) <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b42">43]</ref>, Greedy Randomized Adaptive Search Procedure (GRASP) <ref type="bibr" target="#b10">[11]</ref>, Iterated Local Search (ILS) <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b39">40]</ref>, Variable Neighborhood Search (VNS) <ref type="bibr" target="#b32">[33]</ref>, Simulated Annealing (SA) <ref type="bibr" target="#b26">[27]</ref>, and Tabu Search (TS) <ref type="bibr" target="#b16">[17]</ref>.</p><p>Recently, a stochastic population-based metaheuristic, called Gravitational Search Algorithm (GSA), which is motivated by the laws of gravity and motion has been proposed. Originally, GSA was designed for solving continuous optimization problems <ref type="bibr" target="#b35">[36]</ref> and, like most metaheuristics, has a flexible and well-balanced mechanism for enhancing exploration and exploitation abilities. The search strategy of GSA is to move the members of population towards the K best solutions of population using the laws of gravity and motion, where K is a number between one and the size of the population. Motivated by the success of the GSA with variant optimization problems <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b43">44]</ref>, this paper proposes a Discrete GSA (DGSA) to solve combinatorial optimization problems. As a test, this algorithm was applied to the Traveling Salesman Problem (TSP). The results were satisfactory and for the majority of the instances the results were equal to the best known solution.</p><p>The rest of the paper is organized as follows. Section 2 provides a review of original GSA. In Section 3, the main concepts and components behind GSA to accomplish search is investigated. In Section 4, details of the proposed DGSA are described. An implementation of the proposed algorithm for solving TSP is presented in Section 5. Computational results are presented in Section 6. Finally, in Section 7 conclusions and suggestions for future research are given.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Gravitational search algorithm</head><p>In physics, gravitation is the tendency of objects with mass to accelerate towards each other. In the Newton gravitational law, each object attracts every other object by a gravitational force. As an example, consider a 2-dimensional space including the objects O 1 , O 2 , O 3 , and O 4 . As seen in Fig. <ref type="figure">1</ref>, F 1j (j e {2, 3, 4}) is the force acting on O 1 from O j (j e {2, 3, 4}), and F 1 is the overall force that acts on O 1 from all other objects and generates acceleration a 1 based on Newton's second law. 1  In the basic model of the GSA, which has been originally designed to solve continuous optimization problems, a set of objects (agents) are introduced in the n-dimensional solution space of the problem to find the optimum solution by simulation of the Newtonian laws of gravity and motion. The position of each agent in GSA demonstrates a candidate solution to the problem, hence each agent is represented by the vector X i in the solution space of the problem. Agents with a higher performance get a greater gravitational mass, because a heavy agent has a large effective attraction radius and hence a great intensity of the attraction. During the lifetime of GSA, each agent successively adjusts its position X i toward the positions of K best agents of the population.</p><p>To describe GSA in more detail, consider an n-dimensional space with s searcher agents in which the position of the ith agent is defined as follows:</p><formula xml:id="formula_0">X i ¼ x 1 i ; . . . ; x d i ; . . . ; x n i À Á ; i ¼ 1; 2; . . . ; s;<label>ð1Þ</label></formula><p>where x d i presents the position of the ith agent in the dth dimension. Based on <ref type="bibr" target="#b35">[36]</ref>, gravitational mass of the ith agent is calculated after computing the current population's fitness as follows:</p><p>Fig. <ref type="figure">1</ref>. Every object accelerates in the direction of the resultant force that acts on it from the other objects. 1 Newton's second law states that when a force is applied to an object, the acceleration of this object depends only on the force and gravitational mass of this object. For example, suppose O i is an object, F i is a force which acts on O i , and a i is the acceleration of O i . The value of a i will be obtained as follows: </p><formula xml:id="formula_1">a i ¼</formula><p>To compute the acceleration of the ith agent, overall force that acts on the ith agent from a set of K heavier agents (called Kbest set) must be calculated using Eq. ( <ref type="formula" target="#formula_3">6</ref>), and then this overall force must be divided by the gravitational mass of this agent, i.e. M i (t), using Eq. <ref type="bibr" target="#b6">(7)</ref>.</p><formula xml:id="formula_3">F d i ðtÞ ¼ X j2Kbest;j-i rand j GðtÞ M j ðtÞM i ðtÞ R ij ðtÞ þ e x d j ðtÞ À x d i ðtÞ ;<label>ð6Þ</label></formula><formula xml:id="formula_4">a d i ðtÞ ¼ F d i ðtÞ M i ðtÞ ¼ X j2Kbest;j-i rand j GðtÞ M j ðtÞ R ij ðtÞ þ e x d j ðtÞ À x d i ðtÞ :<label>ð7Þ</label></formula><p>Some of the main parameters of Eqs. ( <ref type="formula" target="#formula_3">6</ref>) and ( <ref type="formula" target="#formula_4">7</ref>) are described as follows: rand j is a uniformly distributed random number in the interval [0, 1], R ij (t) is the Euclidean distance between two agents i and j in an n-dimensional Euclidean space, 2</p><p>e is a very small value used in order to escape from division by zero error whenever the Euclidean distance between two agents i and j is equal to zero, Kbest is the set of first K agents with the best fitness value and biggest gravitational mass, in which K is a function of time, initialized to K initial value at the beginning of the algorithm and its value is decreased with time, and G(t) is the gravitational coefficient that will take an initial value, G initial , and it will be reduced with time toward a final value, G end , by Eq. ( <ref type="formula" target="#formula_5">8</ref>):</p><formula xml:id="formula_5">GðtÞ ¼ GðG initial ; G end ; tÞ:<label>ð8Þ</label></formula><p>Then, the next velocity of the ith agent is calculated as a fraction of its current velocity added to its acceleration by Eq. ( <ref type="formula" target="#formula_6">9</ref>) and the next position of the ith agent can be calculated using Eq. ( <ref type="formula" target="#formula_7">10</ref>):</p><formula xml:id="formula_6">v d i ðt þ 1Þ ¼ rand Â v d i ðtÞ þ a d i ðtÞ;<label>ð9Þ</label></formula><formula xml:id="formula_7">x d i ðt þ 1Þ ¼ x d i ðtÞ þ v d i ðt þ 1Þ;<label>ð10Þ</label></formula><p>where rand is a uniformly distributed random number in the interval [0, 1]. The pseudo code of the original GSA is shown in algorithm <ref type="bibr" target="#b0">(1)</ref>.</p><p>Algorithm (1): Template of original Gravitational Search Algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generate the initial population;</head><p>Evaluate the fitness for each agent; Calculate the gravitational mass for each agent; While stopping criteria is not satisfied Do Update G, K, and Kbest; Calculate the acceleration of each agent by Eq. ( <ref type="formula" target="#formula_4">7</ref>); Calculate the velocity of each agent by Eq. ( <ref type="formula" target="#formula_6">9</ref>); Update the position of each agent by Eq. ( <ref type="formula" target="#formula_7">10</ref>); Evaluate the fitness for each agent; Calculate the gravitational mass for each agent; Endwhile Output: Best solution found. 2 Euclidean distance is the distance between two points in Euclidean space that one would measure with a ruler. In Cartesian coordinates, if P = (p 1 , p 2 , . . . , p n ) and Q = (q 1 , q 2 , . . . , q n ) are two agents i and j, respectively, in n-dimensional Euclidean space, then the Euclidean distance from agent i to agent j, or from agent j to agent i is given by: R</p><formula xml:id="formula_8">ij ¼ R ji ¼ ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi ðq 1 À p 1 Þ 2 þ ðq 2 À p 2 Þ 2 þ Á Á Á þ ðq n À p n Þ 2 q ¼ ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi P n k¼1 ðq k À p k Þ 2 q .</formula><p>In GSA, parameters K and G are two main factors which balance exploitation and exploration. To avoid being trapped in a local optimum, each metaheuristic should use the exploration at beginning iterations. In GSA, this point is accomplished by assignment of high values to parameters K and G at the beginning, i.e. the value of K initial and G initial must be high. The high value for parameter K allows an agent to move in the solution space based on the position of more agents and consequently the exploration ability of the algorithm is increased. Also, a high value for parameter G increases the mobility of each agent in the solution space and hence the exploration capability of the algorithm is increased. With high values for K initial and G initial , the good regions of the solution space are probably recognized in the early iterations of the algorithm. Hence, by lapse of iterations, the exploration of GSA must fade out and its exploitation must fade in. This issue is accomplished by reducing the values of parameters K and G by lapse of iterations. The low value for parameter K causes an agent to move in the solution space based on the position of few agents and consequently the exploitation ability of the algorithm is increased. Also, the low value for parameter G decreases the mobility of each agent in the solution space and hence the exploitation of the algorithm is increased. Therefore, the good regions of the solution space are probably exploited in the ultimate iterations of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Search components of gravitational search algorithm</head><p>To recognize the main search components of GSA, it is necessary to understand how the algorithm works. Suppose a population of agents is initialized in the solution space of a problem. In the top-down view, when GSA is applied to solve an optimization problem it tries ''to move'' the agents' positions in the solution space of the problem. Hence, the movement operator is the main component of GSA in accomplishing the search in the solution space of optimization problems.</p><p>Based on Eq. ( <ref type="formula" target="#formula_7">10</ref>), the movement operator gets two input parameters, the position of the ith agent and a movement length of the ith agent, and then returns a new position in the solution space as output. The movement length of the ith agent is its velocity. Based on Eq. ( <ref type="formula" target="#formula_6">9</ref>), the movement length of the ith agent itself is computed by two classes of movement lengths, the Independent Movement Length (IML) and Dependent Movement Length (DML). Note that IML is the movement length which is obtained for each agent without knowing any other positions besides its own on the current iteration. This type of movement length for the ith agent depends only on its previous movement length (or previous velocity), and in fact it is a fraction of the previous movement length of the ith agent. On the other hand, DML is the movement length which is obtained for each agent by considering the position of all members of Kbest set. The Eq. <ref type="bibr" target="#b6">(7)</ref> shows the calculation of DML for the ith agent in which all members of Kbest try to affect it. Based on Eq. ( <ref type="formula" target="#formula_4">7</ref>), the computation of DML for the ith agent itself depends on several subcomponents such as, the position of the jth agent (j e Kbest), the distance between the ith and the jth agents, the gravitational mass of the jth agent (i.e. M j (t)), and the value of the gravitational coefficient (G(t)).</p><p>Based on Eqs. ( <ref type="formula" target="#formula_6">9</ref>) and ( <ref type="formula" target="#formula_7">10</ref>) and the concepts of IML and DML, the movement operator can be broken into two distinct movement operators, the Independent Movement Operator (IMO) and Dependent Movement Operator (DMO). IMO gets an agent and an IML as inputs and then moves the position of the input agent in the solution space based on the value of the input IML. DMO gets an agent and a DML as inputs and then moves the position of the input agent in the solution space based on the value of the input DML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The proposed discrete gravitational search algorithm</head><p>As seen in Section 3, two main components of GSA are IMO and DMO. In follows, first the IMO for the proposed DGSA is described in Section 4.1. Then, the DMO for the proposed DGSA is described in Section 4.2. Finally, the proposed DGSA framework is described in Section 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Independent movement operator in DGSA</head><p>In original GSA, the IMO gets the position of the ith agent and an IML as inputs and then moves the position of the ith agent in the solution space based on the value of the input IML. In a general view, the concept of IMO demonstrates the trust of an agent to the previous movement of itself. One of the most popular operators that can be substituted with basic IMO is a modified version of local search algorithm. Original local search algorithm is a computational search method that starts with an initial solution and subsequently moves from the present solution to a neighboring solution that improves the objective function of the problem. Many strategies can be applied in the selection of a better neighbor such as: (1) Best improvement selection strategy in which the best neighbor (i.e., the neighbor that improves the objective function the most) is selected, (2) First improvement selection strategy which consists in choosing the first improving neighbor that is better than the current solution, and (3) Random selection strategy in which a random selection is applied to those neighbors that improve the current solution. The process of current solution improvement is continued until all candidate neighbors are worse than the current solution <ref type="bibr" target="#b0">[1]</ref>. Algorithm (2) illustrates the template of an original local search algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm (2): Template of an original local search algorithm.</head><p>Input: y as the starting solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Repeat</head><p>Generate candidate neighbors to y; If there is no better neighbor Then Stop the algorithm; Assign a better neighbor of y to y; Until stopping criteria satisfied; Output: Final solution found.</p><p>Original local search algorithms, similar to basic IMO, cause each agent to move in the solution space without knowing any other positions of the population. Besides, the original local search algorithms similar to the basic IMO are strongly dependent on the starting solution so that the final found solution in the best case is a good neighbor of the starting solution. But, a small difference exists between IMO and original local search algorithms. In IMO, the most movement length of the ith agent in the solution space is determined by the input IML, whereas in local search algorithms the most movement length of the ith agent in the solution space is not specified at the beginning. Fortunately, this difference can be eliminated by manipulating the structure of the original version of local search algorithms. The template of a modified version of local search algorithms which is a proper substitute for IMO is illustrated in algorithm (3). As seen, an IML is added to the input parameters of the algorithm. In fact, the input IML parameter demonstrates the movement length of the local search. Based on Eq. ( <ref type="formula" target="#formula_6">9</ref>), the value of the input IML for the ith agent is calculated by multiplication of a random number in interval [0, 1] to the previous movement length of the ith agent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm (3): Template of a modified local search algorithm (IMO).</head><p>Input: y as the starting solution, and IML as the maximum movement length. iteration = 0; Repeat Generate candidate neighbors to y; If there is no better neighbor Then Stop the algorithm; Assign a better neighbor of y to y; iteration++; Until iteration == IML OR other stopping criteria satisfied; Output: Final solution found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Dependent movement operator in DGSA</head><p>In original GSA, the DMO gets two input parameters, the current position of the ith agent and a DML of the ith agent and then returns a new position in the solution space as output. Based on Eq. ( <ref type="formula" target="#formula_4">7</ref>), the DML of the ith agent is an acceleration vector that is calculated by the sum of accelerations in which all members of Kbest will act on the ith agent. In other words, to compute the DML for the ith agent, all members of Kbest try to attract it (Eq. ( <ref type="formula" target="#formula_4">7</ref>)). In multi-dimensional continuous spaces, defining the DMO is simple: moving the ith agent toward all members of Kbest in all dimensions of space. But, defining the DMO for discrete spaces is somewhat ambiguous. In discrete spaces, the concept of moving from the ith agent toward all members of Kbest encounters an important question: how does the ith agent move toward the jth agent using Newtonian gravitational law and the laws of motion? To answer this main question, first the concept of neighborhood space is presented in order to formalize the structure of the solution space of combinatorial optimization problems. Also the concept of DMO in the neighborhood space is described in Section 4.2.1. Then, Section 4.2.2 describes the way in which DML is calculated in the neighborhood space of combinatorial optimization problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1.">The neighborhood space and dependent movement operator</head><p>The neighborhood space for combinatorial optimization problems is defined by an undirected graph H = (N, E) associated with the solution space of the problem, where the nodes in N correspond to candidate solutions and the edges in E correspond to moves in the neighborhood structure, i.e. ði; jÞ 2 E if and only if i 2 N; j 2 N; j 2 NðiÞ, and i 2 NðjÞ, where N(y) denotes the neighbors of a solution y 2 N. A neighbor for solution y is generated by applying a small move m to the solution y by a small move operator È. For example, for the Traveling Salesman Problem (TSP) which is encoded as a permutation problem, a usual small move operator is based on the swap operator that consists in exchanging (or swapping) the location of two cities c i and c j of the permutation. Fig. <ref type="figure">2</ref> shows the neighborhood space associated with a permutation-based TSP of size 3. In this neighborhood space, the small move operator is a swap operator and the small move m is any arbitrary exchangeable pair of cities.</p><p>One of the most important properties of the neighborhood space H is its connectivity, i.e. for any two arbitrary solutions y and z (which are nodes of H), there should be a path of solutions from y to z in H <ref type="bibr" target="#b41">[42]</ref>. The concept of Path Re-linking (PR) was originally proposed by Glover within the framework of Scatter Search (SS) <ref type="bibr" target="#b15">[16]</ref>. The idea of original PR is to generate and to explore the trajectory in the neighborhood space connecting a starting solution y to a target solution z. In other words, a sequence of neighboring solutions in the neighborhood space is generated from the starting solution to the target solution. For example, given a starting solution y and a target solution z, a path from y to z leads to a sequence of solutions y(0) = y, y(1), y(2), . . . , y(r) = z, where y(i + 1) is obtained from y(i) by applying a small move operator È which introduces in y(i + 1) an attribute that reduces the distance between starting and target solutions (the distance between starting solution y and target solution z in the neighborhood space is shown with dist(y, z)). Examples of such attributes include edges and nodes of a graph, sequence positions in a schedule, and values of variables of a function. To generate the desired paths in the neighborhood space, it is necessary to select a small move operator that performs the following role: upon starting from an initial solution, the small move operator must progressively introduce attributes contributed by a target solution (or reduce the distance between the attributes of the starting and target solutions). If this role was considered by the small move operator, the path between two solutions in the neighborhood space will generally yield solutions that share common attributes with the starting and target solutions. On the other hand, each move on the path makes the solution more different from the starting solution and more similar to the target solution <ref type="bibr" target="#b15">[16]</ref>. Algorithm (4) shows the template for a basic PR algorithm.</p><p>Algorithm (4): Template of the basic PR algorithm.</p><p>Input: y as the starting solution and z as the target solution. While dist(y, z) -0 Do y ¼ y È m; /Ã Small move operator È applies the small move m to the solution y such that this small movement must decrease distðy È m; zÞ than dist(y, z) Ã/ Output: The best solution found in trajectory between y and z.</p><p>As seen in algorithm (4), the basic PR algorithm constructs a trajectory from a starting solution to a target solution in the neighborhood space and then returns the best solution found in this trajectory. The idea of constructing trajectory by PR can be used to simulate the DMO concept in combinatorial spaces. First, suppose a starting solution y, a target solution z, and a movement length l e {0, 1, . . . , r} are given, where r is the number of small move operator usages that constructs the path P from y to z. We define Simple Movement in Neighborhood Space (SMNS) algorithm as the following: by starting from solution y, construct the first lth solutions of assumptive path P between y and z, and return the lth solution as output. In other words, SMNS algorithm constructs a partial trajectory from y toward z with length l and then returns the lth solution, i.e. the last generated solution, as output. The template of SMNS algorithm is shown in algorithm <ref type="bibr" target="#b4">(5)</ref>. As seen, the main differences between PR and SMNS algorithms are: (1) PR algorithm constructs a complete trajectory from y to z, but SMNS algorithm constructs a partial trajectory from y toward z, and (2) PR algorithm returns the best solution found in the trajectory between y and z, but SMNS algorithm returns the lth constructed solution in the trajectory between y and z, where l is the movement length from y toward z.</p><p>(2, 3, 1)</p><p>(2, 1 , 3 )</p><formula xml:id="formula_9">(3, 1 , 2 ) (3, 2, 1) (1, 2, 3) (1, 3<label>, 2)</label></formula><p>Fig. <ref type="figure">2</ref>. An example of neighborhood space for a permutation-based TSP of size 3.</p><p>Algorithm (5): Template of the Simple Movement in Neighborhood Space (SMNS) algorithm.</p><p>Input: y as the starting solution, z as the target solution, and l as the movement length.</p><p>For i = 1 to l Do y ¼ y È m; /Ã Small move operator È applies the small move m to the solution y such that this small movement must decrease distðy È m; zÞ than dist(y, z) Ã/ Output: Solution y.</p><p>The movement length of SMNS algorithm is an important parameter in generating the final solution. In the proposed DGSA, this movement length is equaled with the acceleration that solution z applies on the solution y. In Section 4.2.2, the way of its calculation for two solutions in the neighborhood space is described. Now, the DMO can be formulated by the concept of SMNS. Suppose a starting solution y, the number of target solutions K, target solutions set Z = {z 1 , z 2 , . . . , z K }, and movement lengths set L = {l 1 , l 2 , . . . , l K } are given, where l i e {0, 1, . . . , r i } and r i is the number of PR moves that construct the path P i from y to z i . The template of Multi Target Movement in Neighborhood Space (MTMNS) algorithm is shown in algorithm <ref type="bibr" target="#b5">(6)</ref>. In the proposed DGSA, the MTMNS algorithm is used to accomplish the function of DMO.</p><p>One of the main components of the MTMNS algorithm is to determine the selection priority of each target solution. To determine the selection priority, different parameters can be considered. Here, the highest selection priority is assigned to that target solution which has the lowest quality and the lowest selection priority is assigned to that target solution which has the highest quality, because based on experiments, the latest moves of a solution in the neighborhood space toward K solutions have more influence in the quality of the final obtained solution than the early moves. Also, other target solutions get a selection priority between the lowest and highest selection priority based on their qualities. Algorithm (6): Template of the Multi Target Movement in Neighborhood Space (MTMNS) algorithm.</p><p>Input: y as the starting solution, K as the number of target solutions, Z = {z 1 , z 2 , . . . , z K } as the set of target solutions, and L = {l 1 , l 2 , . . . , l K } as the set of movement lengths. Determine the priority of each target solution; x = y; For i = 1 to K Do j = the index of the target solution which has the ith priority;</p><p>x = output of SMNS algorithm with input parameters: starting solution x, target solution z j , and movement length l j ; Output: Solution x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2.">Calculating dependent movement length</head><p>Let the ith agent corresponds to starting solution y, the jth agent corresponds to target solution z, and finally the DML of the ith agent toward the jth agent corresponds to l ij . In the proposed DGSA, the value of l ij is calculated by the following equation:</p><formula xml:id="formula_10">F ij ðtÞ ¼ rand Â GðtÞ Â M j ðtÞM i ðtÞ NR ij ðtÞ Â R ij ðtÞ;<label>ð11Þ</label></formula><formula xml:id="formula_11">a ij ðtÞ ¼ l ij ¼ F ij ðtÞ M i<label>ðtÞ</label></formula><formula xml:id="formula_12">$ % ¼ rand Â GðtÞ Â M j ðtÞ NR ij ðtÞ Â R ij ðtÞ $ % ;<label>ð12Þ</label></formula><p>where M i (t) and M j (t) are gravitational masses of agents i and j respectively, rand is a uniformly distributed random number in the interval [0, 1], R ij (t) is the distance between two agents i and j, defined as the number of applying the small move operator È that converts agent i to agent j (notice that it is important that the way in which distance is calculated is related to the used small move operator È in the SMNS algorithm),</p><formula xml:id="formula_13">NR ij (t) is a normalized value of R ij (t) in interval [0.5, 1] which is obtained by expression 0:5 þ R ij ðtÞ 2ÂMax dist</formula><p>, where Max dist is the maximum possible distance between each arbitrary pair of solutions in the neighborhood space, G(t) is the gravitational coefficient that takes an initial value G initial in interval (0, 1] and will be reduced with time toward the final value G end in interval (0, 1], such that G initial P G end . The function which reduces the value of parameter G(t) is dependent on the solution space structure of the target combinatorial optimization problem. One of the simplest ways to find a good function to reduce the value of this parameter for solving a combinatorial optimization problem is to compare the results of different functions. For example, based on experiments carried out on the different decreasing functions, the linear decreasing function is a good choice for many instances of the Traveling Salesman Problem (TSP).</p><p>Notice that in the original GSA the DMO for an agent is performed in an n-dimensional continuous space (see Eq. ( <ref type="formula" target="#formula_4">7</ref>)), therefore the movement of an agent toward another agent is performed in all different dimensions of the solution space. But, in the proposed DGSA the DMO for an agent is performed in the neighborhood space of combinatorial optimization problems. Hence, based on the structure of neighborhood spaces, the movement of an agent toward another agent in the DGSA is performed by a single number that demonstrates the number of moves that must be applied to the agent (see Eq. ( <ref type="formula" target="#formula_12">12</ref>)). Also, because of the concept of dependent movement in DGSA the difference of two solutions in the dth dimension is not considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">The DGSA framework</head><p>To better understand the proposed DGSA, it is necessary to present its algorithmic details. The pseudo code of the proposed DGSA is presented in algorithm <ref type="bibr" target="#b6">(7)</ref>. Algorithm <ref type="bibr" target="#b6">(7)</ref>: Template of the proposed DGSA.</p><p>Input: n as the size of input instance, s as the number of searcher agents, K initial as the initial value of K, G initial as the initial value of the gravitational coefficient, and G end as the final value of the gravitational coefficient. // initialization phase iteration = 0; Generate the initial population P(iteration) of the solutions by greedy randomized algorithm; Evaluate the fitness for each agent of P(iteration); Calculate the gravitational mass for each agent of P(iteration) by Eq. ( <ref type="formula">3</ref>); Generate the initial velocity V(iteration) Randomly; // main phase While stopping criteria is not satisfied DO // Dependent Movement Operator phase Update G, K and Kbest;</p><p>Calculate l ij for each agent i and each agent j e Kbest based on Eq. ( <ref type="formula" target="#formula_12">12</ref>);</p><p>For i = 1 to s Do P i (iteration + 1) = output of MTMNS algorithm execution with input parameters: P i as starting solution, K as the number of target solutions, Kbest as target solutions set, and l ij for each agent j e Kbest as movement lengths set;</p><p>// Independent Movement Operator phase For i = 1 to s Do IML ¼ drand Â V i ðiterationÞe;//V i (iteration) is the previous movement length and rand is a random number in [0, 1] P i (iteration + 1) = output of the modified Local Search algorithm with input parameter: P i (iteration) as starting solution and IML maximum movement length; Evaluate the fitness for each agent of P(iteration + 1); Calculate the gravitational mass for each agent of P(iteration + 1) by Eq. ( <ref type="formula">3</ref>); iteration = iteration + 1; Endwhile Output: Best solution found.</p><p>At first, an initial population is generated by a construction procedure which can guarantee both the proper quality and the necessary diversity of the initial population. This construction procedure is a greedy randomized algorithm. This procedure, similar to a pure greedy algorithm, starts from an empty solution and constructs a solution by assigning values to one decision variable at a time, until a complete solution is generated. However, in contrast to the pure greedy algorithm which always adds an item which has the best efficiency out of the remaining ones to the partial solution, this greedy randomized algorithm builds a set containing a subset of the remaining items with the best efficiency, similar to the Restricted Candidate List (RCL) in GRASP <ref type="bibr" target="#b10">[11]</ref>, and randomly adds one of those items to the partial solution. The other steps in the initialization phase are to determine the fitness of agents using the evaluation function, to calculate the gravitational mass of agents, and finally to initialize the initial velocity of each agent randomly in interval [0, Max dist ], where Max dist is the maximum possible distance between each arbitrary pair of solutions in the neighborhood space of the problem.</p><p>After initialization, the main search loop is entered. It is repeated until a certain termination criterion which can be a maximum number of iterations, a maximum execution time, the convergence of the population, or some other condition, is satisfied. In the main loop itself, two important phases exist: the DMO phase and the IMO phase. In the DMO phase, first the value of G and K is updated and the Kbest set is constructed by considering the first K best solutions found in the lifetime of DGSA execution (notice that in original GSA the Kbest is constructed only by K best solutions found in the current iteration), then l ij for each agent i and each agent j e Kbest is calculated by Eq. ( <ref type="formula" target="#formula_12">12</ref>), and finally the position of each agent is changed in the solution space by the MTMNS algorithm. The main part of the DMO is the small move operator È which is strongly problem-dependent. In the IMO phase, the position of each agent is changed in the solution space by the proposed modified local search algorithm. The main part of the IMO is to determine the neighbors of a solution. In the next section, the main problem dependent parts of DGSA are described for solving the Traveling Salesman Problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Solving Euclidean Traveling Salesman Problem with proposed DGSA (DGSATSP)</head><p>Consider a salesman who has to visit n cities. The Traveling Salesman Problem (TSP) asks for the shortest tour through all the cities such that no city is visited twice and the salesman returns back to the starting city at the end of the tour. We speak of a symmetric TSP, if for all pairs i and j, the distance of two adjacent cities c i and c j is equal to the distance of two adjacent cities c j and c i . Otherwise, we speak of the asymmetric TSP. If the cities can be represented as points in the plain such that the distance of two adjacent cities c i and c j is equal to the Euclidean distance between point i and point j, then the corresponding TSP is called Euclidean TSP.</p><p>TSP is an NP-hard problem <ref type="bibr" target="#b11">[12]</ref>, and it is probably the most famous and extensively studied problem in the field of combinatorial optimization. Its practical importance is one of the reasons of such status. In fact, many significant real world problems can be formulated as instances of the TSP. Apart from its practical importance; the TSP has also become a standard testbed for new algorithmic ideas. In fact, many of the most important techniques for solving combinatorial optimization problems, such as branch &amp; cut method and branch &amp; bound method, were developed using the TSP as an example application. Additionally, many of the metaheuristics, such as Simulated Annealing (SA) and Ant Colony Optimization (ACO), were first tested on the TSP <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b45">46]</ref>.</p><p>The algorithmic schema of DGSA is already presented in algorithm <ref type="bibr" target="#b6">(7)</ref>. But, some parts of DGSA are problem-dependent or at least partly problem-dependent. In the next subsections, these parts of the algorithm are explained with details to solve the TSP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Representation</head><p>To design an iterative metaheuristic, a representation scheme is necessary to encode a solution. The representation of a solution must be easy to manipulate by the search operators, so that the time and space complexities of these operators dealing with the representation must be reduced. Here, the standard array representation is used for each candidate tour. In this representation, a candidate tour is stored in two arrays which are called tour array and inverse array. Tour array is an array of cities in the order they appear in the candidate tour and inverse array is an array whose ith item contains the location of the city i in tour array <ref type="bibr" target="#b1">[2]</ref>. The top pair of arrays in Fig. <ref type="figure">3</ref> illustrates the data structure for the tour (9, 0,</p><p>. Notice that using this pair of arrays helps to efficiently manipulate the tours by the DMO and IMO which are the main operators of DGSA. For example, one of the main operations of IMO and DMO in solving TSP is to find the location of a city in the tour array. The time complexity of finding the location of a city in the tour array, without using the inverse array, is O(n), where n is the number of cities. Whereas, the time complexity of finding the location of a city in the tour array by using the inverse array is O(1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Initial population</head><p>As seen in the template of DGSA, a greedy randomized algorithm is applied to generate the initial population. Here, each member of the population is a tour. Hence, the process of initial population generation is equal to the process of construction of tours. The tour construction process starts with an empty tour, i.e. a tour which currently has no city. In each iteration of tour construction process, the greedy randomized algorithm builds a Restricted Candidate List (RCL) containing a subset of the remaining cities and randomly adds one of the RCL cities to the partial tour. This step is continued until a feasible complete tour is found. In this paper, in each step the RCL is constructed by the remaining nearest cities. The size of the RCL to solve the TSP is specified in the computational results section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Fitness evaluation and gravitational mass calculation</head><p>In TSP, the fitness of each agent is related to its tour length. Suppose p is a candidate tour with n cities. The length of p and the fitness of p are calculated as follows:</p><p>Tour array 9 0 8 5 7 2 6 1 4 3 0 1 2 3 4 5 6 7 8 9</p><p>Inverse array 1 7 5 9 8 3 6 4 2 0 0 1 2 3 4 5 6 7 8 9</p><p>Fig. <ref type="figure">3</ref>. The standard array representation to represent the candidate tour (9, 0, 8, 5, 7, 2, 6, 1, 4, 3).</p><formula xml:id="formula_15">LðpÞ ¼ fitðpÞ ¼ X nÀ1 i¼1 d c pðiÞ ; c pðiþ1Þ À Á þ d c pðnÞ ; c pð1Þ À Á ;<label>ð13Þ</label></formula><p>where d(i, j) is the distance between city i and city j.</p><p>Since TSP is a minimization problem, if a feasible tour has a large length then it is characterized as an unpromising candidate tour and, therefore, its gravitational mass must be set to a small value. Reversely, a large gravitational mass value must correspond to a feasible tour with a low length. Fortunately, this is achievable in proposed DGSA using Eqs. ( <ref type="formula" target="#formula_9">2</ref>)-(5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Dependent movement operator: Multi Target Movement in Neighborhood Space (MTMNS)</head><p>As said in Section 4, the main problem-dependent parts of the DMO in DGSA are: the values of G initial , G end , and K initial , the way of updating parameters G and K, the small move operator È, and the distance between two solutions.</p><p>Similar to original GSA, the value of G initial , G end , and K initial , and also the reduction ways of parameters G and K directly affect the power of exploitation and exploration of DGSA. In this paper, two linear functions are used to reduce the value of parameters G and K with time. The initial values for K initial , G initial , and G end are specified in the computational results section.</p><p>For TSP, which is encoded as a permutation problem in this paper, a usual small move operator is used based on the swap operator that consists in exchanging (or swapping) the location of two elements (or cities) c i and c j of the permutation (or tour). For a cities permutation of size n, the size of the neighborhood for each permutation is n(n À 1)/2. For example, Fig. <ref type="figure">2</ref> shows the neighborhood space associated with a TSP of size 3. In this case, the distance between two solutions is the fewest number of applying the swap operator that links the first solution to the second solution. For example, the distance between two permutations (2, 3, 1) and (1, 2, 3) is 2, see Fig. <ref type="figure">2</ref>. As seen, usually for two permutations there are different paths whose lengths are exactly equal to the distance between these two permutations. For example, the distance between two permutations (2, 3, 1) and (1, 2, 3) is 2, and there are three different paths between these two solutions with length 2, see Fig. <ref type="figure">2</ref>. In this paper, a random shortest path between the first solution and the second solution is selected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Independent movement operator: modified local search</head><p>As pointed out, a local search algorithm is a computational method that starts at a solution of the solution space and subsequently moves from the present solution to a neighboring solution that improves the objective function. In this paper, a modified version of the 2-opt (abbreviated for 2-optimal) algorithm is used <ref type="bibr" target="#b27">[28]</ref>. The 2-opt algorithm is the simplest and most known local search algorithm for TSP. This algorithm starts with a given tour and iteratively replaces two edges of the tour with two other edges in such a way that the new tour length is shorter. This process is continued until no more improvements are possible. Therefore, a tour is said to be 2-opt if it is impossible to obtain a shorter tour by replacing any two of its edges by any other set of two edges. Fig. <ref type="figure" target="#fig_0">4</ref> illustrates a 2-opt exchange of edges, typically called a 2-opt move. Notice that a 2-opt move keeps the tour feasible and corresponds to a reversal of a subsequence of the cities.</p><p>All parts of the used modified 2-opt algorithm in this paper are similar to the basic 2-opt algorithm except for its stopping criterion. As pointed out, the largest movement length of the ith agent in IMO is determined by an input parameter, whereas in the 2-opt algorithm the largest movement length of the ith agent is not specified at the beginning, so that the 2-opt process is continued until no more improvements are possible. To adapt the 2-opt with IMO, it is necessary that an input parameter whose value shows the largest movement of the ith agent be added to the 2-opt algorithm. The value of this input parameter for the ith agent is calculated by multiplication of a random number in interval [0, 1] by the previous movement length of the ith agent.</p><p>The worst case time complexity of naive 2-opt and also modified 2-opt is O(n 2 ), where n is the number of cities, which leads to a significant amount of CPU time per search step when applied to TSP instances with several hundreds or thousands of cities. Fortunately, there exist a number of speedup techniques that result in significant improvements in the time complexity of 2-opt steps. In this paper, some techniques such as Fixed Radius Search (FRS), Candidate Lists (CL), and Don't Look Bits (DLB) <ref type="bibr" target="#b22">[23]</ref> are used to improve the time complexity of the 2-opt algorithm. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Computational results</head><p>In this section, the performance of the proposed DGSA is investigated by applying the proposed algorithm to solve TSP benchmark instances taken from the standard TSPLIB library <ref type="bibr" target="#b37">[38]</ref>. Each instance is run for 50 independent replications. The proposed DGSATSP was implemented in C language and run on a PC with an Intel 2.2 GHz CPU. The parameters of DGS-ATSP are fixed on the following values: the number of searcher agents, i.e. s, is set to 10, the size of the RCL is set to 20, the initial value of K, i.e. K initial , is set to 5, the initial value of G, i.e. G initial , is set to 0.5, the end value of G, i.e. G end , is set to 0.1, and the stopping criterion is satisfied after 200 iterations. These parameters are experimentally obtained by testing the DGSATSP on the different instances.</p><p>The algorithm was tested on a set of 54 Euclidean benchmark instances with sizes ranging from 51 to 2392 nodes. The computational results generated by the proposed DGSATSP are given in Table <ref type="table" target="#tab_1">1</ref>. In this table, the first column shows the name of the instance, the second column shows the number of nodes of the instance, the third column gives the optimal solution for each instance taken from the TSPLIB, the fourth column shows the best solution found by the DGSATSP for each instance, the fifth column shows the average quality of the 50 runs of the algorithm (w average ), the sixth column shows the quality of the best run of the proposed algorithm (w best ) and finally, the seventh column gives the computational time of the best run needed to find the solution in terms of seconds. In each independent replication of the algorithm, the quality of the best obtained solution (w) is given in terms of the relative deviation from the optimum, that is w = (100(C DGSATSP À C opt ))/C opt , where C DGSATSP denotes the cost of the best solution found by the DGSATSP, and C opt is the cost of the optimal solution.</p><p>8th DIMACS Implementation Challenge <ref type="bibr" target="#b25">[26]</ref> is probably the most extensive examination to date of heuristic algorithms in the field of TSP and presents computational results for approximately 40 tour construction heuristics (divided in three categories, namely, Tour Construction Algorithms that Emphasize Speed over Quality, Classic Tour Construction Algorithms with quality more than 15% above the Held and Karp Bound, and Classic Tour Construction Algorithms with quality less than 15% of the Held and Karp Bound) and for approximately 80 tour improvement heuristics (divided into 5 categories, namely, Simple Local Search Algorithms (2-Opt, 3-Opt, etc.), Lin-Kernighan (LK) Implementations and Variants, Repeated Local Search Algorithms, algorithms that Use Chained LK as a Subroutine, and Metaheuristics (Tabu Search, etc.)). In Ref. <ref type="bibr" target="#b29">[30]</ref> a good ranking of most of the algorithms of this challenge is presented (for the instances with node number between 1002 and 2392, i.e. Pr1002, Pcb1173, D1291, Rl1304, Rl1323, Fl1400, Fl1577, Rl1889, D2103, and Pr2392). In Table <ref type="table" target="#tab_2">2</ref>, this ranking is updated with adding the proposed DGSATSP and an Adaptive Simulated Annealing with Greedy Search (ASA-GS) <ref type="bibr" target="#b14">[15]</ref> to the list of investigated algorithms. As seen in this table, the proposed DGSATSP is ranked in the ninth place among 55 algorithms. DGSATSP is ranked better than all tour construction heuristics. It is, also, ranked better than all simple local search algorithms, all Variable Neighborhood Search implementations, and all metaheuristics. Table <ref type="table" target="#tab_3">3</ref> shows a ranking of 10 algorithms of Table <ref type="table" target="#tab_2">2</ref> which have top quality in terms of the running time. As seen in this table, the proposed DGSATSP is ranked in the fourth place.</p><p>Also, Table <ref type="table" target="#tab_4">4</ref> shows a comparison in terms of both solution quality and running time between the proposed DGSATSP and a Max-Min Ant System (MMAS) <ref type="bibr" target="#b40">[41]</ref> which is one of the best implementations of the ant algorithm for solving TSP. As seen in Table <ref type="table" target="#tab_4">4</ref>, the average solution quality of MMAS is better than DGSATSP. But, the average running time of DGSATSP is better than MMAS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions and future work</head><p>Gravitational Search Algorithm (GSA) is a stochastic population-based metaheuristics which was originally designed for solving continuous optimization problems. In this paper, a Discrete Gravitational Search Algorithm (DGSA) was introduced to solve combinatorial optimization problems. The proposed DGSA, when applied to the Traveling Salesman Problem (DGS-ATSP) gave satisfactory results; infact, for the majority of examples considered, the results were equal to the best known solution. Moreover, when compared with 54 different algorithms it ranked ninth. In general, one of the main contributions of this paper was to show that the GSA can be used for solving combinatorial optimization problems with satisfactory results. In the future we may examine the performance of DGSA for other combinatorial optimization problems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. A 2-opt exchange of edges.</figDesc><graphic coords="10,178.58,589.89,183.29,83.23" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>(t) and fit i (t) represent the gravitational mass and the fitness value of the agent i at time t, respectively, and worst(t) and best(t) are defined as follows for a minimization problem:</figDesc><table><row><cell>q i ðtÞ ¼</cell><cell cols="4">fit i ðtÞ À worstðtÞ bestðtÞ À worstðtÞ</cell><cell>;</cell><cell>ð2Þ</cell></row><row><cell cols="2">M i ðtÞ ¼</cell><cell>q i ðtÞ P s j¼1 q j ðtÞ</cell><cell>;</cell><cell>ð3Þ</cell></row><row><cell cols="3">where M i bestðtÞ ¼ Min j2f1;2;...;sg</cell><cell cols="2">fit j ðtÞ;</cell><cell>ð4Þ</cell></row><row><cell cols="4">worstðtÞ ¼ Max j2f1;2;...;sg</cell><cell>fit j ðtÞ:</cell></row></table><note><p><p>Fi</p>gravitational mass of Oi .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>The computational results generated by proposed DGSATSP on Euclidean TSP benchmarks.</figDesc><table><row><cell>Instance</cell><cell cols="4">Size Optimum DGSATSP w average</cell><cell>w best</cell><cell>CPU</cell><cell cols="2">Instance Size</cell><cell>Optimum</cell><cell>DGSATSP</cell><cell>w average</cell><cell>w best</cell><cell>CPU</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(%)</cell><cell>(%)</cell><cell>(s)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(%)</cell><cell>(%)</cell><cell>(s)</cell></row><row><cell>Eil51</cell><cell>51</cell><cell>426</cell><cell>426</cell><cell>0.00</cell><cell>0.00</cell><cell>0.08</cell><cell>Ts225</cell><cell>225</cell><cell>126,643</cell><cell cols="2">126,643 0.00</cell><cell>0.00</cell><cell>0.93</cell></row><row><cell>Berlin52</cell><cell>52</cell><cell>7542</cell><cell>7542</cell><cell>0.00</cell><cell>0.00</cell><cell>0.06</cell><cell>Pr226</cell><cell>226</cell><cell>80,369</cell><cell cols="2">80,369 0.00</cell><cell>0.00</cell><cell>0.98</cell></row><row><cell>St70</cell><cell>70</cell><cell>675</cell><cell>675</cell><cell>0.00</cell><cell>0.00</cell><cell>0.08</cell><cell>Gil262</cell><cell>262</cell><cell>2378</cell><cell cols="2">2378 0.00</cell><cell>0.00</cell><cell>1.12</cell></row><row><cell>Eil76</cell><cell>76</cell><cell>538</cell><cell>538</cell><cell>0.00</cell><cell>0.00</cell><cell>0.11</cell><cell>Pr264</cell><cell>264</cell><cell>49,135</cell><cell cols="2">49,135 0.00</cell><cell>0.00</cell><cell>1.07</cell></row><row><cell>Pr76</cell><cell cols="2">76 1,08,159</cell><cell>1,08,159</cell><cell>0.00</cell><cell>0.00</cell><cell>0.10</cell><cell>A280</cell><cell>280</cell><cell>2579</cell><cell cols="2">2579 0.00</cell><cell>0.00</cell><cell>1.36</cell></row><row><cell>Rat99</cell><cell>99</cell><cell>1211</cell><cell>1211</cell><cell>0.00</cell><cell>0.00</cell><cell>0.13</cell><cell>Pr299</cell><cell>299</cell><cell>48,191</cell><cell cols="2">48,191 0.04</cell><cell>0.00</cell><cell>1.57</cell></row><row><cell cols="2">KroA100 100</cell><cell>21,282</cell><cell>21,282</cell><cell>0.00</cell><cell>0.00</cell><cell>0.15</cell><cell>Lin318</cell><cell>318</cell><cell>42,029</cell><cell cols="2">42,029 0.00</cell><cell>0.00</cell><cell>2.12</cell></row><row><cell cols="2">KroB100 100</cell><cell>22,141</cell><cell>22,141</cell><cell>0.00</cell><cell>0.00</cell><cell>0.16</cell><cell>Rd400</cell><cell>400</cell><cell>15,281</cell><cell cols="2">15,281 0.12</cell><cell>0.00</cell><cell>3.12</cell></row><row><cell cols="2">KroC100 100</cell><cell>20,749</cell><cell>20,749</cell><cell>0.00</cell><cell>0.00</cell><cell>0.15</cell><cell>Fl417</cell><cell>417</cell><cell>11,861</cell><cell cols="2">11,861 0.15</cell><cell>0.00</cell><cell>3.57</cell></row><row><cell cols="2">KroD100 100</cell><cell>21,294</cell><cell>21,294</cell><cell>0.00</cell><cell>0.00</cell><cell>0.17</cell><cell>Pr439</cell><cell>439</cell><cell>107,217</cell><cell cols="2">107,217 0.13</cell><cell>0.00</cell><cell>3.81</cell></row><row><cell>KroE100</cell><cell>100</cell><cell>22,068</cell><cell>22,068</cell><cell>0.00</cell><cell>0.00</cell><cell>0.16</cell><cell>Pcb442</cell><cell>442</cell><cell>50,778</cell><cell cols="2">50,783 0.21</cell><cell>0.01</cell><cell>4.25</cell></row><row><cell>Rd100</cell><cell>100</cell><cell>7910</cell><cell>7910</cell><cell>0.00</cell><cell>0.00</cell><cell>0.19</cell><cell>D493</cell><cell>493</cell><cell>35,002</cell><cell cols="2">35,002 0.31</cell><cell>0.00</cell><cell>5.01</cell></row><row><cell>Eil101</cell><cell>101</cell><cell>629</cell><cell>629</cell><cell>0.00</cell><cell>0.00</cell><cell>0.22</cell><cell>Rat575</cell><cell>575</cell><cell>6773</cell><cell cols="2">6775 0.49</cell><cell>0.04</cell><cell>6.95</cell></row><row><cell>Lin105</cell><cell>105</cell><cell>14,379</cell><cell>14,379</cell><cell>0.00</cell><cell>0.00</cell><cell>0.25</cell><cell>P654</cell><cell>654</cell><cell>34,643</cell><cell cols="2">34,643 0.18</cell><cell>0.00</cell><cell>7.89</cell></row><row><cell>Pr107</cell><cell>107</cell><cell>44,303</cell><cell>44,303</cell><cell>0.00</cell><cell>0.00</cell><cell>0.24</cell><cell>D657</cell><cell>657</cell><cell>48,912</cell><cell cols="2">48,956 0.78</cell><cell>0.09</cell><cell>9.32</cell></row><row><cell>Pr124</cell><cell>124</cell><cell>59,030</cell><cell>59,030</cell><cell>0.01</cell><cell>0.00</cell><cell>0.29</cell><cell>Rat783</cell><cell>783</cell><cell>8806</cell><cell cols="2">8811 0.67</cell><cell>0.06</cell><cell>12.04</cell></row><row><cell>Bier127</cell><cell>127</cell><cell>118,282</cell><cell>118,282</cell><cell>0.00</cell><cell>0.00</cell><cell>0.31</cell><cell>Dsj1000</cell><cell cols="4">1000 18,659,688 18,678,348 0.71</cell><cell>0.10</cell><cell>18.72</cell></row><row><cell>Ch130</cell><cell>130</cell><cell>6110</cell><cell>6110</cell><cell>0.00</cell><cell>0.00</cell><cell>0.34</cell><cell>Pr1002</cell><cell>1002</cell><cell>259,045</cell><cell cols="2">259,381 0.82</cell><cell>0.13</cell><cell>19.80</cell></row><row><cell>Pr136</cell><cell>136</cell><cell>96,772</cell><cell>96,772</cell><cell>0.00</cell><cell>0.00</cell><cell>0.40</cell><cell cols="2">Pcb1173 1173</cell><cell>56,892</cell><cell cols="2">56,937 1.42</cell><cell>0.08</cell><cell>24.09</cell></row><row><cell>Pr144</cell><cell>144</cell><cell>58,537</cell><cell>58,537</cell><cell>0.00</cell><cell>0.00</cell><cell>0.39</cell><cell>D1291</cell><cell>1291</cell><cell>50,801</cell><cell cols="2">50,821 0.37</cell><cell>0.04</cell><cell>28.11</cell></row><row><cell>Ch150</cell><cell>150</cell><cell>6528</cell><cell>6528</cell><cell>0.00</cell><cell>0.00</cell><cell>0.41</cell><cell>Rl1304</cell><cell>1304</cell><cell>252,948</cell><cell cols="2">253,175 0.79</cell><cell>0.09</cell><cell>30.78</cell></row><row><cell cols="2">KroA150 150</cell><cell>26,524</cell><cell>26,524</cell><cell>0.00</cell><cell>0.00</cell><cell>0.43</cell><cell>Rl1323</cell><cell>1323</cell><cell>270,199</cell><cell cols="2">270,334 0.31</cell><cell>0.05</cell><cell>31.67</cell></row><row><cell>Pr152</cell><cell>152</cell><cell>73,682</cell><cell>73,682</cell><cell>0.00</cell><cell>0.00</cell><cell>0.47</cell><cell>Fl1400</cell><cell>1400</cell><cell>20,127</cell><cell cols="2">20,149 0.68</cell><cell>0.11</cell><cell>32.12</cell></row><row><cell>Rat195</cell><cell>195</cell><cell>2323</cell><cell>2323</cell><cell>0.03</cell><cell>0.00</cell><cell>0.63</cell><cell>Fl1577</cell><cell>1577</cell><cell>22,249</cell><cell cols="2">22,249 0.21</cell><cell>0.00</cell><cell>34.49</cell></row><row><cell>D198</cell><cell>198</cell><cell>15,780</cell><cell>15,780</cell><cell>0.01</cell><cell>0.00</cell><cell>0.69</cell><cell>Rl1889</cell><cell>1889</cell><cell>316,536</cell><cell cols="2">316,536 0.38</cell><cell>0.00</cell><cell>37.94</cell></row><row><cell cols="2">KroA200 200</cell><cell>29,368</cell><cell>29,368</cell><cell>0.02</cell><cell>0.00</cell><cell>0.76</cell><cell>D2103</cell><cell>2103</cell><cell>80,450</cell><cell cols="2">80,546 1.16</cell><cell>0.12</cell><cell>43.01</cell></row><row><cell cols="2">KroB200 200</cell><cell>29,437</cell><cell>29,437</cell><cell>0.01</cell><cell>0.00</cell><cell>0.79</cell><cell>Pr2392</cell><cell>2392</cell><cell>378,032</cell><cell cols="2">378,372 0.91</cell><cell>0.09</cell><cell>45.12</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc>Ranking of the algorithms based on their average quality.</figDesc><table><row><cell>Rank</cell><cell>Method</cell><cell>Average</cell><cell>Rank</cell><cell>Method</cell><cell>Average</cell></row><row><cell>1</cell><cell>Tour Merging [4]</cell><cell>0.004</cell><cell>29</cell><cell>Concorde-LK [3,4]</cell><cell>3.916</cell></row><row><cell>2</cell><cell>ILK-NYYY [26]</cell><cell>0.009</cell><cell>30</cell><cell>4-Hyperopt [24]</cell><cell>4.062</cell></row><row><cell>3</cell><cell>ILK-JM [24]</cell><cell>0.041</cell><cell>31</cell><cell>LK-ABCC [4]</cell><cell>4.308</cell></row><row><cell>4</cell><cell>KH's MTV on LK [20]</cell><cell>0.064</cell><cell>32</cell><cell>3-Hyperopt [24]</cell><cell>4.559</cell></row><row><cell>5</cell><cell>I-3-opt-JM [24]</cell><cell>0.413</cell><cell>33</cell><cell>GENIUS [13]</cell><cell>4.685</cell></row><row><cell>6</cell><cell>ALK [25]</cell><cell>0.420</cell><cell>34</cell><cell>TS-2opt-2opt [45]</cell><cell>4.830</cell></row><row><cell>7</cell><cell>ACR Chained LK [4]</cell><cell>0.567</cell><cell>35</cell><cell>2.5opt-B [6]</cell><cell>5.930</cell></row><row><cell>8</cell><cell>ILK-N [34]</cell><cell>0.642</cell><cell>36</cell><cell>2opt-JM [24]</cell><cell>6.113</cell></row><row><cell>9</cell><cell>DGSATSP</cell><cell>0.705</cell><cell>37</cell><cell>2-Hyperopt [24]</cell><cell>6.218</cell></row><row><cell>10</cell><cell>Concorde CLK [3,4]</cell><cell>0.880</cell><cell>38</cell><cell>HK-Christofides [25]</cell><cell>6.496</cell></row><row><cell>11</cell><cell>LK-H [20]</cell><cell>0.969</cell><cell>39</cell><cell>2opt-B [6]</cell><cell>6.830</cell></row><row><cell>12</cell><cell>TS-SC-DB [45]</cell><cell>1.034</cell><cell>40</cell><cell>GENI [13]</cell><cell>8.050</cell></row><row><cell>13</cell><cell>ENS-GRASP [30]</cell><cell>1.181</cell><cell>41</cell><cell>CCA [25]</cell><cell>10.430</cell></row><row><cell>14</cell><cell>LK-HK-Christo-start [25]</cell><cell>1.202</cell><cell>42</cell><cell>CW [9]</cell><cell>11.260</cell></row><row><cell>15</cell><cell>TS-LK-DB [45]</cell><cell>1.241</cell><cell>43</cell><cell>2opt-C [4]</cell><cell>14.560</cell></row><row><cell>16</cell><cell>VNS-3-Hyperopt [25]</cell><cell>1.292</cell><cell>44</cell><cell>FI [6]</cell><cell>16.640</cell></row><row><cell>17</cell><cell>BSDPH [25]</cell><cell>1.308</cell><cell>45</cell><cell>RI [6]</cell><cell>17.470</cell></row><row><cell>18</cell><cell>LK-JM [24]</cell><cell>1.410</cell><cell>46</cell><cell>Boruvka [4]</cell><cell>17.760</cell></row><row><cell>19</cell><cell>SC EC [25]</cell><cell>1.702</cell><cell>47</cell><cell>CHCI [6]</cell><cell>17.960</cell></row><row><cell>20</cell><cell>LK-NYYY [26]</cell><cell>1.706</cell><cell>48</cell><cell>C-Greedy [4]</cell><cell>18.230</cell></row><row><cell>21</cell><cell>LK-N [34]</cell><cell>1.804</cell><cell>49</cell><cell>B-Greedy [25]</cell><cell>18.708</cell></row><row><cell>22</cell><cell>VNS-2-Hyperopt [25]</cell><cell>1.993</cell><cell>50</cell><cell>Q-Boruvka [4]</cell><cell>19.600</cell></row><row><cell>23</cell><cell>TS-SC-SC [45]</cell><cell>2.034</cell><cell>51</cell><cell>NN [4]</cell><cell>24.850</cell></row><row><cell>24</cell><cell>ASA-GS [15]</cell><cell>2.188</cell><cell>52</cell><cell>Spacefilling [25]</cell><cell>47.545</cell></row><row><cell>25</cell><cell>TS-LK-LK [45]</cell><cell>2.200</cell><cell>53</cell><cell>Best-Way Strip [25]</cell><cell>49.405</cell></row><row><cell>26</cell><cell>TS-2opt-DB [45]</cell><cell>3.110</cell><cell>54</cell><cell>FRP [6]</cell><cell>74.360</cell></row><row><cell>27</cell><cell>3opt-JM [24]</cell><cell>3.500</cell><cell>55</cell><cell>Strip [25]</cell><cell>75.565</cell></row><row><cell>28</cell><cell>3opt-B [6]</cell><cell>3.635</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc>Ranking of 10 top algorithms of Table2based on the running time.</figDesc><table><row><cell>Rank</cell><cell>Method</cell><cell>CPU Time (s)</cell></row><row><cell>1</cell><cell>ACR Chained LK [4]</cell><cell>1.58</cell></row><row><cell>2</cell><cell>I-3-opt-JM [24]</cell><cell>3.84</cell></row><row><cell>3</cell><cell>Concorde CLK [3,4]</cell><cell>20.45</cell></row><row><cell>4</cell><cell>DGSATSP</cell><cell>32.71</cell></row><row><cell>5</cell><cell>ILK-N [34]</cell><cell>46.17</cell></row><row><cell>6</cell><cell>KH's MTV on LK [20]</cell><cell>60.04</cell></row><row><cell>7</cell><cell>ILK-NYYY [26]</cell><cell>175.24</cell></row><row><cell>8</cell><cell>ILK-JM [24]</cell><cell>316.87</cell></row><row><cell>9</cell><cell>Tour Merging [4]</cell><cell>343.88</cell></row><row><cell>10</cell><cell>ALK [25]</cell><cell>858.78</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4</head><label>4</label><figDesc>Comparison between proposed DGSATSP and MMAS<ref type="bibr" target="#b40">[41]</ref>.</figDesc><table><row><cell>Instance</cell><cell>Size</cell><cell>Optimum</cell><cell>MMAS</cell><cell></cell><cell>DGSATSP</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>w average (%)</cell><cell>CPU (s)</cell><cell>w average (%)</cell><cell>CPU (s)</cell></row><row><cell>D198</cell><cell>198</cell><cell>15,780</cell><cell>0.00</cell><cell>21.96</cell><cell>0.01</cell><cell>0.69</cell></row><row><cell>Lin318</cell><cell>318</cell><cell>42,029</cell><cell>0.00</cell><cell>35.12</cell><cell>0.00</cell><cell>2.12</cell></row><row><cell>Pcb442</cell><cell>442</cell><cell>50,778</cell><cell>0.25</cell><cell>86.84</cell><cell>0.21</cell><cell>4.25</cell></row><row><cell>Rat783</cell><cell>783</cell><cell>8806</cell><cell>0.06</cell><cell>534.72</cell><cell>0.67</cell><cell>12.04</cell></row><row><cell>Pcb1173</cell><cell>1173</cell><cell>56,892</cell><cell>0.03</cell><cell>1268.48</cell><cell>1.42</cell><cell>24.09</cell></row><row><cell>D1291</cell><cell>1291</cell><cell>50,801</cell><cell>0.02</cell><cell>1281.17</cell><cell>0.37</cell><cell>28.11</cell></row><row><cell>Fl1577</cell><cell>1577</cell><cell>22,249</cell><cell>0.25</cell><cell>2139.32</cell><cell>0.21</cell><cell>34.49</cell></row><row><cell>Average</cell><cell></cell><cell></cell><cell>0.09</cell><cell>766.85</cell><cell>0.41</cell><cell>15.11</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>M.B. Dowlatshahi et al. / Information Sciences 258 (2014) 94-107</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>M.B. Dowlatshahi et al. / Information Sciences 258 (2014) 94-107</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>The authors thank the editor and reviewers for their valuable comments and suggestions that improved this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Local Search in Combinatorial Optimization</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H L</forename><surname>Aarts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Wiley &amp; Sons</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Chichester, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Finding Tours in the TSP</title>
		<author>
			<persName><forename type="first">D</forename><surname>Applegate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bixby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Chvatal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<idno>99885</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Bonn</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Forschungsinstitut fur Diskrete Mathematik</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Concorde: A code for Solving Traveling Salesman Problems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Applegate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bixby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Chvatal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<ptr target="&lt;http://www.math.princeton.edu/tsp/concorde.html&gt;" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Chained Lin-Kernighan for large traveling salesman problems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Applegate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bixby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Chvatal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Informs Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="82" to="92" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A prototype classifier based on gravitational search algorithm</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bahrololoum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nezamabadi-Pour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bahrololoum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Saeed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Soft Computing</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="819" to="825" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fast algorithms for geometric traveling salesman problems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ORSA Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="387" to="411" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Metaheuristics in combinatorial optimization: Overview and conceptual comparison</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="268" to="308" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A parallel ant colony algorithm on massively parallel processors and its convergence analysis for the travelling salesman problem</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">199</biblScope>
			<biblScope unit="page" from="31" to="42" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scheduling of vehicles from a central depot to a number of delivery points</title>
		<author>
			<persName><forename type="first">G</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="568" to="581" />
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Dorigo</surname></persName>
		</author>
		<title level="m">Optimization, Learning and Natural Algorithms</title>
		<meeting><address><addrLine>Milano, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A probabilistic heuristic for a computationally difficult set covering problem</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Feo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G C</forename><surname>Resende</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research Letters</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="67" to="71" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory on NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>W.H. Freeman and Co. Publishers</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">New insertion and post optimization procedures for the traveling salesman problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gendreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hertz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="1086" to="1094" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Metaheuristics in Combinatorial Optimization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gendreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Potvin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Operations Research</title>
		<imprint>
			<biblScope unit="volume">140</biblScope>
			<biblScope unit="page" from="189" to="213" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Solving the traveling salesman problem based on an adaptive simulated annealing algorithm with greedy search</title>
		<author>
			<persName><forename type="first">X</forename><surname>Geng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Soft Computing</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="3680" to="3689" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Tabu search and adaptive memory programming</title>
		<author>
			<persName><forename type="first">F</forename><surname>Glover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances, Applications and Challenges</title>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="1" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">F</forename><surname>Glover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Laguna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tabu</forename><surname>Search</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Kluwer Academic Publishers</publisher>
			<pubPlace>Laguna</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Chaotic secure communication based on a gravitational search algorithm filter</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">H</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">M</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Engineering Applications of Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="766" to="774" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A chaotic digital secure communication based on a modified gravitational search algorithm filter</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">H</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">M</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">208</biblScope>
			<biblScope unit="page" from="14" to="27" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An effective implementation of the Lin-Kernighan traveling salesman heuristic</title>
		<author>
			<persName><forename type="first">K</forename><surname>Helsgaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="page" from="106" to="130" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Outline for a logical theory of adaptive systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="297" to="314" />
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Adaptation in Natural and Artificial Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>University of Michigan Press</publisher>
			<pubPlace>Ann Arbor, MI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Hoos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stutzle</surname></persName>
		</author>
		<title level="m">Stochastic Local Search: Foundations and Applications</title>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The traveling salesman problem: a case study</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Mcgeoch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Local Search in Combinatorial Optimization</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Aarts</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</editor>
		<imprint>
			<publisher>Wiley and Sons</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="215" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The Traveling Salesman Problem and its Variations</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Mcgeoch</surname></persName>
		</author>
		<editor>G. Gutin, A. Punnen</editor>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Kluwer Academic Publishers</publisher>
			<biblScope unit="page" from="369" to="444" />
			<pubPlace>Dordrecht</pubPlace>
		</imprint>
	</monogr>
	<note>Experimental analysis of heuristics for the STSP</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">8th DIMACS Implementation Challenge: The Traveling Salesman Problem</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Mcgeoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Glover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rego</surname></persName>
		</author>
		<ptr target="&lt;http://www2.research.att.com/~dsj/chtsp/index.html&gt;" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Optimization by simulated annealing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Gelatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Vecchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">220</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Computer solutions of the traveling salesman problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Computer Journal</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="2245" to="2269" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">The P = NP Question and Godel&apos;s Lost Letter</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Expanding neighborhood GRASP for the traveling salesman problem</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Marinakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Migdalas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Pardalos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Optimization and Applications</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="231" to="257" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Honey bees mating optimization algorithm for the Euclidean traveling salesman problem</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Marinakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marinaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dounias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="page" from="4684" to="4698" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Large-step Markov chains for the traveling salesman problem</title>
		<author>
			<persName><forename type="first">O</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Otto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Felten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Complex Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="299" to="326" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Variable neighborhood search</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mladenovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1097" to="1100" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Neto</surname></persName>
		</author>
		<title level="m">Efficient Cluster Compensation for Lin-Kernighan Heuristics</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science University of Toronto, Canada</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Using gravitational search algorithm for finding near-optimal base station location in two-tiered WSNs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Rafsanjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dowlatshahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Machine Learning and Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="377" to="380" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">GSA: a gravitational search algorithm</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rashedi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nezamabadi-Pour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saryazdi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">179</biblScope>
			<biblScope unit="page" from="2232" to="2248" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Filter modeling using gravitational search algorithm</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rashedi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nezamabadi-Pour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saryazdi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Engineering Applications of Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="117" to="122" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">TSPLIB-a traveling salesman problem library</title>
		<author>
			<persName><forename type="first">G</forename><surname>Reinelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ORSA Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="376" to="384" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A novel opposition-based gravitational search algorithm for combined economic and emission dispatch problems of power systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mukherjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Electrical Power &amp; Energy Systems</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="21" to="33" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Local Search Algorithms for Combinatorial Problems: Analysis, Algorithms and New Applications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Stutzle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>Sankt Augustin, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>DISKI-Dissertationenzur Kunstliken Intelligenz.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Max-min ant system</title>
		<author>
			<persName><forename type="first">T</forename><surname>Stutzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Hoos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="889" to="914" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Talbi</surname></persName>
		</author>
		<title level="m">Metaheuristics: From Design to Implementation</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A heuristic-based hybrid genetic-variable neighborhood search algorithm for task scheduling in heterogeneous multiprocessor system</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="page" from="567" to="581" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A novel hybrid K-harmonic means and gravitational search algorithm approach for clustering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Systems with Applications</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="9319" to="9324" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Tabu search on the geometric traveling salesman problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zachariasen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Metaheuristics: Theory and Applications</title>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Osman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Kelly</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="571" to="587" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A parallel immune algorithm for traveling salesman problem and its application on cold rolling scheduling</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="page" from="1212" to="1223" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
