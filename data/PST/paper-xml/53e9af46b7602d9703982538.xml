<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Monotonic and Residuated Logic Programs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Carlos</forename><surname>Viegas</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Luís</forename><forename type="middle">Moniz</forename><surname>Pereira</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Centro de Inteligência Artificial (CENTRIA)</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Departamento de Informática</orgName>
								<orgName type="institution">Universidade Nova de Lisboa</orgName>
								<address>
									<postCode>2829-516</postCode>
									<settlement>Caparica</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Monotonic and Residuated Logic Programs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">31C72547B956CB548B0396B1AF38E851</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Logic Programming</term>
					<term>Possibilistic Logic</term>
					<term>Many-valued logics</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we define the rather general framework of Monotonic Logic Programs, where the main results of (definite) logic programming are validly extrapolated. Whenever defining new logic programming extensions, we can thus turn our attention to the stipulation and study of its intuitive algebraic properties within the very general setting. Then, the existence of a minimum model and of a monotonic immediate consequences operator is guaranteed, and they are related as in classical logic programming. Afterwards we study the more restricted class of residuated logic programs which is able to capture several quite distinct logic programming semantics. Namely: Generalized Annotated Logic Programs, Fuzzy Logic Programming, Hybrid Probabilistic Logic Programs, and Possibilistic Logic Programming. We provide the embedding of possibilistic logic programming.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The literature on logic programming theory is brimming with proposals of languages and semantics for extensions of definite logic programs (e.g. <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10]</ref>), i.e. those without non-monotonic or default negation. Usually, the authors characterize their programs with a model theoretic semantics, where a minimum model is guaranteed to exist, and a corresponding monotonic fixpoint operator (continuous or not). In many case the semantics is many-valued.</p><p>In this paper we abstract out all the details and define a rather general framework of Monotonic Logic Programs to capture the core "spirit" of logic programming. For this purpose we follow an algebraic approach to both the language and the semantics of logic programs. We were inspired by the deep theoretical results of many-valued logics and fuzzy logic (see <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b8">9]</ref> for excellent accounts) and applied these ideas to logic programming. In fact, a preliminary work in this direction is <ref type="bibr" target="#b18">[19]</ref>, but the authors restrict themselves to a linearly ordered set of truth-values (the real closed interval [0, 1]) and to a very limited syntax: the head of a rule is a literal and the body is a multiplication (t-norm) of literals. We start by defining the notion of an implication symbol, sufficient to guarantee the validity of the standard logic programming results. Later on we resort to residuated lattices (c.f. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b8">9]</ref>), where a generalized modus ponens rule is defined. This characterizes the essence of logic programming: from the truth-value of bodies of rules for an atom we can determine the truth-value of that atom, depending on the degree of confidence in each of the rules.</p><p>Our paper proceeds as follows. In Section 2 we introduce the language of Monotonic Logic Programs and associated implication algebras. In the section after that we present our main theoretical results. Then we set forth the definitions of residual lattices and show that the Residuated Logic Programs of <ref type="bibr" target="#b1">[2]</ref> are a special instance of Monotonic Logic Programs, where one associates with each rule a weight or confidence factor. Lastly, we show the embedding of Possibilistic Logic Programming into Residuated Logic Programs, and terminate with some conclusions and future directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Monotonic Logic Programs</head><p>The theoretical foundations of logic programming were clearly established in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16]</ref> for definite logic programs (see also <ref type="bibr" target="#b11">[12]</ref>), i.e. programs made up of rules of the form</p><formula xml:id="formula_0">A 0 ⊂ A 1 ∧. . .∧A n (n ≥ 0) where each A i (0 ≤ i ≤ n) is a propositional sym- bol (an</formula><p>atom), ⊂ is classical implication, and ∧ the usual Boolean conjunction. In this section we generalize the language of definite logic programs in order to encompass more complex bodies and heads and, evidently, many-valued logics. For simplicity, we consider only the propositional (ground) case.</p><p>When defining a (new) logic it is necessary to address the following two distinct but related aspects: the syntax and the corresponding interpretation of the logical symbols in the language. In this paper we adopt an algebraic characterization of both the language and interpretation of operators. This is a very general and powerful framework, allowing for a simple relation between the two. For lack of space, we reduce the presentation to the essentials. For more details consult for instance <ref type="bibr" target="#b7">[8]</ref>.</p><p>The main assumptions of the paper are collected in the next two definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Implication Algebra).</head><p>Let T =&lt; T , &gt; be a complete upper semilattice <ref type="foot" target="#foot_1">1</ref> and consider an algebra A on the carrier set T . We say that A is an implication algebra with respect to T iff it has defined an operator ← on A such that ∀ a1,a2∈T (a 1 ← a 2 ) = iff a 1 a 2 where is the top element of T.</p><p>Example 1. The closed real interval [0, 1] with the usual ordering is a complete lattice. The algebra G on [0, 1] with Gödel implication x ⇐ y = 1 (if x ≥ y), and x ⇐ y = x otherwise, is an implication algebra. It is obvious that if x &lt; y then x ⇐ y &lt; 1.</p><p>Mark that some many-valued logics have implication connectives which do not obey the property of implication algebras. We shall illustrate this in the next section.</p><p>Our Monotonic and Residuated Logic Programs will be constructed from the abstract syntax induced by an implication algebra and a set of propositional symbols. The method of relating syntax and semantics in such an algebraic setting is well-known and we defer again to <ref type="bibr" target="#b7">[8]</ref> for more details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Monotonic Logic Programs).</head><p>Let A be an implication algebra with respect to a complete lattice T. Let Π be a set of propositional symbols and F ORM A (Π) the corresponding algebra of formulae freely generated from Π and the "symbols" of operators in A. A monotonic logic program is a set of rules of the form A ← Ψ such that:</p><formula xml:id="formula_1">1. The rule (A ← Ψ ) is a formula of F ORM A (Π); 2.</formula><p>The head of the rule A is a propositional symbol of Π. 3. The body formula Ψ with propositional symbols B 1 , . . . , B n (n ≥ 0) corresponds to an isotonic function having those symbols as arguments.</p><p>As usual we shall represent binary connectives in infix notation.</p><p>A rule of a monotonic logic program expresses a (monotonic) computation rule of the truth-value of the head propositional symbol from the truth-values of the symbols in the body. The monotonicity of the rule is guaranteed by the isotonicity of the function corresponding to formula Ψ : if an argument of Ψ is monotonically increased then the truth-value of Ψ also monotonically increases. The unique homomorphic extension theorem, guarantees that for every interpretation of propositional symbols there is an unique associated valuation function. Mark too that we employ the same symbol to represent a connective at the syntactic level (formulas) and the corresponding operator in the underlying algebra. This simplifies presentation. A simple analysis easily concludes that a ⇐ b ∧ c is a correct monotonic logic program rule, since λbc. ∧ (b, c) = λbc.min(b, c) is an isotonic function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Model and Fixpoint Theory for Monotonic Logic Programs</head><p>In this section we define a model and a fixpoint theory for Monotonic Logic Programs, and extend to them the classical results of logic programming. The important point to realize is that all the fundamental results of logic programming depend only on the monotonicity of the body of the rule and on the fact that it is possible to determine the truth-value of the proposition in the head from the truth-value of the rule body. Also notice that we demand all the rules to be satisfied: every implication should evaluate to .</p><p>Let us start by defining the notion of interpretation. An interpretation is simply an assignment of truth-value to each propositional symbol in the language. We assume, in the remainder of this section, an implication algebra A with respect to a complete lattice T =&lt; T , &gt;. The operator and implication symbol will be denoted by ←. Consider also that a set Π of propositional symbols is given, as well as the corresponding algebra F ORM A (Π) of formulae over Π. Forthwith, the notion of interpretation is straightforward:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Interpretation). An interpretation is a mapping I : Π → T . By the unique homomorphic extension theorem, the interpretation extends uniquely to a valuation function Î : F ORM A (Π) → T . The set of all interpretations with respect to the implication algebra A is denoted by</head><formula xml:id="formula_2">I A .</formula><p>The ordering on the truth-values in T is extended to the set of interpretations as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Lattice of interpretations). Consider I A the set of all interpretations with respect to implication algebra A, and two arbitrary interpretations</head><formula xml:id="formula_3">I 1 , I 2 ∈ I A . Then, &lt; I A , &gt; is a complete lattice where I 1 I 2 iff ∀ p∈Π I 1 (p) I 2 (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>p). The least interpretation maps every propositional symbol to the least element of T , and the greatest interpretation maps every propositional symbol to the top element of the complete lattice of truth values T .</head><p>A rule of a monotonic logic program is satisfied whenever the truth-value of the rule is . A model is an interpretation which satisfies every rule in the program. Formally:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Model of a program). Consider an interpretation I ∈ I</head><formula xml:id="formula_4">A . A monotonic logic program rule A ← Ψ is satisfied by I iff Î ((A ← Ψ )) = .</formula><p>Interpretation I is a model of a monotonic logic program P iff all rules in P are satisfied by I.</p><p>We proceed by showing that every monotonic logic program has a least model which is the least fixpoint of a monotonic operator, along with other standard logic programming results. One such result is the immediate consequences operator, extending the results of van Emden and Kowalski <ref type="bibr" target="#b15">[16]</ref> to the general theoretical setting of implication algebras: Definition 6 (Immediate consequences operator). Let P be a monotonic logic program. Define the immediate consequences operator T A P : I A → I A , mapping interpretations to interpretations, as:</p><formula xml:id="formula_5">T A P (I)(A) = lub Î(Ψ ) such that A ← Ψ ∈ P</formula><p>where A is a propositional symbol.</p><p>The immediate consequences operator evaluates the body of every rule for a propositional symbol A. The truth-value of A is simply the least upper bound of the truth-values of all the bodies of the rules for it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Monotonicity of the immediate consequences operator).</head><p>Let I 1 and I 2 be two interpretations in I A , and P a monotonic logic program. Operator T A P is monotonic, i.e. if I 1 I 2 then T A P (I 1 ) T A P (I 2 ). As usual, the set of models of P is characterized by the post-fixpoints of T R P : Theorem 2. An interpretation I of I A is a model of a monotonic logic program P iff T A P (I) I. By the Knaster-Tarski fixpoint theorem, T A P has a least fixpoint. Thus: Definition 7 (Semantics of Monotonic Logic Programs). Let P be a monotonic logic program and M P the least fixpoint of T A P . The semantics of a monotonic logic program is given by M P , being its least model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 (Fixpoint Semantics). Let P be a monotonic logic program, and consider the transfinite sequence of interpretations of I A :</head><formula xml:id="formula_6">T A P ↑ 0 = T A P ↑ n+1 = T A P (T R P ↑ n ), if n + 1 is a successor ordinal T A P ↑ α = β&lt;α T A P ↑ β , if α is a limit ordinal</formula><p>Then, there is an ordinal λ such that T A P ↑ λ+1 = T A P ↑ λ , and the least model of P is M P = T A P ↑ λ . The major difference from standard classical logic programming is that our T A P operator might not be continuous, and therefore more than ω iterations may be necessary to "reach" the least fixpoint. All the other important results carry over to our general framework. This possibility is unavoidable if one wants to retain generality. For the study of sufficient conditions to guarantee the continuity of the T A P , see <ref type="bibr" target="#b12">[13]</ref>. We now illustrate the importance of the provisions of Definition 1 with an example: Example 3. Reichenbach <ref type="bibr" target="#b14">[15]</ref> devised a calculus for addressing the logical problems raised by quantum mechanics. He defined three implications, three negations, two equivalences, a conjunction and a disjunction. For our example, the three implication operators and conjunction will suffice. The set of truth-values is {0, 1, 2} with the usual ordering. The truth-tables<ref type="foot" target="#foot_2">2</ref> are:</p><formula xml:id="formula_7">⊂ 0 1 2 0 2 1 0 1 2 2 1 2 2 2 2 ⇐ 0 1 2 0 2 2 0 1 2 2 0 2 2 2 2 ← 0 1 2 0 1 1 0 1 1 1 1 2 1 1 2 ∧ 0 1 2 0 0 0 0 1 0 1 1 2 0 1 2</formula><p>Consider the three programs below:</p><formula xml:id="formula_8">a ⊂ b ∧ c b ⊂ 1 c ⊂ 1 a ⇐ b ∧ c b ⇐ 1 c ⇐ 1 a ← b ∧ c b ← 1 c ← 1</formula><p>The least fixpoint of the immediate consequences operator when applied to the above programs results in the same interpretation, mapping propositions a, b, and c to truth-value 1. The first implication (⊂) complies with the provisions of Definition 1. Therefore the interpretation so obtained is the least model of the program on the left, as can be checked easily .</p><p>For the middle program, we know that t 1 ≥ t 2 implies (t 1 ⇐ t 2 ) = 2, for t 1 , t 2 ∈ {0, 1, 2} but the converse does not hold. In general, the least fixpoint is a model of the program but might not be minimal, as in this case: the interpretation mapping every proposition to 0 is a model.</p><p>Finally, for the program on the right, we have that (t 1 ← t 2 ) = 2 entails t 1 ≥ t 2 but not conversely. This situation is more problematic, since the least fixpoint might not be a model of the program, as per the example. In fact, this program has no model because the implications will always be evaluated to a truth-value different from 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Residuated Logic Programs</head><p>In a non-classical setting the intended truth-value of a given rule might possibly not be absolute truth. So, a generalization of Modus Ponens is required to reason logically with confidence factors. In many-valued logics this issue is very well understood, namely in Fuzzy Propositional Logics <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b8">9]</ref>. Since one of our initial goals was to capture Fuzzy Logic Programming <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b18">19]</ref>, it is natural to adopt as the semantical basis the residuated lattices (see for instance <ref type="bibr" target="#b0">[1]</ref>). Definition 8 (Adjoint pair). Let &lt; P, P &gt; be a partially ordered set and (←, ⊗) a pair of binary operations in P . We say that (←, ⊗) forms an adjoint pair in &lt; P, P &gt; iff:</p><formula xml:id="formula_9">(a 1 ) Operation ⊗ is isotonic, i.e. if x 1 , x 2 , y ∈ P such that x 1 P x 2 then</formula><p>(x 1 ⊗ y) P (x 2 ⊗ y) and (y ⊗ x 1 ) P (y ⊗ x 2 ); (a 2 ) Operation ← is isotonic in the first argument (the consequent) and antitonic in the second argument (the antecedent), i.e. if x 1 , x 2 , y ∈ P such that x 1 P x 2 then (x 1 ← y) P (x 2 ← y) and (y ← x 2 ) P (y ← x 1 ); (a 3 ) For any x, y, z ∈ P , we have that x P (y ← z) holds if and only if (x ⊗ z) P y holds.</p><p>The intuition for the two above properties is immediate, the third one may be more difficult to grasp. In one direction, it is simply asserting that the following Fuzzy Modus Ponens rule is valid (cf. <ref type="bibr" target="#b8">[9]</ref>):</p><p>If x is a lower bound of ψ ← ϕ, and z is a lower bound of ϕ then a lower bound y of ψ is x ⊗ z.</p><p>The other direction ensures that the truth-value of y ← x is in fact the maximal z satisfying x ⊗ z P y. Mark that the implication symbol in an adjoint pair must obey the provisions of Definition 1.</p><p>Besides (a 1 )-(a 3 ), it is necessary to assume the existence of a bottom and a top element in the lattice of truth-values, and that is an unit element of ⊗. It is also usual to assume, additionally, extra conditions on the multiplication operation (⊗), namely associativity, commutativity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 9 (Residuated Lattice).</head><p>Consider the lattice L =&lt; L, L &gt;. We say that (L, ←, ⊗) is a residuated lattice whenever the following three conditions are met:</p><p>(l 1 ) L is a bounded lattice: it has a bottom (⊥) and a top element ( ); (l 2 ) (←, ⊗) is an adjoint pair in L; (l 3 ) (L, ⊗, ) is a commutative monoid <ref type="foot" target="#foot_3">3</ref> .</p><p>We say that the residuated lattice is complete whenever &lt; L, L &gt; is complete. In this case condition (l 1 ) is immediately satisfied.</p><p>For residuated logic programs we resort to special implication algebra where a multiplication operation is defined, and the corresponding residuum operation (or implication), plus a constant representing the top element of the lattice of truth-values (whose set is the carrier of the algebra). Together they must define a complete residuated lattice since we intend to deal with infinite programs (theories). Obviously, a residuated algebra may have additional operators. Formally: Definition 10 (Residuated Algebra). Let (L, ←, ⊗) be a complete residuated lattice. The implication algebra A defining operators ←, ⊗ with respect to L is a residuated algebra.</p><p>From the example at the beginning of this section, it should be clear that in order to define the syntax of residuated logic programs it is necessary to know beforehand the underlying truth-value residuated algebra, given that each program rule must be associated with a truth-value. Thus, it is natural to generalize the language of monotonic logic programs as follows (for a particular instance see <ref type="bibr" target="#b18">[19]</ref>): Therefore, all the theorems of monotonic logic programs carry over directly to residuated ones, under the notion of model portrayed in the above theorem. In <ref type="bibr" target="#b12">[13]</ref> several implication operators can be put to use. However, it is easily seen that the embedding of Definition 11 can be trivially adapted to handle several adjoint pairs in the lattice of truth-values, and so the corresponding notion of model is the same. Thus Multi-Adjoint Logic Programs are indeed an instance of Monotonic ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 11 (Residuated Logic Programs). Let R be a residuated algebra with respect to a residuated lattice (T, ←, ⊗). A residual logic program is a monotonic logic program over R with rules of the form A ← ϑ ⊗ Ψ where ϑ is a truth-value in T, and Ψ an arbitrary isotonic formula. A (weighted) rule</head><formula xml:id="formula_10">A ← ϑ ⊗ Ψ is represented 4 by A ϑ ← -Ψ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Possibilistic Logic Programming</head><p>As summarized in <ref type="bibr" target="#b6">[7]</ref>, possibilistic logic is a logic of uncertainty tailored for reasoning under incomplete evidence and partially inconsistent knowledge. Each formula in the language is assigned a weight in a totally ordered set, corresponding to a lower bound on the degree of necessity or possibility of the formula. The degree of necessity of a formula states to what extent the available evidence entails the truth of the formula, while the degree of possibility expresses to what extent the truth of a formula is not incompatible with the available evidence. The theory is built upon the notion of possibility measure Π <ref type="bibr" target="#b19">[20]</ref>, obeying the following axioms:</p><formula xml:id="formula_11">Π(⊥) = 0 Π( ) = 1 ∀ p,q Π(p ∨ q) = max(Π(p), Π(q))</formula><p>The logic is not truth-functional since in general it is only guaranteed that Π(p ∧ q) ≤ min(Π(p), Π(q)). We base our presentation on <ref type="bibr" target="#b5">[6]</ref> and consider as well only propositional clauses. For the full theory the reader is referred to the excellent overview of <ref type="bibr" target="#b6">[7]</ref>.</p><p>A propositional possibilistic clause is either a pair (c (Nα)) or a pair (c (Πβ)), where c is a propositional clause, α ∈ ]0, 1] and β ∈ [0, 1]. In general terms, the semantics is engendered from the possibility measures which satisfy the set of possibilistic clauses:</p><p>-The formula (c (Nα)) states that c is certain at least to degree α, i.e. N (c) ≥ α which is equivalent to Π(¬c) ≤ 1 -α. -The expression (c (Πβ)) states that c is possible in some world at least to degree β, i.e. Π(c) ≥ β.</p><p>Notice that Π and N are dual measures of necessity and possibility governed by the equation N (c) = 1 -Π(¬c). The truth-values (Π0), . . . , (Πβ), . . . , (Π1), . . . , (Nα), . . . , (N 1) are totally ordered. We denote the complete lattice formed this way by P. The semantics of a possibilistic set of clauses F is given by a consequence relation. We say that (c w) is a logical consequence of F (denoted by F |= (c w)) if every possibility measure that satisfies F also satisfies (c w).</p><p>There is a formal system <ref type="bibr" target="#b6">[7]</ref> which is sound and complete with respect to the above inconsistency-tolerant semantics of possibilistic logic. The inference rules for the propositional case are:</p><formula xml:id="formula_12">(GM P ) (ϕ w 1 ), (ϕ → ψ w 2 ) (ψ w 1 * w 2 ) (S) (ϕ w 1 ) (ϕ w 2 ), ∀w 2 ≤ w 1</formula><p>where operation * is defined by</p><formula xml:id="formula_13">(Nα) * (Nβ) = (N min(α, β)) (Nα) * (Πβ) = (Πβ) if α + β &gt; 1 (Π0) if α + β ≤ 1 (Πα) * (Πβ) = (Π0)</formula><p>The important point for our discussion is that * is a multiplication operation and therefore we can define an appropriate residuum operator ( ) such that jointly they form an adjoint pair. In our setting, and given an interpretation I such that Î(ϕ) = w 1 we know that</p><formula xml:id="formula_14">Î(ψ ϕ) ≥ w 2 iff Î(ψ) ≥ Î(ϕ) * w 2 iff Î(ψ) ≥ w 1 * w 2</formula><p>similarly to the above inference rule (GM P ). Notice that our interpretations might not be models of the possibilistic theory. However, we are able to extract some information regarding the possibility or necessity degree of propositional symbols. This is a technique quite similar to the one employed by Kifer and Subrahmanian <ref type="bibr" target="#b9">[10]</ref> for embedding van Emden's quantitative rules into GAPs <ref type="bibr" target="#b16">[17]</ref>.</p><p>To simplify the presentation we map the truth values in P to the real interval [0, 1], as follows: truth-value (Π β) is mapped to β 2 and truth-value (N α) corresponds to 1+α  2 . This is a bijection. The multiplication operator * is isomorphic to operator × in the definition next: Definition 12 (Possibilistic Residuated Algebra). Let P be the residuated algebra on [0, 1] with multiplication × and implication operators defined by: <ref type="bibr" target="#b5">[6]</ref> is a finite set of (first-order) possibilistic Horn Clauses annotated only with necessity degrees. We consider just the case of propositional Possibilistic Logic Programs. We have the following expected result: Theorem 5. Let F be a propositional possibilistic logic program, a set of possibilistic Horn clauses (B 1 ∧. . .∧B n → A w) where A, B 1 , . . . B n are propositional symbols and w is a weight of the form (Nα). We construct monotonic logic program P over P by translating each possibilistic Horn clause to the attendant monotonic logic program rule A p × B 1 × . . . × B n where p = 1+α 2 is the real number in [0, 1] corresponding to weight w. Then F |= (A w) iff w ≤ (lfp T P P )(A). For the case of possibilistic Horn clauses annotated with possibility degrees which is not addressed in <ref type="bibr" target="#b5">[6]</ref>, our own translation is sound but not complete, as discussed in the next example: Example 4. Consider the possibilistic theory:</p><formula xml:id="formula_15">p 1 × p 2 = 0 if p 1 + p 2 ≤ 1 min(p 1 , p 2 ) if p 1 + p 2 &gt; 1 p 1 p 2 =    1 if p 1 ≥ p 2 p 1 if p 1 &lt; p 2 and p 1 + p 2 &gt; 1 1 -p 2 if p 1 &lt; p 2 and p 1 + p 2 ≤ 1 A Possibilistic Logic Program</formula><formula xml:id="formula_16">(a ∧ b → q(N 1)) (p → a (N 1)) (p → b (N 1)) (p (Π1))</formula><p>Translating the above to a residual logic program we surmise in the least fixpoint of the immediate consequences operator that q is provable with degree (Π0). However, in possibilistic logic we conclude (q (Π1). The problem is that our T P P operator is not aware that the proofs for (a (Π1) and (b Π1) depend on the same proposition p.</p><p>We conjecture, however, that in situations where the proof does not depend on multiple uses of the same proposition, we extract the correct conclusions:</p><p>Example 5 (adapted from <ref type="bibr" target="#b5">[6]</ref>). Consider the knowledge base: works(john, paris) → lives(john, paris) (N 0.7) works(mary, paris) → lives(mary, paris) (N 0.7) works(henry, paris) → lives(henry, paris) (N 0. We gather from the least model of the above monotonic logic program that works(mary, paris) and works(henry, paris) have confidence 1.0, i.e. necessity degree (N 1). Moreover, both Henry and Mary live in Paris with necessity degree (N 0.7). Regarding John, the proposition works(john, paris) is ascribed the truth-value 0.4 corresponding to possibility degree (Π 0.8), and lives(john, paris) receives value 0.8, meaning that it is necessary that John lives in Paris with at least degree 0.6. Such results are in accordance with Possibilistic Logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions and Further Work</head><p>The strong point of this paper is the generality of our setting, both at the language and at the semantical level. We have presented an algebraic characterization of Monotonic Logic Programs. Program rules are arbitrary monotonic body functions where the heads are propositional symbols. Our semantic structures are implication algebras where an appropriate implication operator is imposed.</p><p>We then obtain a logic programming semantics with corresponding model and fixpoint theory. The major construction is a generalized immediate consequences operator, in the spirit of van Emden and Kowalski's T p operator. The operator is monotonic and the models of a Monotonic Logic Program are its post-fixpoints. Therefore a minimum model is guaranteed to exist, it being the least fixpoint of the immediate consequences operator. Thus, when defining a new logic programming semantics we can shift attention to the stipulation and study of its intuitive semantical algebraic properties because the main results of definite logic programming carry over for free to this very general setting.</p><p>We have studied residual lattices and algebras, where a generalized form of Modus Ponens Rule is valid. Having defined an implication (or residuum operator), and the associated multiplication, we can assign to program rules a confidence factor, thereby defining residuated logic programs. We show that the results of Monotonic Logic Programs carry over immediately to Residuated ones.</p><p>We provide a simple translation of Possibilistic Logic Programming into Residuated Logic Programs, and discuss the issues arising from the introduction of possibility degrees. In <ref type="bibr" target="#b1">[2]</ref> we have previously shown that our framework can capture Hybrid Probabilistic Logic Programs <ref type="bibr" target="#b3">[4]</ref>. Both ground Generalized Annotated Logic Programs <ref type="bibr" target="#b9">[10]</ref> and Fuzzy Logic Programming <ref type="bibr" target="#b18">[19]</ref> are also special cases of our setting.</p><p>The embedding of c-annotated ground GAP rules under the restricted semantics is direct, and uses a technique similar to the one presented in <ref type="bibr" target="#b1">[2]</ref>. More interestingly, we devised a way for translating ground GAPs rules with arbitrary annotations (constant, variable, or term annotated) into a single Monotonic Logic Programming rule without occurrences of variables. This translation only assumes that (finite) meets are defined in the truth-value complete upper semi-lattice. The converse is also possible, using an extension of the embedding of Fuzzy Logic Programs into Annotated Logic Programming <ref type="bibr" target="#b17">[18]</ref>. It shall be the subject of forthcoming work.</p><p>Our incursion paves the way to combine and integrate several forms of reasoning into a uniform framework, namely fuzzy, probabilistic, uncertain, and paraconsistent reasoning. We have defined too <ref type="bibr" target="#b2">[3]</ref> another class of logic programs, extending the Monotonic one, where rule bodies may be anti-monotonic functions, with well-founded and Stable Model like semantics. This brings together non-monotonic and incomplete forms of reasoning with those listed before. L. Caires for helpful discussions. Special thanks to Manuel Ojeda-Aciego for his insightful comments and for sending us a preliminary version of the paper <ref type="bibr" target="#b12">[13]</ref>. We also thank Peter Vojtás for letting us know of the existence of <ref type="bibr" target="#b17">[18]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 2 .</head><label>2</label><figDesc>Consider the set of propositional symbols Π = {a, b, c} and the implication algebra of Example 1 with the additional operator x∧y = min(x, y). As common, we denote the algebra by G([0, 1], ⇐, ∧). The arity of the operators is implicit. Mark that ∧ is the meet in [0, 1]. The formulas b ∧ c and a ⇐ b ∧ c correspond to the functions λbc. ∧ (b, c) and λabc. ⇐ (a, ∧(b, c)), respectively. Variables range over the interval [0, 1].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 4 (</head><label>4</label><figDesc>Consequently, residuated logic programs are a special class of monotonic ones. The important result is the following: Model of a Residuated Logic Program). An interpretation I ∈ I R is a model of a residuated logic program P iff Î (A ← Ψ ) ϑ for every weighted rule A ϑ ← -Ψ in P .</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>S. Benferhat and P. Besnard (Eds.): ECSQARU 2001, LNAI 2143, pp. 748-759, 2001. c Springer-Verlag Berlin Heidelberg 2001</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>The original formulation of this definition assumed a complete lattice. As shown in<ref type="bibr" target="#b12">[13]</ref>, we can easily generalize to complete upper semilattices since the meet operation over infinite sets is never used. This is also the case for GAPs<ref type="bibr" target="#b9">[10]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>For the implication connectives, the consequent truth-value appears in rows and the antecedent one in columns.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>It is shown in<ref type="bibr" target="#b12">[13]</ref> that (l3) can be substituted by the weaker condition ⊗ ϑ = ϑ ⊗ = ϑ.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>We are assuming that every truth-value has a corresponding constant mapping in R.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. Work partially supported by PRAXIS projects MEN-TAL and FLUX. We thank V. S. Subrahmanian, J. Dix, T. Eiter, J. Alferes and</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Many-Valued Logics. Theoretical Foundations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bolc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Borowik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Hybrid probabilistic logic programs as residuated logic programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Damásio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logics in AI, Proceedings of JELIA&apos;00</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Aciego</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">P</forename><surname>De Guzmán</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Pereira</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000-09">September 2000</date>
			<biblScope unit="volume">1919</biblScope>
			<biblScope unit="page" from="57" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Antitonic logic programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Damásio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LPNMR&apos;01</title>
		<meeting>LPNMR&apos;01</meeting>
		<imprint>
			<date type="published" when="2001-09">September 2001</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hybrid probabilistic programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dekhtyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="187" to="250" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fuzzy sets in approximate reasoning, part 2: Logical approaches</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Prade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fuzzy Sets and Systems</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="203" to="244" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Towards possibilistic logic programming</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Prade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICLP&apos;91</title>
		<meeting>of ICLP&apos;91</meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="581" to="598" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Possibilistic logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Prade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Logic in Artificial Intelligence and Logic Programming</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Hogger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="439" to="513" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Gallier</surname></persName>
		</author>
		<title level="m">Logic for Computer Science</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Hájek</surname></persName>
		</author>
		<title level="m">Metamathematics of Fuzzy Logic. Trends in Logic. Studia Logica Library</title>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Theory of generalized annotated logic programming and its applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="335" to="367" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Predicate logic as a programming language</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IFIP&apos;74</title>
		<meeting>IFIP&apos;74</meeting>
		<imprint>
			<publisher>North Holland Publishing Company</publisher>
			<date type="published" when="1974">1974</date>
			<biblScope unit="page" from="569" to="574" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Foundations of Logic Programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lloyd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>2nd. edition</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Multi-adjoint logic programming with continuous semantics</title>
		<author>
			<persName><forename type="first">J</forename><surname>Medina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ojeda-Aciego</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vojtas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LPNMR&apos;01</title>
		<meeting>LPNMR&apos;01</meeting>
		<imprint>
			<date type="published" when="2001-09">September 2001</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On fuzzy logic I, II, III</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pavelka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zeitschr. f. Math. Logik und Grundl. der Math</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Reply to Ernest Nagel&apos;s criticism of my views on quantum mechanics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Reichenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Philosophy</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="239" to="247" />
			<date type="published" when="1946">1946</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The semantics of predicate logic as a programming language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Van Emden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ACM</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">23</biblScope>
			<biblScope unit="page" from="733" to="742" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Quantitative deduction and its fixpoint theory</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Van Emden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="53" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Annotated and fuzzy logic programs -relationship and comparison of expressive power</title>
		<author>
			<persName><forename type="first">P</forename><surname>Vojtas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>Slovakia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Safárik University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Soundness and completeness of non-classical extended SLD-resolution</title>
		<author>
			<persName><forename type="first">P</forename><surname>Vojtás</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Paulík</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Ws. on Extensions of Logic Programming (ELP&apos;96)</title>
		<meeting>of the Ws. on Extensions of Logic Programming (ELP&apos;96)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1050</biblScope>
			<biblScope unit="page" from="289" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fuzzy sets as a basis for a theory of possibility</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Zadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fuzzy Sets and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="3" to="28" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
