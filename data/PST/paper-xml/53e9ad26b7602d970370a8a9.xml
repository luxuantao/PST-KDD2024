<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Enabling Scientific Workflow Reuse through Structured Composition of Dataflow and Control-Flow</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shawn</forename><surname>Bowers</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Bertram</forename><surname>Ludäscher</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Anne</forename><forename type="middle">H H</forename><surname>Ngu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">UC Davis Genome Center</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Deptartment of Computer Science UC Davis Genome Center</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">San Marcos Terence Critchlow Center for Applied Scientific Computing</orgName>
								<orgName type="institution">Texas State University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Enabling Scientific Workflow Reuse through Structured Composition of Dataflow and Control-Flow</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5AB1016419D100C95F9F924D73E99D85</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Data-centric scientific workflows are often modeled as dataflow process networks. The simplicity of the dataflow framework facilitates workflow design, analysis, and optimization. However, modeling "control-flow intensive" tasks using dataflow constructs often leads to overly complicated workflows that are hard to comprehend, reuse, and maintain. We describe a generic framework, based on scientific workflow templates and frames, for embedding control-flow intensive subtasks within dataflow process networks. This approach can seamlessly handle complex control-flow without sacrificing the benefits of dataflow. We illustrate our approach with a real-world scientific workflow from the astrophysics domain, requiring remote execution and file transfer in a semi-reliable environment. For such workflows, we also describe a 3-layered architecture based on frames and templates where the top-layer consists of an overall dataflow process network, the second layer consists of a tranducer template for modeling the desired control-flow behavior, and the bottom layer consists of frames inside the template that are specialized by embedding the desired component implementation. Our approach can enable scientific workflows that are more robust (faulttolerance strategies can be defined by control-flow driven transducer templates) and at the same time more reusable, since the embedding of frames and templates yields more structured and modular workflow designs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Scientific workflow systems <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b25">26]</ref> are increasingly being used by scientists to construct and execute com-plex scientific analyses. Such analyses are typically datacentric and involve "gluing" together data retrieval, computation, and visualization components into a single executable analysis pipeline. The components may be part of the workflow system, part of another application (invoked through system calls, executing R or MATLAB scripts, etc.), or even external, accessed via web or grid services. In addition to providing scientists with a mechanism to compose and configure otherwise heterogeneous components, scientific workflow systems aim to support end-to-end workflow management, e.g., through tools for accessing external data sources, archival of intermediate results, and monitoring of workflow execution.</p><p>One common approach is to model scientific workflows as directed acyclic graphs (DAGs), where arcs denote scheduling dependencies between computation tasks called jobs <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b6">7]</ref>. For example, scheduling these job-based workflows amounts to queueing and executing jobs based on the partial order induced by the DAG. Alternatively, a number of scientific workflow systems have adopted a more expressive language for modeling scientific workflows based on dataflow process networks <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b14">15]</ref>, a model of computation that comes with "built-in" support for stream-based and concurrent execution. <ref type="foot" target="#foot_0">1</ref>Dataflow is a natural paradigm for data-driven and dataintensive scientific workflows such as, e.g., the terabytesized Fusion Plasma Simulation <ref type="bibr" target="#b2">[3]</ref> and the Terascale Supernova Initiative <ref type="bibr" target="#b30">[31]</ref>. Workflows expressed using dataflow process networks can be efficiently analysed and scheduled <ref type="bibr" target="#b16">[17]</ref>, and are also a simple and intuitive model for workflow designers <ref type="bibr" target="#b3">[4]</ref>. However, while dataflow has become a standard model of scientific workflows, some amount of control-flow modeling is often necessary for engineering fault-tolerant, robust, and adaptive workflows. Here, control-flow refers to the use of constructs such as branching via if-then-else and switch-case statements, and iteration with multiple entry and exit points.</p><p>Another reason for the use of control-flow constructs concerns the handling of complex data structures, often found in scientific applications. In particular, workflows must often "build in" support for accessing, combining, and manipulating portions of these data structures explicitly. Connecting independently created components (e.g., different web-services or applications created by different organizations) offers similar challenges, requiring additional subprocesses to align component input and output data structures (schemas) <ref type="bibr" target="#b3">[4]</ref>. These differences in structure can be complex, e.g., involving different levels of representation granularity and requiring structural transformations.</p><p>In this paper, we address the problem of combining dataflow and control-flow for scientific workflows. It has been noted <ref type="bibr" target="#b19">[20]</ref> that modeling control-flow using only dataflow constructs can quickly lead to overly complex workflows that are hard to understand, reuse, reconfigure, maintain, and schedule <ref type="bibr" target="#b16">[17]</ref>. In particular, modeling control-flow using dataflow involves inserting and linking various lowlevel and specialized control components alongside dataflow components, thus making it difficult to distinguish control-flow from dataflow aspects (since they are "entangled").</p><p>The organization and contributions of the paper are as follows: We describe a framework that "untangles" dataflow and control-flow aspects and instead supports a structured embedding of control-intensive subtasks within dataflow process networks (Section 2). Our approach is to encapsulate generic behavioral specifications (i.e., controlflow) in workflow templates. Templates are distinct and separate components and thus can be easily reused in other workflows. Templates are partial specifications and contain "holes", so-called frames, that act as placeholders for independently defined subcomponents. Composing templates with existing dataflow components results in applying the associated behavior to the component in such a way that the separation between control-flow and dataflow is maintained, thus allowing the underlying dataflow component to be easily changed (typically through a configuration parameter of the template). This approach allows workflow designers to change complex control-flow behavior by simply using different templates. Our approach was inspired by the notion of hierarchical finite state machines <ref type="bibr" target="#b10">[11]</ref> and can also be seen as an extension of actor-oriented modeling <ref type="bibr" target="#b17">[18]</ref> with frames and templates (Figure <ref type="figure" target="#fig_1">2</ref>).</p><p>In Section 3 we first present a specialized 3-layered architecture of our framework. It allows the designer to select and reuse different control-flow intensive behaviors for generic top-level components, by embedding inside of them suitable transducer templates as the middle-layer. The concrete implementation of frames inside of transducer templates is independently selected via the bottom-layer.</p><p>We then describe a Generic Data Transfer (GDT) component, which has been implementated on top of the opensource KEPLER system <ref type="bibr" target="#b20">[21]</ref>, an extension of PTOLEMY II <ref type="bibr" target="#b4">[5]</ref> for scientific workflows. The GDT component was motivated by earlier work on a control-intensive astrophysics workflow <ref type="bibr" target="#b30">[31]</ref>. As shown in Figure <ref type="figure" target="#fig_0">1</ref>, this workflow uses dataflow constructs to implement a fault-tolerance scheme (involving "retry") for transfering files, resulting in a very complex process network. In the new approach, the GDT component encapsulates this and other transfer behaviors as templates in which workflow designers can select from a set of behaviors as well as the desired underlying transfer protocols (e.g., scp, ftp, or using SRB <ref type="bibr" target="#b27">[28]</ref>). Given a particular behavior and protocol, the GDT automatically composes these into the desired executable component. At any time, the behavior and the underlying protocols can be easily changed by simply reconfiguring GDT. In the original workflow this would be a complex and error-prone programming task, involving the insertion, deletion, and rewiring of various control-flow and dataflow components.</p><p>In Section 3 we also describe a Generic remote eXecution (GX) component, whose middle-layer employs exactly the same control-intensive behaviors (via transducer templates) as GDT to support fault-tolerance, demonstrating the versatility of our approach and the improved component reusability it creates.</p><p>Finally, we describe related work in Section 4 and conclude in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Actor-Oriented Design Extensions</head><p>In KEPLER, users develop workflows by selecting appropriate components called actors and placing them on a design canvas, after which they can be "wired" together to form the desired workflow graph (cf. Figure <ref type="figure" target="#fig_0">1</ref>). Actors have input and output ports which provide the communication interface to other actors. Workflows can be hierarchically structured, yielding composite actors that encapsulate subworkflows (e.g., see the bottom-right in Figure <ref type="figure" target="#fig_0">1</ref>). A novel feature of KEPLER, inherited from PTOLEMY II, is that the overall execution and component interaction semantics of a workflow is not defined by the components, but is factored out into a separate component called a director. Taken together, workflows, actors, ports, connections, and directors represent the basic building blocks of actor-oriented modeling and design <ref type="bibr" target="#b17">[18]</ref>.</p><p>In this section we define scientific workflows as dataflow process networks and describe two extensions to actororiented modeling, i.e., frames and templates. Frames form the basis of our approach for embedding control-flow intensive behaviors (via workflow templates) inside of dataflow process networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Scientific Workflows as Process Networks</head><p>An actor-oriented workflow graph W = A, D consists of a set A of actors representing components or tasks and a set of directed dataflow connections D (see below), representing communication channels that connect actors via ports, and along which actors communicate by passing tokens.</p><p>Let ports(A) denote the set of ports of actor A. Each port p ∈ ports(A) is designated as either input or output. Some input ports may be distinguished as parameters pars(A) ⊆ in(A) which can be used for configuring A's behavior. For convenience, we write A.p to emphasize that port p belongs to actor A. The signature Σ A of an actor is given by its ports; we write Σ A = in(A) → out(A).</p><p>Actors are wired together through their ports via data-</p><formula xml:id="formula_0">flow connections. A dataflow connection d ∈ D is a di- rected hyperedge d = o, i , connecting n output ports o = {o 1 , . . . , o n } with m input ports i = {i 1 , . . . , i m }. A dataflow connection d = o,</formula><p>i corresponds to a merge step of output tokens from o, followed by a copy step, delivering all tokens to the input ports i.</p><p>A composite actor A W encapsulates a sub-workflow W . The (external) ports of A W consist of a distinguished set of ports from W , i.e., A W might not expose all of its subworkflow's ports. A hierarchical workflow is a workflow graph that contains at least one composite actor. Since subworkflows can themselves be hierarchical, any level of nesting can be modeled.</p><p>A port p may have a structural data type constraining the allowed set of values accepted by p (if p is an input port) or produced by p (if p is an output port). The PTOLEMY II type system includes simple types (e.g., string and int) and complex types (such as nested record and list structures). A port p may also have a semantic type, denoting a concept from a description logic ontology <ref type="bibr" target="#b3">[4]</ref>. For example, a semantic type is: MEASUREMENT ∀ITEM.SPECIESOCCURRENCE indicating that the corresponding port accepts (or produces) data tokens that denote measurements where the measured item is a species occurrence (as opposed to, e.g., a temperature). In addition to port semantic types, an actor A itself may also be associated with a semantic type, describing the overall function or purpose of A.While structural (i.e., data) type safety ensures that actors can "work with" incoming data tokens at runtime, semantic type safety avoids actor connections at design time that are not meaningful in terms of their concept annotations (e.g., occurrence data cannot be used where temperature data is expected).</p><p>So far, the execution semantics of a workflow graph W has not been specified. Indeed, in PTOLEMY II and thus in KEPLER, the workflow designer can choose among different models of computation, each one being represented by a so-called director. A director specifies and mediates all inter-actor communication, separating workflow orchestration and scheduling (the director's concern) from individual actor execution (the actor's concern). This separation achieves a form of behavioral polymorphism <ref type="bibr" target="#b17">[18]</ref>, resulting in more reusable actor components and subworkflows. KEPLER (through PTOLEMY II) provides a variety of directors that implement process network (PN and SDF), discrete event (DE), continuous time (CT), and finite state transducer (FST) semantics.</p><p>In PN, e.g., the director executes each actor in a workflow as a separate process (or thread). Connections (or channels) are used to send (i.e., stream) sequences of data tokens between actors, and actors map input sequences to output sequences. Actors communicate asynchronously in process networks through buffered channels implemented as queues of effectively unbounded size. Thus, the PN director can be used to pipeline data tokens through scientific workflows, enabling highly concurrent execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Frames</head><p>Actors in actor-oriented modeling and design are always concrete: they correspond to particular implementations and can be directly executed in a workflow. We extend actor-oriented modeling with a new entity called frame, which is an abstraction that denotes a set of alternative actor implementations (or templates) with similar, but not necessarily identical functionality. 2 For workflow designers, frames are placeholders for components that will be instantiated and specialized later. Thus, a designer can place a frame F on the design canvas, and connect it with other workflow components, without prematurely specifying which component C is to be used. For component developers, frames can be used as abstractions for a family of components (actors or templates) with similar function.</p><p>Formally, a frame is a named entity F that acts as a 2 Here the term frame symbolizes a notion akin to a picture frameallowing different "pictures" (i.e., components) so long as they conform to the constraints imposed by the "frame." placeholder for a component C to be "plugged into" F (see Figure <ref type="figure" target="#fig_1">2 a</ref>). When devising a frame F , a family of components C F is envisioned, with each C ∈ C F being a possible alternative for embedding into F . Like an actor, a frame has input, output, and parameter ports, structural types, and semantic types; taken together they form the frame signature Σ F . This signature represents the common API of the family C F of components that F abstracts.</p><p>An embedding F [C] of a component C into a frame F is a set of pairs associating (or "wiring") ports of C with ports of F , i.e., F [C] ⊆ ports(F ) × ports(C). We indicate the wiring type of a pair (x, y) ∈ F [C] as follows:</p><formula xml:id="formula_1">• F.x C.y; if x ∈ in(F ), y ∈ in(C) (input) • F.x C.y; if x ∈ out(F ), y ∈ out(C) (output) • F.x C.y; if x ∈ pars(F ), y ∈ pars(C) (parameter)</formula><p>The embedded component C may also introduce new ports not in ports(F ). We denote these ports as C.y, C.y, and C.y for input, output, and parameter ports y, respectively. Similarly, an embedding F [C] may not use all the ports of C. We denote these unused ports as F.x , F.x , and F.x for input, output, and parameter ports x, respectively. We note that parameter ports F.x can also be connected to input ports C.y and vice versa. However, other connection types (x, y) ∈ F [C] are not allowed. Here we assume that all the ports of F are used in the embedding.</p><p>An embedding F [C] is well-formed if the input and output port directions are observed, i.e., F 's inputs (outputs) are wired only to inputs (outputs) of C (Figure <ref type="figure" target="#fig_1">2 a</ref>). A well-formed embedding F [C] is structurally well-typed if the structural types align, and semantically well-typed if the semantic types align. We require for each connection between a port of F and a port of C having (structural or semantic) types τ F and τ C that: <ref type="bibr" target="#b0">(1)</ref>  In some cases, the above typing rules can be "loosened" when the frame occurs within a workflow. In particular, if an input port of F is connected to the output port of an actor having a type τ A τ F (similarly, τ A τ F ), then we only require for a corresponding input port of C that τ A τ C (similarly, τ A τ C ). Thus, it may be possibly that</p><formula xml:id="formula_2">τ C ≺ τ F if τ A ≺ τ F (and similarly, τ C τ F if τ A τ F</formula><p>). This situation is only possible when F has such a "context," i.e., is part of a larger workflow.</p><p>When a workflow designer chooses a component C to embed within a frame F , we can use the port types of C and F to semi-automatically compute the appropriate connections for F [C]. A similar approach has been implemented within KEPLER for validating that a workflow's actor connections are both structurally well-typed and semantically meaningful <ref type="bibr" target="#b1">[2]</ref>. In addition, component types can be used to help workflow designers search repositories for plausible components to be embedded within a given frame. <ref type="foot" target="#foot_2">4</ref>Finally, we note that frames also provide a natural mechanism to execute a number of different actors associated with the frame in parallel. For example, for a frame defining a certain type of clustering approach, a scientist may desire to execute multiple specific algorithms associated with the frame simultaneously over the same input data within a workflow. Frames may similarly be embedded with additional, generic capabilities in addition to their component embeddings. For example, they may transparently apply higher-order functions such as foldl (foldr), scanl (scanr), zipWith, until, iterate, and so on to embedded components, serving to reduce certain types of iteration control-flow complexities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Workflow Templates</head><p>A frame F imposes some constraints on the set C F of components for which it stands. In particular, embeddings F [C] should be well-formed and well-typed for any C ∈ C F as explained above. However, no assumptions can be made about the "inner workings" of C. A workflow template T provides a similar level of abstraction for a set of workflows W T . Unlike a frame, however, a template T (partially) specifies the behavior of the workflows it represents.</p><p>Like actors and frames, a template T has the usual port signature Σ T : in(T ) → out(T ). In addition, a template includes an "inner" workflow graph W T , where some of the components of W T are not concrete actors, but frames (Figure <ref type="figure" target="#fig_1">2 b</ref>). Let F 1 , . . . , F n be the frames that occur in W T , either directly, or indirectly through nested templates.</p><p>Then we can view T as a partial workflow specification T (F 1 , . . . , F n ), whose frames F i can be independently specialized by embedded components (actors or templates) C i . The resulting embedding</p><formula xml:id="formula_3">T (F 1 [C 1 ], . . . , F n [C n ]</formula><p>) is a concrete, executable workflow if no C i has itself a frame; otherwise the embedding is a (more refined) template.</p><p>In addition to providing input/output constraints through the port signature Σ T and behavioral constraints through the workflow graph structure W T (with frames acting as placeholders), a template T can also constrain the intended model(s) of computation by providing one or more directors: In Figure <ref type="figure" target="#fig_1">2 c</ref>, a transducer template T (F ) is shown. This template includes a workflow graph W T with a frame F . Moreover, an FST director is inscribed in T , meaning that the workflow graph is to be executed as a finite state transducer <ref type="foot" target="#foot_3">5</ref> . A director dictates the execution model of a workflow graph W T (e.g., SDF or PN for synchronous dataflow and process network execution, respectively; or here: FST), and may also impose constraints on the graph structure. In the case of FST, nodes (components) are not called actors but states (depicted as circles in Figure <ref type="figure" target="#fig_1">2 c</ref>); connections are called state transitions (depicted as curved arcs). In response to a state transition, the FST director calls a state implementation if one has been associated with the state <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref>. In our case, we can create a more generic behavior for the finite state transducer by delaying the specification of a concrete actor to implement a state, and instead introducing a frame. In this way the same controlflow driven behavior can be reused with different underlying state implementations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Applying Templates and Frames for Data Transfer and Remote Exection</head><p>Here we consider a particular design pattern 6 for structuring frames and templates into generic workflow components that can be executed using alternative control behaviors and alternative task implementations. We define the Generic Data Transfer (GDT) and Generic eXecution (GX) components using this pattern. We also describe our implementation of the GDT and GX components within KEPLER.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">A Generic Control-Flow Component Pattern</head><p>The generic control-flow component pattern consists of three levels, as shown in Figure <ref type="figure" target="#fig_2">3</ref>. The top level is represented as a frame within a dataflow graph and denotes a particular task (e.g., data transfer or remote execution). This top-level frame can be embedded with one of many finite state transducer templates (the middle level), each of which defines a control-flow behavior for the task. A transducer template has one or more state frames that can be embedded with a particular task implementation (e.g., scp or ssh). The various frame implementations form the bottom-level of the pattern.</p><p>We use finite state transducers for modeling embedded control-flow because they offer a more natural, intuitive, and typically more succinct language for specifying control behavior, compared to dataflow process networks. Fi- 6 similar in spirit to software design patterns <ref type="bibr" target="#b8">[9]</ref> nite state machines (or transducers) are often used to model business workflows <ref type="bibr" target="#b0">[1]</ref>, which are primarily control-flow oriented (as opposed to dataflow oriented), and underpin many of the web-service orchestration languages <ref type="bibr" target="#b5">[6]</ref>.</p><p>We define a finite state transducer (FST) in the normal way: An FST is a tuple M = I, O, Q, q 0 , T , where I and O are sets of input and output events, respectively, Q is a finite set of states, q 0 is the initial state, and T is a finite set of transitions, each of which has the form t : q c/a -→ q . Here, c is an optional condition that guards the transition t (i.e., t can only be executed if c is true), and a is an optional action. The FST M starts in the initial state. When M is "called" from the outside, it transitions from the current state q to the next state q , based on the current input events I and the conditions of transitions emminating from q. In addition, we consider FST states that can be associated with a subworkflow (called state refinements in PTOLEMY II <ref type="bibr" target="#b10">[11]</ref>), where the subworkflow is executed upon entry into the state.</p><p>Components that implement this generic control-flow pattern enable workflow designers to easily configure both the behavior and underlying implementation of the component. A workflow designer can (i) insert into a workflow the generic component (as shown at the top of Figure <ref type="figure" target="#fig_2">3</ref>), (ii) select a behavior from the available transducer templates associated with the component, and (iii) select task implementations from those avilable for the state frames of the template. The behaviors and implementations that a workflow designer selects from may originally be specified by the component developer or can potentially be reused and repurposed from other generic components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generic Components for Data Transfer and Remote Execution</head><p>A common task in scientific workflows is data transfer between hosts. Current solutions "hardwire" into the overall workflow both the underlying transport protocol (e.g., scp) and the dynamic behavior used to operate the protocol (e.g., reactions to exceptions and number of retries). For example, the astrophyhsics workflow previously discussed (see Figure <ref type="figure" target="#fig_0">1</ref>) hardcodes the transfer of local simulation data from one host to the host in which a particular analysis is performed. Data transfer is also commonly performed in scientific workflows to store and archive the results of analytical processes, certain provenance information, and intermediate data products.</p><p>Data transfer using our framework can instead be specified as follows. The designer first selects the GDT component whose signature specifies the common inputs and outputs such as source and target hosts, file names and locations, and user information. Using the GDT, the designer can then select a transducer template with the desired data-transfer behavior (e.g., from a library of prede-  fined transducer templates). The designer may choose, e.g., a retry-failover template that: (1) attempts a transfer protocol p 1 up to n times, (2) if p 1 is not successful, attempts an alternative transfer protocol p 2 up to m times, and (3) if p 2 also fails, reports a failure condition. Note that n, m, p 1 , and p 2 are configuration parameters of the template where p 1 and p 2 denote state-frame implementations. The designer can then select appropriate state-frame implementations through the GDT. The designer might select, e.g., an scp state implementation for p 1 and an ftp state implementation for p 2 . Finally, based on the signatures and configured parameters of the GDT component, retry-failover template, and the state implementations (scp and ftp), the proper embeddings are performed resulting in a fully instantiated (i.e., "ground") GDT component that can then be executed from within the overall workflow.</p><p>Using KEPLER we have implemented an initial version of the GDT component, as shown in Figure <ref type="figure" target="#fig_3">4</ref>. In this implementation, the GDT component (top, left) is a special actor (more precisely, an extension of a composite actor) that provides necessary frame functions for supporting the generic control-flow pattern. The GDT component contains an intermediate subworkflow (upper-right). This subworkflow contains a "modal model" actor, which is required in PTOLEMY II for nesting FSTs within dataflow process networks. This subworkflow also permits multiple executions of the transducer template on each firing of the GDT component.</p><p>Two transducer templates are shown in Figure <ref type="figure" target="#fig_3">4</ref> for the GDT component. The selected template (middle, left) is a simple retry loop, which executes the desired protocol maxRetry times before entering a fail state. Note that this template performs an equivalent function as the control components of Figure <ref type="figure" target="#fig_0">1</ref>. The other template (middle, right) of Figure <ref type="figure" target="#fig_3">4</ref> provides a simple fail-over behavior in which an initial protocol is attempted, and if it fails, a failover protocol is used. Finally, scp and SRB sput 7 state implementations are shown at the bottom of Figure <ref type="figure" target="#fig_3">4</ref>. In the figure, the scp implementation has been selected, and its signature propagated to the GDT component.</p><p>In our current implementation, all configuration including the selection of templates and state implementations is performed by assigning specific attributes of the GDT com-   <ref type="foot" target="#foot_4">8</ref> For example, when a workflow designer configures the GDT component, a dialog box is presented that contains a drop-down list of available templates. Once a template is selected, the user can also select an associated state implementation (note that at anytime after selecting a template it can be navigated to within the KEPLER GUI).</p><p>The GDT actor reacts to these attribute changes dynamically, assigning the transducer to the modal model, refining the appropriate transducer states, and making the appropriate port connections. A workflow designer can also easily reconfigure the GDT component by assigning different templates or state implementations (in contrast, e.g., to the workflow of Figure <ref type="figure" target="#fig_0">1</ref>). Finally, in addition to the GDT component, we have also implemented the Generic eXecution (GX) component, shown in Figure <ref type="figure" target="#fig_4">5</ref>. The GX component is similar to the GDT component, but is tailored for remote execution (e.g., ssh) as opposed to file transfer. The GX component, however, can directly reuse the control-flow templates defined for the GDT component (middle of Figure <ref type="figure" target="#fig_4">5</ref>). The ability to reuse control-flow in this way is a significant advantage of this approach. Indeed, the ability to reuse both control-flow and dataflow components via templates and frames can lead to more robust, intuitive, and ultimately reusable scientific workflows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Related Work</head><p>Scientific workflow systems <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref> are often based on a dataflow model, due to the data-centric and data-driven nature of many scientific analyses. In contrast, business workflow systems <ref type="bibr" target="#b0">[1]</ref>, workflow-patterns approaches <ref type="bibr" target="#b29">[30]</ref>, and systems for web-service composition (e.g., BPEL4WS <ref type="bibr" target="#b5">[6]</ref> and OWL-S <ref type="bibr" target="#b23">[24]</ref>) often use controlbased models such as finite state machines or Petri nets as their primary model of computation. Few systems seamlessly integrate both control-flow and dataflow within a single model. Our approach for embedding control-flow into dataflow was inspired by hierarchical finite state machines <ref type="bibr" target="#b10">[11]</ref> in PTOLEMY II and more generally, PTOLEMY's ability to nest heterogeneous compution models <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b4">5]</ref>. The notion of templates and frames offer novel extensions to existing semantic web-service frameworks <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b25">26]</ref> and composition approaches <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14]</ref>, and are inspired by existing approaches in conceptual business workflow modeling <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b24">25]</ref> and software engineering <ref type="bibr" target="#b8">[9]</ref>.</p><p>The need for adaptive and reusable workflows has been an active research issue in business workflow systems since the late 90's <ref type="bibr" target="#b12">[13]</ref>. To achieve adaptability, <ref type="bibr" target="#b15">[16]</ref> proposed decoupling of conceptual workflow specifications (WSFL) from the individual tasks (TSL) that make up a workflow. In this work, control flow within a task (task execution be-havior) is modeled by a generic state transition diagram. More recently, web-service composition <ref type="bibr" target="#b13">[14]</ref> approaches have applied similar techniques, supporting separate interface declarations from underlying control-flow models. In CMI <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b24">25]</ref>, task execution behavior is further enhanced by introducing state hierarchy, application specific states, and operations. This approach resulted in two advanced activity modeling concepts in CMI called "service" and "placeholder" activities. Service activities provide an abstraction for complex coordination with external entities and placeholder activities provide a mechanism for dynamic binding to an activity implementation. The main contribution of CMI's service activity is its ability to separate the service interface declaration from its concrete implementation. Each service interface declaration has an associated state machine that is used as a guide for matching to a compatible concrete implementation. CMI's placeholder activity further restricts binding of services based on userdefined policies and criteria. This feature is critical in implementing complex control flow without having to exhaustively list all the potential activities within a process. The use of service and placeholder activities has enabled the construction of a complex and adaptive workflow at a much faster pace as demonstrated in <ref type="bibr" target="#b24">[25]</ref>. Frames and templates are related to placeholders and services, respectively, however, our model is more powerful in that it allows arbitrary nesting of frames and templates as well as hierarchal composition of different execution behavior (i.e., both control and dataflow).</p><p>In general, our approach extends KEPLER and PTOLEMY by providing higher-level configuration mechanisms through frames and templates. While PTOLEMY provides a number of base capabilities that make workflow specification easier-including the notion of actor-oriented modeling, domain polymorphism <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b4">5]</ref>, and composite actors-the task of replacing a component with a similar component can be a daunting task, especially for scientific workflows with control-flow aspects, making this type of reusability even more challenging (see Figure <ref type="figure" target="#fig_0">1</ref>). Our approach can significantly reduce this effort, and provides a more conceptual set of primitives for modeling workflows, e.g., by allowing certain decisions on particular implementations to be defered including the control-flow and dataflow behavior.</p><p>The development of "rigid" workflow modeling and design frameworks have recently been identified as a major bottleneck for scientific workflow reuse and repurposing (i.e., reconfiguring existing workflows for new purposes) <ref type="bibr" target="#b11">[12]</ref>. New design primitives such as templates and frames can significantly enhance reusability in scientific workflows. Moreover, the use of frames and templates together with semantic types also yields improved discovery mechanisms for scientific workflow repositories and can en-able more automated approaches for supporting workflow reusability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Concluding Remarks</head><p>While scientific workflows are primarily datafloworiented, certain workflow tasks can be control-intensive, e.g., procedures for providing fault-tolerant and adaptive distributed data transfer. Modeling these tasks directly using dataflow constructs can lead to workflows that are overly complex and difficult to maintain and reuse. In this paper, we have described a framework to support the structured embedding of generic control-flow components within dataflow process networks. In particular, we have introduced (actor) frames and (workflow) templates and shown how they can be used to develop robust workflows via reusable control-intensive subtasks. We have also described a simple three-layer architecture pattern that we have found useful in practice for modeling certain controlflow behavior, where (1) a high-level frame defines a certain generic type of procedure (such as data transfer); ( <ref type="formula">2</ref>) the high-level frame can be embedded with one of many transducer templates, encapsulating a particular "strategy" of control-flow (e.g., "retry"); and (3) each transducer template consists of one or more frames that can be embedded with the particular task implementations for carrying out the high-level procedure (e.g., secure-copy).</p><p>As future work, we intend to extend our prototype of the generic data transfer and remote execution components in a number of ways. First, we want to fully integrate frames and templates as first-class modeling constructs within KE-PLER. We also intend to develop additional transducer templates and lower-level implementation components for data transfer and remote execution, based on the needs of the workflow of Figure <ref type="figure" target="#fig_0">1</ref>. Another goal is to populate KEPLER with new generic components, including both frames and templates, to support a wide range of scientific workflows. Finally, we want to explore mechansisms for easily combining transducer templates (in addition to dataflow templates). For example, we want to allow a workflow engineer to select two or more existing templates and easily combine them to dynamically create a new, more complex template further enabling reuse of scientific workflows.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Control-flow intensive astrophysics workflow in KEPLER [31]. "Retry", a composite actor for fault-tolerant data transfer (top), contains a subworkflow (bottom), which itself contains a "Con-ditionalLoop" subworkflow (inside not shown). Complex feedback loops and the use of boolean switches illustrate the complexity of modeling control-flow directly in a dataflow process network.</figDesc><graphic coords="3,265.07,234.47,265.69,111.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2</head><label>2</label><figDesc>Figure 2. a) Embedding of component C in frame F; b) workflow template T(F 1 ,F 2 ); c) finite state transducer template T(F).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FFigure 3 .</head><label>3</label><figDesc>Figure 3. A pattern for modeling generic control-flow components that consists of an outer frame (top), a nested transducer template (middle), and state-frame embeddings (bottom)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. The Generic Data Transfer component (top left), its underlying modal model implementation in KEPLER (top right), two compatible transducer templates (middle), and two possible embeddings (bottom)</figDesc><graphic coords="7,161.59,248.98,141.38,94.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. The Generic eXecution component (top left), its underlying modal model implementation in KEPLER (top right), two compatible transducer templates (middle), and two possible embeddings (bottom); note the templates are reused from the Generic Data Transfer component</figDesc><graphic coords="8,147.50,252.46,162.34,58.01" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>τ F τ C for input structural types; (2) τ C τ F for output structural types; (3) τ F τ C for input semantic types; and (4) τ C τ F for output semantic types. 3 Thus, we use contra-variant subtyping for both structural and semantic types: when embedding a component C in a frame F , C should be able to handle F s inputs. Conversely, F should be able to handle outputs of C (or, equivalently, C should not produce output that is more general than what F anticipates). The signature Σ F [C] after embedding C in F includes (unless specified otherwise by the designer) the ports of F plus the new ports introduced by C.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Generic Component Transducer Modal Model Selected Template Alternative Template Selected State Implementation Alternative State Implementation</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Generic Component Transducer Modal Model Selected Template Alternative Template Selected State Implementation Alternative State Implementation</head><label></label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Workflows modeled in this way are also not limited to DAGs, i.e., they can contain loops.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>" " denotes the standard subtyping relation between data types, while " " denotes concept subsumption in description logics.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Such a search is a particular form of semantic web-service "matchmaking"<ref type="bibr" target="#b23">[24]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>a kind of finite state machine that not only consumes input tokens but that also produces output tokens</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>In PTOLEMY II, and attribute is a static property.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. This work supported in part by NSF/ITR 0225673 (GEON), NSF/ITR 0225676 (SEEK), NIH/NCRR 1R24 RR019701-01 (BIRN-CC), and DOE DE-FC02-01ER25486 (SDM); and performed under the auspices of the U.S. Department of Energy by University of California Lawrence Livermore National Laboratory under contract No. W-7405-Eng-48, number UCRL-CONF-215235.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Workflow management systems: The next generation of distributed processing tools</title>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mohan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Transaction Models and Architectures</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Incorporating semantics in scientific workflow authoring</title>
		<author>
			<persName><forename type="first">C</forename><surname>Berkley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bowers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ludäscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schildhauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Conf. on Scientific and Statistical Database Management (SSDBM)</title>
		<meeting>of the Intl. Conf. on Scientific and Statistical Database Management (SSDBM)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">High performance threaded data streaming for large scale simulations</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bhat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Klasky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Atchley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parashar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE/ACM Intl</title>
		<meeting>of the IEEE/ACM Intl</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>Workshop on Grid Computing (GRID&apos;04</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Actor-oriented design of scientific workflows</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bowers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ludäscher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Conf. on Conceptual Modeling (ER)</title>
		<meeting>of the Intl. Conf. on Conceptual Modeling (ER)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Heterogeneous concurrent modeling and design in Java</title>
		<author>
			<persName><forename type="first">C</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Neuendorffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zheng</surname></persName>
		</author>
		<idno>UCB/ERL M05/21</idno>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report Technical Memorandum</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Curbera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Goland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Leyman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Roller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weer-Awarana</surname></persName>
		</author>
		<idno>Version 1.0. 2002</idno>
		<title level="m">Business Process Execution Language for Web Services (BPEL4WS</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Pegasus: Mapping scientific workflows onto the grid</title>
		<author>
			<persName><forename type="first">E</forename><surname>Deelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Blythe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kesselman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the European Across Grids Conference</title>
		<meeting>of the European Across Grids Conference</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Taming heterogeneity-The Ptolemy approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Janneck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ludvig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Neuendorffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE</title>
		<meeting>of the IEEE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">91</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Design Patterns</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley Professional</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Managing Process and Service Fusion in Virtual Enterprises</title>
		<author>
			<persName><forename type="first">D</forename><surname>Georgakopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cichocki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information System, Special Issue on Information System Support for Electronic Commerce</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hierarchical finite state machines with multiple concurrency models</title>
		<author>
			<persName><forename type="first">A</forename><surname>Girault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on CAD</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Seven bottlenecks to workflow reuse and repurposing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Goderis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Goble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lord</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Semantic Web Conference (ISWC2005)</title>
		<meeting>of the Intl. Semantic Web Conference (ISWC2005)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A taxonomy of adaptive workflow management</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bussler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Workshop Towards Adaptive Workflow Systems</title>
		<meeting>of the Workshop Towards Adaptive Workflow Systems</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Tools for composite web services: A short overview</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Coroutines and networks of parallel processes</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Macqueen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IFIP Congress</title>
		<meeting>of the IFIP Congress</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Managing heterogeneous multi-system tasks to support enterprise-wide operations</title>
		<author>
			<persName><forename type="first">N</forename><surname>Krishnakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Distributed and Parallel Databases</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Static scheduling of synchronous data flow programs for digital signal processing</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Messerschmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>C-36</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Actor-oriented models for codesign: Balancing re-use and performance</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Neuendorffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Models for System Design</title>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Dataflow process networks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Parks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE</title>
		<meeting>of the IEEE</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">83</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">On simplifying collection handling and control-flow issues in SPA/Ptolemy-II</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ludäscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Altintas</surname></persName>
		</author>
		<idno>SciDAC-SPA-TN-2003-01</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>San Diego Supercomputer Center</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Scientific workflow management and the Kepler system</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ludäscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Altintas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Berkley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Higgins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation: Practice &amp; Experience</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">SCIRun/BioPSE: Integrated problem solving environment for bioelectric field problems and visualization</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Macleod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Weinstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Davison De St</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Germain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE Intl. Symposium on Biomedical Imaging (ISBI): From Nano to Macro</title>
		<meeting>of the IEEE Intl. Symposium on Biomedical Imaging (ISBI): From Nano to Macro</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Triana: A graphical web service composition and execution toolkit</title>
		<author>
			<persName><forename type="first">S</forename><surname>Majithia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Shields</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE Intl. Conf. on Web Services (ICWS)</title>
		<meeting>of the IEEE Intl. Conf. on Web Services (ICWS)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Bringing semantics to web services: The OWL-S approach</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paolucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mcilraith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Burstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Mcdermott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Payne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sabou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Solanki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Sycara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Workshop on Semantic Web Services and Web Process Composition (SWSWPC)</title>
		<meeting>of the Intl. Workshop on Semantic Web Services and Web ess Composition (SWSWPC)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Advanced process-based component integration in Telcordia&apos;s cable OSS</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H H</forename><surname>Ngu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Georgakopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cichocki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Desmarais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bates</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Conf. on Data Engineering (ICDE)</title>
		<meeting>of the Intl. Conf. on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A tool for the composition and enactment of bioinformatics workflows</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Oinn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Addis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ferris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marvin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Senger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Greenwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Carver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Glover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Pocock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wipat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">17</biblScope>
			<date type="published" when="2004">2004</date>
			<pubPlace>Taverna</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">From coordination of workflow and group activities to composition and management of virtual enterprises</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Georgakopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Symposium on Database Applications in Non-Traditional Environments</title>
		<meeting>of the Intl. Symposium on Database Applications in Non-Traditional Environments</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<ptr target="http://www.sdsc.edu/srb/" />
		<title level="m">SDSC Storage Resource Broker SRB</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Distributed computing in practice: The Condor experience</title>
		<author>
			<persName><forename type="first">D</forename><surname>Thain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tannenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency -Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2-4</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Workflow patterns. Distributed and Parallel Databases</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H M</forename><surname>Ter Hofstede</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kiepuszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Barros</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Case study: Terascale supernova initiative workflow (TSI-Swesty)</title>
		<author>
			<persName><forename type="first">X</forename><surname>Xin</surname></persName>
		</author>
		<ptr target="http://www-casc.llnl.gov/sdm/documentation/casestudy-tsi-s.doc" />
	</analytic>
	<monogr>
		<title level="s">LLNL Technical Note</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
