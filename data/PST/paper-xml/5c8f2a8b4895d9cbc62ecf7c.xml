<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PRIOR CONVICTIONS: BLACK-BOX ADVERSARIAL ATTACKS WITH BANDITS AND PRIORS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><surname>Ilyas</surname></persName>
							<email>ailyas@mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Logan</forename><surname>Engstrom</surname></persName>
							<email>engstrom@mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Aleksander</forename><forename type="middle">M</forename><surname>Ądry</surname></persName>
						</author>
						<title level="a" type="main">PRIOR CONVICTIONS: BLACK-BOX ADVERSARIAL ATTACKS WITH BANDITS AND PRIORS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study the problem of generating adversarial examples in a black-box setting in which only loss-oracle access to a model is available. We introduce a framework that conceptually unifies much of the existing work on black-box attacks, and we demonstrate that the current state-of-the-art methods are optimal in a natural sense. Despite this optimality, we show how to improve black-box attacks by bringing a new element into the problem: gradient priors. We give a bandit optimization-based algorithm that allows us to seamlessly integrate any such priors, and we explicitly identify and incorporate two examples. The resulting methods use two to four times fewer queries and fail two to five times less than the current state-of-the-art. 1  Published as a conference paper at ICLR 2019 evaluate our approach on the task of generating black-box adversarial examples, where the methods obtained from integrating two example priors significantly outperform state-of-the-art approaches.</p><p>Concretely, in this work:</p><p>1. We formalize the gradient estimation problem as the central problem in the context of query-efficient black-box attacks. We then show how the resulting framework unifies the previous attack methodology. We prove that the least squares method, a classic primitive in signal processing, not only constitutes an optimal solution to the general gradient estimation problem but also is essentially equivalent to the current-best black-box attack methods. 2. We demonstrate that, despite this seeming optimality of these methods, we can still improve upon them by exploiting an aspect of the problem that has been not considered previously: the priors we have on the distribution of the gradient. We identify two example classes of such priors, and show that they indeed lead to better predictors of the gradient. 3. Finally, we develop a bandit optimization framework for generating black-box adversarial examples which allows for the seamless integration of priors. To demonstrate its effectiveness, we show that leveraging the two aforementioned priors yields black-box attacks that are 2-5 times more query efficient and less failure-prone than the state of the art.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Recent research has shown that neural networks exhibit significant vulnerability to adversarial examples, or slightly perturbed inputs designed to fool the network prediction. This vulnerability is present in a wide range of settings, from situations in which inputs are fed directly to classifiers <ref type="bibr" target="#b23">(Szegedy et al., 2013;</ref><ref type="bibr" target="#b3">Carlini et al., 2016)</ref> to highly variable real-world environments <ref type="bibr" target="#b12">(Kurakin et al., 2016;</ref><ref type="bibr" target="#b0">Athalye et al., 2017)</ref>. Researchers have developed a host of methods to construct such attacks <ref type="bibr" target="#b7">(Goodfellow et al., 2014;</ref><ref type="bibr">Moosavi-Dezfooli et al., 2015;</ref><ref type="bibr" target="#b2">Carlini &amp; Wagner, 2017;</ref><ref type="bibr" target="#b15">Madry et al., 2017)</ref>, most of which correspond to first order (i.e., gradient based) methods. These attacks turn out to be highly effective: in many cases, only a few gradient steps suffice to construct an adversarial perturbation.</p><p>A significant shortcoming of many of these attacks, however, is that they fundamentally rely on the white-box threat model. That is, they crucially require direct access to the gradient of the classification loss of the attacked network. In many real-world situations, expecting this kind of complete access is not realistic. In such settings, an attacker can only issue classification queries to the targeted network, which corresponds to a more restrictive black box threat model.</p><p>Recent work <ref type="bibr" target="#b4">(Chen et al., 2017;</ref><ref type="bibr" target="#b1">Bhagoji et al., 2017;</ref><ref type="bibr" target="#b10">Ilyas et al., 2017)</ref> provides a number of attacks for this threat model. <ref type="bibr" target="#b4">Chen et al. (2017)</ref> show how to use a basic primitive of zeroth order optimization, the finite difference method, to estimate the gradient from classification queries and then use it (in addition to a number of optimizations) to mount a gradient based attack. The method indeed successfully constructs adversarial perturbations. It comes, however, at the cost of introducing a significant overhead in terms of the number of queries needed. For instance, attacking an ImageNet <ref type="bibr" target="#b21">(Russakovsky et al., 2015)</ref> classifier requires hundreds of thousands of queries. Subsequent work <ref type="bibr" target="#b10">(Ilyas et al., 2017)</ref> improves this dependence significantly, but still falls short of fully mitigating this issue (see Section 4.1 for a more detailed analysis).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">OUR CONTRIBUTIONS</head><p>We revisit zeroth-order optimization in the context of adversarial example generation, both from an empirical and theoretical perspective. We propose a new approach for generating black-box adversarial examples, using bandit optimization in order to exploit prior information about the gradient, which we show is necessary to break through the optimality of current methods. We Table 1: Summary of effectiveness of 2 and ∞ ImageNet attacks on Inception v3 using NES, bandits with time prior (Bandits T ), and bandits with time and data-dependent priors (Bandits T D ). Note that in the first column, the average number of queries is calculated only over successful attacks, and we enforce a query limit of 10,000 queries. For purposes of direct comparison, the last column calculates the average number of queries used for only the images that NES (previous SOTA) was successful on. Our most powerful attack uses 2-4 times fewer queries, and fails 2-5 times less often.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attack</head><p>Avg </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BLACK-BOX ATTACKS AND THE GRADIENT ESTIMATION PROBLEM</head><p>Adversarial examples are natural inputs to a machine learning system that have been carefully perturbed in order to induce misbehaviour of the system, under a constraint on the magnitude of the pertubation (under some metric). For image classifiers, this misbehaviour can be either classification as a specific class other than the original one (the targeted attack) or misclassification (the untargeted attack). For simplicity and to make the presentation of the overarching framework focused, in this paper we restrict our attention to the untargeted case. Both our algorithms and the whole framework can be, however, easily adapted to the targeted setting. Also, we consider the most standard threat model in which adversarial perturbations must have p -norm, for some fixed p, less than some p .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">FIRST-ORDER ADVERSARIAL ATTACKS</head><p>Suppose that we have some classifier C(x) with a corresponding classification loss function L(x, y), where x is some input and y its corresponding label. In order to generate a misclassified input from some input-label pair (x, y), we want to find an adversarial example x which maximizes L(x , y) but still remains p -close to the original input. We can thus formulate our adversarial attack problem as the following constrained optimization task:</p><formula xml:id="formula_0">x = arg max x : x −x p ≤ p L(x , y)</formula><p>First order methods tend to be very successful at solving the problem despite its non-convexity <ref type="bibr" target="#b7">(Goodfellow et al., 2014;</ref><ref type="bibr" target="#b2">Carlini &amp; Wagner, 2017;</ref><ref type="bibr" target="#b15">Madry et al., 2017)</ref>. A first order method used as the backbone of some of the most powerful white-box adversarial attacks for p bounded adversaries is projected gradient descent (PGD). This iterative method, given some input x and its correct label y, computes a perturbed input x k by applying k steps of the following update (with x 0 = x)</p><formula xml:id="formula_1">x l = Π Bp(x, ) (x l−1 + ηs l ) with s l = Π ∂Bp(0,1) ∇ x L(x l−1 , y) (1)</formula><p>Here, Π S is the projection onto the set S, B p (x , ε ) is the p ball of radius ε around x , η is the step size, and ∂U is the boundary of a set U . Also, as is standard in continuous optimization, we make s l be the projection of the gradient ∇ x L(x l−1 , y) at x l−1 onto the unit p ball. This way we ensure that s l corresponds to the unit p -norm vector that has the largest inner product with ∇ x L(x l−1 , y).</p><p>(Note that, in the case of the 2 -norm, s l is simply the normalized gradient but in the case of, e.g., the ∞ -norm, s l corresponds to the sign vector, sgn (∇ x L(x l−1 , y)) of the gradient.) So, intuitively, the PGD update perturbs the input in the direction that (locally) increases the loss the most. Observe that due to the projection in (1), x k is always a valid perturbation of x, as desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">BLACK-BOX ADVERSARIAL ATTACKS</head><p>The projected gradient descent (PGD) method described above is designed to be used in the context of so-called white-box attacks. That is, in the setting where the adversary has full access to the gradient ∇ x L(x, y) of the loss function of the attacked model. In many practical scenarios, however, this kind of access is not available-in the corresponding, more realistic black-box setting, the adversary has only access to an oracle that returns for a given input (x, y), only the value of the loss L(x, y).</p><p>One might expect that PGD is thus not useful in such black-box setting. It turns out, however, that this intuition is incorrect. Specifically, one can still estimate the gradient using only such value queries. (In fact, this kind of estimator is the backbone of so-called zeroth-order optimization frameworks <ref type="bibr" target="#b22">(Spall, 2005)</ref>.) The most canonical primitive in this context is the finite difference method. This method estimates the directional derivative D v f (x) = ∇ x f (x), v of some function f at a point x in the direction of a vector v as</p><formula xml:id="formula_2">D v f (x) = ∇ x f (x), v ≈ (f (x + δv) − f (x)) /δ.<label>(2)</label></formula><p>Here, the step size δ &gt; 0 governs the quality of the gradient estimate. Smaller δ gives more accurate estimates but also decreases reliability, due to precision and noise issues. Consequently, in practice, δ is a tunable parameter. Now, we can just use finite differences to construct an estimate of the gradient.</p><p>To this end, one can find the d components of the gradient by estimating the inner products of the gradient with all the standard basis vectors e 1 , . . . , e d :</p><formula xml:id="formula_3">∇ x L(x, y) = d k=1 e k (L(x + δe k , y) − L(x, y)) /δ ≈ d k=1 e k ∇ x L(x, y), e k<label>(3)</label></formula><p>We can then easily implement the PGD attack (c.f. (1)) using this estimator:</p><formula xml:id="formula_4">x l = Π Bp(x, ) (x l−1 + η s l ) with s l = Π ∂Bp(0,1) ∇ x L(x l−1 , y)<label>(4)</label></formula><p>Indeed, <ref type="bibr" target="#b4">Chen et al. (2017)</ref> were the first to use finite differences methods in this basic form to power PGD-based adversarial attack in the black-box setting. This basic attack was shown to be successful but, since its query complexity is proportional to the dimension, its resulting query complexity was prohibitively large. For example, the Inception v3 <ref type="bibr" target="#b24">(Szegedy et al., 2015)</ref> classifier on the ImageNet dataset has dimensionality d=268,203 and thus this method would require 268,204 queries. (It is worth noting, however, that <ref type="bibr" target="#b4">Chen et al. (2017)</ref> developed additional methods to, at least partially, reduce this query complexity.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">BLACK-BOX ATTACKS WITH IMPERFECT GRADIENT ESTIMATORS</head><p>In the light of the above discussion, one can wonder if the algorithm (4) can be made more queryefficient. A natural idea here would be to avoid fully estimating the gradient and rely instead only on its imperfect estimators. This gives rise to the following question: How accurate of an gradient estimate is necessary to execute a successful PGD attack?</p><p>We examine this question first in the simplest possible setting: one in which we only take a single PGD step (i.e., the case of k = 1). Previous work <ref type="bibr" target="#b7">(Goodfellow et al., 2014)</ref>   <ref type="figure">1</ref>, suggest that it is feasible to generate adversarial examples without estimating correctly even most of the coordinates of the gradient. For example, in the context of ∞ attacks, setting a randomly selected 20% of the coordinates in the gradient to match the true gradient (and making the remaining coordinates have random sign) is sufficient to fool the classifier on more than 60% images with single-step PGD. Our experiments thus demonstrate that an adversary is likely to be able to cause a misclassification by performing the iterated PGD attack, even when driven by a gradient estimate that is largely imperfect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">THE GRADIENT ESTIMATION PROBLEM</head><p>The above discussion makes it clear that successful attacks do not require a perfect gradient estimation, provided this estimate is suitably constructed. It is still unclear, however, how to efficiently find this kind of imperfect but helpful estimator. Continuous optimization methodology suggests that the key characteristic needed from our estimator is for it to have a sufficiently large inner product with the actual gradient. We thus capture this challenge as the following gradient estimation problem: Definition 1 (Gradient estimation problem). For an input/label pair (x, y) and a loss function L, let g * = ∇ x L(x, y) be the gradient of L at (x, y). Then the goal of the gradient estimation problem is to find a unit vector g maximizing the inner product</p><formula xml:id="formula_5">E g T g * ,<label>(5)</label></formula><p>from a limited number of (possibly adaptive) function value queries L(x , y ). (The expectation here is taken over the randomness of the estimation algorithm.)</p><p>One useful perspective on the above gradient estimation problem stems from casting the recovery of g * in (5) as an underdetermined vector estimation task. That is, one can view each execution of the finite difference method (see (2)) as computing an inner product query in which we obtain the value of the inner product of g * and some chosen direction vector A i . Now, if we execute k such queries, and k &lt; d (which is the regime we are interested in), the information acquired in this process can be expressed as the following (underdetermined) linear regression problem Ag * = y, where the rows of the matrix A correspond to the queries A 1 , . . . , A k and the entries of the vector y gives us the corresponding inner product values.</p><p>Relation to compressive sensing. The view of the gradient estimation problem we developed bears striking similarity to the compressive sensing setting <ref type="bibr" target="#b5">(Foucart &amp; Rauhut, 2013)</ref>. Thus one might wonder if the toolkit of that area could be applied here. Compressive sensing crucially requires, however, certain sparsity structure in the estimated signal (here, in the gradient g * ) and, to our knowledge, the loss gradients do not exhibit such a structure. (We discuss this further in Appendix B.)</p><p>The least squares method. In light of this, we turn our attention to another classical signal-processing method: norm-minimizing 2 least squares estimation. This method approaches the estimation problem posed in (5) by casting it as an undetermined linear regression problem of the form Ag * = b, where we can choose the matrix A (the rows of A correspond to inner product queries with g * ). Then, it obtains the solution g to the regression problem by solving:</p><formula xml:id="formula_6">min g g 2 s.t. A g = y.<label>(6)</label></formula><p>A reasonable choice for A (via <ref type="bibr" target="#b11">Johnson &amp; Lindenstrauss (1984)</ref> and related results) is the distancepreserving random Gaussian projection matrix, i.e. A ij normally distributed.</p><p>The resulting algorithm turns out to yield solutions that are approximately those given by Natural Evolution Strategies (NES), which <ref type="bibr" target="#b10">(Ilyas et al., 2017)</ref> previously applied to black-box attacks. In particular, in Appendix A, we prove the following theorem.</p><p>Theorem 1 (NES and Least Squares equivalence). Let xNES be the Gaussian k-query NES estimator of a d-dimensional gradient g and let xLSQ be the minimal-norm k-query least-squares estimator of g. For any p &gt; 0, with probability at least 1 − p we have that</p><formula xml:id="formula_7">xLSQ , g − xNES , g ≤ O (k/d) • log 3 ((k/p)) ||g|| 2 .</formula><p>Note that when we work in the underdetermined setting, i.e., when k d (which is the setting we are interested in), the right hand side bound becomes vanishingly small. Thus, the equivalence indeed holds. In fact, using the precise statement (given and proved in Appendix A), we can show that Theorem 1 provides us with a non-vacuous equivalence bound. Further, it turns out that one can exploit this equivalence to prove that the algorithm proposed in <ref type="bibr" target="#b10">Ilyas et al. (2017)</ref> is not only natural but optimal, as the least-squares estimate is an information-theoretically optimal gradient estimate in the regime where k = d, and an error-minimizing estimator in the regime where k &lt;&lt; d. Theorem 2 (Least-squares optimality (Proof in Appendix A)). For a linear regression problem y = Ag with known A and y, unknown g, and isotropic Gaussian errors, the least-squares estimator is finite-sample efficient, i.e. the minimum-variance unbiased (MVU) estimator of the latent vector g. Theorem 3 (Least-squares optimality (Proof in <ref type="bibr" target="#b16">Meir (1994)</ref>)). In the underdetermined setting, i.e. when k &lt;&lt; d, the minimum-norm least squares estimate (x LSQ in Theorem 1) is the minimumvariance (and thus minimum-error, since bias is fixed) estimator with no empirical loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BLACK-BOX ADVERSARIAL ATTACKS WITH PRIORS</head><p>The optimality of least squares strongly suggests that we have reached the limit of query-efficiency of black-box adversarial attacks. But is this really the case? Surprisingly, we show that an improvement is still possible. The key observation is that the optimality we established of least-squares (and by Theorem 1, the NES approach in <ref type="bibr" target="#b10">(Ilyas et al., 2017)</ref>) holds only for the most basic setting of the gradient estimation problem, a setting where we assume that the target gradient is a truly arbitrary and completely unknown vector.</p><p>However, in the context we care about this assumption does not hold -there is actually plenty of prior knowledge about the gradient available. Firstly, the input with respect to which we compute the gradient is not arbitrary and exhibits locally predictable structure which is consequently reflected in the gradient. Secondly, when performing iterative gradient attacks (e.g. PGD), the gradients used in successive iterations are likely to be heavily correlated.</p><p>The above observations motivate our focus on prior information as an integral element of the gradient estimation problem. Specifically, we enhance Definition 1 by making its objective</p><formula xml:id="formula_8">E g T g * I]</formula><p>, where I is prior information available to us.</p><p>(7)</p><p>This change in perspective gives rise to two important questions: does there exist prior information that can be useful to us?, and does there exist an algorithmic way to exploit this information? We show that the answer to both of these questions is affirmative.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">GRADIENT PRIORS</head><p>Consider a gradient ∇ x L(x, y) of the loss function corresponding to some input (x, y). Does there exist some kind of prior that can be extracted from the dataset {x i }, in general, and the input (x, y) in particular, that can be used as a predictor of the gradient? We demonstrate that it is indeed the case, and give two example classes of such priors.</p><p>Time-dependent priors. The first class of priors we consider are time-dependent priors, a standard example of which is what we refer to as the "multi-step prior." We find that along the trajectory taken by estimated gradients, successive gradients are in fact heavily correlated. We show this empirically by taking steps along the optimization path generated by running the NES estimator at each point, and plotting the normalized inner product (cosine similarity) between successive gradients, given by Figure <ref type="figure">2</ref> demonstrates that there indeed is a non-trivial correlation between successive gradientstypically, the gradients of successive steps (using step size from Ilyas et al. ( <ref type="formula">2017</ref>)) have a cosine similarity of about 0.9. Successive gradients continue to correlate at higher step sizes: Appendix B shows that the trend continues even at step size 4.0 (a typical value for the total perturbation bound ε). This indicates that there indeed is a potential gain from incorporating this correlation into our iterative optimization. To utilize this gain, we intend to use the gradients at time t − 1 as a prior for the gradient at time t, where both the prior and the gradient estimate itself evolve over iterations.</p><formula xml:id="formula_9">∇ x L(x t , y), ∇ x L(x t+1 , y) ||∇ x L(x t , y)|| 2 ||∇ x L(x t+1 , y)|| 2 t ∈ {1 . . . T − 1}.<label>(8</label></formula><p>Data-dependent priors. We find that the time-dependent prior discussed above is not the only type of prior one can exploit here. Namely, we can also use the structure of the inputs themselves to reduce query complexity (in fact, the existence of such data-dependent priors is what makes machine learning successful in the first place).</p><p>In the case of image classification, a simple and heavily exploited example of such a prior stems from the fact that images tend to exhibit a spatially local similarity (i.e. pixels that are close together tend to be similar). We find that this similarity also extends to the gradients: specifically, whenever two coordinates (i, j) and (k, l) of ∇ x L(x, y) are close, we expect ∇ x L(x, y) ij ≈ ∇ x L(x, y) kl too. To corroborate and quantify this phenomenon, we compare ∇ x L(x, y) with an average-pooled, or "tiled", version (with "tile length" k) of the same signal. An example of such an average-blurred gradient can be seen in Appendix B. More concretely, we apply to the gradient the mean pooling operation with kernel size (k, k, 1) and stride (k, k, 1), then upscale the spatial dimensions by k. We then measure the cosine similarity between the average-blurred gradient and the gradient itself. Our results, shown in Figure <ref type="figure">3</ref>, demonstrate that the gradients of images are locally similar enough to allow for average-blurred gradients to maintain relatively high cosine similarity with the actual gradients, even when the tiles are large. Our results suggest that we can reduce the dimensionality of our problem by a factor of k 2 (for reasonably large k) and still estimate a vector pointing close to the same direction as the original gradient. This factor, as we show later, leads to significantly improved black-box adversarial attack performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A FRAMEWORK FOR GRADIENT ESTIMATION WITH PRIORS</head><p>Given the availability of these informative gradient priors, we now need a framework that enables us to easily incorporate these priors into our construction of black-box adversarial attacks. Our proposed method builds on the framework of bandit optimization, a fundamental tool in online convex optimization <ref type="bibr" target="#b9">Hazan (2016)</ref>. In the bandit optimization framework, an agent plays a game that consists of a sequence of rounds. In round t, the agent must choose a valid action, and then by playing the action incurs a loss given by a loss function t (•) that is unknown to the agent. After playing the action, he/she only learns the loss that the chosen action incurs; the loss function is specific to the round t and may change arbitrarily between rounds. The goal of the agent is to minimize the average loss incurred over all rounds, and the success of the agent is usually quantified by comparing the total loss incurred to that of the best expert in hindsight (the best single-action policy). By the nature of this formulation, the rounds of this game can not be treated as independent -to perform well, the agent needs to keep track of some latent record that aggregates information learned over a sequence of rounds. This latent record usually takes a form of a vector v t that is constrained to a specified (convex) set K. As we will see, this aspect of the bandit optimization framework will provide us with a convenient way to incorporate prior information into our gradient prediction.</p><p>An overview of gradient estimation with bandits. We can cast the gradient estimation problem as an bandit optimization problem in a fairly direct manner. Specifically, we let the action at each round t be a gradient estimate g t (based on our latent vector v t ), and the loss t correspond to the (negative) inner product between this prediction and the actual gradient. Note that we will never have a direct access to this loss function t but we are able to evaluate its value on a particular prediction vector g t via the finite differences method (2) (which is all that the bandits optimization framework requires us to be able to do).</p><p>Just as this choice of the loss function t allows us to quantify performance on the gradient estimation problem, the latent vector v t will allow us to algorithmically incorporate prior information into our predictions. Looking at the two example priors we consider, the time-dependent prior will be reflected by carrying over the latent vector between the gradient estimations at different points. Data-dependent priors will be captured by enforcing that our latent vector has a particular structure. For the specific prior we quantify in the preceding section (data-dependent prior for images), we will simply reduce the dimensionality of the latent vector via average-pooling ("tiling"), removing the need for extra queries to discern components of the gradient that are spatially close.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">IMPLEMENTING GRADIENT ESTIMATION IN THE BANDIT FRAMEWORK</head><p>We now describe our bandit framework for adversarial example generation in more detail. Note that the algorithm is general and can be used to construct black-box adversarial examples where the perturbation is constrained to any convex set ( p -norm constraints being a special case). We discuss the algorithm in its general form, and then provide versions explicitly applied to the 2 and ∞ cases.</p><p>As previously mentioned, the latent vector v t ∈ K serves as a prior on the gradient for the corresponding round t -in fact, we make our prediction g t be exactly v t projected onto the appropriate space, and thus we set K to be an extension of the space of valid adversarial perturbations (e.g. R n for 2 examples, [−1, 1] n for ∞ examples). Our loss function t is defined as</p><formula xml:id="formula_10">t (g) = − ∇L(x, y), g ||g|| ,<label>(9)</label></formula><p>for a given gradient estimate g, where we access this inner product via finite differences. Here, L(x, y) is the classification loss on an image x with true class y.</p><p>The crucial element of our algorithm will thus be the method of updating the latent vector v t . We will adapt here the canonical "reduction from bandit information" <ref type="bibr" target="#b9">(Hazan, 2016)</ref>. Specifically, our update procedure is parametrized by an estimator ∆ t of the gradient ∇ v t (v), and a first-order update step A (K × R dim(K) → K), which maps the latent vector v t and the estimated gradient of t with respect to v t (which we denote ∆ t ) to a new latent vector v t+1 . The resulting general algorithm is presented as Algorithm 1.</p><p>In our setting, we make the estimator ∆ of the gradient −∇ v ∇L(x, y), v of the loss be the standard spherical gradient estimator (see <ref type="bibr" target="#b9">Hazan (2016)</ref>). We take a two-query estimate of the expectation, and employ antithetic sampling which results in the estimate being computed as</p><formula xml:id="formula_11">∆ = (v + δu) − (v − δu) δ u,<label>(10)</label></formula><p>Algorithm 1 Gradient Estimation with Bandit Optimization 1: procedure BANDIT-OPT-LOSS-GRAD-EST(x, y init ) 2:</p><formula xml:id="formula_12">v 0 ← A(φ) 3:</formula><p>for each round t = 1, . . . , T do 4:</p><p>// Our loss in round t is t (g t ) = − ∇ x L(x, y init ), g t 5:</p><p>g t ← v t−1 6:</p><formula xml:id="formula_13">∆ t ← GRAD-EST(x, y init , v t−1 ) // Estimated Gradient of t 7: v t ← A(v t−1 , ∆ t ) 8: g ← v T 9: return Π ∂K [g]</formula><p>where u is a Gaussian vector sampled from N (0, 1 d I). The resulting algorithm for calculating the gradient estimate given the current latent vector v, input x and the initial label y is Algorithm 2.</p><p>Algorithm 2 Single-query spherical estimate of ∇ v ∇L(x, y), v</p><formula xml:id="formula_14">1: procedure GRAD-EST(x, y, v) 2: u ← N (0, 1 d I) // Query vector 3:</formula><p>{q 1 , q 2 } ← {v + δu, v − δu} // Antithetic samples 4:</p><p>t (q 1 ) = − ∇L(x, y), q 1 ≈ L(x,y)−L(x+ •q1,y) // Gradient estimation loss at q 1 5:</p><p>t (q 2 ) = − ∇L(x, y), q 2 ≈ L(x,y)−L(x+ •q2,y) // Gradient estimation loss at q 2 6:</p><formula xml:id="formula_15">∆ ← t(q1)− t(q2) δ u = L(x+ q2,y)−L(x+ q1,y) δ u 7:</formula><p>// Note that due to cancellations we can actually evaluate ∆ with only two queries to L 8:</p><p>return ∆</p><p>A crucial point here is that the above gradient estimator ∆ t parameterizing the bandit reduction has no direct relation to the "gradient estimation problem" as defined in Section 2.4. It is simply a general mechanism by which we can update the latent vector v t in bandit optimization. It is the actions g t (equal to v t ) which provide proposed solutions to the gradient estimation problem from Section 2.4.</p><p>The choice of the update rule A tends to be natural once the convex set K is known. For K = R n , we can simply use gradient ascent:</p><formula xml:id="formula_16">v t = A(v t−1 , ∆ t ) := v t−1 + η • ∆ t (11)</formula><p>and the exponentiated gradients (EG) update when the constraint is an ∞ bound (i.e. K = [−1, 1] n ):</p><formula xml:id="formula_17">p t−1 = 1 2 (v t−1 + 1) p t = A(g t−1 , ∆ t ) := 1 Z p t−1 exp(η • ∆ t ) s.t. Z = p t−1 exp(η • ∆ t ) + (1 − p t−1 ) exp(−η • ∆ t ) v t = 2p t − 1</formula><p>Finally, in order to translate our gradient estimation algorithm into an efficient method for constructing black-box adversarial examples, we interleave our iterative gradient estimation algorithm with an iterative update of the image itself, using the boundary projection of g t in place of the gradient (c.f. ( <ref type="formula">1</ref>)). This results in a general, efficient, prior-exploiting algorithm for constructing black-box adversarial examples. The resulting algorithm in the 2 -constrained case is shown in Algorithm 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTS AND EVALUATION</head><p>We evaluate our bandit approach described in Section 3 and the natural evolutionary strategies (NES) approach of <ref type="bibr" target="#b10">Ilyas et al. (2017)</ref> on their effectiveness in generating untargeted adversarial examples. We consider both the 2 and ∞ threat models on the ImageNet <ref type="bibr" target="#b21">(Russakovsky et al., 2015)</ref> dataset, in terms of success rate and query complexity. We further investigate loss and gradient estimate quality over the optimization trajectory in each method. To show the method extends to other datasets, x 0 ← x init // Adversarial image to be constructed 5:</p><p>while C(x) = y init do 6:</p><p>g t ← v t−1 7:</p><p>x t ← x t−1 + h • gt ||gt||2 // Boundary projection g ||gt|| standard PGD: c.f. <ref type="bibr" target="#b20">(Rigollet, 2015)</ref> 8:</p><formula xml:id="formula_18">∆ t ← GRAD-EST(x t−1 , y init , v t−1 ) // Estimated Gradient of t 9: v t ← v t−1 + η • ∆ t 10: t ← t + 1 return x t−1</formula><p>we also compare to NES in the CIFAR-∞ threat model; in all threat models, we show results on Inception-v3, Resnet-50, and VGG16 classifiers.</p><p>In evaluating our approach, we test both the bandit approach with time prior (Bandits T ), and our bandit approach with the given examples of both the data and time priors (Bandits T D ). We use 10,000 and 1,000 randomly selected images (scaled to [0, 1]) to evaluate all approaches on ImageNet and CIFAR-10 respectively. For NES, Bandits T , and Bandits T D we found hyperparameters (given in Appendix C, along with the experimental parameters) via grid search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">RESULTS</head><p>For ImageNet, we record the effectiveness of the different approaches in both threat models in Table <ref type="table">1</ref> ( 2 and ∞ perturbation constraints), where we show the attack success rate and the mean number of queries (of the successful attacks) needed to generate an adversarial example for the Inception-v3 classifier (results for other classifiers in Appendix F). For all attacks, we limit the attacker to at most 10,000 oracle queries. As shown in Table <ref type="table">1</ref>, our bandits framework with both data-dependent and time prior (Bandits T D ), is six and three times less failure-prone than the previous state of the art (NES <ref type="bibr" target="#b10">(Ilyas et al., 2017)</ref>) in the ∞ and 2 settings, respectively. Despite the higher success rate, our method actually uses around half as many queries as NES. In particular, when restricted to the inputs on which NES is successful in generating adversarial examples, our attacks are 2.5 and 5 times as query-efficient for the ∞ and 2 settings, respectively. In Appendix G, we also compare against the AutoZOOM method of <ref type="bibr" target="#b25">Tu et al. (2018)</ref>, where we show that our Bandits T D method at a higher 100% success rate is over 6 times as query-efficient. Finally, we also have similar results for CIFAR-10 under the ∞ threat model, which can be found in Appendix E.</p><p>We also further quantify the performance of our methods in terms of black-box attacks, and gradient estimation. Specifically, we first measure average queries per success after reaching a certain success rate (Figure <ref type="figure" target="#fig_1">4a</ref>), which indicates the dependence of the query count on the desired success rate. The data shows that for any fixed success rate, our methods are more query-efficient than NES, and (due to the exponential trend) suggest that the difference may be amplified for higher success rates. We then plot the loss of the classifier over time (averaged over all images), and performance on the gradient estimation problem for both ∞ and 2 cases (which, crucially, corresponds directly to the expectation we maximize in (7). We show these three plots for ∞ in Figure <ref type="figure" target="#fig_1">4</ref>, and show the results for 2 (which are extremely similar) in Appendix D, along with CDFs showing the success of each method as a function of the query limit. We find that on every metric in both threat models, our methods strictly dominate NES in terms of performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATED WORK</head><p>All known techniques for generating adversarial examples in the black-box setting so far rely on either iterative optimization schemes (our focus) or so-called substitute networks and transferability.</p><p>In the first line of work, algorithms use queries to gradually perturb a given input to maximize a corresponding loss, causing misclassification. <ref type="bibr" target="#b18">Nelson et al. (2012)</ref> presented the first such iterative attack on a special class of binary classifiers. Later, <ref type="bibr" target="#b26">Xu et al. (2016)</ref>   <ref type="formula">2017</ref>) designed a black-box attack strategy that also uses finite differences but via natural evolution strategies (NES) to estimate the gradients. They then used their algorithm as a primitive in attacks on more restricted threat models.</p><p>In a concurrent line of work, <ref type="bibr" target="#b19">Papernot et al. (2017)</ref> introduce a method for attacking models with so-called substitute networks. Here, the attacker trains a model -called a substitute network -to mimic the target network's decisions (obtained with black-box queries) , then uses (white-box) adversarial examples for the substitute network to attack the original model. Adversarial examples generated with these methods <ref type="bibr" target="#b19">Papernot et al. (2017)</ref>; <ref type="bibr" target="#b14">Liu et al. (2016)</ref> tend to transfer to a target MNIST or CIFAR classifier. We note, however, that for attacking single inputs, the overall query efficiency of this type of methods tends to be worse than that of the gradient estimation based ones. Substitute models are also thus far unable to make targeted black-box adversarial examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We develop a new, unifying perspective on black-box adversarial attacks. This perspective casts the construction of such attacks as a gradient estimation problem. We prove that a standard least-squares estimator both captures the existing state-of-the-art approaches to black-box adversarial attacks, and actually is, in a certain natural sense, an optimal solution to the problem.</p><p>We then break the barrier posed by this optimality by considering a previously unexplored aspect of the problem: the fact that there exists plenty of extra prior information about the gradient that one can exploit to mount a successful adversarial attack. We identify two examples of such priors: a "time-dependent" prior that corresponds to similarity of the gradients evaluated at similar inputs, and a "data-dependent" prior derived from the latent structure present in the input space.</p><p>Finally, we develop a bandit optimization approach to black-box adversarial attacks that allows for a seamless integration of such priors. The resulting framework significantly outperforms state-of-the-art by a factor of two to six in terms of success rate and query efficiency. Our results thus open a new avenue towards finding priors for construction of even more efficient black-box adversarial attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A PROOFS</head><p>Theorem 1 (NES and Least Squares equivalence). Let xNES be the Gaussian k-query NES estimator of a d-dimensional gradient g and let xLSQ be the minimal-norm k-query least-squares estimator of g. For any p &gt; 0, with probability at least 1 − p we have that</p><formula xml:id="formula_19">xLSQ , g − xNES , g ≤ O k d • log 3 k p ||g|| 2 ,</formula><p>and in particular,</p><formula xml:id="formula_20">xLSQ , g − xNES , g ≤ 8 2k d • log 3 2k + 2 p 1 + κ √ d ||g|| 2</formula><p>with probability at least 1 − p, where</p><formula xml:id="formula_21">κ ≤ 2 log 2k(k + 1) p .</formula><p>Proof. Let us first recall our estimation setup. We have k query vectors δ i ∈ R d drawn from an i.i.d Gaussian distribution whose expected squared norm is one, i.e. δ i ∼ N (0, 1 d I), for each 1 ≤ i ≤ k. Let the vector y ∈ R k denote the inner products of δ i s with the gradient, i.e.</p><formula xml:id="formula_22">y i := δ i , g ,</formula><p>for each 1 ≤ i ≤ k. We define the matrix A to be a k × d matrix with the δ i s being its rows. That is, we have Ag = y. Now, recall that the closed forms of the two estimators we are interested in are given by</p><formula xml:id="formula_23">xNES = A T y = A T Ag xLSQ = A T (AA T ) −1 y = A T (AA T ) −1 Ag, which implies that xNES , g = g T A T Ag xLSQ , g = g T A T (AA T ) −1 Ag.</formula><p>We can bound the difference between these two inner products as</p><formula xml:id="formula_24">xLSQ , g − xNES , g = g T A T (AA T ) −1 − I Ag ≤ g T A T (AA T ) −1 − I ||Ag|| ≤ (AA T ) −1 − I ||Ag|| 2 . (<label>12</label></formula><formula xml:id="formula_25">)</formula><p>Now, to bound the first term in (12), observe that</p><formula xml:id="formula_26">(AA T ) −1 = I − (I − AA T ) −1 = ∞ l=0 (I − AA T ) l</formula><p>and thus</p><formula xml:id="formula_27">I − (AA T ) −1 = ∞ l=1 (AA T − I) l .</formula><p>(Note that the first term in the above sum has been canceled out.) This gives us that</p><formula xml:id="formula_28">I − (AA T ) −1 ≤ ∞ l=1 AA T − I l ≤ AA T − I 1 − ||AA T − I|| ≤ 2 AA T − I ,</formula><p>as long as AA T − I ≤ 1 2 (which, as we will see, is indeed the case with high probability). Our goal thus becomes bounding AA T − I = λ max (AA T − I), where λ max (•) denotes the largest (in absolute value) eigenvalue. Observe that AA T and −I commute and are simultaneously diagonalizable. As a result, for any 1 ≤ i ≤ k, we have that the i-th largest eigenvalue λ i (AA T − I) of AA T − I can be written as</p><formula xml:id="formula_29">λ i (AA T − I) = λ i (AA T ) + λ i (−I) i = λ i (AA T ) − 1.</formula><p>So, we need to bound</p><formula xml:id="formula_30">λ max (AA T − I) = max λ 1 (AA T ) − 1, 1 − λ k (AA T )</formula><p>To this end, recall that E[AA T ] = I (since the rows of A are sampled from the distribution N (0, 1 d I)), and thus, by the covariance estimation theorem of <ref type="bibr" target="#b6">Gittens and Tropp Gittens &amp; Tropp (2011)</ref> (see Corollary 7.2) (and union bounding over the two relevant events), we have that</p><formula xml:id="formula_31">Pr(λ max (AA T − I) ≥ ε) = Pr(λ 1 (AA T ) ≥ 1 + ε or λ k (AA T ) ≥ 1 − ε) = Pr(λ 1 (AA T ) ≥ λ 1 (I) + ε or λ k (AA T ) ≥ λ k (I) − ε) ≤ 2k • exp − dε 2 32k . Setting ε = 32k log(2(k + 1)/p) d , ensuring that ε ≤ 1 2 , gives us Pr λ max (AA T ) − 1 ≥ 32k log(2(k + 1)/p) d ≤ k k + 1 p.</formula><p>and thus</p><formula xml:id="formula_32">(AA T ) −1 − I ≤ 32k log(2(k + 1)/p) d ,<label>(13)</label></formula><p>with probability at least 1 − k k+1 p. To bound the second term in (12), we note that all the vectors δ i are chosen independently of the vector g and each other. So, if we consider the set {ĝ, δ1 , . . . , δk } of k + 1 corresponding normalized directions, we have (see, e.g., <ref type="bibr" target="#b8">(Gorban et al., 2016)</ref>) that the probability that any two of them have the (absolute value of) their inner product be larger than some ε = 2 log(2(k+1)/p) d is at most</p><formula xml:id="formula_33">exp −(k + 1) 2 e −d(ε ) 2 /2 = exp −2 k + 1 p ≤ p 2(k + 1)</formula><p>.</p><p>On the other hand, we note that each δ i is a random vector sampled from the distribution N (0, 1 d I d ), so we have that (see, e.g., Lemma 1 in <ref type="bibr">(Laurent &amp; Massart, 2000)</ref>), for any 1 ≤ i ≤ k and any ε &gt; 0,</p><formula xml:id="formula_34">Pr ||δ i || 2 ≥ 1 + ε ≤ exp − (ε ) 2 d 4 .</formula><p>Setting ε = 2 log(2k(k + 1)/p) d yields</p><formula xml:id="formula_35">P ||δ i || 2 ≥ 1 + 2 log(2(k + 1)k/p) d ≤ p 2k(k + 1)</formula><p>.</p><p>Published as a conference paper at ICLR 2019 Applying these two bounds (and, again, union bounding over all the relevant events), we get that</p><formula xml:id="formula_36">||Ag|| 2 = k i=1 (Ag) 2 i ≤ d •   2 log 2(k+1) p d       1 + 2 log 2k(k+1) p d     ||g|| 2 ≤ 2 log 2(k + 1) p     1 + 2 2 log 2(k+1) p d     ||g|| 2</formula><p>with probability at most p k+1 .</p><p>Finally, by plugging the above bound and the bound (13) into the bound (12), we obtain that</p><formula xml:id="formula_37">xLSQ , g − xNES , g ≤ 32k log(2(k + 1)/p) d • 2 log 2(k + 1) p     1 + 2 2 log 2(k+1) p d     ||g|| 2 ≤ 8 2k d • log 3 2k + 2 p 1 + κ √ d ||g|| 2 ,</formula><p>with probability 1 − p, where κ = 2 log 2k(k + 1) p .</p><p>This completes the proof.</p><p>Theorem 2 (Least-Squares Optimality). For a fixed projection matrix A and under the following observation model of isotropic Gaussian noise: y = Ag + ε where ε ∼ N (0, εId), the least-squares estimator as in Theorem 1, xLSQ = A T (AA T ) −1 y is a finite-sample efficient (minimum-variance unbiased) estimator of the parameter g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof.</head><p>Proving the theorem requires an application of the Cramer-Rao Lower Bound theorem:</p><p>Theorem 3 (Cramer-Rao Lower Bound). Given a parameter θ, an observation distribution p(x; θ), and an unbiased estimator θ that uses only samples from p(x; θ), then (subject to Fisher regularity conditions trivially satisfied by Gaussian distributions),</p><formula xml:id="formula_38">Cov θ − θ = E ( θ − θ)( θ − θ) T ≥ [I(θ)]</formula><p>−1 where I(θ) is the Fisher matrix:</p><formula xml:id="formula_39">[I(θ)] ij = −E ∂ log p(x; θ) ∂θ i ∂θ j</formula><p>Now, note that the Cramer-Rao bound implies that if the variance of the estimator θ is the inverse of the Fisher matrix, θ must be the minimum-variance unbiased estimator. Recall the following form of the Fisher matrix:</p><formula xml:id="formula_40">I(θ) = E ∂ log p(x; θ) ∂θ ∂ log p(x; θ) ∂θ T (14)</formula><p>Now, suppose we had the following equality, which we can then simplify using the preceding equation: </p><formula xml:id="formula_41">I(θ) θ − θ = ∂ log p(x; θ) ∂θ<label>(15)</label></formula><formula xml:id="formula_42">I(θ)E ( θ − θ)( θ − θ) T I(θ) = I(θ)<label>(18)</label></formula><p>Multiplying the preceding by [I(θ)] −1 on both the left and right sides yields:</p><formula xml:id="formula_43">E ( θ − θ)( θ − θ) T = [I(θ)] −1 ,<label>(19)</label></formula><p>which tells us that ( <ref type="formula" target="#formula_41">15</ref>) is a sufficient condition for finite-sample efficiency (minimal variance). We show that this condition is satisfied in our case, where we have y ∼ Ag + ε, θ = xLSQ , and θ = g. We begin by computing the Fisher matrix directly, starting from the distribution of the samples y:</p><formula xml:id="formula_44">p(y; g) = 1 (2πε) d exp 1 2ε (y − Ag) T (y − Ag) (20) log p(y; g) = d 2 log (2πε) + 1 2ε (y − Ag) T (y − Ag) (21) ∂ log p(y; g) ∂g = 1 2ε 2A T (y − Ag) (22) = 1 ε A T (y − Ag) (23)<label>(24)</label></formula><p>Using ( <ref type="formula">14</ref>),</p><formula xml:id="formula_45">I(g) = E 1 ε A T (y − Ag) 1 ε A T (y − Ag) T (25) = 1 ε 2 A T E (y − Ag)(y − Ag) T A (26) B OMITTED FIGURES B.1 COMPRESSIVE SENSING</formula><p>Compressed sensing approaches can, in some cases, solve the optimization problem presented in Section 2.4. However, these approaches require sparsity to improve over the least squares method.</p><p>Here we show the lack of sparsity in gradients through a classifier on a set of canonical bases for images. In Figure <ref type="figure" target="#fig_3">5</ref>, we plot the fraction of 2 weight accounted for by the largest k components in randomly chosen image gradients when using two canonical bases: standard and wavelet (db4). While lack of sparsity in these bases does not strictly preclude the existence of a basis on which gradients are sparse, it suggests the lack of a fundamental structural sparsity in gradients through a convolutional neural network. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 TILING</head><p>An example of the tiling procedure applied to a gradient can be seen in Figure <ref type="figure">6</ref>. We show in Figure <ref type="figure" target="#fig_5">7</ref> that the correlation between successive gradients on the NES trajectory are signficantly correlated, even at much higher step sizes (up to 2 norm of 4.0, which is a typical value for ε, the total adversarial perturbation bound and thus an absolute bound on step size). This serves as further motivation for the time-dependent prior.    Figure <ref type="figure">9</ref>: Cumulative distribution functions for the number of queries required to create an adversarial example in the 2 and ∞ settings for the NES, bandits with time prior (Bandits T ), and bandits with time and data-dependent priors (Bandits T D ) approaches. Note that the CDFs do not converge to one, as the approaches sometimes cannot find an adversarial example in less than 10,000 queries. Figure <ref type="figure">10</ref>: The average number of queries used per successful image for each method when reaching a specified success rate: we compare NES <ref type="bibr" target="#b10">Ilyas et al. (2017)</ref>, Bandits T (our method with time prior only), and Bandits T D (our method with both data and time priors) and find that our methods strictly dominate NES-that is, for any desired sucess rate, our methods take strictly less queries per successful image than NES.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C HYPERPARAMETERS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E RESULTS FOR CIFAR-10</head><p>Here, we give results for the CIFAR-10 dataset, comparing our best method (Bandits T D ) and NES. We train Inception-v3, ResNet-50, and VGG16 classifiers by fine-tuning the standard PyTorch ImageNet classifiers. As such, all images are upsampled to 224 × 224 (299 × 299) for . Just as for ImageNet, we use a maximum ∞ perturbation of 0.05, where images are scaled to [0, 1].</p><p>Table 5: Summary of effectiveness of ∞ CIFAR10 attacks on Inception v3, ResNet-50, and VGG16 (I, R, V) using NES and bandits with time and data-dependent priors (Bandits T D ). Note that in the first column, the average number of queries is calculated only over successful attacks, and we enforce a query limit of 10,000 queries. For purposes of direct comparison, the last column calculates the average number of queries used for only the images that NES (previous SOTA) was successful on. Our most powerful attack uses 2-4 times fewer queries, and fails 2-22 times less often.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attack</head><p>Avg To compare with the method of <ref type="bibr" target="#b25">Tu et al. (2018)</ref>, we consider the same classifier and dataset (Inception-v3 and Imagenet) under the same 2 threat model. Note that <ref type="bibr" target="#b25">Tu et al. (2018)</ref> use mean rather than maximum 2 perturbation to evaluate their attacks (since the method is based on a Lagrangian relaxation). To ensure a fair comparison we compare against the average number of queries to reach the adversarial examples bounded within a pertubation budget of 2 • 10 −4 , which is explicitly reported byTu et al. <ref type="bibr">(2018)</ref>.</p><p>For the bandits approach, we used Bandits T , (the bandits method with the time prior) and Bandits T D (the bandits method with both time and data prior) and run the methods until 100% success is reached. We use the same hyperparameters from the untargeted ImageNet experiments (given in Appendix C).</p><p>Our findings, given in Table <ref type="table">7</ref> show that our best method achieves an 100% success rate, and an over 6-fold reduction in queries. Note that the method of <ref type="bibr" target="#b25">Tu et al. (2018)</ref> achieves 100% success rate in general, but only constrains the mean 2 perturbation, and thus actually achieves a strictly less than 100% success rate with this perturbation threshold.</p><p>Table <ref type="table">7</ref>: Comparison against coordinate-based query efficient finite differences attacks from <ref type="bibr" target="#b25">Tu et al. (2018)</ref>, using the ImageNet dataset, with a maximum 2 constraint of 0.0002 per-pixel normalized (which is equal to a max-2 threshold reported by <ref type="bibr" target="#b25">Tu et al. (2018)</ref>). For our methods (Bandits T and Bandits T D ) we use the same hyperparameters as in our comparison to NES, which are given in Appendix C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attack</head><p>Avg. Queries Success Rate AutoZOOM-BiLin <ref type="bibr" target="#b25">(Tu et al., 2018)</ref> 15,064 &lt;100% AutoZOOM-AE <ref type="bibr" target="#b25">(Tu et al., 2018)</ref> 14,914 &lt;100% Bandits T (Ours) 4455 100% Bandits T D (Ours) 2297 100%</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: Cosine similarity between the gradients at the current and previous steps along the optimization trajectory of NES PGD attacks, averaged over 1000 random ImageNet images.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure4: (left) Average number of queries per successful image as a function of the number of total successful images; at any desired success rate, our methods use significantly less queries per successful image than NES, and the trend suggests that this gap increases with the desired success rate. (center) The loss over time, averaged over all images; (right) The correlation of the latent vector with the true gradient g, which is precisely the gradient estimation objective we define.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Sparsity in standard, wavelet (db4 wavelets), and PCA-constructed bases for the gradients of 5,000 randomly chosen example images in the ImageNet validation set. The y-axis shows the mean fraction of 2 weight held by the largest k vectors over the set of 5,000 chosen images. The x-axis varies k. The gradients are taken through a standardly trained Inception v3 network. None of the bases explored induce significant sparsity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Figure6: Average blurred gradient with kernel size or "tile length" 5. The original gradient can be seen in 6a, and the "tiled" or average blurred gradient can be seen in 6b</figDesc><graphic url="image-1.png" coords="18,141.17,516.84,151.47,151.47" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Figure 2 repeated for several step sizes, showing that the successive correlation between gradients continues even at higher step sizes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure8: Average loss and cosine distance versus number of queries used over the approaches' optimization trajectories in the two threat models. We average each cosine distance and loss point at each query number over 100 images from the evaluation set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>query limit ( 2 ) NES Bandits T (time prior) Bandits T D (time + data)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>by success % ( 2 ) NES Bandits T (time prior) Bandits T D (time + data)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Algorithm 3 Adversarial Example Generation with Bandit Optimization for 2 norm perturbations 1: procedure ADVERSARIAL-BANDIT-L2(x init , y init )</figDesc><table><row><cell>2:</cell><cell>// C(•) returns top class</cell></row><row><cell>3:</cell><cell></cell></row></table><note>v 0 ← 0 1×d // If data prior, d &lt; dim(x); v t (∆ t ) up (down)-sampled before (after) line 8 4:</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Hyperparameters for the NES approach.</figDesc><table><row><cell>Hyperparameter</cell><cell></cell><cell>Value</cell><cell></cell></row><row><cell></cell><cell cols="3">ImageNet ∞ ImageNet 2 CIFAR10 ∞</cell></row><row><cell>Samples per step</cell><cell>100</cell><cell>10</cell><cell>50</cell></row><row><cell>Learning Rate</cell><cell>0.01</cell><cell>0.3</cell><cell>0.01</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Hyperparameters for the bandits approach (variables names as used in pseudocode).</figDesc><table><row><cell>Hyperparameter</cell><cell></cell><cell>Value</cell><cell></cell></row><row><cell></cell><cell cols="3">ImageNet ∞ ImageNet 2 CIFAR10 ∞</cell></row><row><cell>η (OCO learning rate)</cell><cell>100</cell><cell>0.1</cell><cell>100</cell></row><row><cell>h (Image p learning rate)</cell><cell>0.005</cell><cell>0.5</cell><cell>0.0001</cell></row><row><cell>δ (Bandit exploration)</cell><cell>0.01</cell><cell>0.01</cell><cell>0.01</cell></row><row><cell>η (Finite difference probe)</cell><cell>0.01</cell><cell>0.01</cell><cell>0.01</cell></row><row><cell>Tile size (Data-dependent prior only)</cell><cell>(6px) 2</cell><cell>(6px) 2</cell><cell>(10px) 2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>Experimental setup for comparing Bandits-NES. Setup and results for comparison with<ref type="bibr" target="#b25">Tu et al. (2018)</ref> in Appendix G</figDesc><table><row><cell>Parameter</cell><cell></cell><cell>Value</cell><cell></cell></row><row><cell></cell><cell cols="3">ImageNet ∞ ImageNet 2 CIFAR10 ∞</cell></row><row><cell>Max allowed queries</cell><cell></cell><cell>10, 000</cell><cell></cell></row><row><cell>Test set size</cell><cell>10, 000</cell><cell>10, 000</cell><cell>1, 000</cell></row><row><cell>Allowed perturbation ε</cell><cell>0.05</cell><cell>5.0</cell><cell>0.05</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">The code for reproducing our work is available at https://git.io/fAjOJ.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank Ludwig Schmidt for suggesting the connection between LSQ and NES. AM supported in part by NSF grants CCF-1553428 and CNS-1815221. LE supported in part by a Siebel Foundation Scholarship and IBM Watson AI grant. AI supported by an Analog Devices Fellowship.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Finally, note that we can write:</p><p>which concludes the proof, as we have shown that xLSQ satisfies the condition (15), which in turn implies finite-sample efficiency.</p><p>Claim 1. Applying the precise bound that we can derive from Theorem 1 on an ImageNet-sized dataset (d = 300000) and using k = 100 queries (what we use in our ∞ threat model and ten times that used for our 2 threat model),</p><p>For 10 queries,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F RESULTS FOR OTHER CLASSIFIERS</head><p>Here, we give results for the ImageNet dataset, comparing our best method (Bandits T D ) and NES for Inception-v3 (also shown in Table <ref type="table">1</ref>), VGG16, and ResNet50 classifiers. Note that we do not fine-tune the hyperparameters to the new classifiers, but simply use the hyperparameters found for Inception-v3. Nevertheless, our best method consistently outperforms NES on black-box attacks.</p><p>Table 6: Summary of effectiveness of ∞ and 2 ImageNet attacks on Inception v3, ResNet-50, and VGG16 (I, R, V) using NES and bandits with time and data-dependent priors (Bandits T D ). Note that in the first column, the average number of queries is calculated only over successful attacks, and we enforce a query limit of 10,000 queries. For purposes of direct comparison, the last column calculates the average number of queries used for only the images that NES (previous SOTA) was successful on.</p><p>Our most powerful attack uses 2-4 times fewer queries, and fails 2-5 times less often. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Synthesizing robust adversarial examples</title>
		<author>
			<persName><forename type="first">Anish</forename><surname>Athalye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Logan</forename><surname>Engstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Kwok</surname></persName>
		</author>
		<idno>CoRR, abs/1707.07397</idno>
		<ptr target="http://arxiv.org/abs/1707.07397" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Exploring the space of black-box attacks on deep neural networks</title>
		<author>
			<persName><forename type="first">Nitin</forename><surname>Arjun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Warren</forename><surname>Bhagoji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><surname>Song</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1712.09491</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Towards evaluating the robustness of neural networks</title>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Carlini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (SP), 2017 IEEE Symposium on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="39" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hidden voice commands</title>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Carlini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pratyush</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tavish</forename><surname>Vaidya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuankai</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Micah</forename><surname>Sherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clay</forename><surname>Shields</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenchao</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="513" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Zoo: Zeroth order optimization based black-box attacks to deep neural networks without training substitute models</title>
		<author>
			<persName><forename type="first">Pin-Yu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yash</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinfeng</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cho-Jui</forename><surname>Hsieh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM Workshop on Artificial Intelligence and Security</title>
				<meeting>the 10th ACM Workshop on Artificial Intelligence and Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A mathematical introduction to compressive sensing</title>
		<author>
			<persName><forename type="first">Simon</forename><surname>Foucart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Holger</forename><surname>Rauhut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Birkhäuser Basel</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Tail bounds for all eigenvalues of a sum of random matrices</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gittens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Tropp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-04">apr 2011</date>
		</imprint>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Explaining and harnessing adversarial examples</title>
		<author>
			<persName><forename type="first">Ian</forename><forename type="middle">J</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathon</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Szegedy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.6572</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Approximation with random bases: Pro et contra</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Alexander N Gorban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danil</forename><forename type="middle">V</forename><surname>Yu Tyukin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantin</forename><forename type="middle">I</forename><surname>Prokhorov</surname></persName>
		</author>
		<author>
			<persName><surname>Sofeikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">364</biblScope>
			<biblScope unit="page" from="129" to="145" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Introduction to online convex optimization</title>
		<author>
			<persName><forename type="first">Elad</forename><surname>Hazan</surname></persName>
		</author>
		<idno type="DOI">10.1561/2400000013</idno>
		<ptr target="http://dx.doi.org/10.1561/2400000013" />
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Optimization</title>
		<idno type="ISSN">2167-3888</idno>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="157" to="325" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Black-box adversarial attacks with limited queries and information</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Logan</forename><surname>Engstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anish</forename><surname>Athalye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jessy</forename><surname>Lin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1712.07113</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Extensions of lipschitz mappings into a hilbert space</title>
		<author>
			<persName><forename type="first">Johnson</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joram</forename><surname>Lindenstrauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Contemporary mathematics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Adversarial machine learning at scale</title>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Kurakin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><forename type="middle">J</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samy</forename><surname>Bengio</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.01236</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Adaptive estimation of a quadratic functional by model selection. The Annals of Statistics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Laurent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Massart</surname></persName>
		</author>
		<idno type="DOI">10.1214/aos/1015957395</idno>
		<ptr target="https://doi.org/10.1214/aos/1015957395" />
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page">2000</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Delving into transferable adversarial examples and black-box attacks</title>
		<author>
			<persName><forename type="first">Yanpei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xinyun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.02770</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Towards deep learning models resistant to adversarial attacks</title>
		<author>
			<persName><forename type="first">Aleksander</forename><surname>Madry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aleksandar</forename><surname>Makelov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ludwig</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitris</forename><surname>Tsipras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Vladu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1706.06083</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Deepfool: a simple and accurate method to fool deep neural networks</title>
		<author>
			<persName><forename type="first">Ron</forename><surname>Meir</surname></persName>
		</author>
		<idno>CoRR, abs/1511.04599</idno>
		<ptr target="http://arxiv.org/abs/1511.04599" />
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
				<editor>
			<persName><forename type="first">Seyed-Mohsen</forename><surname>Moosavi-Dezfooli</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alhussein</forename><surname>Fawzi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Pascal</forename><surname>Frossard</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1994">1994. 2015</date>
		</imprint>
	</monogr>
	<note>Bias, variance and the combination of least squares estimators</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Simple black-box adversarial attacks on deep neural networks</title>
		<author>
			<persName><forename type="first">Nina</forename><surname>Narodytska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shiva</forename><surname>Kasiviswanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE Conference on Computer Vision and Pattern Recognition Workshops (CVPRW)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1310" to="1318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Query strategies for evading convex-inducing classifiers</title>
		<author>
			<persName><forename type="first">Blaine</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ling</forename><surname>Benjamin Ip Rubinstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><forename type="middle">D</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">J</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satish</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><surname>Tygar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1293" to="1332" />
			<date type="published" when="2012-05">May. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Practical black-box attacks against machine learning</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Papernot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Somesh</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ananthram</forename><surname>Berkay Celik</surname></persName>
		</author>
		<author>
			<persName><surname>Swami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security</title>
				<meeting>the 2017 ACM on Asia Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="506" to="519" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Mathematics of machine learning course notes: Projected gradient descent</title>
		<author>
			<persName><forename type="first">Phillipe</forename><surname>Rigollet</surname></persName>
		</author>
		<ptr target="https://ocw.mit.edu/courses/mathematics/18-657-mathematics-of-machine-learning-fall-2015/lecture-notes/MIT18_657F15_L12.pdf" />
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">ImageNet Large Scale Visual Recognition Challenge</title>
		<author>
			<persName><forename type="first">Olga</forename><surname>Russakovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jia</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Satheesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiheng</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrej</forename><surname>Karpathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Khosla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">C</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Fei-Fei</surname></persName>
		</author>
		<idno type="DOI">10.1007/s11263-015-0816-y</idno>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Vision (IJCV)</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="211" to="252" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Introduction to stochastic search and optimization: estimation, simulation, and control</title>
		<author>
			<persName><forename type="first">C</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName><surname>Spall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>John Wiley &amp; Sons</publisher>
			<biblScope unit="volume">65</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Intriguing properties of neural networks</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dumitru</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Fergus</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1312.6199</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Rethinking the inception architecture for computer vision</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Ioffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathon</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zbigniew</forename><surname>Wojna</surname></persName>
		</author>
		<idno>corr abs/1512.00567</idno>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Autozoom: Autoencoder-based zeroth order optimization method for attacking black-box neural networks</title>
		<author>
			<persName><forename type="first">Chun-Chen</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pai-Shun</forename><surname>Ting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pin-Yu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sijia</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinfeng</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cho-Jui</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shin-Ming</forename><surname>Cheng</surname></persName>
		</author>
		<idno>CoRR, abs/1805.11770</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automatically evading classifiers</title>
		<author>
			<persName><forename type="first">Weilin</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanjun</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Network and Distributed Systems Symposium</title>
				<meeting>the 2016 Network and Distributed Systems Symposium</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
