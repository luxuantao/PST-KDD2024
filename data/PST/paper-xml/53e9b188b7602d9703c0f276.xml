<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Jockey: Guaranteed Job Latency in Data Parallel Clusters</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><forename type="middle">D</forename><surname>Ferguson</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Bodik</surname></persName>
							<email>peterb@microsoft.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Srikanth</forename><surname>Kandula</surname></persName>
							<email>srikanth@microsoft.com</email>
							<affiliation key="aff2">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eric</forename><surname>Boutin</surname></persName>
							<email>eric.boutin@microsoft.com</email>
							<affiliation key="aff3">
								<orgName type="institution">Microsoft Bing</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rodrigo</forename><surname>Fonseca</surname></persName>
							<email>rfonseca@cs.brown.edu</email>
							<affiliation key="aff4">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Jockey: Guaranteed Job Latency in Data Parallel Clusters</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">71FCF52564C39A9560101D619C6CAC40</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.1 [Operating Systems]: Process Management-Scheduling General Terms Algorithms</term>
					<term>Performance deadline</term>
					<term>scheduling</term>
					<term>SLO</term>
					<term>data parallel</term>
					<term>dynamic adaptation</term>
					<term>Dryad</term>
					<term>MapReduce</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Data processing frameworks such as MapReduce <ref type="bibr" target="#b7">[8]</ref> and Dryad [11]  are used today in business environments where customers expect guaranteed performance. To date, however, these systems are not capable of providing guarantees on job latency because scheduling policies are based on fairsharing, and operators seek high cluster use through statistical multiplexing and over-subscription. With Jockey, we provide latency SLOs for data parallel jobs written in SCOPE. Jockey precomputes statistics using a simulator that captures the job's complex internal dependencies, accurately and efficiently predicting the remaining run time at different resource allocations and in different stages of the job. Our control policy monitors a job's performance, and dynamically adjusts resource allocation in the shared cluster in order to maximize the job's economic utility while minimizing its impact on the rest of the cluster. In our experiments in Microsoft's production Cosmos clusters, Jockey meets the specified job latency SLOs and responds to changes in cluster conditions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Batch processing frameworks for data parallel clusters such as MapReduce <ref type="bibr" target="#b7">[8]</ref> and SCOPE <ref type="bibr" target="#b5">[6]</ref> on Dryad <ref type="bibr" target="#b10">[11]</ref> are see-Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. EuroSys <ref type="bibr">'12, April 10-13, 2012</ref>, Bern, Switzerland. Copyright © 2012 ACM 978-1-4503-1223-3/12/04. . . $10.00 ing increasing use in business environments as part of nearreal time production systems at Facebook <ref type="bibr" target="#b4">[5]</ref> and Microsoft. These frameworks now run recurring, business-critical jobs, and organizations require strict service-level objectives (SLOs) on latency, such as finishing in less than one hour. Missing a deadline often has significant consequences for the business (e.g., delays in updating website content), and can result in financial penalties to third parties. The outputs of many jobs feed into other data pipelines throughout the company; long job delays can thus affect other teams unable to fix the input jobs. Operators who monitor these critical jobs are alerted when they fall behind, and have to manually resolve problems by restarting jobs, or adjusting resource allocations. A framework which automatically provided latency SLOs would eliminate such manual repairs.</p><p>The ability to meet an SLO in data parallel frameworks is challenging for several reasons. First, unlike interactive web requests <ref type="bibr" target="#b22">[23]</ref>, data parallel jobs have complex internal structure with operations (e.g., map, reduce, join, etc.) which feed data from one to the other <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>. Barriers, such as aggregation operations, require the synchronization of all nodes before progress can continue. Failures, be they at task, server or network granularity, cause unpredictable variation, and particularly delay progress when they occur before a barrier.</p><p>Secondly, statistical multiplexing and over-subscription ensure high utilization of such clusters. This creates variability in response times due to work performed by other jobs. Finally, work-conserving allocation policies add variation by providing jobs with spare resources <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27]</ref>. Under these policies, each admitted job is guaranteed some task slots; slots that go unused are distributed to other jobs that have pending tasks. While this improves cluster efficiency, job latency varies with the availability of spare capacity in the cluster.</p><p>We provide latency guarantees for data parallel jobs in shared clusters with Jockey, which combines a detailed perjob resource model with a robust control policy. Given a pre-vious execution of the job<ref type="foot" target="#foot_0">1</ref> and a utility function, Jockey models the relationship between resource allocation and expected job utility. During job runtime, the control policy computes the progress of the job and estimates the resource allocation that maximizes job utility and minimizes cluster impact by considering the task dependency structure, individual task latencies, and failure probabilities and effects.</p><p>While the resource allocator in Jockey operates on individual jobs, we can use admission control to ensure that sufficient guaranteed capacity is available to all admitted SLO jobs. Jockey's job model can be used to check whether a newly submitted job would "fit" in the cluster -that is, that all previously accepted SLO jobs would still be able to meet their deadlines -before permitting it to run. If a submitted SLO job does not fit in the cluster, the cluster scheduler would need to arbitrate between the jobs to determine an allocation which maximizes the global utility at the risk of missing some SLO deadlines. We leave the development of such a global arbiter as future work.</p><p>Prior approaches to providing guaranteed performance fall into one of three classes. The first class partitions clusters into disjoint subsets and is used at companies such as Facebook <ref type="bibr" target="#b9">[10]</ref>. Jobs which require guaranteed performance are run in a dedicated cluster, and admission control prevents contention between jobs. This class achieves guarantees by sacrificing efficiency because the dedicated cluster must be mostly idle to meet SLOs. A second class of solutions shares the cluster, but provides priority access to SLO-bound jobstasks from such jobs run when ready and with optimal network placement. This shields SLO-bound jobs from variance due to other jobs. However, the impact on non-SLO jobs is significant: their partially complete tasks may have to vacate resources or lose locality when a higher-priority task arrives. In addition, this approach can only support a limited number of SLO-bound jobs to prevent negative interference between them. A final class of solutions, common across many domains, models the workload and selects a static resource allocation that ensures the deadline is met. We find that simple models for more general data parallel pipelines are imprecise, and dynamic adaptation is necessary to cope with runtime changes in the cluster and job structure.</p><p>Our core contribution is an approach that combines a detailed job model with dynamic control. Experiments on large-scale production clusters indicate that Jockey is remarkably effective at guaranteeing job latency -in 94 experiments it missed only a single deadline, by only 3% -and that neither the model nor control is effective without the other. Jockey is successful because it (a) minimizes the impact of SLO-bound jobs on the cluster while still providing guarantees, (b) pessimistically over-allocates resources at the start to compensate for potential future failures, and (c) can meet la-tency SLOs without requiring guaranteed performance from individual resources such as the cluster network and disks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Experiences from production clusters</head><p>To motivate our method for guaranteeing job latency in a production data-parallel cluster, we first describe the architecture of the cluster and the importance of latency SLOs. We then show that SLOs are difficult to meet due to high variance in job latency, and illustrate the causes of such variance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Cluster Background</head><p>To gain insight into the problem, we examine a single cluster in Cosmos, the data parallel clusters that back Bing and other Microsoft online properties. Example applications running on this cluster include generating web indices, processing end-user clickstreams, and determining advertising selections. Jobs are written in SCOPE <ref type="bibr" target="#b5">[6]</ref>, a mash-up language with both declarative and imperative elements similar to Pig <ref type="bibr" target="#b16">[17]</ref> or HIVE <ref type="bibr" target="#b21">[22]</ref>. A compiler translates the job into an execution plan graph wherein nodes represent stages such as map, reduce or join, and edges represent dataflow <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b11">12]</ref>. Each stage consists of one or more parallel tasks. For stages that are connected by an edge, communication between their tasks ranges from one-to-one to all-to-all. A barrier occurs when tasks in a dependent stage cannot begin until every task in the input stage finishes. Barriers are often due to operations that are neither associative nor commutative. Job data files reside in a distributed file system which is implemented using the same servers that run tasks, similar to Hadoop's HDFS or the Google File System <ref type="bibr" target="#b8">[9]</ref>. The cluster is shared across many business groups; at any time, there are many jobs running in the cluster and several tasks running on each server.</p><p>Similar to other cluster schedulers <ref type="bibr" target="#b26">[27]</ref>, our cluster employs a form of fair sharing across business groups and their jobs. Each job is guaranteed a number of tokens, as dictated by cluster policy, and each running task uses one token, which is released upon task completion. For efficiency, spare tokens are allocated to jobs that have pending tasks. Jobs are admitted to the cluster such that the total tokens guaranteed to admitted jobs remains bounded. While a token guarantees a task's share of CPU and memory, other resources such as network bandwidth and disk queue priority are left to their default sharing mechanisms, which are either per-flow or perrequest based.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">SLOs in Data Parallel Clusters</head><p>Setting an SLO deadline depends on a number of factors, most of which relate to the job's purpose. At a minimum, the deadline must be feasible: it cannot be shorter than the amount of time required to finish the job given an infinite amount of resources (i.e., the length of the critical path). Feasibility can be checked with trial job executions, or estimated using a simulator such as the one in Jockey (see <ref type="bibr">Section 4.1)</ref>.</p><p>Deadlines for some jobs are derived from contractual agreements with external (non-Microsoft) customers, such as advertisers or business partners, while others are set to ensure customer-facing online content is kept fresh and upto-date. In each case, missing a deadline can be financially detrimental to the business, either because of a contractuallyspecified penalty or the associated loss of revenue. Because final outputs are often the product of a pipeline of jobs, a deadline on the final output leads to individual deadlines for many different jobs running in Cosmos.</p><p>Finally, many internal deadlines are "soft" -that is, finishing after four hours instead of three is undesirable, but does not trigger a financial penalty. However, a single cluster runs a large number of concurrent jobs, some of which have no deadlines, some have soft deadlines, and some have very strict deadlines. With standard weighted fair sharing, it is difficult to map latency objectives for each of type of deadline onto an appropriate weight. Directly specifying a utility function to indicate a job's deadline and importance alleviates this problem for our users.</p><p>In our experiments (Section 5), we set the target deadline based on the length of the critical path, and for seven of the jobs, we test with two different deadlines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Variance in Job Latency</head><p>We quantify variance in the cluster by comparing completion times across runs of recurring jobs, such as the many production jobs which repeatedly execute on newly arrived data. By being mostly similar, recurring jobs provide a ready yet real source for cross-job comparison. The executions we examine consist of production-cluster jobs that repeated at least ten times each during September 2011.</p><p>Across the runs of each recurring job, we compute the completion time's coefficient of variation (CoV), i.e., std ev me an . Table <ref type="table" target="#tab_1">1</ref> shows that the median recurring job has a CoV of 0.28, and 10% of all jobs have a CoV over 0.59. While a CoV value less than 1 is considered to be low variance, these results imply that for half (or 10%) of recurring jobs the latency of a sixth of their runs is &gt; 28% (or &gt; 59%) larger than the mean.</p><p>We find that the size of the input data to be processed varies across runs of recurring jobs. To discount the impact of input size on job latency, we further group runs of the same job into clusters containing runs with input size differing by at most 10%. Table <ref type="table" target="#tab_1">1</ref> shows that much of the variation still persists even within these clusters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Causes of Variance</head><p>A potential cause of job latency variance is the use of spare tokens. Recall that our cluster re-allocates tokens which are unused by the jobs to which they were guaranteed. To explore this hypothesis, we compared runs of seven jobs described in Section 5.2 with experimental runs that were restricted to using guaranteed capacity only -the CoV dropped by up to five times. While these jobs are smaller than the median job in our cluster, and thus the specific decrease may not be representative, we believe it confirms our hypothesis that spare tokens add variance to job latency. The use of spare capacity creates variance in a job's run time for two reasons. First, the availability of spare tokens fluctuates because it depends on the nature of other jobs running in the cluster -if other jobs have more barriers or more outliers due to data skew, more tokens will be spare. In the above experiments, the fraction of the job's vertices that executed using the spare capacity varied between 5% and 80%. Second, tasks using spare tokens run at a lower priority than those using guaranteed tokens, and thus can be evicted or pushed into the background during periods of contention.</p><p>Task runtimes also vary due to hardware and software failures, and contention for network bandwidth and server resources. In public infrastructures, such as EC2 and Azure, such contention is even higher than in our cluster <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b24">25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Impact on Job Pipelines</head><p>Because many business processes consist of pipelines of multiple jobs, variance in the completion time of a single job can have a wide impact. To quantify this impact, we examined all jobs in our cluster over a period of three days. When a job's input contains data blocks written by an earlier job, we infer a dependence. We did not track dependences due to changes to the filesystem (e.g., copying or renaming blocks) and use of data outside the cluster (e.g., downloading a job's output to train a classifier which is then used by other jobs).</p><p>For the 10.2% of jobs with at least one dependency, which includes most SLO-bound jobs, Fig. <ref type="figure">1</ref> quantifies those dependences. The violet (solid) line shows that the median job's output is used by over ten other jobs -for the top 10% of jobs, there are over a hundred dependent jobs. The blue (small dashes) line shows that many directly dependent jobs start soon after the completion of a job -the median gap is ten minutes. This means that delays in the job will delay the start of these subsequent jobs. The green (dash-dot line) shows that the chains of dependent jobs can be quite long and span different business groups (red or big dash line). At business group or company boundaries, these delays can cause financial penalties and require manual intervention.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Lessons for Jockey</head><p>Jockey uses the number of guaranteed tokens as the mechanism to adjust a job's performance because it directly addresses one source of variance in our cluster. Because our tokens are analogous to tickets in a lottery scheduler or the weights in a weighted fair queuing regime, Jockey's methodology is directly applicable to other systems which use a weighted fair approach to resource allocation.</p><p>Jockey uses readily available prior executions to build a model of a recurring job's execution. Such a model is essential to translating resource allocation into expected completion time. We will show later how Jockey makes use of prior executions despite possible variations in input size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Solutions for Providing SLOs</head><p>We consider three solutions to our goal of providing SLOlike guarantees of job completion times in Cosmos. The first is to introduce an additional priority class in the cluster-wide scheduler, and map different SLOs onto each class. The second is to manually determine resource quotas for each job. Finally, we develop a novel method to dynamically adjust resources based on the job's current performance and historical data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Additional priority classes</head><p>The first potential solution is to implement a third class of tokens with a new, higher priority. Jobs with the strictest SLOs can be allocated and guaranteed these "SuperHigh" tokens. Through the combination of strict admission control, repeated job profiling to determine the necessary allocation, and a paucity of SuperHigh tokens at the cluster-scale, it is possible to meet SLOs with this design.</p><p>However, there are numerous downsides to this approach. When a job runs with SuperHigh tokens it increases contention for local resources. This has a negative impact on regular jobs, which can be slowed or potentially lose localitythe beneficial co-location of storage and computational resources. Secondly, the cluster scheduler must be overly pessimistic about the number of SuperHigh-priority jobs which can execute simultaneously. If too many such jobs are admitted to the cluster, the jobs will thrash and cluster goodput will fall. Finally, the heart of this solution is to introduce ordinal priority classes into the system, which are known to have weak expressive power and can lead to poor scheduling decisions when the system is overloaded <ref type="bibr" target="#b3">[4]</ref>. We did not further evaluate this solution because its use would impact actual SLO-bound jobs in our production cluster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Quotas for each job</head><p>A second potential solution for meeting SLO-bound jobs is to introduce strict, static quotas with the appropriate number of guaranteed tokens for each job. This solution is evaluated in Section 5.2 as Jockey w/o adaptation, and we find it to be unsatisfactory for three reasons. First, as cluster conditions change due to node failures and other events detailed later, the number of tokens required to meet the SLO also changes. Therefore, it would be necessary to regularly rebalance the quotas for all such SLO jobs.</p><p>Second, we have observed that determining weights and quotas is difficult for many users of large clusters. To reduce the chance of missing an SLO, some users request too many resources, which makes useful admission control challenging. Others request too few because they have relied on overly-optimistic trial runs, or a tenuous bounty of spare capacity tokens in the past. To explore the ability of users to correctly size their resource requests, we examined the guaranteed allocations and the maximum achieved parallelism of production jobs during a one-month period. We found that the maximum parallelism of one-third of the jobs was less than the guaranteed allocation. Futhermore, the maximum parallelism of one-quarter of the jobs reached more than ten times the guaranteed allocation thanks to the spare capacity.</p><p>Finally, it is clear that when multiple SLO-bound jobs exist in the system, the cluster's goodput can be improved by dynamically re-allocating resources from jobs with slack SLOs to those with tight SLOs. <ref type="foot" target="#foot_1">2</ref> This motivates the design of our solution, along with additional requirements described next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Dynamic resource management</head><p>In order to meet the desired SLOs in Cosmos, we developed a dynamic resource management system, Jockey, which we describe in detail in Section 4. Our design was guided by the limitations of the two solutions above, the variability of job performance described in Section 2.3, and the structure of SCOPE programs. We also faced additional constraints such as the need to adapt to changes in cluster availability, delays in job submission, and changes in the SLO after job initialization.</p><p>The variability of job performance implies that the scheduler needs to react to changing cluster conditions, periodically re-allocating resources at a fine timescale during job execution. We discuss the sensitivity of the scheduler to this timescale in Section 5.5. Because resource allocations are recalculated during the job's execution, it is necessary to have an accurate indicator of the job's current progress, in addition to a model of the job's end-to-end latency.</p><p>The DAG structure of jobs in Cosmos creates two challenges. A first is that Jockey must make decisions which respect dependencies between tasks. A second is the wide variation in a job's degree of parallelism during execution. Some stages may be split into hundreds of tasks, while others, such as an aggregation stage, are split into few tasks. The scheduler must allocate enough resources early in the job so that it does not attempt in vain to speed-up execution by increasing the resources for a later stage beyond the available parallelism. Jockey must also be aware of the probability and effect of failures at different stages in the job so there is an appropriate amount of time remaining to recover before the deadline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Jockey</head><p>Jockey is composed of three components: a job simulator, which is used offline to estimate the job completion time given the current job progress and token allocation, a job progress indicator, which is used at runtime to characterize the progress of the job, and a resource allocation control loop, which uses the job progress indicator and estimates of completion times from the simulator to allocate tokens such that the job's expected utility is maximized and its impact on the cluster is minimized (see the architecture diagram in Fig. <ref type="figure" target="#fig_0">2</ref>). We describe these components in more detail in the following three sections, and address limitations of our approach in Section 4.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Job Completion Time Prediction</head><p>In order to allocate the appropriate number of tokens to meet an SLO, Jockey must be able to predict the job's completion time under different token allocations given the current progress. This is challenging because the system has to consider all remaining work in the job and the dependencies between stages. We consider two methods for this prediction: an event-based simulator, and an analytical model inspired by Amdahl's Law. Based on our evaluation in Section 5.3, we use the simulator approach in the current version of Jockey.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Job simulator and the offline estimation</head><p>The job simulator produces an estimate of the job completion time given a particular allocation of resources and job progress. These estimates are based on one or more previous runs of the job, from which we extract performance statistics such as the per-stage distributions of task runtimes and initialization latencies, and the probabilities of single and multi-ple task failures. The job simulator takes as input these statistics, along with the job's algebra (list of stages, tasks and their dependencies), and simulates events in the execution of the job. Events include allocating tasks to machines, restarting failed tasks and scheduling tasks as their inputs become available. This simulator captures important features of the job's performance such as outliers (tasks with unusually high latency) and barriers (stages which start only when all tasks in dependent stages have finished), but does not simulate all aspects of the system, such as input size variation and the scheduling of duplicate tasks. We discuss the accuracy of the simulator in Section 5.3.</p><p>A basic implementation of the resource allocation control loop could invoke the simulator during each iteration by marking the completed tasks and simulating forward. Then, for each resource allocation under consideration, multiple simulations could be used to estimate the distribution of completion times and thus the expected utility given that allocation. However, depending on the number of allocations considered and the size of the job, these simulations could take a long time and add a significant delay to the control loop. Therefore, we develop a method that only uses the simulator offline, precomputing all information necessary to accurately and quickly allocate resources.</p><p>For each SLO job, we estimate C(p, a) -a random variable denoting the remaining time to complete the job when the job has made progress p and is allocated a tokens. In the control loop, we use these precomputed values to select an appropriate allocation. We present an approach to compute the job progress p in Section 4.2.</p><p>We estimate the distribution of C(p, a) by repeatedly simulating the job at different allocations. From each simulation, say at allocation a that finishes in time T, we compute for all discrete t ∈ [0, T] the progress of the job p t at time t and the remaining time to completion t c = Tt. Clearly, t c = C(p t , a), i.e., the value t c is one sample from the distribution of C(p t , a). Iterating over all t in a run and simulating the job many times with different values of a provides many more samples, allowing us to estimate the distribution well. Because the logic in the simulator is close to that of the real system, these estimates approximate real run times well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Amdahl's Law</head><p>Rather than using the simulator above, we can use a modified version of Amdahl's Law <ref type="bibr" target="#b0">[1]</ref> to estimate the job's completion time given a particular allocation. Amdahl's Law states that if the serial part of a program takes time S to execute on a single processor, and the parallel part takes time P, then running the program with N processors takes S + P/N time. In our case, we let S be the length of the critical path of the job and P be the aggregate CPU time spent executing the job, minus the time on the critical path. To estimate the remaining completion time of a job when allocated a tokens, we evaluate the above formula with N = a.</p><p>To use Amdahl's Law in our resource allocation loop, we need to estimate the total work remaining in the job, P t , and the length of the remaining critical path, S t , while the job is running. For each stage s, let f s be the fraction of tasks that finished in stage s, l s be the execution time of the longest task in stage s, L s be the longest path from stage s to the end of the job and T s be the total CPU time to execute all tasks in stage s. Note that the last three parameters can be estimated from prior runs before the job starts, and f s can easily be maintained by the job manager at run time. Now, S t = max stage s∶ fs &lt;1 (1f s )l s + L s and P t = ∑ stage s∶ fs &lt;1 (1f s )T s . In words, across stages with unfinished tasks f s &lt; 1, we estimate the total CPU time that remains to be P t and the longest critical path starting from any of those stages to be S t .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Job Progress Estimation</head><p>As introduced above, we use a progress indicator to capture the state of the job and to index into C(p, a), the remaining time distributions that were pre-computed from the simulator. The progress indicator should faithfully reflect the work that has happened and the work that remains. In particular, it should account for parallel stages whose tasks can finish in any order, tasks that differ widely in completion time, and stages that differ in their numbers of tasks. Furthermore, tasks sometimes fail, requiring previous output to be recomputed, and the indicator should reflect such events as well.</p><p>A job progress indicator can integrate several characteristics of a running job. Examples include the fraction of completed tasks in each stage, the aggregate CPU time spent executing, the relative time when a particular stage is started or completed, and the length of the remaining critical path. We built six progress indicators that use different subsets of these aspects. Here we describe the progress indicator that worked best in our experiments. See Section 5.4 for description and evaluation of the remaining indicators.</p><p>The totalworkWithQ indicator estimates job progress to be the total time that completed tasks spent enqueued or executing. Based on past run(s) of the job, we compute for each stage s, the total time tasks spend executing T s and enqueued Q s . At runtime, given f s , the fraction of tasks in stage s that are complete, the progress estimate is</p><formula xml:id="formula_0">∑ stage s f s (Q s + T s ).</formula><p>This indicator is simple. In particular, it assumes that tasks in the same stage have similar queuing and running times and ignores potentially useful information such as the intra-task progress, dependencies between future stages, barriers, and the length of remaining critical path. However, our goal is to design an indicator that is an effective index into the C(p, a) distributions computed in Section 4.1. Our experience (see Sections 5.2 and 5.4) shows that this indicator performs better in Jockey than more complex indicators across a wide range of conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Resource Allocation Control Loop</head><p>The goal of the resource allocation control loop is to implement a policy which maximizes the job's utility and mini-mizes its impact on the cluster by adjusting the job's resource allocation. There are four inputs to the control loop: 1. f s , the fraction of completed tasks in stage s 2. t r , the time the job has spent running 3. U(t), the utility of the job completing at time t. A typical utility function used in our environment would be nearly flat until the job deadline, drop to zero some time after the deadline and, in some cases, keep dropping well below zero to penalize late finishes.</p><p>4. Either the precomputed C(p, a) distributions, Q s and T s , for each stage s (when using the simulator-based approach), or the precomputed l s , L s , and T s for each stage s (when using the Amdahl's Law-based approach).</p><p>The policy's output is the resource allocation for the job.</p><p>The basic policy logic periodically observes the job's progress and adapts the allocated resources to ensure it finishes with high utility. First, it computes the progress p using a job progress indicator. Next, the expected utility from allocating a tokens is computed as follows: given progress p and the time the job has been running t r , the expected utility is U a = U(t r + C(p, a)). Finally, the minimum allocation that maximizes utility is</p><formula xml:id="formula_1">A r = arg min a {a ∶ U a = max b U b }.</formula><p>Inaccuracies in predicting job latencies and the nondeterministic performance of the cluster can cause the raw allocation A r to under-or over-provision resources, or oscillate with changes. To moderate these scenarios, Jockey integrates three standard control-theory mechanisms:</p><p>1. Slack: To compensate for inaccuracy in the job latency estimate (by the simulator or Amdahl's Law), we multiply the predictions from C(p, a) by a constant factor S. For example, with slack S = 1.2, we would add an additional 20% to the predictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Hysteresis:</head><p>To smooth oscillations in the raw allocation, we use hysteresis parametrized by α. In particular, we adapt A s t -the smoothed allocation at time t -as follows:</p><formula xml:id="formula_2">A s t = A s t-1 + α(A r -A s t-1</formula><p>). Whereas a value of α = 1 implies that the allocation immediately jumps to the desired value, for α ∈ (0, 1) the gap between the allocation and the desired value reduces exponentially with time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Dead zone:</head><p>To dampen noise in the job progress indicator, we add a dead zone of length D, i.e., shift the utility function leftwards by D and change allocations only if the job is at least D behind schedule. For example, with D = 3 minutes, a deadline of 60 minutes is treated as a deadline of 57 minutes, and the policy won't act unless the job is at least 3 minutes delayed.</p><p>Our results in Section 5 show the need for dynamic adaptation. We also report on the incremental contributions due to each of the above techniques. In Section 5.5 we perform a sensitivity analysis of parameter choices, and find that the slack, hysteresis, and dead zone parameters have wide operat-ing regimes. Values for these parameters can be set in advance with the aid of Jockey's simulator: slack can be set based on simulator's margin of error when compared with actual job executions, values for hysteresis and dead zone can be determined experimentally with a simulated control loop. While the simulator does not perfectly reproduce the actual dynamics of the cluster and jobs, it provides guidance when adjusting these settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Limitations and Future Work</head><p>As described here, Jockey makes local decisions to ensure each job finishes within the SLO while using as few resources as necessary. We plan to extend Jockey to reach globally optimal allocations when managing multiple SLO-bound jobs. Doing so requires an additional inter-job arbiter that dynamically shifts resources from jobs with low expected marginal utility to those with high expected marginal utility.</p><p>At this time, Jockey is only capable of meeting SLOs for jobs it has seen before. We consider this a reasonable limitation since most of the business-critical jobs are recurring. For non-recurring jobs, a single profile run is enough to generate accurate job completion estimates, as demonstrated in Section 5.2. Extending Jockey to support novel jobs, either through sampling or other methods, is left for future work.</p><p>Jockey is agnostic to small changes in the input size of the job and in the execution plans. Large changes to either are visible to Jockey and can be treated as new jobs; i.e., train new completion time distributions based on the changed runs. In practice, we build Jockey's offline distributions using the largest observed input because Jockey automatically adapts the allocation based on the actual resource needs during the lifetime of the job.</p><p>We acknowledge that Jockey cannot recover from serious failures or degenerate user code. For example, if running the job on the entire cluster would not meet the SLO, Jockey is of little use. However, such cases are rare, and for common failures Jockey can meet deadlines by running the job at appropriately higher parallelism. In either case, Jockey will attempt to meet the SLO by continuously increasing the amount of resources guaranteed to the job until the model indicates that the deadline will be met, the job completes, or a hard limit is reached.</p><p>A few enhancements to the current design are also under consideration. Additional input signals to the control loop, such as the size of the input data, progress within running tasks, and cluster-wide performance metrics, could improve adaptivity. Additional control knobs such as the aggressiveness of mitigating stragglers <ref type="bibr" target="#b1">[2]</ref>, the OS priority of tasks, and the bandwidth shares of network transfers, could broaden what Jockey can do to meet SLOs. Finally, rather than use progress indicators, efficient ways to integrate the simulator with the online phase, perhaps as a less frequent control loop, could provide more precise control over job progress.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Evaluation</head><p>In this section, we first evaluate the ability of Jockey to meet job latency SLOs in various scenarios: different deadlines, changes in cluster conditions, and changes in deadlines during job runtime. Then, we evaluate Jockey's three components: the latency prediction, the progress indicators, and the sensitivity of the control loop to changes in its parameters in Sections 5.3, 5.4, and 5.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Methodology</head><p>We evaluate Jockey on 21 production jobs; these were all the recurring jobs of a business group in Microsoft that were neither too short to use in our evaluation, nor too big for the guaranteed cluster slice available to our experiments. We use a single production run of these jobs as input to the simulator (Section 4.1) to pre-compute the completion time distribution (C(p, a)) and other statistics (l s , L s , T s , and Q s ). Experimental runs were performed using a modified job manager that implements progress indicators and adapts allocations dynamically (Sections 4.2 and 4.3). We perform more detailed analysis for a subset of these jobs; their characteristics are in Table <ref type="table" target="#tab_2">2</ref> and stage dependency structure is illustrated in Fig. <ref type="figure" target="#fig_1">3</ref>.</p><p>The analysis and experiments were performed on a largescale cluster running production workloads with an average utilization of 80% and a number of compute nodes in the high thousands. Each node is a commodity, multi-core machine with tens of GBs of RAM. There are approximately 40 machines per rack, connected by a network oversubscribed by a small factor.</p><p>For most jobs, we evaluate Jockey's ability to meet a deadline of 60 minutes. For the detailed subset, we used two different deadlines -the longer always twice the shorter. A deadline of d minutes translates to a piecewise-linear utility function going through these points: (0, 1), (d, 1), (d + 10, -1), (d + 1000, -1000). This means that the utility drops significantly after the deadline. We ran at least three experiments for each combination of job, deadline and policy. In total, we report results from more than 800 experiments.</p><p>Our evaluation metrics are as follows: 1) did the job complete before the specified deadline?, 2) how much earlier or later did the job finish compared to the deadline?, and 3) what was the impact on the rest of the cluster for jobs that met the deadline? We measure the job's impact using the notion of oracle allocation. For a deadline of d minutes and a job that requires aggregate CPU time of T minutes, the oracle allocation is O(T, d) = ⌈T/d⌉ tokens. This is the minimum allocation required in theory to finish the job in d minutes. This estimate is optimistic since it assumes the total work is known in advance, and the job can continuously run at a parallelism of O(T, d) (that is, it is agnostic to the job's structure). However, it is a good baseline for comparing different resource allocation approaches. The job's impact on the cluster is measured as the fraction of job allocation requested by the policy that  is above the oracle allocation. See Fig. <ref type="figure">6</ref> for examples of the oracle allocation.</p><p>In our experiments, we re-run the resource allocation control loop (Section 4.3) each minute and use the totalwork-WithQ progress indicator. We use a slack of 1.2 to accommodate the inaccuracy of job latency prediction, hysteresis parameter of 0.2 to smooth the requested resource allocation, and a dead zone of 3 minutes. We discuss Jockey's sensitivity to these values in Section 5.5, and compare progress indicators in Section 5.4.</p><p>We compare Jockey -based on predictions from the job simulator and adapting allocations at runtime -with three other policies. Jockey w/o adaptation uses the job simulator to find an a priori resource allocation that maximizes job utility, but does not adapt allocations during job runtime. Jockey w/o simulator does adapt but uses the simpler Amdahl's Lawbased model of the job. Finally, we compare against the max allocation policy which guarantees all the resources available (in these experiments, 100 tokens) to finish the SLObound job as quickly as possible.</p><p>While the max allocation policy is able to meet all of the SLO deadlines, as shown below, it is not a practical policy to use. Because it guarantees all allocated resources to each job, it is not possible to run more than one job at a time using the max allocation policy. Because the maximum parallelism of Dryad jobs varies, running one job at a time would create "valleys" before the barrier stages, during which the resources would be underutilized (indeed, this problem would be worse for those jobs which cannot make use of all allocated resources at any point). Filling those valleys with additional jobs naturally requires a dynamic allocation policy, as we develop with Jockey.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">SLO-based Resource Allocation</head><p>Fig. <ref type="figure" target="#fig_2">4</ref> summarizes our experiments; there are more than 80 runs per policy. The x-axis shows the fraction of job allocation above the oracle allocation; the y-axis shows the fraction of experiments that missed deadlines. In both cases, lower values are better. Jockey misses the deadline in one experiment (see below for an explanation), and has a low impact on the rest of the cluster. Jockey w/o adaptation has a slightly higher impact on the cluster, but misses many more deadlines because of its inability to adapt to cluster changes. Jockey w/o simulator, which uses Amdahl's Law to estimate job completion times, achieves the lowest impact on the cluster, but misses many deadlines. This is because the simple analytic model of the job leads to imprecise predictions of the com-  pletion time. Finally, the max allocation policy meets every deadline by significantly over-provisioning the job -potentially starving other jobs in the cluster. Further, when multiple SLO-bound jobs must run simultaneously, this policy provides no benefits. Fig. <ref type="figure" target="#fig_3">5</ref> presents the experimental results in more detail. The x-axis on the graph represents the job completion time relative to the specified deadline; values below 100% represent experiments that met the SLO, values above 100% (right of the dashed black line) are experiments that did not. Notice that jobs using the max allocation policy finish significantly before the deadline -the median such job finishes approximately 70% early -which translates to a large impact on the rest of the cluster; jobs under the other three policies finish much closer to the deadline. Finally, notice that using dynamic resource allocation in Jockey (solid line) further reduces the variance in latency compared to Jockey w/o adaptation (dotted line), which uses a fixed allocation of tokens.</p><p>On the right in Fig. <ref type="figure" target="#fig_3">5</ref>, we see that while both Jockey w/o simulator and Jockey w/o adaptation miss the same fraction of deadlines, the late jobs using Jockey w/o simulator finish much earlier post-deadline. The median late job of Jockey w/o simulator finishes only 1% late, while the median late job of Jockey w/o adaptation finishes 10% late. This shows that even though Amdahl's Law provides less accurate latency predictions than the simulator, dynamic allocation causes jobs to finish close to the deadline. See Fig. <ref type="figure">6</ref> for detailed examples of experiments using our simulation-based policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adapting to changes in cluster conditions</head><p>Because Jockey is dynamic, it is robust to inaccurate latency predictions and can respond to changes in cluster conditions. For example, a fixed allocation calculated using a model of job performance (such as a simulator), can be too low to meet the deadline, as demonstrated above. In our experiments, the Jockey w/o adaptation policy misses the SLO deadline in 18% of experiments, even though this policy uses the same slack factor of 1.2 as our dynamic policy experiments.</p><p>One reason such off-line predictions are inaccurate is that cluster conditions change. Because access is shared and other jobs run concurrently, use of network and CPU resources varies over time. Further detail from the experiment in which Jockey misses the SLO illustrates these variations.</p><p>(a) job F, 45-minute deadline: as described in the text, the actual job took twice as much time to execute due to an overloaded cluster. Our policy realized the slower progress and started adding resource early. In the end, the job finished only 3% late.</p><p>(b) job E, 45-minute deadline: policy started adding resources after it noticed a particular stage was taking longer to complete.</p><p>(c) job G, 60-minute deadline: policy over-provisioned the job at the beginning and released resources as the deadline approached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6.</head><p>Three examples of dynamic resource allocation policy experiments. The blue line is the raw allocation based on the job's utility and current progress, the black line is the allocation set by the policy, the red line is the number of vertices running, and the green line is the oracle allocation. We compare the training execution that was used to compute the completion distributions, C(p, a), with two actual runs of the same job when controlled by Jockey. In Table <ref type="table" target="#tab_4">3</ref>, job 1 is the run that missed the deadline, whereas job 2 met the deadline. Fig. <ref type="figure">6</ref>(a) plots the timelapse of how Jockey adapted during job 1. Notice that the total amount of work required to finish both jobs is higher than their training runs, with job 1 needing almost twice the total work. The median and 90 th percentile of vertex queueing and execution latencies are also higher. In spite of this, Jockey added enough resources to finish job 2 on time. From Fig. <ref type="figure">6</ref>(a), we see that Jockey noticed job 1 to be slower and added resources (blue line on top), missing the deadline by only 90 seconds. Figures <ref type="figure">6(b)</ref> and<ref type="figure">(c)</ref> show other types of adaptations. In the former, Jockey identifies a stage taking more time than usual and increases the allocation. In the latter, the job finishes faster than usual, and Jockey frees resources to be used by other jobs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adapting to changes in deadlines</head><p>An important feature of dynamic resource allocation is that it can adapt to changing job deadlines by adding more resources to meet a stricter deadline, or vice versa. This is crucial when multiple SLO-bound jobs must be run since we might need to slow a job to ensure a more important job finishes on time. While arbitrating among multiple SLO-bound jobs is not Jockey's focus, we view changes in deadlines as a mechanism to ensure the on-time completion of individual jobs as used by a future multi-job scheduler. The success of a such a scheduler thus depends on Jockey's ability to successfully adapt to changing deadlines. Finally, although extending a deadline does not any change in resources in order to meet the new, longer deadline, by decreasing the amount of guaranteed resources, Jockey can make more guaranteed resources available for future SLO-bound jobs.</p><p>For each of the seven jobs, we performed three separate experiments in which, ten minutes after start of the job, we cut the deadline in half, doubled the deadline or tripled the deadline, respectively. In each run, Jockey met the new deadline. In the runs where we lowered the deadline by half, the policy had to increase resource allocation by 148% on average. In the runs where we doubled or tripled the deadline, the policy released 63% or 83% (respectively) of the allocated resources on average. See two example runs in Fig. <ref type="figure" target="#fig_5">7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Job Latency Prediction Accuracy</head><p>While our policy can adapt to small errors in latency estimates, larger errors can lead to significant over-provisioning or under-provisioning of resources. To evaluate the accuracy of the end-to-end latency predictions made by the simulator and Amdahl's Law, we executed each of the seven jobs three times at eight different allocations. We initialized the variables for both our predictors, the simulator and modified Amdahl's Law, based on jobs at one allocation and estimated their accuracy at predicting latency for other allocations. In practice, we care about the worst-case completion time, so we   compare the largest prediction from either predictor to the slowest run at each allocation. Across jobs and allocations, the average errors of the simulator and Amdahl's Law were 9.8% and 11.8%, respectively; see details in Fig. <ref type="figure" target="#fig_6">8</ref>. Amdahl's Law has high error at low allocations, but performs much better at higher allocations, where the job's runtime is closer to the length of the critical path.</p><p>While the average error of Amdahl's Law is only slightly higher than the simulator's, Jockey w/o simulator missed 16% of the deadlines. The explanation of most of these SLO violations is that the policy using Amdahl's Law initially allocated too few tokens and was unable to catch-up during job run time. Also, the job simulator captures the variance of the endto-end job latency due to outliers and failures, and therefore creates a safety buffer to make sure SLOs can be met despite this variance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Job Progress Indicators</head><p>When dynamically allocating resources to a job, having an accurate prediction of end-to-end job latency is not enough; the control policy also needs an accurate estimate of job's progress in order to index into the remaining time distributions. Jockey uses totalworkWithQ, which uses the total queueing and execution time of completed vertices, to estimate job progress (Section 4.2).</p><p>Here, we describe a few other progress indicators we considered: totalwork computes progress as the fraction of the total execution time of completed vertices; vertexfrac uses the total fraction of vertices that completed; cp uses the fraction of the job's remaining critical path; the minstage and minstage-inf indicators use the typical start and end times of the individual stages relative to the job. If t b s and t e s are the relative start and end times of stage s, minstage infers these values from the previous run of the job while minstage-inf uses a simulation of the job with no constraint on resources and hence focusses on the critical path. Both estimate job progress as the stage furthest from when it typically completes, i.e., min stage s∶ fs &lt;1 {t b s + f s (t e st b s )}, where s is the fraction of vertices completed in stage s.</p><p>To evaluate these indicators, we measure how accurately they predict the end-to-end job latency during the runtime of a job. When Jockey calls the control loop at time t after the start of the job, the progress indicator estimates progress to be p t , which is indexed into the remaining time distribution and a completion time estimate is calculated as T t = t + C(p t , a). We compare the T t obtained from different indicators with the actual time at which the job finishes.</p><p>The values of the progress indicator (normalized to range from 0 to 100) and the estimated completion times T t for two of the progress indicators are shown in Fig. <ref type="figure" target="#fig_7">9</ref>. An undesirable characteristic of a progress indicator is getting stuck (ie., reporting constant values) even when the job is making progress. We see that the CP indicator is stuck from t=20min to t=40min causing T t to increase during this period. Such behavior confuses the control policy into assuming that the job is not making progress and increases the job's resource allocation even though the job may finish on time with the existing allocation. An ideal indicator would generate T t = D when enough resources are available, where D is the job duration, for all times t; the more T t diverges from D, the more the control policy has to unnecessarily adjust the resource allocation of the job.</p><p>We compare these indicators using two metrics; the longest constant interval, i.e., the longest period, relative to the duration of the job, when the progress indicator was constant and the average △T, which measures the oscillations in the T t estimates and is computed as the average of |T t -T t+1 | relative to the duration of the job. The larger the value of either metric, the greater opportunity for needless oscillations in allocations. See the comparison in Table <ref type="table" target="#tab_1">10</ref>.</p><p>The totalworkWithQ indicator, which incorporates the duration and queueing time of vertices in each stage, performs best. The minstage, minstage-inf and CP indicators, which consider the structure of the job, perform significantly worse because their progress estimates are based on the stage which has made the least progress, and do not reflect progress   in other stages. TotalworkWithQ considers progress in all running stages, and thus increments more smoothly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Sensitivity Analysis</head><p>To evaluate the control loop's sensitivity, we adjusted its parameters and ran each of the seven jobs three times with a single deadline after each adjustment. The baseline here is Jockey with default parameter values. The results are summarized in Fig. <ref type="figure">11</ref>. Running our policy with no hysteresis and no dead zone, results in meeting only 57% of the SLOs, while using the hysteresis with no dead zone, meets 90% of the SLOs. Using hysteresis is clearly crucial; without it, the allocation fluctuates too much in each direction. When it drops too much because of this oscillation, Jockey cannot catch-up later. We tried running with no slack, but instead use an increased value of the hysteresis parameter to let Jockey adapt more quickly when jobs fall behind. Here, on average, Jockey allocated too few tokens at the start of the job and missed 24% of the deadlines. Next, changing the period at which adaptation happens from one to five minutes still met 95% of the deadlines. But, for jobs that were over-provisioned, Jockey did not quickly reduce the allocation, resulting in jobs finishing 22% before the deadlines (compared to 14% in our baseline). We also ran Jockey using the minstage and CP indicators, which met 100% and 95% of the deadlines (respectively), and had a similar impact on the cluster as the baseline. As shown in Section 5.4, these indicators have some undesirable properties as inputs to a control loop, but these experiments suggest that with hysteresis, they can still perform well in practice.</p><p>Results for different slack values are presented in Fig. <ref type="figure" target="#fig_8">12</ref>, based on 21 runs for each value. The only SLO violations occurred in experiments without slack; adding even 10% slack was enough to meet the SLOs. Adding more slack led to jobs finishing well before the deadline and having a larger impact on the rest of the cluster because it directly causes overallocation of resources. This can be seen in the increasing initial and median job allocations as slack is increased.</p><p>Results for different values of the hysteresis parameter are presented in Fig. <ref type="figure" target="#fig_9">13</ref>. For each value of the parameter and each of the seven jobs, we ran three experiments. Only three experiments did not meet the SLO; two at the lower extreme value -0.05, high smoothing -and one at the upper extreme -1.0, no smoothing. Overall, experiments with higher values of the hysteresis parameter finished closer to the deadline and had slightly less impact on the rest of the cluster, but the maximum allocation requested by the policy was much higher than with greater smoothing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Summary</head><p>Our evaluation on a large-scale production cluster shows that Jockey can reliably meet job latency SLOs; in 94 experiments that ran Jockey missed one deadline by 3% due to much higher load on the cluster at that time. Without the simulator, or without dynamic resource adaptation, Jockey performed significantly worse. While the max-allocation policy met all SLOs, Jockey had 3× less impact on the rest of the cluster, which allows more SLO-bound jobs to be run simultaneously. We also demonstrated that Jockey can dynamically adapt to changing job deadlines, which allows us to trade resources between multiple jobs based on their utilities. Jockey's success chiefly derives from an accurate model of the job, one that captures the remaining execution time as a function of resource allocation and job progress. However, when the model is not 100% accurate, standard techniques from control theory (such as hysteresis and adding slack) can partially compensate for the inaccuracy. We show in our sensitivity analysis that, without these techniques, Jockey's approach performs much worse.</p><p>Nonetheless, in certain cases, the job execution can significantly diverge from the model and the control loop could either overprovision the job (taking resources from other jobs) or underprovision it (allocating too few resources and missing the SLO). This could happen if the inputs of the job change substantially -resulting in a more expensive execution -or if the whole cluster is experiencing performance issues, such as an overloaded network. In these cases, we could quickly update the model by running the simulator at runtime, or simply fall back on weighted fair-sharing once the control loop detects large errors in model predictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>Job scheduling and resource management are not new problems, and there has been much related work in these areas. Jockey builds upon recent work on performance indicators and improvements in MapReduce-like clusters, as well as previous work in grid computing and real-time systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Performance in data parallel clusters</head><p>Jockey is most closely related to the Automatic Resource Inference and Allocation for MapReduce Environments project (ARIA), which also proposes a method to allocate resources in a large-scale computational framework for meeting soft deadlines <ref type="bibr" target="#b23">[24]</ref>. Both the ARIA work and our own feature a control loop which estimates the job's progress, uses past execution profiles to predict the completion time, and adjusts the resources assigned to the task to meet the target deadline.</p><p>However, Jockey differs from ARIA in several important ways. First, the ARIA project was developed for map-reduce frameworks which feature only three computational phases: a Map phase, a Shuffle phase, and a Reduce phase; the framework used here supports directed acyclic graphs (DAGs) of arbitrarily long pipelines of independent and dependent stages. Second, the ARIA authors develop analytic equations which estimate each stage's completion time, similar to the Amdahl's Law-based approach we consider. But, as noted above, we found simulations to be more accurate for predicting future progress in DAGs because they incorporate the effects of vertex outliers, failures and barriers. Third, the approach described here is robust to changes in the cluster conditions or the deadlines or the amount of job's input. Our experiments show that slack, hysteresis and a dead zone are necessary for meeting SLOs in a production setting. Finally, the experiments here are more realistic. They are performed on a large shared production cluster with all the allied noise and a wide variety of bottlenecks. ARIA used a dedicated cluster of 66 nodes without any network bottleneck. Hence, we believe Jockey is a better match for production DAG-like frameworks such as Hive <ref type="bibr" target="#b21">[22]</ref>, Pig <ref type="bibr" target="#b16">[17]</ref>, and Ciel <ref type="bibr" target="#b15">[16]</ref> To predict the completion time of a running job, Jockey must estimate the job's current progress. Our approach is informed by the ParaTimer progress indicator <ref type="bibr" target="#b14">[15]</ref>, which is most similar to the vertexfrac function which we first consider. As discussed above, the vertexfrac design was not the best method for Jockey because it incorrectly indicates a lack of progress during long-running stages with a low degree of parallelism, and because it can be overly optimistic about failures and data skew <ref type="bibr" target="#b14">[15]</ref>. When developing Jockey, we found it to be more effective to slow a job running ahead of deadline due to prior pessimism about failures, rather than attempt to speed-up a job which is running behind.</p><p>As a side-effect of predictably meeting SLOs, Jockey decreases the variance in job completion latencies. This goal is shared with work on reducing such variance directly, such as Mantri <ref type="bibr" target="#b1">[2]</ref> and Scarlett <ref type="bibr" target="#b2">[3]</ref>. The approach taken by Jockey, to automatically adjust resource allocations in response to predicted fluctuations in latency, is complementary to this earlier work. While we have not yet studied the effect of combining these approaches, we believe that such a combination will further improve Jockey's ability to meet SLOs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Deadlines in grid and HPC workloads</head><p>The Amdahl's Law-like approach described in Section 4.1 is inspired by the value-maximizing, deadline-aware scheduler for animation rendering tasks by Anderson et al. <ref type="bibr" target="#b3">[4]</ref>, which they term the disconnected staged scheduling problem (DSSP). The approach developed estimates the amount of resources required to complete the task using two quantities: the aggregate CPU time (the time to complete the job on a single processor), and the length of the critical path (the time to complete the job on an infinite number of processors).</p><p>Finally, Sandholm and Lai have explored the relationship between a job's weight in a fair-sharing scheduler and the chance of meeting a given deadline in both grid-computing environments <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref> and MapReduce-like contexts <ref type="bibr" target="#b20">[21]</ref>. Jockey automatically makes these weight decisions based on the utility curve submitted by the user, whereas Sandholm and Lai's methods price the system's resources based on aggregate demand and permit users to allocate resources based on their own budgets and deadlines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Deadlines in real-time workloads</head><p>Previous work on real-time systems has advocated dynamic resource management to perform admission control <ref type="bibr" target="#b25">[26]</ref>, meet deadlines <ref type="bibr" target="#b17">[18]</ref> and maximize aggregate utility <ref type="bibr" target="#b13">[14]</ref>, as Jockey does for data parallel clusters. Jockey differs by operating at a significantly larger scale, managing larger computational jobs with longer deadlines, and adjusting the resource allocation during a job's execution, rather than only between repeated executions of the same job. Jockey also uses a simulator to estimate a distribution of job completion times for a given allocation of resources, rather than rely upon an analytic model of the critical path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>In today's frameworks, providing guaranteed performance for pipelines of data parallel jobs is not possible on shared clusters. Jockey bridges this divide. To do so, it must combat varying availability and responsiveness of resources, two problems which are compounded by the dependency structure of data parallel jobs. By combining detailed job models with robust dynamic adaptation, Jockey guarantees job latencies without over-provisioning resources. Such "right-sizing" of allocations lets Jockey successfully run SLO-bound jobsit met 99% of the SLOs in our experiments -in a cluster simultaneously running many other jobs -Jockey only needed 25% more resources than the theoretical minimum.</p><p>When a shared environment is underloaded, guaranteed performance brings predictability to the user experience;</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Architecture diagram: in the offline phase, we use a profile of a previous run to estimate job statistics and use the simulator to estimate completion times. During runtime, the control loop monitors the job and uses job statistics, latency predictions and the utility function to propose the minimum resource allocation that maximizes the utility of the job.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Stage dependencies of seven jobs used in evaluation. Each node represents a stage in a job; blue, triangular nodes are stages with full shuffle. Sizes of the nodes are proportional to the number of vertices in the stage, and edges represent stage dependencies (top to bottom). In this visualization, a typical MapReduce job would be represented by a black circle connected to a blue triangle.</figDesc><graphic coords="8,450.00,211.00,55.00,73.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Comparison of average allocation above the oracle allocation and fraction of missed deadlines for each policy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Left, CDFs of job completion times relative to the specified deadline for different policies. Right, detail of the upper-right corner.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>(a) Deadline changed from 140 to 70 minutes. The policy adjusted the resource allocation (black line) to meet the new deadline. (b) Deadline increased from 20 to 60 minutes. The policy released more than 90% of the resources and still met the new deadline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Examples of two experiments with changing deadlines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Average simulator and Amdahl's Law prediction error. The xaxis indicates allocations at which the job's latency was predicted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. The totalworkWithQ (left) and CP (right) progress indicators for job G. The solid lines (left axes) show the estimated worst-case job completion times Tt, the dashed lines (right axes) correspond to the values of the progress indicator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12.Sensitivity of the slack parameter. Top, the fraction of jobs that met the SLO and the fraction of job allocation above the oracle allocation. Bottom, average of first, last and median allocations during each experiment, and average of total machine hours allocated by the policy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 .</head><label>13</label><figDesc>Figure<ref type="bibr" target="#b12">13</ref>. Sensitivity of the hysteresis parameter. Top, fraction of jobs that met the SLO, fraction of allocations above the oracle, and job latencies relative to deadlines. Bottom, average of median, max and last allocations during each run, and average of total machine hours Jockey allocated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>CoV across runs with inputs differing by at most 10%</head><label></label><figDesc></figDesc><table><row><cell>Statistic</cell><cell cols="4">Percentiles 10th 50th 90th 99th</cell></row><row><cell>CoV across recurring jobs</cell><cell>.15</cell><cell>.28</cell><cell>.59</cell><cell>1.55</cell></row><row><cell></cell><cell>.13</cell><cell>.20</cell><cell>.37</cell><cell>.85</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>The coefficient of variation (CoV) of completion time across runs of recurring jobs. Variation persists across runs with similar input sizes.</figDesc><table><row><cell>100%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>80%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>60%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>40%</cell><cell></cell><cell></cell><cell cols="3">gap between dependent jobs [minutes]</cell></row><row><cell>20%</cell><cell></cell><cell></cell><cell cols="3">length of dependent job chains # jobs indirectly using output of this job</cell></row><row><cell>0%</cell><cell></cell><cell></cell><cell cols="2"># groups that depend on a job</cell><cell></cell></row><row><cell>0.1</cell><cell>1</cell><cell>10</cell><cell>100</cell><cell>1000</cell><cell>10000</cell></row><row><cell cols="6">Figure 1. Dependence between jobs: 20% of jobs have more than 20 other</cell></row><row><cell cols="6">jobs depending on their output. Over half of the directly dependent jobs start</cell></row><row><cell cols="6">within 10 minutes of the earlier job and are hence likely to stall if the earlier</cell></row><row><cell cols="6">job is delayed. Long chains of dependent jobs are common, and many chains</cell></row><row><cell cols="2">span business groups.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Statistics of seven jobs used in evaluation.</figDesc><table><row><cell>stat</cell><cell>A</cell><cell>B</cell><cell>C</cell><cell>D</cell><cell>E</cell><cell>F</cell><cell>G</cell></row><row><cell>vertex runtime median [sec]</cell><cell>16.3</cell><cell>4.0</cell><cell>2.6</cell><cell>6.1</cell><cell>8.0</cell><cell>3.6</cell><cell>3.0</cell></row><row><cell>vertex runtime 90 th percentile [sec]</cell><cell>61.5</cell><cell>54.1</cell><cell>5.7</cell><cell>25.1</cell><cell cols="2">130.0 17.4</cell><cell>7.7</cell></row><row><cell>vertex runtime 90 th percentile [sec] (fastest stage)</cell><cell>4.0</cell><cell>3.3</cell><cell>1.7</cell><cell>1.4</cell><cell>3.9</cell><cell>3.3</cell><cell>1.6</cell></row><row><cell cols="5">vertex runtime 90 th percentile [sec] (slowest stage) 126.3 116.7 21.9 72.6</cell><cell cols="3">320.6 110.4 68.3</cell></row><row><cell>total data read [GB]</cell><cell cols="7">222.5 114.3 151.1 268.7 195.7 285.6 155.3</cell></row><row><cell>number of stages</cell><cell>23</cell><cell>14</cell><cell>16</cell><cell>24</cell><cell>11</cell><cell>26</cell><cell>110</cell></row><row><cell>number of barrier stages</cell><cell>6</cell><cell>0</cell><cell>3</cell><cell>3</cell><cell>1</cell><cell>1</cell><cell>15</cell></row><row><cell>number of vertices</cell><cell>681</cell><cell cols="4">1605 5751 3897 2033</cell><cell>6139</cell><cell>8496</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 .</head><label>3</label><figDesc>For job F, comparing the metrics of the training job used to create the C(p, a) distributions in the simulator with two actual runs, jobs 1 and 2. Both the runs require more work; job 1 needs almost twice as much work to complete. Jockey notices the slow-down and allocates extra resources at runtime to finish job 2 on time and job 1 finishes only 90s late.</figDesc><table><row><cell>statistic</cell><cell cols="3">training job 1 job 2</cell></row><row><cell>total work [hours]</cell><cell>12.7</cell><cell>23.5</cell><cell>18.5</cell></row><row><cell>queueing median [sec]</cell><cell>5.8</cell><cell>6.8</cell><cell>6.9</cell></row><row><cell>queueing 90 th perc. [sec]</cell><cell>8.4</cell><cell>11.6</cell><cell>11.4</cell></row><row><cell>latency median [sec]</cell><cell>3.6</cell><cell>5.8</cell><cell>5.2</cell></row><row><cell>latency 90 th perc. [sec]</cell><cell>17.4</cell><cell>36.6</cell><cell>27.1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Comparison of progress indicators.</figDesc><table><row><cell>indicator</cell><cell cols="3">△T longest constant interval</cell></row><row><cell cols="2">totalworkWithQ 2.0%</cell><cell></cell><cell>8.5%</cell></row><row><cell>totalwork</cell><cell>2.3%</cell><cell></cell><cell>9.3%</cell></row><row><cell>vertexfrac</cell><cell>2.2%</cell><cell></cell><cell>10.1%</cell></row><row><cell>CP</cell><cell>3.0%</cell><cell></cell><cell>15.2%</cell></row><row><cell>minstage</cell><cell>3.3%</cell><cell></cell><cell>19.9%</cell></row><row><cell>minstage-inf</cell><cell>3.9%</cell><cell></cell><cell>26.7%</cell></row><row><cell>40% 60% 80% 100% Figure 10. 20%</cell><cell cols="3">latency relative to deadline fraction met SLA fraction above oracle allocation</cell></row><row><cell>1</cell><cell>1 . 2</cell><cell>1 . 4 slack</cell><cell>1 . 6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Results of sensitivity analysis. The baseline results are a subset of results reported in Section 5.2.</figDesc><table><row><cell>experiment</cell><cell>met SLA</cell><cell>latency vs. deadline</cell><cell>allocation above oracle</cell><cell>median allocation</cell></row><row><cell>baseline</cell><cell>95%</cell><cell>-14%</cell><cell>35%</cell><cell>52.9</cell></row><row><cell>no hysteresis, no deadzone</cell><cell>57%</cell><cell>-2%</cell><cell>25%</cell><cell>49.7</cell></row><row><cell>no deadzone</cell><cell>90%</cell><cell>-9%</cell><cell>30%</cell><cell>50.3</cell></row><row><cell>no slack, less hysteresis</cell><cell>76%</cell><cell>-5%</cell><cell>27%</cell><cell>44.9</cell></row><row><cell>5-min period</cell><cell>95%</cell><cell>-22%</cell><cell>35%</cell><cell>45.7</cell></row><row><cell>minstage progress</cell><cell>100%</cell><cell>-16%</cell><cell>34%</cell><cell>48.2</cell></row><row><cell>CP progress</cell><cell>95%</cell><cell>-16%</cell><cell>31%</cell><cell>44.9</cell></row><row><cell>Figure 11.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Recurring jobs, which include most SLO-bound jobs, account for over 40% of runs in our cluster, providing ready historical data for our models.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>A few Cosmos users even tried to do this by hand in the past!</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors wish to thank Sameer Agarwal, Jonathan Perry, Moises Goldszmidt, and our shepherd Karsten Schwan for helpful comments and advice during the development of this project and while preparing our paper, as well as the many members of the Cosmos development team, particularly Jay Finger, Astha Gupta, Solom Heddaya, Pat Helland, Bikas Saha, Shoaib Sehgal, and Jingren Zhou.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>when it is overloaded, utility-based resource allocation ensures jobs are completed according to importance. Jockey brings these benefits to data parallel processing in large-scale shared clusters.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Validity of the single processor approach to achieving large scale computing capabilities</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Amdahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AFIPS &apos;67 (Spring)</title>
		<meeting>AFIPS &apos;67 (Spring)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1967">1967</date>
			<biblScope unit="page" from="483" to="485" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Reining in the Outliers in Map-Reduce Clusters using Mantri</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ananthanarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Harris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI &apos;10</title>
		<meeting>OSDI &apos;10<address><addrLine>Vancouver, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Coping with Skewed Content Popularity in MapReduce Clusters</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ananthanarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><surname>Scarlett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroSys &apos;11</title>
		<meeting>EuroSys &apos;11<address><addrLine>Salzburg, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Value-maximizing deadline scheduling and its application to animation rendering</title>
		<author>
			<persName><forename type="first">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Salazar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Santos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Swaminathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wiener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPAA &apos;05</title>
		<meeting>SPAA &apos;05<address><addrLine>Las Vegas, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Apache Hadoop goes Realtime at Facebook</title>
		<author>
			<persName><forename type="first">D</forename><surname>Borthakur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Muthukkaruppan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Spiegelberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Molkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD &apos;11</title>
		<meeting>SIGMOD &apos;11<address><addrLine>Athens, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">SCOPE: Easy and Efficient Parallel Processing of Massive Data Sets</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chaiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jenkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shakib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1265" to="1276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">FlumeJava: Easy, efficient data-parallel pipelines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raniwala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bradshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Weizenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PLDI &apos;10</title>
		<meeting>PLDI &apos;10<address><addrLine>Toronto, Ontario, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">MapReduce: Simplified data processing on large clusters</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="107" to="113" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Google file system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-T</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="43" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">No One (Cluster) Size Fits All: Automatic Cluster Sizing for Data-intensive Analytics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Herodotou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SoCC &apos;11</title>
		<meeting>SoCC &apos;11<address><addrLine>Cascais, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dryad: Distributed Data-parallel Programs from Sequential Building Blocks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fetterly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroSys &apos;07</title>
		<meeting>EuroSys &apos;07<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Quincy: Fair Scheduling for Distributed Computing Clusters</title>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Currey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Wieder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Talwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP &apos;09</title>
		<meeting>SOSP &apos;09<address><addrLine>Big Sky, Montana, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">CloudCmp: Comparing public cloud providers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IMC &apos;10</title>
		<meeting>IMC &apos;10<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Online optimization for latency assignment in distributed real-time systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lumezanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Astley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDCS &apos;08</title>
		<meeting>ICDCS &apos;08</meeting>
		<imprint>
			<date type="published" when="2008-06">June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">ParaTimer: a progress indicator for MapReduce DAGs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Morton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Balazinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD &apos;10</title>
		<meeting>SIGMOD &apos;10<address><addrLine>Indianapolis, IN, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">CIEL: a universal execution engine for distributed data-flow computing</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schwarzkopf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Smowton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Madhavapeddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI&apos;11</title>
		<meeting>NSDI&apos;11<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Pig latin: a not-so-foreign language for data processing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tomkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD &apos;08</title>
		<meeting>SIGMOD &apos;08<address><addrLine>Vancouver, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Adaptive resource management in asynchronous real-time distributed systems using feedback control functions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ravindran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kachroo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hegazy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 5th Symposium on Autonomous Decentralized Systems</title>
		<meeting>of 5th Symposium on Autonomous Decentralized Systems</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Prediction-based enforcement of performance contracts</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sandholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GECON&apos;07</title>
		<meeting>GECON&apos;07<address><addrLine>Rennes, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A statistical approach to risk mitigation in computational markets</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sandholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HPDC &apos;07</title>
		<meeting>HPDC &apos;07<address><addrLine>Monterey, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">MapReduce optimization using regulated dynamic prioritization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sandholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMETRICS &apos;09</title>
		<meeting>SIGMETRICS &apos;09<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Hive: a warehousing solution over a map-reduce framework</title>
		<author>
			<persName><forename type="first">A</forename><surname>Thusoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Anthony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wyckoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Murthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2009-08">August 2009</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1626" to="1629" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Dynamic provisioning of multi-tier internet applications</title>
		<author>
			<persName><forename type="first">B</forename><surname>Urgaonkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shenoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Goyal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICAC &apos;05</title>
		<meeting>ICAC &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">SLO-Driven Right-Sizing and Resource Provisioning of MapReduce Jobs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cherkasova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LADIS &apos;11</title>
		<meeting>LADIS &apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The Impact of Virtualization on Network Performance of Amazon EC2 Data Center</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE IN-FOCOM &apos;10</title>
		<meeting>IEEE IN-FOCOM &apos;10</meeting>
		<imprint>
			<date type="published" when="2010-03">March 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Utilization-Based Admission Control for Real-Time Applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Xuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bettati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICPP &apos;10</title>
		<meeting>ICPP &apos;10<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Delay Scheduling: A Simple Technique for Achieving Locality and Fairness in Cluster Scheduling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Borthakur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Elmeleegy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroSys &apos;10</title>
		<meeting>EuroSys &apos;10<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
