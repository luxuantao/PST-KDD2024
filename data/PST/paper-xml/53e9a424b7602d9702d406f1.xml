<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Secure Information Flow and Pointer Confinement in a Java-like Language</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Anindya</forename><surname>Banerjee</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Naumann</surname></persName>
							<email>naumann@cs.stevens-tech.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computing and Information Sciences</orgName>
								<orgName type="institution">Kansas State University</orgName>
								<address>
									<postCode>66506</postCode>
									<settlement>Manhattan</settlement>
									<region>KS</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution">Stevens Institute of Technology</orgName>
								<address>
									<postCode>07030</postCode>
									<settlement>Hoboken</settlement>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Secure Information Flow and Pointer Confinement in a Java-like Language</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7F2819250A225FBCF62294C301061BD6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider a sequential object-oriented language with pointers and mutable state, private fields and classbased visibility, dynamic binding and inheritance, recursive classes, casts and type tests, and recursive methods. Programs are annotated with security levels, constrained by security typing rules. A noninterference theorem shows how the rules ensure pointer confinement and secure information flow.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>There are many channels by which sensitive information can be leaked. This paper is concerned with information flows that arise in sequential object-oriented programs due to control flow, data flow, and dynamic memory allocation. Inspired by Denning's work <ref type="bibr" target="#b11">[10,</ref><ref type="bibr" target="#b12">11]</ref>, Volpano, Smith and Irvine devised an elegant, syntax-directed type system for annotating program variables, commands, and procedure parameters with security levels <ref type="bibr" target="#b35">[34,</ref><ref type="bibr" target="#b33">32]</ref>. Goguen and Meseguer <ref type="bibr" target="#b14">[13]</ref> introduced noninterference, expressed in terms of suitable simulation relations, to formalize information flow policies. Volpano and Smith proved that their type system ensures noninterference <ref type="bibr" target="#b35">[34,</ref><ref type="bibr" target="#b33">32]</ref>.</p><p>Subsequently, several researchers have given similar analyses for possibilistic and probabilistic noninterference for multi-threaded programs <ref type="bibr" target="#b29">[28,</ref><ref type="bibr" target="#b34">33,</ref><ref type="bibr" target="#b26">25,</ref><ref type="bibr" target="#b20">19,</ref><ref type="bibr" target="#b28">27]</ref>. <ref type="bibr">Barthe</ref> and Serpette prove noninterference for a purely functional instance-based object calculus <ref type="bibr" target="#b5">[4]</ref>. For sequential programs, Abadi et al. <ref type="bibr">[1]</ref>, Sabelfeld and Sands <ref type="bibr" target="#b27">[26]</ref> and Heintze and Riecke <ref type="bibr" target="#b16">[15]</ref> consider higher order procedures. They also make explicit the connections between the relational formulation of noninterference and other dependency analyses such as slicing and binding time analysis <ref type="bibr">[1,</ref><ref type="bibr" target="#b5">4]</ref>, building noninterference properties into the semantics in the manner of Reynolds' relationally parametric models <ref type="bibr" target="#b25">[24]</ref>. However, it is difficult to extend such models in a tractable way to encompass language features such as recursive types and shared mutable objects which are extensively used in languages such as Java <ref type="bibr" target="#b3">[2]</ref>.</p><p>Our contribution is to deal with dynamic memory allocation and object-oriented constructs: we prove noninterference for a sequential object-oriented language with pointers and mutable state, private fields and class-based visibility, dynamic binding and inheritance, casts and type tests, and mutually recursive classes and methods. The security type system extends that of Volpano and Smith <ref type="bibr" target="#b33">[32]</ref> to encompass data flow via mutable object fields and control flow in dynamically dispatched method calls.</p><p>Myers <ref type="bibr" target="#b21">[20]</ref> gave a security typing system for a fragment of Java even richer than ours, but left open the problem of justifying the rules with a noninterference result. This is hardly surprising, as the rules are quite complicated. Some of the complications are inherent in the complexity of the language; others are introduced with the aim of accomodating dynamic access control and sophisticated security policies including declassification <ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b21">20,</ref><ref type="bibr" target="#b36">35]</ref>.</p><p>In the present paper, we confine attention to the problem of proving noninterference for a "realistic" sequential language (not far from JavaCard <ref type="bibr" target="#b8">[7]</ref>), using conventional annotations without declassification or dynamic access control. Our results are given in elementary terms. We eschew the elegant structures used in <ref type="bibr" target="#b16">[15,</ref><ref type="bibr">1,</ref><ref type="bibr" target="#b27">26]</ref>, but we can give detailed proofs in the space of a few pages. This may also help in extending our results to other language features.</p><p>We use the weak form of noninterference which does not consider termination to be observable. Strong noninterference is treated by Volpano and Smith <ref type="bibr" target="#b33">[32]</ref> (and others), but for a sequential language this requires loop guards to have low security. We omit loops but include recursion which also admits nontermination. Thus to extend their ideas to our language we would require low security guards for conditionals that involve recursive calls, a complication we choose to avoid here. The extension of strong noninterference to recursive procedures merits study in a simple setting before it is combined with the features of an objectoriented language.</p><p>Our work grew out of a study of data abstraction for Java <ref type="bibr" target="#b4">[3]</ref>. We found that a straightforward compositional semantics is adequate even in the presence of recursive types and dynamically bound method calls (which are typically viewed as being akin to higher order procedures). The semantics is simple enough to extend easily to additional constructs, e.g., access control is included in <ref type="bibr" target="#b4">[3]</ref>.</p><p>Due to pointer aliasing, the language is not relationally parametric per se. But suitable confinement of pointers suffices to yield a strong representation-independence result for user-defined abstractions <ref type="bibr" target="#b4">[3]</ref>. The term "confinement" appears to originate in the literature on operating system security, but its use is natural in object-oriented programming where pointer confinement has been proposed for encapsulation at the level of modules, classes, or instances <ref type="bibr" target="#b17">[16,</ref><ref type="bibr" target="#b9">8,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b6">5,</ref><ref type="bibr" target="#b32">31]</ref>. For information flow, we impose a confinement condition on high-security pointers.</p><p>The following section is a detailed overview of the paper. Section 3 formalizes the language and its semantics. Section 4 gives the security typing system. Section 5 deals with confinement, which is then used in Section 6 to prove the noninterference theorem. Section 7 considers related work and prospects for further advance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview</head><p>We consider a language that is quite complicated relative to those for which noninterference results have been proved before, but we use simple security annotations that generalize those of Volpano and Smith. We annotate local variables, fields, and method parameters using types (T, κ) where T is an ordinary program type and κ is one of the two security levels H and L. Generalization to a lattice of levels would complicate notations without adding illumination. We also annotate classes. The security level of a class is the security level of this, i.e., the target of a method call, and it is also used for confinement as described in the sequel.</p><p>In the following example there is a single field f of high security (level H), in a class named C of level L.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>class C L extends D {</head><p>(bool,H) f;</p><p>(bool,H) m ((bool,L) x) L { if (x) this.f := not x; else this.f := x; return (x == this.f); } } Our typing system assigns to method m the type x:(bool,L) L -→(bool,H). This designates a method which takes a parameter of level L, has effect L on the heap, and returns a value of level H. The heap effect L is given in the method declaration, following the parameter list ((bool,L) x).</p><p>The type of the result expression (x == this.f) is (bool,H) because the type of this.f is (bool,H). Although both this and x are L, field f is is declared H.</p><p>In typing judgements, Volpano and Smith use a type H cmd for commands that assign only to H variables. Our typing judgements use a command type (com κ 1 , κ 2 ) for commands that assign only to variables of level at least κ 1 and to object fields of level at least κ 2 . That is, the heap effect designated by a command type is concerned with field levels. The same is true of the heap effect designated above the arrow in a method type like x:(bool,L) L -→(bool,H). If we modify the example to declare a heap effect H for the method, resulting in a type x:(bool,L) H -→(bool,H), the class is still typable because the only effect is on a field of level H.</p><p>Consider the following variation.</p><formula xml:id="formula_0">class C H extends D { (bool,??) f; (bool,H) m ((bool,L) x) L { if (x) this.f := not x else this.f := x; return (x == this.f); } }</formula><p>The type of m is again x:(bool,L) L -→(bool,H) but the class is H. What level, marked ??, can be used for field f? The conditional statement needs to be typable in context x:(bool,L),this:(C,H) because the label on a class designates the level of this. The conditional should be given type (com ?,L), as the heap effect for the method is L. What about the effect, marked ?, on the local environment (i.e., local variables and parameters)? Our rule for field update requires that the level of the field be at least the level of the assigned variable: as this is H, field f needs to be declared as H and then the conditional can be typed as (com H,L).</p><p>Subclassing in Java is "invariant" in the sense that method signatures cannot be specialized in subclasses. Although other alternatives merit study, our typing system is the same: the declared security levels of a method cannot be changed in subclasses. However, we allow the subclass of an L class to be declared H. This has interesting consequences and it is one of the reasons why we need a semantic notion of pointer confinement, called L-confinement, as discussed later.</p><p>These examples are far from an exhaustive illustration of the interesting patterns that arise. Nor can a brief exposition give a thorough justification for the rules. A few more examples appear in Section 4.1. Although our type system is quite general, it disallows some sensible programs such as those involving declassification. On the other hand, it admits some declarations that are sound but not very useful, such as variables of type (C,L) for H-class C.</p><p>In Section 3 we give the formal syntax and denotational semantics of the underlying language for which we consider security annotations. Java is sufficiently complicated that it is a challenge to formalize its syntax in a readable way. We adapt the formalization of a smaller fragment of Java, FJ <ref type="bibr" target="#b18">[17]</ref>, which mixes standard notations from type theory with Java-like syntax. We extend FJ by adding imperative features, and modify it by treating fields as private (class-visible) rather than public. The semantics is defined in terms of an ordinary typing system; it does not depend on security annotations.</p><p>In Section 4 we give the typing system for security annotations. In practice, one would want to specify security policy by labelling certain inputs and outputs, leaving the rest to automated inference, but that is beyond the scope of the paper, as is label polymorphism. For expository purposes, it is convenient to use separate subsumption and subtyping rules that express, for example, that an L expression can always be used in a context where an H expression is allowed. But for proofs it is more convenient to use syntax-directed rules that incorporate subsumption. For lack of space we give only the syntax-directed rules for our system, at the cost that the rules have rather many constraints on security levels. Readers unfamiliar with this style of specifying a flow analysis are encouraged to read Volpano and Smith's clear and succinct presentation <ref type="bibr" target="#b33">[32]</ref>.</p><p>Our main result, in Section 6, is a noninterference theorem: For a program with annotations satisfying the rules, fields, variables, and method results with label L do not depend on those with label H. As in work cited in the introduction, noninterference is formalized in terms of an equivalence relation on states. Here a state consists of an environment η and a heap h. For two states (η, h) and (η , h ) to be equivalent, written (η, h) ∼ (η , h ), means that they agree on L-variables and on L-fields of heap objects. The noninterference theorem says that if a typable program is executed in the two related states (η, h) and (η , h ), the outcomes are also related. What this means is that changes to high security inputs cannot be observed at low outputs.</p><p>The main noninterference result pertains to the methods of a complete program consisting of a collection of classes that can involve mutually recursive fields and methods. The semantics of such a program is given as a fixpoint and the main result is proved by induction. This proof depends on a main lemma saying that commands are noninterferingsafe, for short-under the assumption that the methods they call are safe. Safety depends on confinement. Section 5 is concerned with confinement. In <ref type="bibr" target="#b33">[32]</ref>, noninterference is proved on the basis of two lemmas called simple security and confinement. Simple security corresponds roughly to our L-confinement and safety Lemmas 5.1 and 6.1 for expressions. These results say that an L-expression cannot distinguish between related states. Confinement in <ref type="bibr" target="#b33">[32]</ref> corresponds to what we call H-confinement, which pertains to H-commands: such commands do not assign to L-variables or fields. Noninterference for conditionals depends on H-confinement: A conditional with H-guard can behave differently in equivalent states, so the statement parts must be restricted to be H-commands.</p><p>To deal with the heap, we use a property called Lconfinement. The language includes subclassing and subsumption, and we allow an L-class to have an H-subclass. As a result, simple typing does not prevent certain H to L flows. Moreover, an L-object can be aliased by both an Land an H-variable. Hence, we must show that a typable Lexpression never denotes an H-pointer and that commands preserve the invariant that L-variables and L-fields contain no H-pointers.</p><p>Besides controlling direct information flows, Lconfinement is also needed to treat dynamic memory allocation and the equivalence ∼ for heaps. An environment maps variable identifiers to values, whereas a heap maps locations to values. One need only define η ∼ η for η and η with the same domain. In a simple imperative language, an Hcommand can distinguish between ∼-related states but the distinction appears in terms of the states of variables (and termination). In a language with heap allocation, there is also the possibility of differing allocations. Thus it is unreasonable for h ∼ h to require identical domains. But allocation must depend on the domain of the heap, to ensure freshness. If h ∼ h allows different domains then an L-command could potentially distinguish by observing the behavior of the allocator.</p><p>In a language with pointer arithmetic, comparison using &lt; is a real problem. In Java, pointers are abstract: they can be compared only by =. Although two related heaps could result in different allocations, one can argue that no information is leaked to L-commands because they cannot make useful distinctions between pointer values. One could formalize this idea by requiring that, for the L part of related heaps, the domains need not be equal but rather there should be a bijection between them so that corresponding objects are related. From related states, allocation of a new L-object would add a pair to the bijection. Although this approach appears viable, we have avoided it for two reasons. First, the added complication would pervade all definitions and results. We prefer to follow the lead of Volpano and Smith in using simple standard semantic notions to the extent possible. Second, although it is easy to see how to maintain the bijection in a small step semantics, it is not as simple in a compositional semantics. Some other possibilities for relating heaps are in <ref type="bibr" target="#b30">[29,</ref><ref type="bibr" target="#b31">30]</ref>, though we have not pursued these ideas.</p><p>Our approach depends on the allocator satisfying a mild parametricity condition which is also needed for the abstraction theorem of <ref type="bibr" target="#b4">[3]</ref>. The condition says that the choice of a fresh location for an object of class C depends only on currently-allocated C objects. Capability-based systems provide similar abstractions. The benefit here is that the definition of h ∼ h can simply require that h and h have the same domain for L-objects. We have not imposed a condition that the heaps are garbage-free. Garbage in the initial state has no influence on the final state. One might have thought that we would need to garbage-collect in order for the final states to be related, but this is not necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Language: syntax and semantics</head><p>This section presents the language without security annotations; it is this language for which the semantics is defined. The language is the same as the core language in <ref type="bibr" target="#b4">[3]</ref>, from which we have also borrowed expository material. To make the paper more self-contained, we give complete typing rules and semantic definitions. For further explanation and justification of the definitions, the reader is advised to consult <ref type="bibr" target="#b4">[3]</ref>.</p><p>The grammar is based on given sets of class names (with typical element C), field names (f ), method names (m), and variable/parameter names x (including this). Barred identifiers like T indicate finite lists, e.g., T f stands for a list f of field names with corresponding types T . Without formalizing it precisely, we assume there is a class Object with no fields or methods which can be used as a superclass. Additional base types, such as integers, can be treated in the same way as bool and unit. Table <ref type="table">1</ref> gives the typing rules. A typing environment Γ is a finite function from variable names to types. A judgement of the form Γ; C e : T says that e has type T in the context of a method of class C, with parameters and local variables declared by Γ. A judgement Γ; C S : com says that S is a command in the same context. To simplify the typing rules and semantic definitions, we assume that variable and parameter names are not re-used.</p><p>A complete program is given as a class table CT that associates each declared class name with its declaration. The typing rules make use of auxiliary notions that are defined in terms of CT , so the typing relation depends on CT but this is elided in the notation. Because typing of each class is done in the context of the full table, methods can be mutually recursive, and so can field types.</p><p>Methods and classes are considered public. The rules for field access and update enforce visibility: fields of a class are accessible only to methods of that class, as in Java's private visibility.</p><p>Subsumption is built in to the rules using the subtyping relation ≤ on T specified as follows. For base types, bool ≤ bool and unit ≤ unit. For classes C and D,</p><formula xml:id="formula_1">we have C ≤ D iff either C = D or the class declaration for C is class C extends B { . . . } for some B ≤ D.</formula><p>To define some auxiliary notations, let A class table is well formed if each of its method declarations is well formed according to the following rule. Turning to semantics, the state of a method in execution is comprised of a heap h, which is a finite partial function from locations to object states, and an environment η, which assigns locations and primitive values to local variables and parameters. Every environment of interest includes the distinguished variable this which points to the target object. A command denotes a function from initial state to either a final state or the error value ⊥.</p><formula xml:id="formula_2">CT (C) = class C extends D { T 1 f ; M }</formula><p>For locations, we assume that a countable set Loc is given, along with a distinguished entity nil not in Loc. We treat object states as mappings from field names to values. To track the object's class we assume given a function loctype : Loc → ClassNames such that for each C there are infinitely many locations with loctype = C. We write locs C for { | loctype = C}. The assumption about loctype ensures an adequate supply of fresh locations, given that the domain of any heap is finite. Table <ref type="table">1</ref>. Typing rules for expressions and commands.</p><formula xml:id="formula_3">[[bool]] = {true, false} [[unit]] = {•} [[C]] = {nil} ∪ { | ∈ Loc ∧ loctype ≤ C} η ∈ [[Γ]] ⇔ dom η = dom Γ ∧ ∀x ∈ dom η . η x ∈ [[Γ x]] s ∈ [[C state]] ⇔ dom s = fields C ∧ ∀f ∈ fields C . sf ∈ [[type(f, C)]] h ∈ [[Heap]] ⇔ dom h ⊆ fin Loc ∧ ∀ ∈ dom h . h ∈ [[(loctype ) state]] [[C, (x : T ) → T ]] = [[x : T , this : C]] → [[Heap]] → ([[T ]] × [[Heap]]) ⊥ [[MEnv ]] ⊆ (C : ClassNames) (m : MethodNames) [[C, mtype(m, C)]]</formula><p>Table <ref type="table">2</ref>. Semantic domains.</p><p>Methods are associated with classes, in a method environment, rather than with instances. For this reason the semantic domains, given in Table <ref type="table">2</ref>, are rather simple. There are no recursive domain equations to be solved. The semantics is defined for an arbitrary allocator, but the noninterference theorem depends on parametricity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Allocator, parametric)</head><p>An allocator is a location-valued function fresh such that loctype(fresh(C, h)) = C and fresh(C, h) ∈ dom h, for all C, h. An allocator is</p><formula xml:id="formula_4">parametric if dom h 1 ∩ locs C = dom h 2 ∩ locs C implies fresh(C, h 1 ) = fresh(C, h 2 ). 2 For example, if Loc = N the function fresh(C, h) = min{ | loctype = C ∧ ∈ dom h} is parametric.</formula><p>It is straightforward to show that, as in Java, no program constructs create dangling pointers, but it is slightly simpler to formulate the definitions to allow dangling pointers. Like cast failures, dereferences of dangling pointers and nil are considered an error. We identify all errors, and divergence, with the improper value ⊥.</p><p>The semantics is defined by induction on typing judgements, and for all typings for e and S we have</p><formula xml:id="formula_5">[[Γ; C e : T ]] ∈ [[MEnv ]] → [[Γ]] → [[Heap]] → [[T ]] ⊥ [[Γ; C S : com]] ∈ [[MEnv ]] → [[Γ]] → [[Heap]] → ([[Γ]] × [[Heap]]) ⊥</formula><p>To streamline the treatment of ⊥ in the semantic definitions, we use a metalanguage construct, let d = E 1 in E 2 , with the following meaning: If the value of E 1 is ⊥ then that is the value of the entire let expression; otherwise, its value is the value of E 2 with d bound to the value of E 1 . This construct is only exploited in the semantic definitions; later, in definitions of properties, we handle ⊥ explicitly.</p><p>Function update is written, e.g.,</p><formula xml:id="formula_6">[η | x → d].</formula><p>In the semantics of local variables, we write for domain restriction: if x is in the domain of function η then η x is the function like η but without x in its domain.</p><p>Table <ref type="table">3</ref> gives the semantics of expressions and Table <ref type="table">4</ref> gives the semantics of commands. The definitions are straightforward renderings of the operational semantics <ref type="bibr" target="#b3">[2]</ref>. For example, the value of e.f in state (η, h) is ⊥ if the value of e is ⊥ or is not in dom h; otherwise, the value of e is some location ∈ dom h, so the object state h is a finite map with f ∈ dom (h ) and the value of e.f is h f . Field update x.f := e in state (η, h) does not change the environment; the new heap For method call as an expression, e.m(e), the value is ⊥ unless the value of e is some ∈ dom h. In that case, let d be the method meaning given by µ for method m at the dynamic type (loctype ) of e. The result of the call is obtained by applying d to the initial heap h and to the environment [x → d, this → ] where d is the list of values of arguments e. The result, if not ⊥, is a pair (d 0 , h 0 ); for method call as expression, the value of e.m(e) is d 0 . Note that h 0 is discarded; for expository simplicity we do not model side effects of expressions (see Section 7 for a discussion). For method call as command, d 0 is discarded and the new state is η, h 0 , as the call has no effect on the environment η of the caller.</p><formula xml:id="formula_7">[h | → [h | f → d]]</formula><p>The semantics of a class table is the method environment, μ, given as the least upper bound of the ascending</p><formula xml:id="formula_8">[[Γ; C x : T ]]µηh = ηx [[Γ; C null : B]]µηh = nil [[Γ; C unit : unit]]µηh = • [[Γ; C e 1 ==e 2 : bool]]µηh = let d 1 = [[Γ; C e 1 : T ]]µηh in let d 2 = [[Γ; C e 2 : T ]]µηh in (d 1 = d 2 ) [[Γ; C e.f : T ]]µηh = let = [[Γ; C e : C]]µηh in if ∈ dom h then ⊥ else h f [[Γ; C e.m(e) : T ]]µηh = let = [[Γ; C e : D]]µηh in if ∈ dom h then ⊥ else let (x : T ) → T = mtype(m, D) in let d = µ(loctype )m in let d = [[Γ; C e : U ]]µηh in let (d 0 , h 0 ) = d[x → d, this → ]h in d 0 [[Γ; C (B) e : B]]µηh = let = [[Γ; C e : D]]µηh in if ∈ dom h ∧ loctype ≤ B then else ⊥ [[Γ; C e instanceof B : bool]]µηh = let = [[Γ; C e : D]]µηh in ∈ dom h ∧ loctype ≤ B Table 3. Semantics of expressions. chain µ ∈ N → [[MEnv ]</formula><p>] defined as follows. </p><formula xml:id="formula_9">µ 0 C m = λη. λh. ⊥ µ j+1 C m = [[M ]]µ j if m is declared as M in C µ j+1 C m = µ j+1 B m if m is inherited from B in C [[M ]]µηh = let (η 0 , h 0 ) =</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Security typing</head><p>In this section we annotate the syntax of Section 3 with security labels. Where a type T could occur, i.e., in declarations of fields, parameters, and local variables, we use pairs (T, κ) where κ is a security level. Such a pair, written τ , is called a security type. The security levels are L and H, ordered L ≤ H. We write κ 1 κ 2 to denote least upper  <ref type="table" target="#tab_0">5</ref> and<ref type="table">6</ref> give typing rules for annotated programs. We write ∆ for typing environments that assign security types. A judgement ∆; C S : (com κ 1 , κ 2 ) says that S assigns only to variables (locals and parameters) of level ≥ κ 1 and to object fields of level ≥ κ 2 (see <ref type="bibr">Lemma 5.4)</ref>.</p><formula xml:id="formula_10">[[Γ; C x := e : com]]µηh = let d = [[Γ; C e : T ]]µηh in ([η | x → d], h) [[Γ; C x.f := e : com]]µηh = let = ηx in if ∈ dom h then ⊥ else let d = [[Γ; C e : U ]]µηh in (η, [h | → [h | f → d]]) [[Γ; C x := new B( ) : com]]µηh = let = fresh(B, h) in ([η | x → ], [h | → [fields B → defaults]]) [[Γ; C e.m(e) : com]]µηh = let = [[Γ; C e : D]]µηh in if ∈ dom h then ⊥ else let (x : T ) → T = mtype(m, D) in let d = µ(loctype )m in let d = [[Γ; C e : U ]]µηh in let (d 0 , h 0 ) = d[x → d, this → ]h in (η, h 0 ) [[Γ; C S 1 ; S 2 : com]]µηh = let (η 0 , h 0 ) = [[Γ; C S 1 : com]]µηh in [[Γ; C S 2 : com]]µη 0 h 0 [[Γ; C if e S 1 else S 2 : com]]µηh = let b = [[Γ; C e : bool]]µηh in if b then [[Γ; C S 1 : com]]µηh else [[Γ; C S 2 : com]]µηh</formula><p>In Section 2 we noted that security typing can be presented more perspicuously using separate subtyping and subsumption rules. For example, our rule for x := e in Table 6 could give the command the type (com κ 1 , H), rather than including the unconstrained κ 4 and the constraint κ 3 ≤ κ 1 , as there is no heap effect and the most precise environment information is κ 1 . Even for a syntax-directed system, it may be possible to avoid subsumptions for primitive commands, given those built into rules for command constructs like sequencing. But care needs to be taken because levels in a method declaration cannot be changed in overriding declarations, and primitive commands can occur as method bodies. We err on the side of generality.</p><p>The rules use versions of the auxiliary functions mtype etc. that take security levels into account. Let</p><formula xml:id="formula_11">CT (C) = class C κ 1 extends D { τ 1 f ; M }</formula><p>and let M be in the list M of method declarations, with</p><formula xml:id="formula_12">M = τ 1 m(τ 2 x) κ 2 {S; return e}</formula><p>The security version of mtype is defined by smtype(m, C) = (x : τ 2 ) κ2 -→ τ 1 . Corresponding to dfields, fields and type, we define sdfields, sfields and stype which differ only in that they give security types, e.g., sdfields C = τ 1 f . We also need a function level that gives the level associated with the class itself: for the declaration above, level C = κ 1 . Define level Object = L. For locations, define level = level(loctype ).</p><p>The rule for method declaration imposes the condition that an overriding definition cannot change the parameter or return types, nor the heap effect. The rule for class declaration restricts inheritance of methods. This is discussed in Section 4.1 below.</p><p>We use the symbol † to erase annotations: (T, κ) † = T , and this extends to erasure for typing environments, commands, and method declarations in the obvious way. For example, if M is the method declaration (bool, L) m((bool, L) x) L {x := x; return x} then M † is bool m(bool x) {x := x; return x}.</p><p>For any judgement ∆; C S : (com κ 1 , κ 2 ) derivable using the rules in Tables <ref type="table" target="#tab_0">5</ref> and<ref type="table">6</ref>, the erased judgement ∆ † ; C S † : com is derivable using the rules of Table <ref type="table">1</ref>. Conversely, any program typable using the rules of Table <ref type="table">1</ref> can be annotated everywhere by L and typed by the rules in Tables <ref type="table" target="#tab_0">5</ref> and<ref type="table">6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Examples</head><p>We consider a program in which the HIV status of a medical patient is to be kept confidential. A basic patient record looks as follows. We assume that there is an L-class String.  We solve the problem in a simple way: The rule for classes in Table <ref type="table">6</ref> requires that an H-subclass of an L-class overrides all methods of its superclass. This is unnecessarily, and unacceptably, restrictive. It requires, for example, that getName be overridden although it poses no risk of bad flow; and an overriding declaration does not have access to the private field name. The problem can be solved in a less restrictive way using the notion of "anonymous method" of Vitek and Bokowski <ref type="bibr" target="#b32">[31]</ref>: such methods do not leak the receiver this. The static analyses described in <ref type="bibr" target="#b32">[31,</ref><ref type="bibr" target="#b15">14]</ref> restrict inheritance only for methods that leak this. We expect that their constraints can be adapted easily to our setting.</p><formula xml:id="formula_13">x = this T 2 ≤ T 1 κ 2 ≤ κ 1 κ 3 ≤ κ 1 ∆, x : (T 1 , κ 1 ); C e : (T 2 , κ 2 ) ∆, x : (T 1 , κ 1 ); C x := e : (com κ 3 , κ 4 ) (T, κ 2 )f ∈ sdfields C ∆, x : (C, κ 1 ); C e : (U, κ 3 ) U ≤ T κ 1 κ 3 κ 5 ≤ κ 2 ∆, x : (C, κ 1 ); C x.f := e : (com κ 4 , κ 5 ) x = this B ≤ D level B κ 2 ≤ κ 1 κ 3 ≤ level B ∆, x : (D, κ 1 ); C x := new B( ) : (com κ 2 , κ 3 ) smtype(m, D) = x : (T , κ) κ3 -→ (T, κ 2 ) ∆; C e : (D, κ 4 ) ∆; C e : (U , κ 5 ) U ≤ T κ 5 ≤ κ κ 4 κ 7 ≤ κ 3 ∆; C e.m(e) : (com κ 6 , κ 7 ) ∆; C S 1 : (com κ 1 , κ 2 ) ∆; C S 2 : (com κ 3 , κ 4 ) κ 5 ≤ κ 1 κ 3 κ 6 ≤ κ 2 κ 4 ∆; C S 1 ; S 2 : (com κ 5 , κ 6 ) ∆; C e : (bool, κ 5 ) ∆; C S 1 : (com κ 1 , κ 3 ) ∆; C S 2 : (com κ 2 , κ 4 ) κ 5 ≤ κ 6 κ 7 κ 6 ≤ κ 1 κ 2 κ ≤ κ 3 κ 4 ∆; C if e S 1 else S 2 : (com κ 6 , κ 7 ) ∆; C e : (U, κ 4 ) ∆, x : (T, κ 1 ); C S : (com κ 5 , κ 6 ) U ≤ T κ 4 ≤ κ 1 κ 2 ≤ κ 5 κ 3 ≤ κ 6 ∆; C var (T, κ 1 ) x := e in S : (com κ 2 , κ 3 )</formula><p>x : (T , κ), this : (C, κ 1 ); C S : (com κ 2 , κ 3 ) x : (T , κ), this : (C, κ 1 ); C e : (T, κ 4 ) smtype(m, D) is undefined or equals x : (T , κ)</p><formula xml:id="formula_14">κ3 -→ (T, κ 4 ) C κ 1 extends D (T, κ 4 ) m((T , κ) x) κ 3 {S; return e} level D ≤ κ C κ extends D M for each M ∈ M If level D = κ then every m with smtype(m, D) defined is overridden in C by some M ∈ M . class C κ extends D { τ f ; M } Table 6</formula><p>. Security typing rules for commands, method declarations, and classes.</p><p>Our last examples involve information leaks via the conditional control flow implicit in dynamically bound method calls. Consider these three classes. The leak method is the same as before but using YNh and its subclasses. Consider x of type (YNh,H) in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>class YN L extends</head><p>x:=xp.leak(); x.set(); ...x.val()...</p><p>The declared level of x must be H because it is assigned from leak. The method call rule then requires for x.set that the heap effect of set be H, which in turn forces the level of field v to be H. Indeed, if its level was L then the call x.set() would violate noninterference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Remarks about proofs</head><p>Proofs in the sequel involve detailed analysis of the semantics and the security typing rules. For each specific case, the semantic definition may involve several values (e.g., the value of e is needed in the semantics of x := e), and the rule may involve several types and security labels. In writing a given proof case, we found it convenient to write down both the rule and the semantics for reference. It is impractical to include such redundancy in the paper, however. Instead, when it comes to proving something about a particular construct we make free use of identifiers in the typing rule (in Table <ref type="table" target="#tab_0">5</ref> or 6), for types and labels, and identifiers in the semantic definition for semantic values (in Table 3 or 4). We explicitly introduce identifiers for types or values only when necessity or perspicuity demands it.</p><p>Note that the semantic definition may use different identifiers for types, as the semantics is based on the typing rules in Table <ref type="table">1</ref> rather than the security rules in Tables <ref type="table" target="#tab_0">5</ref> and<ref type="table">6</ref>.</p><p>We streamline the proofs by ignoring ⊥ outcomes in many cases. Most of the results only pertain to non-⊥ outcomes, and the constructs are mostly strict in ⊥. Without comment we assume various intermediate values are non-⊥ unless confusion could result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Confinement</head><p>This section shows that typable programs maintain the invariant that L fields and variables never hold H locations. The formalization uses the indistinguishability relation ∼ also used in the main results of Section 6.</p><p>In formalizing the absence of L-variables that refer to H-objects, we take advantage of the fact that nil ∈ Loc and ⊥ ∈ Loc. We use the short name "ok" for L-confinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (L-confinement (ok ))</head><formula xml:id="formula_15">• Define LLoc = { ∈ Loc | level = L}.</formula><p>• For heaps, define ok h iff for all ∈ dom h and every f ∈ fields(loctype ), if stype(f, loctype ) = (T, L) for some T and h f ∈ Loc then h f ∈ LLoc.</p><p>• For environments, define ok ∆ η iff for every x with ∆ x = (T, L) for some T , if η x ∈ Loc then η x ∈ LLoc.</p><p>• For method environments, define ok µ iff the following holds: for every m, C, η, h, if ok h, ok ∆ η, and µCmηh = ⊥ then ok h 0 and Proof: By induction on the derivation of ∆; C e : (T, L) (for brevity: "induction on e"). Recall from Section 4.2 that throughout the proofs we ignore the ⊥ cases.</p><formula xml:id="formula_16">κ 3 = L ∧ d ∈ Loc ⇒ d ∈ LLoc, where smtype(m, C) = x : (T , κ) κ2 -→ (T, κ 3 ) ∆ = x : (T , κ), this : (C, level C) (d, h 0 ) = µCmηh</formula><p>• Case of x:</p><formula xml:id="formula_17">Then d = [[∆ † ; C x : T ]]µηh = ηx.</formula><p>The result follows directly from assumption ok ∆ η.</p><p>• e.f : By typing, κ 1 = L = κ 2 . Because κ 2 = L we can use induction on e; this, together with the assumption that the semantics is non-⊥, yields that there is = [[∆ † ; C e : C]]µηh and ∈ LLoc and ∈ dom h. Now the result follows using κ 1 = L and assumption ok h. Since by assumption ok ∆ η, it is enough to deal with x; that is, if κ 1 = L we must show ∈ Loc ⇒ ∈ LLoc. Indeed, the allocator fresh yields ∈ Loc. But by the typing rule, κ 1 = L implies level B = L, hence ∈ LLoc as required. Finally, we get ok h 0 , where</p><formula xml:id="formula_18">h 0 = [h | → [fields B → defaults]],</formula><p>because ok h by hypothesis and defaults contains no locations (the defaults are false and nil).</p><p>• e.m(e): We have η 0 = η, and ok ∆ η by assumption, so it suffices to show ok h 0 . Let ∆ 0 = x : (T , κ), this : (loctype , level ), and</p><formula xml:id="formula_19">η 0 = [x → d, this → ].</formula><p>We claim ok ∆ 0 η 0 ; then we get the result by ok µ. The claim is proved by the same argument as for method calls in the proof of Lemma 5.1 (literally the same argument, owing to the fact that the relevant identifiers are the same in the typing rules for method call as expression and as command).</p><p>• if e S 1 else • S 1 ; S 2 : Use induction on S 1 , then on S 2 . 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5.3 (L-confinement of method environments)</head><p>For each i we have ok µ i , and ok μ.</p><formula xml:id="formula_20">2</formula><p>The proof is by induction on i, using Lemmas 5.1 and 5.2, and then fixpoint induction for μ. It follows the pattern of the proof of Theorem 6.3, and is given in the full paper.</p><p>Object states are indistinguishable by L if their L-fields are equal, and environments are indistinguishable if their Lvariables are equal. In the case of heaps and object states, the relevant levels are determined by the field declarations in the class table. By contrast, the levels for environments are determined by parameter and local variable declarations, hence the dependence is explicit in the notation ∼ ∆ . It is straightforward to show that each of these is an equivalence relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Indistinguishable by L)</head><formula xml:id="formula_21">• For s, s ∈ [[C state]], define s ∼ s iff ∀f ∈ fields C . let (T, κ) = stype(f, C) in (κ = L ⇒ sf = s f ). • For h, h ∈ [[Heap]], define h ∼ h iff dom h ∩ LLoc = dom h ∩ LLoc and ∀ ∈ dom h ∩ LLoc . h ∼ h . • For η, η ∈ [[∆ † ]], define η ∼ ∆ η iff ∀x ∈ dom ∆ . let (T, κ) = ∆x in (κ = L ⇒ ηx = η x). 2</formula><p>If a command is typable as (com H, κ) it does not assign to L-variables, and if it is typable as (com κ 2 , H) it does not assign to L-fields of objects. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (H-confined method environment)</head><formula xml:id="formula_22">Method environment µ is H-confined, written Hconf µ, if µCmηh = ⊥ ⇒ h 0 ∼ h,</formula><formula xml:id="formula_23">• if κ 1 = H and (η 0 , h 0 ) = [[∆ † ; C S † : com]]µηh then η ∼ ∆ η 0 . • if κ 2 = H and (η 0 , h 0 ) = [[∆ † ; C S † : com]]µηh then h ∼ h 0 .</formula><p>Proof: By induction on the derivation of ∆; C S : (com κ 1 , κ 2 ). As usual, we follow the conventions described in Section 4.2; in particular, level identifiers in the proof are those in the relevant rules, not κ 1 , κ 2 as used in the statement of the Lemma. • x.f := e: This has no effect on the environment, so it suffices to show that κ 5 = H ⇒ h ∼ h 0 , where</p><formula xml:id="formula_24">h 0 = [h | → [h | f → d]],</formula><p>= ηx and d = [[∆ † ; C e : U ]]µηh. If ∈ LLoc then h ∼ h 0 because the two heaps are identical on LLoc. If ∈ LLoc then we must consider the updated field h f . Assuming κ 5 = H, the typing rule forces the level κ 2 of field f to be H; nothing else is updated, so h ∼ h 0 holds by definition of ∼. We claim that ok ∆ 0 η and ok ∆ 0 η and η 0 ∼ ∆0 η 0 . Then we get the result d = d by safe µ. It remains to prove the claims. We give the argument for the case that x is a single identifier, as the generalization is obvious but awkward to put into words. • x.f := e: This has no effect on the environment, so we only need to show that the result heaps are related. Let Finally, we get h 0 ∼ h 0 as follows. If either or is in LLoc then level B = L so by parametricity of the allocator we get = , satisfying the domain condition for h 0 ∼ h 0 . For the range, i.e., h ∼ h , the result holds because the new object states are identical.</p><formula xml:id="formula_25">h 0 = [h | → [h | f → d]] and let h 0 = [h | → [h | f → d ]]. We must show h 0 ∼ h 0 . If the level κ 2 of f is H, then h 0 ∼ h (</formula><p>• e.m(e): By semantics, the command has no effect on the environment, so it suffices to show h 0 ∼ h 0 . (This is fortunate, because the statement of the Lemma uses identifiers η 0 , η 0 that are used differently in the semantics.)</p><p>We show h 0 ∼ h 0 by cases on κ 4 . If κ 4 = H then it is possible that = and thus the two calls can have different behavior. But by the typing constraint κ 4 ≤ κ 3 we have κ 3 = H and thus Hconf µ yields h 0 ∼ h ∼ h ∼ h 0 . It remains to consider the case κ 4 = L. In this case, we have = by Lemma 6.1. Now let ∆ 0 = x : (T , κ), this : (loctype , level ),</p><formula xml:id="formula_26">η 0 = [x → d, this → ], and η 0 = [x → d , this → ].</formula><p>We claim that ok ∆ 0 η and ok ∆ 0 η and η 0 ∼ ∆0 η 0 . Then we get the result h 0 = h 0 by safe µ. Owing to our choice of identifiers in the typing rules, the proof of the claim is just the same as in the case for method call as expression (see the proof of Lemma 6.1).</p><p>• S 1 ; S 2 : Use induction and L-confinement (Lemma 5.2) for S 1 ; then induction on S 2 .</p><p>• if e S 1 else S 2 : We proceed by cases on level κ 5 of the guard e. Suppose </p><formula xml:id="formula_27">= κ 2 = κ 3 = κ 4 = H. Let (η 0 , h 0 ) = [[∆ † ; C if e S 1 else S 2 : com]]µηh and (η 0 , h 0 ) = [[∆ † ; C if e S 1 else S 2 : com]]µη h .</formula><p>By H-confinement Lemma 5.4 we have η ∼ ∆ η 0 , η ∼ ∆ η 0 , h ∼ h 0 , and h ∼ h 0 . Using assumptions η ∼ ∆ η and h ∼ h we get η 0 ∼ ∆ η 0 and h 0 ∼ h 0 by transitivity.</p><p>• var (T, κ 1 ) x := e in S: First, we have Proof: Because safe μ is defined as a fixpoint, we first show that safe µ i for all i, by induction on i. Then the result follows by fixpoint induction.</p><formula xml:id="formula_28">[η | x → d] ∼ (∆,x:(T,κ1)) [η | x → d ] because if κ 1 = L then</formula><p>We have safe µ 0 because µ 0 Cm is constantly ⊥. Suppose safe µ i , to show safe µ i+1 . By definition, we must show safe µ i+1 Cm for each C, m. There are two cases, depending on whether m is declared or inherited.</p><p>Suppose m has declaration M = τ 1 κ 1 m(τ x) κ 2 {S; return e} in C and let ∆ = x : τ , this : (C, level C). By Lemmas 5.3 and 5.5 we have ok µ i and Hconf µ i . Suppose ok ∆ η and ok h, and let (η 0 , h 0 ) = [[(x : T , this : C); C S : com]]µ i ηh (if the outcome is ⊥ there is nothing more to prove). By Lemma 5.2, L-confinement of commands, we have ok ∆ η 0 , ok ∆ η 0 , ok h, and ok h . By Lemma 6.2, safety for commands, we have h 0 ∼ h 0 and η 0 ∼ ∆ η 0 . It remains to show that if the result level κ 4 for m is L we have d = d . But by security typing for method declarations, if κ 4 = L then the return expression e is typed L. Using ok µ i , η 0 ∼ ∆ η 0 , etc., Lemma 6. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Discussion</head><p>Beyond the progress reported here, much remains to be done. Non-interference is an attractive property because it can be easily formalized and can provide a precise description of end-to-end security in a system. By itself, however, noninterference as an information flow policy can be rather restrictive. As has been shown by several researchers, a controlled amount of declassification or downgrading of sensitive information is needed in realistic systems for them to be useful. As a future extension of this work, we expect to formalize noninterference in the presence of declassification following the work of Zdancewic and Myers <ref type="bibr" target="#b36">[35]</ref>.</p><p>One direction of work that we have already pursued is adding Java's access control mechanism to the core language <ref type="bibr" target="#b4">[3]</ref>. We plan to add information flow annotations to this language. Then, allowing declassification may lead to leakage of information, but the access control mechanism can possibly be used to obtain a noninterference result.</p><p>Java has quite a few features beyond the language treated here. To extend our language to the remaining features of JavaCard <ref type="bibr" target="#b8">[7]</ref>, the semantics can be extended using standard techniques. To treat expressions with side effects, both the environment and the heap would be threaded through the semantics of expressions. We have avoided this in the current paper because it is unilluminating. Exceptional control flow would add further semantic complications of a similar kind. The other missing features have to do with scope and visibility: protected fields, private and protected classes, interfaces, and packages. These features can be treated in the typing rules, similarly to our treatment of private fields, and the semantic consequences could perhaps be exploited to reduce the need for security annotations.</p><p>Features of Java beyond those of JavaCard pose a bigger challenge: threads, class loading <ref type="bibr" target="#b10">[9]</ref>, reflection, and serialization. Specifying noninterference for such constructs would probably go hand-in-hand with specification of pointer confinement and data abstraction properties.</p><p>As a step towards more general pointer confinement and abstraction, we are already studying polymorphic classes as in GJ <ref type="bibr" target="#b7">[6]</ref>. Label polymorphism is also desirable <ref type="bibr" target="#b22">[21,</ref><ref type="bibr" target="#b21">20]</ref>, e.g., for library classes. Label polymorphism might lessen the practical need for H-subclasses of L-classes, which in turn would allow simplification of the security typing rules.</p><p>An important implementation issue is which security annotations can be left implicit, to be inferred by a type reconstruction algorithm. We have not addressed type reconstruction in the current work, but expect that techniques from Pottier et al. can be adapted <ref type="bibr" target="#b23">[22,</ref><ref type="bibr" target="#b24">23]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>T</head><label></label><figDesc>::= bool | unit | C CL ::= class C extends C { T f ; M } M ::= T m(T x) {S; return e} S ::= x := e | x.f := e | x := new C() | e.m(e) | if e S else S | var T x := e in S | S; S e ::= x | e.f | e.m(e) | e==e | (C) e | null | e instanceof C</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>and let M be in the list M of method declarations, with M = T m(T 2 x) {S; return e}. We record the typing information by defining mtype(m, C) = (x : T 2 ) → T . For the declared fields, we define dfields C = T 1 f and type(f , C) = T 1 . To include inherited fields, we define fields C = dfields C ∪ fields D, and assume f is disjoint from the names in fields D. The built-in class Object has no methods or fields. Note that mtype(m, C) is defined only if m is declared or inherited in C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(x : T , this : C); C S : com (x : T , this : C); C e : U U ≤ T mtype(m, D) is undefined or equals (x : T ) → T C extends D T m(T x){S; return e}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Γ; C x : Γx Γ; C e 1 : T Γ; C e 2 : T Γ; C e 1 ==e 2 : bool Γ; C null : B T f ∈ dfields C Γ; C e : C Γ; C e.f : T mtype(m, D) = (x : T ) → T Γ; C e : D Γ; C e : U U ≤ T Γ; C e.m(e) : T Γ; C e : D B ≤ D Γ; C (B) e : B Γ; C e : D B ≤ D Γ; C e instanceof B : bool Γ; C unit : unit x = this Γ; C e : T T ≤ Γ x Γ; C x := e : com Γx = C T f ∈ dfields C Γ; C e : U U ≤ T Γ; C x.f := e : com x = this B ≤ Γx Γ; C x := new B( ) : com mtype(m, D) = (x : T ) → T Γ; C e : D Γ; C e : U U ≤ T Γ; C e.m(e) : com Γ; C e : bool Γ; C S 1 : com Γ; C S 2 : com Γ; C if e S 1 else S 2 : com Γ; C S 1 : com Γ; C S 2 : com Γ; C S 1 ; S 2 : com Γ; C e : U (Γ, x : T ); C S : com U ≤ T Γ; C var T x := e in S : com</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>In addition to domains like [[T ]] and [[Γ]] that correspond directly to syntactic notations, we use the following domains:[[Heap]] is the set of heaps, [[C state]]is the set of states of objects of class C, [[MEnv ]] is the set of method environments (we write for finite partial functions), and [[(C, (x : T ) → T )]] is the set of meanings for methods of class C with result T and parameters x : T . The sets [[Heap]], [[bool]], [[C]], and [[C state]] are ordered by equality. We write → for continuous function space, ordered pointwise, and X ⊥ for domain X with added bottom element ⊥. Each set [[(C, (x : T ) → T )]] has a least element (the constantly-⊥ function) and least upper bounds of ascending chains, and this suffices for the fixpoint semantics. Without giving a precise formalization, we require that [[MEnv ]] contain exactly the partial functions µ such that µCm is defined for all classes C declared in CT and methods m declared or inherited in C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>updates h by replacing h with the object state [h | f → d] obtained by updating field f to have the value d of e.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>[[(x : T , this : C); C S : com]]µηh in let d = [[(x : T , this : C); C e : T ]]µη 0 h 0 in (d, h 0 ) where in class C we have M = T m(T x){S; return e}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>[</head><label></label><figDesc>[Γ; C var T x := e in S : com]]µηh= let d = [[Γ; C e : U ]]µηh in let (η 0 , h 0 ) = [[(Γ, x : T ); C S]]µ[η | x → d]h in (η 0 x, h 0 ) Table 4. Semantics of commands.bound. The grammar is revised as follows. κ ::= L | H τ ::= (T, κ) CL ::= class C κ extends C { τ f ; M } M ::= τ m(τ x) κ {S; return e} S ::= . . . | var τ x := e in S | . . .Tables</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>∆</head><label></label><figDesc>; C x : ∆x ∆; C null : (D, κ) ∆; C unit : (unit, κ) ∆; C e 1 : (T, κ 1 ) ∆; C e 2 : (T, κ 2 ) ∆; C e 1 ==e 2 : (bool, κ 1 κ 2 ) (T, κ 1 )f ∈ sdfields C ∆; C e : (C, κ 2 ) ∆; C e.f : (T, κ 1 κ 2 ) ∆; C e : (D, κ) B ≤ D ∆; C (B) e : (B, κ) smtype(m, D) = x : (T , κ) κ3 -→ (T, κ 2 ) ∆; C e : (D, κ 4 ) ∆; C e : (U , κ 5 ) U ≤ T κ 5 ≤ κ ∆; C e.m(e) : (T, κ 2 κ 4 ) ∆; C e : (D, κ) B ≤ D ∆; C e instanceof B : (bool, κ)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Lemma 5 . 1 (</head><label>51</label><figDesc>L-confinement of expressions) Let ∆; C e : (T, L) and let d = [[∆ † ; C e : T ]]µηh. If ok µ, ok ∆ η, and ok h then d ∈ Loc ⇒ d ∈ LLoc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>• 2 Lemma 5 . 2 (</head><label>252</label><figDesc>e.m(e): Let ∆ 0 = [x : (T , κ), this : (loctype , level )], and η 0 = [x → d, this → ]. We claim that ok ∆ 0 η 0 ; then we get the result by ok µ because by typing κ 2 = κ 4 = L. It remains to prove the claim. If κ = L, then by the typing rule, κ 5 = L. So by induction on e, and since the semantics is non-⊥, we get d ∈ Loc ⇒ d ∈ LLoc. Hence ok (x : (T , κ)) [x → d]. We get ok (this : (loctype , level )) [this → ] directly from the definitions of ok and LLoc, as level = L iff ∈ LLoc. • (B) e: By κ = L, and because we are considering the case where [[(B) e]]µηh = ⊥, we can use induction on e to obtain ∈ Loc ⇒ ∈ LLoc. Moreover, must be in dom h otherwise the semantics is ⊥. Now the result follows directly. • e instanceof B, e==e , null, unit: The result returned in each case is not in Loc. This falsifies the antecedent in the lemma. L-confinement of commands) Let ∆; C S : (com κ 1 , κ 2 ). If ok µ, ok h, ok ∆ η, and [[∆ † ; C S † : com]]µηh = ⊥ then ok ∆ η 0 and ok h 0 , where (η 0 , h 0 ) = [[∆ † ; C S † : com]]µηh. Proof: By induction on the derivation of ∆; C S : (com κ 1 , κ 2 ), using the assumptions of the Lemma. • x := e: This has no heap effect: the result heap h 0 is h and ok h holds by assumption. We only need to show ok (∆, x : (T 1 , κ 1 )) [η | x → d], where d = [[∆ † ; C e : T 2 ]]µηh. Accordingly, assume that κ 1 = L. Then by typing, κ 2 = L so Lemma 5.1 for e yields d ∈ Loc ⇒ d ∈ LLoc. • x.f := e: The result environment η 0 is just η, and ok ∆ η holds by assumption. We only need to show ok h 0 , where h 0 = [h | → [h | f → d]], = ηx and d = [[∆ † ; C e : U ]]µηh. Since the semantics is non-⊥, we have ∈ dom h. Now assume that the level κ 2 of field f is L. Then by the typing rule we have κ 1 = κ 3 = L. Now applying Lemma 5.1 on e, we obtain, d ∈ Loc ⇒ d ∈ LLoc. This proves ok h 0 . • x := new B( ): For the environment, we must show ok (∆, x : (D 1 , κ 1 ))[η | x → ], where = fresh(B, h).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>S 2 :</head><label>2</label><figDesc>Let b = [[∆ † ; C e : bool]]µηh. Then if b = true, the result follows by induction on S 1 and if b = false, the result follows by induction on S 2 . • var (T, κ 1 ) x := e in S: First, we have ok (∆, x : (T, κ 1 )) [η | x → d] where d = [[∆ † ; C e : U ]]µηh. This is because if κ 1 = L, then by typing κ 4 = L, so by Lemma 5.1 for e, d ∈ Loc ⇒ d ∈ LLoc. Induction on S yields ok (∆, x : (T, κ 1 )) η 1 and ok h 0 , where (η 1 , h 0 ) = [[(Γ, x : T ); C S]]µ[η | x → d]h. Hence ok ∆ (η 1 x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>2 Lemma 5 . 4 (</head><label>254</label><figDesc>where (d, h 0 ) = µCmηh, for all C, m with smtype(m, C) = x : (T , κ) H -→ (T, κ). H-confinement of commands) Let ∆; C S : (com κ 1 , κ 2 ). Then for all µ, η, h such that Hconf µ and [[∆ † ; C S † : com]]µηh = ⊥ we have</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>•</head><label></label><figDesc>x := e: This has no effect on the heap. We need to show that κ 3 = H ⇒ η ∼ (∆,x:(T1,κ1)) η 0 , where η 0 = [η | x → d] and d = [[∆ † ; C e : T ]]µηh. Assuming κ 3 = H, we obtain κ 1 = H by the typing rule. Now the result follows using definition ∼ (∆,x:(T1,H)) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>•</head><label></label><figDesc>e.f : By typing, κ 1 = L = κ 2 . Because κ 2 = L we can use induction on e; this yields that there is with [[∆ † ; C e : C]]µηh = = [[∆ † ; C e : C]]µη h , as we only consider the case that both semantics are non-⊥. For the same reason, is in the domain of both h and h . By κ 2 = L and Lemma 5.1 we have ∈ LLoc so, by assumption h ∼ h , we get h ∼ h ; this implies h f = h f because field f has label κ 1 = L. • e.m(e): By the security typing rule we have e : (D, L), so by induction = . Let ∆ 0 = x : (T , κ), this : (loctype , level ), η 0 = [x → d, this → ], and η 0 = [x → d , this → ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>For η 0 ∼ 2 Lemma 6 . 2 (</head><label>0262</label><figDesc>∆0 η 0 , note that since = it suffices to deal with d, d regardless of whether loctype = L. If κ = L then we need d = d . Now κ = L implies κ 5 = L by the security typing rule, and then we get d = d by induction on e; moreover Lemma 5.1 yields ok (x : (T , κ)) [x → d]. Thus ok ∆ 0 η because ok (this : (loctype , level )) [this → ] holds for any . We have ok ∆ 0 η mutatis mutandis. • (B) e: By κ = L, we can use induction on e to obtain = . Moreover, as we are considering the case where [[(B) e]]µηh = ⊥ = [[(B)e]]µη h , we have that is in both dom h and dom h . The result follows directly. • e instanceof B, null, unit: All are easy. Safe commands) ∆; C S : (com κ 1 , κ 2 ). Suppose also ok µ, ok h, ok h , ok ∆ η, ok ∆ η , safe µ, Hconf µ, η ∼ ∆ η , h ∼ h , and [[∆ † ; C S † : com]]µηh = ⊥ = [[∆ † ; C S † : com]]µη h . Then η 0 ∼ ∆ η 0 and h 0 ∼ h 0 , where (η 0 , h 0 ) = [[∆ † ; C S † : com]]µηh and (η 0 , h 0 ) = [[∆ † ; C S † : com]]µη h . Proof: By induction on the derivation of ∆; C S : (com κ 1 , κ 2 ). Under the assumptions of the Lemma, we show [[∆ † ; C S : com]]µηh = [[∆ † ; C S : com]]µη h by cases on S. • x := e: This has no effect on the heap; we only need to show [η | x → d] ∼ (∆,x:(T1,κ1)) [η | x → d ], where d = [[∆ † ; C e : T 2 ]]µηh and d = [[∆ † ; C e : T 2 ]]µη h . Under the assumption η ∼ (∆,x:(T1,κ1)) η , it remains to show that κ 1 = L implies d = d . If κ 1 = L then κ 2 = L, by typing, and then Lemma 6.1 yields d = d . (Use of Lemma 6.1 depends on the assumptions ok h etc.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>and h 0 ∼ h ) because h 0 and h are identical except for the H field f . So the result follows by transitivity of ∼. For the other case, κ 2 = L, we have κ 1 = κ 3 = L by the typing rule. Since η ∼ (∆,x:(C1,κ1)) η , we obtain = ηx = η x = . So it remains to show that h 0 f ∼ h 0 f , i.e., d = d . And this holds by Lemma 6.1 for e, using that κ 3 = L.• x := new B( ): For the environment, we must show[η | x → ] ∼ ∆,x:(D1,κ1) [η | x → ]. By assumption η ∼ ∆,x:(D1,κ1) η it is enough to deal with x; that is, if κ 1 = L we need = . By the typing rule, κ 1 = L implies level B = L. Thus, by h ∼ h , we have dom h ∩ locs B = dom h ∩ locs B; then = by parametricity of the allocator (Definition 1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>κ 5 =</head><label>5</label><figDesc>L. Then by Lemma 6.1 for e, b = b . If b = true, the result follows by induction on S 1 and if b = false, the result follows by induction on S 2 . Consider the other case, κ 5 = H. By typing, κ 6 = H = κ 7 and κ 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>by typing κ 4 = 2 Theorem 6 . 3 (</head><label>4263</label><figDesc>L, so, by Lemma 6.1, d = d . Second, we have ok (∆, x : (T, κ 1 )) [η | x → d] by Lemma 5.1. So we can use induction on S to get η 0 ∼ (∆,x:(T,κ1)) η 0 and h 0 ∼ h 0 , and hence (η 0 x) ∼ ∆ (η 0 x). Noninterfering programs) The meaning μ of a well-formed class table is safe: safe μ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>1, safety for expressions, yields d = d . This concludes the proof of safe µ i+1 Cm. Suppose m is inherited in C from superclass D. Let ∆ C = x : τ , this : (C, level C) and ∆ D = x : τ , this : (D, level D). We claim that, for any η, η , ok ∆ C η ⇒ ok ∆ D η and η ∼ ∆ C η ⇒ η ∼ ∆ D η . Then safe µ i+1 Cm follows from the claim and safe µ i+1 Dm which was already proved. (Strictly speaking we are using secondary induction on inheritance chains.) For the claim, we only need to consider this, as otherwise ∆ C and ∆ D are the same. For this, ok ∆ D η requires level D = L ⇒ η this ∈ LLoc. From C ≤ D we get level D ≤ level C by the typing rule for classes. Moreover, since m is inherited from C the rule requires level D = level C so we are done. 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 5 . Security typing rules for expressions.</head><label>5</label><figDesc>After execution of line(1), LBuf, HBuf, and xp.name all reference the same object. After execution of line (2), LBuf aliases xp.name, and HBuf aliases xp.hiv. All the code above is allowed by the security typing rules, assuming appropriate types for the read methods. The following are not allowed in main.</figDesc><table><row><cell cols="2">class LPatient L extends Object {</cell><cell>(3) Lbuf := Hbuf;</cell></row><row><cell>(String,L) name;</cell><cell></cell><cell cols="2">(4) lp.setName(xp.getHiv());</cell></row><row><cell cols="2">(String,L) getName() H { return this.name } (unit,L) setName((String,L) n) L {</cell><cell cols="2">In both (3) and (4), there is a direct flow from H to L. Let us consider an H-subclass of XPatient.</cell></row><row><cell>this.name := n</cell><cell>} }</cell><cell cols="2">class HPatient H extends XPatient {</cell></row><row><cell></cell><cell></cell><cell>(String,H) f;</cell></row><row><cell></cell><cell></cell><cell cols="2">(unit,L) setf((String,H) v) H {</cell></row><row><cell></cell><cell></cell><cell>this.f := v</cell><cell>}</cell></row><row><cell></cell><cell></cell><cell cols="2">(String,H) getf() H {</cell></row><row><cell></cell><cell></cell><cell>return this.f</cell><cell>} }</cell></row><row><cell cols="2">class XPatient L extends LPatient {</cell><cell></cell></row><row><cell>(String,H) hiv;</cell><cell></cell><cell></cell></row><row><cell cols="2">(unit,L) setHIV((String,H) s) H { this.hiv := s } (String,H) getHIV() H {</cell><cell cols="2">There is, however, a problem with inherited methods. Suppose LPatient declared a method</cell></row><row><cell>return this.hiv</cell><cell>} }</cell><cell cols="2">(String,L) passSelf() H {</cell></row><row><cell cols="2">Here is an application using such objects, written using</cell><cell>...o.m(this)...</cell></row><row><cell>slight abuses of the official syntax.</cell><cell></cell><cell></cell></row><row><cell cols="2">class Main L extends Object {</cell><cell></cell></row><row><cell>(unit,L) main() L {</cell><cell></cell><cell></cell></row><row><cell cols="2">var (String,L) Lbuf := null;</cell><cell></cell></row><row><cell cols="2">var (String,H) Hbuf := null;</cell><cell></cell></row><row><cell cols="2">var (LPatient,L) lp:=readFile(...);</cell><cell></cell></row><row><cell cols="2">var (XPatient,L) xp:=new XPatient();</cell><cell></cell></row><row><cell cols="2">Lbuf := lp.getName();</cell><cell></cell></row><row><cell cols="2">Hbuf := lp.getName();</cell><cell></cell></row><row><cell>(1) xp.setName(Lbuf);</cell><cell></cell><cell></cell></row><row><cell cols="2">Hbuf := readFromTrustedChan(...);</cell><cell></cell></row><row><cell>(2) xp.setHIV(Hbuf); } }</cell><cell></cell><cell></cell></row></table><note><p><p>Note that setName has L-effect, as it assigns to an L-field. Method getName can be declared as having L or H effect; we choose the latter. A confidential field is added for HIV status in the following class.</p>By contrast with setName, the effect of setf can be declared H as it assigns only to an H-field. } where o.m is a call on some object o of a method m with L parameter. This is typable in LPatient, although it would not be typable in HPatient where the level of this is H. For a variable hp of class HPatient, an invocation hp.passSelf() of the inherited method would result in a flow from H to L in the call o.m(this).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>In main, the expression xp.leak().val() has level H due to the return type of leak.</figDesc><table><row><cell></cell><cell></cell><cell>Here is a similar example but using the heap and method</cell></row><row><cell></cell><cell></cell><cell>call commands rather than expressions.</cell></row><row><cell></cell><cell></cell><cell>class YNh L extends Object {</cell></row><row><cell></cell><cell>Object {</cell><cell>(bool,H) v;</cell></row><row><cell cols="2">(bool,L) val(){ return true; } } }</cell><cell>(bool,H) val(){ return v } }</cell></row><row><cell cols="2">class Y L extends YN {</cell><cell>(unit,L) setv((bool,H) w) H {</cell></row><row><cell cols="2">(bool,L) val(){ return true; } }</cell><cell>this.v:=w }</cell></row><row><cell cols="2">class N L extends YN {</cell><cell>(unit,L) set() H {this.setv(true)} }</cell></row><row><cell cols="2">(bool,L) val(){ return false; } }</cell><cell>class Yh L extends YNh {</cell></row><row><cell></cell><cell></cell><cell>(unit,L) set() H {this.setv(true)} }</cell></row><row><cell></cell><cell></cell><cell>class Nh L extends YNh {</cell></row><row><cell cols="2">We add the following method to XPatient. The typing</cell><cell>(unit,L) set() H {this.setv(false)} }</cell></row><row><cell cols="2">rules force the result to have level H; otherwise there would</cell></row><row><cell>be a bad data flow.</cell><cell></cell></row><row><cell cols="2">(YN,H) leak() H {</cell></row><row><cell>var (YN,H) o;</cell><cell></cell></row><row><cell cols="2">if (this.hiv) o := new Y();</cell></row><row><cell>else</cell><cell>o := new N();</cell></row><row><cell>return o;</cell><cell>}</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement: To Geoffrey Smith for discussions that helped clarify noninterference and to the anonymous referees for their comments.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Supported by NSF grants EIA-9806835 and CCR-0296182 † Supported by NSF grant INT-9813854   </p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Moreover, smtype(m, (loctype )) = x : (T , κ) H -→ (T, κ 2 ). Hence, by assumption Hconf µ, we get h ∼ h 0 .</p><p>• S 1 ; S 2 : First assume κ 5 = H. Then by the typing rule, κ 1 = H = κ 3 . By induction on S 1 we get η ∼ ∆ η 1 where we write (η 1 , h 1 ) for the intermediate state. Then by induction on S 2 , we get η 1 ∼ ∆ η 0 where</p><p>Next, assume κ 6 = H. Then κ 2 = H = κ 4 . And, h ∼ h 0 follows by induction on S 1 and S 2 and transitivity.</p><p>• if e S 1 else S 2 : First, assume κ • var (T, κ 1 ) x := e in S: First, assume κ 2 = H.</p><p>Then by the typing rule, κ 5 = H. Hence by induction on S,</p><p>Next, assume κ 3 = H. Then by the typing rule, κ 6 = H. And, by induction on S we get h ∼ h 0 . 2 Note that a command var (T, L) x := e in S can be typed as ∆; C S : (com H, κ 2 ) so the Lemma applies to such commands. But the typing rule ensures that no Lvariable is assigned in S. Moreover, if κ 2 = H then no L-fields are assigned. So x is of limited use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5.5 (H-confinement of method environments)</head><p>For each i we have Hconf µ i , and Hconf μ.</p><p>2</p><p>The proof is by induction on i, using Lemma 5.4, and then fixpoint induction. It follows the pattern of the proof of Theorem 6.3, and is given in the full paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Noninterference</head><p>A method meaning is safe, i.e., noninterfering, provided that, for terminating computations, L-indistinguishable initial heaps and environments lead to L-indistinguishable results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Safe method environment)</head><p>We define safe µ iff for all C, m and all h, h , η, η the following holds: If ok h, ok h ok ∆ η, and ok ∆ η then</p><p>= µCmη h 2 Our main result is that the method environment denoted by a secure class table is safe. The proof uses the following two results which express noninterference for the expression and command constructs, respectively.</p><p>If an expression can be typed ∆; C e : (T, L) then its meaning is the same in two L-indistinguishable states, provided that it diverges in neither state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 6.1 (Safe expressions)</head><p>In this proof and subsequent ones, we extend the convention described in Section 4.2. When comparing semantics for a pair of states (η, h) and (η , h ), we use corresponding primes on identifiers in the semantic definitions. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">First, assume κ 2 = H. Then by typing</title>
		<imprint/>
	</monogr>
	<note>= new B(</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">But this follows by definition of ∼ (∆,x:(D,κ1)) since κ 1 = H. Next assume κ 3 = H. Then by typing, level B = H. Hence ∈ LLoc. We must show h ∼ h 0 , where h 0 =</title>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
		<imprint/>
	</monogr>
	<note>We must show η ∼ (∆,x:(D,κ1)) η 0 where η 0 = [η | x → ] and = fresh(B, h). h | → [fields B → defaults. But this follows by definition of ∼ because h and h 0 are identical on LLoc. References</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A core calculus of dependency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Riecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="147" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The Java Programming Language</title>
		<author>
			<persName><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Representation independence, confinement and access control</title>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="166" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Partial evaluation and noninterference for object calculi</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Serpette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FLOPS&apos;99</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Middeldorp</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</editor>
		<meeting>FLOPS&apos;99</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1722</biblScope>
			<biblScope unit="page" from="53" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Capabilities for sharing: A generalisation of uniqueness and read-only</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boyland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Retert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP 2001 -Object-Oriented Programming</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="2" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Making the future safe for the past: Adding genericity to the Java programming language</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stoutamire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Object Oriented Programming: Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="1998-10">Oct. 1998</date>
			<biblScope unit="page" from="183" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Java Card Technology for Smart Cards</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Simple ownership types for object containment</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP 2001 -Object Oriented Programming</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Knudsen</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="53" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Formal Aspects of Mobile Code Security</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Dean</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Princeton University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A lattice model of secure information flow</title>
		<author>
			<persName><forename type="first">D</forename><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="236" to="242" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Certification of programs for secure information flow</title>
		<author>
			<persName><forename type="first">D</forename><surname>Denning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="504" to="513" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Providing flexibility in information flow control for object-oriented systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Samarati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bertino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jajodia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Security and Privacy</title>
		<meeting>IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="130" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Security policies and security models</title>
		<author>
			<persName><forename type="first">J</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1982 IEEE Symposium on Security and Privacy</title>
		<meeting>the 1982 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Encapsulating objects with confined types</title>
		<author>
			<persName><forename type="first">C</forename><surname>Grothoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Object Oriented Programming: Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="241" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The SLam calculus: programming with secrecy and integrity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Riecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="365" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Islands: Aliasing protection in object-oriented languages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hogg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Object Oriented Programming: Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="271" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Featherweight Java: A minimal core calculus for Java and GJ</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Prog. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="396" to="459" />
			<date type="published" when="2001-05">May 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Data abstraction and information hiding</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<idno>160</idno>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<date type="published" when="2000-11">Nov. 2000</date>
		</imprint>
		<respStmt>
			<orgName>COMPAQ Systems Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A generic approach to the security of multi-threaded programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mantel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 14th IEEE Computer Security Foundations Workshop</title>
		<meeting>14th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="126" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">JFlow: Practical mostly-static information flow control</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="228" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Complete, safe information flow with decentralized labels</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, IEEE Symposium on Security and Privacy</title>
		<meeting>IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="186" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Information flow inference for free</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pottier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Conchon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fifth ACM International Conference on Functional Programming</title>
		<meeting>the fifth ACM International Conference on Functional Programming</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="46" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Information flow inference for ML</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pottier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Simonet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="319" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Types, abstraction, and parametric polymorphism</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Processing &apos;83</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Mason</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="513" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Probabilistic noninterference for multi-threaded programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 13th IEEE Computer Security Foundations Workshop</title>
		<meeting>13th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="200" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A Per model of secure information flow in sequential programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Higher-order and Symbolic Computation</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="59" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A new type system for secure information flow</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 14th IEEE Computer Security Foundations Workshop</title>
		<meeting>14th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="115" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Secure information flow in a multi-threaded imperative language</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="355" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Names and Higher-Order Functions</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stark</surname></persName>
		</author>
		<ptr target="http://www.dcs.ed.ac.uk/home/stark/publications/thesis.html" />
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Logical relations for encryption</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sumii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="256" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Confined types in java. Software Practice and Experience</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bokowski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="507" to="532" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A type-based approach to program security</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TAPSOFT&apos;97, number 1214 in LNCS</title>
		<meeting>TAPSOFT&apos;97, number 1214 in LNCS</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="607" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Confinement properties for multithreaded programs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A sound type system for secure flow analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Irvine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="167" to="187" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Robust declassification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 14th IEEE Computer Security Foundations Workshop</title>
		<meeting>14th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="15" to="23" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
