<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Near-Optimal Connectivity Encoding of 2-Manifold Polygon Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrei</forename><surname>Khodakovsky</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<settlement>Caltech</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Alliez</surname></persName>
							<email>pierre.alliez@sophia.inria.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">INRIA Sophia-Antipolis</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mathieu</forename><surname>Desbrun</surname></persName>
							<email>desbrun@usc.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">U. of So. Cal</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Schr√∂der</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<settlement>Caltech</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Near-Optimal Connectivity Encoding of 2-Manifold Polygon Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8BDCC4EBA45A6648EC6CA9DCB3E89B5C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Compression Algorithms</term>
					<term>Connectivity Encoding</term>
					<term>Polygon Meshes</term>
					<term>Curves &amp; Surfaces</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Encoders for triangle mesh connectivity based on enumeration of vertex valences are among the best reported to date. They are both simple to implement and report the best compressed file sizes for a large corpus of test models. Additionally they have recently been shown to be near-optimal since they realize the Tutte entropy bound for all planar triangulations.</p><p>In this paper we introduce a connectivity encoding method which extends these ideas to 2manifold meshes consisting of faces with arbitrary degree. The encoding algorithm exploits duality by applying valence enumeration to both the primal and dual mesh in a symmetric fashion. It generates two sequences of symbols, vertex valences and face degrees, and encodes them separately using two context-based arithmetic coders. This allows us to exploit vertex and/or face regularity if present. When the mesh exhibits perfect face regularity (e.g., a pure triangle or quad mesh) and/or perfect vertex regularity (valence six or four respectively) the corresponding bit rate vanishes to zero asymptotically. For triangle meshes, our technique is equivalent to earlier valence driven approaches.</p><p>We report compression results for a corpus of standard meshes. In all cases we are able to show coding gains over earlier coders, sometimes as large as 50%. Remarkably, we even slightly gain over coders specialized to triangle or quad meshes. A theoretical analysis reveals that our approach is near-optimal as we achieve the Tutte entropy bound for arbitrary planar graphs of 2 bits per edge in the worst case.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Encoding connectivity is an important component (next to geometry coding) of all surface compression algorithms to date. This is true for single rate and progressive coders and independent of the surface primitive, e.g., piecewise linear, NURBS, subdivision, or multiresolution patches.</p><p>Much of the previous work in this area has been concerned with methods applicable to triangle and quad meshes and has reached some sophistication both in terms of observed and worst case performance. Comparatively little work has been dedicated to the harder problem of connectivity encoding of 2-manifold graphs with arbitrary face degrees and vertex valences (see the examples in Figure <ref type="figure">1</ref>). FIG. <ref type="figure">1</ref> Examples of polygon meshes: (left) Beethoven mesh (2812 polygons, 2655 vertices) -(right) Galleon mesh (2384 polygons, 2372 vertices). Close-up of a polygon mesh: the valence of a vertex is the number of edges incident to this vertex, while the degree of a face is the number of edges enclosing it. Both are in general unconstrained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Goals and Contributions</head><p>We propose an extension of the best known single-rate triangle mesh connectivity encoding techniques-which are based on valence enumeration <ref type="bibr" target="#b21">[22,</ref><ref type="bibr">1]</ref>-to the encoding of polygon meshes. Our strategy, which is based on encoding all vertex valences and face degrees is near-optimal, i.e., it guarantees the bit rate bound for a planar polygon graph established by Tutte <ref type="bibr" target="#b24">[25]</ref> assuming a sub-linear number of split symbols. The implementation of the algorithm is straightforward and its compression performance improves upon all results reported earlier. The latter is true even for coders which are specialized for triangle or quad meshes. Additionally we describe our context-based entropy coder which further improves coding performance by exploiting common patterns in meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND AND OVERVIEW</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Basic Definitions</head><p>The specification of a polygon mesh (Figure <ref type="figure">1</ref>(left)) consists of topologic quantitiesvertices, edges, and faces-and geometric quantities-attributes such as vertex positions, face colors, etc. Our interest here is in efficient encoding of topology. Connectivity describes the incidences between elements and is implied by the topology. For example, two vertices or two faces are adjacent if there exists an edge incident to both.</p><p>As depicted in Figure <ref type="figure">1</ref>(right), we will call the number of edges incident to a vertex its valence, while the number of edges incident to a face will be denoted its degree. The ring of a vertex is the ordered list of all its incident faces. Bit rates will be given in bits per vertex (b/v), bits per edge (b/e), and bits per face (b/f ) as required. The total number of vertices, edges, and faces of a mesh will be denoted V , E, and F respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Related Work</head><p>The related work on single rate coders falls into two major groups of algorithms: those specific to triangle meshes, and those for more general polygon meshes. We review these in turn.</p><p>Triangle Meshes Early work was motivated by the desire to render triangle meshes quickly. Deering <ref type="bibr" target="#b4">[5]</ref> proposed generalized triangle strips coupled with a vertex cache consuming on average 10 b/v. Bar-Yehuda and Gotsman <ref type="bibr" target="#b1">[2]</ref> provided a theoretical study of the cache/compression tradeoff. Speed was also a main concern for Chow <ref type="bibr" target="#b2">[3]</ref> and Gumhold <ref type="bibr" target="#b6">[7]</ref>. Focusing more on absolute compression ratios, Taubin and co-workers designed the "topological surgery" scheme <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref> which is capable of adapting to connectivity regularity, resulting in 1 b/v for very regular meshes and 4 b/v on average otherwise.</p><p>Subsequently, Rossignac introduced EdgeBreaker <ref type="bibr" target="#b15">[16]</ref>, a better and simpler traversal technique focusing on edges and introducing the concept of active gate. The mesh is traversed by moving to the incident face across an active gate, followed by moving the active gate to the new face. This algorithm has an upper bound of 4 b/v for triangle meshes. A number of improvements to the algorithm <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b16">17]</ref> and its theoretic bounds <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b5">6]</ref> have followed.</p><p>In 1998 Touma and Gotsman <ref type="bibr" target="#b21">[22]</ref> pioneered a novel vertex-based traversal scheme that provides a natural adaptation to triangle mesh regularity through entropy coding. In contrast to all previous methods, the traversal results in V rather than F tokens, decreasing the bit rate to 2 b/v on average and vanishing to zero for regular meshes. Alliez and Desbrun [1] recently explained the excellent performance of such algorithms by analyzing the entropy of the list of all valences and showing that it is optimal. There are however exceptional symbols (splits) for which no non-trivial bound is yet known (hence the claim of "near"-optimality). As a practical solution they proposed an adaptive traversal control heuristic which reduces the number of splits to get closer to the optimal bit rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Arbitrary Polygon Meshes</head><p>Given that a polygon mesh with the same number of vertices contains less edges than a triangle mesh it should be possible to encode it with fewer bits. However, initial attempts to compress general graphs <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b10">11]</ref> led to rates of around 9 b/v. These methods are based on building interlocking spanning trees for vertices and faces. Consequently, the number of edges becomes the natural measure of planar graph size, in turn governing the encoding size. Chuang et al. <ref type="bibr" target="#b3">[4]</ref> later described a more compact encoding via canonical ordering and multiple parentheses. They state that any simple 3-connected plane graph can be encoded using at most 1.5 log 2 (3)E + 3 2.377 bits per edge.</p><p>Li and Kuo <ref type="bibr" target="#b14">[15]</ref> pioneered a dual approach that traverses the edges of the dual mesh and outputs a variable length sequence of symbols based on the type of a visited edge. The final sequence is then encoded using a context based entropy encoder.</p><p>Isenburg and Snoeyink encoded the connectivity of polygon meshes along with their properties in a method called Face Fixer <ref type="bibr" target="#b9">[10]</ref>. This algorithm is gate-based and generalizes the EdgeBreaker algorithm while adding the notion of a face degree. A complete traversal of the mesh is organized through successive gate labeling along an active boundary loop. As in <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b15">16]</ref> both the encoder and decoder need a stack of boundary loops. Seven distinct labels F n , R, L, S, E, H n and M i,k,l are used in order to describe the way to fix faces or holes together while traversing the current active gate. The labels F n correspond to face degrees and are limited to the range <ref type="bibr">[3 -5]</ref> thanks to an additional special symbol F c . Since the final sequence of symbols exhibits strong correlation the authors used an order-3 arithmetic coder. King et al. <ref type="bibr" target="#b12">[13]</ref> and Kronrod and Gotsman <ref type="bibr" target="#b13">[14]</ref> also generalized the EdgeBreaker method to arbitrary polygon meshes. For the former quad meshes are encoded with 3 b/v and for the latter quad meshes are encoded with 3.5 b/v and quadrilateral meshes containing a minority of triangles with 4 b/v. However, none of these polygon mesh encoders come close to the bit rates of any of the best, specialized encoders <ref type="bibr" target="#b21">[22,</ref><ref type="bibr">1]</ref> when applied to triangle meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Key Concept: Duality</head><p>In addition to the previous work analysis, we make the following observation. Consider an arbitrary 2-manifold triangle graph M. Its dual graph M, in which faces are represented as dual vertices and vertices become dual faces (see Figure <ref type="figure" target="#fig_1">2</ref>), should have the same connectivity entropy: dualization neither adds nor removes information. The valences of M are now all equal to 3, while the face degrees take on the same values as the vertex valences of M. Since a list of all 3s has zero entropy, just encoding the list of degrees of M would lead to the same bit rate as found for the valences of M. Conversely, if a polygon mesh has only valence-3 vertices, then its dual would be a triangle mesh. Hence its entropy should be equal to the entropy of the list of its degrees.</p><p>The above observation leads us to the key concept of this paper: our compression algorithm should be dual, in the sense that both a mesh and its dual get encoded with the same number of bits. As a direct consequence, the encoding process should be symmetric in the coding of valences and degrees. In fact, we will show in the Appendix that encoding each separately realizes the enumeration bound of Tutte. A second direct consequence is that the bit rate of a mesh should be measured in b/e, since the number of edges is the only variable not changing during a graph dualization. However, for purposes of comparison with earlier work we will report comparative results in b/v in Section 4. Note: While this paper was in review, we learned about a similar approach concurrently developed in independent work by Isenburg <ref type="bibr" target="#b7">[8]</ref>. It also exploits the idea of dual mesh entropy and lends additional support to the usefulness of this approach. We refer the interested reader to <ref type="bibr" target="#b7">[8]</ref> for additional details.</p><formula xml:id="formula_0">F6 -V4 -V4 -V4 -V4 -V4 -V4 F4 -V4 -V4 F4 -V5 F3 -V4 F4 -V4 F3 -V5 F4 -V4 F4 -V4 -V5 F4 -V3 -V4 F4 -V5 F4 -V3 -V4 F4 -V5</formula><p>FIG. <ref type="figure">3</ref> Example of a simple traversal sequence starting from a seed face. At the beginning, the seed face degree is output along with the valence of all its vertices. The first vertex then becomes active and the next face is traversed in counterclockwise order, resulting in one face degree and two vertex valences output. The traversal keeps going until all the faces and vertices have been visited.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Overview of our Approach</head><p>In this paper, we propose a unified and simple solution for connectivity encoding of triangle, quad and polygon 2-manifold meshes with arbitrary topology and any number of components or boundaries.</p><p>The basic technique underlying our algorithm is similar to most connectivity compression methods. A seed face is chosen and all its neighbors are traversed recursively until all faces of the corresponding connected component are visited. A new seed face of the next connected component is then chosen and the process continues. Every time the encoder traverses the next element of the mesh, it outputs some symbol which uniquely identifies a new state. From this stream of symbols, the decoder can reconstruct the mesh. Various encoding algorithms differ in the way they actually traverse a mesh and in the sets of symbols used for identifying the encoder state.</p><p>As we have seen in the previous work section, a generalization of the gate-based approach to arbitrary polygon meshes was suggested in <ref type="bibr" target="#b9">[10]</ref>. In the present paper we propose a generalization of the second, vertex-based approach. Because of the duality properties of our approach, it may equivalently be viewed as a face-based approach. We use two sets of symbols to encode vertex valences and face degrees. At any given moment both encoder and decoder will know which type of symbol (face or vertex) they are dealing with. Consequently, if the input mesh contains only faces of fixed degree (all triangles or all quads, for example), the corresponding stream will be compressed to near zero b/f by an entropy coder leaving only a vertex valence stream. Conversely, if the mesh has faces of varying degrees, but all vertices have the same valence, we get a zero entropy vertex stream. Note that the FaceFixer algorithm also uses face degrees, so it can take advantage of a mesh with uniform face degrees, but not of one with uniform vertex valences. The shark model exemplifies such a case (see Table <ref type="table" target="#tab_1">2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ENCODING ALGORITHM</head><p>In this section we give a complete, yet informal description of our algorithm, including the data structures needed. Pseudo code giving exact details is included in the Appendix. We also discuss the optimality of our approach, and show that encoding both the valence and degree lists exactly matches the worst-case entropy for a planar graph as established by Tutte <ref type="bibr" target="#b24">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data Structures</head><p>We maintain only vertex and face data structures explicitly. Vertices store their valence and references to all incident faces in counterclockwise order. Similarly, a face stores its degree and references to all incident vertices in counterclockwise order. Vertices as well as faces go through a sequence of states: empty, active, and complete. At any given time at most one face is active, but there may be multiple vertices active. These are held in the active vertex queue. When a face is processed-moved from empty to active to complete states-all its vertices, which are not yet active, are activated through insertion into the active vertex queue. Consequently, each active vertex has at least one complete incident face. As soon as all the faces incident to a vertex have become complete, the vertex changes its state to complete and is removed from the queue. Thus, the active vertex queue represents the boundary between the part of the mesh which has already been traversed and the part as yet to be visited.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Traversal Strategy</head><p>Initialization step We start the mesh traversal by picking an initial seed face. The encoder outputs the degree of this face, followed by the valences of all the vertices incident to this face in counterclockwise order. These vertices are added to the queue. Conversely, the decoder receives the seed face degree and creates a corresponding face. It then fills all the slots for the incident vertices, moving them from the empty to active state, i.e., enters them into its queue. In this way encoder and decoder maintain matching states.</p><p>Completing the vertices The traversal continues by removing the highest priority active vertex from the queue and making it the current vertex. We will discuss heuristics for queue priority assignment in Section 3.3.</p><p>The algorithm proceeds counterclockwise around the active vertex, skipping all faces which have already been completed. Recall that at least one face is completed and at least one incident face is still empty, otherwise the vertex would not be in the active queue. When the encoder detects an empty face-empty slot in the incident face data structure associated with the current vertex-it proceeds through the following steps:</p><p>‚Ä¢ the face is activated, it becomes the "current" face, and its degree is output;</p><p>‚Ä¢ the current face is added to the appropriate slot in the incident face data structures of the current vertex as well as any other active vertices which are incident to current face; ‚Ä¢ any remaining empty vertices of the current face are activated and their valences output in counterclockwise order; ‚Ä¢ the current face is complete and removed from processing. Notice that we alternately turn around vertices and faces (see Figure <ref type="figure">3</ref>). The active vertex and the subsequently picked active face can be considered as successive pivots, extending the traversal proposed in <ref type="bibr">[1]</ref>.</p><p>The decoder follows a symmetric procedure, ensuring the same ultimate traversal. When it finds the first empty face slot in the currently active vertex, it proceeds as follows:</p><p>‚Ä¢ read in a face degree and create the face, moving it from state "empty" to "active," calling it the "current" face; ‚Ä¢ add the current face to the appropriate slot in the active vertex and any other active vertices it is incident on (while the encoder could read off this information the decoder must deduce it and we detail this procedure below); ‚Ä¢ read the valences of the remaining empty vertices incident on the current face, activating them through insertion into the active vertex queue; ‚Ä¢ move the current face to the complete state. Any vertices completed during the traversal of the current face are removed from the active vertex queue. They no further belong to the boundary of the traversed region. After the current face is processed the algorithm proceeds to the next face in the currently active vertex until it is complete. Subsequently a new active vertex is taken from the queue and the process repeats until the active vertex queue is empty. If there are some connected components remaining, a new seed face is chosen on it and another component traversal starts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Details of face insertion</head><p>The procedure that inserts the current face in active vertices other than the current vertex is the only non-trivial operation during the traversal. From the current vertex, we "walk" along the boundary of the visited region in both directions to find which vertices are incident to the current face. The corresponding active vertices will get the current face inserted in their corresponding slots. Since the current face was created to fill the first empty slot in the current vertex we know it shares an edge with the non-empty face slot immediately preceding it in the current vertex (see Figure <ref type="figure">4</ref> for an example). For convenience, let us call the shared edge between these two faces the current edge. It follows that the current face should also be inserted in the active vertex associated with the other end point of the current edge. Further it is known into which face slot in that vertex the current face should be inserted. Iteratively we check whether the preceding face slot in that ring is non-empty. If it is, we update the current edge accordingly and continue as long as we can update the current edge. Once stopped we attempt the same walk in the other direction from the active vertex. Notice that both the encoder and the decoder use the same procedure to find the relevant vertices. Hence the decoder will be able to interpret the subsequent valence transmission(s) with respect to the correct slots in the current face.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIG. 4</head><p>Insertion of a face and connection to the existing mesh. First we add the face to the active ring. Next we travel along the boundary adding the new face to all adjacent vertices, first in one direction then in the other. Finally, we insert the remaining (white) vertex based on the valence code received.</p><p>Boundaries We deal with boundaries by inserting dummy faces to close every hole of the mesh. The traversal algorithm remains unchanged, and all dummy faces are processed in the same way as regular faces. The only modification is that the valences of dummy faces are encoded using a different symbol so that the decoder can remove them later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Splits</head><p>Recall that when the decoder creates the current face, all the vertices which can be obtained from neighboring faces are already active. Alas, it is also possible that the current face is incident to an active vertex, without this fact being deducible (see Figure <ref type="figure">5</ref>). We call such a situation a split since locally a single component of the boundary of the visited region is split into two sub-boundaries when this situation occurs. The other possible case is that the unreachable vertex belongs to a different boundary component. Such a situation is usually referred to as a merge <ref type="bibr" target="#b21">[22,</ref><ref type="bibr">1]</ref>. Since we only keep a single queue of all boundary vertices without distinguishing between different components, we do not make a distinction between boundary splits and merges. Instead, we refer to both cases as splits, simplifying the implementation.</p><p>Splits must happen when encoding non-zero genus models, since a regular traversal always creates regions topologically equivalent to disks. Unfortunately, splits may also occur for models of genus zero. We will see that the traversal order can be optimized to minimize the number of splits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIG. 5</head><p>The black vertex demonstrates the split situation. This vertex already exists in a visited region, but the current (dashed) face cannot find it from its immediate neighbors.</p><p>If the encoder detects a split situation, i.e., it is about to activate a vertex which is already active, it outputs a special split symbol instead of the valence. This symbol is followed by the current index of the split vertex in the active vertex queue. The index of the current face in the list of faces incident to the split vertex is also output in order to fully specify the split.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Heuristic for Traversal Order</head><p>Since the split operations are potentially expensive we want to minimize them. Following the approach detailed in [1], we optimize the traversal order by managing the queue priorities based on a heuristic. The priority of each vertex in the queue is inversely proportional to its "incompleteness," i.e., the number of empty face slots in a ring. This heuristic favors completion of "almost complete" rings. Such rings are usually located in concave sections of the boundary between the visited and non-visited parts of the mesh. Empirically, these are the main source of splits. Hence, the heuristic tends to avoid the formation of such regions, decreasing the number of splits. A number of other heuristics of higher complexity were also suggested in [1] and could be used here to achieve potentially better coding performance. To ensure synchronization, both encoder and decoder use the same heuristic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Entropy Coding</head><p>The output of the traversal algorithm just described consists of a stream of face degree symbols and a stream of vertex valence symbols. These streams could be encoded by any efficient context-based arithmetic coder (AC). Each stream has its own set of context tables. A simple coder can use just one context table per stream. Such a coder is appropriate if the mesh is small or if the encoding stream has a very regular symbol pattern. In general, better encoding results are achieved by using multiple contexts for each stream. Such contexts allow to better exploit both correlations between streams, and between symbols within each stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1.">Symbol Definitions</head><p>We define 15 symbols for the face degree stream and 16 symbols for the vertex valence stream. Symbols "3"-"15" correspond to actual valences or degrees. The symbol "2" represents valence 2 in the vertex stream and the B (for boundary) symbol in the face stream. The symbol "1" is an ESC symbol for encoding larger valences or degrees. Finally, the symbol "0" is the Split code in the vertex stream and is not used in the face stream. B and ESC symbols are followed by the actual degree or valence number (offset, so 16 is mapped to 0). The Split symbol requires the encoding two extra numbers: the index of the split vertex in the active vertex queue and of the current face index in the split vertex. We encode them with a uniform context on the interval [0..N -1]. For the queue index N is the size of the queue at that moment. For the index of the current face in the split vertex incident face list, N is taken to be the number of empty slots in the split vertex.</p><p>If, for a particular stream, only one context is used, the corresponding context table is saved exactly in the file header. In the case when many contexts are used (see below), it is too expensive to save exact tables. Instead, we save only the positions of the most significant bit of all counters. These are used to initialize contexts with approximate distributions. Tables are then updated by an adaptive arithmetic coder. The cost of encoding a non-empty table is 2-3 bytes on average compared to 10-12 bytes for encoding of an exact table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2.">Our Statistical Model</head><p>The face and vertex streams are encoded using multiple contexts. The appropriate context is chosen based on already-known information about neighboring faces and vertices. This approach is different from using a higher-order arithmetic coder which uses a number of previously processed symbols to define the new context. The latter approach is less advantageous, since some of the previous symbols may correspond to faces or vertices which are not relevant to the current symbol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Face degrees</head><p>The context for a face degree symbol F is determined by the degree of the previous face F p in the same active ring and the sum V av of valences of the vertices on the edge between the current and the previous faces.</p><p>In particular, we separately consider most common degrees 3, 4, 5. If F p has some other degree we encode the symbol F with a default context. The same default context is used when there is no previous face. We use three different contexts for each of degrees 3 and 4 and just one context for a less common degree 5. We decide between three possible contexts depending on</p><formula xml:id="formula_1">V av &lt; V crit , V av = V crit , V av &gt; V crit where V crit = 12 if F p is a triangle and V crit = 8 if F p is a quad.</formula><p>Vertex valences are encoded with 8 contexts in a similar way to face degrees. The context for the vertex V is determined by the degree of the face F which contains this vertex and the sum V av of valences of all know vertices in that face.</p><p>We use three contexts if F is a triangle or quad, one context for degree 5 and one context for other degrees. If F is a triangle or a quad we distinguish between three possible contexts depending on</p><formula xml:id="formula_2">V av &lt; N v ‚Ä¢ V crit , V av = N v ‚Ä¢ V crit , or V av &gt; N v ‚Ä¢ V crit ,</formula><p>where N v is a number of known vertices and V crit is 6 for triangles and 4 for quads.</p><p>Discussion The motivation for using such contexts is that the average valence of vertices in quad and triangle regions are different. Therefore, there is a correlation between the vertex or face symbol to encode and the average valence of known neighboring vertices.</p><p>We have found the above heuristics to generally improve the coding of meshes. We have experimented our technique on the large SNHC database, and on average, a gain of 13% is observed when we use our simple statistical model over a direct encoding (slightly worse bitrates are obtained only for small meshes). We also show in Table <ref type="table">1</ref> that using only contexts based on valences or degrees is consistently worse than our mixed strategy on this 3D database. Although one could adjust this strategy to perform better on a given corpus of meshes, our choice seems a good compromise for the typical meshes used in graphics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bytes</head><p>using VF (%) using V (%) using F (%) shows the group. The second column shows the relative improvement when using multiple contexts. Third and forth column show improvement when using multiple contexts only on vertex, and face streams respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Optimality</head><p>Alliez and Desbrun [1] have recently proven that the list of valences of a triangle mesh is an exact entropy measure of connectivity. The worst case scenario fits the theoretical results of Tutte <ref type="bibr" target="#b23">[24]</ref> of log 2 (256/27) ‚âà 3.24 bits per vertex, while regularity in valence leads to almost zero entropy. In Appendix A we prove, using a similar approach, that the entropy of the two lists of valences and degrees also matches the counting results of Tutte for general, 3-connected graphs <ref type="bibr" target="#b24">[25]</ref>. This proves the "near-optimality" of our approach: under the assumption that only a sub-linear number of splits is produced during encoding, the bit rate of our encoder is asymptotically optimal. This assumption of a small number of splits holds for all the meshes we tried. Note though that it is possible to produce "pathological" meshes which will cause a linear number of splits to occur under all heuristics we have considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">RESULTS</head><p>We begin with a performance comparison of our algorithm and the FaceFixer coder. Table <ref type="table" target="#tab_1">2</ref> shows the results of compression for a set of standard models (see Figure <ref type="figure">6</ref>) both in total bytes and b/v. The average improvement is approximately 20%. The most significant improvement is achieved for the shark model: most of the vertices in this model have the same valence. Because of the separation of vertex and face information in our coder, the vertex information was encoded at practically no cost, leading to a factor 2 improvement in bit rate performance. In Tables <ref type="table">3</ref> and<ref type="table" target="#tab_3">4</ref>, we also compare our polygon mesh coder to the Touma-Gotsman (TG) and Alliez-Desbrun (AD) triangle mesh coders on sets of irregular and semi-regular triangle meshes. As expected, all these algorithms exhibit essentially similar performance. Comparison between the FaceFixer algorithm and our approach. The second column shows the number of vertices in the polygon mesh; the third column shows the number of splits, the fourth and fifth columns show the size of the compressed file in total bytes and b/v; the sixth column shows the performance of FaceFixer while the last column shows the improvement.  <ref type="table">3</ref> The table compares Touma-Gotsman (TG), Alliez-Desbrun (AD), and our compression scheme on a number of irregular triangle meshes. The second column shows the number of vertices in the models and the last column shows the number of splits. The coder performances are expressed in b/v.</p><formula xml:id="formula_3">model V TG(b/v) AD(b/v) our(b/v) splits</formula><p>Lastly, we compressed the connectivity of adaptively tessellated Catmull-Clark surfaces (Table <ref type="table" target="#tab_4">5</ref>). These meshes contain mostly quads, but also have a number of "conforming" triangles in the transition regions between different levels of tessellation (see Figure <ref type="figure">6</ref>).</p><p>These tables all indicate the better bit rates for polygon meshes, and similar or slightly better results for triangle meshes over the best available coders known as of today. This confirms the notion of near-optimality of our algorithm as proven by our simple entropy analysis. There is however no doubt that it is possible to design better encoders for a specific corpus of meshes by adapting or fine-tuning the statistical modeling we implemented. Our current implementation processes all tested meshes in less than two seconds on a PIII 933MHz computer. The set of models we used for comparison can be found at http://www.multires. The table shows performance of our coder on large adaptively tessellated Catmull-Clark surfaces. Because of the adaptivity, the meshes contain triangles at the interfaces between regions of different tessellation depth. The second column shows the number of vertices in the model and the last column shows the number of splits. The coder performance is expressed in both total bytes and b/v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSION AND FUTURE WORK</head><p>We have presented a unified technique for connectivity compression of 2-manifold polygon meshes. It performs near-optimally on all major types of meshes encountered in practice: triangle, quad and general polygon meshes. Our algorithm exploits duality by encoding separately the list of vertex valences and the list of face degrees. Vertex and/or face regularity can therefore be fully exploited. Additionally, we show that encoding these two lists is in perfect agreement with previous theoretical analyses <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref>, and leads to a worst-case of 2 b/e on arbitrary meshes, and of 3.24 b/v for triangulations. We also provide a statistical model for the entropy coding that improves compression ratios further by exploiting local regularities in valence and degree distributions. These are found quite commonly in all the meshes we examined. Our implementation demonstrates the compression gains of this polygon mesh compression technique over all previously published techniques, on all tested meshes. The very same algorithm even outperforms most of the previous encoders which were specifically tuned to triangle or quad meshes when applied to such specialized inputs.</p><p>Possible future work includes the generalization of this approach to volume meshes, FIG. <ref type="figure">6</ref> Polygon and mixed triangle/quad meshes used in our table of results.</p><p>including tetrahedron or hexahedron meshes. This would require vertex, face and edge valences to be encoded. An extension to non-manifold meshes would also be very relevant for practical applications. Finally we hope to build more sophisticated statistical models of valence and degree distributions based on larger corpora of meshes, to further improve the compression performance.</p><p>APPENDIX A: ENTROPY ANALYSIS Consider a 2-manifold polygon mesh M with V vertices, E edges, and F faces, and the following standard assumptions on the mesh:</p><p>‚Ä¢ it has no boundary, i.e., every edge has two incident faces;</p><p>‚Ä¢ it is topologically equivalent to a sphere, i.e., has genus zero;</p><p>‚Ä¢ it has only one connected component. For the sake of clarity, we also define r to be the ratio between the number of faces and the number of vertices, r = F/V . Typical examples for r are 2, 1 and 0.5 for triangle, quad and hex meshes respectively (see Figure <ref type="figure">7</ref>). If a mesh has no digon, no stick and no isolated vertex, r lies in the range [0.5, 2]. FIG. <ref type="figure">7</ref> Left: a triangle mesh (r = 2), average vertex valence 6. Middle: a quad mesh (r = 1), average vertex valence 4. Right: a hex mesh (r = 0.5), vertex valence 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Entropy of a code sequence</head><p>The entropy is a measure of the information content of a series of symbols. More precisely, it denotes the minimal number of bits per symbol required for lossless encoding of the sequence. It is both a function of the number N of distinct symbols and their respective probabilities</p><formula xml:id="formula_4">p i entropy = N i=1 p i log 2 1 p i .</formula><p>The final bit rate of a connectivity encoding technique is therefore intricately related to the statistical distribution of the symbols used. Next, we review the constraints on the distribution of vertex valences and face degrees in an arbitrary polygon mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Euler formula</head><p>Euler's formula for a 2-manifold polygon mesh of genus zero, one connected component and no boundary states:</p><formula xml:id="formula_5">F + V -E = 2.</formula><p>(1)</p><p>Additional relations between the number of edges and valences, respectively degrees, are:</p><formula xml:id="formula_6">N i=3 v i = 2E and M j=3 f j = 2E.</formula><p>These simply state that summing all valences, respectively degrees, counts each edge twice. These sums may be rewritten by summing over all possible valences, respectively degrees, the number of times each occurs. The latter is most conveniently expressed through the use of probabilities of occurrence of each valence and degree. Let the former be given by p i for i = 3, . . . , ‚àû and the latter by q j for j = 3, . . . , ‚àû to give:</p><formula xml:id="formula_7">V ‚àû i=3 i p i = 2E and F ‚àû j=3 j q j = 2E.<label>(2)</label></formula><p>Solving Eq. 1 for E, substituting into Eqs. 2, dividing by V and F respectively we arrive at the following expressions for the average vertex valences and face degrees:</p><formula xml:id="formula_8">v = ‚àû i=3 i p i = 2E V = 2(r + 1), f = ‚àû j=3 j q j = 2E F = 2( 1 r + 1),<label>(3)</label></formula><p>where the last equality holds in the limit as V respectively F go to infinity. Note that these equations confirm the canonical cases shown in Figure <ref type="figure">7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Worst asymptotic bit rate vs. Tutte's enumeration</head><p>The algorithm described in this paper encodes both the vertex valence list and the face degree list. The entropy of the valences is:</p><formula xml:id="formula_9">e 1 = ‚àû i=3 p i log 2 (1/p i ) [b/v],</formula><p>while that for the degrees is:</p><formula xml:id="formula_10">e 2 = ‚àû j=3 q j log 2 (1/q j ) [b/f].</formula><p>Multiplying through by the ratios V /E and F/E found in Eq. 3 one can express the total bit rate e, i.e., the sum of both bit rates, in units of b/e:</p><formula xml:id="formula_11">e = 1 r + 1 e 1 + r r + 1 e 2 = ‚àû i=3 p i log 2 (1/p i ) + r ‚àû j=3 q j log 2 (1/q j ) r + 1 . (<label>4</label></formula><formula xml:id="formula_12">)</formula><p>Our goal in the remainder of this section is to find the maximum possible entropy e for arbitrary meshes with r ‚àà [0.5, 2]. Maximizing Eq. 4 each as a function of p i and q j without any additional constraints would lead to both a maximum number of distinct face degrees and vertex valences, each with an equal probability of occurrence. However, such a configuration of valences and degrees is incompatible with Euler's formula. This leads us to a constrained maximization problem.</p><p>There are a total of four constraints on the p i and q j . Two are given by Eq. 3 with two additional constraints simply stating that the p i and q j have to sum to one: This coincides exactly with the minimum number of bits needed to encode each edge of an arbitrary planar graph found by Tutte <ref type="bibr" target="#b24">[25]</ref> through enumeration of all possible genus-0 3-connected graphs. The fact that we meet the exact entropy of general polygon meshes validates a posteriori our approach of encoding independently the valence and degree lists. This, by no means, should be confused with a claim of optimality for a given corpus of meshes: it simply means that over the whole set of polygon meshes, one can not hope to devise a connectivity algorithm requiring a smaller maximum number of bits. As we mentioned in Section 4, better algorithms could be designed for a restricted set of meshes.</p><p>Notice that e(2) = 1.08 b/e 3.24 b/v for a triangle mesh, exhibiting the upper bound of log 2 (256/27) b/v proven by Tutte from the enumeration of planar triangulations <ref type="bibr" target="#b23">[24]</ref>. The maximum entropy is the same when r = 0.5, confirming our remark that a mesh and its dual should have the same entropy. Meshes for which r = 0.5 are duals of triangle meshes. More generally, we observe that e(r) = e(1/r), i.e., primal and dual meshes have equal entropy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX B: PSEUDO-CODE OF OUR TRAVERSAL ALGORITHM</head><p>In the following pseudo-code we use a Face class and a Vertex class such as each face has access to its degree and to an array of its vertices, and each vertex has access to its valence and an array of its adjacent faces. We further assume that any access to a vertex (resp., face) array is done modulo the degree (resp., the valence), to avoid unnecessary index testing. "ActiveSet" is a container for all active vertices. Finally, the following functions have to be implemented in the decoder and the encoder to perform actual I/O operations (read for the decoder, write for the encoder):</p><p>Face* ioFace (v, j) -i/o a degree. Returns a face Face* ioFaceInit () -likewise, but just to bootstrap. Returns 0 if Done Vertex* ioVertex (f,i) -i/o a valence or a Split code. Returns Vertex or 0 (if split) int ioSplitVertex (f,i) -i/o a vertex index in ActiveSet, int ioSplitPos (f,i); -i/o a face position in a vertex array // Entry point void run ( ) { while ( runComponent () ! = Done ) ; }</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIG. 2</head><label>2</label><figDesc>FIG.2Left: a polygon mesh with highlighted faces of degree 3 and 5. Middle: the dual mesh is built by placing one node in each original face and connecting them through each edge incident to two original faces. Right: the dual mesh now contains corresponding vertices of valence 3 and 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIG. 8</head><label>8</label><figDesc>FIG.8Plot of the worst-case bit rate e(r) in units of b/e.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="14,88.94,498.48,400.08,172.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Compression results for the 1296 manifold models from the SNHC database. The results were sorted by the size of the compressed files and averaged by groups. The first column</figDesc><table><row><cell>1-100</cell><cell>-3.88</cell><cell>-15.52</cell><cell>-3.08</cell></row><row><cell>100-200</cell><cell>6.99</cell><cell>-4.24</cell><cell>5.85</cell></row><row><cell>200-400</cell><cell>15.20</cell><cell>-0.97</cell><cell>12.88</cell></row><row><cell>400-1000</cell><cell>20.61</cell><cell>0.05</cell><cell>18.86</cell></row><row><cell>1k-5k</cell><cell>19.95</cell><cell>1.67</cell><cell>17.57</cell></row><row><cell>5k-10k</cell><cell>21.33</cell><cell>5.13</cell><cell>15.94</cell></row><row><cell>10k-85k</cell><cell>19.82</cell><cell>7.68</cell><cell>11.77</cell></row><row><cell>All</cell><cell>13.01</cell><cell>-2.76</cell><cell>11.15</cell></row><row><cell></cell><cell></cell><cell>TABLE 1</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 2</head><label>2</label><figDesc></figDesc><table><row><cell>model</cell><cell>V</cell><cell cols="5">splits size(B) size(b/v) FF(b/v) gain</cell></row><row><cell>al</cell><cell>3618</cell><cell>10</cell><cell>1128</cell><cell>2.50</cell><cell>2.926</cell><cell>15%</cell></row><row><cell cols="2">beethoven 2655</cell><cell>18</cell><cell>763</cell><cell>2.30</cell><cell>2.890</cell><cell>20%</cell></row><row><cell>cessna</cell><cell>3745</cell><cell>42</cell><cell>1204</cell><cell>2.57</cell><cell>2.841</cell><cell>9%</cell></row><row><cell>cow</cell><cell>2904</cell><cell>11</cell><cell>638</cell><cell>1.76</cell><cell>2.213</cell><cell>21%</cell></row><row><cell>cupie</cell><cell>2984</cell><cell>19</cell><cell>665</cell><cell>1.78</cell><cell>2.307</cell><cell>23%</cell></row><row><cell>galleon</cell><cell>2373</cell><cell>17</cell><cell>621</cell><cell>2.09</cell><cell>2.595</cell><cell>19%</cell></row><row><cell>sandal</cell><cell>2636</cell><cell>50</cell><cell>749</cell><cell>2.27</cell><cell>2.602</cell><cell>13%</cell></row><row><cell>shark</cell><cell>2560</cell><cell>19</cell><cell>265</cell><cell>0.83</cell><cell>1.670</cell><cell>50%</cell></row><row><cell>teapot</cell><cell>1189</cell><cell>7</cell><cell>182</cell><cell>1.22</cell><cell>1.669</cell><cell>27%</cell></row><row><cell cols="2">tommygun 4171</cell><cell>47</cell><cell>1199</cell><cell>2.30</cell><cell>2.611</cell><cell>12%</cell></row><row><cell cols="2">triceratops 2832</cell><cell>45</cell><cell>455</cell><cell>1.28</cell><cell>2.115</cell><cell>39%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 4</head><label>4</label><figDesc>This table compares Touma-Gotsman (TG), Alliez-Desbrun (AD), and our coder on a number of semi-regular triangle meshes. The second column shows the number of vertices in the models and the last column shows the number of splits. The coder performances are expressed in b/v.</figDesc><table><row><cell>caltech.edu/software/ircomp</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 5</head><label>5</label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments The work reported here was supported in part by the NSF (ACI-9721349, DMS-9872890, ACI-9982273, EEC-9529152, CCR-0133983). Other support was provided by Intel, Microsoft, Alias|Wavefront, Pixar, and the Packard Foundation. Additional thanks to Olivier Devillers for many discussions on the number-of-splits issue, and Craig Gotsman for access to his coder. The datasets are courtesy of Viewpoint Datalabs, Martin Isenburg, Digital Michelangelo Project, Stanford University, Cyberware, Headus, Hugues Hoppe, and The Scripps Research Institute.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Incorporating these constraints through the use of Lagrange multipliers as was done in [1], the maximum of Eq.4 can be achieved by choosing p i and q j to maximize: f (p 3 , p 4 , . . . , Œª p , ¬µ p , q 3 , q 4 , . . . , Œª q , ¬µ q ) = 1 r + 1</p><p>where Œª p , ¬µ p , Œª q and ¬µ q are the four Lagrange multipliers. Equating all derivatives of f with respect to each of the unknown variables p i and q j to zero, we find that p i and q j must follow an exponential decay:</p><p>and q j = Œ± f Œ≤ -j f . To determine the coefficients Œ± v , Œ± f , Œ≤ v , and Œ≤ f , we rewrite the constraints given by Eqs. 5 and 3 as:</p><p>Using the identities (valid for Œ≤ &gt; 1):</p><p>we find the following unique solution:  </p><p>// Create a vertex // in: a face and vertex's position i // out: an active vertex (valence and v.f</p><p>// Creates a face // in: vertex v and face's position j // out: active face (degree and f.v[0] are valid), f is "FV" consistent with v void activateF ( v, j ) { f = ioFace (v,j); // i/o degree, create face f.v[0] = v; addFaceToVertex (f, 0, v, j); } // Processes all vertices of a face f // in: an active face f (degree and f.v[0] are valid), and face's position j &gt; 0, (v.f[j-1] ! = 0) // out: all fields of f are valid, "FV" is enforced void completeF ( f, j ) { vp = f.v[0]; jp = j; i = 1; while ( vn = f.v[i] ) { // forces "FV" in "next" direction jn = vn.find ( vp.f[jp-1] )-1; vn.addFaceToVertex (f, i, vn, jn); vp = vn; jp = jn; i++; if ( i &gt;= f.degree ) return ; </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Valence-Driven Connectivity Encoding of 3D Meshes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Alliez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics 2001 Conference Proceedings</title>
		<imprint>
			<date type="published" when="2001-09">Sept. 2001</date>
			<biblScope unit="page" from="480" to="489" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Time/space Tradeoffs for Polygon Mesh Rendering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bar-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="141" to="152" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Optimized Geometry Compression for Real-Time Rendering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization 97 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="347" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Compact Encodings of Planar Graphs via Canonical Orderings and Multiple Parentheses</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Chuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-N</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Kao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="118" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Geometry Compression</title>
		<author>
			<persName><forename type="first">M</forename><surname>Deering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">New Bounds on the Encoding of Planar Triangulations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<idno>WSI-2000-1</idno>
		<imprint>
			<date type="published" when="2000-03">March 2000</date>
			<pubPlace>T√ºbingen</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Wilhelm Schickard Institute for Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Real Time Compression of Triangle Mesh Connectivity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="133" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Compressing Polygon Mesh Connectivity with Degree Duality Prediction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface</title>
		<imprint>
			<date type="published" when="2002-05-29">27-29 May 2002</date>
		</imprint>
	</monogr>
	<note>In to appear in</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Spirale</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName><surname>Reversi</surname></persName>
		</author>
		<title level="m">Reverse Decoding of Edge-Breaker Encoding. 12th Canadian Conference on Computational Geometry</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="247" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Face Fixer: Compressing Polygon Meshes With Properties</title>
		<author>
			<persName><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 2000 Conference Proceedings</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="263" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Short Encodings of Planar Graphs and Maps</title>
		<author>
			<persName><forename type="first">And</forename><surname>Keeler</surname></persName>
		</author>
		<author>
			<persName><surname>Westbrook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics and Combinatorial Operations Research and Computer Science</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<date type="published" when="1995">1995</date>
			<publisher>DAMATH</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Guaranteed 3.67V bit Encoding of Planar Triangle Graphs</title>
		<author>
			<persName><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Canadian Conference on Computational Geometry</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="146" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Connectivity Compression for Irregular Quadrilateral Meshes</title>
		<author>
			<persName><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Szmczak</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>GVU, Georgia Tech</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. TR-99-36</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient Coding of Non-Triangular Meshes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kronrod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific Graphics 2000 Conference Proceedings</title>
		<imprint>
			<date type="published" when="2000-10">october 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Mesh connectivity coding by the dual graph approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><forename type="middle">J</forename><surname>Kuo</surname></persName>
		</author>
		<idno>MPEG98 Contribution Document No. M3530</idno>
		<imprint>
			<date type="published" when="1998-07">July 1998</date>
			<pubPlace>Dublin, Ireland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Connectivity Compression for Triangle Meshes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName><surname>Edgebreaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="page" from="47" to="61" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
			<affiliation>
				<orgName type="collaboration">D Compression Made Simple</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Safonova</surname></persName>
			<affiliation>
				<orgName type="collaboration">D Compression Made Simple</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Szymczak</surname></persName>
			<affiliation>
				<orgName type="collaboration">D Compression Made Simple</orgName>
			</affiliation>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Edgebreaker on a Corner-Table</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Wrap&amp;Zip Decompression of the Connectivity of Triangle Meshes Compressed with EdgeBreaker</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="119" to="135" />
			<date type="published" when="1999-11">november 1999</date>
		</imprint>
	</monogr>
	<note>Theory and Applications</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An EdgeBreaker-based Efficient Compression Scheme for Regular Meshes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th Canadian Conference on Computational Geometry</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="257" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Geometry Coding and VRML</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="1228" to="1243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Geometric Compression Through Topological Surgery</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="115" />
			<date type="published" when="1998-04">April 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Triangle Mesh Compression</title>
		<author>
			<persName><forename type="first">C</forename><surname>Touma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1998-06">june 1998</date>
			<biblScope unit="page" from="26" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Succinct representations of graphs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Turan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="289" to="294" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A Census of Planar Triangulations</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tutte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Canadian Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="21" to="38" />
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A Census of Planar Maps</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tutte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Canadian Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="249" to="271" />
			<date type="published" when="1963">1963</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
