<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Static and Dynamic Co-Optimizations for Blocks Mapping in Hybrid Caches</title>
				<funder ref="#_m2AMGvq">
					<orgName type="full">Center for Domain Specific Computing (NSF</orgName>
				</funder>
				<funder ref="#_9ceAkKt">
					<orgName type="full">SRC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yu-Ting</forename><surname>Chen</surname></persName>
							<email>ytchen@cs.ucla.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jason</forename><surname>Cong</surname></persName>
							<email>cong@cs.ucla.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hui</forename><surname>Huang</surname></persName>
							<email>huihuang@cs.ucla.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chunyue</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Raghu</forename><surname>Prabhakar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Glenn</forename><surname>Reinman</surname></persName>
							<email>reinman@cs.ucla.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Static and Dynamic Co-Optimizations for Blocks Mapping in Hybrid Caches</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>B.3.2 [MEMORY STRUCTURES]: Design Styles -Cache memories L2 cache</term>
					<term>Hybrid cache</term>
					<term>STT-RAM</term>
					<term>Endurance</term>
					<term>Energy</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, a combined static and dynamic scheme is proposed to optimize the block placement for endurance and energyefficiency in a hybrid SRAM and STT-RAM cache. With the proposed scheme, STT-RAM endurance is maximized while performance is maintained. We use the compiler to provide static hints to guide initial data placement, and use the hardware to correct the hints based on the run-time cache behavior. Experimental results show that the combined scheme improves the endurance by 23.9x and 5.9x compared to pure static and pure dynamic optimizations respectively. Furthermore, the system energy can be reduced by 17% compared to pure dynamic optimization through minimizing STT-RAM writes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The traditional SRAM caches suffer from huge leakage power, which dominates the total energy consumption in the on-chip memory system. To alleviate this problem, emerging non-volatile memory technologies such as phase-change RAM (PRAM) and spin-torque transfer magnetoresistive RAM (STT-RAM) are used as alternative on-chip memory with the advantages of low leakage and high density. However, non-volatile memories suffer from the challenges of limited endurance, higher write latency and energy. Compared to PRAM, STT-RAM has significantly higher endurance (10 9 versus 10 12 write cycles) and shorter write latency <ref type="bibr" target="#b1">[1]</ref> and is much more promising in the last-level cache design <ref type="bibr" target="#b2">[2]</ref> [3][4] <ref type="bibr" target="#b5">[5]</ref>[6] <ref type="bibr" target="#b7">[7]</ref>. Moreover, due to the intensive writes of caches, hybrid caches consisting of both SRAM and STT-RAM are investigated <ref type="bibr" target="#b2">[2]</ref>[3][4] <ref type="bibr" target="#b7">[7]</ref>, where the SRAM can accommodate write-intensive data and the STT-RAM can accommodate other data with its dense capacity.</p><p>The STT-RAM endurance is an important issue to be considered in the last-level cache design. Although ITRS predicts the write cycles of STT-RAM will be 10 15 at 2024 <ref type="bibr" target="#b1">[1]</ref>, the best available write cycles of STT-RAM are 4 x 10 12 at present <ref type="bibr" target="#b5">[5]</ref>. Supposed we execute segmentation <ref type="bibr" target="#b8">[8]</ref>, a medical imaging application, on a 4GHz CPU with 32 KB L1 cache, 2MB STT-RAM L2 cache continuously, the lifetime of a STT-RAM cache can last only 2.17 years without any optimizations applied. The endurance problem becomes even worse in the multi-level cell (MLC) STT-RAM technology <ref type="bibr" target="#b5">[5]</ref>. Block placement optimizations is very important to shrink the large endurance gap between STT-RAM and SRAM in a hybrid cache. Recent work considers either static or dynamic schemes to optimize the block placement to reduce the average write frequency to STT-RAM cells, while maintaining the overall performance by making use of higher density of STT-RAM. Some of the proposed approaches targeted at PRAM, and those ideas can also be applied to STT-RAM with the same objective.</p><p>The first category of the prior work uses static schemes. In <ref type="bibr">[9]</ref> the authors introduce data migration and re-computation to reduce the write frequency on PRAM main memory. In <ref type="bibr" target="#b10">[10]</ref>, the partitioning of the application working set into SRAM and PRAM can reduce 79% of the writes to PRAM.</p><p>The second category of the prior work uses dynamic schemes. Recent work in <ref type="bibr" target="#b5">[5]</ref> uses periodically set-remapping to distribute the writes among sets in a STT-RAM cache. Another set of work migrates the write-intensive cache blocks to other cache lines in the same/different cache set or in the SRAM in order to reduce the average write frequency of the STT-RAM cache lines <ref type="bibr" target="#b4">[4]</ref>.</p><p>However, there exist intrinsic limitations in both approaches, which cannot be resolved independently -The static optimization decisions are made at compile time without run-time information, thus compiler may generate misleading hints to the hardware. On the other hand, pure dynamic optimization use blocked-based counter structures to learn the memory reference patterns on-thefly. However, the dynamic scheme lacks a global view of the whole program and has no knowledge to future access pattern.</p><p>In this paper, we propose a combined approach in which the static and dynamic optimizations can compensate to each other. The compiler tries to provide data placement hints to hardware to reduce STT-RAM write frequency, while the hardware is designed to be able to correct compiler hints based on runtime cache behavior. Experimental results show that the combined scheme improves the endurance by 23.9x and 5.9x compared to pure static and pure dynamic optimizations, respectively, while maintaining similar performance. Furthermore, the system energy can be reduced by 17% compared to pure dynamic optimization since STT-RAM writes are reduced through initial placement from the proposed compiler flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PROBLEM FORMULATION</head><p>In this work, we assume that the L2 cache is a hybrid cache architecture with 4-way SRAM and 12-way STT-RAM, which is similar to the setting described in <ref type="bibr" target="#b4">[4]</ref> <ref type="bibr" target="#b7">[7]</ref>. The block-level initial placement and dynamic migration is allowed to place the data blocks in either SRAM or STT-RAM. The initial placement is given by the compiler hints and the runtime cache pressure while the dynamic migration is designed with hardware mechanisms. Our assumptions in detail are described in Section 4.1 and Section 4.3 for better illustration of our co-optimization strategy.</p><p>The objective of this work is to improve the endurance of the hybrid cache and reduce system energy while maintaining performance through the combined scheme. Another meaningful objective is to co-optimize performance and energy while under the endurance constraint. A storage-efficient way to monitoring the endurance of each cache block is required under the second scenario. The discussion of this formulation is not included in this work but may be worthwhile for further investigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MOTIVATIONAL EXAMPLES</head><p>In this section, we use real-life examples to illustrate how pure static optimization and dynamic optimization may produce suboptimal block placement decisions in a hybrid cache design.</p><p>The deficiency of pure static optimization comes from the fact that the runtime write frequencies of L2 cache (which is the hybrid last-level cache in our evaluated system) blocks are inputdependent, which cannot be fully obtained offline. First, the input data may change the control flow of the program, and this will change the write frequency of the data that are affected by the control flow variation. Second, since part of the writes to the L2 cache come from the write-back operations from the L1 caches, the compiler cannot accurately capture the L2 cache write behavior with the existence of the L1 caches. For example, given the LRU replacement policy, the data which is written fewer times in the code may be frequently evicted by the L1 cache and behaves much more write-intensive in the L2 cache than other data which are written more frequently. Note that life time of the STT-RAM mainly depends on the peak write count of all the cells <ref type="bibr" target="#b4">[4]</ref> <ref type="bibr" target="#b5">[5]</ref>. Even static optimizations can reduce the total STT-RAM writes compared to dynamic optimizations via global optimization, the potential mis-predictions can still severely degrade the STT-RAM lifetime, since there is no dynamic scheme to migrate mispredicted write-intensive blocks into SRAM. This causes a large peak write count to this cell. As an example, Table <ref type="table" target="#tab_0">1</ref> shows the STT-RAM cell write count distribution of the segmentation application <ref type="bibr" target="#b8">[8]</ref> for both of the pure static <ref type="bibr" target="#b10">[10]</ref> and the pure dynamic <ref type="bibr" target="#b4">[4]</ref> scheme. The peak write count of static optimization is significantly larger than that of the dynamic one. The deficiency of dynamic migration comes from the fact that it lacks the future memory access information and highly relies on the application to exhibit a bipolar L2 write frequency patternsthe L2 cache blocks are either rarely written or intensively written.</p><p>Then the write-intensive blocks can swap their places with the rarely written blocks through dynamic migration. However, based on our observation, not all the applications have such characteristics, especially in the three medical imaging applications <ref type="bibr" target="#b8">[8]</ref> used in our study. As shown in Figure <ref type="figure" target="#fig_0">1</ref>, most of the blocks are uniformly written 2-3 times. Under this circumstance, if the migration threshold is set to be higher than 3, then there will be little migration, both the SRAM and STT-RAM will be evenly written based on the LRU scheme, which may impair the endurance. However, even if the migration threshold is set to be 2 or 3, the migration for most blocks does not save any write, since most blocks behave similarly. A correct approach is to place all these streaming accessed blocks into the SRAM, which can be obtained via static optimization in the compiler.</p><p>After that, the expensive writes on STT-RAM can be significantly reduced and thus dynamic energy can reduced. To overcome these limitations while taking the advantage of both static and dynamic schemes, we use a combined strategy: the compiler tries to guide the hardware in order to rapidly achieve the desired placement, while the hardware corrects the compiler hints based on the run-time cache behavior. To the best of our knowledge, we are the first one taking such a hybrid approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE COMBINED APPROACH 4.1 Compiler Support</head><p>In this work, we develop an automatic compilation flow to generate data placement hints for each memory reference. Here, we assume LRU replacement policy is used and L2 is an inclusive cache with the same block size of L1, which is widely used in modern processors because of easy coherence implementation.</p><p>Similar to <ref type="bibr" target="#b10">[10]</ref>, our compiler tends to place write-intensive references into SRAM and non-write-intensive data into STT-RAM. Based on our inclusive cache assumption, the write accesses on L2 STT-RAM cells occur at only two situations: (1) L1 dirty evictions due to L1 cache replacement and (2) L2 cache replacement. However, the work in <ref type="bibr" target="#b10">[10]</ref> assumes there is no cache in the memory system, thus does not consider the effect of higherlevel (L1) cache on the memory access behavior. Figure <ref type="figure">2</ref> shows an example code and its corresponding memory access behavior.</p><p>We can find that both arrays A and B are written twice. However, since array A is more frequently accessed and can be kept in the L1 cache (we assume LRU replacement policy is used here), neither of the two writes falls into the L2 cache. On the other hand, since array B is evicted from the L1 cache before its next access, one write-back operation will be issued into L2.</p><formula xml:id="formula_0">loop 1: A[i] = ?; B[i] = ?; (write array A and B in L1) loop 2: ? = A[i] ?; (read array A in L1) loop 3: ? = C[i] ?; (array B is evicted into L2) loop 4: A[i] = ?; B[i] = B[i]?;</formula><p>(write array A and B in L1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2: One sample code and its memory access behavior</head><p>To capture this effect, we use the concept of memory reuse distance (MRD) <ref type="bibr" target="#b11">[11]</ref>, which equals the total size of unique data elements accessed between two references to X. A larger memory reuse distance of X implies that X will not be accessed in the near future, and thus X is more likely to be evicted from the L1 cache.</p><p>Definition 1: For an write operation w of memory instruction X, assuming the future access sequence of X is w, r 1 , r 2 , ..., r n , w ' , etc (r and w corresponds to read and write operation). w is called an L1-writeback write if one of the following conditions is satisfied:</p><p>(1) there exists</p><formula xml:id="formula_1">MRD(r i , r i+1 ) &gt; dist L1 (i = 1, ..., n-1) (2) MRD(r n , w ' ) &gt; dist L1 (3) MRD(w, r 1 ) &gt; dist L1 . (dist L1 is the average reuse distance to keep X in L1 cache)</formula><p>From Definition 1 we can see, if the memory reuse distance between two accesses into a dirty data X is larger than a threshold value dist L1 , the compiler will treat the first write (w) to X as a L1writeback, since X will be written back into L2. The other set of L2 write accesses comes from L2 misses and data are written into L2 from main memory. Here we use dist L2 to indicate the average reuse distance to keep X in L2 cache. For two adjacent accesses to X, if the memory reuse distance between them is larger than dist L2 , the compiler will treat the second access as a L2 miss, which will introduce one L2 write operation.</p><p>In our flow, we provide a 2-bit compiler hint for each memory instruction to guide its data placement in L2 cache. For each access to reference X, we count the total number of future L2 writes to X including both L1-writeback writes and L2 misses. If there are frequent L2 writes, our compiler will generate hint "01" for X. On the other hand, hint "00" is generated to indicate that X will not be written frequently. For those accesses that the compiler cannot analyze accurately (e.g., due to unknown loop bound), hint "1x" is generated and the data placement is controlled by hardware. Note that a memory instruction in a regular loop is accessed multiple times with repeated access patterns <ref type="bibr" target="#b12">[12]</ref>, therefore we can apply the same hint to all the accesses to it. It should be noted that the compiler just tries its best to predict the write frequency. The value of dist L1 and dist L2 can be obtained from profiling on representative input or set to a fixed value by default. However, it is not feasible to profile all input sets. In this work, a conservative approach is used to set dist L1 to L1 set associativity. This can ensure that data X will not be evicted out from L1 between two accesses with reuse distance less than dist L1 . Since the compiler cannot make an optimal decision without knowing the runtime cache behavior, these generated hints may not be followed in the hardware. We will discuss our combined scheme in Section 4.3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Compiler-Hardware Interface</head><p>In our implementation, the compiler passes the hints to the hardware through setting two bits in the 32-bit instruction code. We assume that there are two extra bits in each memory instruction that the compiler can use to assist the run-time cache block replacement. Existing architectures already use these kinds of extra bits in the instruction, such as the prefetch and evict-next instruction in the Alpha 21264. We believe that, in most architectures, the increasing speed gap between memory and processor will justify the inclusion of additional bits in the instruction code to facilitate the reduction of this gap. Once a memory reference instruction is executed, if this is a L1 cache hit, these 2 bits will be discarded. If this is a L1 miss, then the bits will be passed to the L2 cache controller, if this is a L2 hit, then these 2 bits will be discarded; if this is a L2 miss, these 2 bits will be used as hints for the initial placement of the new block.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Hardware Support</head><p>In this work, we use a 1MB 16-way hybrid cache including a 4way SRAM data array and a 12-way STT-RAM data array similar to the configurations used in <ref type="bibr" target="#b2">[2]</ref>[4] <ref type="bibr" target="#b7">[7]</ref>. The asymmetric configuration is chosen since smaller SRAM contributes less leakage while the bigger STT-RAM provides the advantage of higher density. We use separate replacement units on SRAM and STT-RAM in order to perform block replacement in these two arrays independently. We also introduce a global replacement unit for them in order to perform a global replacement among them if required. All of these replacement units use LRU policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Capacity-Pressure and Compile Hints based Initial Placement</head><p>The initial block placement decision is made based on both of the compiler hint and also the SRAM/STT-RAM capacity pressure monitored in the hardware.</p><p>Before discussing the decision making process, we first show our capacity pressure assessing hardware. To assess the SRAM/STT-RAM capacity pressure, we introduce two additional hardware structures: missing tags (MTs) and MT counters. The proposed structures are similar to the missing tags <ref type="bibr" target="#b12">[12]</ref> and victim tags <ref type="bibr" target="#b14">[14]</ref>.</p><p>MTs and MT counters are integrated with the tag array design, as shown in Figure <ref type="figure">3</ref>. In addition to the original 4-way SRAM tag array and the 12-way STT-RAM tag array, a 4-way SRAM MTs and a 4-way STT-RAM MTs are introduced. Moreover, for each cache set, there are a SRAM MT counter and a STT-RAM MT counter, and these counters indicate the capacity pressure of the SRAM and STT-RAM portions in that cache set, respectively. Note that the sizes of MTs are the same for both SRAM and STT-RAM arrays to provide similar pressure monitoring criterion.</p><p>We use the SRAM MT to illustrate the MT and MT counter functionality, and the STT-RAM MT and MT counter work in the same way. When a cache miss occurs in the SRAM, the tag of the victim block will overwrite the LRU tag in the same set in SRAM MTs and be marked as most recently reused tag. If there is a miss in the SRAM array and there is a hit in the SRAM MTs, this indicates that a potential hit will occur if the requested block were placed in STT-RAM. Then the SRAM MT counter in the corresponding cache set is incremented by one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3: SRAM and STT-RAM missing tag and counter</head><p>We use an interval-based assessing approach, i.e., the value of the MT counters in the current interval will be used to guide the initial placement in the next interval. Considering the lessfrequent access to the L2 cache, the interval length cannot be too short, but it can also be too long in terms of timely assessment. In this work, we set it to be 10K cycles. At the end of each 10K cycles, the value of all the MT counters will be evaluated to fill the capacity pressure table (CPT). The number of entries of CPT equals to the number of sets in the cache and each entry contains two bits: the SRAM capacity pressure and the STT-RAM capacity pressure of that cache set. If the value of the SRAM (STT-RAM) MT counter of a cache set is greater than a threshold, then the SRAM (STT-RAM) bit for that set in the CPT is set to 1 (high), otherwise set to 0 (low). Then all the MT counters are reset to 0. In the next interval, the CPT is accessed together with the compiler hints to decide the initial block placement.</p><p>Given the capacity pressure from the CPT and also the compiler hints, the L2 cache controller makes the initial placement as shown in Table <ref type="table" target="#tab_1">2</ref>. If a block is going to be placed in SRAM (STT-RAM), then the LRU replacement unit of SRAM (STT-RAM) will be triggered to evict the victim in that cache set of SRAM (STT-RAM). If a block is going to be placed globally, the global LRU replacement unit is triggered to evict the LRU block of all the SRAM and STT-RAM cache lines in that cache set. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Write-Frequency based Dynamic Migration</head><p>As pointed out in Section 4.1, the compiler hints are not absolutely accurate due to the input variation and the L1 cache impact. Moreover, according to Section 4.3.1, when capacity pressure unbalance occurs, blocks may be initially placed in the less-intensive used portion of the hybrid cache, instead of based on the write-frequency of the block itself, as shown in Table <ref type="table" target="#tab_1">2</ref>.</p><p>Thus it is possible that a block is incorrectly initially placed.</p><p>We use dynamic migration to correct the initial placement by migrating the actually write-intensive STT-RAM data blocks to SRAM. We use the dynamic migration scheme similar to <ref type="bibr" target="#b4">[4]</ref>, which is briefly described as follows. Each L2 cache block is associated with a saturate 2-bit write counter to indicate the number of writes during its on-chip lifetime. If the write counter of a STT-RAM block saturates (three writes), the migration unit will check the write counters of the SRAM blocks in the same cache set. If there is any counter that is less than 3, then the corresponding SRAM block is swapped with that STT-RAM block. After that, all the write counters in this cache set are reset to 0. If the counters of all the SRAM blocks in a set are saturated, no migration will be performed. Therefore, the possibility that another write-intensive block could be swapped from the SRAM back to STT-RAM is avoided.</p><p>In sum, in our combined approach, if the compiler provides correct hints, the hardware can use them to rapidly achieve correct block placement. If compiler makes mis-predictions, the hardware corrects the compiler hints as shown in Table <ref type="table" target="#tab_2">3</ref>. Note that all the hardware corrections are automatically triggered by our introduced hardware counters.</p><p>Compiler mis-predictions: (a) Mis-predicts some write-intensive blocks as non-write-intensive. (b) Generates larger percent of non-write-intensive blocks that it actually is. (c) Generates larger percent of write-intensive blocks that it actually is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hardware corrections: (i) Distributes blocks to STT-RAM. (ii)</head><p>Distributes blocks to SRAM. (iii) Migrates write-intensive blocks from STT-RAM to SRAM. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION METHODOLOGY 5.1 Compilation and Simulation Infrastructure</head><p>The compiler support for hint generation is implemented based on LLVM compiler infrastructure <ref type="bibr" target="#b15">[15]</ref>. Omega library <ref type="bibr" target="#b16">[16]</ref> is used in this flow to perform memory dependency analysis. Given a source program written in C/C++, we parse it into LLVM IR using LLVM's frontend. All standard optimizations in O3 are applied. Our hint-generating flow is invoked as a pass on the optimized LLVM intermediate representation (IR) code and will automatically generate data placement hints for each load/store instruction. We also modify LLVM backend to emit hint-included load/store instructions in the final assembly code. A potential issue of this LLVM frontend analysis is that some load/store instructions cannot be captured in IR level. For example, the loads/stores in pre-compiled library functions cannot be analyzed under this framework. Moreover, the loads/stores from operating system cannot be analyzed during compile time. Therefore, a hardware support mentioned in Section 4.3 is required to provide better optimization. We extend the full-system cycle-accurate Simics <ref type="bibr" target="#b17">[17]</ref> and GEMS <ref type="bibr" target="#b18">[18]</ref> simulation platform to model the proposed hardware support.</p><p>The system configurations of SIMICS/GEMS are shown in Table <ref type="table" target="#tab_3">4</ref>. We obtain the energy data of the SRAM array and MTs/MT counters through Cacti 6.5 <ref type="bibr" target="#b19">[19]</ref> with 32nm process technology at 330K. The energy data of the STT-RAM array are obtained from NVSim <ref type="bibr" target="#b20">[20]</ref>. Table <ref type="table" target="#tab_4">5</ref> shows the energy model we use in our evaluation. Note that the low leakage cells (itrs-lstp) are used in SRAM data array and tag array. For peripheral circuitry, we use high performance cells (itrs-hp) to optimize performance and area. Note that we also try to implement the peripheral circuitry with low leakage cells for further leakage minimization. However, we observed that considerable area overhead may arise since the width of an itrs-lstp transistor should be large enough to provide the enough current for STT-RAM write operation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Benchmarks</head><p>Our testbenchs consist of eight benchmark applications, which have been carefully chosen to represent memory intensive algorithms in the fields of data processing, massive communication, scientific computation and medical applications. The benchmark applications include three memory-intensive applications from SPEC2006 <ref type="bibr" target="#b21">[21]</ref> (bzip2, mcf and lbm) and five applications from the medical imaging domain <ref type="bibr" target="#b8">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Reference Schemes</head><p>To demonstrate the effectiveness of our combined scheme (combined), we compare to two representative prior approaches:</p><p>Pure static optimization (static): The hardware will strictly follow the compiler-generated block placement hint. The compiler hints are generated based on the approach proposed in <ref type="bibr" target="#b10">[10]</ref>, and we further take the effect of L1 cache into consideration using the techniques discussed in Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pure dynamic optimization (dynamic):</head><p>We use the dynamic migration scheme proposed in <ref type="bibr" target="#b4">[4]</ref>. Our dynamic migration scheme in Section 4.3 uses this scheme with the same migration threshold as 3. There is no compiler hint in this scheme.</p><p>Note that the energy overhead of MTs and MT counters is only applied on the combined scheme.</p><p>6. RESULTS</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Endurance</head><p>In this work, we assume that the maximum write cycles of a STT-RAM cell is 4 x 10 12 <ref type="bibr" target="#b5">[5]</ref>. We assume that a workload continuously runs on the system. To model the endurance in a more sophisticated way, one can provide a loading factor, which is the percentage of the overall runtime occupied by the workload. The lifetime is measured from the start of the simulation until the first STT-RAM line becomes defective, which is similar to the estimation methodology proposed in <ref type="bibr" target="#b4">[4]</ref> and <ref type="bibr" target="#b5">[5]</ref>.</p><p>Figure <ref type="figure">4</ref> demonstrates the lifetime which is normalized to the static scheme. The static scheme typically performs the worst among the three schemes (up to 1.2x~148x worse than the combined scheme). This is because that once a compiler mispredicts a write-intensive block as a non-write-intensive one and places it into the STT-RAM, this block will be intensively written and there is no dynamic migration to mitigate it. The lifetime of the STT-RAM mainly depends on the peak write count of the cells. The exceptions are fft, lbm and denoise where the program only have negligible input-variation, so that the static scheme can have longer lifetime than the other two schemes. Note that the static scheme can only reduce the total writes instead of the peak write count among all blocks, as shown in Figure <ref type="figure">5</ref>. Therefore, the static scheme is the worst in terms of endurance but it can save STT-RAM write energy, which is discussed in Section 6.2.</p><p>With the dynamic migration to average the writes to STT-RAM blocks, the dynamic scheme achieves up to 14x improvement of lifetime compared to the static scheme. However, the reduction of the peak write count of STT-RAM is accompanied with the cost of much more total STT-RAM writes, since it lacks global information to reduce the total STT-RAM writes. Figure <ref type="figure">5</ref> shows that dynamic scheme has 1.6x~36.6x more STT-RAM writes than the static scheme. In cases of fft and lbm, the data blocks are all uniformly written less than 3 times on either SRAM or STTRAM. Therefore, there is little migration in the dynamic scheme and it has a life time which is only 4%~13% of that of the static scheme.</p><p>The combined scheme has a 1.6x~14.7x lifetime compared to that of the dynamic scheme. By following the correct compiler hints, the combined scheme rapidly achieves the optimal block placement without additional migrations, especially in the cases where most of the blocks are uniformly written less than two or three times, as shown in the motivational examples in Section 2. This can save both the peak write count and also the total writes of the STT-RAM. Although the combined scheme has 0.8x~4.1x more total STT-RAM writes than static, it achieves 1.2x~148x lifetime due to averaging the writes to the STT-RAM cells (except fft where static has a 1.8x longer lifetime than combined). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Energy</head><p>Figure <ref type="figure" target="#fig_3">6</ref> shows the distribution of hybrid cache (L2 cache) energy that is normalized to the static scheme. The leakage consumption of three schemes is similar. This is because leakage is proportional to program runtime and the runtime (as shown in Figure <ref type="figure">7</ref>) of the three schemes is similar. Therefore, the key factor that influences the system energy is the L2 STT-RAM dynamic energy. The static scheme has the least energy, because the reduced STT-RAM writes (as shown in Figure <ref type="figure">5</ref>) bring in considerable dynamic energy savings. Without the hints of initial placement, a large number of writes arises in the dynamic scheme, leading to 9%~80% energy overhead (38% overhead on average) compared to the static scheme.</p><p>The combined scheme achieves similar energy consumption to that of the static scheme (7%~20% energy overhead, 11% overhead on average) and outperforms the dynamic scheme (2%~39% energy reduction, 17% reduction on average). Note that the energy overhead of the combined scheme comes from both the leakage of the introduced MTs and the extra dynamic STT-RAM writes energy compared to the static scheme.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Performance</head><p>Performance is measured by the runtime of a workload (in terms of number of clock cycles obtained from our simulation infrastructure). Figure <ref type="figure">7</ref> shows the comparison results of runtime that are normalized to the static scheme.</p><p>Since the total cache size for the three schemes are the same, the runtime does not varied significantly. The differences among the three schemes come from how efficiently they make use of the aggregate capacity of both SRAM and STT-RAM to reduce the cache misses. The dynamic scheme typically performs the best due to the equivalent initial placement to SRAM and STT-RAM, which best utilizes the STT-RAM capacity. As mentioned in Section 4.3.1, compiler may generate larger write-intensive data on SRAM due to the input variation, thus impose high capacity pressure to the SRAM and result in high cache misses (as shown in Figure <ref type="figure" target="#fig_4">8</ref>). Therefore, the static scheme performs -1%~9% worse than the dynamic scheme (with a -1% ~30% increase in the L2 cache misses). The only exception is fft where static outperforms dynamic due to accurate compiler hints. In the combined scheme, the hardware can automatically correct the compiler mis-predictions as discussed in Section 4.3. Therefore, it achieves similar runtime to that of the dynamic scheme (within a -5% ~ 5% variation). These analyses are summarized in Table <ref type="table" target="#tab_5">6</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Different Bit Widths of Write Counters</head><p>We perform the sensitivity analysis on different bit widths of the write saturation counters in our proposed combined scheme. The write counters are used for dynamic migration to improve the endurance. We justify that 2-bit counters are adequate enough for write counters. Figure <ref type="figure" target="#fig_5">9</ref> shows that the lifetime can be significantly enhanced in mcf, deblur, registration, and segmentation when 2-bit counters are applied. The 1-bit counters are inefficient since the SRAM blocks in the same set may easily saturate and thus prevent the migration of write-intensive STT-RAM blocks into SRAM ones. For the rest of workloads, the lifetime is insensitive to the bit width. According to our experimental results, the bit widths of write counters are insensitive to both energy and runtime among all workloads (less than 1% difference). In terms of energy, the only exception is mcf, where most of write intensive blocks cannot be migrated into SRAM when 1-bit counters are used. Therefore, the STT-RAM energy increases by 15% in the 1-bit counters case compared to the others (2-to 5-bit). For performance, it is insensitive to the widths of write counters since performance is maintained through cache capacity pressure monitoring, as described in Section 4.3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>In this paper, a combined static and dynamic scheme is proposed to optimize the block placement in a hybrid SRAM and STT-RAM cache, so that endurance and energy are co-maximized. The compiler tries to guide the hardware to rapidly achieve the desired placement, while the hardware corrects the compiler hints based on the runtime cache behavior. Experimental results show that the combined scheme improves the endurance by 23.9x and 5.9x compared to pure static and pure dynamic schemes, respectively, while maintaining similar performance. Meanwhile, the system energy can be reduced by 17% compared to the pure dynamic scheme.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Write frequency distribution of the L2 cache blocks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: Comparison results of STT-RAM lifetime</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>ic Hybrid cache energy (normalized to static)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Comparison results of hybrid cache energy</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>Figure 7: Comparison results of runtime</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: STT-RAM lifetime over different bit widths</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : STT-RAM write count distribution #writes</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell>0-100</cell><cell>100-200</cell><cell>200-300</cell><cell>300-400</cell><cell>400-1000</cell><cell>1000-5000</cell><cell cols="2">&gt;=5000 max</cell></row><row><cell>static</cell><cell>12262</cell><cell>6</cell><cell>5</cell><cell>0</cell><cell>0</cell><cell>10</cell><cell>5</cell><cell>5470</cell></row><row><cell>dynamic</cell><cell>12207</cell><cell>38</cell><cell>16</cell><cell>27</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>395</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 : Initial placement decision based on compiler hints and SRAM/STT-RAM capacity pressure</head><label>2</label><figDesc></figDesc><table><row><cell cols="2">Capacity pressure</cell><cell></cell><cell>Compiler hint</cell><cell></cell></row><row><cell cols="4">SRAM STT-RAM infreq write freq write</cell><cell>unknown</cell></row><row><cell>High</cell><cell>Low</cell><cell>STT-RAM</cell><cell>STT-RAM</cell><cell>STT-RAM</cell></row><row><cell>Low</cell><cell>High</cell><cell>SRAM</cell><cell>SRAM</cell><cell>SRAM</cell></row><row><cell>High</cell><cell>High</cell><cell>STT-RAM</cell><cell>SRAM</cell><cell>Global</cell></row><row><cell>Low</cell><cell>Low</cell><cell>SRAM</cell><cell>SRAM</cell><cell>SRAM</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 : Hardware corrections to the compiler mistakes</head><label>3</label><figDesc></figDesc><table><row><cell cols="3">Compiler mis-predictions</cell><cell cols="3">Hardware corrections</cell></row><row><cell>a</cell><cell>b</cell><cell>c</cell><cell>i</cell><cell>ii</cell><cell>iii</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 : Simics/GEMS simulator configurations</head><label>4</label><figDesc></figDesc><table><row><cell>Core</cell><cell>Sun UltraSPARC-III Cu processor core</cell></row><row><cell>L1 Instruction/</cell><cell>32KB, 2-way set-associative, 64-byte block, 2-</cell></row><row><cell>Data Cache</cell><cell>cycle access latency, pseudo-LRU</cell></row><row><cell></cell><cell>1MB, 16-way set-associative (4-way SRAM,</cell></row><row><cell>L2 Cache</cell><cell>12-way STT-RAM), 64-byte block, access</cell></row><row><cell>(Hybrid cache)</cell><cell>latency: 10-cycle for SRAM, 11-cycle (read)</cell></row><row><cell></cell><cell>and 30-cycle (write) for STT-RAM</cell></row><row><cell>Main Memory</cell><cell>4GB, 320-cycle access latency</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 : Energy/power data of the evaluated hybrid cache Read energy Write energy</head><label>5</label><figDesc></figDesc><table><row><cell>Leakage</cell></row><row><cell>power</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 : Comparison summary of the experimental results</head><label>6</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">static</cell><cell></cell><cell cols="2">dynamic</cell><cell>combined</cell></row><row><cell cols="3">Endurance</cell><cell></cell><cell cols="2">worst</cell><cell></cell><cell cols="2">fair</cell><cell>best</cell></row><row><cell cols="3">Performance</cell><cell></cell><cell cols="2">fair</cell><cell></cell><cell cols="2">best</cell><cell>best</cell></row><row><cell></cell><cell cols="2">Energy</cell><cell></cell><cell cols="2">best</cell><cell></cell><cell cols="2">worst</cell><cell>~best</cell></row><row><cell>Lifetime (normalized to 1-bit)</cell><cell>0 4 8 12 16 20</cell><cell>bzip2</cell><cell>mcf</cell><cell>lbm</cell><cell></cell><cell>deblur</cell><cell>denoise</cell><cell cols="2">registration segmentation 148 119 87 52</cell><cell>fft</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>1-bit</cell><cell>2-bit</cell><cell>3-bit</cell><cell>4-bit</cell><cell>5-bit</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>X X X X X X X X X X X X X X X</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head n="8.">ACKNOWLEDGEMENTS</head><p>This work is partially supported by the <rs type="funder">SRC</rs> Contract <rs type="grantNumber">2009-TJ-1984</rs>, and the <rs type="funder">Center for Domain Specific Computing (NSF</rs> <rs type="grantName">Expedition in Computing Award</rs> <rs type="grantNumber">CCF-0926127</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_9ceAkKt">
					<idno type="grant-number">2009-TJ-1984</idno>
				</org>
				<org type="funding" xml:id="_m2AMGvq">
					<idno type="grant-number">CCF-0926127</idno>
					<orgName type="grant-name">Expedition in Computing Award</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.itrs.net/" />
		<title level="m">International Technology Roadmap for Semiconductors</title>
		<imprint>
			<publisher>Semiconductor Industries Association</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A novel architecture of the 3D stacked MRAM L2 cache for CMPs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="239" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hybrid cache architecture with disparate memory technologies</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Speight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajamony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="34" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">High-endurance and performance-efficient design of hybrid cache architectures through adaptive line replacement</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jadidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arjomand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sarbazi-Azad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ISPLED</title>
		<imprint>
			<biblScope unit="page" from="79" to="84" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Processor caches built using multilevel spin-transfer torque RAM cells</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISLPED</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="73" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">STT-RAM based energy-efficient hybrid cache for CMPs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLSI-SoC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="31" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Dynamically Reconfigurable Hybrid Cache: An Energy-Efficient Last-Level Cache Design</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Potkonjak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<editor>DATE</editor>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Platform Characterization for Domain-Specific Computing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ASPDAC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reducing write activities on non-volatile memories in embedded CMPs via data migration and recomputation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-M</forename><surname>Sha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="350" to="355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Power-aware partitioning for DSPs with hybrid PRAM and DRAM main memory</title>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="405" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Predicting whole-program locality through reuse distance analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="245" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A reuse-aware prefetching algorithm for scratchpad memory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC 2011</title>
		<imprint>
			<biblScope unit="page" from="960" to="965" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fine-grain CAM-tag cache resizing using miss tags</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISLPED</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="130" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An energyefficient adaptive hybrid cache</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gururaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISLPED</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="67" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="http://llvm.org/" />
		<title level="m">LLVM compiler</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
		<ptr target="http://www.cs.umd.edu/projects/omega/" />
	</analytic>
	<monogr>
		<title level="j">Omega library</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Simics: A full system simulation platform</title>
		<author>
			<persName><forename type="first">P</forename><surname>Magnusson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Christensson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Eskilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forsgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hallberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hogberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Larsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moestedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="50" to="58" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multifacet&apos;s general execution-driven multiprocessor simulator (GEMS) toolset</title>
		<author>
			<persName><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Computer Architecture News</title>
		<imprint>
			<biblScope unit="page" from="92" to="99" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><surname>Hp Cacti</surname></persName>
		</author>
		<ptr target="http://quid.hpl.hp.com:9081/cacti/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Design implication of Memristor-Based RRAM Cross-Point Structures</title>
		<author>
			<persName><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>In DATE</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><surname>Spec Cpu</surname></persName>
		</author>
		<ptr target="http://www.spec.org/cpu" />
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
