<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Delay-Fault Test Generation and Synthesis for Testability Under a Standard Scan Design Methodology</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Kwang-Ting</forename><surname>Cheng</surname></persName>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Srhivas</forename><surname>Devadas</surname></persName>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Kurt</forename><surname>Keutzer</surname></persName>
						</author>
						<author>
							<persName><forename type="first">-T</forename><surname>Cheng</surname></persName>
						</author>
						<author>
							<persName><forename type="first">S</forename><surname>Devada</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">AT&amp;T Bell Laboratories</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering and Com-puter Science</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>01239</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Delay-Fault Test Generation and Synthesis for Testability Under a Standard Scan Design Methodology</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">55A6A44A04C89EF7244FD7AB35CF4BB0</idno>
					<note type="submission">received March 20, 1991; revised August 17, 1992. This work was supported in part by the Defense Advanced Research Projects</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We address the problems of test generation and synthesis aimed at producing VLSI sequential circuits that are delay-fault testable under a standard scan design methodology. We begin with theoretical results regarding the standard-scan delay testability of finite state machines (FSM's) described at the state transition graph (STG) level. We show that a one-hot coded and optimized FSM whose STG satis6es a certain property is guaranteed to be fully gate-delay-fault testable under standard scan. We extend this result to arbitrary-length encodings and develop a heuristic state assignment algorithm that results in highly gate-delay-fault testable sequential FSMs, which are also area-efficient, as evinced by results obtained on benchmark FSM circuits.</p><p>We switch focus to the problem of delay test generation for large sequential circuits and modify a PODEM-based combinational test pattern generator for our purpose. The modifications involve a two time-frame expansion of the combinational logic of the circuit, and the use of backtracking heuristics tailored for our problem. We also employ a version of the scan shifting technique in our test pattern generator. We give an algorithm to determine an efficient ordering of the flip-flops in the scan-chain using the information derived from running a delay test generator on the circuit. Given an ordering of the flip-flops, we give an optimization algorithm that attempts to minimize the number of flip-flops to be made enhanced-scan so as to obtain a required level of delay-fault coverage. We show how the test vector sets derived using our test generator can be compacted by solving a clique covering problem. We present test generation, flip-flop ordering, flip-flop selection and test set compaction results on large benchmark circuits.</p><p>Manuscript</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>I. INTRODUCTION ILE a high degree of delay-fault coverage is de-w sirable, a number of problems are associated with testing in delay-fault models. The first problem is creating logic that is highly testable for delay-faults. Synthesis for delay-fault testability of combinational circuits has recently been the subject of extensive investigation (e.g., <ref type="bibr">[ 11-[3]</ref>). Practical integrated circuit designs that are com-pletely hazard-free robustly path-delay-fault testable were automatically synthesized using the techniques presented in <ref type="bibr">[4]</ref>, <ref type="bibr">[5]</ref>. The work in <ref type="bibr">[4]</ref>, [5] assumes an enhancedscan design methodology for the robust application of test vector pairs.</p><p>Another obstacle to delay-fault testing is the large vector sets required to test each path in (hazard-free) robust manner <ref type="bibr">[6]</ref>, <ref type="bibr">[7]</ref>. This problem is addressed in <ref type="bibr">[l]</ref> where a general robust path-delay -fault model is proposed which can potentially significantly reduce the test vector sets. Another alternative is to use delay fault models with a fewer number of faults such as the gate delay fault model. Results presented in <ref type="bibr">[5]</ref> show that by using a gate delayfault model rather than a path-delay-fault model can reduce the required number of test vectors to a manageable number.</p><p>A remaining important barrier to the practical use of delay-fault testing is that the application of a test vector pair to the combinational logic portion of a VLSI sequential circuit may require that the memory elements in the circuit be enhanced scan flip-flops, i.e., flip-flops that can store not just 1, but 2 bits of state. This is because an arbitrary vector pair cannot be applied to a sequential circuit under a non-scan or a standard scan design methodology. The use of an enhanced scan latch imposes an area penalty that is prohibitively expensive for many circuit designs. In this paper, we address the problem of test generation for, and the synthesis of, VLSI sequential circuits that are delay-fault testable under a standard scan design methodology.</p><p>There has been some previous work in the area of sequential delay testing. The various issues in the delay testing of sequential circuits were illustrated in [8], and the use of scan design rather than non-scan design was recommended. In <ref type="bibr">[9]</ref>, the problem of non-scan delay testing and finite-state machine (FSM) synthesis for delay testability was addressed. This work was limited to synthesizing testable finite state machines from state transition graph (STG) descriptions, hence the size of the circuits dealt with were small. Also, no guarantees of fault coverage were made. Designing stuck-open fault testable, standard scan-based sequential circuits was the subject of <ref type="bibr">[lo]</ref>. However, only circuits where each next state and output function were realized by a single complex gate were considered. A heuristic algorithm to arrange the flip-0278-0070/93$03.00 0 1993 IEEE flops in a scan chain so a maximal number of given vector pairs can be applied was presented in [ 1 13.</p><p>We begin this paper with theoretical results regarding the standard-scan delay testability of FSM's described at the STG level (Section 111). We show that a one-hot coded and optimized FSM whose STG satisjies a certain property is guaranteed to be fully gate-delay-fault testable under standard scan. We extend this result to arbitrarylength encodings and develop a heuristic state assignment algorithm that results in highly gate-delay-fault testable sequential FSM's, which are also area-efficient, as evinced by results obtained on benchmark FSM circuits.</p><p>We switch focus to the problem of delay test generation of large sequential circuits and modify a PODEM-based combinational test pattern generator for our purpose. The modifications involve a two time-frame expansion of the combinational logic of the circuit, and the use of backtracking heuristics tailored for our problem. Vector pairs that can be obtained by single-bit shifts can be applied at speed under standard scan. This notion is called scan shifing (called transition shifing in <ref type="bibr">[12]</ref>). We first give an algorithm to determine the eficient ordering of the pipflops in the scan chain that uses the information derived from running a delay test generator on the circuit. Given an ordering of the flip-flops, we give an optimization algorithm that attempts to minimize the number of$ip-$ops to be made enhanced-scan so as to obtain the required level of delay-fault coverage, under a partial enhancedscadstandard-scan methodology. To address the problem of large vector sets we show how the test sets derived using our test generator can be compacted by solving a clique covering problem. We present test generation, flipflop ordering, flip-flop selection and test set compaction results on circuits from the ISCAS sequential benchmark set in Section V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">DEFINITIONS AND NOTATION</head><p>Analysis and synthesis of delay-fault testable circuits requires spanning the field of logic optimization, testing and timing analysis. In this section we try to provide a minimal amount of terminology from these fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Logic Synthesis</head><p>A Boolean function F of N variables is a mapping from BN = (0, l}N + (0, 11. We model B N as a Binary Ncube. A vertex u E B N for which F ( u ) = 1 is a member of the ON-set. If F ( u ) = 0 then u is a member of the OFFset.</p><p>A literal is a Boolean variable or its complement. We formally define a cube as a set of literals and we interpret the cube as a product of literals. For example { a , b , c } is a cube, interpreted as abc , which may be abbreviated to abc. A minterm is a cube in which every variable in the Boolean function appears. We may interpret the minterm as a vertex in the N-cube.</p><p>Minterms and cubes may be used to represent the values of a set of input variables: e.g., xjjz is shorthand for x = 1, y = 0, and z = 1. In this way there is a natural correspondence between an input vector or input stimulus, a minterm and a vertex in the N-cube. This correspondence may be extended to cubes where unspecified values in the function are assumed to be undefined values.</p><p>Thus, if a circuit C has inputs U , w , x , y , z , then applying the cube xyz to C is shorthand for applying u = X, w = X, x = 1, y = 0, and z = 1. (Here Xdenotes an unknown value.)</p><p>We define a cover as a set of cubes and we interpret the cover as a sum-of-products expression. For example { { a , b , c}, { d , e , f } } is a cover, interpreted as abc + def. We say that a cube q covers a cube (or vertex) r , denoted r C q, iff q is a subset of r( q G r ) . The use of the set notation q E r is counter-intuitive and we will use r C q henceforth. We say that a cube (vector) q is compatible with a cube (vector) r iff there does not exist a literal 1 E q such that E r. In other words, two vectors are compatible if their values do not conflict in any input.</p><p>Given cubes (vectors) q and r , if q and r are compatible then the cube intersection, denoted q n r, is q U r and if cubes q and rare not compatible then q n r = 4. Again, the use of the set notation q U r is counter-intuitive and we will use the more familiar q n r henceforth. If a cube q covers only ON-set vertices of a Boolean function F then q is called an implicant of F. A relatively essential vertex or an irredundancy test of a cube q in a cover C is a vertex that is covered by q and is not contained in any other cube in C.</p><p>A Boolean Network q is a directed-acyclic graph (DAG) such that for each node ni in q there is an associated cover Fi, and a Boolean variable yi representing the output of Fi. As there is a one-to-one correspondence between a node and its cover we will use the terms interchangeably. There is a directed edge from ni to nj iff 5 explicitly depends on yi or yi. Furthermore, some of the variables in may be classified as primary inputs or primary outputs. We may directly implement a Boolean Network r] by a combinational circuit (3 replacing each cover Fi in r] by a NAND/NAND network and by replacing each edge set fanning out from a node in q by a net.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Delay Testing</head><p>In this section we introduce terminology that will allow us to discuss timing issues as well as fault models for temporal behavior. A path in a combinational circuit is an alternating sequence of vertices and edges, {uo, eo, --* , <ref type="figure">U,</ref><ref type="figure">,</ref><ref type="figure">e,</ref><ref type="figure">,</ref><ref type="figure">U,</ref><ref type="figure">,</ref><ref type="figure">+</ref> where edge ei, 1 I i I n, connects the output of vertex ui to an input of vertex ui + For 1 I i 5 n, ui is a gate; uo is a primary input and u , + ~ is a primary output. Each ei is a net.</p><p>An event is a transition 0 + 1 or 1 + 0 at a gate.</p><p>Consider a sequence of events, {ro, r , , * -* , r,} occurring at gates { go, g l , ---, g,) along a path, such that ri occurs as a result of event ri -, . The event ro is said to propagate along the path.</p><p>A circuit has a gate-delay-fault if there is one gate in the circuit such that the output of the circuit is slow to make a 0 + 1 (or 1 + 0) transition because of an extra delay encountered at the gate. Each single gate-delay-fault is assumed to be so catastrophic as to cause a delay along any path through the gate to any output.</p><p>A circuit has a path-delay-fault if there exists a path from a primary input to a primary output via a set of gates and nets such that a primary input event is slow to propagate dong the path to the primary output.</p><p>A two-pattern test T = ( vl, v 2 ) is said to be a general robust delay test for a path T , if and only if, when a is faulty and the test T is applied, the circuit output is different from the expected state at sampling time, independent of the delays along gate input leads not on ?r [ 131.</p><p>A more stringent model is the hazard-free robust de- The vector ( U ] , v 2 ) is made up of (il @ sl, i2 @ sz), where il and i2 are the values of the Primary Input (PI) lines, and sl and s2 are the values of the Present State (PS) lines. The symbol @ denotes the concatenation of bit vectors. The constraint imposed by using a standard scan or a non-scan design methodology is now apparent: we require il to produce s2 as the next state if the machine is in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S1-</head><p>Given a sequential circuit with n flip-flops implemented under standard scan, our delay test methodology is as follows: We set the machine in test mode (by setting the Mode Switch high) and scan in state s1 into the flip-flops (it requires n clock cycles). The machine is then clocked twice with appropriate primary input vectors il and i2. Before the machine is clocked the second time (in the words, before U , is applied), it has to be set in the normal mode to catch the fault effects from the functional logic. However, it can be set in either the normal mode or the test mode before the first clock pulse is applied. If the machine is in normal mode, then s2 will be from the functional logic. Otherwise, the value of a flip-flop in s2 will be obtained from its predecessor in the scan chain.</p><p>In this paper, we will be dealing with the general robust path and gate-delay-fault models. However, the suggested test generation procedure described in Section V should be considered as an approximate method for generating robust tests. To avoid using a multi-valued logic in test generation, the procedure may generate vector pairs that are hazardous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">SYNTHESIZING DELAY-FAULT TESTABLE FINITE STATE MACHINES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Introduction</head><p>Our goal is to be able to synthesize a fully gate-delayfault testable finite state machine (FSM) under a standard scan design methodology, or under a non-scan method-ology. To this purpose we first show that given a State Transition Graph (STG) that satisfies a certain property, a one-hot coded and two-level minimized FSM derived from the STG will be fully testable under the gate-delayfault model described in Section 11. We show how any STG that does not satisfy the above property can be transformed into a STG that does satisfy the property by an appropriate addition of edges and states. Requiring the STG to satisfy this property is a sufficiency condition, and not necessary for a fully gate-delay-fault testable machine. We argue that most STGs will result in a fully gatedelay-fault testable machine after one-hot coding and twolevel minimization.</p><p>One-hot codes may require too many bits and may be area-inefficient for large FSM's. We switch focus to arbitrary-length encodings (greater than or equal to the minimum-bit encoding). We give conditions that are necessary for the encoded and optimized two-level cover implementing the STG to be fully gate-delay-fault testable. We show that these conditions can be satisfied by appropriate modifications of the STG prior to encoding, and by constraining the encoding process.</p><p>It is possible to retain the gate-delay-fault testability under a multilevel logic implementation either in the onehot coding case, or in the arbitrary encoding case, using a constrained algebraic factorization procedure to derive a multilevel network <ref type="bibr">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Terminology</head><p>A one-hot coding of a FSM with N, states, implies a code of length N,, with the code of each state having a 1 in a unique identifying position and 0's in each other position. After one-hot coding the FSM, the unused state codes are used as don't care conditions during two-level logic minimization. In a two-level implementation there is no sharing between the logic of the next state lines in a one-hot coded and minimized FSM; however, a cube (AND gate) may feed both a PO and an NS line.</p><p>A block diagram of a FSM is shown in Fig. <ref type="figure">l(a)</ref>. Its STG is shown in <ref type="bibr">Fig. l(b)</ref>. The one-hot coded STG is shown in Fig. <ref type="figure">2</ref>(a) with an appropriate don't care set appended, and a gate-level implementation of the combinational logic of the one-hot coded and logic minimized STG is shown in Fig. <ref type="figure">2(b)</ref>.</p><p>We are concerned with the gate-delay-fault testability of the gates in a two-level network. Given a particular AND gate, g, in a two-level network, we can detect a 0 + 1 delay fault on g, to a particular PO or NS line, by applying a vector vl in the OFF-set of the PO or NS line, and then applying a vector v2 that is an irredundancy test for the cube corresponding to g for the PO or NS line. An irredundancy test implies that all AND gates that feed the PO or NS line are held at 0, except for g which is at 1. Applying ( v2, v l ) will detect the 1 + 0 gate delay fault on g. Note that the above test may not be a robust test for 'The hazard-free robust path-delay-fault model is simply called the ro-the-gate-delay-fault On g since the Other gates may glitch to a 1 on the application of ( v l , v 2 ) . However it is in</p><formula xml:id="formula_0">-o/o</formula><p>state q , neither do we require that the minterm pro- -11------keeping with our testing methodology outlined in Section 11.</p><p>Testing any AND gate in a single-output two-level cover will simultaneously test the OR gate as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Testability of a One-Hot Coded and Two-Level Minimized FSM</head><p>Consider a one-hot coded and two-level minimized cover C derived from a STG G, representing a FSM M. Even if all the AND gates feed the NS line (while also feeding the PO lines), we need to test the OR gates implementing the PO lines, which can be done by testing any one of the AND gates feeding the PO line, to the PO line.</p><p>For each of the cases above, we give the requirements on a ( i l @ s l , i2 @ s2) that tests a particular AND gate g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1)</head><p>An irredundancy test for g at the PO o (there may be several), call it i l @ sl, should go to a state s2 which satisfies the property that 3i2 such that the value of o on the application of i2 @ s2 is 0 . The state s2 may not satisfy such a property. The original STG G can be modified so that each state q E G produces a 0 value for each output o on at least one input minterm i2. Note that we do not require both 0 and 1 values on o to be produced by each ducing the 0 value for o be the same for different states. Also note that there may be several irredundancy tests for g and we really only need one irredundancy test to produce an s2 that satisfies the above property. Making each state in a STG satisfy the property is an easy sufficiency condition. If we wish to relax this condition, we need to predict what the irredundancy tests are in the one-hot coded and minimized cover, and related them to input minterms and states-a difficult task. 2) An irredundancy test for g at the NS line n, i , @ s1 will result in the machine going to a state s, that is the state corresponding to the NS line, n. Recall that in a one-hot coding each NS line and PS line corresponds to a unique state in the FSM. Given that the irredundancy test produces a 1 at n, it means that the FSM has moved to s,. We now require that 3 i2 such that i 2 @ s, goes to a state s3 # s,. If s3 # s,, then the N S line n will have the value 0.</p><p>The above requirement is easy to satisfy. For each state q E G, we simply require that there be at least one input minterm i2 that moves the machine to some state other than q. To put it differently, there should be no state p that only has "loop" edges, i.e., edges that result in the machine remaining in P .</p><p>A strongly connected machine [ 141, where every state can be reached from every other state, will satisfy the above property. A STG that is not strongly connected can easily be modified to obtain a STG that is strongly connected. 3) Consider an irredundancy test for g at a PO o , namely i2 @ s2. We need s1 to be produced by some input vector il from some state s1 such that the value of o is 0. In other words, we need, for each state q in the STG, at least one incoming edge which produces a value of 0 for each PO o (We do not require that the value of 1 be asserted for each PO 0). Again, a STG can be easily modified to satisfy the above sufficiency condition. 4) Consider an irredundancy test for g corresponding to a NS line n, namely i2 @ s2. This vector results in the machine going to the state corresponding to the NS line n, namely sn. We require that s2 # s".</p><p>Then we can reach s2 with the value of the N S line n being 0, and apply i2.</p><p>The above requirement appears to be trivial, but in fact, is quite tricky. As mentioned earlier, it is difficult to predict what the irredundancy tests of each cube in the one-hot coded and minimized cover are going to be. We need the irredundancy tests for a cube and a NS line n to not correspond to sn. If a loop edge of s" becomes an irredundancy test for a NS line n , then the above condition is violated. One can envision a (complicated) two-level minimization strategy that monitors the irredundancy tests of each cube and ensures that these tests do not correspond to loop edges. An easy way out is to split states in the machine so as to remove all loop edges.</p><p>For instance, given a state graph fragment as follows:</p><p>il SI 41 01 <ref type="table" target="#tab_2">12 41 41 0 2   13 41 $2 0 1  we can split q1 into q1</ref> and<ref type="table" target="#tab_2">q2 transforming it to:   il SI 41 01   12 41 42 0 2   12 4 2 4 1 0 2   13 41 s2 01   13 42 s 2 01</ref> where no loop edges exist. If q1 and q2 are encoded with different one-hot codes, then gate-delay-fault testability will be guaranteed. It should be stressed that the above condition is a sufficient one and the likelihood of irredundancy tests corresponding only to loop edges in a typical machine is rather low. Thus, it is feasible even though painstaking, to obtain a fully gate-delay-fault testable machine two-level circuit via one-hot coding and two-level minimization by appropriate modifications of the original STG. An example of applying the above transformations is shown in Fig. <ref type="figure">3</ref>. In Fig. <ref type="figure">3</ref>(a) we have an incompletely symbolic STG which satisfies the conditions 1 and 2 above. State s l does not satisfy condition 3, and an edge from state s2 fanning out to sl is added to satisfy the property. Finally, state s3 is split into s3a and s3b to satisfy condition 4. One-hot coding and minimizing the STG of Fig. <ref type="figure">3</ref>(b) will result in a fully gate-delay-fault testable machine.</p><p>Empirical results indicate that these modifications are not necessary for high/full testability (cf. Section 4.2). Synthesis of multilevel circuits is treated in Section 3.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Testability of a FSM Under An Arbitrary Encoding</head><p>If a FSM has been encoded using, say a minimum-bit encoding, and then two-level minimized, we have a more complicated scenario as far as delay testing is concerned.</p><p>AND gates may feed multiple NS lines, and there is no correspondence between the NS lines and states. However, an analysis can be performed and conditions necessary for gate-delay-fault testability can be derived.</p><p>As in the previous section, we will focus on the four different cases that occur while testing an AND gate g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1)</head><p>Same as in the one-hot coding case.</p><p>2) Consider an irredundancy test i l @ s1 for a NS line n. This produces a 1 at the NS line n. Assume that </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4)</head><p>i , @ sI moves the machine to state s2. We require that 3 i2 such that i2 @ s2 produces a 0 at the NS line n. A constrained encoding can satisfy the above requirement. For each next state line n (i.e., each bit in the encoding), we require an encoding such that each state fans out on some input minterm to a state that has a 0 in the bit corresponding to the NS line.</p><p>Same as in the one-hot coding case.</p><p>Consider an irredundancy test i2 @ s2 for a NS line n. We need s2 to have a 0 at the bit position corresponding to the NS line n. Then we can reach s2 by any means and apply i2 to detect the 0 + 1 gate delay fault on g . Like in the one-hot coding case, this is a tricky requirement. If an irredundancy test is a loop edge, then the above condition is violated. One can remove loop edges as discussed earlier. In addition, we have to constrain the state encoding. If a state q has a 1 in a bit position, n, then if we can encode the fanin states of q (states from which we can reach q in one clock cycle) such that they all have a 0 in position n, the irredundancy tests will satisfy the above property. This may be a difficult constraint to satisfy for all states and all bit positions. Given that there are usually several irredundancy tests for a AND gate and several NS lines that a gate can be tested to, in practice this does not pose much of a problem. The use of scan shifting can further help in this case.</p><p>A fanin state of 4, namely s, need not have a 0 in the bit position n, if q can be obtained by shifting (a 0 or a 1 through) s. Further, loop edges will be allowed for states with the all 1's code and the all 0's code.</p><p>A STG that satisfies conditions 1 and 3 above is shown in Fig. <ref type="figure">4(a</ref>). An encoding that satisfies conditions 2 and 4 is shown in Fig. <ref type="figure">4(b)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Single-Output Versus Multiple-Output Minimization</head><p>After encoding a STG G, one can either perform a single-output two-level minimization or a multiple-output minimization. There are a number of different factors that are affected by this choice. In terms of circuit area, singleoutput two-level minimization has the potential to share only a small amount of logic in the two-level circuit, while, given an arbitrary encoding, multiple-output minimization can result in a significantly smaller number of total product terms. Surprisingly, extensive experience has shown that algebraically factoring a single-output minimized two-level circuit most often results in a smaller circuit than algebraically factoring a multiple-output minimized two-level circuit, even though the latter is a smaller starting point. In terms of impact on testability, the number of cubes that feed a particular PO or NS line, will be larger in the case of the multiple-output minimized result and therefore the number of irredundancy tests per cube to a particular PO or NS line will be smaller, but there is also has the advantage that an AND gate corresponding to a cube can be tested to several NS and PO lines, as opposed to only one line. Even though the number of irredundancy tests for a cube in the multiple-output minimized case may be smaller, it should be noted that there will be at least one irredundancy test for each AND gate g to each PO or NS line g feeds, given that the cover is irredundant .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.">Multilevel Logic Implementations</head><p>The theory for maintaining the gate-delay-fault testability of a two-level network via a constrained algebraic factorization 141 can be used to advantage while synthesizing testable FSM's. We produce a FSM implemented using two-level logic that is standard-scan testable, and constrained algebraic factorization will maintain testability and test vector sets.</p><p>Performing a single-output two-level minimization initially prior to constrained factorization will ease the constraints that the factorization has to satisfy. Though the number of product terms in a single-output minimized circuit is typically significantly larger than a multiple-output minimized circuit, it appears that both serve as, more or less, comparable starting points for multilevel logic optimization [lS], [4]. That is, the impact on the multilevel circuits' areas due to beginning from a different starting point is typically small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. HEURISTIC STATE ASSIGNMENT FOR HIGH TESTABILITY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">I . Testability Conditions and Minimal-Feedback</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Logic Structures</head><p>While the theory of the previous section can lead to a heuristic state assignment algorithm that maximizes delay testability, it is worthwhile to investigate one other property of a logic-level implementation of a sequential machine that guarantees delay-fault testability under standard scan, namely a feedback-free structure. The circuit of Fig. <ref type="figure" target="#fig_4">5</ref> is fully gate-delay-fault testable, if A, B and C are gate-delay-fault testable individually, and if A and B produce all possible output combinations. Given a vector pair ( v l , u 2 ) required to test a gate in B, we scan in v l into the flip-flops L1 and apply the appropriate primary input to A that produces v2 at L1 one clock cycle later.</p><p>In <ref type="bibr" target="#b14">[16]</ref>, a state assignment algorithm devised toward producing a minimal-feedback structure was presented, in order to improve non-scan single stuck-at fault testability. The program SACRED <ref type="bibr" target="#b14">[16]</ref> is guaranteed to find a feedback-free structure given a STG specification, if one exists. FSM's require some form of feedback. It is intuitive that if feedback is minimized that delay-fault testability will improve.</p><p>We can integrate the conditions presented in Sections 3.3 and 3.4 with the notion of minimizing feedback in an eventual logic-level implementation of a FSM to arrive at a heuristic algorithm for state assignment that maximizes delay-fault testability. In particular, we revisit the conditions required in the four cases of testing a gate in a onehot coded and optimized cover, taking into account the fact that a next state line n can be made to not depend on all present state lines but rather on a minimal subset.</p><p>For each of the conditions 1-4 of Sections 3.3 and 3.4, we require an irredundancy test il @ s1 for a gate g or an irredundancy test i2 @ s2 for a gate g. Consider a next state line n that does not depend on a particular present state line p . In this case, any irredundancy test for any gate g feeding the next state line n, will have the bit POsition corresponding to p as a -(don't cure). This implies that we can choose the value of p to be 0 or 1 to satisfy conditions 1-4 of Section 3.4. For instance, in condition 2, one of the two states corresponding to s1 (with p as a -) should go to a state s2 on the application of i l , such that 3 i2 where i2 @ s2 produces a 0 at the next state line n. The condition has thus been relaxed. The other constraints are also relaxed in the case of obtaining multiple irredundancy tests for any particular gate.</p><p>Thus, a heuristic state assignment strategy tailored toward maximizing gate-delay-fault testability corresponds to the integration of the constraints given by conditions 2 and 4 of Section 3.4 into the algorithms of SACRED. During each step of the SACRED algorithm, codes are chosen based on minimizing the dependence of the next state lines on the present state lines, and attempting to satisfy the constraints posed by conditions 2 and 4. It should be noted that the program SACRED as presented in <ref type="bibr" target="#b14">[16]</ref> had a different goal from minimizing the combinational dependence of the next state lines on the present state lines. Minimizing the sequential depth, i.e., the longest feedback path in the circuit was a primary objective. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Experimental Results</head><p>In this section, we give empirical results on the testability of implementations using one-hot and SACRED encoding followed by two-level minimization and constrained algebraic factorization. The gate-delay-fault coverage is measured for a set of MCNC benchmark finite state machines. In our experiments no modifications to the STG were made. Gate-delay-fault coverage is obtained by the following: While gate-delay-faults remain undetected and paths through the fault have not been considered: 1) select an unconsidered path through the undetected gatedelay-fault, 2) generate a path-delay-fault vector pair for the path using the test generation procedure described in Section V, and 3) determine gate-delay-fault coverage due to the vector pair.</p><p>It is assumed that the required state s2 in the second vector can be derived by either functional justification or scan shifting. The details of test generation strategy are given in Section V. Table <ref type="table" target="#tab_2">I</ref> shows the percentages of testable gate-delay fault coverage of two different implementations. Since we do not modify the state transition graphs, the properties described in the previous sections may not be satisfied and, thus, 100% testability is not achieved in some examples. None of the SACRED implementations listed in Table I has a pure pipeline structure except shifreg. Thus, coverage less than 100% is also expected in the SACRED encoding cases. However, as we expect, the gate-delay-fault coverage of both one-hot and SACRED implementations is always higher than 95 % .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. STRATEGIES FOR TEST GENERATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Introduction</head><p>Test generation for delay-faults under standard scan design is similar to a two time-frame sequential circuit test generation problem [ 171. In the first time-frame, all primary inputs and present state lines are fully controllable. In the second time-frame, only the primary inputs are fully controllable. There are two ways to produce the required state of the second time-frame: functional justijcation or scan shifting.</p><p>In functional justification, the values applied to the PI'S and PS lines of the first time-frame not only sensitize proper paths for the given delay-fault but also produce the required state for the second time-frame after the clock is activated. In scan shifting, the required state of the second time-frame is produced using the test mode. The value of a present state line in the second time-frame is obtained from its predecessor in the scan chain by setting the mode switch to the scan mode before the clock is applied. Fig. <ref type="figure">6</ref> shows the concept. The scan shifting concept has been proposed in <ref type="bibr">[12]</ref>.</p><p>We assume the general robust fault model for test generation, but weaken it slightly. For a given path-delayfault in the general robust delay fault model the required sensitization values on the side-inputs of gates along the path are listed in Table <ref type="table" target="#tab_2">I1</ref> [ 181. For example, to sensitize a rising transition (i.e., 0 in time-frame I and 1 in timeframe 11) from an AND gate's input to its output, the value 1 is required in time-frame I1 on each side-input while there is no requirement (don't care -) in time-frame I. However, for an OR gate, a stable 0 is required in both time-frames. To assign a stable value for a duration of two frames may require the use of a multi-valued logic. As a result the computational cost of test generation may increase. Therefore, we adopt an approximate sensitization requirement that is listed in Table <ref type="table">111</ref>. Instead of requiring a stable value at the side-inputs of gates along the given path, it requires that these signals have the same final value at both time frames. The condition given in Table <ref type="table" target="#tab_2">I11</ref> is weaker than that given in Table <ref type="table">11</ref>. A vector pair that sensitizes a path and satisfies the requirements given in Table <ref type="table" target="#tab_2">I11</ref> for side-inputs may cause hazards. Therefore, our procedure that is based on Table <ref type="table" target="#tab_2">I11</ref> should be considered as an approximate method for generating robust tests. The side-effect of this approximation is that hazards on side-inputs can potentially mask delay defects on the path under test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Generating Tests in Standard-Scan Circuits</head><p>In a synchronous digital sequential circuit, a combinational sub-circuit between flip-flops naturally defines a combinational logic circuit. Given that observation it is natural to speak of the ON-set and OFF-set of the cone of logic feeding a flip-flop. In order to conduct functional justification efficiently, we first preprocess the circuit to enumerate the partial or complete (memory and CPU time permitting) ON and OFF-sets of each of the NS lines [ 191.</p><p>Cover enumeration is done via a PODEM-based enumeration algorithm. A limit on the number of cubes in each ON or OFF-set can be replaced. This limit is used to restrict the amount of memory and CPU time used for enumeration. Cover enumeration is generally very fast and full covers of moderately large circuits can be extracted easily.</p><p>Given the covers for all NS lines, the test generation for a given path and the fault type (rising or falling) follows three steps. 1) Generating a pattern (i2 @ s2) for time-frame I1 which satisfies all the value requirements given in  -Table <ref type="table" target="#tab_2">I11</ref> and having as many don 't cure ( -) entries in s2 as possible. This step is done using a PODEMlike algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE I1 SENSITIZATION REQUIREMENTS ON SIDE-INPUTS OF GATES ALONG</head><p>2) If a present state (PS) line in has a 1 (0) in s2, the ON-set (OFF-set) of the corresponding NS line is picked. The intersection of the ON and OFF-sets of the NS lines with 0's and 1's gives the set of input vectors (C(s,)) that would produce s2. 3) Generating a pattern (il @ sl) for time-frame I which satisfies all the value requirement given in Table <ref type="table" target="#tab_2">I11</ref> and is covered by C(s2). If no such pattern exists, backtrack and repeat from Step 1.</p><p>The complexity of processing time-frame I is typically much higher than the traditional combinational circuit test generation for stuck-at-faults. It requires not only sensitizing a given path but also producing a specified state at the NS lines. This may result in a lot of backtracking.</p><p>Step 2 described above, which is a very fast process, significantly reduces the amount of backtracking in timeframe I. It is particularly helpful in proving that a fault is redundant. One extra run of step 2 is required for each backtrack between time-frame I and I1 (i.e., when no test is found in step 3). In this case, we store the unjustifiable state to avoid unnecessary justification in the future.</p><p>The average test generation complexity using scan shifting is typically lower than that using functional justification. Test generation using scan shifting also follows a three-step procedure which is very similar to that using functional justification except that the second step is much simpler. In step 2, if a PS line has a 1 (0) in s2, we would assign a 1 (0) in its predecessor in the scan chain at sl.</p><p>Test generation for time-frame I then starts with the partially assigned state.</p><p>A fault which is redundant assuming the use of functional justification may become testable using scan shifting. Similarly, a fault which is redundant assuming the use of scan shifting may become testable using functional justification. Since the test generation complexity using scan shifting is lower, we first try test generation in this mode. If a fault is identified to be redundant, the test generator will be switched to the functional justification mode and test generation will be attempted again.</p><p>We implemented the algorithm in the C language and used it to conduct experiments on the ISCAS sequential benchmark circuits. Table IV gives the circuit statistics and the total number of path/gate-delay-faults. We randomly selected 5000 paths (10 OOO faults) for test generation if the circuit has more paths. To achieve real defect coverage in actual practice it would be more useful to select a set of paths that cover each gate in the circuit, or to test all critical paths. In all experiments, we ran test generation for each fault in the fault list. No fault simulation was conducted.</p><p>For each circuit, we conducted our experiment in the following way: first, we ran the test generator assuming that the PS lines are fully controllable in both time frames. In other words, we assume the circuit is implemented using enhanced scan flip-flops that can store two bits of state. Table <ref type="table">V</ref> shows the achievable fault coverage under the enhanced scan design environment. The percentages of detected and redundant path-delay-faults are listed. The last column gives the average run time per fault in CPU seconds on SUN4/260. We also compute the percentage of gate-delay-faults detected by the tests of the testable path-delay-faults. The number is listed in column 5 of Table V. If a fault is redundant in the enhanced scan design environment, it must be redundant in the standard scan design environment. Therefore, we only use the enhanced-scan testable faults in our standard-scan test generation experiments.</p><p>We then ran the test generator in scan shifting followed by functional justification mode. For a given fault, scan shifting is first tried. In this mode, the required value in a flip-flop of the second pattern is obtained from its predecessor in the scan chain as described above. If it is proven redundant in this mode, functional justification follows. In this mode, the required state of the second pattern is justified through the functional logic. Table <ref type="table" target="#tab_5">VI</ref> gives the results we have obtained for standard-scan delay test generation. A redundant fault reported here is redun-   dant with respect to both modes. In the scan shifting mode, we assume the order of the flip-flops in the scan chain follows the same order of their appearance in the netlist file. The percentage of path-delay-fault coverage is about 64.9%. For those circuits that all path-delay-faults are considered for test generation, the percentage of gatedelay-faults covered by the test sequence of the detectable path-delay-faults is always higher than 80%. On an average, it takes about eight times more CPU seconds per fault during standard-scan test generation when compared to that required in an enhanced scan design environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1.">Experimental Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Efficient Ordering of Scan Flip-Flops</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Y</head><p>We first run the test generator under standard scan using functional justification. Notice that the order of the flip-flops in the scan chain is irrelevant to test generation under this mode. If a test pair is found, this fault would be detectable with any scan order. If the fault is not detectable using functional justification, we run test generation again in enhanced scan mode. The test generator attempts to have as many don 't care <ref type="bibr">(-)</ref> entries as possible in the present state lines in the second vector of the two vector sequence. Once the test pair (U], tr2) = (il @ sl, i2 @ s2) is generated, a set of constraints on the scan ordering is computed and recorded. These constraints, if satisfied, guarantee that s2 is obtainable by scan shifting of v1 in standard scan. In general, if the value of flip-flop X is 0 (1) in s1 and the value of flip-flop Y is 1 (0) in s2, then the constraint is that flip-flop X cannot be the predecessor of flip-flop Y. For a circuit of n flip-flops, we can easily record the constraints by maintaining an n X n constraint matrix A. Initially all entries are zero. Given a test vector-pair for a fault f, if flip-flop X is not allowed to be the immediate predecessor of flip-flop Y in the scanchain, then entry Ax, is increased by one.</p><p>Consider a circuit of two inputs and three flip-flops. Suppose the target delay-fault is redundant in functional justification mode and the test pair generated in enhanced scan mode is ( -1 @ 0 -1 ,O -@lo1 ) . The constraint matrix A which is initialized to 0 will become:</p><p>We continue to update the constraint matrix until all faults in the fault list are processed. Given a particular set of test vector-pairs, the final value of Ai,j can be interpreted as the number of faults that will not be detected by scan shifting if flip-flop i is the immediate predecessor of flip-flop j in the scan-chain. Notice that a delay-fault may have more than one test. Here we just consider one test during the construction of the constraint matrix. Therefore, even if the constraints derived from the test are not completely satisfied, the fault may still be detected by a test other than the one that was used to construct the constraint matrix. Hence, the value of is simply the upper-bound of the number of undetectable faults by scan shifting if flip-flop i is the predecessor of flip-flopj under the vector set used to construct the matrix. Once all faults are processed, we determine a scan ordering to satisfy most constraints.</p><p>Having constructed the constraint matrix the routine DETERMINE-ORDER in Fig. <ref type="figure" target="#fig_7">7</ref> tries to find a scan ordering such that a minimum number of constraints are violated. It selects the flip-flops one by one to form the scan chain. The first flip-flop (head) of the scan-chain, which is not a successor of any flip-flop is determined first. The natural flip-flop to choose to start the chain is the one that would violate the largest number of constraints if it was successor of any other flip-flop in the scan-chain; however, as we don't yet know what the scan-chain will be, we cannot compute this exactly. As a heuristic we choose as head of the scan chain a flip-flop that has the largest column sum of the constraint matrix A. We then repeatedly determine the next flip-flop Y of the scan-chain that has the minimum value of Ai, where i is the previously selected flip-flop.</p><p>Example: Consider a circuit of two inputs, three flipflops and four delay-faults. Suppose all four faults cannot be detected in functional justification mode and the vector pairs generated under enhanced scan are given as in Table <ref type="table" target="#tab_5">VI1</ref> .</p><p>The order of the scan-chain has nothing to do with the values of il and i2. The constraint matrix that is initialized to zero becomes:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>----</head><p>head of the scan-chain because it has the largest column sum (equal to 4) of the constraint matrix. Since A,,* = = 1 and column sum of flip-flop 3 (equal to 3) is larger than that of flip-flop 2 (equal to l), flip-flop 3 is selected as the next element of the scan-chain. The last element of the scan chain is then flip-flop 2. In this scan order, the required state of vector 2 (s2) can be generated from s1 by scan shifting the tests for fault 2, 3 and 4 with the given vector pairs shown above. Notice that fault 1 may still be detected if it has other tests beside the one given in the table above. Note also that if the order of the flip-flops in the scan-chain is flip-flop 1, 2 and 3, only fault 3 can be detected by its test vector pair given above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">I. Experimental Results</head><p>Table <ref type="table" target="#tab_8">VI11</ref> gives the results for two different orderings of the scan-chain: one follows the same order of their appearance in the netlist file (called default order) and the other determined by our algorithm give in Section 5 . 3 , called eficient order. Since a fault that is redundant in the enhanced-scan circuit must be redundant in both functional justification and scan shifting modes, we only use the enhanced-scan testable faults in our standard-scan test generation experiments. The fault coverage is computed as the detected path-delay-faults over total enhanced-scan testable faults.</p><p>In all examples except one (s510), the fault coverage of the best scan order is higher than that of the default scan order. In average of 20 circuits, the former is about 20% higher than the latter. In the case of s510, almost all entries of the constraint matrix have similar values. Thus, different scan orderings will give similar fault coverages. The time given under column "efficient order" includes the time for determining the scan order. I.e., the average CPU time per fault is computed as: (total time for determining the scan order + total test generation time for the circuits using the efficient scan order)/total faults. In the step of determining the scan ordering, we did not run the test generator in the functional justification mode to save run time for this step. In this step, for each enhanced-scan testable fault, a test pair is generated under the enhanced scan mode and the test pair is used for constructing the constraint matrix. Because the CPU time consumed by routine DETERMINE-ORDER ( ) is very small, the time reported under column "efficient order" is very close to the sum of the test generation time under enhanced scan and the test generation time under standard scan using the efficient scan order. The test generation time in scan shifting mode is significantly faster than that in functional justification mode. If the efficient scan order is used, more faults are detected in scan shifting mode and, thus, less faults need to be tried under functional justification. This explains why the run time of the efficient scan order is about 30% faster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Selecting Flip-Flops to be Made Enhanced-Scan</head><p>Even with an efficient order of the flip-flops in the scan chain, a certain percentage of delay-faults that are detectable in the enhanced scan design environment remain undetectable in the standard scan design environment. If the fault coverage in standard scan environment is not acceptable, a partial-enhanced-scan design methodology can be used. In partial-enhanced-scan design, a subset of flip-flops is selected and made enhanced scan. The corresponding present state lines of the enhanced-scan flip-flops are fully controllable in both time-frames in test generation. Many of the standard-scan undetectable faults will become detectable in the partial-enhanced-scan environment and a required level of delay-fault coverage may be achieved.</p><p>Given a set of faults that are testable under enhancedscan but are redundant in either functional justification mode or scan shifting mode with a given ordering of flipflops, the proposed method attempts to minimize the number of flip-flops to be made enhanced-scan so as to detect all or a specified percentage of the given delay-faults.</p><p>In the following, we first give the formulation of the problem. Since finding the optimal solution requires solving an NP-complete problem, we resort to heuristics to find an efficient solution.</p><p>Let us denote the ON-set and OFF-set of a flip-flopfi.</p><p>as ON (a.) and OFF (8) and the value of a flip-flop fi. on vectorj as vi(&amp;.). The set of flip-flops that is neither enhanced-scan (i.e., is standard-scan) nor the head of the scan chain is denoted as SS. In the partial-enhanced-scan design environment, if a given faultfis detectable in the functional justification mode, it means that there exists a vector pair ( U , , v2) that satisfies the following properties:</p><p>(1.1) the vector pair sensitizes the necessary paths for The second (third) term in (1.2) is the cube intersection of the ON-sets (OFF-sets) of those flip-flops that are not enhanced-scan and their value in v2 is 1 (0). If these three cubes are compatible (i.e., their cube intersection is not empty), then it will be possible to generate vector 2 through functional justification.</p><p>For a given scan ordering, we denote the predecessor of a flip-flop&amp;. as P ( f i . ) . If a given faultfis detectable in the scan shifting mode, it means that there exists a vector pair that satisfies the following properties:</p><p>(2.1) the vector pair sensitizes the proper paths for the given delay -fault;</p><p>Oor -;</p><p>(2.2) ~f i ,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E SS and ~2 ( 8 )</head><p>= 0, vl(P(fi.)) = Property (2.2) simply means that for every standardscan flip-flop whose required value in v2 is 0, the value of its predecessor in the scan-chain in v1 must be either 0 or don't-care. Property (2.3) has a similar meaning.</p><p>The procedure of selecting flip-flops for partial enhanced scan is summarized as follows: If the set of the enhanced-scan flip-flops ES covers set F F f ( f ) , then vector pair i , that would detect faultf, can be produced through functional justification. Similarly, if it covers F F y ( f ) , then the corresponding vector pair can be produced through scan shifting. If ES covers either one of them for some vector pair i, the fault will be detectable in this partial-enhanced-scan environment.</p><p>The complexity of computing F F f ( f ) is very high while that of F F Y ( f ) is relatively easy. Thus, in our experiments, we only computed FFY and computed only one test vector pair per fault (i.e., restricted the size of T ( <ref type="formula">f</ref>  </p><formula xml:id="formula_1">-0 00000 -0 1 -11- -I -1- -- 0 -0 -1 f l f 2 11 1 -10- 10 0-loo 1- 1 lo00 1- 10-1- f 3 f 4 --</formula><p>The user first specifies the required delay -fault coverage. During this process, the fault coverage is estimated as the number of faults whose FFY are covered by the current set of selected enhanced-scan flip-flops plus the number of standard-scan detectable faults divided by the total number of enhanced-scan detectable faults. Since a fault whose FFY is not covered by the enhanced-scan flipflops is not necessarily partial-enhanced-scan undetectable, this estimation is a lower bound of the coverage. To compute the final fault coverage, test generation of those uncovered faults in the partial-enhanced-scan environment should be re-run.</p><p>Table <ref type="table" target="#tab_10">X</ref> shows the results of partial-enhanced-scan by specified 100% and 95% coverage as the desirable coverage. Notice that the fault coverage is computed as the detected faults over total enhanced-scan testable faults. The faults that are redundant under enhanced-scan are excluded from consideration.</p><p>The order of the flip-flops in the scan-chain is assumed the efficient order determined by the method described in Section 5 . 3 . Table <ref type="table" target="#tab_10">X</ref> gives the number and percentage of selected enhanced-scan flip-flops. Once the flip-flops are selected, the test generation is re-run assuming the selected flip-flops are enhanced-scan and the remaining flipflops are standard-scan. The final fault coverage is also listed in the table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1">Experimental Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Computing Test Vector Sets 5.5.1. Introduction</head><p>In order to reduce test application time it is describe to produce a test vector set that is as compact as possible. While fault simulation can be used to dynamically compact a test vector set, we take a more global approach to test vector compaction (within a single output of a function). In hazard-free robust path-delayfault testing only a single path is sensitized by each test vector pair and their is no room for vector compaction. However, for the general robust or non-robust path-delayfault model, multiple paths may be sensitized. The fact that multiple paths may be simultaneously sensitized allows for vector compaction. During the test generation process, vector pairs are produced that detect path delay faults in such a way that the vectors have a maximal number of undefined values. Recall from Section I1 that two vectors are compatible if their values do not conflict in any input. Given this compatibility relation a compatibility graph can be generated and a clique covering algorithm can be applied to compact compatible vectors. This will be discussed in detail in Section 5.5.4. Vector pairs produced from test generation using scan shifting cannot be compacted with vector pairs produced using functional justification, since the two test application methods are fundamentally different, so we will consider the compaction of scan shifting vectors and functionally justified vectors individually. We will describe our compaction strategy for path-delay-faults and gatedelay-faults. We first show the correctness of our compaction strategy for circuits implemented under standard scan using the scan shifting approach and then will discuss the functional justification case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.2.">Correctness of Compaction Strategy We now</head><p>show in detail how vector pairs produced by scan shifting can be compacted.</p><p>Theorem 5.1: Let (ikl @ ski, ik2 @ sk2) and (ill @ sll, i12 @ s12) be two scan-shift vector pairs detecting the path delay faults ?rk and ?rf respectively. If ikl, is compatible with ill, skl is compatible with sll and ik2 is compatible with i12 then ( i k l n ill @ skl n sll, ik2 n i12 @ shift((Sk1 n sll)) can be applied as a scan-shift vector pair that detects path-delay-faults on both ?Tk and ?rl. <ref type="bibr">Pro08</ref> Since skl is compatible with sll for any kind of bit-wise shift (e.g., shift left by l), shift(Sk1) is compatible with shift (sl ,). We know that shift (sl 1) C s12 and sll, iI2 @ sI2) are each scan-shifted vector pairs. This means that shift&amp;) n shif(slI) C sk2 and shift(skl) n shift(sll) E s12. This in turn implies that shift((Skl n sll) E sk2 and shift(skl n sll) E sI2. Therefore, given that ikl is compatible with ill and ik2 is compatible with i12(ikl n Shift(Sk1) c Sk2 because (ikl @ S k i , ik2 @ sk2) and (ill @ ill @ skl n s l l , ik2 n iI2 @ shift(skl n sll)) is a scan-shift vector pair that detects path delay faults on both ?Tk and We now show that the vector pairs produced by functional justification can also be compacted. First some notation: Given a vector pair (ikl @ ski, ik2 @ sk2) nextstates (&amp;I) denotes the next states reached on the application of the input ikl when the machine is in any of the states given by ski.</p><p>Theorem 5.2: Let (ikl @ ski, ik2 @ sk2) and (ill @ sl1, i12 @ s12) be two functional-justification vector pairs detecting the path delay faults ?rk and ?rl respectively. If i k l is compatible with il 1, skl is compatible with sl and ik2 is compatible with i12, then (ikl n ill @ skl n SII, ik2 n i12 @ next-states (ski n sl 1)) is a functional-justification vector pair that detects path-delay-faults on both ?rk and ?rl.</p><p>Pro08 Denote next-states (ski) as the next states reached when the machine is in any of the states given by sk1 on the application of input i k l , and nextstates (s, as the next states reached when the machine is in the states sI1 on the application of input i l l . Since the vector pairs can be functionally justified, we know that nextstares(skl) G sk2 and next-srares(sll) 5 sI2. This means that next-states (ski) n next-states (sl 1) C sk2 and nextstates(skl) n next-states(sll) C s12. This in turn implies that next-states (Ski n SI 1) C sk2 and next-states (ski n si 1) C s12, where next-states (ski n sl corresponds to the next states reached on the application of input ikl n ill when the machine is in the states skl n sll. We know that next-states(skl) is compatible with sll, since i k l is compatible with il and skl is compatible with sI (the machine has to go to some state). Therefore, given that ik2 is compatible with i12(ikl n i l l @ skf n s l l , ik2 n iI2 @ nextstates (ski n sl is a functional-justification vector pair that detects both ?rk and ?rl.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.3.">Compacting Delay-Fault Tests</head><p>In order to compact path-delay-fault tests, we simply use the clique covering approach described in Section 5.5.4.</p><p>Compacting gate delay fault tests is a two-step process. We only require a test for some path that passes through the gate. Therefore, we pick a minimum set of testable paths that cover all the gates in the circuit in polynomial time using the algorithm developed in [21]. This gives us a set of paths, for which we have the test vector pairs. We then use the clique covering approach described in the next section to compact the test vector pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.4.">Clique Covering</head><p>We compact vectors by solving the clique covering problem [22] on an undirected graph built as follows: Each vertex 6 in the graph corresponds to a pair of test vectors (cubes). We have an edge ( V i , 5 ) in the graph if the vector pairs Vi and V, are compatible, according to the definition given in Section 5.5.1. We then proceed to find a clique covering of the graph. Recall that a clique is a fully connected subgraph in a graph with undirected edges between vertices. Clique covering corresponds to selecting a minimum number of cliques that cover all the vertices in the graph. Each clique corresponds to a vector pair that is covered by all the ver- tices (cubes, or vector pairs) in the clique. This vector is compatible with all the cubes in the clique and may therefore be used to simultaneously test all the faults associated with the vector pairs in the clique.</p><p>The above strategy works for Vi's that are composed of pairs of cubes, because cube compatibility is a transitive relation. That is, if c1 is compatible with c2 and c2 is compatible with c3, then c1 is compatible with c3. However, the same is not true of covers i.e., sets of cubes. If we generate more than one test pair per path delay fault, then our 6 ' s may be composed of several cube pairs; we only have to select a vector that is contained in any one of the cube pairs. Therefore, during clique covering, a check has to be made to see if the sets ofcubes, corresponding to vertices in the selected clique, are compatible.</p><p>Motivated by the fact that clique covering is an NPcomplete problem <ref type="bibr" target="#b20">[22]</ref>, we resort to efficient heuristics. We use a greedy heuristic that begins with a seed node, "grows" the node to a maximal clique, selects the clique, deletes all the vertices corresponding to the clique and iterates until all the vertices are selected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.5.">Experimental Results</head><p>Compaction results using the clique covering strategy are presented in Table <ref type="table" target="#tab_11">XI</ref>. As can be seen, factors of up to 10 have been achieved by virtue of a global optimization strategy toward test compaction. The vector set for compaction is derived by our test generator running under standard scan for all pathdelay faults. For s5238 and s9234 which have more paths, 5000 paths are randomly selected for consideration. For each fault, scan shifting is first attempted. The efficient scan ordering determined by the method described in Section 5.3 is assumed. If the fault is redundant in scan shifting, functional justification is further attempted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS</head><p>It is our belief that one of the principal obstacles to the wider practical application of test generation for faults in path-delay-fault and gate-delay-fault models is the inability to delay-test a sequential circuit using a standard-scan methodology. In this paper we have addressed this problem, and given a variety of techniques that can be used to generate delay tests for sequential circuits. Furthermore, we have shown how various synthesis techniques can be applied to improve the delay-fault testability of circuits in a standard scan methodology. It appears that entire integrated circuits of moderate complexity can be synthesized for high (nearly 100 %) gate-delay-fault coverage, using our techniques.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>bust path-delay-fault model in [4], [7].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Fig. 1. A FSM and its STG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Transformations to achieve testability under one-hot coding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>1222 IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 12, NO. 8</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. A simple feedback-free circuit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Fig. 6. Scan design structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Algorithm for determining scan-chain order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>FOR</head><label></label><figDesc>EACH FAULT ( f ) THAT IS ENHANCED-SCAN DETECTABLE BUT STANDARD-SCAN UNDETECTABLE { GENERATE A SET OF VECTOR PAIRS, T( f ) , THAT DETECT^ UNDER ENHANCED-SCAN; FOR EACH VECTOR PAIR i E T(f) OBTAIN A MINIMAL SET OF FLIP-FLOPS FF? ( f ) FOR ENHANCED-SCAN SUCH THAT (1.2) IS SATISFIED; I* In this case, the required state of vector 2 can be produced through finctional just$cation. */ FOR EACH VECTOR PAIR i E T( f ), OBTAIN A MINIMAL SET (2.2) AND (2.3) ARE SATISFIED; /* In this case, the required state of vector 2 can be produced through scan shifting. */ }FIND A MINIMAL SET (ES) OF FLIP-FLOPS FOR ENHANCED-OF FLIP-FLOPS FFy ( f ) FOR ENHANCED-SCAN SUCH THAT SCAN SUCH THAT, FOR EVERY FAULT OR A GIVEN PER-CENTAGE OF FAULTS, AT LEAST ONE SET OUT OF THE SETS FF? (f) AND FF; ( f) IS COVERED BY ES.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Consider a circuit of two inputs, five flipflops ( a , b, c , d and e ) and four enhanced-scan detectable but standard-scan undetectable faults. The vector pairs generated under enhanced-scan for these four faults are listed in Table IX. Here only one vector pair is generated under enhanced scan (n = 1 ) and only FFY is computed. Assume the scan ordering is: scan-in -+ a -+ b + c -+ d + e + scan-out. Hence, P ( b ) = a , P ( c ) = b, *etc.The sets of F F Y ( f l ) , F F Y ( f 2 ) , F F Y ( f 3 ) andFFY(f4) are { c , d ) , { c ) , { d } , { b , d } . If flip-flops b , cand d are selected to be enhanced-scan, all four faults will be detected in the partial-enhanced-scan environment using scan shifting. If only flip-flops c and d are selected, f 1 , f 2 and f 3 will be covered. In this case, fault f 4 may still be covered if (1) vector (1 -@llOOO) n ON(a)n OFF(b) # 0 or ( 2 ) there are other test pairs forf4 that satisfies either (1.1) and (1.2) or (2.1), (2.2) and (2.3).Once the sets FFY are computed, the selection of a set of flip-flops to cover the largest number of faults is equivalent to a set covering problem [20] (an NP-complete problem). The following heuristic is used.Compute the frequency of every flip-flop unselected thus far. The frequency is the number of faults 5 whose set FFY (5) contains that flip-flop.Select the flip-flop having the highest frequency. Eliminate the faults whose set FFY are covered by the current set of selection and estimate the fault coverage. If the estimated fault coverage is lower than the required level, go to step 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>lay fault model, treated in [l], [4].' A robust test is said to be a hazard-free robust test if no hazards can occur on the tested path during the application of the test, regardless of gate delay values.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Consider an AND gate g in C . We have four possible cases if we wish to test the AND gate g : 1) test g for a 1 + 0 gate delay fault to a PO line o; 2) test g for a 1 + 0 gate delay fault to a NS line n; 3) test g for a 0 + 1 gate delay fault to a PO line 0; 4) test g for a 0 + 1 gate delay fault to a NS line n.</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE I RESULTS</head><label>I</label><figDesc>OF GATE-DELAY FAULT COVERAGE</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>gate-delay fault cov.</head><label></label><figDesc></figDesc><table><row><cell>Circuit</cell><cell>#input</cell><cell>#output</cell><cell>#state</cell><cell>sacred</cell><cell>one-hot</cell></row><row><cell>shiftreg</cell><cell>1</cell><cell>1</cell><cell>8</cell><cell>100.0%</cell><cell>100.0%</cell></row><row><cell>tav</cell><cell>4</cell><cell>4</cell><cell>4</cell><cell>100.096</cell><cell>100.04%</cell></row><row><cell>train1 1</cell><cell>2</cell><cell>1</cell><cell>11</cell><cell>95.9%</cell><cell>100.096</cell></row><row><cell>bbara</cell><cell>4</cell><cell>2</cell><cell>10</cell><cell>96.8%</cell><cell>100.096</cell></row><row><cell>cse</cell><cell>7</cell><cell>7</cell><cell>16</cell><cell>95.9%</cell><cell>99.7%</cell></row><row><cell>dk14</cell><cell>3</cell><cell>5</cell><cell>7</cell><cell>97.0%</cell><cell>100.0%</cell></row><row><cell>malati</cell><cell>4</cell><cell>4</cell><cell>24</cell><cell>99.4%</cell><cell>96.2%</cell></row><row><cell>sl</cell><cell>8</cell><cell>6</cell><cell>19</cell><cell>97.9%</cell><cell>99.6%</cell></row><row><cell>donfilex</cell><cell>1</cell><cell>1</cell><cell>24</cell><cell>96.9%</cell><cell>99.6%</cell></row><row><cell>tbk</cell><cell>6</cell><cell>3</cell><cell>32</cell><cell>98.4%</cell><cell>100.0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE IV ISCAS</head><label>IV</label><figDesc></figDesc><table><row><cell></cell><cell cols="3">-89 SEQUENTIAL BENCHMARK CIRCUITS</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>number of</cell><cell>number of</cell></row><row><cell></cell><cell></cell><cell></cell><cell>gate-</cell><cell>path-</cell></row><row><cell></cell><cell>number of</cell><cell>number of</cell><cell>delay-</cell><cell>delay-</cell></row><row><cell>Circuit</cell><cell>gates</cell><cell>flip-flops</cell><cell>faults</cell><cell>faults</cell></row><row><cell>s27</cell><cell>10</cell><cell>3</cell><cell>34</cell><cell>56</cell></row><row><cell>s208</cell><cell>96</cell><cell>8</cell><cell>230</cell><cell>290</cell></row><row><cell>s298</cell><cell>119</cell><cell>14</cell><cell>272</cell><cell>462</cell></row><row><cell>s344</cell><cell>160</cell><cell>15</cell><cell>368</cell><cell>710</cell></row><row><cell>s382</cell><cell>158</cell><cell>21</cell><cell>364</cell><cell>800</cell></row><row><cell>400</cell><cell>148</cell><cell>21</cell><cell>372</cell><cell>900</cell></row><row><cell>s420</cell><cell>196</cell><cell>16</cell><cell>462</cell><cell>738</cell></row><row><cell>s444</cell><cell>181</cell><cell>21</cell><cell>410</cell><cell>1070</cell></row><row><cell>s510</cell><cell>211</cell><cell>6</cell><cell>472</cell><cell>738</cell></row><row><cell>s526</cell><cell>194</cell><cell>21</cell><cell>434</cell><cell>820</cell></row><row><cell>s526n</cell><cell>193</cell><cell>21</cell><cell>436</cell><cell>816</cell></row><row><cell>s820</cell><cell>289</cell><cell>5</cell><cell>624</cell><cell>984</cell></row><row><cell>s832</cell><cell>287</cell><cell>5</cell><cell>620</cell><cell>1012</cell></row><row><cell>s953</cell><cell>395</cell><cell>32</cell><cell>880</cell><cell>2266</cell></row><row><cell>sl196</cell><cell>529</cell><cell>18</cell><cell>1122</cell><cell>5998</cell></row><row><cell>s1238</cell><cell>508</cell><cell>18</cell><cell>1080</cell><cell>5998</cell></row><row><cell>s1488</cell><cell>653</cell><cell>6</cell><cell>1334</cell><cell>1924</cell></row><row><cell>s1494</cell><cell>653</cell><cell>6</cell><cell>1322</cell><cell>1952</cell></row><row><cell>s5378 99234</cell><cell>2779 5597</cell><cell>179 228</cell><cell>6038 11688</cell><cell>&gt; loo00 &gt; loo00</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE VI RESULTS</head><label>VI</label><figDesc>OF TEST GENERATION USING BOTH SCAN SHIFTING (WITH DEFAULT SCAN-CHAIN ORDER) AND FUNCTIONAL-JUSTIFICATION</figDesc><table><row><cell></cell><cell cols="2">Path-delay-fault</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>gate-fault</cell><cell>ave. CPU</cell></row><row><cell>Circuit</cell><cell>detected</cell><cell>redundant</cell><cell>covered</cell><cell>sec. per fault</cell></row><row><cell>s27</cell><cell>100.0%</cell><cell>0.0%</cell><cell>100.096</cell><cell>0.00</cell></row><row><cell>s208</cell><cell>60.7%</cell><cell>39.3%</cell><cell>95.2%</cell><cell>0.04</cell></row><row><cell>s298</cell><cell>59.4%</cell><cell>40.6%</cell><cell>88.2%</cell><cell>0.04</cell></row><row><cell>s344</cell><cell>62.8%</cell><cell>37.2%</cell><cell>92.7%</cell><cell>0.20</cell></row><row><cell>s382</cell><cell>54.8%</cell><cell>45.2%</cell><cell>96.2%</cell><cell>0.34</cell></row><row><cell>s400</cell><cell>54.9%</cell><cell>45.1%</cell><cell>94.9%</cell><cell>0.30</cell></row><row><cell>4 2 0</cell><cell>52.4%</cell><cell>47.6%</cell><cell>92.6%</cell><cell>0.16</cell></row><row><cell>s444</cell><cell>54.2%</cell><cell>45.6%</cell><cell>93.4%</cell><cell>0.46</cell></row><row><cell>s510</cell><cell>57.6%</cell><cell>42.4%</cell><cell>91.7%</cell><cell>0.21</cell></row><row><cell>s526</cell><cell>53.5%</cell><cell>46.5%</cell><cell>84.3%</cell><cell>0.44</cell></row><row><cell>s526n</cell><cell>53.7%</cell><cell>46.3%</cell><cell>84.2%</cell><cell>0.44</cell></row><row><cell>s820</cell><cell>64.9%</cell><cell>35.1%</cell><cell>87.3%</cell><cell>1.62</cell></row><row><cell>s832</cell><cell>64.8%</cell><cell>35.2%</cell><cell>86.8%</cell><cell>1.65</cell></row><row><cell>s953</cell><cell>56.6%</cell><cell>43.2%</cell><cell>88.7%</cell><cell>0.57</cell></row><row><cell>sl196</cell><cell>99.9%</cell><cell>0.01 %</cell><cell>99.2%</cell><cell>0.26</cell></row><row><cell>s1238</cell><cell>99.9%</cell><cell>0.01 %</cell><cell>97.5%</cell><cell>0.26</cell></row><row><cell>s1488</cell><cell>57.3%</cell><cell>42.7%</cell><cell>87.9%</cell><cell>0.89</cell></row><row><cell>s 1494</cell><cell>57.1%</cell><cell>42.9%</cell><cell>80.0%</cell><cell>0.88</cell></row><row><cell>s5378</cell><cell>78.7%</cell><cell>3.4%</cell><cell>58.4%</cell><cell>8.12</cell></row><row><cell>s9234</cell><cell>54.3%</cell><cell>19.8%</cell><cell>5.7%</cell><cell>8.20</cell></row><row><cell>average</cell><cell>64.9%</cell><cell>32.9%</cell><cell>85.2%</cell><cell>1.25</cell></row><row><cell>TABLE V</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>RESULTS OF TEST GENERATION ASSUMING ENHANCED SCAN DESIGN</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>We present an algorithm to Compute an efficient ordering of the flip-flops i n the scan-chain that maximizes the coverage of the delay faults. The algorithm uses the information derived from running a delay test</figDesc><table><row><cell></cell><cell cols="2">Path-delay-fault</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Circuit s27</cell><cell>detected 89.3%</cell><cell>redundant 10.7%</cell><cell cols="3">gate-fault c o v e d In this Section, 100.0% ave. CPU sec. oer fault 0.05</cell></row><row><cell>s208</cell><cell>100.096</cell><cell>0.0%</cell><cell>100.096</cell><cell>0.012</cell><cell></cell></row><row><cell>s298</cell><cell>76.2%</cell><cell>23.8%</cell><cell>100.0%</cell><cell>0.013</cell><cell></cell></row><row><cell>s344 s382</cell><cell>90.6% 88.0%</cell><cell>9.4% 12.0%</cell><cell>98.6% 100.0%</cell><cell>0.021 0.031</cell><cell>generator on the circuit.</cell></row><row><cell>s400</cell><cell>80.3%</cell><cell>19.7%</cell><cell>99.2%</cell><cell>0.030</cell><cell></cell></row><row><cell>s420</cell><cell>100.096</cell><cell>0.0%</cell><cell>100.096</cell><cell>0.026</cell><cell></cell></row><row><cell>s444</cell><cell>67.6%</cell><cell>32.4%</cell><cell>98.8%</cell><cell>0.040</cell><cell></cell></row><row><cell>s510</cell><cell>100.0%</cell><cell>0.0%</cell><cell>100.096</cell><cell>0.030</cell><cell></cell></row><row><cell>s526</cell><cell>86.3%</cell><cell>13.7%</cell><cell>100.0%</cell><cell>0.022</cell><cell></cell></row><row><cell>s526n</cell><cell>87.0%</cell><cell>13.0%</cell><cell>100.0%</cell><cell>0.022</cell><cell></cell></row><row><cell>s820</cell><cell>100.0%</cell><cell>0.0%</cell><cell>100.096</cell><cell>0.046</cell><cell></cell></row><row><cell>s832</cell><cell>98.4%</cell><cell>1.6%</cell><cell>99.7%</cell><cell>0.050</cell><cell></cell></row><row><cell>s953</cell><cell>100.0%</cell><cell>0.0%</cell><cell>94.8%</cell><cell>0.054</cell><cell></cell></row><row><cell>sl196</cell><cell>59.5%</cell><cell>40.5%</cell><cell>99.3%</cell><cell>0.124</cell><cell></cell></row><row><cell>s1238</cell><cell>51.2%</cell><cell>48.8%</cell><cell>97.6%</cell><cell>0.133</cell><cell></cell></row><row><cell>s1488</cell><cell>99.6%</cell><cell>0.4%</cell><cell>100.0%</cell><cell>0.089</cell><cell></cell></row><row><cell>s1494</cell><cell>98.7%</cell><cell>1.3%</cell><cell>99.8%</cell><cell>0.089</cell><cell></cell></row><row><cell>s5378</cell><cell>79.8%</cell><cell>15.2%</cell><cell>75.7%</cell><cell>1.269</cell><cell></cell></row><row><cell>s9234</cell><cell>4.6%</cell><cell>95.4%</cell><cell>5.9%</cell><cell>0.694</cell><cell></cell></row><row><cell>average</cell><cell>82.9%</cell><cell>16.9%</cell><cell>93.5%</cell><cell>0.140</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>TABLE VI11 PATH-DELAY-FAULT COVERAGE AND RUN TIME USING BOTH SCAN SHIFTING (WITH EITHER DEFAULT OR EFFICIENT SCAN-CHAIN ORDER) AND FUNCTIONAL JUSTIFICATION</head><label>VI11</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>~</cell></row><row><cell></cell><cell cols="2">default order</cell><cell cols="2">efficient order</cell></row><row><cell></cell><cell>fault</cell><cell>ave. CPU sec.</cell><cell>fault</cell><cell>ave. CPU sec.</cell></row><row><cell>Circuit</cell><cell>coverage</cell><cell>per fault</cell><cell>coverage</cell><cell>per fault</cell></row><row><cell>s27</cell><cell>100.0%</cell><cell>0.00</cell><cell>100.0%</cell><cell>0.00</cell></row><row><cell>s208</cell><cell>60.7%</cell><cell>0.04</cell><cell>69.0%</cell><cell>0.05</cell></row><row><cell>s298</cell><cell>59.4%</cell><cell>0.04</cell><cell>82.1%</cell><cell>0.05</cell></row><row><cell>s344</cell><cell>62.8%</cell><cell>0.20</cell><cell>92.7%</cell><cell>0.21</cell></row><row><cell>s382</cell><cell>54.8%</cell><cell>0.34</cell><cell>95.6%</cell><cell>0.17</cell></row><row><cell>s400</cell><cell>54.9%</cell><cell>0.30</cell><cell>95.3%</cell><cell>0.19</cell></row><row><cell>s420</cell><cell>52.4%</cell><cell>0.16</cell><cell>85.0%</cell><cell>0.15</cell></row><row><cell>s444</cell><cell>54.2%</cell><cell>0.46</cell><cell>96.4%</cell><cell>0.11</cell></row><row><cell>s5 10</cell><cell>57.6%</cell><cell>0.21</cell><cell>56.4%</cell><cell>0.23</cell></row><row><cell>s526</cell><cell>53.5%</cell><cell>0.44</cell><cell>78.1%</cell><cell>0.45</cell></row><row><cell>s526n</cell><cell>53.7%</cell><cell>0.44</cell><cell>78.0%</cell><cell>0.45</cell></row><row><cell>s820</cell><cell>64.9%</cell><cell>1.62</cell><cell>66.7%</cell><cell>0.49</cell></row><row><cell>s832</cell><cell>64.8%</cell><cell>1.65</cell><cell>66.4%</cell><cell>0.51</cell></row><row><cell>s953</cell><cell>56.6%</cell><cell>0.57</cell><cell>100.0%</cell><cell>0.09</cell></row><row><cell>s1196</cell><cell>99.9%</cell><cell>0.26</cell><cell>99.9%</cell><cell>0.29</cell></row><row><cell>s1238</cell><cell>99.9%</cell><cell>0.26</cell><cell>99.9%</cell><cell>0.29</cell></row><row><cell>s1488</cell><cell>57.3%</cell><cell>0.89</cell><cell>61.4%</cell><cell>0.94</cell></row><row><cell>s1494</cell><cell>57.1%</cell><cell>0.88</cell><cell>57.3%</cell><cell>1.03</cell></row><row><cell>s5378</cell><cell>78.7%</cell><cell>8.12</cell><cell>100.0%</cell><cell>5.39</cell></row><row><cell>s9234</cell><cell>54.3%</cell><cell>8.20</cell><cell>100.0%</cell><cell>5.92</cell></row><row><cell>average</cell><cell>64.9%</cell><cell>1.25</cell><cell>83.8%</cell><cell>0.85</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>TABLE IX VECTORS DETECTING FOUR FAULTS Fault 'I s, (ubcde) '2 s2 (ubcde)</head><label>IX</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>TABLE X RESULTS OF PARTIAL-ENHANCED-SCAN</head><label>X</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Selection Criterion</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">100%</cell><cell></cell><cell cols="2">95 %</cell></row><row><cell></cell><cell></cell><cell cols="2">Selected</cell><cell></cell><cell cols="2">Selected</cell><cell></cell></row><row><cell></cell><cell>Total</cell><cell cols="6">FFs -Final -Final FFS</cell></row><row><cell cols="3">Circuit Flip-Flops #</cell><cell>%</cell><cell cols="2">fault covg. #</cell><cell>%</cell><cell>fault covg.</cell></row><row><cell>s27</cell><cell>3</cell><cell>0</cell><cell>0%</cell><cell>100%</cell><cell>0</cell><cell>0%</cell><cell>100%</cell></row><row><cell>s208</cell><cell>8</cell><cell cols="2">7 88%</cell><cell>100%</cell><cell cols="2">7 88%</cell><cell>100%</cell></row><row><cell>s298</cell><cell>14</cell><cell cols="2">5 36%</cell><cell>100%</cell><cell cols="2">2 14%</cell><cell>99.4%</cell></row><row><cell>s344</cell><cell>15</cell><cell cols="2">9 60%</cell><cell>100%</cell><cell cols="2">5 33%</cell><cell>98.3%</cell></row><row><cell>s382</cell><cell>21</cell><cell cols="2">4 19%</cell><cell>100%</cell><cell cols="2">2 10%</cell><cell>96.6%</cell></row><row><cell>S400</cell><cell>21</cell><cell cols="2">4 19%</cell><cell>100%</cell><cell cols="2">2 10%</cell><cell>96.3%</cell></row><row><cell>s420</cell><cell>16</cell><cell cols="2">15 94%</cell><cell>1 0 0 %</cell><cell cols="2">13 81%</cell><cell>95.8%</cell></row><row><cell>S444</cell><cell>21</cell><cell cols="2">4 19%</cell><cell>100%</cell><cell cols="2">2 10%</cell><cell>97.8%</cell></row><row><cell>s5 10</cell><cell>6</cell><cell cols="2">5 83%</cell><cell>100%</cell><cell cols="2">5 83%</cell><cell>100%</cell></row><row><cell>s526</cell><cell>21</cell><cell cols="2">4 19%</cell><cell>100%</cell><cell cols="2">3 14%</cell><cell>98.4%</cell></row><row><cell>s526n</cell><cell>21</cell><cell cols="2">4 19%</cell><cell>100%</cell><cell cols="2">3 14%</cell><cell>98.4%</cell></row><row><cell>s820</cell><cell>5</cell><cell cols="2">4 80%</cell><cell>100%</cell><cell cols="2">4 80%</cell><cell>100%</cell></row><row><cell>s832</cell><cell>5</cell><cell cols="2">4 80%</cell><cell>100%</cell><cell cols="2">4 80%</cell><cell>100%</cell></row><row><cell>s953</cell><cell>32</cell><cell>0</cell><cell>0%</cell><cell>100%</cell><cell>0</cell><cell>0%</cell><cell>1 0 0 %</cell></row><row><cell>sl196</cell><cell>18</cell><cell>0</cell><cell>0%</cell><cell>100%</cell><cell>0</cell><cell>0%</cell><cell>100%</cell></row><row><cell>s1238</cell><cell>18</cell><cell>0</cell><cell>0%</cell><cell>100%</cell><cell cols="2">0 0%</cell><cell>100%</cell></row><row><cell>s1488</cell><cell>6</cell><cell cols="2">5 83%</cell><cell>100%</cell><cell cols="2">5 83%</cell><cell>100%</cell></row><row><cell>s1494</cell><cell>6</cell><cell cols="2">5 83%</cell><cell>100%</cell><cell cols="2">5 83%</cell><cell>100%</cell></row><row><cell>s5378</cell><cell>179</cell><cell>0</cell><cell>0%</cell><cell>100%</cell><cell>0</cell><cell>0%</cell><cell>100%</cell></row><row><cell>s9234</cell><cell>228</cell><cell>0</cell><cell>0%</cell><cell>100%</cell><cell>0</cell><cell>0%</cell><cell>100%</cell></row><row><cell>average</cell><cell>-</cell><cell cols="2">-39%</cell><cell>100%</cell><cell cols="2">-34%</cell><cell>99.1%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>TABLE XI TEST</head><label>XI</label><figDesc>COMPACTION RESULTS OF ISCAS-89 BENCHMARK CIRCUITS</figDesc><table><row><cell></cell><cell cols="2">Before Compaction</cell><cell cols="2">After Compaction</cell></row><row><cell>Circuit</cell><cell>Scan</cell><cell>Justify</cell><cell>Scan</cell><cell>Justify</cell></row><row><cell>s27</cell><cell>100</cell><cell>0</cell><cell>10</cell><cell>0</cell></row><row><cell>s208</cell><cell>396</cell><cell>20</cell><cell>54</cell><cell>6</cell></row><row><cell>s298</cell><cell>518</cell><cell>60</cell><cell>65</cell><cell>13</cell></row><row><cell>s344</cell><cell>1150</cell><cell>42</cell><cell>135</cell><cell>16</cell></row><row><cell>s382</cell><cell>1336</cell><cell>10</cell><cell>157</cell><cell>3</cell></row><row><cell>s400</cell><cell>1372</cell><cell>6</cell><cell>161</cell><cell>2</cell></row><row><cell>s420</cell><cell>1154</cell><cell>108</cell><cell>125</cell><cell>14</cell></row><row><cell>S444</cell><cell>1382</cell><cell>12</cell><cell>143</cell><cell>4</cell></row><row><cell>s5 10</cell><cell>616</cell><cell>188</cell><cell>101</cell><cell>55</cell></row><row><cell>s526</cell><cell>1086</cell><cell>30</cell><cell>110</cell><cell>5</cell></row><row><cell>s526n</cell><cell>1082</cell><cell>30</cell><cell>108</cell><cell>5</cell></row><row><cell>s820</cell><cell>1028</cell><cell>284</cell><cell>183</cell><cell>86</cell></row><row><cell>s832</cell><cell>1064</cell><cell>252</cell><cell>190</cell><cell>72</cell></row><row><cell>s953</cell><cell>4532</cell><cell>0</cell><cell>572</cell><cell>0</cell></row><row><cell>sl196</cell><cell>7396</cell><cell>20</cell><cell>1310</cell><cell>10</cell></row><row><cell>s1238</cell><cell>7306</cell><cell>20</cell><cell>1212</cell><cell>10</cell></row><row><cell>s1488</cell><cell>1962</cell><cell>398</cell><cell>30 1</cell><cell>95</cell></row><row><cell>s1494</cell><cell>1774</cell><cell>442</cell><cell>265</cell><cell>1 L 17</cell></row><row><cell>s5378</cell><cell>15020</cell><cell>74</cell><cell>929</cell><cell>23</cell></row><row><cell>s9234</cell><cell>1452</cell><cell>0</cell><cell>244</cell><cell>0</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>This work was stimulated by valuable discussions with Vijay Iyengar, Ken Wagner, and Tom Williams.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the design of path delay fault testable combinational circuits</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pramanick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Faulr Tolerant Compuring Symp</title>
		<meeting>20th Faulr Tolerant Compuring Symp</meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="374" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the design of robust multiple fault testable CMOS combinational logic circuits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Con$ Compurer-Aided Design</title>
		<meeting>Int. Con$ Compurer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1988-11">Nov. 1988</date>
			<biblScope unit="page" from="240" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Synthesis of delay fault testable combinational logic</title>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lusky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inr. Con$ Compurer-Aided Design</title>
		<meeting>Inr. Con$ Compurer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1989-11">Nov. 1989</date>
			<biblScope unit="page" from="418" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Synthesis and optimization procedures for robustly delay-fault testable logic circuits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th Design Auromarion Conf</title>
		<meeting>27th Design Auromarion Conf</meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="221" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Design of integrated circuits fully testable for delay faults and multifaults</title>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inr. Tesr Conf</title>
		<meeting>Inr. Tesr Conf</meeting>
		<imprint>
			<date type="published" when="1990-10">Oct. 1990</date>
			<biblScope unit="page" from="284" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A model for delay faults based on paths</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inr. Tesr Conf</title>
		<meeting>Inr. Tesr Conf</meeting>
		<imprint>
			<date type="published" when="1985-09">Sept. 1985</date>
			<biblScope unit="page" from="342" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Necessary and sufficient conditions for robust delay-fault testability of logic circuits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Sixrh MIT Con$ on Advanced Research on VLSI</title>
		<imprint>
			<date type="published" when="1990-04">Apr. 1990</date>
			<biblScope unit="page" from="221" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Testing for timing failures in synchronous sequential integrated circuits</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">K</forename><surname>Malaiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Narayanswamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inr. Tesr S. Devadas</title>
		<meeting>Inr. Tesr S. Devadas</meeting>
		<imprint>
			<date type="published" when="1989-08">Aug. 1989</date>
			<biblScope unit="page" from="144" to="152" />
		</imprint>
	</monogr>
	<note>Proc. Inr. Tesr Conf.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Design of scan-testable CMOS sequential circuits</title>
		<author>
			<persName><forename type="first">B</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Menon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inr. Test Conf</title>
		<meeting>Inr. Test Conf</meeting>
		<imprint>
			<date type="published" when="1990-09">Sept. 1990</date>
			<biblScope unit="page" from="369" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Arrangement of latches in scan-path design to improve delay fault coverage</title>
		<author>
			<persName><forename type="first">W</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ciletti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Inr. Tesr Conf</title>
		<meeting>of Inr. Tesr Conf</meeting>
		<imprint>
			<date type="published" when="1990-09">Sept. 1990</date>
			<biblScope unit="page" from="387" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Transition fault simulation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Waicukauski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lindbloom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Iyengar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Design and Test</title>
		<imprint>
			<biblScope unit="page" from="32" to="38" />
			<date type="published" when="1987-04">Apr. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On delay fault testing in logic circuits</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="694" to="703" />
			<date type="published" when="1987-09">Sept. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Peterson</surname></persName>
		</author>
		<title level="m">Inrroducrion to Swirching Theory and Logical Design</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Also appeared as &quot;On properties of algebraic transformations and the synthesis of multifault-imdundant circuits</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Jacoby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Momson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Desinn</title>
		<imprint>
			<biblScope unit="page" from="560" to="571" />
			<date type="published" when="1981">Nov. 1989. Mar. 1992. Oct. 1983. 1981</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Inr. Cont Computer-Aided Design</orgName>
		</respStmt>
	</monogr>
	<note>On the relationship between area optimization and multifault testability of multilevel logic</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Design of sequential machines for efficient test generation</title>
		<author>
			<persName><forename type="first">K-T</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inr. Con$ Computer-Aided Design</title>
		<meeting>Inr. Con$ Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1989-11">Nov. 1989</date>
			<biblScope unit="page" from="358" to="361" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A heuristic algorithm for the testing of asynchronous circuits</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Putzolu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="639" to="647" />
			<date type="published" when="1971-06">June 1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An automatic test pattern generator for the detection of path delay faults</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Con$ Computer-Aided Design</title>
		<meeting>Int. Con$ Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="284" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Test generation for highly sequential circuits</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Newton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. ConJ Computer-Aided Design</title>
		<meeting>Int. ConJ Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1989-11">Nov. 1989</date>
			<biblScope unit="page" from="362" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">1</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On path selection in combinational logic circuits</title>
		<author>
			<persName><forename type="first">W.-N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sahni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="56" to="63" />
			<date type="published" when="1989-01">Jan. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Freeman</publisher>
			<pubPlace>San Francisco, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">please see page 598 of the May 1993 issue of this TRANSACTIONS. Kurt Keutzer (S&apos;82-M&apos;84) received the B.S. degree in mathematics from the Maharishi International University in 1978 and the M.S. and Ph.D. degrees in computer science from Indiana University in 1981 and 1984, respectively. In 1984 he joined AT&amp;T Bell Laboratories, where he worked to apply various computer science disciplines to practical problems in computer-aided design</title>
		<author>
			<persName><surname>Kwang-Ting</surname></persName>
		</author>
		<idno>this TRANSACTIONS. Srinivas Devadas (S&apos;87-M&apos;88</idno>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer-Aided Design, and the inclusion of a paper in the anthology Twenty-Five Years of Electronic Design Automation. Dr. Keutzer serves on the editorial boards of the IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN, the new journal Formal Methods in System Design, a d Bowker&apos;s CADCAM Abstracts</title>
		<meeting><address><addrLine>Mountain View, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">1993. 1991</date>
		</imprint>
	</monogr>
	<note>Tim) Cbeng (S&apos;88-M&apos;88. please see page 24 of the January. where he continues his research. His efforts have led to two Design Automation Conference best paper awards. He also serves on several other technical program committees</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
