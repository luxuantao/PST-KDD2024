<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A framework for efficient spatial web object retrieval</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012-03-18">18 March 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Dingming</forename><surname>Wu</surname></persName>
							<email>dmwu@comp.hkbu.edu.hk</email>
						</author>
						<author>
							<persName><forename type="first">Gao</forename><surname>Cong</surname></persName>
							<email>gaocong@ntu.edu.sg</email>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Hong Kong Baptist University</orgName>
								<address>
									<settlement>Kowloon Tong, Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<settlement>Singapore</settlement>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<settlement>Aarhus</settlement>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A framework for efficient spatial web object retrieval</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2012-03-18">18 March 2012</date>
						</imprint>
					</monogr>
					<idno type="MD5">5F49B7467ADF5720C8FE1B3A034684AA</idno>
					<idno type="DOI">10.1007/s00778-012-0271-0</idno>
					<note type="submission">Received: 20 April 2011 / Revised: 20 February 2012 / Accepted: 5 March 2012 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The conventional Internet is acquiring a geospatial dimension. Web documents are being geo-tagged and geo-referenced objects such as points of interest are being associated with descriptive text documents. The resulting fusion of geo-location and documents enables new kinds of queries that take into account both location proximity and text relevancy. This paper proposes a new indexing framework for top-k spatial text retrieval. The framework leverages the inverted file for text retrieval and the R-tree for spatial proximity querying. Several indexing approaches are explored within this framework. The framework encompasses algorithms that utilize the proposed indexes for computing location-aware as well as region-aware top-k text retrieval queries, thus taking into account both text relevancy and spatial proximity to prune the search space. Results of empirical studies with an implementation of the framework demonstrate that the paper's proposal is capable of excellent performance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Driven in part by the emergence of the mobile Internet, the conventional Internet is acquiring a geo-spatial dimension. On the one hand, many (geo-referenced) points of interestfor example, stores, tourist attractions, hotels, entertainment services, public transport, and public services-are being associated with descriptive text documents. On the other hand, web documents are increasingly being geo-tagged.</p><p>This fusion of geo-location and documents enables queries that take into account both spatial proximity and text relevancy. One study has found that about one fifth of web search queries are geographical and have local intent, as determined by the presence of geographical terms such as place names and postal codes <ref type="bibr" target="#b31">[31]</ref>. Indeed, commercial search engines have started to provide location-based services, such as map services, local search, and local advertisements. For example, Google Maps supports location-aware text retrieval queries. Additional examples of location-based services include online yellow pages.</p><p>This paper proposes a kind of top-k query that takes into account both spatial proximity and text relevancy for points of interest with associated text. An example query may request a "good micro-brewery that serves pizza" and that is close to the user's hotel. We call this type of query a top-k spatial text retrieval query. It consists of a spatial component (the user's hotel) and a text component (good micro-brewery that serves pizza). This kind of query is different from the query that retrieves relevant documents within a geographical range.</p><p>More specifically, we consider two types of top-k spatial text retrieval queries that differ in their spatial components. The Location-aware top-k Text retrieval (LkT) query has a point location as its spatial component. The answer to the LkT query is a list of k objects ranked according to a ranking function that combines their distances to the query location and the relevance of their textual descriptions to the query text. The Region-aware top-k Text retrieval (RkT) query has a region (e.g., a rectangle) as its spatial component. We consider two variants of the RkT query that yield different results. The motivation underlying the RkT queries is that the spatial component of a query may be inaccurate and thus is better modeled by a region rather than a point location. This inaccuracy may be due to several reasons. First, positioning devices might not be accurate enough to provide point locations. Second, in some applications, for example, Google Maps, users enter keywords to represent their locations, for example, the names of streets, which are regions. Third, for privacy reasons, users may not want to reveal their accurate locations by enlarging points to regions.</p><p>In the paper, we compute the text relevancy of a query result by means of language models and a probabilistic ranking function that have sound foundations in statistical theory and that have performed well empirically in many information retrieval tasks <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b36">36]</ref>.</p><p>The top-k spatial text retrieval queries pose new challenges to both existing spatial database and existing information retrieval techniques that have evolved separately. The research in spatial databases mainly focuses on highly structured, map-based geometric data and their attributes. In contrast, information retrieval research often treats location information as common keywords.</p><p>We propose a new indexing framework for processing topk spatial text retrieval queries. This framework integrates the inverted file for text retrieval and the R-tree for spatial proximity querying to obtain an Inverted file R-tree, called the IR-tree, that is essentially an R-tree extended with inverted files. Associated algorithms are proposed for the processing of the LkT and RkT queries that are capable of pruning the search space by simultaneously making use of both spatial proximity and text relevancy.</p><p>Each node of the IR-tree records a summary of the location information and the textual content of all the objects in the subtree rooted at the node. The query processing algorithms utilize the location information to estimate the spatial distance of a query to the objects in the node's subtree, and they use the text information to estimate the text relevancy scores for these objects.</p><p>We also explore a variant of the IR-tree that incorporates document similarity when computing Minimum Bounding Rectangles (MBRs), yielding a new index called the DIRtree. While the IR-tree considers only location information when generating its MBRs, the DIR-tree takes into account both location information and document similarity. The IRtree can be seen as a special case of the DIR-tree. To further improve the performance of the IR-tree and the DIR-tree, we cluster the documents attached to spatial objects. In an index node, tighter text relevancy scores can be estimated for a group of similar documents than for diverse documents that belong to different categories. This cluster-enhanced method can be applied to both the IR-tree and the DIR-tree, yielding the CIR-tree and the CDIR-tree.</p><p>To further optimize the IR-tree, we propose two techniques to derive tighter MBRs. The first technique constructs an MBR for each term (word) in the inverted files of each node, which we call a TermMBR. This technique can be applied to all the above-mentioned four indexes. The second technique constructs an MBR for each cluster of each node in the CIR-tree and the CDIR-tree, which we call a Cluster-MBR.</p><p>The paper extends a previously published conference paper <ref type="bibr" target="#b7">[8]</ref>. Beyond a recent paper <ref type="bibr" target="#b22">[22]</ref> that proposes a variation of the IR-tree presented in the conference paper, we are not aware of any techniques in the literature that efficiently support the computation of the top-k spatial text retrieval queries considered in this paper. In Sect. 8, we cover the extensions over these papers in detail. Some techniques <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b38">38]</ref> use an ad hoc combination of nearest neighbor (NN) and keyword search techniques for spatial text retrieval. For example, an R-tree is used to find the nearest neighbors, and then for each neighbor, an inverted file is used to rank the objects according to text relevancy. This ad hoc combination cannot easily be applied to process top-k spatial text retrieval queries because it is difficult to determine in advance the number of nearest neighbors needed to obtain the top-k results ranked by a combination of spatial proximity and text relevancy. A recent proposal <ref type="bibr" target="#b9">[10]</ref> integrates the R-tree with signature files. However, this proposal is inapplicable to top-k spatial text retrieval (which involves ranking, not just the checking of Boolean predicates) mainly due to the use of signature files, which cannot sensibly handle ranked text retrieval <ref type="bibr" target="#b39">[39]</ref>.</p><p>In summary, the paper's contribution is threefold. First, we introduce two types of top-k spatial text retrieval queries, called LkT and RkT queries, that return objects ranked according to a linear interpolation function that combines normalized spatial proximity and text relevancy.</p><p>Second, to efficiently process these queries, we propose a new indexing framework that integrates location indexing and text indexing. Specifically, we develop the IR-tree and associated algorithms for the processing of LkT and RkT queries. A variant of the IR-tree, the DIRtree, is proposed to incorporate document similarity when computing MBRs. We also exploit document clustering to improve the indexing framework. Additionally, we propose so-called ClusterMBRs and TermMBRs to compute tighter MBRs with the aim of improving query processing performance.</p><p>Third, we evaluate the paper's proposals. Results of empirical studies with implementations of the proposed techniques demonstrate that the paper's proposals offer scalability and are capable of excellent performance. An analytical study offers insight into the query performance of the IR-tree and suggests that it outperforms the recent variant <ref type="bibr" target="#b22">[22]</ref> quite significantly in realistic settings.</p><p>The rest of this paper is organized as follows. Section 2 formally defines the Location-aware top-k Text retrieval problem and the Region-aware top-k Text retrieval problem. Two baseline algorithms are proposed in Sect. <ref type="bibr" target="#b2">3</ref>. Section 4 presents the index framework for processing the LkT query. Section 5 proposes four methods for enhancing the framework. Algorithms for RkT queries are presented in Sect. <ref type="bibr" target="#b5">6</ref>. We cover the empirical performance study in Sect. <ref type="bibr" target="#b6">7</ref>. Finally, we cover related work in Sect. 8 and offer conclusions and research directions in Sect. 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem statement</head><p>Let D be a database. Each spatial web object O in D is defined as a pair (O.λ, O.ψ), where O.λ is a location descriptor in multidimensional space and O.ψ is a document (e.g., a dining menu) that describes the object (e.g., an Italian restaurant). We assume a two-dimensional geographical space composed of latitude and longitude, but the paper's proposals generalize to other multidimensional spaces of low dimensionality.</p><p>Intuitively, a Location-aware top-k Text retrieval (LkT) query retrieves k objects in database D for a given query Q such that their locations are the closest to the location specified in Q and their textual descriptions are the most relevant to the keywords in Q. Formally, given a query Q, defined as a pair (Q.λ, Q.ψ), where Q.λ is a location descriptor and Q.ψ is a set of keywords, the objects returned are ranked according to a ranking function given by:</p><formula xml:id="formula_0">f (D ε (Q.λ, O.λ), P(Q.ψ| O.ψ)), where D ε (Q.λ, O.λ) is the Euclidian distance between Q and O and P(Q.ψ|O.ψ)</formula><p>is the text relevancy of O.ψ with regard to Q.ψ. The text relevancy can be computed as the probability of generating query Q.ψ from the language models of the documents or other text models.</p><p>We tackle the problem of efficiently answering LkT queries. Thus, given a query Q, we retrieve a ranked list of k objects according to their ranking scores as computed by the ranking function f (•, •) introduced above. The paper's proposals are applicable to a wide range of ranking functions, namely all functions that are monotone with respect to distance proximity and text relevancy.</p><p>In this paper, we follow existing work and use linear combinations <ref type="bibr" target="#b24">[24]</ref>. Specifically, we derive a ranking function as a weighted sum of normalized terms for ranking an object O with regard to a query Q, called spatial-textual distance and denoted by</p><formula xml:id="formula_1">D ST (Q, O). D ST (Q, O) = α D ε (Q.λ, O.λ) maxD +(1 -α) 1 - P(Q.ψ|O.ψ) maxP ,<label>(1)</label></formula><p>where α ∈ [0, 1] is a parameter used to balance spatial proximity and text relevancy; the Euclidian distance between Q and O, D ε (Q.λ, O.λ), is normalized by maxD, which can be, for example, the maximum distance between two objects in D; and maxP is used to normalize the text relevancy score into the range from 0 to 1. Note that the lower the score computed by ranking function, the better. The parameter α in Eq. 1 allows users to set their preferences between text relevancy and location proximity at query time. Note that this study focuses on efficient solutions, not on new effective ranking functions.</p><p>The query location Q.λ in an LkT query is a point. In some applications, as stated in Sect. 1, users may give a region rather than an accurate point location. A Region-aware top-k Text retrieval (RkT) query Q, defined as a pair (Q.Ω, Q.ψ) covers this scenario, where Q.Ω is a region, for example, a rectangle. We propose two specializations of the RkT query: RkT e and RkT u .</p><p>The RkT e query Q returns exactly k objects and uses the same ranking function as does the LkT query. The only difference is that if</p><formula xml:id="formula_2">O.λ ∈ Q.Ω then D ε (Q.Ω, O.λ) = 0; oth- erwise, the Euclidean distance D ε (Q.Ω, O.λ) is defined as the minimum Euclidian distance between Q and O, denoted by mindist(Q.Ω, O.λ).</formula><p>The result of the RkT u query Q is not a ranked list, but the union of the LkT (q, Q.ψ) result sets, where q is every possible point in region Q.Ω. Formally,</p><formula xml:id="formula_3">RkT u (Q.Ω, Q.ψ) = q∈Q.Ω {LkT (q, Q.ψ)}.</formula><p>(</p><p>In the definition, we use set notation ("{• • • }") to emphasize that the LkT query results are viewed as sets. Thus, the result of the RkT u query is a union of sets, which is a set.</p><p>The RkT e and the RkT u queries differ in how distances between objects and queries are measured. In general, the RkT query targets application scenarios where users cannot provide accurate point locations, for example, due to inaccurate positioning or the service provider not having access to the users' locations due to privacy concerns. If we assume that the query point location is hidden inside the spatial region given in the query and the real result is known, the RkT e and the RkT u queries both return approximate results. The RkT e query considers the minimum Euclidean distance between the query region and the objects, so its result may contain some false hits and may miss some true result objects. The result of the RkT u query is a superset of the real result, since it    <ref type="table" target="#tab_0">1</ref> shows a document-by-term matrix of their documents. For example, the matrix shows that the weight of term Chinese in document O 1 .ψ is 0.5. The weight of a term that does not appear in a document is set to a small value, for example, 0.001. Given an LkT (k = 1) query Q with location Q.λ as shown in Fig. <ref type="figure" target="#fig_0">1</ref> and Q.ψ = (Chinese restaurant), object O 1 is the result with ranking score 0.475 according to Tables <ref type="table" target="#tab_11">1</ref> and<ref type="table" target="#tab_1">2</ref> (α = 0.5). Given an RkT e (k = 1) query Q with region Q .Ω, shown as a dashed rectangle in Fig. <ref type="figure" target="#fig_0">1</ref>, and Q .ψ = (Spanish food), object O 3 is the result with ranking score 0.49995 according to Tables <ref type="table" target="#tab_11">1</ref> and<ref type="table" target="#tab_1">2</ref> </p><formula xml:id="formula_5">D ε (Q.λ, ) mindist(Q .Ω, ) maxdist(Q .Ω, ) O 1 .λ 0.2 0 .1 0 .3 O 2 .λ 0.</formula><formula xml:id="formula_6">(α = 0.5). If Q is an RkT u (k = 1) query, the results are O 2 , O 3 , O 4 , O 8 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Baselines</head><p>We next discuss how to exploit existing techniques for processing LkT queries. While no baseline algorithm exists for LkT queries, a straightforward baseline is to adapt an existing approach <ref type="bibr" target="#b24">[24]</ref>, thus computing the text relevancy using an inverted file and computing location proximity using an R-tree separately for all objects and then combining them to obtain the top-k objects. This is not efficient. The main difficulty is in benefitting from both the inverted file and the R-tree.</p><p>The two new baseline algorithms presented next: Inverted File Only (IFO) and R-tree plus Inverted File (RIF) are inspired by the Threshold algorithm <ref type="bibr" target="#b11">[12]</ref>.</p><p>Baseline 1: IFO. The idea is to utilize the inverted file to compute the text relevancy scores of all objects (corresponding to the right operand of the operator "+" in Eq. 1), thus obtaining a list IRRanking that ranks objects in ascending order of their scores. The list is then scanned to compute the spatial proximity to the query until further scanning will not generate top-k results. Only the inverted file is used.</p><p>During a scan, the algorithm keeps track of the combined ranking score (defined in Eq. 1; the lower the score, the better) of the current k'th object, denoted by threshold. If the IRRanking score of a new object T exceeds threshold, the algorithm stops since all objects after T in IRRanking also have a score that exceeds threshold; otherwise, we retrieve its location, compute its combined ranking score, and compare with threshold to determine whether threshold needs to be updated. <ref type="table" target="#tab_3">3</ref> illustrate the use of IFO. Consider an LkT (k = 3) query on a dataset of 9 objects. Initially (Step 1), the IRRanking list is computed using the inverted file and the threshold is set to ∞. Next (Step 2), the first object O 9 in the IRRanking list is removed and added to the Candidates list with its combined ranking score. Then, we repeatedly remove the first object in the IRRanking list and add it to the Candidates list with its combined score. The objects in the Candidates list occur in ascending order of their combined scores, and threshold always points to the third object in the list. When the score of the first object in IRRanking eventually exceeds threshold, the algorithm stops, and the top three objects O 7 , O 2 , O 9 in Candidates are returned (Step 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2 Table</head><p>Baseline 2: RIF. This algorithm uses an R-tree and an inverted file in two stages. The inverted file is used for computing the list IRRanking as for IFO. The algorithm then incrementally finds nearest neighbors <ref type="bibr" target="#b18">[18]</ref> using the R-tree and checks the text relevancy scores of objects in IRRanking.</p><p>In the process, the algorithm keeps track of the minimum text relevancy score in IRRanking, denoted by MinTR, that has not been "seen" so far, and the combined ranking score of the current kth object, denoted by threshold. For a newly "seen" object with spatial distance dist, if the combined score computed from dist and MinTR exceeds threshold, the algorithm stops since it is guaranteed that all "unseen" objects will not have lower scores than the current kth object (and thus cannot be in the result).</p><p>Example 3 Table <ref type="table">4</ref> illustrates the RIF algorithm. Consider an LkT (k = 3) query on the 9 objects from Example 2. Initially (Step 1), the IRRanking list is computed using the inverted file, the threshold is set to ∞, and MinTR is set to 0.25. Next (Step 2), the R-tree reports the nearest object O 1 with dist = 0.03. Since the combined score computed from dist and the current MinTR is smaller than threshold, object O 1 is removed from the IRRanking list and added to the Candidates list with its combined score computed from dist = 0.03 and its text relevancy score (i.e., 0.48) in the IRRanking list. Then, the R-tree continuously reports the next nearest object, and the processing in Step 2 is repeated. The objects in the Candidates list are ordered ascendingly on their combined scores, and threshold always points to the third object in the list. Also, MinTR always points to the first object in the IRRanking list. After several steps, when the R-tree reports an object (e.g., O 4 ) such that the combined score computed from its dist and the current MinTR exceeds threshold, the algorithm stops, and the top three objects O 7 , O 2 , O 9 in Candidates are returned (Step 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Hybrid indexing for location-aware text retrieval</head><p>We present a framework that integrates the R-tree and the inverted file into a new index, the Inverted file R-tree (IR-tree), and that includes an algorithm for processing LkT queries using the IR-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hybrid index framework: the IR-tree</head><p>The R-tree <ref type="bibr" target="#b15">[16]</ref> is arguably the dominant index for spatial queries, and the inverted file is the most efficient index for information retrieval <ref type="bibr" target="#b39">[39]</ref>. These were developed separately and for different kinds of queries.</p><p>We aim to develop an approach that is able to leverage both techniques for the efficient processing of LkT queries. To achieve this goal, a simple approach is to use the inverted file (resp. the R-tree) to generate a number of top candidate objects based on text relevancy (resp. spatial proximity) and then compute the spatial distances (resp. text relevancy) of the candidate objects using the other index. However, this approach is not efficient since there is no sensible way to determine the number of candidate objects needed from the first step in order to ensure that the top-k objects are found in the end. Instead, we propose a hybrid indexing structure, the IR-tree, that utilizes both indexing structures in a combined fashion.</p><p>The IR-tree is essentially an R-tree, each node of which is enriched with a reference to an inverted file for the objects contained in the subtree rooted at the node.</p><p>In the IR-tree, a leaf node contains a number of entries of the form (O, O.r ), where O refers to an object in database D and O.r is the bounding rectangle of object O. A leaf node also contains a pointer to an inverted file for the text documents of the objects being indexed. The inverted file is stored separately from the R-tree, for two reasons: First, it is more efficient to store each inverted file contiguously, rather than as a sequence of blocks or pages that are scattered across a disk <ref type="bibr" target="#b39">[39]</ref>. Second, the inverted file can be distributed across several machines, while this is not easily possible for the R-tree <ref type="bibr" target="#b32">[32]</ref>.</p><p>An inverted file consists of the following two main components.</p><p>-A vocabulary of all distinct terms in a collection of documents. -A set of posting lists, each of which relates to a term t.</p><p>Each posting list is a sequence of pairs O, w , where O refers to an object whose document O.ψ contains term t, and w is the weight of term t in document O.ψ.</p><p>A non-leaf node N contains a number of entries of the form (e, e.r ) where e points to a child node of N and e.r is the Minimum Bounding Rectangle (MBR) of all rectangles in entries of the child node. A pseudo document is constructed for each non-leaf entry in the IR-tree. The pseudo document is an important concept in the IR-tree. It represents all documents in the entries of the child node, enabling us to estimate a bound on the text relevancy to a query of all documents contained in the subtree rooted at e. The weight of a term t in the pseudo document referenced by e is the maximum weight of t in the documents contained in the subtree rooted at node e. A non-leaf node N also contains a pointer to an inverted file for the pseudo documents of the entries stored in N .  </p><formula xml:id="formula_7">O 7 , 0.1 O 7 , 0.4 InvFile-R 5 R 1 , 0.5 R 1 , 0.5 R 1 , 0.5 R 2 , 0.1 R 2 , 0.7 R 2 , 0.3 R 2 , 0.7 InvFile-R 6 R 3 , 0.4 R 4 , 0.4 R 3 , 0.4 R 4 , 0.1 R 4 , 0.1 R 4 , 0.4 InvFile-root R 5 , 0.7 R 5 , 0.5 R 5 , 0.7 R 5 , 0.1 R 6 , 0.4 R 6 , 0.4 R 6 , 0.4 R 6 , 0.1</formula><p>Example 4 Figure <ref type="figure" target="#fig_1">2</ref> illustrates the IR-tree for the 8 objects in Fig. <ref type="figure" target="#fig_0">1</ref>. Table <ref type="table" target="#tab_4">5</ref> shows the inverted files of the nodes in the IR-tree (Fig. <ref type="figure" target="#fig_1">2</ref>). As a specific example, the weight of the term restaurant in entry R 2 in InvFile-R 5 is 0.7, which is the maximum weight of the term in the three documents O 3 , O 4 , O 8 in node R 2 . Term t has the same weight in all the documents that do not contain t, which is determined by the maximum likelihood estimate of t in the whole dataset. These values are stored separately.</p><p>We proceed to present an important metric, the minimum spatial-textual distance, denoted by MIND ST (•, •), which will be used in the query processing. Given a query Q and a node N in the IR-tree, the metric MIND ST (Q, N ) offers a lower bound on the actual spatial-textual distance D ST (•, •) between query Q and the objects enclosed in the rectangle of node N . This bound can be used to order and efficiently prune the search space in the hybrid index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1</head><p>The minimum spatial-textual distance of a query Q from a node N in the hybrid index, denoted as MIND ST (Q, N ), is defined as follows:</p><formula xml:id="formula_8">MIND ST (Q, N ) = α mindist(Q.λ, N .r ) maxD +(1 -α) 1 - P(Q.ψ|N .ψ) maxP ,<label>(3)</label></formula><p>where α, maxD, and maxP are the same as in Eq. 1; P(Q.ψ|N .ψ) is the text relevancy of the pseudo document of node N ; and mindist(Q.λ, N .r ) is the minimum Euclidian distance between Q.λ and N .r (the MBR of N ).</p><p>A salient feature of the proposed hybrid indexing structure is that it inherits the nice properties of the R-tree for query processing.</p><p>Theorem 1 Given a query Q and a node N whose rectangle encloses a set of objects SO = {O i , 1 ≤ i ≤ m}, the following is true:</p><formula xml:id="formula_9">∀O i ∈ SO (MIND ST (Q, N ) ≤ D ST (Q, O i )).</formula><p>Proof Since object O i is enclosed in the rectangle of node N , the minimum Euclidian distance between Q.λ and N .r is no larger than the Euclidian distance between Q.λ and</p><formula xml:id="formula_10">O i .λ, that is, mindist(Q.λ, N .r ) ≤ D ε (Q.λ, O i .λ).</formula><p>For each term t, its weight in N .ψ (the pseudo document of node N ) is the maximum weight of t in all the documents in node N . Thus, P(Q.ψ|N .ψ) ≥ P(Q.ψ|O i .ψ).</p><p>According to Eqs. 1 and 3, we have</p><formula xml:id="formula_11">MIND ST (Q, N ) ≤ D ST (Q, O i ), thus completing the proof.</formula><p>When searching the hybrid index for the top-k objects given a query Q, one must decide at each visited node of the hybrid index which entry to search first. Metric MIND ST offers an approximation of the spatial-textual distance to every entry in the node and, therefore, can be used to direct the search. Note that only the posting lists of keywords in query Q, but not all posting lists, are loaded into memory at a node to compute MIND ST .</p><p>We next present an algorithm for building the IR-tree. The IR-tree is constructed by means of an insert operation that is adapted from the corresponding R-tree operation <ref type="bibr" target="#b15">[16]</ref>. Algorithm 1 shows the Insert algorithm. It takes two arguments, the MBR and the document of an object. It uses a standard implementation of the R-tree <ref type="bibr" target="#b15">[16]</ref> with operations ChooseLeaf and Split.</p><p>We may characterize the additional disk storage required by the IR-tree by comparing with the original R-tree and the inverted file. The number of nodes in the IR-tree is the same as that of the original R-tree, and the size of the inverted files contained in all leaf nodes of the IR-tree is comparable with that of the original inverted file. The IR-tree needs additional space to store the inverted files in its non-leaf nodes, the sizes of which depend on the number of non-leaf nodes and the storage utilization of nodes. If the capacity of each node is 100 entries, the length of the posting list for one word is at most 100 in a non-leaf node, which is independent of the number of objects contained in the subtree rooted at the nonlead node. The size of the inverted file at a non-leaf node is Algorithm 1 Insert(MBR, document) 1: N ← ChooseLeaf(MBR); 2: Add MBR to node N , add document to the inverted file of N ; 3: if N needs to be split then; 4:</p><formula xml:id="formula_12">{N 1 , N 2 } ← N .Split(); 5:</formula><p>if N is root node then 6:</p><p>Initialize a new node M; 7:</p><p>Add N 1 and N 2 to node M and update the inverted file of N 1 , N 2 and M; 8:</p><p>Set M to the root node; 9: else 10:</p><p>Ascend from N to the root, adjusting covering rectangles, updating the inverted file and propagating node splits as necessary; 11: else if N is not root then 12:</p><p>Update the covering rectangles and inverted files of the ancestor nodes of N ; thus much smaller than that of the original inverted file. The paper's experimental study covers storage space.</p><p>In our implementation, we use a single dictionary for the inverted files of all nodes. Posting lists are indexed in B +trees. Each word is mapped to an ID and is used as the key of the B + -trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Processing of LkT queries</head><p>To process LkT queries with the hybrid index framework, we exploit the best-first traversal algorithm (e.g., <ref type="bibr" target="#b18">[18]</ref>) for retrieving the top-k objects. With the best-first traversal algorithm, a priority queue is used to keep track of the nodes and objects that have yet to be visited. The values of D ST (•, •) and MIND ST (•, •) are used as the keys of objects and nodes, respectively.</p><p>When deciding which node to visit next, the algorithm picks the node N with the smallest MIND ST (Q, N ) value in the set of all nodes that have yet to be visited. The algorithm terminates when k objects (ranked according to Eq. 1) have been found. Algorithm 2 shows the pseudo-code.</p><p>We proceed to explain the algorithm and the use of the priority queue in the algorithm with an example.</p><p>Example 5 Consider the query Q (Q.ψ = (Chinese restaurant) in Fig. <ref type="figure" target="#fig_0">1</ref>. We want to find the top-1 object. We give the spatial-textual distances D ST (•, •) (Eq. 1) between query Q and all objects, as well as MIND ST (•, •) (Eq. 3) and the minimum Euclidian distances between Q and all bounding rectangles in Table <ref type="table">6</ref> (α = 0.5). Note that Algorithm LkT only computes the distances between Q and the objects or rectangles traversed by the algorithm, not all the distance in Table <ref type="table">6</ref>.</p><p>The algorithm uses a priority queue that contains the objects and bounding rectangles listed together with their D ST and MIND ST scores, in increasing order of the scores, with ties broken by the alphabetical ordering. The algorithm Algorithm 2 LkT(Query, Index, k) for each entry(Node) in node Element do 18:</p><p>Queue.Enqueue(Node, MIND ST (Query, Node)); Observe that in the example, the algorithm does not traverse the entire tree in Fig. <ref type="figure" target="#fig_1">2</ref> since the search space is being pruned. However, the algorithm still visits some nodes that contain no results. Before reporting O 1 , nodes root, R 5 , R 2 , and R 1 are visited. Since O 1 is the top-1 object, ideally we would visit root, R 5 , and R 1 , but not R 2 . The reason why R 2 is visited is that the value MIND ST of R 2 is less than that of R 1 .</p><formula xml:id="formula_13">Table 6 Spatial-textual distances D ST (Q, O i ) mindist(Q.λ, R i .r ) MIND ST (Q, R i ) O 1 0.475 R 1 0.2 0 .</formula><p>In Table <ref type="table" target="#tab_4">5</ref>, we can see that objects O 3 and O 4 are very different. The weight of term Chinese is 0.7 in O 3 .ψ, but O 4 .ψ does not contain it. On the other hand, the weight of term restaurant is 0.7 in O 4 .ψ, but O 3 .ψ does not contain it. Since R 2 contains the two objects, the weights of Chinese and restaurant in R 2 .ψ are both 0.7. The reason for R 2 being highly relevant to the query is that it mixes objects of different types such that the weights of many terms are high in the pseudo document for R 2 .</p><p>Based on this observation, we proceed to discuss how to enhance the query processing performance offered by the framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Enhanced hybrid indexing</head><p>We extend the hybrid indexing framework by incorporating document similarity, yielding an index called the DIRtree (Document similarity enhanced Inverted file R-tree) in Sect. 5.1. The IR-tree can be viewed as a special case of the DIR-tree. Section 5.2 presents a clustering enhanced method for improving the indexing framework. We present the ClusterMBR enhancement in Sect. 5.3 and the Term-MBR enhancement in Sect. 5.4. We briefly discuss updates in Sect. 5.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Incorporating document similarity</head><p>Like the R-tree, the IR-tree is built based on the heuristic of minimizing the area of each enclosing rectangle in the inner nodes. Thus, the tree aims to place nodes that are spatially close in the same higher-level node. However, the spatial objects considered in this paper also have associated documents, and the LkT query takes into account both location proximity and text relevancy.</p><p>Unlike the IR-tree, the DIR-tree aims to take both location and text information into account during tree construction, by optimizing for a combination of minimizing the areas of the enclosing rectangles and maximizing the text similarities between the documents of the enclosing rectangles.</p><p>We present an algorithm for building the DIR-tree in Sect. 5.1.1, and we cover query processing in Sect. 5.1.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">The DIR-tree</head><p>The structure of nodes in a DIR-tree is similar to that of nodes in an IR-tree. The only difference is that each non-leaf entry e additionally has a centroid document e.φ of all the documents enclosed in the subtree rooted at e.</p><p>Formally, let φ = w 1 , . . . , w m be the centroid document of a set of documents {ψ 1 , . . . , ψ n }. Then, φ.w i = max(ψ 1 .w i , . . . , ψ n .w i ). To choose an appropriate insertion path for an object, the DIR-tree takes into account both the spatial area parameter and the similarity between the document of the object and the centroid document of the entry in a node. We next describe how to incorporate the document similarity.</p><p>Let e 1 , . . . , e p be the entries in the current node, and let O be the object to be inserted. In the R-tree, the spatial area cost of inserting O into e k , 1 ≤ k ≤ p, is defined as AreaCost(e k ) = area(e k .r )area(e k .r ), where e k .r is the (possibly enlarged) version of rectangle e k after inclusion of O.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2</head><p>The spatial area cost extended with document similarity is defined as follows:</p><formula xml:id="formula_14">SimAreaCost(e k , O) = (1 -β) AreaCost(e k ) maxArea +β(1 -DocSim(e k .φ, O.ψ)) (4)</formula><p>In this definition, the document similarity DocSim(•, •) can be any measure (e.g., cosine similarity and Hamming distance) of the distance between document vectors, 1 maxArea, the area of the minimum bounding rectangle enclosing all objects, is used for normalization, and β is a parameter. Observe that if we set β = 0, the DIR-tree reduces to the IR-tree. In the other extreme, setting β = 1 means that we consider only document similarity when building a DIR-tree.</p><p>The insertion algorithm of the DIR-tree follows that of the IR-tree, with the exception of the specifics of functions ChooseSubtree and Split. Function ChooseSubtree is given in Algorithm 3. Beginning at the root, the function finds at every level the most suitable subtree to accommodate the new entry until a leaf node is reached. Specifically, it repeatedly chooses subtrees that minimize Eq. 4, that is, the value of SimAreaCost(•, •). If ChooseSubtree reaches a leaf node with the maximum number of entries M, function Split distributes the M +1 rectangles between two nodes. We incorporate document similarity into the standard Quadratic Split algorithm <ref type="bibr" target="#b15">[16]</ref>. Function Split is given in Algorithm 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Query processing in the DIR-tree</head><p>We use Algorithm 1 for the processing of LkT queries on the DIR-tree. An example illustrates its benefits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 6</head><p>We build a DIR-tree on the 8 objects in Fig. <ref type="figure" target="#fig_0">1</ref>. The result is shown in Figs. <ref type="figure">3</ref> and<ref type="figure">4</ref>. Consider the query Q in Fig. <ref type="figure">3</ref>, where Q.ψ = (Chinese restaurant). If we apply Algorithm 1 to retrieve the top-2 most relevant objects, the result is O 1 , O 5 , and the nodes root, R 5 , and R 1 are visited in the DIR-tree. If we use instead the corresponding IR-tree in Fig. <ref type="figure" target="#fig_1">2</ref>, nodes root, R 5 , R 6 , R 1 , and R 3 are visited. The DIRtree thus yields better performance than does the IR-tree for query Q. 1 Unlike in query processing, we do not use language models here since this would introduce asymmetry.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Cluster-enhanced method</head><p>We propose to enhance the hybrid indexing framework with clustering, which makes it possible to estimate tighter bounds at each tree node, thus improving query performance.</p><p>Spatial web objects often belong to different categories. For example, the geo-referenced points of interest may belong to specific categories, such as retail, accommodations, restaurants, and tourist attractions. Points of interest from different such categories may appear in the same node of the hybrid index, and thus two objects in the same node can contain very dissimilar document.</p><p>The idea is to cluster objects into groups according to their documents. Each index node may then contain objects from different clusters. Instead of constructing a single pseudo document for each node, we construct a pseudo document for each cluster in each node. Since objects within the same group are more similar than objects in different groups, the bounds estimated using clusters in a node will be tighter than those estimated for whole nodes. Therefore, we may expect the use of clustering to improve the query performance of both the IR-tree and the DIR-tree. We name the clusterenhanced IR-tree the CIR-tree and the cluster-enhanced DIRtree the CDIR-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">The CIR-tree</head><p>For convenience of presentation, we describe the proposed cluster-enhanced method in the context of the IR-tree; the method is equally applicable to the DIR-tree. Given any clustering of objects into n groups C 1 , . . . , C n , we form an inverted file incorporating the cluster information. We next present how to incorporate the cluster information into the nodes in the hybrid index.</p><p>The structure of a leaf node in the CIR-tree is similar to that of leaf nodes in the IR-tree. The only difference is that we add a cluster label to each entry (object) in the leaf node. The cluster label indicates the cluster the object belongs to.</p><p>Next, for each non-leaf entry e, we construct a set of pseudo documents. Each such document corresponds to one cluster. The number of pseudo documents of e depends on the number of clusters that objects in the subtree of e belong to. The inverted file of a non-leaf node indexes all these pseudo documents.</p><p>The pseudo document of a cluster at a node is constructed in a bottom-up manner similarly to how we generate the pseudo documents in the IR-tree. Specifically, for each cluster C i in a leaf node pointed to by a non-leaf entry e, we first construct a pseudo document denoted by e.C i .ψ. For each term t, we choose the maximum weight of t in all the documents in each cluster C i in the leaf node as the weight of t in e.C i .ψ.</p><p>Having constructed the pseudo documents of the clusters of the leaf nodes, we can construct pseudo documents of clusters of nodes at the upper levels from bottom to top. When we use pseudo documents at a lower level to construct pseudo documents at a higher level, identical clusters from different child nodes should be combined.</p><p>For instance, assume that a non-leaf entry e has two child entries e a and e b (i.e., child nodes), where e a includes two Example 7 Consider again the 8 objects in Fig. <ref type="figure" target="#fig_0">1</ref>. We cluster these documents into four clusters: <ref type="figure" target="#fig_3">5</ref> shows the CIR-tree for the 8 objects. The contents of InvFile-R 1 , InvFile-R 2 , InvFile-R 3 , and InvFile-R 4 are the same as in Table <ref type="table" target="#tab_4">5</ref>. The contents of InvFile-R 5 , InvFile-R 6 , and Inv-File-root are given in Table <ref type="table" target="#tab_9">7</ref>.</p><formula xml:id="formula_15">C 1 = {O 1 , O 5 , O 7 }, C 2 = {O 2 , O 6 , O 8 }, C 3 = {O 3 }, C 4 = {O 4 }. Figure</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Query processing in the CIR-tree</head><p>The algorithm for processing LkT queries on the CIR-tree is almost the same as Algorithm 2, the exception being that line 18 in Algorithm 2 is replaced by the code in Fig. <ref type="figure" target="#fig_4">6</ref>. The key of an entry in the priority queue is the minimum value of MIND ST (Query, Node.C i ) among all clusters.</p><p>Example 8 Consider the query in Example 5. The algorithm for processing the query using the CIR-tree starts by enqueueing the entries in the root and then executes the following steps:</p><p>(1) Queue:{(R 5 ,0.4),(R Observe that before reporting O 1 , nodes root, R 5 , and R 1 are visited. Compared with the algorithm using the IR-tree, fewer nodes are visited (recall that the algorithm using the IR-tree also visited R 2 ) because the CIR-tree provides tight bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Clustering objects</head><p>Ideally, we would find clusters that are optimal for the running time of Algorithm 2. Consider a query Q for the top-k objects on dataset D and a set of clusters {C 1 , . . . , C n } on the  It is well known that finding clusters of points that minimize the diameter within a metric space is NP-hard <ref type="bibr" target="#b14">[15]</ref>. Although minimizing the diameter of a cluster in our problem usually results in a tight upper bound of each cluster for a query, this does not immediately imply that finding a clustering solution that minimizes ScanTime() is NP-hard, since ScanTime() does not directly correspond to the diameters of clusters.</p><formula xml:id="formula_16">-R 5 R 1 .C 1 , 0.5 R 1 .C 2 , 0.5 R 1 .C 1 , 0.5 R 2 .C 3 , 0.1 R 2 .C 3 , 0.7 R 2 .C 2 , 0.3 R 1 .C 2 , 0.5 R 2 .C 4 , 0.1 R 2 .C 2 , 0.3 R 2 .C 4 , 0.7 InvFile-R 6 R 3 .C 1 , 0.4 R 4 .C 1 , 0.1 R 3 .C 1 , 0.4 R 4 .C 1 , 0.1 R 4 .C 1 , 0.1 R 4 .C 2 , 0.4 R 4 .C 1 , 0.4 R 4 .C 2 , 0.3 InvFile-root R 5 .C 1 , 0.5 R 5 .C 2 , 0.5 R 5 .C 1 , 0.5 R 5 .C 3 , 0.1 R 5 .C 3 , 0.7 R 6 .C 1 , 0.1 R 5 .C 2 , 0.5 R 5 .C 4 , 0.1 R 6 .C 1 , 0.4 R 6 .C 2 , 0.4 R 5 .C 4 , 0.7 R 6 .C 1 , 0.1 R 6 .C 1 , 0.4 R 6 .C 2 , 0.3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 The problem of finding a clustering solution that minimizes</head><formula xml:id="formula_17">ScanTime(C 1 , . . . , C n , D, k, Q) is NP-hard.</formula><p>Proof The proof is by reduction from the bin packing problem, which is NP-hard <ref type="bibr" target="#b14">[15]</ref>. Consider k = 1 and let objects have the same location information. If the IRScore computed based on pseudo documents (i.e., upper bounds) is smaller than the IRScore of the top-1 document, Algorithm 2 first scans the clusters containing the top-1 document to find the top-1 document, and it then prunes the clusters whose upper bound IRScore is lower than the IRScore of the top-1 document.</p><p>Assume that a parameter B is the sum of the logarithmic value of the term language model of the top-1 result. Minimizing the scan time corresponds to the decision problem of assigning all objects to k clusters, such that for each cluster, Score(C) ≤ B. Given an instance of the bin packing problem, each item corresponds to one object whose document contains a distinct term, each bin corresponds to a cluster, and the size of each item corresponds to the logarithmic value of the term language model. The query Q will contain all terms in documents in D. There is then a solution for the bin packing problem that packs all the items in k bins of size B if and only if there is a solution for our problem.</p><p>Given the above result, we must use a heuristic method for the clustering. One natural and simple approach is to use the k-means clustering algorithm <ref type="bibr" target="#b23">[23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">ClusterMBR enhancement</head><p>The cluster-enhanced method proposed in Sect. 5.2 provides tighter bounds on document similarities in each node. However, each cluster in the same node has the same MBR, which is the MBR of the node itself. We propose to refine the MBR of each cluster by constructing an MBR for each cluster at a node. This enables us to estimate a tighter bound on the distance from the query to the node. This technique can be applied to both the CIR-tree and the CDIR-tree.</p><p>For convenience of presentation, we introduce the Cluster-MBR technique in the context of the CIR-tree. We construct cluster MBRs only in non-leaf nodes of the CIR-tree while the structure of leaf nodes remains the same. The MBR of a cluster in a non-leaf node is constructed in a bottom-up manner as we generate the MBRs in the R-tree. Specifically, for each non-leaf entry e that includes n clusters, we construct n MBRs, one for each cluster. The MBR of cluster C i encloses the rectangles of the child entries that belong to the same cluster C i . In order not to affect the tree structure of the CIR-tree, the cluster MBRs for each non-leaf node are stored Example 9 Consider the right branch of the CIR-tree shown in Fig. <ref type="figure" target="#fig_3">5</ref>. Figure <ref type="figure" target="#fig_5">7</ref> shows the cluster MBRs of non-leaf entries R 3 , R 4 , and R 6 . As an example, the MBR of cluster C 1 for entry R 6 encloses the MBR of R 3 .C 1 and R 4 .C 1 . Comparing Figs. <ref type="figure" target="#fig_0">1</ref> and<ref type="figure" target="#fig_5">7</ref>, the cluster MBRs are smaller than the original MBRs, and they thus provide tighter bounds.</p><p>When applying the ClusterMBR technique on the CIRtree, the algorithm for processing LkT queries is almost the same as the algorithm used on the CIR-tree. The only difference is that when computing MIND ST (Query, Node.C i ), we use the MBR of C i instead of the MBR of the entire Node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">TermMBR enhancement</head><p>We proceed to propose the TermMBR Enhancement to optimize our framework. Each term in an inverted file has multiple locations in an MBR of a node, that is, a term locates at the locations of objects that have documents that include the term. Consider R 5 in Fig. <ref type="figure" target="#fig_0">1</ref>: documents O 1 .ψ and O 3 .ψ include the term Chinese, so in rectangle R 5 , term Chinese has the two locations of O 1 and O 3 . In our framework, given a query Q, when computing MIND ST of one entry e in a node, the minimum distance between Q.λ and e.r , mindist(Q.λ, e.r ), serves as the lower bound on distance between Q and all objects in the rectangle e.r . However, this lower bound is loose because each term in Q.λ has its own locations. We only need to consider these locations, and other places in the rectangle do not contribute to the query. Hence, for each non-leaf entry in the index structure, we draw an MBR for each term that encloses all the locations of that term. Figure <ref type="figure">8</ref> shows the MBRs of the four terms in R 5 as given in Fig. <ref type="figure" target="#fig_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 8 Example of term MBRs</head><p>Given a query Q, when computing MIND ST of a non-leaf entry e, we fetch the MBRs of all terms in Q.ψ. The minimum distance between Q.λ and those MBRs is then used to replace mindist(Q.λ, e.r ). By doing so, the lower bound is expected to be tighter and to lead to better query performance. The term MBRs are added in the posting lists of the inverted files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Update of the IR-tree</head><p>Since the proposed index structures are based on the R-tree, the update in the framework, including insertion and deletion of an object, is similar to the corresponding operations in the R-tree. For the IR-tree based indexes, insertion and deletion of an object in the tree structure is exactly as in the R-tree. In addition, corresponding information in the inverted files, cluster MBRs, or term MBRs can be updated easily. For DIRtree based indexes, Algorithm 3 and 4 are used for inserting or deleting an object. Additional information related to an inserted or deleted object can be updated as in the IR-tree based indexes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Processing of RkT queries</head><p>The RkT e query can be processed by the proposed algorithms for the LkT query. We thus proceed to focus on the RkT u query. Section 6.1 proposes an in-memory algorithm for the processing of the RkT u query. Section 6.2 proposes to use a disk resident index, that is, IR-tree, to find candidates first, And then those candidates are passed to the algorithm described in Sect. 6.1 to compute the final result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The RkT u Algorithm</head><p>Given an RkT u query Q, since Q.Ω is a spatial extent, the whole dataset D is partitioned into two sets. One set D in contains objects that locate inside Q.Ω. The other set D out contains objects that locate outside Q.Ω. The result of Q may contain some objects that belong to D in (internal top-k objects) and some objects that belong to D out (external top-k objects).</p><p>An RkT u query Q can be represented by a set of LkT queries Q = {Q 1 , Q 2 , . . .}, where the union of the spatial components of all the LkT queries in Q equals to the spatial component of the RkT u query, that is, Q i ∈Q {Q i .λ} = Q.Ω and all the LkT queries in Q have the same keywords as does the RkT u query, that is,</p><formula xml:id="formula_18">∀Q i ∈ Q(Q i .ψ = Q.ψ).</formula><p>We first consider the case k = 1. We propose two lemmas that indicate the necessary and sufficient conditions for an object to be an internal or an external top-1 object.</p><p>Lemma 1, below, is exploited when computing internal results of RkT u queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1 An object O is an internal top-1 object of the RkT u query Q if and only if O is located inside the query region Q.Ω and it is the top-1 object of an LkT query</head><formula xml:id="formula_19">Q i (∈ Q),</formula><p>where Q i has the same location as does the object O. Formally, object O is an internal top-1 object of the RkT u query</p><formula xml:id="formula_20">Q ⇐⇒ O.λ ∈ Q.Ω and O is the top-1 object of one LkT query Q i (∈ Q) where Q i .λ = O.λ and Q i .ψ = Q.ψ.</formula><p>Proof The proof of the implication ⇐ is inherent in the definition of the RkT u query. The proof of the implication ⇒ is done by contradiction. Assume that an object O other than O is the top-1 object of Q i , as shown in Fig. <ref type="figure" target="#fig_6">9a</ref>. According to the definition of the LkT query, we have:</p><formula xml:id="formula_21">α D ε (Q i .λ, O.λ) maxD + (1 -α) 1 - P(Q i .ψ|O.ψ) maxP &gt; α D ε (Q i .λ, O .λ) maxD + (1 -α) 1 - P(Q i .ψ|O .ψ) maxP .</formula><p>(5)</p><formula xml:id="formula_22">Since Q i .λ = O.λ, that is, D ε (Q i .λ, O.λ) = 0, Eq. 5 becomes: (1 -α) 1 - P(Q i .ψ|O.ψ) maxP &gt; α D ε (Q i .λ, O .λ) maxD + (1 -α) 1 - P(Q i .ψ|O .ψ) maxP . (<label>6</label></formula><formula xml:id="formula_23">)</formula><p>Since O is an internal top-1 object of Q, it must be the top-1 object of another LkT query Q j (∈ Q). Then we have:</p><formula xml:id="formula_24">D ST (Q j , O) = α D ε (Q j .λ, O.λ) maxD + (1 -α) 1 - P(Q j .ψ|O.ψ) maxP . (<label>7</label></formula><formula xml:id="formula_25">)</formula><p>Since Q i .ψ = Q.ψ and Q j .ψ = Q.ψ, combining Eq. 6 and 7, we have:</p><formula xml:id="formula_26">D ST (Q j , O) &gt; α D ε (Q j .λ, O.λ) + D ε (Q i .λ, O .λ) maxD +(1 -α) 1 - P(Q j .ψ|O .ψ) maxP (<label>8</label></formula><formula xml:id="formula_27">)</formula><p>Since Q i .λ = O.λ and according to the triangle inequality, that is, Eq. 8 becomes:</p><formula xml:id="formula_28">D ε (Q j .λ, O.λ)+ D ε (O.λ, O .λ) &gt; D ε (Q j .λ, O .λ),<label>(a) (b)</label></formula><formula xml:id="formula_29">D ST (Q j , O) &gt; α D ε (Q j .λ, O .λ) maxD +(1 -α) 1 - P(Q j .ψ|O .ψ) maxP = D ST (Q j , O ).</formula><p>Hence, object O is not the top-1 object of the LkT query Q j . This contradicts the assumption that object O is the top-1 object of the LkT query Q j and completes the proof. Lemma 2, below, is used when computing external results of RkT u queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2 An object O is an external top-1 object of the RkT u query Q if it is located outside Q's region and is the top-1 object of at least one LkT query that has the same keywords and is located on the boundary of Q's region. Formally, object O is an external top-1 object of the RkT u query</head><formula xml:id="formula_30">Q ⇐⇒ O.λ / ∈ Q.Ω</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and O is the top-1 object of at least one LkT query</head><formula xml:id="formula_31">Q i (∈ Q) such that Q i .λ belongs to the boundary of Q.Ω and Q i .ψ = Q.ψ.</formula><p>Proof The proof of the implication ⇐ is inherent in the definition of the RkT u query. We prove the implication ⇒ by contradiction. Assume object O is not the top-1 object of any LkT query in Q that locates on the boundary of Q.Ω. Since object O is an external top-1 object of the RkT u query Q, object O must be the top-1 object of at least one LkT query Q j (∈ Q) inside Q.Ω. As shown in Fig. <ref type="figure" target="#fig_6">9b</ref>, let Q i be the LkT query in Q that locates at the intersection of segment O.λQ j .λ and the boundary of Q.Ω. Since O is not the top-1 object of the LkT query Q i , there must be an object O that is the top-1 object of Q i , that is,</p><formula xml:id="formula_32">α D ε (Q i .λ, O.λ) maxD + (1 -α) 1 - P(Q i .ψ|O.ψ) maxP &gt; α D ε (Q i .λ, O .λ) maxD + (1 -α) 1 - P(Q i .ψ|O .ψ) maxP . (<label>9</label></formula><formula xml:id="formula_33">)</formula><p>Adding α</p><formula xml:id="formula_34">D ε (Q i .λ,Q j .λ) maxD</formula><p>on both sides of Eq. 9, since</p><formula xml:id="formula_35">D ε (Q i .λ, O .λ) + D ε (Q i .λ, Q j .λ) &gt; D ε (Q j .λ, O .λ),</formula><p>and</p><formula xml:id="formula_36">Q i .ψ = Q j .ψ, we have α D ε (Q j .λ, O.λ) maxD + (1 -α) 1 - P(Q j .ψ|O.ψ) maxP &gt; α D ε (Q j .λ, O .λ) maxD + (1 -α) 1 - P(Q j .ψ|O .ψ) maxP , that is, D ST (Q j , O) &gt; D ST (Q j , O ).</formula><p>Hence, object O is not the top-1 object of Q j , which contradicts the assumption that O is the top-1 object of Q j .</p><p>Lemma 2 shows that finding external top-1 objects of an RkT u query Q is equivalent to finding the top-1 object for LkT queries in Q that locate on the boundary of Q.Ω. We assume the boundary of Q.Ω comprises four line segments. The problem is converted into finding top-1 objects for an RkT u query Q where Q.Ω degenerates to four line segments, where each line segment Q.L is represented by two pairs of coordinates: [Q.L.minx, Q.L.miny : Q.L.maxx, Q.L.maxy].</p><p>Before describing how to find external top-1 objects for LkT queries in Q that locate on the boundary of Q.Ω, we first study the ranking function of the RkT u query. Contrary to the LkT query, an object O does not have only one constant ranking score, but has multiple ranking scores described by a function f (q, O) for a given RkT u query Q. Lemma 3 explains this function and its properties.</p><p>Lemma 3 Given an RkT u query Q, each object O has a ranking score function f (q, O) for each line segment Q.L of the boundary of Q.Ω that models its ranking scores, where q is a point location on Q.L.</p><p>Proof According to Eq. 2, given an RkT u query Q, for each object O, the value of function</p><formula xml:id="formula_37">P(Q.ψ|O.ψ) is a constant, while D ST (Q, O) is a function of q (q ∈ Q.L), that is, f (q, O) = α (q.x -O.x) 2 + (q.y -O.y) 2 maxD + T (O.ψ),<label>(10)</label></formula><p>where</p><formula xml:id="formula_38">T (O.ψ) = (1 -α)(1 -P(Q.ψ|O.ψ) maxP</formula><p>). Since the line segment Q.L is either horizontal or vertical, either q.y or q.x is fixed. Without loss of generality, we assume Q.L is horizontal and q.y is a constant L .y. Then Eq. 10 becomes: <ref type="bibr" target="#b10">(11)</ref> where A(O.y) = (L .y -O.y) 2 and B = α maxD . The ranking score function f (q, O) is one arm of a hyperbola. Taking the first derivative and setting it equal to 0, we get:</p><formula xml:id="formula_39">f (q, O) = B (q.x -O.x) 2 + A(O.y) + T (O.ψ),</formula><formula xml:id="formula_40">B (q.x -O.x) (q.x -O.x) 2 + A(O.y) = 0.</formula><p>Solving for q.x gives q.x = O.x. The second derivative is</p><formula xml:id="formula_41">B A(O.y) ((q.x -O.x) 2 + A(O.y)) 3 .</formula><p>Since it is positive, q.x = O.x is a minimum. Hence, function f (q, O) is monotone decreasing on (-∞, O.x] and monotone increasing on [O.x, +∞]. Given an RkT u query Q, for each line segmant </p><formula xml:id="formula_42">Q.L of Q, let Q = {Q 1 , Q 2 , . . .}</formula><formula xml:id="formula_43">∀L m (Q i .λ ∈ L m ∧ Q j .λ ∈ L m ∧ Q i ∈ Q ∧ Q j ∈ Q ⇒ LkT (Q i .λ, Q i .ψ) = LkT (Q j .λ, Q j .ψ)) (<label>12</label></formula><formula xml:id="formula_44">)</formula><p>Proof Given any two objects O 1 and O 2 in D, in order to find the intersections between their ranking functions, equation f (q.x, O 1 ) = f (q.x, O 2 ) needs to be solved, that is,</p><formula xml:id="formula_45">B (q.x -O 1 .x) 2 + A(O 1 .y) + T (O 1 .ψ) = B (q.x -O 2 .x) 2 + A(O 2 .y) + T (O 2 .ψ) (13) Let (q.x -O 1 .x) 2 + A(O 1 .y) = z 2</formula><p>, where z &gt; 0. Equation 13 becomes:</p><formula xml:id="formula_46">4(O 1 .x -O 2 .x) 2 z 2 -2Bz + C = 0,<label>(14)</label></formula><p>where</p><formula xml:id="formula_47">C = (O 1 .x -O 2 .x) 2 (B 2 -4 A(O 1 .y))+B 2 (A(O 1 .y)- A(O 2 .y)) -(T (O 1 .ψ) -T (O 2 .ψ)) 2 .</formula><p>Since Eq. 14 has two roots at most, there are at most four different values of q.x, that is, there are at most four intersections between any two ranking functions. Since D is a finite set, intersection set E is also finite. Hence, line segment Q.L is divided into a finite number of subsegments by E.</p><p>We prove Eq. 12 by contradiction. Given any subsegment L m , suppose LkT queries Q 1 and Q 2 locate on L m and have object O 1 and object O 2 as their top-1 object, respectively. Without loss of generality, assume</p><formula xml:id="formula_48">Q 1 .x &lt; Q 2 .x. Then we have f (Q 1 .x, O 1 ) &lt; f (Q 1 .x, O 2 ) and f (Q 2 .x, O 2 ) &lt; f (Q 2 .x, O 1 ). Since function f (•, •) is continuous,</formula><p>there must be an intersection between f (q.x, O 1 ) and f (q.x, O 2 ) when q.x ∈ (Q 1 .x, Q 2 .x). That contradicts to the definition of subsegment L m .</p><p>As an example in Fig. <ref type="figure" target="#fig_7">10</ref>, subsegment [Q.L .minx, e1.x] takes O1 as the top-1 object. The top-1 object of subsegment [e1.x, e2.x] is O2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3</head><p>An intersection e i (e i ∈ E) is called a change point if the top-1 object of LkT queries located on subsegment [e i-1 .x, e i .x) is different from the top-1 object of LkT queries located on subsegment (e i .x, e i+1 .x].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5 Let O be the top-1 object of LkT queries located on subsegment [e i-1 .x, e i .x). If e i is an intersection between the ranking functions of two different objects O and O then e i is a change point, and object O is the top-1 object of LkT queries located on subsegment (e i .x, e i+1 .x].</head><p>Proof Let f (q.x, O) be the ranking function of O and let f (q.x, O ) be the ranking function of O . Consider function g(x) = f (q.x, O)f (q.x, O ). Since e i is the intersection between f (q.x, O) and f (q.x, O ), we have g(e i .x) = 0. For a small value h, g(e i .xh) = f (e i .xh, O)f (e i .xh, O ) &lt; 0, since O is the top-1 object of subsegment [e i-1 .x, e i .x). Thus, we have g (e i .x) &gt; 0. Therefore, we know g(e i .x +h) &gt; 0, that is, f (e i .x +h, O) &gt; f (e i .x + h, O ) because g(x) is a continuous function. Hence, object O is not the top-1 object of subsegment (e i .x, e i+1 .x], and e i is a change point.</p><p>Let O be the top-1 object of subsegment (e i .x, e i+1 .x] instead of O , and let f (q.x, O ) be the ranking function of </p><formula xml:id="formula_49">O . Since f (x, O) &lt; f (x, O ) when x ∈ [e i-1 .x, e i .x), f (x, O) &gt; f (x, O ) when x ∈ (e i .x</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Using the IR-tree for pruning</head><p>Using the RkT u algorithm, it is computational expensive to find change points when the dataset is large, since it needs to compute the intersections between the ranking function of the current top-k object and that of all the other objects. We propose to use the IR-tree to find candidates that are a small Algorithm 5 RkT u (Q, k) portion of the whole dataset. Then, the RkT u algorithm is applied on the small set of candidates to find the true results.</p><p>According to Eq. 11, each object has a minimum ranking value and a maximum ranking value, resulting in a score interval [τ min , τ max ]. All objects are sorted in ascending order of τ min (recall that the smaller the score is, the better). Then, the top-k objects are put into a candidate set CS, and a threshold is defined as the kth smallest τ max in CS. Next, we check the (k + i)th object, where 1 ≤ i ≤ n and n is the total number of objects in the dataset. If the τ min of an object O does not exceed the threshold, object O is put into the candidate set, and threshold is updated accordingly. Otherwise, the candidate set is returned.</p><p>Example 11 In Fig. <ref type="figure" target="#fig_0">11</ref> To find candidates with the IR-tree or its enhanced versions, we exploit the best-first traversal algorithm. A priority queue is used to keep track of the nodes and objects that have yet to be visited. The values of τ min and MIND ST are used as the keys of objects and nodes, respectively. A candidate set and a threshold are maintained. When processing an object, its score interval [τ min , τ max ] is computed and if τ min ≤ threshold it is added to the candidate set. The Fig. <ref type="figure" target="#fig_0">11</ref> An example of score intervals threshold is updated accordingly. When processing a node, we apply the following pruning strategy.</p><p>Pruning Strategy. Given an RkT u query Q, let N be a node in the hybrid index. If MIND ST (Q, N) &gt; threshold, then no object in node N can be the result of Q, and thus N is pruned.</p><p>Proof Knowing that MIND ST (Q, N) is a lower bound of the ranking values of objects enclosed by node N and threshold is the kth minimal τ max in candidate set CS, if MIND ST (Q, N) &gt; threshold, there are already k objects in candidate set CS with smaller ranking values than all the objects in N . Hence, node N can be pruned. If a node is not pruned, all the entries in the node are added to the priority queue. The termination condition is that the key of the first element in the priority queue is bigger than threshold. When this happens, the algorithm stops, and the candidate set is returned. Algorithm 6 shows the pseudo-code of FindCandidates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Discussion</head><p>No algorithms exist for the processing of RkT u queries. Hu et al. <ref type="bibr" target="#b19">[19]</ref> consider the k range-nearest-neighbor (kRNN) query that requests the union of the k nearest neighbors (kNNs) for every point in a given query range Ω. The result of the kRNN query consists of two kinds of objects, internal kRNN objects that are inside Ω and external kRNN objects that are kNNs for all points on Ω's boundary. They assume the boundary comprises four line segments and propose an algorithm (LNN-Search) to find kNNs for all points on a line segment. The basic idea is to divide the line segment into several subsegments, such that every point in a subsegment has the same kNNs. Those subsegments are determined by the intersections of the line segment and perpendicular bisectors of some pairs of objects.</p><p>There are two major differences between the RkT u query and the kRNN query. One is that the objects inside the query Algorithm 6 FindCandidates(Query, Index, k) region Q.Ω are not always results. That is because the ranking function D ST (•, •) takes both text relevance and distance into account. An object inside Q.Ω might have a low text relevance so that it can have a higher value of D ST (•, •) than do some objects outside Q.Ω. The other is that the existing LNN-Search <ref type="bibr" target="#b19">[19]</ref> is not applicable to the RkT u query, since the property of perpendicular bisectors does not hold when using D ST (•, •) as the distance metric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experimental study</head><p>We proceed to evaluate the performance of the algorithms for the processing of the LkT and RkT u queries using the proposed hybrid indexes and enhancements, including the IR-tree, the DIR-tree, the cluster-enhanced method, the Clus-terMBR enhancement, and the TermMBR enhancement, and a recently proposed IR-tree variant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Algorithms</head><p>In addition to the proposed algorithms, we implemented the two baseline algorithms presented in Sect. 3 as competitors. Since compression techniques for inverted files may reduce the I/O cost of IFO and RIF (while may incur extra computational cost), we favor the IFO and the RIF by excluding the data transfer time from disk to main memory from the reported elapsed time of IFO and RIF reported in all experiments. Note that both baseline algorithms need to compute the text relevancy score for all the objects whose documents contain at least one of the query keywords. In our implementation, we use an accumulator for each object document, and all accumulators are memory resident. However, the hybrid approaches only need accumulators for the objects in a tree node (100 at most in our experiments, to be explained). This means that the baseline algorithms need more memory than the hybrid algorithms.</p><p>We also consider an IR-tree variant presented in a recent paper <ref type="bibr" target="#b22">[22]</ref>. To differentiate it from our IR-tree, we name it the IRLi-tree, thus combining the name of the index and the first author's name. The ideas underlying the IR-tree and the IRLi-tree are the same: that is, integrating an R-tree with inverted files to prune the search space according to spatial proximity and text relevancy simultaneously. The proposed pseudo document <ref type="bibr" target="#b7">[8]</ref> and document summary <ref type="bibr" target="#b22">[22]</ref> of a nonleaf node serve to offer an estimate of the text relevancy between the query and the objects in the subtree rooted at the non-leaf node. The two indexes differ only in terms of the storage scheme for the pseudo documents/document summaries of non-leaf nodes: Cong et al. <ref type="bibr" target="#b7">[8]</ref> index the pseudo documents in each non-leaf node using a separate inverted file, while Li et al. <ref type="bibr" target="#b22">[22]</ref> store the document summaries of all non-leaf nodes in one single inverted file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Data and queries</head><p>We use a real spatial dataset modeling the roads in California<ref type="foot" target="#foot_0">2</ref> and documents from WEBSPAM-UK2007<ref type="foot" target="#foot_1">3</ref> that consists of a large number of real web documents to generate a dataset DATA by randomly selecting a document for a spatial object. Table <ref type="table" target="#tab_14">8</ref> lists properties of the dataset.</p><p>We generate 4 query sets, in which the number of keywords is 1, 2, 3, and 4, respectively, in the space of DATA. Each set comprises 200 queries. Queries are generated from objects, and we guarantee that no query has an empty result. Specifically, to generate a query, we randomly pick an object in the dataset, and take the location of the object as the query location and randomly choose words from the document of the object as the query keywords.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Setup</head><p>All index structures (IR-tree, DIR-tree, enhancements, baselines, IRLi-tree) are disk resident, and the page size is 4 KB. The number of children of a node in the R-tree is computed given the fact that each node occupies a page. This translates to 100 children per node in our implementation.</p><p>All algorithms were implemented in Java, and an Intel(R) Xeon(R) CPU E5320@1.86 GHz with 16 GB main memory was used for the experiments. The Java Virtual Machine Heap is set to 10GB. We report the average elapsed time cost of the queries in each query set. Many layers of cache (e.g., disk driver cache, operating system cache, application cache) exist between a Java application and the physical disk. Rather than measuring physical I/Os from the disk using Java, we report the simulated I/O cost using a simulated LRU buffer that contains 5 % of the index.</p><p>We study the effect of different parameters and set parameter default values as follows: the number k of requested results is 10; the number of query keywords is 2; parameter α in the ranking function (Eq. 1) is 0.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Tuning experiment</head><p>This experiment tunes the number of clusters in the clusterenhanced method and the parameter β used in the DIR-tree to find good values for the two methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying the number of clusters</head><p>CIR-trees with 5, 10, 15, 20, 30, and 50 clusters are built. We use the k-means algorithm for clustering. The sizes of the resulting CIR-trees are shown in Table <ref type="table" target="#tab_15">9</ref>. The storage increases slightly with the number of clusters.</p><p>Figures <ref type="figure" target="#fig_9">12a,</ref><ref type="figure">b</ref> show the performance of top-10 queries. The I/O cost of the CIR-tree comes from the R-tree and the inverted file. As shown in Fig. <ref type="figure" target="#fig_9">12b</ref>, the total I/O cost is dominated by the I/O cost of using the inverted file. As the number of clusters increases, the total I/O cost increases since the posting lists in the inverted file become longer. In contrast, the I/O cost from the R-tree decreases when the number of clusters increases. This is because more clusters provide tighter bounds on the text relevancies so that more nodes are pruned in the R-tree. The elapsed time shown in Fig. <ref type="figure" target="#fig_9">12a</ref> has the same trend as does the I/O cost from the R-tree, that is, decreasing as the number of clusters increases. This behavior  occurs because the time needed for loading longer posting lists in the inverted file is less than the time needed for the processing of the nodes pruned by tighter bounds provided by more clusters in the CIR-tree.</p><p>However, it is not true that the more clusters, the better the performance always. With too many clusters, for example, 50 clusters, and the time needed for the processing of clusters in non-leaf nodes counteracts the time saved by fewer node visits due to more clusters, and the elapsed time gets worse. In the following experiments, we set the number of clusters to 30.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying the importance of document similarity when building DIR-trees</head><p>We use the Hamming distance to compute the DocSim(•, •) that occurs in Eq. 4. In order to make the construction of the DIR-tree efficient, when computing Eq. 4, we only consider the top-100 words according to the word frequencies in the whole dataset. We vary the parameter β to build different DIR-trees. Figure <ref type="figure" target="#fig_0">13a,</ref><ref type="figure">b</ref> show the performance of the different DIR-trees. In the extreme case of β = 0, the tree is actually an IR-tree. In the other extreme case of β = 1, only document similarity is considered when building the DIR-tree. The performance is best at β = 0.7. For a specific application, we can find a good parameter value empirically. The value of β is set to 0.7 in subsequent experiments. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Performance evaluation of LkT queries</head><p>We apply the cluster-enhanced method to the IR-tree and the DIR-tree, resulting in the CIR-tree and the CDIR-tree. The ClusterMBR and TermMBR enhancements are applied to the CDIR-tree, denoted as the CM-CDIR-tree and TM-CDIR-tree, respectively. Four sets of experiments are carried out. The first evaluates the performance when varying the number k of requested results. The second evaluates the effect of the number of query keywords on performance. The third evaluates the effect of the parameter α in the ranking function. The fourth evaluates the effect of the buffer size. We also report the index size for each approach and study the performance in main memory. All the hybrid indexes are based on the R-tree and the inverted files. Figure <ref type="figure" target="#fig_0">14c,</ref><ref type="figure">d</ref> show the average simulated I/O cost of the R-tree and the inverted files, respectively. The I/O costs of the R-trees in the IRLi-tree and the IR-tree are the same, while the I/O cost of the inverted file in the IRLitree is notably higher than that of the IR-tree. To see why, recall that both trees construct pseudo documents (document summaries) for non-leaf entries in the R-tree. The IRLi-tree uses a single inverted file to index all pseudo documents and attaches an inverted file to each leaf node in the R-tree, while the IR-tree maintains an inverted file for each node in the R-tree. When processing queries, the posting lists of query keywords to be loaded in the IRLi-tree are longer than those in the IR-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying k in LkT queries</head><p>We find that for hybrid indexes, the elapsed time is correlated to the I/O cost of the R-tree. The I/O cost of the R-tree indicates how much the search space is pruned. The higher the I/O cost of the R-tree, the less the searching space is pruned, and vice versa. We also find that the total I/O cost is dominated by the I/O cost of the inverted files. That is because processing one node in the R-tree costs one I/O, but incurring multiple I/Os from the inverted file due to multiple query keywords and long posting lists.</p><p>The DIR-tree performs slightly better than the IR-tree, and the cluster enhancement (CIR-tree and CDIR-tree) improves the performance of both the IR-tree and the DIR-tree. This is expected since the DIR-tree accounts for the similarity among documents of objects, while the IR-tree does not. Because the cluster enhancement provides tighter bounds on the text relevancy, the CIR-tree and the CDIR-tree enable more effective pruning of the search space than do the IR-tree and the DIR-tree, as shown in Fig. <ref type="figure" target="#fig_0">14c</ref>. The I/O costs of the inverted files in the CIR-tree and the CDIR-tree are higher than those in the IR-tree and the DIR-tree, as shown in Fig. <ref type="figure" target="#fig_0">14d</ref>. That is because in the CIR-tree and the CDIR-tree, each non-leaf entry has multiple pseudo documents, which makes posting lists longer. However, the extra I/Os from the inverted files caused by the cluster enhancement do not negatively affect the time saved by its effective pruning. The CM-CDIR-tree improves the performance of the CDIR-tree. The I/O cost of the inverted files in the CM-CDIR-tree is higher than that of the CDIR-tree, since accessing the MBRs of clusters incurs additional I/Os. However, the tighter bounds provided by cluster MBRs save some I/Os and computation in the tree structure and inverted files, and those savings are not negatively affected by the additional I/Os from cluster MBRs. Hence, the elapsed time of the CM-CDIR-tree is less than that of the CDIR-tree. Although the term MBRs in the TM-CDIR-tree provide more accurate estimate and save some I/O in the tree structure compared with the CDIR-tree (Fig. <ref type="figure" target="#fig_0">14c</ref>), accessing the MBRs of terms incurs additional I/O (Fig. <ref type="figure" target="#fig_0">14d</ref>) and counteracts the savings provided by accurate estimations. The tradeoff is between the saved time offered by accurate estimate and the additional I/O caused by the data that provides accurate estimate. In this experiment, the CM-CDIR-tree is better than the TM-CDIR-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying the number of keywords in LkT queries</head><p>Figure <ref type="figure" target="#fig_12">15a</ref>, b show that the hybrid indexes outperform the baseline approaches. As the number of keywords increases, the cost of processing queries increases, since more posting lists are loaded from the inverted file as shown in Fig. <ref type="figure" target="#fig_12">15d</ref>.</p><p>The IR-tree outperforms the IRLi-tree when the number of keywords are 1, 2, and 3. However, the IRLi-tree performs better when the number of keywords is 4, since the I/O cost of the inverted file in the IRLi-tree is lower than that in the IR-tree as shown in Fig. <ref type="figure" target="#fig_12">15d</ref>.</p><p>This experiment also shows that the DIR-tree performs slightly better than does the IR-tree. We note that when the number of keywords is 1, the cluster enhancement does not improve the IR-tree and the DIR-tree. That is expected since the bound on the text relevancy based on a single keyword is always accurate. In other words, Fig. <ref type="figure" target="#fig_12">15c</ref> shows that the IR-tree (DIR-tree) and the CIR-tree (CDIR-tree) do the same amount of search when the number of keywords is 1. However, the I/O costs of the inverted files of the cluster enhancements are higher due to the long posting lists. When the number of keywords is greater than 1, the cluster enhancement can improve the query performance of both the IR-tree and the DIR-tree.</p><p>The results for the CM-CDIR-tree and the TM-CDIR-tree are consistent with the results from the previous experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying α in LkT queries</head><p>Parameter α in Eq. 1 allows users to set their preferences between text relevancy and spatial proximity. Figure <ref type="figure" target="#fig_4">16</ref> shows the results when varying α. A large α means that the spatial distance is more important, while a small α means that the keywords are more important. It is consistent with the previous experiments that the hybrid indexes beat IFO and RIF. The performance of the RIF is improved while the performance of the IFO is getting worse as α increases, since the R-tree in the RIF helps while no spatial index involved in the IFO. As expected, the IR-tree performs better for large α while the DIR-tree performs better for small α. The DIRtree takes into account document similarity, and the benefit increases when the text relevancy is given higher weight. As in the previous experiment, the cluster enhancement is effective, and the CM-CDIR-tree achieves the best performance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Effect of buffering</head><p>We use a simulated LRU buffer, and we vary the buffer size from 0 to 20 % of the index size. As shown in Fig. <ref type="figure" target="#fig_5">17</ref>, extra buffer space improves the simulated I/O performance of all approaches. As expected, the improvement decreases as the buffer size increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation in main memory</head><p>This experiment studies the performance of different approaches in main memory, that is, the whole index structure can fit into main memory. We use a small dataset that combines of a real spatial dataset containing 131,461 objects located in LA streets 4 with five categories of the document dataset 20 Newsgroups. 5 The average elapsed time is 4 http://www.rtreeportal.org.  <ref type="figure" target="#fig_14">18</ref>. In the main memory setting where no I/O is involved, the hybrid indexes again beat RIF since the hybrid indexes explore a smaller search space. The IR-tree slightly outperforms the IRLi-tree since the IRLi-tree computes the text relevancies of all objects that contain at least one query keyword, while the IR-tree only computes part of them. This experiment also shows that the enhancements improve the performance of the IR-tree with the CM-CDIR-tree being best.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Space requirements</head><p>Table <ref type="table" target="#tab_16">10</ref> shows the total sizes of each index structure. The differences between the RIF and the hybrid indexes in the table show the overhead introduced by the hybrid indexes. As discussed in Sect. 4.1, the inverted file built in RIF is roughly equal to the inverted files in the leaf nodes of the hybrid indexes. The overhead occurs because in the hybrid indexes, each non-leaf node also has an inverted file. The size of the IR-tree is slightly bigger than that of the IRLi-tree, since the IR-tree stores an inverted file for each non-leaf node while the IRLi-tree has a single inverted file for all non-leaf nodes.</p><p>The difference between the IR-tree (resp. DIR-tree) and the CIR-tree (resp. CDIR-tree) shows the storage overhead due to the cluster refined inverted files in the non-leaf nodes in the CIR-tree. Note that the sizes of the inverted files in their leaf nodes are the same. The size of the DIR-tree is similar to that of the IR-tree. Cluster MBRs are stored separately. They only add slightly (0.04 GB) to the storage of the CDIRtree. The TM-CDIR-tree occupies more space than does the CDIR-tree due to the space occupied by the MBR of each term in the inverted files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.6">Performance evaluation of RkT u queries</head><p>There exists no baseline algorithm for RkT u queries. Thus, we extend the proposed baseline algorithm RIF for LkT queries to process RkT u queries. The term MBR and the cluster MBR techniques are applied to the CDIR-tree, and the results are compared with the original CDIR-tree and the IR-tree. Four sets of experiments are carried out. The first evaluates the performance when varying the number k of requested results. The second evaluates the effect of the number of query keywords. The third evaluates the effect of the parameter α in the ranking function. The fourth evaluates the performance when varying the size of the query region. As for LkT queries, parameter β is set to 0.7, and the number of clusters is set to 30. By default, parameter α is set to 0.3, the number of keywords is 2, the size of the query region is set to 0.01 % of the whole space, and k = 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying k in RkT u queries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 19a, b show the elapsed time and I/O costs of the</head><p>FindCandidates algorithm with different indexes when varying k. All the four hybrid indexes significantly outperform the baseline approach for all values of k in terms of both elapsed time and I/O cost. Figure <ref type="figure" target="#fig_15">19c,</ref><ref type="figure">d</ref> show the average simulated I/O cost of the R-tree and the inverted files, respectively. This experiment also demonstrates that for hybrid indexes, the elapsed time is correlated with the I/O cost of the R-tree. It is consistent with the study of the LkT query that the CDIR-tree performs better than the IR-tree and that the ClusterMBR technique improves the performance of the CDIR-tree. Figure <ref type="figure" target="#fig_15">19e</ref> shows the total elapsed time of processing RkT u queries. The performance is dominated by the FindCandidates step. The elapsed time increases as k increases. Since the Filtering step incurs no I/O, the total I/O cost is the same as shown in Fig. <ref type="figure" target="#fig_15">19b</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying the number of keywords in RkT u queries</head><p>Figure <ref type="figure" target="#fig_15">19f</ref>-i show the elapsed time and I/O costs of the FindCandidates algorithm on different indexes when varying the number of keywords. This experiment also illustrates that the hybrid indexes outperform RIF. When the number of keywords is 1, the IR-tree outperforms the CDIR-tree and its variants. The reason is the same as what is explained before. For the other cases, the ClusterMBR technique applied to the CDIR-tree performs the best. Figure <ref type="figure" target="#fig_15">19j</ref> shows the total elapsed time of processing RkT u queries, indicating that the cost of the Filtering step is trivial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying α in RkT u queries</head><p>Figure <ref type="figure" target="#fig_15">19k</ref>-o show the performance on different indexes when varying α. The hybrid indexes outperform RIF. It is again found that the CM-CDIR-tree is best.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varying the size of the query region</head><p>Figure <ref type="figure" target="#fig_15">19p</ref>-t show the performance on different indexes when varying the size of the query region. Again, this experiment demonstrates that the hybrid indexes outperform RIF significantly and that the enhanced techniques improve performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.7">Summary</head><p>The experimental study shows that the proposed hybrid indexes significantly and quite consistently outperform the baseline. It also shows that the proposed enhancements indeed improve the performance of the hybrid indexes. We conclude that applying the ClusterMBR to the CDIR-tree has the best performance for the processing of both LkT and RkT queries in most of cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Nearest neighbor and top-k queries</head><p>The processing of k-nearest neighbor queries (kNNs) in spatial databases is a classical subject. Most proposals use index structures to assist in the kNN processing. Perhaps the most influential kNN algorithm is due to Roussopoulos et al. <ref type="bibr" target="#b30">[30]</ref>. In this solution, an R-tree <ref type="bibr" target="#b15">[16]</ref> indexes the data points, potential nearest neighbors are maintained in a priority queue, and the tree is traversed according to a number of heuristics. Other methods modify the index structures to better suit the particular problem addressed <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b35">35]</ref>. Hjaltason and Samet <ref type="bibr" target="#b18">[18]</ref> propose an incremental nearest neighbor algorithm based on an R*-tree <ref type="bibr" target="#b3">[4]</ref>.</p><p>Our work is also related to top-k query processing <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b11">12]</ref>. Fagin et al. <ref type="bibr" target="#b11">[12]</ref> propose a class of algorithms known as threshold algorithms. These algorithms, like the ones pro-posed for information retrieval <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">27]</ref>, enable efficient computation of aggregate functions over multiple sorted lists. These algorithms can be easily integrated into the leaf nodes in our framework (we need to process all entries in nonleaf nodes, so the threshold algorithm does not apply there); however, using them does not improve performance in our framework. The possible reason is that the posting lists in a leaf node are short (limited by the capacity of a node).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Text retrieval queries</head><p>A variety of retrieval models have been proposed to meet different information retrieval needs, such as probabilistic models, the vector space model, the probabilistic similarity measure often referred to as the Okapi measure (BM25) <ref type="bibr" target="#b29">[29]</ref>, and language models. The latter represent a relatively new approach, and they offer either the best or competitive performance in many settings <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b28">28]</ref>.</p><p>Many different types of text indexes have been proposed. The most efficient index structure for text retrieval is the inverted file <ref type="bibr" target="#b39">[39]</ref>, and many state-of-the-art, large-scale IR systems such as web search engines employ inverted files for ranking-query evaluation. Alternative indexing techniques for text documents also exist, including suffix arrays <ref type="bibr" target="#b2">[3]</ref> and signature files <ref type="bibr" target="#b12">[13]</ref>. Zobel et al. <ref type="bibr" target="#b40">[40]</ref> empirically show that signature files are not competitive with the inverted file for information retrieval queries.</p><p>To improve efficiency, a host of works develop effective heuristics for reducing query evaluation costs by reordering the inverted file according to frequency or contribution <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">27]</ref>. Other techniques also exist (e.g., <ref type="bibr" target="#b33">[33]</ref>) aim to increase query efficiency, and compression techniques exist that aim to reduce storage costs (e.g., <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b26">26]</ref>). These techniques can be applied to our framework; however, they are beyond the scope of this study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Location-aware text retrieval queries</head><p>Commercial search engines such as Google and Yahoo! have introduced local search services that appear to focus on the retrieval of local content, for example, related to stores and restaurants. However, the algorithms used are not publicized.</p><p>Much attention has been given to the problem of extracting geographic information from web pages (e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b25">25]</ref>). The extracted information can be used by search engines.</p><p>McCurley <ref type="bibr" target="#b25">[25]</ref> covers the notion of geo-coding and describes geographic indicators found in web pages, such as zip codes and location names.</p><p>A recent study by Zhou et al. <ref type="bibr" target="#b38">[38]</ref> tackles the problem of retrieving web documents relevant to a keyword query within a pre-specified spatial region. They propose three approaches based on a loose combination of an inverted file and an R*-tree. The best approach according to their experiments is to build an R*-tree for each distinct keyword on the web pages containing the keyword. As a result, queries with multiple keywords need to access multiple R*-trees, and the results must be intersected. Building a separate R*-tree for each keyword also requires substantial storage.</p><p>Our hybrid indexing framework differs substantially from this approach, although both use inverted files and R-trees. Our approach incorporates the inverted file at each node of an R-tree such that both location and text information can be utilized simultaneously to prune the search space at query time, while the approaches of Zhou et al. <ref type="bibr" target="#b38">[38]</ref> adopt combinations that require query processing to occur in two stages: One type of indexing is used to filter web document in the first stage, and then another type is employed in the second stage. This is similar in spirit to the baseline approach used in our experiments.</p><p>Next, our approach and their approaches target different kinds of queries: while we focus on top-k queries, Zhou et al. aim to retrieve relevant documents within a given geographic region. We know of no way of adapting these approaches to process the top-k queries considered in this paper (without scanning all objects). In contrast, our framework can easily be extended to process the queries considered by Zhou et al.</p><p>Another study <ref type="bibr" target="#b6">[7]</ref> considers a different type of query that retrieves web pages that contain the query keywords and whose page footprint intersects with the query footprint, where a footprint is an arbitrary, possibly noncontiguous area. They apply spatial filling curve to the inverted index. Vaid et al. <ref type="bibr" target="#b34">[34]</ref> also present techniques to combine the output of a text and a spatial index to answer a spatial keyword query in two stages. The aforementioned two differences between our approach and that of Zhou et al. also apply here.</p><p>Next, Hariharan et al. <ref type="bibr" target="#b16">[17]</ref> address the problem of finding objects containing query keywords within a region. They present a hybrid indexing structure called the KR * -tree that consists of an R * -tree and an inverted file for the nodes of the R * -tree. The nodes of the KR * -tree are virtually augmented with the sets of keywords that appear in the subtrees rooted at the nodes. At query time, the KR * -tree based algorithm finds the nodes that contain the query keywords and then uses these as candidates for subsequent search. This approach suffers from unnecessary overhead when there are many candidates.</p><p>Felipe et al. <ref type="bibr" target="#b9">[10]</ref> integrate signature files and the R-tree to enable keyword search on spatial data objects that each have a limited number of keywords. This approach needs to load the signature files of all words into memory when a node is visited, which incurs substantial I/O. Signature files are generally inferior to inverted files for general text retrieval <ref type="bibr" target="#b39">[39]</ref>. The fact that there is no practical way of using signature files for handling ranked queries <ref type="bibr" target="#b39">[39]</ref> renders it infeasible for this approach to support LkT queries that need to compute text relevancy scores (using language models).</p><p>Another hybrid indexing structure <ref type="bibr" target="#b37">[37]</ref> combines the R*tree and bitmap indexing to process the m-closest keyword query that returns the spatially closest objects matching m keywords. This approach exhibits the same problems as do signature-file based indexing <ref type="bibr" target="#b9">[10]</ref>.</p><p>Martins et al. <ref type="bibr" target="#b24">[24]</ref> compute text relevancy and location proximity independently and then combine the two ranking scores. The baseline algorithms we investigate in this paper appear to be better than this approach.</p><p>Khodaei et al. <ref type="bibr" target="#b21">[21]</ref> propose the Spatial Keyword Inverted File to handle location-based web searches. They develop a new distance measure called spatial tf-idf to rank relevant documents.</p><p>Cao et al. <ref type="bibr" target="#b5">[6]</ref> propose the concept of prestige-based relevance to capture both the textual relevance of an object to a query and the effects of nearby objects. The top-k spatial web objects are ranked according to both prestige-based relevance and location proximity.</p><p>In a previously published conference paper <ref type="bibr" target="#b7">[8]</ref>, we introduce LkT queries, and we propose the IR-tree, the DIR-tree, and the cluster-enhanced method. This paper in addition proposes an efficient solution for the processing of a new type of query, called the RkT query, and it proposes and studies two new enhanced techniques for the framework proposed in <ref type="bibr" target="#b7">[8]</ref>, namely the ClusterMBR, which constructs an MBR for each cluster of each node, and the TermMBR, which constructs an MBR for each word in the inverted files of each node. Section 7.1 compares in depth with the IR-tree proposed by Li et al. <ref type="bibr" target="#b22">[22]</ref>. All extensions in this paper to the conference paper <ref type="bibr" target="#b7">[8]</ref> go beyond Li et al.'s proposal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusions and future work</head><p>This paper proposes a new indexing framework for location-aware top-k text retrieval and region-aware top-k text retrieval. The framework tightly integrates the inverted file for text retrieval and the R-tree for spatial proximity querying in a novel manner. Several hybrid indexing approaches are explored within the framework. The framework encompasses algorithms that utilize the proposed indexes for computing the top-k query, and it is capable of simultaneously taking into account text relevancy and spatial proximity to prune the search space during query processing. Results of empirical studies with an implementation of the framework demonstrate that the paper's proposal is capable of excellent performance.</p><p>This work opens to a number of promising directions for future work. First, it is worth adapting existing optimization techniques developed for inverted files (e.g., compression) and R-trees to the paper's setting. Second, the performance of the DIR-tree may be affected by the choice of the document similarity function DocSim(•, •) in Eq. 4. Moreover, the document space has high dimensionality (our dataset has 2+ million distinct words), which makes the construction of the DIR-tree slow. When inserting an object into the DIRtree, we need to compute the document similarity between the object and some entries in the tree. After finding the node in which to insert the object, we have to update the pseudo documents of its predecessor nodes. When a node overflows, the splitting is also computationally expensive due to the high dimensional document space. We can reduce the document space dimensionality, for example, by considering the top-100 words according to word frequencies. However, it may adversely affect the performance of the DIR-tree. It is worth developing an approach that is able to make the construction of the DIR-tree efficient without hurting its performance. Third, it is of interest to understand how the top-k queries considered can best be processed if the objects are constrained to a spatial network.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1 Objects and their bounding rectangles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Hybrid index IR-tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 Fig. 4</head><label>34</label><figDesc>Fig. 3 Objects and bounding rectangles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5</head><label>5</label><figDesc>Fig. 5 Example of the CIR-tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6 Replacement to line 18 in Algorithm 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7</head><label>7</label><figDesc>Fig. 7 Example of cluster MBRs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9</head><label>9</label><figDesc>Fig. 9 Proof of Lemmas 1 and 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 shows</head><label>10</label><figDesc>Figure 10 shows the curves of ranking score functions of four objects with respect to a line segment [0.2, 0.5 : 0.3, 0.5].Given an RkT u query Q, for each line segmant Q.L of Q, let Q = {Q 1 , Q 2 , . . .} be the set of LkT queries such that</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>, e i+1 .x], and both f (x, O) and f (x, O ) are continuous, there must be at least one intersection between f (x, O) and f (x, O ) on [e i-1 .x, e i+1 .x]. That contradicts the premise that e i is the only intersection on subsegment [e i-1 .x, e i+1 .x]. Hence, object O is the top-1 object of subsegment (e i .x, e i+1 .x].Based on Lemmas 2, 4, and 5, we proceed to describe how to find the top-1 objects for RkT u queries. Starting from the left-hand side endpoint of Q.L, for each object O i in D, we compute its value of f (Q.L.minx, O i ). The object that has the smallest value is added to the result and taken as the current top-1 object O. Next, we find the subsegment on which the LkT queries have the same top-1 object O. We compute the intersections between the ranking function of O and all the other objects. The intersection e that falls into the range [Q.L.minx, Q.L.maxx] and has the smallest x value is the change point, and thus LkT queries located on subsegment [Q.L.minx, e.x] take O as the top-1 object. The corresponding object O of e (the ranking functions of O and O intersect at e) is taken as the current top-1 object. Then, the same process is repeated to find the next subsegment starting from e.x on which the LkT queries have the same current top-1 object. The algorithm stops when no new change point is found. The set of all found top-1 objects are returned as the result.Example 10 As shown in Fig.10, Q.L.minx = 0.2, and f (Q.L.minx, O 1 ) is the smallest. Object O 1 is the current top-1 object. Since intersection e1 (between the ranking functions of O 1 and O 2 ) is a change point, object O 1 is the top-1 object of subsegment [Q.L.minx, e1.x). Next, we find the subsegment (e1.x, e3.x) that takes O 2 as the top-1 object, since intersection e3 (between the ranking functions of O 2 and O 3 ) is a change point. Finally, object O 3 is the top-1 object of subsegment (e3.x, Q.L.maxx]. Extension to k Lemmas 2, 4, and 5 hold when k &gt; 1. Algorithm 5 shows the pseudocode for retrieving external top-k objects of one of the line segments of the boundary of an RkT u query Q. The union of the results of four line segments is the final result of the RkT u query Q. Assume the line segment is horizontal. It is easy to apply the algorithm to vertical line segments. Line 1 computes the ranking score of each object by using the Euclidean distance between the leftmost point Q.L .minx of the line segment and objects. The k objects, denoted by TOPK, with the smallest ranking score are added to the result set. The change point cp is set to Q.L .minx (Line 2). Next, it computes the intersections between the ranking function of each object in TOPK and the ranking function of each object in D \ TOPK (Lines 4-6). The intersections that fall between the change point and the rightmost point of the line segment are kept in E (Lines 7-9). If E is empty, the top-k objects of the line segment have been found, and the algorithm stops. Otherwise, we select the leftmost intersection e in E. Suppose e is the intersection between ranking functions of object O(∈ TOPK) and O (∈ D \ TOPK). Object O is removed from the current top-k set TOPK. Object O is added to TOPK and the result set. The change point is updated to e.x (Lines 12-16).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12</head><label>12</label><figDesc>Fig. 12 Varying the number of clusters. a Elapsed time. b Simulated I/O</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 13 Fig. 14</head><label>1314</label><figDesc>Fig. 13 Varying β. a Elapsed time. b Simulated I/O</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14a ,</head><label>14a</label><figDesc>Figure 14a, b show the average elapsed time and the average simulated I/O cost. All the hybrid indexes significantly outperform the baseline approaches for all values of k in terms of both metrics.All the hybrid indexes are based on the R-tree and the inverted files. Figure14c, dshow the average simulated I/O cost of the R-tree and the inverted files, respectively. The I/O costs of the R-trees in the IRLi-tree and the IR-tree are the same, while the I/O cost of the inverted file in the IRLitree is notably higher than that of the IR-tree. To see why, recall that both trees construct pseudo documents (document summaries) for non-leaf entries in the R-tree. The IRLi-tree uses a single inverted file to index all pseudo documents and attaches an inverted file to each leaf node in the R-tree, while</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 15</head><label>15</label><figDesc>Fig. 15 Varying the number of keywords in LkT queries. a Elapsed time. b Simulated I/O. c Simulated I/O of the R-tree. d Simulated I/O of the inverted files</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 16 Fig. 17</head><label>1617</label><figDesc>Fig. 16 Varying α in LkT Queries. a Elapsed time. b Simulated I/O. c Simulated I/O of the R-tree. d Simulated I/O of the inverted files</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 18</head><label>18</label><figDesc>Fig. 18 Evaluation in main memory</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 19</head><label>19</label><figDesc>Fig. 19 Evaluating RkT queries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Document-by-term matrix</figDesc><table><row><cell></cell><cell>Chinese</cell><cell>Spanish</cell><cell>Restaurant</cell><cell>Food</cell></row><row><cell>O 1 .ψ</cell><cell>0.5</cell><cell>-</cell><cell>0.5</cell><cell>-</cell></row><row><cell>O 2 .ψ</cell><cell>-</cell><cell>0 . 5</cell><cell>0 . 5</cell><cell>-</cell></row><row><cell>O 3 .ψ</cell><cell>0.7</cell><cell>-</cell><cell>-</cell><cell>0.1</cell></row><row><cell>O 4 .ψ</cell><cell>-</cell><cell>-</cell><cell>0 . 7</cell><cell>0 . 1</cell></row><row><cell>O 5 .ψ</cell><cell>0.4</cell><cell>-</cell><cell>0.4</cell><cell>-</cell></row><row><cell>O 6 .ψ</cell><cell>-</cell><cell>0 . 4</cell><cell>0 . 3</cell><cell>-</cell></row><row><cell>O 7 .ψ</cell><cell>0.1</cell><cell>0.1</cell><cell>0.4</cell><cell>0.1</cell></row><row><cell>O 8 .ψ</cell><cell>-</cell><cell>0 . 3</cell><cell>0 . 3</cell><cell>-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc>Distances between queries and objects</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc>Example of IFO</figDesc><table><row><cell>Step 1</cell><cell></cell><cell>Step 2</cell><cell></cell><cell>Step 3</cell><cell></cell><cell>. . .</cell><cell>Step 6</cell><cell></cell></row><row><cell>IR ranking</cell><cell>Candidates</cell><cell>IR ranking</cell><cell>Candidates</cell><cell>IR ranking</cell><cell>Candidates</cell><cell>. . .</cell><cell>IR ranking</cell><cell>Candidates</cell></row><row><cell>O 9 , 0.25</cell><cell>∞</cell><cell>O 7 , 0.31</cell><cell>O 9 , 0.5</cell><cell>O 2 , 0.42</cell><cell>O 7 , 0.4</cell><cell>. . .</cell><cell>O 6 , 0.51</cell><cell>O 7 , 0.4</cell></row><row><cell>O 7 , 0.31</cell><cell>∞</cell><cell>O 2 , 0.42</cell><cell>∞</cell><cell>O 3 , 0.44</cell><cell>O 9 , 0.5</cell><cell>. . .</cell><cell>O 4 , 0.53</cell><cell>O 2 , 0.48</cell></row><row><cell>O 2 , 0.42</cell><cell>∞</cell><cell>O 3 , 0.44</cell><cell>∞</cell><cell>O 1 , 0.48</cell><cell>∞</cell><cell>. . .</cell><cell>O 8 , 0.56</cell><cell>O 9 , 0.5</cell></row><row><cell>O 3 , 0.44</cell><cell></cell><cell>O 1 , 0.48</cell><cell></cell><cell>O 6 , 0.51</cell><cell></cell><cell>. . .</cell><cell>O 5 , 0.62</cell><cell>O 1 , 0.51</cell></row><row><cell>O 1 , 0.48</cell><cell></cell><cell>O 6 , 0.51</cell><cell></cell><cell>O 4 , 0.53</cell><cell></cell><cell>. . .</cell><cell></cell><cell>O 3 , 0.52</cell></row><row><cell>O 6 , 0.51</cell><cell></cell><cell>O 4 , 0.53</cell><cell></cell><cell>O 8 , 0.56</cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>O 4 , 0.53</cell><cell></cell><cell>O 8 , 0.56</cell><cell></cell><cell>O 5 , 0.62</cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>O 8 , 0.56</cell><cell></cell><cell>O 5 , 0.62</cell><cell></cell><cell></cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>O 5 , 0.62</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>Boxed: threshold</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Table 4 Example of RIF</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Step 1</cell><cell></cell><cell>Step 2</cell><cell></cell><cell>Step 3</cell><cell></cell><cell>. . .</cell><cell>Step 6</cell><cell></cell></row><row><cell>IR ranking</cell><cell>Candidates</cell><cell>IR ranking</cell><cell>Candidates</cell><cell>IR ranking</cell><cell>Candidates</cell><cell>. . .</cell><cell>IR ranking</cell><cell>Candidates</cell></row><row><cell>O 9 , 0.25</cell><cell>∞</cell><cell>O 9 , 0.25</cell><cell>O 1 , 0.51</cell><cell>O 9 , 0.25</cell><cell>O 2 , 0.48</cell><cell>. . .</cell><cell>O 6 , 0.51</cell><cell>O 7 , 0.4</cell></row><row><cell>O 7 , 0.31</cell><cell>∞</cell><cell>O 7 , 0.31</cell><cell>∞</cell><cell>O 7 , 0.31</cell><cell>O 1 , 0.51</cell><cell>. . .</cell><cell>O 4 , 0.53</cell><cell>O 2 , 0.48</cell></row><row><cell>O 2 , 0.42</cell><cell>∞</cell><cell>O 2 , 0.42</cell><cell>∞</cell><cell>O 3 , 0.44</cell><cell>∞</cell><cell>. . .</cell><cell>O 8 , 0.56</cell><cell>O 9 , 0.5</cell></row><row><cell>O 3 , 0.44</cell><cell></cell><cell>O 3 , 0.44</cell><cell></cell><cell>O 6 , 0.51</cell><cell></cell><cell>. . .</cell><cell>O 5 , 0.62</cell><cell>O 1 , 0.51</cell></row><row><cell>O 1 , 0.48</cell><cell></cell><cell>O 6 , 0.51</cell><cell></cell><cell>O 4 , 0.53</cell><cell></cell><cell>. . .</cell><cell></cell><cell>O 3 , 0.52</cell></row><row><cell>O 6 , 0.51</cell><cell></cell><cell>O 4 , 0.53</cell><cell></cell><cell>O 8 , 0.56</cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>O 4 , 0.53</cell><cell></cell><cell>O 8 , 0.56</cell><cell></cell><cell>O 5 , 0.62</cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>O 8 , 0.56</cell><cell></cell><cell>O 5 , 0.62</cell><cell></cell><cell></cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>O 5 , 0.62</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell cols="3">Boxed: threshold; underlined: MinTR</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5</head><label>5</label><figDesc>Contents of inverted files</figDesc><table><row><cell></cell><cell>Chinese</cell><cell>Spanish</cell><cell>Restaurant</cell><cell>Food</cell></row><row><cell>InvFile-R 1</cell><cell>O 1 , 0.5</cell><cell>O 2 , 0.5</cell><cell>O 1 , 0.5</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>O 2 , 0.5</cell><cell></cell></row><row><cell>InvFile-R 2</cell><cell>O 3 , 0.7</cell><cell>O 8 , 0.3</cell><cell>O 4 , 0.7</cell><cell>O 3 , 0.1</cell></row><row><cell></cell><cell></cell><cell></cell><cell>O 8 , 0.3</cell><cell>O 4 , 0.1</cell></row><row><cell>InvFile-R 3</cell><cell>O 5 , 0.4</cell><cell></cell><cell>O 5 , 0.4</cell><cell></cell></row><row><cell>InvFile-R 4</cell><cell>O 7 , 0.1</cell><cell>O 6 , 0.4</cell><cell>O 6 , 0.3</cell><cell>O 7 , 0.1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Choose the next entry and add it to the group with the smaller SimAreaCost(•, •), resolving ties by adding the entry to the group with the smaller AreaCost();</figDesc><table><row><cell cols="3">Algorithm 3 ChooseSubtree</cell></row><row><cell cols="2">1: N ← the root;</cell></row><row><cell cols="2">2: loop</cell></row><row><cell>3:</cell><cell>if N is a leaf node then</cell></row><row><cell>4:</cell><cell>Return N ;</cell></row><row><cell>5:</cell><cell>else</cell></row><row><cell>6:</cell><cell cols="2">Choose the entry in N with the minimum value for</cell></row><row><cell></cell><cell cols="2">SimAreaCost(e k , O), resolving ties by choosing the entry with the</cell></row><row><cell></cell><cell cols="2">minimum value for AreaCost(e k );</cell></row><row><cell>7:</cell><cell cols="2">N ← the child node pointed by the child pointer of the chosen</cell></row><row><cell></cell><cell>entry;</cell></row><row><cell cols="2">Algorithm 4 Split(N )</cell></row><row><cell cols="3">1: for each pair of entries e i and e j in node N do</cell></row><row><cell>2:</cell><cell cols="2">R i j ← compose a rectangle including e i and e j ;</cell></row><row><cell>3:</cell><cell cols="2">d i j ← area(R i j ) -area(e i ) -area(e j );</cell></row><row><cell>4:</cell><cell cols="2">DocSim ij ← similarity between documents of e i and e j ;</cell></row><row><cell>5:</cell><cell cols="2">ineffi ← (1 -β)d + β(1 -DocSim);</cell></row><row><cell cols="3">6: Choose the pair with the largest ineffi value to be the first elements</cell></row><row><cell></cell><cell>of the two groups;</cell></row><row><cell cols="2">7: loop</cell><cell>assign all entries in N to the two groups</cell></row><row><cell>8:</cell><cell cols="2">if all entries in N have been assigned to the two groups then</cell></row><row><cell>9:</cell><cell>break;</cell></row><row><cell>10:</cell><cell cols="2">if one group needs to include all remaining entries then</cell></row><row><cell>11:</cell><cell cols="2">Assign all remaining entries to it;</cell></row><row><cell>12:</cell><cell>break;</cell></row><row><cell>13:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 7</head><label>7</label><figDesc>Contents of inverted files in the CIR-tree</figDesc><table><row><cell>Chinese</cell><cell>Spanish</cell><cell>Restaurant</cell><cell>Food</cell></row><row><cell>InvFile</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>be the set of LkT queries such that the union of the spatial components of all the LkT queries in Q equals to the line segment Q.L, that is, Q i ∈Q {Q i .λ} = Q.L and all the LkT queries in Q have the same keywords as does the RkT u query, that is, ∀Q i ∈ Q(Q</figDesc><table><row><cell></cell><cell>0.17</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>O1</cell><cell></cell></row><row><cell></cell><cell>0.16</cell><cell></cell><cell></cell><cell>O2 O3</cell><cell></cell></row><row><cell>ranking value</cell><cell>0.13 0.14 0.15</cell><cell>e1</cell><cell>e2</cell><cell>e3 O4</cell><cell>e4</cell></row><row><cell></cell><cell>0.12</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.11 0.2</cell><cell>0.22</cell><cell>0.24</cell><cell>0.26</cell><cell>0.28</cell><cell>0.3</cell></row><row><cell></cell><cell></cell><cell cols="3">line segment Q.L</cell><cell></cell></row><row><cell cols="6">Fig. 10 D ST (Q, O) as a function of points on Q.L</cell></row></table><note><p><p><p><p><p>i .ψ = Q.ψ). For each object O, we derive its ranking score function by following Eq. 11. Let E = {e 1 , e 2 , . . .} denote the set of intersection points of the ranking functions of any pair of objects in D. We arrange the intersections in E in the order of their projected values on Q.L, and we then divide the line segment Q.L into a finite number of subsegments Q.L = {L 1 , L 2 , . . .} according to E. In Fig.</p>10</p>, four intersections e1, . . . , e4 divide Q.L into five subsegments. We next present Lemmas 4 and 5, showing that the top-1 objects of LkT queries, which belong Q and locate on the same subsegment, are the same, and the union of the results of all subsegments are the result of LkT queries on Q.L.</p>Lemma 4</p>The LkT queries in Q that are located on the same subsegment have the same top-1 object, that is,</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>1 :</head><label>1</label><figDesc>Select k objects (denoted by TOPK) and add them to RESULT , such that ∀O i ∈ D \ TOPK ∀O j ∈ TOPK( f (Q.L .minx, O j ) &lt;</figDesc><table><row><cell></cell><cell>f (Q.L .minx, O i ))</cell><cell></cell></row><row><cell cols="2">2: cp ← Q.L .minx;</cell><cell></cell></row><row><cell cols="2">3: while true do</cell><cell></cell></row><row><cell>4:</cell><cell>for each object O i in D \ TOPK do</cell><cell></cell></row><row><cell>5:</cell><cell>for each object O j in TOPK do</cell><cell></cell></row><row><cell>6:</cell><cell>Compute intersections between</cell><cell>f (q.x, O j ) and</cell></row><row><cell></cell><cell>f (q.x, O i );</cell><cell></cell></row><row><cell>7:</cell><cell>for each intersection e do</cell><cell></cell></row><row><cell>8:</cell><cell>if cp ≤ e.x ≤ Q.L .maxx then</cell><cell></cell></row><row><cell>9:</cell><cell>Add e to E;</cell><cell></cell></row><row><cell>10:</cell><cell>if E is empty then</cell><cell></cell></row><row><cell>11:</cell><cell>break;</cell><cell></cell></row><row><cell>12:</cell><cell cols="2">Select the intersection e in E that has the smallest x coordinate;</cell></row><row><cell></cell><cell cols="2">e is the intersection between ranking functions of O and O</cell></row><row><cell>13:</cell><cell>Remove O from TOPK;</cell><cell></cell></row><row><cell>14:</cell><cell>Add O to TOPK;</cell><cell></cell></row><row><cell>15:</cell><cell>Add O to RESULT ;</cell><cell></cell></row><row><cell>16:</cell><cell>cp ← e.x;</cell><cell></cell></row><row><cell cols="2">17: return RESULT ;</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>, there are 4 objects O 1 , O 2 , O 3 , and O 4 . Each object has a score interval with respect to an RkT u query Q (k = 2 and Q.L is a line segment), computed from Eq. 11. The sorted list of objects is (O 2 , O 4 , O 3 , O 1 ). We put the top-2 objects O 2 and O 4 into the candidate set and threshold = O 4 .τ max . Then, we check O 3 and find that O 3 .τ min &lt; threshold. Hence, O 3 is also put into the candidate set, and threshold is updated to O 3 .τ max . We next check object O 1 and find that O 1 .τ min &gt; threshold, so that the candidate set {O 2 , O 4 , O 3 } is returned.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table 8</head><label>8</label><figDesc>Dataset properties</figDesc><table><row><cell>Property</cell><cell>DATA</cell></row><row><cell>Total # of objects</cell><cell>2,249,727</cell></row><row><cell>Average # of unique words per object</cell><cell>429</cell></row><row><cell>Total # of unique words in dataset</cell><cell>2,899,175</cell></row><row><cell>Total # of words in dataset</cell><cell>965,132,883</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head>Table 9</head><label>9</label><figDesc>Sizes of different CIR-trees (GB)</figDesc><table><row><cell># Clusters</cell><cell>5</cell><cell>10</cell><cell>15</cell><cell>20</cell><cell>30</cell><cell>50</cell></row><row><cell>Size</cell><cell>77.53</cell><cell>78.56</cell><cell>79.28</cell><cell>80.05</cell><cell>80.35</cell><cell>81.6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head>Table 10</head><label>10</label><figDesc></figDesc><table><row><cell>(GB)</cell><cell>Index structure sizes</cell><cell>RIF</cell><cell>IRLi-tree</cell><cell>IR-tree</cell><cell>CIR-tree</cell><cell>DIR-tree</cell><cell>CDIR-tree</cell><cell>CM-CDIR-tree</cell><cell>TM-CDIR-tree</cell></row><row><cell></cell><cell></cell><cell>12.77</cell><cell>74.67</cell><cell>75.13</cell><cell>80.35</cell><cell>75.54</cell><cell>80.90</cell><cell>80.94</cell><cell>102.23</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>http://www.rtreeportal.org.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>http://barcelona.research.yahoo.net/webspam/datasets/uk2007.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Web-a-where: geotagging web content</title>
		<author>
			<persName><forename type="first">E</forename><surname>Amitay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Har'el</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Soffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="273" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Vector-space ranking with effective early termination</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Anh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>De Kretser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Modern Information Retrieval</title>
		<author>
			<persName><forename type="first">R</forename><surname>Baeza-Yates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ribeiro-Neto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The R*-tree: an efficient and robust access method for points and rectangles</title>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-P</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="322" to="331" />
		</imprint>
		<respStmt>
			<orgName>SIGMOD</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Evaluating top-k queries over web-accessible databases</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="369" to="380" />
		</imprint>
		<respStmt>
			<orgName>ICDE</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Retrieving top-k prestige-based relevant spatial web objects</title>
		<author>
			<persName><forename type="first">X</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="page" from="373" to="384" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Efficient query processing in geographic web search engines</title>
		<author>
			<persName><forename type="first">Y.-Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Suel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Markowetz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="277" to="288" />
		</imprint>
		<respStmt>
			<orgName>SIGMOD</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient retrieval of the top-k most relevant spatial web objects</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="337" to="348" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Finding question-answer pairs from online forums</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-I</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="467" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Keyword search on spatial databases</title>
		<author>
			<persName><forename type="first">I</forename><surname>De Felipe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rishe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="656" to="665" />
		</imprint>
		<respStmt>
			<orgName>ICDE</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Computing geographical scopes of web resources</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shivakumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="545" to="556" />
		</imprint>
		<respStmt>
			<orgName>VLDB</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal aggregation algorithms for middleware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lotem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="614" to="656" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Signature files: an access method for documents and its analytical performance evaluation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Christodoulakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="267" to="288" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Hybrid index organizations for text databases</title>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="310" to="327" />
		</imprint>
		<respStmt>
			<orgName>EDBT</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>W. H. Freeman &amp; Co</publisher>
			<pubPlace>San Francisco, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">R-trees: a dynamic index structure for spatial searching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guttman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
		<respStmt>
			<orgName>SIGMOD</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Processing spatialkeyword (SK) queries in geographic information retrieval (GIR) systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mehrotra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Distance browsing in spatial databases</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Hjaltason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="265" to="318" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Range nearest-neighbor query</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="78" to="91" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The SR-tree: an index structure for highdimensional nearest neighbor queries</title>
		<author>
			<persName><forename type="first">N</forename><surname>Katayama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Satoh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="369" to="380" />
		</imprint>
		<respStmt>
			<orgName>SIGMOD</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Hybrid indexing and seamless ranking of spatial and textual features of web documents</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khodaei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Shahabi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DEXA</title>
		<imprint>
			<biblScope unit="page" from="450" to="466" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">IR-tree: an efficient index for geographic document search</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="585" to="599" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Least squares quantization in PCM</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="129" to="137" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Indexing and ranking in geo-IR systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Andrade</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="31" to="34" />
		</imprint>
		<respStmt>
			<orgName>GIR</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Geospatial mapping and navigation of the web</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mccurley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>WWW</publisher>
			<biblScope unit="page" from="221" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Coding for compression in full-text retrieval systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Compression Conference</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="72" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Filtered document retrieval with frequency-sorted indexes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Persin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sacks-Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Am. Soc. Inf. Sci</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="749" to="764" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A language modeling approach to information retrieval</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Ponte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Croft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="275" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Okapi at TREC-3</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Hancock-Beaulieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gatford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TREC</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Nearest neighbor queries</title>
		<author>
			<persName><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vincent</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="71" to="79" />
		</imprint>
		<respStmt>
			<orgName>SIGMOD</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Analyzing geographic queries</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sanderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR Workshop on Geographic Information Retrieval</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Master-client R-trees: a new parallel R-tree architecture</title>
		<author>
			<persName><forename type="first">B</forename><surname>Schnitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Leutenegger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="68" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Optimization strategies for complex queries</title>
		<author>
			<persName><forename type="first">T</forename><surname>Strohman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Turtle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Croft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="219" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Spatio-textual indexing for geographical search on the web</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vaid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Joho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sanderson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="218" to="235" />
		</imprint>
		<respStmt>
			<orgName>SSTD</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Similarity indexing with the SS-tree</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="516" to="523" />
		</imprint>
		<respStmt>
			<orgName>ICDE</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A study of smoothing methods for language models applied to information retrieval</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lafferty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOIS</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="214" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Keyword search in spatial databases: Towards searching by document</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Chee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mondal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kitsuregawa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="688" to="699" />
		</imprint>
		<respStmt>
			<orgName>ICDE</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Hybrid index structures for location-based web search</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-Y</forename><surname>Ma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="155" to="162" />
		</imprint>
		<respStmt>
			<orgName>CIKM</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Inverted files for text search engines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="56" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Inverted files versus signature files for text indexing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramamohanarao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="453" to="490" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
