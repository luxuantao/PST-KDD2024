<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Higher-Order Abstract Syntax *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Frank</forename><surname>Pfenning</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213-3890</postCode>
									<region>Pennsylvania</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Conal</forename><surname>Elliott</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213-3890</postCode>
									<region>Pennsylvania</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Higher-Order Abstract Syntax *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BF4503DBE2E1ADFCA6A4939947F776B3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higherorder abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Higher-order abstract syntax is a generalization of the usual data type of abstract syntax tree that is used to represent syntactic objects in implementations of systems that manipulate programs, formulas, rules, etc.</p><p>Higher-order abstract syntax uses a simply typed λcalculus enriched with products and polymorphism and thus extends a proposal by Huet and Lang <ref type="bibr" target="#b10">[11]</ref>. It differs from LF <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b8">9]</ref> in that we do not allow dependent function types, since no appropriate matching or unification algorithm is known. Moreover, we feel that products and polymorphism, which are absent from LF, are an essential feature for practical applications.</p><p>The requirements that led to the design of higherorder abstract syntax arose through one of the Ergo project's goals, namely to build a language-generic environment for formal program development. Components of such an environment that we have completed include a parser and unparser generator, an attribute grammar compiler, a type inference facility, and an interaction facility based on the X window system. Other components now being implemented include a language-and rule-independent transformation system and a logic-independent deduction system.</p><p>Such a program design environment should support rapid prototyping of all relevant aspects of programming languages. That is, one should be able to easily specify syntax, semantics, and transformation rules for a language and obtain an environment tailored to manipulating programs in that language. Our goals are even broader, since we believe that logical languages and proof systems are essential for formal program development and, therefore, that we must be able to support these as well.</p><p>The requirements for the internal representation of syntactic objects in such a system are quite different from the requirements in a single-language system. On the other hand, many of the same issues come up in compiler generation systems. We believe the basic principles that should guide the design of an internal representation for programs (and other syntactic objects) in our context are:</p><p>• Simple, user-friendly syntactic and semantic definition of a language should be supported through the representation. It should also allow definition of transformation and inference rules in a similar style. In particular, it should be possible to avoid complex side-conditions wherever possible.</p><p>• Efficient and correct use can be made of the definitions. In particular, the system must be able to efficiently and correctly transform programs or apply inference rules.</p><p>• The representation should be general enough to be used by all relevant tools in an environment, thereby providing for a high degree of integration between the tools.</p><p>Abstract syntax trees have proved very useful in similar contexts. This has been well established in systems like PSG <ref type="bibr" target="#b1">[2]</ref>, the Cornell Synthesizer Generator <ref type="bibr" target="#b18">[19]</ref>, Gandalf <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b5">6]</ref>, or Popart <ref type="bibr" target="#b19">[20]</ref>. However, abstract syntax trees do not completely satisfy the more general requirements listed above. The crux of the problem is that almost all languages in this context will have name binding constructs. These binding constructs make correct matching and substitution difficult (see Section 2 for some examples). Also, the requirements of a language generic system do not allow incorporation of the information about binding constructs the way it can be done in single-language systems. Instead, the language implementor must explicitly define the binding constructs of the language once and for all, and the system must be able to incorporate this information into the representation.</p><p>We found that all static binding constructs we examined can be represented in a simply typed λcalculus with Cartesian products. We also added polymorphism to the representation to make it powerful to enough to conveniently state general transformation and inference rules. A somewhat less general, but closely related representation was first proposed by Huet and Lang <ref type="bibr" target="#b10">[11]</ref>. It should be noted that our representation in no way prohibits dynamic extent of variables, nor does it mean a commitment to a callby-name over call-by-value semantics. Also, since the types are syntactic sorts, no commitment to the semantic type structure of the object language is made. Higher-order abstract syntax is appropriate and useful for almost all languages, including Prolog, ML, Pascal, various logics and type theories, Hoare logics, etc.</p><p>Adopting this typed λ-calculus representation allows us to use the very powerful mechanism of higherorder unification (of which higher-order matching and substitution are special cases). We have implemented Huet's algorithm <ref type="bibr" target="#b9">[10]</ref> for higher-order unification with extensions to deal with products and polymorphism. It is complete except for some rare cases involving higher-order polymorphism. In certain cases, straightforward matching would produce too many unifiers to be useful, and in this case the client (user or program) can preinstantiate some variables to generate a more specialized version of a pattern. Note that this problem of too many rewrites is inherent in program transformation, and not a defect of our implementation. On the contrary: our implementation provides a simple way of stating a very general, valid rule and then partially instantiating it to a more specialized one which is automatically correct and can be applied efficiently.</p><p>We also provide a first-order interface to higherorder abstract syntax. This first-order interface is defined through the augments in the grammar and is used by tools that still depend on the conventional notion of abstract syntax (like the parser and unparser generators and the current attribute grammar compiler). As discussed in Section ?? the efficiency loss due to the dual interface seems to be minimal.</p><p>In the remainder of this paper, we first point out some of the inadequacies of the representation of programs as abstract syntax trees. We then discuss higher-order abstract syntax and illustrate its use through a diverse set of examples. Finally, some implementation issues concerning higher-order abstract syntax and related work are discussed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Some Motivating Examples</head><p>In this section we highlight some of the problems that arise in matching and substitution due to the presence of binding constructs in a language. Almost all languages have these binding constructs, though sometimes they are not immediately apparent. For example, in Prolog the "free" variables in a clause are actually bound in that clause, since they are clearly distinct from variables with the same name in other clauses. A function definition stated as f(x) = b actually binds x and f (see the beginning of Section 3.2).</p><p>The rules we present throughout this paper are stated without any semantic side conditions such as strictness or termination. Depending on the language semantics, such conditions may still be necessary to ensure full semantic equivalence between the transformed programs. However, it should be noted that in all the examples the syntactic side conditions on the rules disappear without compromising the validity of the rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Correct Matching and Substitution</head><p>This problem should be very familiar; it is generally called "variable capturing". It appears in two different forms: during matching and during substitution. Consider the rule of let-conversion.</p><formula xml:id="formula_0">let x = e in b ⇐⇒ b[e/x]</formula><p>Here are two incorrect applications of this rule. Note that reading them from right to left shows the problem of doing correct matching against b[e/x].</p><formula xml:id="formula_1">let x = y in let y = 5 in x * y / ⇐⇒ let y = 5 in y * y let x = 5 in let x = x * x in x / ⇐⇒ let x = 5 * 5 in 5</formula><p>What is required for correct substitution is recognition of name conflicts and renaming of bound variables. If this rule is read from right-to-left, it is clear that there are many possible ways of abstracting an expression from a program, and that therefore straightforward matching on any representation would be very non-deterministic. In a situation like this the solution is to partially instantiate the pattern before matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Variable Occurrence Restriction</head><p>Variable occurrence restrictions again require renaming of bound variables during substitution, or failure of matching. The following example is taken from a formalization of a natural deduction system to show the variety of circumstances in which these problems occur.</p><p>Γ P ∀I, where x not free in Γ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Γ ∀xP</head><p>If this rule is used by matching against the lower line, the restriction on x must be checked separately -it is difficult to formulate the rule simply and concisely. Ideally, x would be renamed to a new variable x 0 if x is already free in Γ. If the rule is used in the other direction, it should simply not match if x appears in Γ. As we will see in Section 3.3, rules incorporating occurrence conditions can be formulated easily and applied correctly using higher-order abstract syntax.</p><p>Note that in a system that uses first-order abstract syntax, not only would the rule be conditional, but the language implementor would somehow have to define a predicate not-free-in for the language in question.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Correct Treatment of Contexts</head><p>Many program transformation rules can be stated naturally through the use of contexts. Correct applications of these rules, however, is tricky. For example, a rule propagating computation into the branches of an if expression could be written as</p><formula xml:id="formula_2">C[if p then a else b] ⇐⇒ if p then C[a] else C[b]</formula><p>Consider the following incorrect application.</p><formula xml:id="formula_3">let p = false in if p then 1 else 2 / ⇐⇒ if p then let p = false in 1 else let p = false in 2</formula><p>As noted in <ref type="bibr" target="#b15">[16]</ref> syntactic conditions on C are difficult to formulate if one wishes to eliminate the possibility of incorrect rule application as in the example. The use of higher-order abstract syntax solves this problem by allowing the statement of the rule as above, but automatically prohibiting the incorrect use below without any additional conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Design and Use of Higher-Order Abstract Syntax</head><p>In this section we will sketch higher-order abstract syntax and illustrate how it solves the problems mentioned in the previous section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Well-Sorted First-Order Abstract Syntax</head><p>Ordinarily a parser creates untyped abstract syntax trees. They can be viewed as terms where the operators in the language act as function symbols, and the lexical terminals as constants. Variables as such do not exist in this representation, that is, object language variables are represented as identifiers, which are all considered constants. In some systems in which program schemas are considered, explicit notations for schema-variables are introduced. These schema-or meta-variables become variables in the abstract syntax.</p><p>In the context of syntax manipulation tools the need for types in the abstract syntax soon arises. This is because one needs to be able to test whether a substitution of a subterm for another is syntactically legal. The types then are derived from the syntactic sorts or syntactic categories. The notion of syntactic sort and object language type usually do not coincide, though typically the object language types refine the syntactic sort structure.</p><p>As an example throughout this paper we will use a simple functional language with mutually recursive function definitions, because it provides a good framework for illustrating the use of higher-order abstract syntax.</p><p>We begin with a grammar that, except for special fonts, can be read directly by the parser and unparser generator in the Ergo Support System. The grammar augments surrounded by "&lt; &gt;" indicate the abstract syntax that the parser constructs to represent the concrete syntax on the left. We omit some of the straightforward grammar augments.</p><formula xml:id="formula_4">P ::= rec D &lt; rec 0 (D)&gt; D ::= F = E | D 0 and D 1 F ::= V | V F E ::= V &lt; var(V )&gt; | C &lt; const(V )&gt; | if E 0 then E 1 else E 2 &lt;ite(E 0 , E 1 , E 2 )&gt; | let B in E &lt; let 0 (B, E)&gt; | E 0 E 1 &lt;apply(E 0 , E 1 )&gt; | lam V . E &lt;lam 0 (V, E)&gt; B ::= V = E | B 0 and B 1</formula><p>This completes the outline of a view of abstract syntax as typed terms, where operators correspond to function symbols and syntactic sorts to types. Metavariables or schema variables would have to be a distinct syntactic category.</p><p>In the Ergo Support System, the first-order abstract syntax as defined by means of the grammar above is used by the parser, unparser, formatter, and interaction facility (for highlighting proper subterms). However, if a higher-order view is defined for a language the abstract syntax tree is never built. Instead, we parse directly into higher-order abstract syntax.</p><p>The first-order view from the higher-order representation is then created through a function that decomposes a term into its first-order operator and arguments. Currently, this function must be specified directly by the language implementor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Higher-Order Abstract Syntax</head><p>Motivated by the examples in Section 2 we now generalize to higher-order terms. This representation was suggested by Huet and Lang <ref type="bibr" target="#b10">[11]</ref> for use in program transformation. In this first generalization, simply typed lambda terms represent programs. Syntactic sorts become λ-calculus types. The lexical terminals and the operators that do not introduce variable bindings are, respectively, first-order and secondorder constants of the λ-calculus.</p><p>Another crucial change occurs for the variables. Operators in the object language that are binding constructs are now explicitly encoded as third-order constants. As the following examples will show, this requires that bound object language variables actually become variables in the typed lambda calculus.</p><p>The generalization to simply typed λ-terms is still insufficient for many languages. The problem is the presence of lists of various forms: lists of arguments, lists of bound variables, lists of mutually recursive function definitions. The usual solution is to curry functions, which enables representation, but not simple, finitary definition of transformation or inference rules. See, for example, the formalization of Hoare logic in LF <ref type="bibr" target="#b0">[1]</ref>, where the natural encoding remains restricted to a two-register machine. More generally, LF can naturally formalize an n-register machine for any fixed n, but only give a very unsatisfactory encoding of full Hoare logic.</p><p>To solve this problem, we have extended higherorder abstract syntax and the unification algorithm to handle products. In our formulation of the λ-calculus with products, we use pattern binders akin to ML, rather than constants fst and snd. The product is binary and associates to the left. Our example language has three constructs that introduce scope: let, lam, and rec. Figure <ref type="figure">1</ref> shows how they are represented in higher-order abstract syntax.</p><p>In order to express transformation rules through patterns, we now augment the grammar for the object language to a grammar for an associated pattern language. The pattern language is not universal, but rather is be constructed in harmony with a given object language. Because of the higher-order nature of <ref type="bibr" target="#b10">11</ref> . lam(λV 12 . . . E 1 . . .)), . . . , lam(λV m1 . lam(λV m2 . . . E m . . .)) )&gt; Figure <ref type="figure">1</ref>: Representation of let, lam, and rec.</p><formula xml:id="formula_5">let V 1 = E 1 and . . . and V n = E n in E as &lt;let(λ V 1 . . . V n . E) E 1 , . . . , E n &gt; lam V . E as &lt;lam(λV . E)&gt; rec V 1 V 11 . . . V 1n1 = E 1 and . . . and V m V m1 . . . V mnm = E m as &lt;rec(λ V 1 , . . . , V m . lam(λV</formula><p>our abstract syntax, this requires more than just the introduction of schema variables. Typically, an object language and its associated pattern language will differ by three or four productions. These additional productions provide for specifying variable applications, in some cases also for variables, abstractions, and products.</p><p>Here we include higher-order application and abstraction. Note how the augments of these productions differ from the cases building apply and lam.</p><formula xml:id="formula_6">E ::= . . . | E 0 [E 1 ] &lt;E 0 (E 1 )&gt; | λV . E &lt;λV . E&gt;</formula><p>Let us reconsider the let-conversion rule from Section 2.1. We can now state a single polymorphic rule for let-conversion. The first line shows how it would actually be stated, the second line shows the hidden type variable α. The given type is the most general, with let being a polymorphic constant of type (α → E) → α → E. Remember that the types in the representation correspond roughly to the syntactic categories of the language definition.</p><formula xml:id="formula_7">let x = e in b[x] ⇐⇒ b[e] let x α = e α in b α→E [x α ] ⇐⇒ b[e]</formula><p>We can match this rule, for example, against the following term let x = 5 and y = 6 in x * y</p><p>In this example, the substitution will be The Fold and Unfold rules <ref type="bibr" target="#b2">[3]</ref> provide two more examples of how rules can be concisely and easily formulated in this framework. Here we show the simpler Unfold rule and give a definition that states one single rule for any number of mutually recursive function definitions.</p><formula xml:id="formula_8">rec f = b[f][f] ⇐⇒ rec f = b [b[f][f]] [f]</formula><p>We now consider an example where this rule is applied to a recursive function definition. The objective of the transformation is to replace the first recursive call to gcd by the properly instantiated function body. This is achieved in two steps: the first is to replace a recursive function call by its definition, the second is to use lam-reduction (analogous to β-reduction, but on the level of the object language) to obtain the instantiated body.</p><formula xml:id="formula_9">rec gcd x y = if x = 1 then 1 else if x = y then x else if x &lt; y then gcd y x else gcd (x -y) y</formula><p>This program matches the unfold rule in four different ways, each either unfolding or not unfolding each of the two recursive calls. In the substitution below, g abstracts the occurrences of gcd that are to be unfolded and f the ones that remain unchanged in the transformation.</p><p>b ←λg . λh . if x = 1 then 1 else if x = y then x else if x &lt; y then g y x else h (xy) y</p><p>Applying the substitution to</p><formula xml:id="formula_10">rec f = b[b[f][f]][f]</formula><p>, the right-hand side of the rule, yields:</p><formula xml:id="formula_11">rec gcd x y = if x = 1 then 1</formula><p>else if x = y then x else if x &lt; y then (lam x . lam y . if x = 1 then 1 else if x = y then x else if x &lt; y then gcd y x else gcd (xy) y) y x else gcd (xy) y</p><p>Now we can apply lam-reduction twice, yielding the correctly unfolded program:</p><formula xml:id="formula_12">rec gcd x y = if x = 1 then 1 else if x = y then x else if x &lt; y then if y = 1 then 1 else if y = x then y else if y &lt; x then gcd x y else gcd (y -x) x else gcd (x -y) y</formula><p>Then, using two simple rules for simplifying if-then-else expressions we can eliminate some of conditions to get rec gcd x y = if x = 1 then 1 else if x = y then x else if x &lt; y then if y = 1 then 1 else gcd (yx) x else gcd (xy) y Higher-order rule descriptions, like the description of Unfold, can be embedded in a programming language so that compositions of transformations like the one above can be described as short pieces of programs. A good example of such a system is λProlog <ref type="bibr" target="#b14">[15]</ref>. Higher-order abstract syntax provides a way for systems like λProlog to use readable concrete syntax for programs without sacrificing power, simplicity of expression, or efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Propagating Contexts</head><p>Here is the promised solution to the challenge in Section 2.3. The context variable C simply becomes a second-order variable and will be instantiated only to proper contexts. A typical rule would be the following:</p><formula xml:id="formula_13">C[if p then a else b] ⇐⇒ if p then C[a] else C[b]</formula><p>See Figure <ref type="figure" target="#fig_1">2</ref> for an example of a context propagation rule and its use with higher-order abstract syntax. The last counterexample demonstrates how higher-order matching ensures that bound variables will not leave their scope. This restriction is not enforced through a test after a potential match is produced, but is an integral part of the higher-order unification algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Raising Rules</head><p>So far all examples have been second-order. However, there are many applications, in which one would like to use third-order matching. In the context of raised rules (as discussed here), our algorithm will always terminate (a result due to Miller <ref type="bibr" target="#b12">[13]</ref>). Raised rules are a significant generalization of Huet &amp; Lang's template matching <ref type="bibr" target="#b10">[11]</ref>.</p><p>Here is an example of an equivalence we would to obtain as a consequence of a general rule for context propagation.</p><formula xml:id="formula_14">let x = y * y in let z = x * y in if y &gt; 0 then z else x ⇐⇒ if y &gt; 0 then let x = y * y in let z = x * y in z else let x = y * y in let z = x * y in x</formula><p>This does not match the context propagation rule from above, since a substitution like a ←z would be captured by the binding on z. A general solution in a case like this is to raise the order of the rule through explicit abstraction. This solution is inspired by Paulson's ∀-lifting <ref type="bibr" target="#b17">[18]</ref> that was discovered independently by Miller and called raising <ref type="bibr" target="#b12">[13]</ref>. Both raise the order of certain equations in the presence of parameters. Raising requires that we be able to explicitly mention the "λ" of the λ-calculus representation in the pattern. The following is a raised version of context propagation.</p><formula xml:id="formula_15">C[λx . if p then a[x] else b[x]] ⇐⇒ if p then C[λx . a[x]] else C[λx . b[x]] C[if p then a else b] ⇐⇒ if p then C[a] else C[b] x * (if x &gt; 0 then 1 else -1) ⇐⇒ if x &gt; 0 then x * 1 else x * (-1) where C ←-λz . x * z, a ←-1, b ←--1, p ←-x &gt; 0. (if x &gt; 0 then 1 else -1) * x ⇐⇒ if x &gt; 0 then 1 * x else (-1) * x where C ←-λz . z * x, a ←-1, b ←--1, p ←-x &gt; 0.</formula><p>let q = false in if q then 1 else -1 / ⇐⇒ if q then let q = false in 1 else let q = false in -1 since C ←-(λz.let q = false in z), a ←-1, b ←--1 and p ←q leads to a clash. This operation raised the order of a and b to be second-order variables, C is now a third-order variable of type (E → E) → E. A match of this pattern against its motivating example is given through the substitution</p><formula xml:id="formula_16">C ←-λf . let x = y * y in let z = x * y in f[ x, z ] p ←-y &gt; 0 a ←-λ z 0 , z 1 . z 1 b ←-λ z 0 , z 1 . z 0</formula><p>Again note the use of polymorphism in the rule description and the instantiation of type variables to product types to capture the fact that this should apply to any number of bound variables that may appear in the branches of the if, but not in the test p.</p><p>This also shows that variable occurrence conditions become unnecessary. The fact that p could not depend on any variable bound in the context is implicit in the formulation of the rule.</p><p>Our current incomplete support for polymorphism cannot handle this example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Other Applications</head><p>Higher-order abstract syntax captures the binding information present in a language. We have shown in Section 3 how this can be used for correct unification, matching, and substitution and direct formulation of rewrite rules in the context of a language-generic environment for manipulating programs, formulas, and other syntactic objects.</p><p>In the following subsections we indicate how other components of such a generic environment can exploit the scoping information embedded in the representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Type Inference</head><p>In the Ergo Support System, we have prototyped a component for general type inference, given the semantic type signature of a language. Conceptually, the type signature is translated into an attribute grammar that will do type inference on a given term, though the actual implementation is slightly more efficient.</p><p>An early problem with our type signature specification language was that implicit binding constructs could not be handled. For example, in Prolog the binding of the free variables over a clause is implicit, and it need not have the same type as a variable with the same name in another clause. Other languages, where binding constructs are complicated could not be handled either. An example is an imperative language where an arbitrary number of local variable declarations may follow a begin.</p><p>With the use of higher-order abstract syntax these problems disappear, since the necessary analysis is done once and for all at parse time. Without going into detail, here is a possible type signature for our functional example language that is based on the higher-order abstract syntax representation. Note that this completely eliminates the need for analyzing the syntactic categories D, F , and B, which are not present in the higher-order abstract syntax. Constants of the object language may be declared separately -the last line is an example.</p><p>Briefly, the operator in the language (constant in the higher-order abstract syntax) is listed with their semantic types. Type constructors of the object language are funtype, prodtype, boolean, and number, type variables are α and β. rec</p><formula xml:id="formula_17">: (α → α) → α ite : boolean → α → α → α let : (α → β) → α → β apply : (funtype α β) → α → β lam : (α → β) → (funtype α β) *</formula><p>: (funtype (prodtype number number) number)</p><p>The higher-order nature of the abstract syntax makes this straightforward specification possible. Note that this specification does not treat let in the way ML does, that is, it does not copy the type variables in instances of α.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Attribute Grammar Evaluator</head><p>Most attribute grammars on a language with binding constructs will have to pass around an environment as context in which the attribute value will be computed. Typically that environment is enlarged when descending through a binding construct of language. As mentioned above, determining where variables are bound often requires a significant amount of work, like collecting free variables from a term. Using higher-order abstract syntax the repeated work can be avoided, thereby improving the efficiency of attribute analysis. Moreover, expression of attribute equations is more concise, since the environment of bound variables can effectively be hidden from the user in most cases.</p><p>The Analysis Facility in the Ergo Support System can currently process only attribute grammars that traverse first-order abstract syntax. The implementation of an extension of attribute grammars to take advantage of the higher-order abstract syntax is outlined here and planned for the near future.</p><p>Again, lacking space, the example is not fully explained but should indicate the form of such generalized attribute grammars. We show a fragment of an attribute grammar that evaluates expressions from our simple language. A higher-order subterm is treated as if it returns a function from the attribute value for the bound variable to the attribute value for the whole expression. That function can then be applied in the definition of other attributes. In the implementation, the function objects are never built, but they serve as a convenient, conceptual device. In effect, the attribute grammar will be translated into another computing the same value, but using environments in which the variable name is bound to the value to which the function would eventually be applied.</p><formula xml:id="formula_18">E(↑value) = C(↑value) | . . . | let([E → E](↑valuefn), E(↑value 0 ))</formula><p>where value = valuefn(value 0 ) | apply(E(↑value 0 ), E(↑value 1 ))</p><p>where value = value 0 (value 1 )</p><formula xml:id="formula_19">| lam([E → E](↑valuefn))</formula><p>where value = valuefn</p><p>In this example, the evaluation of a let would be significantly more efficient that evaluation of and application of an abstraction to an argument. The reason is that the term corresponding to the lam expression is actually built first, then later reduced by application, while the reference to valuefn in the clause for let will be compiled into a form using environments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Denotational Specification of Language Semantics</head><p>We have found that using higher-order abstract syntax significantly simplifies denotational semantics specifications. The key idea here, proposed in <ref type="bibr" target="#b10">[11]</ref>, is to specify the semantics of a language simply by giving an interpretation of the constants, and adopting the standard interpretations for variables, abstractions and applications.</p><p>Semantic specifications are syntax-directed, that is, the meaning of a compound expression should be a "function" of the meanings of its components in the abstract syntax. The constant interpretations are exactly these functions, and putting together terms with application has the semantic effect of applying the meaning of the constant to the meanings of the components. This frees the language specifier from this step and makes the semantic specifications very direct.</p><p>The standard technique for handling binding constructs is to make the meaning of an expression be a function from environments to values. For example, the semantics of a let expression in a call-by-name language is commonly given as</p><formula xml:id="formula_20">E [[let v = e 0 in e 1 ]]ρ = E [[e 1 ]](ρ + [v → E [[e 0 ]]])</formula><p>Using the formulation of let given above, this simplifies greatly to µ</p><formula xml:id="formula_21">[[let]] = λf . λa . f a</formula><p>The formulation of the call-by-value case is only slightly more complicated.</p><p>Formal syntactic systems involving semantic properties (such as total or partial equivalence of meanings) that are based on higher-order abstract syntax will naturally be much simpler than their traditional counterparts. This is because there is less distance between the (abstract) syntax being manipulated and the meanings that motivate them.</p><p>5 Some Implementation Issues and Further Work</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Implementation of Higher-Order Abstract Syntax</head><p>It seems that the most costly operations on abstract syntax are higher-order matching and unification. We therefore decided to implement the typed λ-terms, and provide the first-order interface through explicit conversion functions that are called when the firstorder components of a term are accessed. Our positive experience with the current implementation confirms that this was the right decision. The first-order constituents of a λ-term are cached as they are computed, thus making term-traversal almost as efficient as for first-order abstract syntax. We have not noticed a performance loss during formatted unparsing, which is the most time-consuming operation carried out using the first-order view of abstract syntax. However, the representation of λ-terms themselves leaves room for improvement. Currently, we use the normal form described by Huet in <ref type="bibr" target="#b9">[10]</ref>, but lazy normalization and the use of deBruijn's notation <ref type="bibr" target="#b4">[5]</ref> should lead to some efficiency improvements in the implementation of the unification algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Specification of Name Binding Constructs</head><p>Currently the language implementor has to supply some highly stylized Lisp functions that achieve the translations between higher-and first-order view of abstract syntax. We have not yet had enough experience to feel confident in a design of a user-oriented way of specifying the binding properties of a language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Nondeterminism</head><p>In general during program transformation, many of the rules will be too non-deterministic to be simply matched against a given program. In such a case we need a more specific instance of a general rule. This more specific instance can be obtained through substitution for some of the free variables in the pattern. The correctness of the specialized rule follows directly from the correctness of the general rule.</p><p>If one uses higher-order matching as part of the execution of a higher-order logic program <ref type="bibr" target="#b14">[15]</ref> then it is the programmer's responsibility to formulate and order the clauses in such a way that the nondeterminism of the higher-order unification is controlled. This requires some experience with λProlog, but is in general not too difficult.</p><p>Another solution we have used successfully is to interactively point at subterms displayed in a window, for example, to identify subterms over which to abstract.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Language Representation</head><p>When one is faced with the task of implementing an object language using higher-order abstract syntax, one is faced with a variety of choices. The most straightforward representation is described in this paper: syntactic categories (usually a subset of the nonterminals) become types and there is a distinct, possibly higher-order constant for each operator in the language.</p><p>However, sometimes one would like to eliminate some of the syntactic sugar from the concrete syntax and thus map different concrete syntax expressions to the same representation. This is currently possible in our implementation, but not very well supported, since the unparser would only unparse into concrete syntax corresponding to the core language. The advantage of using a smaller core language is that one needs to define semantics, transformation rules, etc., only for the core language.</p><p>Another possibility for a more concise representation of a typed language is to use the types of the λ-calculus to represent the types of the object language. The class of languages for which this is possible is limited by the expressiveness of the type system of the higher-order abstract syntax.</p><p>LF, the Edinburgh Logical Framework <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b6">7]</ref> makes explicit use of a different version of the λ-calculus to represent logical formulas and programs and the deduction system for reasoning about them. The way quantifiers are encoded is similar to the way it is done in higher-order abstract syntax and goes back to Church <ref type="bibr" target="#b3">[4]</ref>. Because of the power of their λ-calculus with dependent function types, it is not known whether there is a natural unification algorithm that could be used for proof search in their system in a general way. However, their system is at the same time weaker in a different respect, since it does not allow products or polymorphism. This means that many natural formulations of transformation or inference rules cannot be represented in LF.</p><p>Isabelle <ref type="bibr" target="#b17">[18]</ref> uses a representation similar to ours for the statement of rules, and uses higher-order unification for deduction. Isabelle's λ-calculus representation does not have the expressive power of higherorder abstract syntax, but explicitly encodes quantifier dependencies.</p><p>λProlog <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17]</ref> provides a natural metalanguage for writing programs acting on higher-order abstract syntax. This was the basic point made in <ref type="bibr" target="#b14">[15]</ref>. We plan a generalization of λProlog that would deal with products and thus allow us to use it as a very expressive metalanguage for metaprogramming in the context of language-generic program derivation and theorem proving.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>α</head><label></label><figDesc>←-E × E e ←-5, 6 b ←λ x, y . x * y Then the right-hand side becomes b[e] = (λ x, y . x * y)[ 5, 6 ] = βη 5 * 6</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Examples of context propagation.</figDesc></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This research was supported in part by the Office of Naval Research under contract N00014-84-K-0415 and in part by the Defense Advanced Research Projects Agency (DOD), ARPA Order No. 5404, monitored by the Office of Naval Research under the same contract.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Using typed Lambda Calculus to Implement Formal Systems on a Machine</title>
		<author>
			<persName><forename type="first">Furio</forename><forename type="middle">A</forename><surname>Arnon Avron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><forename type="middle">A</forename><surname>Honsell</surname></persName>
		</author>
		<author>
			<persName><surname>Mason</surname></persName>
		</author>
		<idno>ECS-LFCS-87-31</idno>
		<imprint>
			<date type="published" when="1987-06">June 1987</date>
			<pubPlace>Edinburgh, Scotland</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Laboratory for Foundations of Computer Science, University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The PSG system: from formal language definitions to interactive programming environments</title>
		<author>
			<persName><forename type="first">Rolf</forename><surname>Bahlke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregor</forename><surname>Snelting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="547" to="576" />
			<date type="published" when="1986-10">October 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A transformation system for developing recursive programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Darlington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="44" to="67" />
			<date type="published" when="1977-01">January 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A formulation of the simple theory of types</title>
		<author>
			<persName><forename type="first">Alonzo</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="56" to="68" />
			<date type="published" when="1940">1940</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>De Bruijn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Indag. Math</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="381" to="392" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Views for Tools in Integrated Environments</title>
		<author>
			<persName><forename type="first">David</forename><surname>Garlan</surname></persName>
		</author>
		<idno>CMU-CS-87-147</idno>
	</analytic>
	<monogr>
		<title level="s">Carnegie Mellon University</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">An Environment for Formal Systems</title>
		<author>
			<persName><forename type="first">Timothy</forename><forename type="middle">G</forename><surname>Griffin</surname></persName>
		</author>
		<idno>87-846</idno>
		<imprint>
			<date type="published" when="1987-06">June 1987</date>
			<pubPlace>Ithaca, New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Special issue on the Gandalf project</title>
		<author>
			<persName><forename type="first">Gandalf</forename><surname>Group</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Journal of Systems and Software</title>
		<imprint>
			<date type="published" when="1985-05">May 1985</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A framework for defining logics</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Furio</forename><surname>Honsell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gordon</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Logic in Computer Science</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1987-06">June 1987</date>
			<biblScope unit="page" from="194" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A unification algorithm for typed λ-calculus</title>
		<author>
			<persName><forename type="first">Gérard</forename><surname>Huet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="27" to="57" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Proving and applying program transformations expressed with second-order patterns</title>
		<author>
			<persName><forename type="first">Gérard</forename><surname>Huet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernard</forename><surname>Lang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="31" to="55" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hereditary Harrop formulas and uniform proof systems</title>
		<author>
			<persName><forename type="first">Dale</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gopalan</forename><surname>Nadathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andre</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second Annual Symposium on Logic in Computer Science</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1987-06">June 1987</date>
			<biblScope unit="page" from="98" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Unification under mixed prefixes</title>
		<author>
			<persName><forename type="first">Dale</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>Unpublished manuscript</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Higherorder logic programming</title>
		<author>
			<persName><forename type="first">Dale</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gopalan</forename><surname>Nadathur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Conference on Logic Programming</title>
		<meeting>the Third International Conference on Logic Programming</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1986-07">July 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A logic programming approach to manipulating formulas and programs</title>
		<author>
			<persName><forename type="first">Dale</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gopalan</forename><surname>Nadathur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Logic Programming</title>
		<meeting><address><addrLine>San Francisco, IEEE</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-09">September 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A survey of the project CIP: Computer-aided, intuition-guided programming</title>
		<author>
			<persName><forename type="first">B</forename><surname>Möller</surname></persName>
		</author>
		<idno>TUM-18406</idno>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>West Germany</publisher>
			<pubPlace>Munich</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Institut für Informatik der TU München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A Higher-Order Logic as the Basis for Logic Programming</title>
		<author>
			<persName><forename type="first">Gopalan</forename><surname>Nadathur</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>University of Pennsylvania</publisher>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Natural deduction as higherorder resolution</title>
		<author>
			<persName><forename type="first">Lawrence</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="237" to="258" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The synthesizer generator</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Teitelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments</title>
		<meeting>the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1984-04">April 1984</date>
			<biblScope unit="page" from="42" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">POPART: Producer of Parsers and Related Tools, System Builder&apos;s Manual</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Wile</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>University of Southern California, Information Sciences Institute</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
