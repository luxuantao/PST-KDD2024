<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Improved Bidirectional Heuristic Search Algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Dennis</forename><surname>De</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Umversitett van Amsterdam</orgName>
								<address>
									<settlement>Amsterdam</settlement>
									<region>Holland</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lenie</forename><surname>Sint</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Umversitett van Amsterdam</orgName>
								<address>
									<settlement>Amsterdam</settlement>
									<region>Holland</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Improved Bidirectional Heuristic Search Algorithm</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">59956E716C510CB25FEBF1146840407F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A modification of Pohl's bidirectional heuristic search algorithm is described together with a simplified implementation. Theorems are proved about conditions yielding shortest paths The results are given of a worst-case analysis of different algorithms, suggesting a rank order of their quahty Results that Pohl had obtained with a unidirectional heuristic search algorithm on the 15-puzzle are compared with the results obtained with the new-simplified-algorithm KEY WORDS AND PHRASES artificial intelligence, bidirectional heuristic search, front-to-front grading, path finding CR CATEGORIES 3 64, 3 66</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In this paper we limit ourselves to those problems (a) which are representable m the statei-operator-state2 paradigm, (b) in which the goal can be explicitly represented as a state in a set of states, (c) whose problem space can be described as a labeled graph, (d) for which it is equally possible to work from the start state to the goal state as the other way around, and (e) for which there is a heuristic function available which can be used to guide the search process.</p><p>As IS well known (see, e.g. [3]), a heuristic function can be used to guide a unidirectional search. The property of ending with a shortest path between start state and goal state, as can be found with breadth-first search without heuristic function, can even be preserved if the heuristic function is a lower bound on the real minimum effort to be made. In <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr" target="#b4">[5]</ref> an algorithm ts described which generahzes to the bidirectional case. This algorithm in fact performs two independent unidirectional searches, a forward search guided to the goal node and a backward search graded to the start node. The disadvantage of this is that in a search space where more than one path exists from the start node to the goal node, the two searches often proceed along two different paths, and so the two sets of closed nodes (for an explanation of "closed," "nodes," and other techmcal jargon see <ref type="bibr" target="#b2">[3]</ref>) grow into nearly complete unidirectional trees before intersectmg each other, instead of meeting in the "middle" of the space.</p><p>In Section 2 we discuss another algorithm that remedies this defioency, and we give a simphfication of that algorithm which has been implemented in a Fortran program.</p><p>In Section 3 we compare our results with the results of Pohl's unidirectional heuristic search on the 15-puzzle. In Section 4 we mention some possible improvements of the implemented algorithm.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Bidirectional, Heuristic, Front-to-Front Algorithm (BHFFA)</head><p>Before going into a precise description of the BHFFA, we give an intuitive sketch. Suppose we have the sRuation shown in Figure <ref type="figure" target="#fig_0">1</ref>, where S and T are the sets of closed nodes and S and i" are the two fronts of open nodes, and we decide to expand a node from S. In Pohl's Bidirectional Heuristic Path Algorithm (BHPA) a node was chosen in which had a minimum value of the functiongs + hs, where g8 was the current minimum to the start node s and h s was an estimator of the distance from the node to the goal node t. The hs we use is different. For a node n, hs(n) is a minimum of ft(n,y) + gt(Y), where y ranges over all nodes in the opposite front T; gt is like gs but with respect to the goal node t, and/-/is an estimator of the shortest distance between pairs of nodes.</p><p>The disadvantage of this algorithm with respect to the BHPA must be immediately clear, since the calculation of the function hs in our algorithm is much more complicated ~an the calculation of the distance to t in the BHPA. On the other hand, there are gains, but we defer discussing them until Section 3.</p><p>In order to describe the BHFFA, we have to give some definitions, in which we follow as closely as possible the terminology of <ref type="bibr" target="#b4">[5]</ref>: s is the start node; t is the goal node; S is the collecUon of nodes reached from s which were expanded; T is the collection of nodes reached from t which were expanded; is the collecUon of nodes which are not in S but are direct successors of nodes in S; is the collection of nodes which are not in T but are direct successors of nodes in T;</p><p>H(x, y) is the minimum distance between node x and node y ; fi/(x, y) is a nonnegative estimator of the distance between x and y with f/(x, y) = fi/(y, x); gs(Y) is the minimum distance betweens andy fory ~ S U S, with path in S U S, along the current pointers;</p><p>gt(Y) Is like gs(Y) wRh respect to t and T U T; hs(n) = mmu~¢(f/(n, y) + gt(Y)); ht(n) = minv~(/-/(n, y) + gs(Y)); A(x) = g~(x) + hs(x); F(x) is the fimte set of nodes obtainable by applicable operators on x; F-~(x) is like F(x), but with inverse operators instead; l(n, x) is the nonnegative edge length between n and x.</p><p>We now define the BHFFA: (1) Placex in S andt in 'l', S .= T = O (2) If S t3 7" = O then stop without a solution, otherwise deode to go forward, step (3), or backward, step (10) (3) Select n m S wlthf~(n) = mm~gf~(y), remove n from S and put n in S, let descendants(n) .= F(n) (If more than one can be selected try to find a node n for which n E i" holds) (4) If n ~ T then halt with a solution path.</p><p>(5) If descendants(n) = ~ then go to step (2) (6) Select x from descendants(n) and remove It <ref type="bibr" target="#b6">(7)</ref> Ifx C S then (lfg,(n) + l(n, x) &lt; g,(x) then {redirect the pointer to n}, go to step ( <ref type="formula">5</ref>)) (8) If x E S then (If g,(n) + l(n, x) &lt; gs(x) then {redirect the pointer to n, remove x from S, and put x in $}; go to step (5)). ( <ref type="formula">9</ref>) Put x m S, provtde a pointer to n, and go to step (5) (10) Do steps (3) through (9) with (s, S, S, F) replaced by (t, T, T, F-0</p><p>In step <ref type="bibr" target="#b1">(2)</ref> nothing is said about the decision to go forward or backward. As investigated by Pohl, the most promising procedttre is to count the number of nodes in and i" and to select the front which has the fewest (but at least one).</p><p>Remark. Unhke the case with the unidirectional algorithm, the h-value cannot be stored at a node since this value changes dynamically as a consequence of mutations m the opposite front.</p><p>2.1 SOME THEOREMS ABOUT THE BHFFA. We give some theorems and proofs about the BHFFA which parallel the theorems and proofs about the umdirectional A* algorithm of <ref type="bibr" target="#b2">[3]</ref>. THEOREM 1. If Ill(x, y) --&lt; H(X, y) and tf all edge labels are not less than some positive ~, then the BHFFA halts with a shortest path between s and t (provided there is one).</p><p>PROOF. As in the unidirectional case, we first prove a lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LEMMA 1 If ill(x, y) --&lt; H(x, y), then, for every iteration of the BHFFA and for every optimal path P from s to t, there exist open nodes n ~ S, m ~ T, on P with fs(n) -&lt; H(s, t) and ft(m) -&lt; H(s, t).</head><p>PROOF. Let n be the first node on P, counted from s, with n ~ ,~. Let m be the first node on P, counted from t, with m E 7" (they exist because otherwise all nodes on P would be closed and the BHFFA had already halted with the solunon path P). Case <ref type="bibr" target="#b1">(2)</ref>. We have just proved that the BHFFA eventually halts, and it can only do so for two reasons: It has found a solution path, or S tA T is empty. Lemma 2, however, prohibits that S tA T = 0. Case (3) Just before ending with a node m, there would, by Lemma 1, be a node n in S with .fs(n) -&lt; H(s, t) &lt; fs(m) + gt(m), and thus n would be chosen for expansion instead of re. [] The next theorem proved m <ref type="bibr" target="#b2">[3]</ref> for the umdirectional algorithm is the optimality theorem, which states that if two heuristics H and H* are related by H*(n, t) &lt; H(n, t) -~</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>fs(n) = gs(n) + hs(n), = gs(n) + [I(n, y) + gt(Y)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H(n, t) for all n, and if H(n, t) + H(n, x) -&lt; [I(x, t</head><p>) for all n and x (this property is called the consistency property), then every node expanded by H will also be expanded by H*. The analogue of this theorem for the BHFFA doesn't hold. For a counterexample and an alternative optimality theorem see <ref type="bibr" target="#b0">[1]</ref>.</p><p>2.2 WORsT-CAsE ANALYSIS. A first-order comparison of these algorithms can be done by investigating how they behave in worst-case situations. For a certain search space we give formulas for the number of expanded nodes for the unidirectional and bidirectional Pohl algorithms and the BHFFA, assuming that the heuristic function used gives a maximum error between relative bounds.</p><p>Let the search space be an undirected graph containing a countable collection of nodes; two nodes, the start and goal nodes, have m edges (m &gt; 1), and there is a path of length K between them. From all other nodes emanate m + 1 edges; there are no cycles; and all the edge lengths are one. So all nodes except the start and the goal nodes have m + 1 successors, of which one is the direct ancestor. Since for the unidirectional and bidirectional Pohl algorithms and the BHFFA, the direct ancestor will be found in the set of closed nodes and will consequently be ignored (in this space there is only one g-value possible, so that can't be improved), we only consider the remaining m successors. From a unidirectional point of view, the space is a tree with branching rate m since the algorithm will not look beyond the goal node.</p><p>Suppose that for each node x on the solution path (s.p.), nodes off the s.p. are expanded till some depth n, and that this n is a function of the real distance R to the goal node in the unidirectional case, to the start respectively goal node in the case of Pohl's bidirectional algorithm, and to the opposite front in the BHFFA case: n = u(R). At depth 1 offthe s.p. there are m -1 nodes, at depth i there are m~-~(m -1) nodes, and so the total number of nodes in one such sldetree of depth u(R) is given by utR</p><formula xml:id="formula_0">)--I VR= ~ (m'(m--1))=(m--1)(m u(n)-1)/(m --1) =m u(R)-1.</formula><p>z=O If we denote by fA the total number of nodes erroneously expanded by Algorithm A, we get the following results:</p><p>1. Unidirectional: R is the distance to the goal node, going from s to t on the s.p.; R decreases in steps of 1 from K till 1 and so</p><formula xml:id="formula_1">= ~ V.. (<label>1</label></formula><formula xml:id="formula_2">)</formula><p>idlrectlonal R=I 2. Bidirectional Pohl: For some node lying on the s.p. and expanded by the forward algorithm, R is the distance to the goal node, and this distance decreases in steps of 1 from K for the start node to K/2 + 1 for the intersection node. So the forward algorithm expands a total of ~=K~2+1 VR nodes off the s.p.; the same number is expanded by the backward algorithm (for convenience we assume for all the bidirectional cases that K is even and strict alternation; slight changes are required when K is odd), and so =2 ~ VR.</p><p>(</p><p>]directional Pohl R=KI2+I 3. BHFFA: Firsts is expanded, then t. Suppose a is the successor ofs lying on the s.p. and b is the predecessor oft on the s.p. Then for the sidetree of s, R = R(s, b) = K -1, and so the depth of the sidetree hanging off sts u(K -1). The same goes for the tree hanging off t. When a and b are expanded after the sidetrees at s and t are completed, the distances from a and b to the opposite front are K -3, etc So in this case R is decreasing in steps of 2 from K -1 until 1 is reached; therefore the total number of nodes in all the sldetrees is gwen by</p><formula xml:id="formula_4">K/2 = 2~ V2R--1.<label>(3)</label></formula><p>HFFA R=I</p><p>These results hold independently of the form of u(R).</p><p>It is reasonable to assume that the smaller the real distance, the more accurate (or the less erroneous) will be the estimated distance. Thus we expect that the depth of the stdetree hanging off a node on the s.p. will become smaller as R becomes smaller. In that case u(R) is a monotonically decreasing function. Figures <ref type="figure">2, 3,</ref> and<ref type="figure" target="#fig_1">4</ref> give an idea of the depths of the sidetrees (represented by the lengths of the bars) for all nodes on the solution path tf this assumption holds.</p><p>If R1 &lt; R2 "--&gt; u(R1) &lt; u(R~), then also R1 &lt; R2 ~ VR1 &lt; VR2 (V R denotes the number of nodes in the sidetree with depth R), and so</p><formula xml:id="formula_5">KI2 KI2 KI2 K K K 2EV2.-,&lt; ~.V2R-,+ EV2.= 2VR &lt; E VR+ E Vn R=I R=I R=I R=I R=K/2+I R=K]2+I</formula><p>or fBHFFA &lt; fun,dxrectlonal &lt; fbidxrectlonal Pohl"</p><p>Now we show that u(R) is indeed a monotonically decreasing function if we assume that the heuristic [t gives a maximum error between relative bounds; that is, if for some 8 &gt; O, Unidirectional and bidirectional Pohl (Figure <ref type="figure">5</ref>): Ifx E s.p., y E s.p., y E F(x), and z ~ s.p., z ~ Fn(x), then z will be expanded iffg(z) + h(z) -&lt; g(y) + h(y), (c) a node in the sldetree hanging off x ~ s.p. wdl always realize its minimum in a node y' E F(y), y E s.p., y' ~ s.p., and a node in the sidetree ofy E s.p. wdl always realize its minimum in a node x' E F(x), x ~ s.p., x' E s.p., (d) after expansion ofx' E F(x), x andx' ~ s.p., andy' E F(y), y andy' ~ s.p., no other nodes in the sldetrees of x and y wdl be expanded.</p><formula xml:id="formula_6">n=u(K-1) n=u(K) s n=u(K-1) \ \ \ \ \ \\ \</formula><formula xml:id="formula_7">or K -R + n -+ (R+n)/(I+8)-&lt;K-R+ 1 +(R- 1)(1 +8),orn(1 + 1/(1+8))~--R/(1+8) + (R -1)(1 + 6) + 1, orn(1 + 8 + 1)--&lt; -R + (1 + 8) + (R -1)(1 + 6) 2, orn(2 + 8)-&lt; -R +l+8+R+2RS+R82-1-28-82 ,orn(2+8)--&lt;RS(2+8)-8(l+8</formula><p>In Appendix A we give proofs for these four statements. Suppose we have x ~ S, x' E F(x), z ~ Fn(x), x ~ s.p., x' ~ s.p., z ~ s.p., y ~ 7", y' ~ I-'(y), y E s.p., y' E s.p.</p><p>(see Figure <ref type="figure">6</ref>); then z will be expanded iffgs(z) + h,(z) -&lt; gs(x) + h,(x'), orgs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(z) + gt(Y') + f-I(z, y') -&lt; g,(x') + gt~') + ft(x', y'), or [K-(R+ 1)]/2+n+[K-(R+ 1)]/2+l+(R+n)/(l+8)-&lt;Z([K-(R+1)]/2+l) + (R -1)(1 + 8),</head><p>and this yields n = INT(R8 -8(8 + 1)/(8 + 2)), the same as for the unidirectional and bidirectional Pohl algorithms.</p><p>If we denote 8(8 + 1)/(8 + 2) by ca, the complete formulas for the j:A's become (we assume n = R8 -c8 instead of n = INT(R8 -c~)) </p><formula xml:id="formula_8">1. = VR ~ m~-%-, + m28-%-~ + ''' -t-mKS-%-~ = m(~-% ) nldlreetlonal R= 1 (m K~ -1)/(mS -1) -K, 2.~ =2 ~ VR~2(m(K/2+l)~-cs-~-I-m(K/2+2)~-ca-~"t''''+ ldlrectlonal Polll R=KI2+I m K8-c8-') = 2m ('+~i2'8-c8 (m (Ki2)a -1)/(m a -1) -K, ~B K I 2 3. = 2 E V2R-1 ~ 2(m 8-c~-' + m38-%-' + "" • + m (g-</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Experiments with the BHFFA</head><p>3.1 THE PROGRAM. A modified BHFFA algorithm is implemented as a Fortran program geared toward solving the 15-puzzle. In this search space all edge lengths are taken as unity. The modlficattons made are the following:</p><p>(1) If the program has not found a solution path after expanding 1000 nodes, it gives up.</p><p>(</p><formula xml:id="formula_9">)<label>2</label></formula><p>The number of open nodes in a front is restricted to some maximum m, whmh is given to the program as an input parameter but must be less than 100. This restriction is  = 20 t must be expanded before the algorithm termmates realized by deleting the worst node of a front whenever inserting a new one would mean that the front would contain more than m nodes. We call this operation "pruning," a term also used in <ref type="bibr" target="#b2">[3]</ref>. The pruning ts mainly necessary to save time, as the number of comparisons needed to calculate hs(x) for a node x m ,5 is equal to the number of nodes m and vice versa. But this also means that the algorithm is not admissible anymore (an algorithm satisfying Theorem 1 is called admissible), since it is possible that some node on the optimal path will be thrown away because tt looked bad at some Iteration. In a (which in fact meansfl(x) = g~(x) + minv~i. (P(x, y) + gt(Y)) for x in S; ~tc.). As there were ten different 15-puzzles, this amounts to a total of 320 problems, of which our program solved 240, whereas the unidirectional program of Pohl solved 203 of them. It can be seen that in nearly all these cases the heuristic is not a lower bound on the real effort to be made. This is the main reason why ~aany of the solutions found are not optimal, both for Pohl's program and ours.</p><p>The results are given in Tables I-IV. Table <ref type="table">I</ref> gives the number of problems solved for each of the ten puzzles with each function. Subtotals are made for each puzzle and for each function. Table <ref type="table">II</ref> gives a score for the path lengths. It was obtained as follows: The program with the shortest path for some problem scored 1 and the other program scored 0 (and any path is counted shorter than no path at all); if the same path length was found, both programs scored 1 ; if a problem wasn't solved by either of them they both scored 0. Table <ref type="table">III</ref> gives a similar score for the number of nodes expanded. Table <ref type="table" target="#tab_2">IV</ref> gives for each problem the shortest path found, the average path length over all solved cases, and the average number of expanded nodes over all solved cases.</p><p>Insofar as the solution quality is concerned, the BHFFA is an improvement over the unidirectional algorithm: It solves more problems, finds in general shorter paths, and expands less nodes on the average, although the last effect is less prominent than we expected. The BHFFA performs particularly well with a strong heuristic funcUon; with f4 the total number of nodes expanded by our program was 32 percent less than that by Pohl's program.</p><p>The front length adequate for the problems was found empirically. Experimental runs were made with front lengths of 25, 32, and 50. An increasing number of problems was solved and a higher stability was reached. (By stability we mean the chance that a longer front length preserves a solution obtained with a shorter front length; pruning tricks are the obstructing force here.) As could be expected, the performance with respect to the front length depends on both the solution path length and the heuristic used: The better the estimator, the smaller the front length required (a length of 1 would suffice for a perfect heuristic). All problems were run with a front length of 50, and the least satisfactorily solved were run again with a front length of 99, in order to see whether the maximum number of 1000 expanded nodes or the pruning in the fronts was the bottleneck. In general the first seems to be the case, since no significant improvement was made (with the excepUon offl on A9 where six instead of one out of seven problems were solved).</p><p>The main disadvantage of Pohl's bidirectional algorithm, mentioned in Section 1, appeared to be remedied. The fronts now did meet near the middle of the search space, which we could see by comparing gs and gt of the intersection nodes.</p><p>The large disadvantage of our algorithm is the very time consuming calculauon of the distance estimator. How much more expensive the BHFFA is depends on the heuristic used: The more complicated this function is, the larger will be its share in the total computation time needed for a solution, and the smaller will be the share of the other computations, which have to be done equally for the BHFFA and for the unidirectional algorithm. So, with a front length of m, the BHFFA will be in the limit (with an infinitely complicated heuristic) m times as expensive as the unidirectional algorithm when they end up with a solution path of the same length. In general the loss of efficiency will not be sufficiently set off by the shorter paths found. Nevertheless, it may pay off in, for example, an ABSTRIPS-like environment (see <ref type="bibr" target="#b6">[7]</ref>), where it is crucial to find an optimal path from among many different existing paths, as the number of subproblem searches depends on the path length found in the dominating problem space. There the BHFFA or a similar algorithm (in Section 4 we suggest ways to make it cheaper) with a strong heuristic function may find an optimal path more efficiently than a unidirectional program with a heuristic satisfying the lower bound condition, because this kind of heuristic tends to be rather weak and results in a fast explosion of the number of nodes expanded. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Open Problems and Loose Ends</head><p>The BHFFA can be simphfied by not calculating the heuristic distance to every node in the opposite front but only to the best half or even less of them. This idea Is inspired by the fact that, in the limited number of cases where we checked it, a node realized its mlmmum nearly always m a node which belonged to the best ten of the opposite front. A further simplification would be to delete the resequencing of the opposite front as the consequence of addmg a node to a front. The sensitivity of the solution quality to these computation times and memory savings should be tested. The partly expanded node techmque, as suggested in <ref type="bibr" target="#b5">[6]</ref>, needs investigating. A less technical question, however, concerns the selection of the most interesting of the vast amount of potential macrooperator sequences that appear in a solution path. But the real artificial intelhgence question is still: How can the program improve its heuristic function beyond simply optimizing some coefficients 9 Heavily related to this is the question: How does one find automatically the best representation for a problem to be treated by heuristic algorithms?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>First we repeat the statements made in Secuon 2.2 concerning the BHFFA, and then we give proofs for them. When the BHFFA expands nodes coming alternatwely from S and from T, and when it uses the heuristic lfI(x,y) = H(x,y)(1 + 8) if bothx andy are on the s.p., and H(r, y) = H(x, y)/(1 + 8) in all other cases, then (a) when a nodex, x C s.p., x E S, is expanded, it realizes its minimum in a nodey s.p., y ~ 7";</p><p>(b) whenever a node x E S, x ~ s,p., is expanded, then at the next ~teration a node y E T, y ~ s.p., will be expanded with H(t, y) = H(s, x);</p><p>(c) a node m the sidetree hanging off x E s.p. will always realize its minimum in a nodey' E F(y), y ~ s.p., y' ~ s.p., and a node in the sidetree ofy E s.p. wdl always realize its minimum in a node x' E F(x), x E s.p., x' ~ s.p.;</p><p>(d) after expansion ofx' ~ F(x), x andx' ~ s.p., andy' E F(y), y andy' ~ s.p., no other nodes m the sldetrees of x and y will be expanded.</p><p>(a), (b), and (c) will be proved by induction. First we check the statements for s and t. (a) at the moment s is expanded it realizes it minimum in t; (b) s and t are expanded immediately after each other; (c) for x ~ F"(x), y E Fn(t), s' ~ F(s), t' ~ F(t), x, y E s.p., s', t' E s.p.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>gs(x) + tel(x, t') + gt(t')</head><formula xml:id="formula_10">= n + (K -1 + n)/(1 + 8) + 1</formula><p>&lt; n + (K + n +n)/(1 +~5) +n = gs(X) + .f/(x, y) + gt(Y).</p><p>Sox realizes its mimmum m t' and not iny E F-n(t). The same holds fory with respect to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S t "</head><p>Now we proceed with the reduction steps (see Figure <ref type="figure">8</ref>). Suppose (a), (b), and (c) hold for nodesx andy, x ~ ,~, x ~ s.p., y ~ 7", y E s.p.; then we prove that they also hold forx' ~ F(x), x' E s.p., and fory' ~ F(y), y' E s.p.</p><p>Let H(x, y') be R, then H(s, x) = H(t, y) = [K -(R + 1)]/2 (they are equal according to (b)). Inductive proofs for (a), (b), (c), and (d) follow.</p><p>(a) As the branching rate is a constant, and as x and y were expanded immediately after each other, the sidetrees at x and y will grow m exactly the same way and so, for some nodes zl E F"(x) and z2 E F"(y), at even iterationsfs(zl) = ft(z2). Since according to (c) they realize their minimum in y' respectively x', expansion of zl doesn't change the value of z2; descendants of zl will have larger f-values than zl, and so z2 will be expanded next. Therefore y' will not be expanded as long as x' Is not expanded. Furthermore, x' will not be expanded as long as it realizes ~ts minimum in some node m the sidetree at y, because when this is the case, there is always some node zl m the sidetree at x with the same fs-value to y' and then this zl will be chosen for expansion instead of x'. (We had a worst case so ties are always resolved in the most unfavorable way.) So, at the moment x' is expanded, it realizes its minimum in y', and at the same moment y' realizes its minimum in x', and fs(x') = ft(,v') is the minimum of all distances between nodes from S and 'F. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIG 1 "</head><label>1</label><figDesc>FIG 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIG 4</head><label>4</label><figDesc>FIG 4  Bldlrectmnal Pohl Since at t, R is stdl Fm 5 H(s, t) = K, umdl-K/2, n never gets very small rectlonal</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>1)8-e*-' = 2m 8-e~ HFFA R=I (m K~-1)/(m z~-1)-K. Examples for K = 4, m = 2, 8 = 1 are shown m Figures 7(a) (unidirectional), 7(b) (bidirectional), and 7(c) (BHFFA)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(s, t) = K, BHFFA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIG 7</head><label>7</label><figDesc>FIG 7 Examples of worst-case situations ~/(x,y) = H(x, y)(1 + 6) if bothx and y are on the soluUon path, and [-/(x, y) = H(x, y)/(1 + ~5) otherwise (unldlrecUonal, y = t always; btdlrecuonal Pohl, y = s or t) Filled-m circles are nodes vtslted and expanded, empty circles are nodes visited but not expanded For all the examples K = 4, m = 2, and 6 = 1. The numbers beside the nodes are the f-values, the order of expansion for the first two algorithms is then easdy derived INT IS a functton that produces the integer part of the expression foUowmg it (a) Unidirectional. J: = mINr~-e~(rn ~:° --l)/(m ° --1) --K = 20 × (24 -1)/(2 ~ -1) -4 = 11 See below for part (b) and see next page for part (c) s</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 or 2 [</head><label>12</label><figDesc>FIG 8 BHFFA Dashed hne is f~(zl), dotted hne is ft(z2), both before expansion of x' and y'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>successors, and as the maximum number of steps any node is away from s or t is finite, both Ms and Mt can only contain a finite number of nodes, and so M = M~ t_J Mt is of finite size. Let the number of nodes in M be Y-Let Pm be the (necessarily finite) number of different paths from s to m if m ~ M~, and from t to m if m ~ M, and let p be the maximum over all Pro. Then p is the maximum number of different times a node can be reopened. Afterp • Y iterations of the BHFFA, all nodes of M are permanently closed. So S tAT = O and the BHFFA halts, which produces a contradiction.</figDesc><table><row><cell>for some y E T,</cell></row><row><cell>--&lt; gs(n) + [I(n, m) + gt(m) by definition of hs,</cell></row><row><cell>--&lt; gs(n) + n(n, m) + gt(m),</cell></row><row><cell>= H(s, t) since we are on an optimal path.</cell></row><row><cell>ft(m) &lt;-H(s, t) is proved in the same way. []</cell></row><row><cell>Now suppose Theorem 1 doesn't hold. Then we have three cases: (1) the BHFFA</cell></row><row><cell>doesn't halt; (2) the BHFFA halts without a solution path; (3) the BHFFA halts without</cell></row><row><cell>a shortest path.</cell></row><row><cell>Case (1). Let P be an optimal path from s to t. According to Lemma 1 there always</cell></row></table><note><p>exists an open node n in S U 7" on P with fs(n) or ft(n) -&lt; H(s, t). Therefore the nodes expanded must have an f-value less than or equal to H(s, t). Consequently their g-values are less than or equal to H(s, t). Thus the BHFFA only expands nodes at most H(s, t)/8 steps away from s or t, and this is a finite number. Let Ms and Mt be the sets of all nodes which are ever generated from s and t, respectively. As every node has only a finite number of</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE IV COMPARISON</head><label>IV</label><figDesc>OF PATH LENGTHS</figDesc><table><row><cell>Problem</cell><cell cols="2">Shortest path found for each problem</cell><cell cols="2">Average path length</cell><cell cols="2">Average number of nodes expanded (only over the solved problems)</cell></row><row><cell></cell><cell>Pohl</cell><cell>Our</cell><cell>Pohl</cell><cell>Our</cell><cell>Pohl</cell><cell>Our</cell></row><row><cell>A1</cell><cell>12</cell><cell>12</cell><cell>12</cell><cell>12</cell><cell>12.6</cell><cell>12.9</cell></row><row><cell>A2</cell><cell>26</cell><cell>26</cell><cell>42.8</cell><cell>27.3</cell><cell>161.5</cell><cell>54 4</cell></row><row><cell>A3</cell><cell>36</cell><cell>34</cell><cell>64.8</cell><cell>44 0</cell><cell>389.1</cell><cell>320 9</cell></row><row><cell>A4</cell><cell>20</cell><cell>20</cell><cell>21 8</cell><cell>24.3</cell><cell>90.2</cell><cell>108 6</cell></row><row><cell>A5</cell><cell>38</cell><cell>32</cell><cell>56 7</cell><cell>39 7</cell><cell>310.4</cell><cell>250.1</cell></row><row><cell>A6</cell><cell>32</cell><cell>32</cell><cell>42.8</cell><cell>37.1</cell><cell>335 7</cell><cell>333 4</cell></row><row><cell>A7</cell><cell>36</cell><cell>36</cell><cell>56 6</cell><cell>53.7</cell><cell>365 4</cell><cell>429 3</cell></row><row><cell>A8</cell><cell>85</cell><cell>61</cell><cell>132.0</cell><cell>93.0</cell><cell>605 6</cell><cell>485 9</cell></row><row><cell>A9</cell><cell>86</cell><cell>88</cell><cell>152 9</cell><cell>118.5</cell><cell>551 2</cell><cell>563 5</cell></row><row><cell>A10</cell><cell>64</cell><cell>60</cell><cell>92 3</cell><cell>90 0</cell><cell>609 3</cell><cell>532 3</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research originated from a grant of the Netherlands Organization for the Advancement of Pure Research (Z W O ), whlch enabled the first author to visit the University of Texas, Austin, Texas, where L Slklossy introduced him to this. field Authors' address Umversiteit van Amsterdam, Jodenbreestr 23 k 3123, Amsterdam-1001, Holland</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>..__------O 5 5 ~_//~ ,I 5</p><p>t FIG <ref type="bibr" target="#b6">7</ref>(c) BHFFA The order of expansion is shown m brackets, the f-values are those at the moment of expansion f 2mINa'(a-cn)(m ^a -1)/(m 28 -1) --K = 2 x 2 x (24 -1)/(22 -1) -4 = 6</p><p>search space where only one path exists from start to goal node, some backtracking mechanism would be required to ascertain that this path is found. In the case of the 15puzzle, the actual influence didn't appear to be very large lfm was set at 50 (or larger), as will be seen in Section 3.2.</p><p>(3) Step (8) of the BHFFA, in which occurrence of a new node in the collection of closed nodes in its own front is checked, was eliminated. This was done because we thought the time gained in possibly expanding a few nodes less would not balance the loss caused by searching through the set of closed nodes for every new open node. <ref type="bibr" target="#b3">(4)</ref> Step (4), the terminating condition, was eliminated and replaced by a test in step (6): "If x ~ 7" tO T then halt with a solution path." That the testing of x is in ?" tO T, instead of just in T, is a necessary consequence of the pruning, as it ~s possible that a descendant of a closed node is deleted from the front of open nodes.</p><p>Step (9) was done by estimating all distances to the opposite front and inserting node x m one of the ordered fronts of open nodes, where the ordering is given by the f-values of the open nodes. A nasty side effect was that the insertion of a new node in S could imply a reordering of 7" and vice versa. The ordering was done by using a square matrix m which all combinations of the/:/(x, y)-values of the front were stored.</p><p>Three heuristic functions were implemented in the program:</p><p>(1) P(a, b) = 2, P,, with p, being the Manhattan distance between the positions of tile l in a and in b.</p><p>(2) S(a, b) = ~, p~ h, ° 5, where p, is as m (1) and h, is the distance in a from tile i to the empty square.</p><p>(3) R(a, b) is the number of reversals in a with respect to b, where a reversal has the meaning that a(i) --b(j) and a(j) = b(i), and t and j are adjacent tiles.</p><p>Of these functions the first two originally come from <ref type="bibr" target="#b1">[2]</ref> and the third comes from <ref type="bibr" target="#b3">[4]</ref>.</p><p>3.2 RESULTS, CONCLUSIONS, AND REMARKS. In order to compare our results with the unidirectional case, the program was run with the same 15-puzzle problems as were used by Pohl in <ref type="bibr" target="#b3">[4]</ref> (see Table <ref type="table">I</ref> </p><p>and so now y' will be expanded.</p><p>[] (c) A node in the sidetree of x' always realizes its minimum in y" and vice versa, because if zl ~ F"~(x') and z2 ~ F"z(y'),</p><p>2 = gs(zl) + gt(z2) + f/(zl, z2) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(d)</head><p>f~(x") --&lt; gs(x") + gt(Y") + _-I(x", y") &lt; gs(X") + gt(Y') + lf-l(x", y') = fs(z2); and so z2 won't be expanded anymore. [] ACKNOWLEDGMENT. Discussions with Ira Pohl on earher drafts were highly appreciated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R-3+nl</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">L An optlmahty theorem for a b~-d~rectional heuristic search algorithm Rep of Inst. voor Bedrqfseconomm en Accountancy</title>
		<author>
			<persName><forename type="first">D</forename><surname>De Crlampeaux</surname></persName>
		</author>
		<author>
			<persName><surname>Slut</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<pubPlace>U van Amsterdam, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">AND MICHIE, D Experiments with the graph traverser program</title>
		<author>
			<persName><forename type="first">J</forename><surname>Doran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Royal Soc A</title>
		<imprint>
			<biblScope unit="volume">294</biblScope>
			<biblScope unit="page" from="253" to="259" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Problem-Solwng Methods Ln Artzfictal lntelhgence</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nilsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971">1971</date>
			<publisher>McGraw-Hall</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Bl-dlrectlonal heunsUc search m path problems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Pohl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
			<pubPlace>Stanford U , Stanford, Cahf</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bl-dtrecttonal search</title>
		<author>
			<persName><forename type="first">I</forename><surname>Pohl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine lntelhgence</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="127" to="140" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Look-ahead and one-person games U. of British Columbm</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rosenserg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972">1972</date>
			<pubPlace>Vancouver, Canada</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Planmng m a hierarchy of abstraction spaces</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Sacerdoti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Int. Joint Conf Artlf Intel</title>
		<meeting>Third Int. Joint Conf Artlf Intel<address><addrLine>Stanford, Cahf</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="412" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">RECEIVED AUGUST 1975; REVISED JULY</title>
	</analytic>
	<monogr>
		<title level="j">Journal of the AssoclaUon for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1976">1976. 1977</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
