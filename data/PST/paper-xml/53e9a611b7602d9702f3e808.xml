<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SVL: A SCRIPTING LANGUAGE FOR COMPOSITIONAL VERIFICATION</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hubert</forename><surname>Garavel</surname></persName>
							<email>hubert.garavel@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">INRIA Rhône-Alpes</orgName>
								<address>
									<addrLine>655, avenue de l&apos;Europe</addrLine>
									<postCode>F-38330</postCode>
									<settlement>Montbonnot St. Martin</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frédéric</forename><surname>Lang</surname></persName>
							<email>frederic.lang@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">INRIA Rhône-Alpes</orgName>
								<address>
									<addrLine>655, avenue de l&apos;Europe</addrLine>
									<postCode>F-38330</postCode>
									<settlement>Montbonnot St. Martin</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SVL: A SCRIPTING LANGUAGE FOR COMPOSITIONAL VERIFICATION</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D0698F30B6ADF1C5057E7E4502D5B046</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Abstraction</term>
					<term>Bisimulation</term>
					<term>Compositional Verification</term>
					<term>Concurrency</term>
					<term>Coordination Language</term>
					<term>E-LOTOS</term>
					<term>Enumerative Verification</term>
					<term>Labeled Transition System</term>
					<term>LOTOS</term>
					<term>Model-Checking</term>
					<term>Process Algebra</term>
					<term>Reachability Analysis</term>
					<term>Specification</term>
					<term>Validation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Compositional verification is a way to avoid state explosion for the enumerative verification of complex concurrent systems. Process algebras such as LOTOS are suitable for compositional verification, because of their appropriate parallel composition operators and concurrency semantics. Extending prior work by Krimm and Mounier, this article presents the SVL language, which allows compositional verification of LOTOS descriptions to be performed simply and efficiently. A compiler for SVL has been implemented using an original compiler-generation technique based on the Enhanced LOTOS language. This compiler supports several formats and tools for handling Labeled Transition Systems. It is available as a component of the CADP toolbox and has been applied on various case-studies profitably.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">. I N T R O D U C T I O N</head><p>Enumerative verification (also called reachability analysis or modelchecking) is a popular technique for verifying concurrent systems. Roughly speaking, it is a "brute force" technique, which consists in exploring and checking all states and transitions reachable by a concurrent system. This technique is confronted to the state explosion problem, which occurs when the number of states grows exponentially as the number of concurrent processes in the system increases. To avoid or reduce state explosion, various approaches have been proposed, among which: symbolic verification, on-the-fly verification, partial orders, symmetries, data flow analysis, and compositional verification.</p><p>This article deals with the latter approach (also known as compositional reachability analysis or compositional minimization). This approach assumes that the concurrent system under study can be expressed as a collection of communicating sequential processes, the behaviors of which are modeled as finite state machines or labeled transition systems ( LT Ss, for short). The sequential processes are composed in parallel, either in a flat or hierarchical manner.</p><p>In its simplest form <ref type="bibr">[9,</ref><ref type="bibr">23,</ref><ref type="bibr">27,</ref><ref type="bibr">32,</ref><ref type="bibr">28,</ref><ref type="bibr">29,</ref><ref type="bibr">30]</ref>, compositional verification consists in replacing each sequential process by an abstraction, simpler than the original process but still preserving the properties to be verified on the whole system. Quite often, abstracting a process is done by minimizing its corresponding LTS modulo an appropriate equivalence or preorder relation (e.g., a bisimulation relation, such as strong, branching or observational equivalence). If the system has a hierarchical structure, minimization can also be applied at every intermediate level in the hierarchy. Clearly, this approach is only possible if the parallel composition is "compatible" with LTS minimization: in particular, this is the case with the parallel composition operators of most process algebras, for which bisimulation is a congruence (see <ref type="bibr">[32]</ref> for a discussion on this issue).</p><p>Although this simple form of compositional verification has been applied successfully to some complex systems (e.g., <ref type="bibr">[11,</ref><ref type="bibr">4]</ref> in the case of the LOTOS language <ref type="bibr">[20]</ref>), it may be counter-productive in some other cases: generating the LTS of each process separately may lead to state explosion, whereas the generation of the whole system of concurrent processes might succeed if processes constrain each other when composed in parallel.</p><p>This issue has been addressed by refined compositional verification approaches <ref type="bibr">[15,</ref><ref type="bibr">6,</ref><ref type="bibr">31,</ref><ref type="bibr">7,</ref><ref type="bibr">8,</ref><ref type="bibr">18,</ref><ref type="bibr">22,</ref><ref type="bibr">5,</ref><ref type="bibr">14]</ref>, which allow to generate the LTS of each separate process by taking into account interface constraints (also known as environment constraints or context constraints). These constraints express the behavioral restrictions imposed on each process by synchronization with its neighbor processes. Taking into account the environment of each process allows to eliminate states and transitions that are not reachable in the LTS of the whole system. Depending on the approach, interface constraints can be either written by the user or generated automatically.</p><p>The refined approach to compositional verification has been implemented in two tools, namely the TR A C T A tool [14] and the P R O J E C T O R/ DE S2 AU T tools <ref type="bibr">[22]</ref>. The latter tools are part of the CADP protocol engineering toolbox <ref type="bibr">[10]</ref> and have been applied to in-dustrial case-studies <ref type="bibr">[22,</ref><ref type="bibr">24,</ref><ref type="bibr">19]</ref>. Although positive, these experiments revealed various issues and shortcomings that prevented compositional verification to be used on a larger scale, especially in industrial projects.</p><p>To solve these problems, we designed a scripting language named SVL, which can be seen as a process algebra extended with operations on LTSs, e.g., minimization (also called reduction), abstraction, comparison, deadlock/livelock detection, etc. We implemented a compiler for this language, with the goal of making compositional verification easier for non-experts.</p><p>This article is organized as follows. Section 2 gives a few preliminary definitions. Section 3 briefly presents the principles and limitations of the DES2AUT tool of <ref type="bibr">[22]</ref>. Section 4 defines the syntax and semantics of the SVL language. Section 5 introduces high-level features of SVL, which allow sophisticated strategies for compositional verification. Section 6 describes the implementation of the SVL 2.0 compiler. Finally, Section 7 gives concluding remarks and lists directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">DEFINITIONS</head><p>Labelled Transition Systems are the natural model for action-based specification languages, especially process algebras such as LOTOS <ref type="bibr">[20]</ref>. Formally, an LTS is a tuple M = (S, A, T, s 0 ), where S is the set of states, A the set of actions (or labels ), T ⊆ S x A x S the transition relation, and S 0 ∈ S the initial state. A transition (s, a, s' ) ∈ T indicates that the system can evolve from state s to state s' by performing action a. I n enumerative verification, there are essentially two ways to represent an LTS:</p><p>An explicit LTS is defined in extension, by enumerating all its states and transitions. Practically, there exist several formats to store explicit LTSs in computer files. The CADP verification tool set uses three such formats: AU T, a simple textual format, BCG (Binary Coded Graphs), a compact binary format based upon dedicated compression algorithms, and SE Q, a human-readable format for displaying sequences of transitions produced by verification tools to explain why a given property is not verified. There exist other LTS formats, for instance the Fc2 format used by the FC2 TOOLS [3], with which the CADP tools are interfaced.</p><p>An implicit LTS is defined in comprehension by giving its initial s t a t e s 0 and its successor function succ : S → 2 T defined by succ (s) = { (s, a, s' ) | (s, a, s' ) ∈ T }. A generic representation of implicit LTSs is provided by the language-independent environment OPEN/ CAESAR <ref type="bibr">[13]</ref>  ating the successors of a given state, as well as various data structures (state tables, stacks, etc.), allowing on-the-fly verification algorithms to be implemented concisely. A number of input languages are connected to OPEN /CAESAR , including LOTOS and the EXP formalism of C ADP, which describes implicit LTS s as sets of explicit LTSs combined together using L OTOS parallel composition and hiding operators. Similarly, the FC2 format allows to describe networks of communicating automata, which can be processed by the FC2TOOLS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE DES2AUT TOOL</head><p>D ES2A UT is a tool performing compositional generation of an LTS from a composition expression (called behavior ) written in the DES language <ref type="bibr">[22]</ref>. Given a behavior, the D ES2AUT tool generates and minimizes its LTS compositionally modulo a relation R (e.g., strong or branching bisimulation) specified on the command-line. The DES language is defined by the following grammar, where B, B 0 , B 1 , B 2 are nonterminal symbols denoting behaviors and F, P, G 1 , . . . , Gn are terminal symbols denoting respectively file prefixes, LOTOS process identifiers, and LOTOS gate identifiers:</p><p>(1) (2)</p><p>(3) (4)</p><p>The syntactic constructs above denote:</p><p>(1) an explicit LTS, either contained in a file in AUT ated from an implicit LTS given as an EX P description, an entire (2)</p><p>(3) (4)</p><p>Although the usefulness of the DE S2AU T tool has been established on significant case-studies <ref type="bibr">[22,</ref><ref type="bibr">24,</ref><ref type="bibr">19]</ref>, its applicability is limited by several practical shortcomings:</p><p>It only supports a single verification strategy: for each parallel composition operator, the operands are minimized first, then combined in parallel. Therefore, operands can only be combined two by two according to the evaluation order defined by the algebraic parallel composition operators; it is not possible to combine more than two components simultaneously. In some cases, this leads to state explosions that could be avoided otherwise. In the following example,</p><formula xml:id="formula_0">(User1.aut ⏐ ⏐ ⏐ User2.aut) ⏐ [G ]⏐ Medium.aut</formula><p>generating the interleaved combination of "User1.aut" and " User2.aut " first-independently from "Medium.aut" -is likely to produce a larger state space than if "Medium.aut" was taken into account.</p><p>So far, this problem has been circumvented by using other CADP tools (namely A LDÉBARAN and EXP. OPEN), which allow several LTS s to be combined together using LOTOS parallel composition operators. Practically, this is tedious because the DES and EXP languages accepted by DES 2A UT and ALDÉBARAN -EX P .OPEN , respectively, are incompatible in syntax and semantics, and because many auxiliary D ES and E XP files are needed to describe a compositional verification scenario this way. The problem is even worse as there are often many possible scenarios corresponding to various decompositions of the system into sub-systems, which requires a trial-and-error approach to find the most effective decomposition.</p><p>The D E S 2AUT tool relies on A LDÉBARAN to perform LTS minimization and does not support other bisimulation tools such as BCG _MIN and FC2 TOOLS. Moreover, it only accepts the AUT format, which is much less compact than the B CG format, so that compositional verification often aborts due to a lack of disk space.</p><p>When a compositional verification scenario fails (e.g., if LTS generation, minimization, or parallel composition aborts at some point, because of a lack of memory or disk space, for instance), localizing and understanding the reason of the problem is difficult, as DES2AUT does not provide sufficient debugging information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">. THE SVL LANGUAGE</head><p>To address these problems, we propose a scripting language for compositional verification. This language, named SVL, contains all the features of the DES language, as well as new ones that provide increased flexibility in the verification task.</p><p>To define the abstract syntax of SV L, we first introduce several terminal symbols: F denotes a file prefix, G, G 1 , . . . , G n denote L O T O S gate identifiers, L, L 1 , . . . , L n denote (UNIX-like) regular expressions on labels considered as character strings, and P denotes a LOTOS process identifier. We also introduce the following non-terminal symbols:</p><p>where op denotes an equivalence or preorder relation, par a LOTOS parallel operator, E a file extension, R a bisimulation relation, M an algorithmic method to compute bisimulations ("std" meaning a standard partition refinement algorithm such as Paige-Tarjan or Kanellakis-Smolka, "fly" meaning the Fernandez-Mounier on-the-fly algorithm, and "bdd" meaning an algorithm based on Binary Decision Diagrams), and T a tool.</p><p>The two main non-terminal symbols are S (statements), and B ( behaviors). They are defined by the following grammar, where '[' and ']' delimit optional clauses in the grammar, and where '[' and ']' denote the terminal bracket symbols. An SVL program is a list of statements "S 1 ; . . . ; S n ".</p><formula xml:id="formula_1">(S1) ( S2) ( S3) ( S4) (B1) (B2) (B3) (B4) (B5) (B6) (B7)</formula><p>An SVL behavior denotes either an explicit or an implicit LT S, contrary to the DES language, in which every implicit LTS is immediately converted to an explicit one. Formally, the semantics of a behavior B is given by a denotation function the result of which is either an (explicit or implicit) LTS file, a LOTOS file, a LOTOS process instantiation, or an EXP composition expression (i.e., a set of explicit LTSs combined together with hiding and parallel composition operators). The subscript σ denotes a set of file extensions, which denote all acceptable formats in which the result of should be produced. The value of σ is determined by the context in which B will be used, and namely by the tools that will be applied to B , given that certain tools require certain formats for their inputs and outputs (for instance, the FC 2TOOLS o n l y handle LTSs in the FC 2 format). Hence, format conversions may be required at some places but, for efficiency reasons, should be avoided as much as possible. σ always contains at least an explicit LTS format; if it contains more than one, a preferred LTS format noted pref (σ) is selected in the following preference order: bcg, then aut, then fc2, then s e q. A dedicated type-checking is done on SVL programs, mainly to distinguish between explicit and implicit LT Ss: certain constraints on σ (listed below) must be satisfied, otherwise type-checking errors are reported. The semantics of behaviors is the following: (B1) denotes a behavior contained in a file (or a LOTOS process instantiation). If it is an implicit LTS file (resp., a LOTOS file), then exp or fc2 (resp.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">. META-OPERATIONS</head><p>SVL has so-called meta-operations, which allow various compositional reduction strategies to be written concisely; this has proven to be useful in many case-studies. Meta-operations extend the syntax of S VL behaviors as follows:</p><p>where the attribute A is defined by: Informally, meta-operations have the effect of propagating R M Treductions automatically at various places in the algebraic term B 0 . Depending on the value of A, they have different semantics:</p><p>"leaf" means that an RMT -reduction must be applied to all leaves "F.E" but also to all subterms of B 0 that generate an explicit LTS (i.e., to all abstraction, renaming, hiding, generation, and reduction operators). Leaf reduction is not propagated through generation and reduction operators. Moreover, to maximize the use of the EXP format of CADP and to avoid converting EXP descriptions into explicit L T Ss (unless requested by the user), R M T-reduction is not applied to hiding operators whose operands are parallel compositions of LTSs. "root leaf" is similar to "leaf" except that B 0 itself is also RMTreduced at the top-level. "node" is similar to "leaf" except that R M T-reductions are also applied to all parallel composition operators in the abstract tree of B 0 . This emulates the reduction strategy of the D E S2 AUT tool and is mainly implemented for backward compatibility purpose.</p><p>Formally, "A R reduction using M with T of B " is expanded into ε R M T (B, A) where ε R M T is defined as follows and where the shorthand notation R R M T (B) stands for an R M T-reduction of B :</p><p>After meta-operation expansion, all behaviors containing metaoperations are replaced by simple behaviors (as defined in Section 4). Since the application of ε R M T may create superfluous operations, an optimization function called is applied to the resulting behaviors in order to increase efficiency. For instance, merges nested hiding operators into a single hiding operator. suppresses an RMT -reduction applied to the operand of a hiding (resp. abstraction) operator if the result of this hiding (resp. abstraction) itself is to be reduced modulo the same relation R. Architecture of SVL 2.0</p><formula xml:id="formula_2">also replaces R R M T ( R R ' M ' T ' ( B)) by R R ' M ' T ' ( B )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">. THE SVL 2.0 COMPILER</head><p>A compiler for the SVL language has been implemented within the CADP toolbox. This compiler, named SVL 2.0, includes five phases, as shown in Figure <ref type="figure">1</ref>. It was developed using an original compiler construction technology also used for two other compilers developed by the VASY team of INRIA:</p><p>The lexical analysis, syntax analysis, and abstract tree construction phases (1,100 lines of code) are implemented using the SY N- TAX compiler generator SVL generates a script written in Bourne shell. This script starts by including a set of predefined functions (1,750 lines of Bourne shell), then the SVL statements and expressions are translated into sequences of calls to these functions with suitable parameters.</p><p>In total, the development of SVL 2.0 took about 5 person • month, and totalizes more than 11,000 lines of generated C code. The SVL compiler is designed carefully to ease the verification task. We give five examples of such a careful design:</p><p>When executing a verification scenario, SVL 2.0 produces simultaneously two kinds of output: a high-level, concise execution trace expressed at the abstraction level of the SVL source program, and a low-level log file which lists all the executed shell commands and the output of their execution. This file is very convenient to locate and understand run-time errors.</p><p>During its execution, the generated script produces several temporary files (explicit LTSs, EXP files, hiding and renaming files, etc.) needed by the various tools of CADP. To minimize disk space consumption, SVL removes temporary files as soon as possible and uses as much as possible the BCG format for representing explicit L T Ss, because the BCG format is more compact than other LTS formats.</p><p>Several convenient compiler options are implemented, e.g., "-debug", which prevents intermediate files from being erased, "-expand", which produces the SVL program obtained by expanding all meta-operations, and "-script", which generates the Bourne shell script without executing it.</p><p>As much as possible, the generated script tries to recover from errors automatically by using "expert"' knowledge about the verification process. For instance:</p><p>-When a reduction fails because the combination of relation, tool, and method specified in the source SVL program is not available, SVL 2.0 attempts to change some of the parameters (tool and/or method). For instance, it can replace "std" with "bdd" when using ALDÉBARAN to perform strong reduction of an LTS in the EXP format since standard reduction is not available in this case. -If a weak reduction fails, e.g., because of memory exhaustion, SVL 2.0 tries to perform first stronger reduction(s) before trying again the weak reduction. For instance, observational reduction may be preceded by branching reduction, and branching reduction may be preceded by strong reduction. If the reduction still fails, SVL 2.0 will leave the LT S un-reduced and continue execution.</p><p>-The SVL semantics states that a "generation" operator is mandatory whenever an implicit LTS should be converted to an explicit LTS because such conversion is costly and can lead to state explosion. Practically, this constraint is slightly relaxed: if a "generation" operator is omitted, it will be inserted automatically and a warning message will be emitted.</p><p>SVL 2.0 permits to invoke shell commands from the SVL description. This can be used for calling tools with features not implemented in SV L, for using the shell control structures to perform conditionals and loops, and for modifying the values of environment variables specifying the default tools, methods, and relations as well as options to be passed to the tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>Although compositional verification has a strong potential in attacking the state explosion problem, only a few implementations have been carried out. In this respect, the compositional verification tools of CADP are of particular interest because they are widely distributed and have been applied to several industrial case-studies <ref type="bibr">[4,</ref><ref type="bibr">22,</ref><ref type="bibr">24,</ref><ref type="bibr">19</ref>]. However, these tools require a good level of expertise to be effective. To address this problem, we designed the scripting language SV L, which is welladapted to compositional verification: SVL combines process algebra operators (parallel composition, label hiding) with operations on LTSs (e.g., minimization, abstraction, comparison, livelock/deadlock detection, label hiding and label renaming using regular expressions, etc.). It also provides highlevel meta-operators, which allow sophisticated compositional verification strategies to be expressed concisely. Practically, SVL is expressive enough to supersede the two formats EXP and DES previously used in the CADP toolbox and to suppress the need for hand-written MAKEFILES. SVL behaves as a tool-independent coordination language (in the same way as EUCALYPTUS [12] is a tool-independent graphical user interface). Due to its concise syntax and well-chosen default options, SVL relieves the user from the burden of launching verification tools manually: it invokes the relevant tools with appropriate options and allocates/deletes temporary files automatically. SVL supports several verification tools (ALDÉBARAN , BC G_ MIN, FC2 TOOLS) both for explicit (enumerative) and implicit (on-thefly) verification. It supports several LTS formats (AUT, BCG, FC2, SEQ) though using as much as possible the BCG format, which allows significant savings in both disk space and access time. Switch-changing a few words in the SVL description.</p><p>ing from one tool or one format to another can be done simply by tools and new formats to be integrated easily. Moreover, as Bourne SVL is extensible in two ways. Its modular design will allow new shell commands can be directly invoked from an SVL description, the user can easily describe specific processings and benefit from the high-level constructs of the Bourne shell (if and case conditions, while and for loops, etc.).</p><p>For this language, we have fully implemented the SVL 2.0 compiler which is developed using an original approach to compiler construction, combining the SYNTAX compiler generator and LOTOS NT, a variant of the forthcoming E-LOTOS standard.</p><p>SVL 2.0 has reached a good level of stability and maturity. It is distributed as a component of CADP and available on four different UNIX and WINDOWS platforms. It has been used in ten case-studies profitably, in particular for the compositional verification of a dynamic reconfiguration protocol for agent-based applications <ref type="bibr">[1]</ref>. As regards future work, three directions can be identified:</p><p>SVL could be enhanced with common sub-expressions detection.</p><p>At present, the user can always avoid redundant computations by storing their results in intermediate, named files, which can be reused later. For instance, the statement: can be evaluated more efficiently as:</p><p>Ideally, this optimization could also be performed automatically.</p><p>The SVL language could be enriched with additional operators, e.g., to model-check temporal logic formulas, and additional metaoperators, such as recursive propagation of hiding (so as to hide labels as soon as possible) or recursive abstractions. More applications are needed to determine which extensions are practically useful.</p><p>The SVL language and related tools should be extended to support the new parallel composition operators <ref type="bibr">[17]</ref> introduced in E -LOTOS and LOTOS NT; these operators are more expressive and user-friendly than LOTOS ones and would thus contribute to make compositional verification easier.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>, lotos) must belong to σ If E ∈ σ then returns B else it converts the LTS contained in B to pref ( σ) using BC G_IO or EX P2FC 2. LOTOS process instantiations are handled Similarly as LOTOS files. (B 2) denotes the label hiding of an implicit or explicit LTS using the ALDÉBARAN , BC G_LA B E L S, and EX P.OPEN tools. This generalizes the LOTOS hiding operator by allowing regular expressions on labels. Contrary to the DES language, in which all implicit LTSs are converted into explicit ones before hiding, S VL semantics preserves implicit LT Ss as long as possible (according to the definition of E XP composition expressions). If σ contains exp or fc2 and all labels L 1 , . . . , L n are LOTOS gates and B 0 is a parallel composition of behaviors, then returns the E XP composition expression hide L 1 , . . . , L n in {exp,aut,bcg,fc2,seq} , else returns the conversion to pref (σ) of {bcg} in which labels matching one of L 1, . . . , Ln are hidden. (B 3) denotes the parallel composition of B 1 and B 2 . σ must contain exp or fc2. returns the E XP composition expression par where = {exp, aut, bcg, fc2, seq}. (B4) denotes the label renaming of an explicit LTS using the BC G_LABELS tool, which supports UNIX-like regular expression matching and substring replacement. returns the conversion to pref ( σ ) of {bcg} in which labels are renamed as specified by the rules L 1 → L´1 , . . . , L n → L´n. (B 5) denotes the conversion from an implicit LTS to an explicit one, which is computed using O P E N/ CAESAR compilers and GE N E R A T O R. In SVL, such conversions must be requested explicitly using the "generation" operator, unlike the D ES language in which such conversions are automatic and cannot be avoided. Let α be {exp,fc2,lotos} . If α is already an explicit LTS, then returns α else it returns the conversion of α to an explicit LTS of format pref (σ ). (B6) denotes the reduction of an LTS modulo an equivalence relation R, using an algorithmic method M and a tool T ( A L D É B A R A N, BC G_MI N, or FC 2TO O L S). For short, we abbreviate this operator to RMT-reduction. returns the conversion to format pref ( σ ) of the R M T-reduction of where is the set of the accepted input formats for reduction with tool T. (B7) denotes the abstraction w.r.t. interface constraints, which is computed using O P E N/CAESAR compilers and PR O J E C T O R. returns the conversion to format pref (σ ) of the abstraction of {bcg,exp,fc2,lotos} w.r.t. the interface {aut} . The "user" keyword has the same meaning as the "?" symbol of the DES Language. The statements have the following effects: ( S1) stores in file F.E (where E ≠ lotos ) either if E denotes { E} an explicit LTS format or {aut,bcg,exp,fc2,seq} if E denotes an implicit LTS format. (S2) compares two L T Ss modulo an equivalence or preorder relation R, using an algorithmic method M and a tool T ( ALDÉBARAN or FC2 TOOLS). Formally, it compares and where denotes the set of possible input formats accepted by T. The result stored in file F.E (where E {exp, lotos}) is a (set of) distinguishing path(s) if the comparison returns false or an empty path otherwise. detects deadlocks using a tool T ( ALDÉBARAN , EVALUATOR , EXHIBITOR , or FC2 TOOLS) in where is the set of possible input formats accepted by T. The result stored in file F.E (where E {exp, lotos}) is a (set of) path(s) leading to (one or all) deadlock state(s), if any, or an empty path otherwise. checks for livelocks in a way similar to statement ( S3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>if the relation R´is weaker or equal to the relation R (noted R' R), since an R M T-reduction is useless after an R'M'T' -reduction. At last,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 1.Architecture of SVL 2.0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>[2]. SYNTAX has similar functionalities as LEX and YACC, enhanced with a well-designed automatic error recovery mechanism. Type checking, expansion of meta-operations, and code generation (2,900 lines of code) are implemented as a set of data types and functions written in the LOTOS NT language[16, 26]. Inspired by the standardization work on Enhanced LOTOS [21], LOTOS N T combines the theoretical foundations of process algebras with features borrowed from both functional and imperative languages (such as abstract data types, patterns, assignments, loops, . . . ) suitable for a wider industrial acceptance of formal methods. TheTRAIAN compiler [25]  translates the LOTOS NT code into a set of C types and functions. The generated C code is augmented with about 200 lines of hand-written C code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>embedded in CA D P. OPEN/ CAESAR offers primitives for accessing the initial state of an LTS and for enumer-</figDesc><table><row><cell cols="2">The tools available in C ADP and FC 2 T OOLS allow to perform the</cell></row><row><cell cols="2">usual operations on (explicit or implicit) LTSs in several complementary</cell></row><row><cell cols="2">ways, as summarized in the following table:</cell></row><row><cell>A LDÉBARAN</cell><cell>Reduction, comparison, deadlock/livelock detection</cell></row><row><cell>B CG _ I O</cell><cell>Conversion from one explicit LTS format to another</cell></row><row><cell>B CG_L ABELS</cell><cell>Hiding and renaming of labels</cell></row><row><cell>B CG_M I N</cell><cell>Reduction</cell></row><row><cell>BCG_O PEN</cell><cell>Implicit LT S view of an explicit LTS</cell></row><row><cell>CAESAR.ADT , C AESAR</cell><cell>LT S generation from a LO T O S description</cell></row><row><cell>CAESAR .O PEN</cell><cell>Implicit LT S view of a LOTOS description</cell></row><row><cell>E VALUATOR</cell><cell>Deadlock/livelock detection</cell></row><row><cell>E XHIBITOR</cell><cell>Deadlock detection</cell></row><row><cell>E X P2F C2</cell><cell>Conversion from EX P format to F C 2</cell></row><row><cell>EX P.O P E N</cell><cell>Implicit LT Sview of an EXP description</cell></row><row><cell cols="2">FC 2E XPLICIT, F C 2I MPLICIT Reduction, comparison, deadlock/livelock detection</cell></row><row><cell>GENERATOR</cell><cell>Explicit LTS generation from an implicit LTS</cell></row><row><cell>P ROJECTOR</cell><cell>Abstraction (see Section 3 below)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>O T O S description, or a particular process P defined in a LOTOS description (this process being instantiated with actual gate parameters G 1 , . . . , Gn); the behavior B 0 in which gates G 1 , . . . , G n are hidden using the LO T O S hiding operator; the behaviors B 1 and B 2 executing in parallel with synchronization and communication on gates G 1 , . . . , G n according to the L OTOS parallel composition semantics; the behavior B 1 restricted by synchronizing it on the set of gates G 1 , . . . , G n with B 2 ( B 2 is considered as an automaton, the regular language of which expresses interface constraints); the resulting behavior is called the abstraction of B 1 w.r.t. B</figDesc><table /><note><p>format, or gener-L 2 . The "?" symbol, if present, indicates that the user is unsure that the interface constraints expressed in B 2 are sound w.r.t. the real environment of B 1 : as a consequence, validity checks are performed when the resulting LTS is composed in parallel with other LTSs .</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are also grateful to Ji He (University of Stirling) for her reports about the D E S2AUT tool, to Laurent Mounier (Univ. Joseph Fourier, Grenoble) for his pertinent explanations regarding DES2AUT in particular and compositional verification in general, and to Solofo Ramangalahy, and to the anonymous referees for their useful comments about this paper.</p><p>We would like to thank the former and current members of the I NRIA/VASY team involved in the SVL project, namely: Mark Jorgensen and Christophe Discours, who implemented the early versions (1.0-1.6) of the SVL compiler, Ghassan Chehaibar and Charles Pecheur, who used and gave valuable feedback about the DES2 AUT and SVL 1.* tools, Marc Herbert and Stéphane Martin, who tested the improved CADP tools on several architectures carefully, and Radu Mateescu, who experimented the SVL 2.0 compiler on several case-studies.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>*This work has been partially supported by D Y A D E, the B U L L/IN R I A joint venture for advanced reasearch</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Specification and Verification of a Dynamic Reconfiguration Protocol for Agent-Based Applications</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">; J.-C</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aguilar Cornejo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mateescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Palma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of DAIS&apos;01</title>
		<meeting>of DAIS&apos;01<address><addrLine>Grenoble</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1988">1996. 1988</date>
		</imprint>
	</monogr>
	<note type="report_type">Thèse de Doctorat</note>
	<note>ALDEBARAN : un système de vérification par réduction de processus communicants</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Le système SYNTAX : Manuel d&apos;utilisation et de mise en oeuvre sous Unix</title>
		<author>
			<persName><forename type="first">P</forename><surname>Boullier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Deschamp</surname></persName>
		</author>
		<ptr target="http://www-rocq.inria.fr/oscar/www/syntax" />
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Fc2Tools set: a Toolset for the Verification of Concurrent Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bouali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ressouche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>De Simone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CAV&apos;96</title>
		<title level="s">LNCS</title>
		<meeting>of CAV&apos;96</meeting>
		<imprint>
			<biblScope unit="volume">1102</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Specification and Verification of the PowerScale Bus Arbitration Protocol: An Industrial Experiment with LOTOS</title>
		<author>
			<persName><forename type="first">G</forename><surname>Chehaibar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tawbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zulian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FORTE/PSTV&apos;96. IFIP</title>
		<meeting>of FORTE/PSTV&apos;96. IFIP</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Compositional Analysis of Complex Distributed Systems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Cheung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Hong Kong Univ. of Science and Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Compositional Reachability Analysis of Finite-State Distributed Systems with User-Specified Constraints</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICSE&apos;92</title>
		<title level="s">LNCS</title>
		<editor>
			<persName><forename type="first">J.-C</forename><surname>Fernandez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Rasse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Rodríguez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</editor>
		<meeting>of ICSE&apos;92</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<biblScope unit="volume">1102</biblScope>
		</imprint>
	</monogr>
	<note>Proc. of FSE&apos;93</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Overview of the Eucalyptus Toolbox</title>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int. Workshop on Applied Formal Methods in System Design</title>
		<meeting>of the Int. Workshop on Applied Formal Methods in System Design<address><addrLine>Slovenia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">OPEN/CAESAR: An Open Software Architecture for Verification, Simulation, and Testing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of TACAS&apos;98</title>
		<meeting>of TACAS&apos;98</meeting>
		<imprint>
			<biblScope unit="volume">1384</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Model Checking for Concurrent Software Architectures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Giannakopoulou</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>Imp. College of Science, Technology and Medicine -Univ. of</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName><surname>London</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Compositional Minimization of Finite State Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CAV&apos;90</title>
		<title level="s">LNCS</title>
		<meeting>of CAV&apos;90</meeting>
		<imprint>
			<biblScope unit="volume">531</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Towards a Second Generation of Formal Description Techniques -Rationale for the Design of E-LOTOS</title>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sighireanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FMICS&apos;98. CWI. H. Garavel and M. Sighireanu</title>
		<meeting>of FMICS&apos;98. CWI. H. Garavel and M. Sighireanu</meeting>
		<imprint/>
	</monogr>
	<note>Proc. of FORTE/PSTV&apos;99. IFIP</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">System Design of a CC-NUMA Multiprocessor Architecture using Formal Specification, Model-Checking, Co-Simulation, and Test Generation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lüttgen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Viho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zendri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">; J.-P</forename><surname>Krimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Workshop on Specification and Verification of Concurrent Systems</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Malhotra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Giacalone</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Shapiro</surname></persName>
		</editor>
		<meeting>of the Workshop on Specification and Verification of Concurrent Systems</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1988-05">Sept. 1996. July 2001. September 1988. May 2001. 1988</date>
			<biblScope unit="volume">8807</biblScope>
		</imprint>
		<respStmt>
			<orgName>ISO -Information Processing Systems -OSI</orgName>
		</respStmt>
	</monogr>
	<note>Proc. of ASE&apos;99</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Sighireanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Bouchoux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chaudet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Herbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Vivien</surname></persName>
		</author>
		<ptr target="http://www.inrialpes.fr/vasy/traian" />
		<title level="m">TRAIAN: A Compiler for E-LOTOS/LOTOS NT Specifications</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">LOTOS NT User&apos;s Manual (Version 2.1)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sighireanu</surname></persName>
		</author>
		<ptr target="ftp://ftp.inrialpes.fr/pub/vasy/traian/manual.ps.Z" />
	</analytic>
	<monogr>
		<title level="j">INRIA projet VASY</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Algorithmic Procedure for Checking Safety Properties of Protocols</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Sabnani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Lapone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">U</forename><surname>Uyar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications</title>
		<imprint>
			<date type="published" when="1989-09">Sept. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Hierarchy-Based Incremental Reachability Analysis of Communication Protocols</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Koppol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int. Conf. on Network Protocols</title>
		<meeting>of the Int. Conf. on Network Protocols</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An Incremental Approach to Reachability Analysis of Distributed Programs</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Koppol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int. Workshop on Software Specification and Design</title>
		<meeting>of the Int. Workshop on Software Specification and Design</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Compositional State Space Generation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Valmari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Advances in Petri Nets</title>
		<meeting>of Advances in Petri Nets</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">674</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Compositional Reachability Analysis Using Process Algebra</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Yeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Controlling State Explosion in Reachability Analysis</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Yeh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Young</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993-12">Dec. 1993</date>
		</imprint>
		<respStmt>
			<orgName>Software Engineering Research Center (SERC) Laboratory, Purdue Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
	<note>Proc. of SIGSOFT&apos;91</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
