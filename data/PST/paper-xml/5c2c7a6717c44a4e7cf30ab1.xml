<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Predicting SDC Vulnerability of Instructions Based on Random Forests Algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Liping</forename><surname>Liu</surname></persName>
							<idno type="ORCID">0000-0001-6605-7825</idno>
							<affiliation key="aff0">
								<orgName type="department">Computer Department</orgName>
								<orgName type="institution">Beijing Institute of Technology</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Linlin</forename><surname>Ci</surname></persName>
							<email>cilinlin_bit@126.com</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Department</orgName>
								<orgName type="institution">Beijing Institute of Technology</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Department</orgName>
								<orgName type="institution">Beijing Institute of Technology</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Predicting SDC Vulnerability of Instructions Based on Random Forests Algorithm</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1007/978-3-030-05057-3_44</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Fault tolerance</term>
					<term>Error detection</term>
					<term>Reliability</term>
					<term>SDC vulnerability Random forests</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Silent Data Corruptions (SDCs) is a serious reliability issue in many domains of computer system. Selectively protecting of the program instructions that have a higher SDC vulnerability is one of the research hot spots in computer reliability field at present. A number of algorithms have already been presented to tackle this problem. However, many of them require tens of thousands of fault injection experiments, which are highly time and resource intensive. This paper proposes SDCPredictor, a novel solution that identify the SDC-vulnerable instructions based on random forests algorithm. SDCPredictor are based on static and dynamic features of the program alone, and do not require fault injections to be performed. SDCPredictor selectively protects the most SDCvulnerable instructions in the program subject to a given performance overhead bound. Our experimental results show that SDCPredictor can obtain higher SDC detection efficiency than previous similar techniques.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>SEU-induced soft errors have been known as one of the major threats to functionality and reliability of space-borne computers and their host spacecrafts. Soft errors may be explicit bit flips in latches or memories, or glitches in combinational logics that can propagate and be captured in latches <ref type="bibr" target="#b0">[1]</ref>. SEU could result in silent data corruption (SDC), which means wrong outcomes of a program without any crash detected. When an SDC occurs, the program will fail without any indication of the failure. This can lead to the error propagating in the system and causing catastrophic effects. Thus, with the increase in the number of transistors on a chip and the reduction of chip sizes, the transient fault rate of software will grow with Moore's Law <ref type="bibr" target="#b1">[2]</ref>. Therefore, it is necessary to protect these devices against SDC errors.</p><p>Conventional hardware only solutions such as guard banding and hardware redundancy are challenging to apply due to power constraints. As a result, researchers have explored software-based techniques to tolerate hardware faults <ref type="bibr" target="#b2">[3]</ref>. Softwarebased techniques do not require any modification in the hardware of the microprocessor. In fact, some of these approaches have already been used in mission critical systems for satellites and space missions <ref type="bibr" target="#b3">[4]</ref>.</p><p>Although software-based approaches such as full duplication are more costeffective than the hardware-based ones, they provoke a non-negligible overhead to the programs in terms of execution time and code size. In many cases, this is the main difficulty for the software-based techniques feasibility. In order to reduce these overheads and to offer more exibility to designers, recent works have proposed the selective hardening based on software <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref>.</p><p>Studies have shown that SDCs are caused by errors in a relatively small proportion of programs' data variables <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>, and by selectively protecting these SDC-prone variables, one can achieve high coverage against SDCs. However, most prior work has identified SDC-prone variables using fault injection experiments, which are expensive for large applications.</p><p>Various efforts have been made to refine the injection framework. CriticalFault <ref type="bibr" target="#b9">[10]</ref> applied vulnerability analysis to avoid the injections that result in mask. Since SFI was applied by Relyzer and CriticalFault, the weaknesses of SFI cannot be avoided. Relyzer <ref type="bibr" target="#b10">[11]</ref> ran fault injections for the selected dynamic instruction sequences called "pilots". SymPLIFIED <ref type="bibr" target="#b11">[12]</ref> identified SDC-causing instructions by symbolic execution, which covers all SDCs in real executions. However, it was even more time-consuming than fault injection. Shoestring <ref type="bibr" target="#b12">[13]</ref> assumed that instructions, which impact global memory or produce arguments passed to function calls, can incur SDCs. Although the time cost was reduced, it brought a large number of false positives.</p><p>The work <ref type="bibr" target="#b15">[16]</ref> proposes a configurable protection technique for SDC-causing errors that allows users to trade-off performance for reliability. Two models, namely SDCTune and SDCAuto, are built to predict the SDC proneness of a program's data. SDCAuto is built automatically using a machine learning approach known as the Classification and Regression Tree (CART) algorithm. Compared with fault injection based method, SDCAuto can obtain a relative accurate predicting of the SDC rate of an application and save a lot of time. However, one disadvantage of CART algorithm is that the tree may grow to be biased if some classes of data dominate. Besides, SDCAuto does not consider the data deviation of program output, which is important for some soft computing applications. For example, multimedia applications can tolerate blurry decoded images, and machine learning applications can tolerate noise. Such applications can tolerate most hardware errors as long as the erroneous outputs do not deviate significantly from error-free outcomes. Even instructions in the same application with the same SDC rate may cause different data deviation. It's obvious that the instruction causing more serious data deviation should give priority to be protected.</p><p>We propose a new configurable protection approach, SDCPredictor, to predict the SDC vulnerability of program instructions. Our goal is to find the subset of instructions which are the most SDC-vulnerable against SDC errors for a given performance cost budget. SDCPredictor predicts SDC vulnerability of program instructions based on random forest algorithm. Random forest has an effective method for estimating missing data, and has some mechanisms to deal with unbalanced data sets. SDCPredictor predicts the SDC vulnerability of program instructions by analyzing the features of an instruction, without requiring any fault injections to be performed, thus achieving significant time-saving. Because the parameters of the prediction model is optimized, SDCPredictor has a better prediction speed and accurate than previous methods. The contributions of this work are as follows:</p><p>We develop an intelligent prediction model, SDCPredictor, based on random forests algorithm, which can predict the SDC vulnerability of program instructions precisely. To the best of our knowledge, we are the first to predict the SDC vulnerability of program instructions using random forests. SDCPredictor not only concerns about the probability that a fault in instruction will lead to SDC, but also the severity of SDC. When building the individual tree of random forests, we evaluate its quality to determine whether the tree should be retained or discarded. This screening process improve the predictive power of SDCPredictor. We evaluate the SDC vulnerability prediction accuracy and fault coverage of SDCPredictor on a set of benchmark programs. The experimental results demonstrate that SDCPredictor can obtain higher SDC detection efficiency than previous similar techniques.</p><p>The remainder of the paper is organized as follows. In Sect. 2 the related works on identifying SDC-Causing instructions are reviewed. In Sect. 3 we describe the proposed approach in detail. Section 4 reports the experimental results we gathered and finally in Sect. 5 draws some conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Works</head><p>A variety of efforts have been made to identify and protect SDC-causing instructions. To ensure system robustness, prior work has used statistical fault injection (SFI) to model the soft error rate (SER) of targeted systems.</p><p>CriticalFault <ref type="bibr" target="#b9">[10]</ref> proposes a biased injection framework that employs vulnerability analysis to map out relevant faults for stress testing. However, the remaining faults are still too many to be simulated for accurate SDC rate analysis. Relyzer <ref type="bibr" target="#b10">[11]</ref> systematically analyzes all fault injection sites in an application for transient faults, and employs fault pruning techniques that prune faults that need detailed study by either predicting their outcomes or showing them equivalent to other faults. SmartInjector <ref type="bibr" target="#b11">[12]</ref> firstly lists all possible faults in an application, and then exploits the fault pruning techniques to remove most faults from injections by performing program analysis. SmartInjector also exploits a fault outcome prediction technique to determine the outcome of a simulation before it runs to completion.</p><p>Although SFI has proven to be effective for identifying SDC-causing instructions, it is extremely time-consuming and not unacceptable for large applications.</p><p>Another SDC identifying method is statistical vulnerability analysis. Shoestring <ref type="bibr" target="#b12">[13]</ref> uses a static analysis approach to identify the instructions which are likely to result in SDCs, and employs instruction duplication to protect these instructions. Shoestring only considers the instructions in the backward slices of the instructions which update global variables or the arguments of library calls as the SDC-inducing instructions. The remaining instructions in a program are left unprotected. Although Shoestring only incurs an average performance overhead of 15.8%, the simple heuristic it uses only covers 33.9% of SDCs. SymPLIFIED <ref type="bibr" target="#b13">[14]</ref> identifies SDC-causing instructions by symbolic execution, which covers all SDCs in real executions. However, it is even more time-consuming than fault injection.</p><p>The work <ref type="bibr" target="#b14">[15]</ref> proposes a software-based method to identify and harden the most vulnerable blocks of a program. Using the genetic algorithm (GA), the proposed method takes the dynamic behavior of the programs into consideration to identify the most vulnerable blocks of a program. However, not all the instructions of vulnerable blocks are SDC-causing instructions and should be protected, as they incur high performance overhead when protected.</p><p>In recent years, machine learning based methods are introduced to identify the SDC-causing instructions. The work <ref type="bibr" target="#b15">[16]</ref> proposes a machine learning algorithm based model, namely SDCAuto, to predict the SDC proneness of a program's data. SDCAuto builds the model automatically through a machine learning algorithm, thus requiring little to no effort on the part of the developer. It performs configurable protection against SDC-causing errors in general purpose applications without using fault injections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Proposed Method</head><p>In this Section we will describe the proposed approach in detail. We first define some terms used in this paper, some of which are drawn from work <ref type="bibr" target="#b15">[16]</ref>.</p><p>Dynamic Dependency Graph: A Dynamic Dependency Graph (DDG) is a directed acyclic graph (V, E) that captures the dynamic dependencies among the values produced in the course of program execution, where V is the set of vertexes and E is the set of edges. In a DDG, a vertex v can be a register, a memory address or even a constant value. An edge e records the instruction (i.e., an operation) and links source operand(s) to destination operand(s). Data propagation distance: This is the maximum dynamic distance between the def and use of a value. This is denoted as DisðvÞ. Fanout: The fanout of a node is the set of all immediate successors of the node in the DDG. In terms of values, it is the set of uses of the value represented by the node. The fanout of a node indicates how many nodes are directly impacted by an error in that node. Cover: The cover of a node is the number of nodes from which an error can propagate to a given node before causing a crash. Basic Block: A Basic Block (BB) is a maximal set of ordered non-branching instructions (except in the last instruction) or branch destinations (except in the first instruction) in which the execution always enters at the first instruction and leaves via the last instruction. SDC coverage: The SDC coverage is defined as the fraction of SDC causing errors detected by error detection technology. SDC proneness per instruction: This is the probability that a fault in instruction I leads to an SDC. This is denoted as PðSDCÞ. SDC vulnerability per instruction: This is the SDC vulnerability of instruction I. SDC vulnerability not only concerns about the SDC proneness, but also the data deviation of program output. This is denoted as VðSDCÞ. Dynamic count ratio: This is the ratio of the number of dynamic instances of instruction executed to the total number of dynamic instructions in the program. This is denoted as DðIÞ. SDC impact: The SDC impact is defined as the rate of the number of incorrect program outcome caused by SDC over the total number fault-free program outcome during the execution.</p><p>In this section, we first extract program features of instructions that correlate with highly SDC vulnerability. We then implement fault injection experiments on a small set of benchmark programs to generate training data set for training purposes. Finally, we use training data set to build our models and generate protected code. Figure <ref type="figure" target="#fig_0">1</ref> shows the block diagram of the proposed method. Details of each component are given below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Feature Extraction</head><p>Recent studies show hardware faults are often derated or masked. A hardware-error is said to be derated if it is inherently masked in the system. Different instructions of a program have different error-derating rate <ref type="bibr" target="#b14">[15]</ref>. In other words, different instructions of a program have different SDC vulnerability.</p><p>Fault propagation can be stopped by an instruction either masking the fault, or by crashing the program. Both masking and crashing decrease the probability of an SDC resulting from the instruction that propagates its data to the other crashing/masking instruction, as a result of which its SDC proneness is lower. Our fault injection experiments show that the masking of an error at an instruction I can occur due to the following factors: (1) The error at instruction I may be masked by I itself. ( <ref type="formula" target="#formula_1">2</ref>) The error at instruction I may be masked due to the successor instruction in path p. Faults that occur in the higher bit positions of operands of memory address calculation instructions are more likely to cause the program to crash. Shift instructions, comparison instructions and logical operation instructions can decrease the SDC proneness of the source operands by a certain extent. We call these instructions as SDC-masked instructions.</p><p>Our fault injection experiments show that the SDC proneness of instruction is not equal to its SDC vulnerability. Figure <ref type="figure" target="#fig_1">2</ref> shows an example code based on Blackscholes benchmark from PARSEC benchmarks. In Fig. <ref type="figure" target="#fig_1">2</ref>, the integer variable named numOptions determine the loop time of the two for loops. A fault corrupted the value of variable numOptions in the line 1 cause SDC of six variables; while a fault corrupted the value of variable numOptions in line 11 only cause SDC of one variable. It is obvious that the assignment instruction in line 1 has a higher SDC vulnerability than the assignment instruction in line 11. However, the SDC proneness of the assignment instruction in line 1 is equal to the assignment instruction in line 14. Therefore, the severity of SDC should be consideration in determining the SDC vulnerability of instruction. Features are extracted according to the above analysis and also based on prior work <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref>. In total, 62 features are extracted. We categorize these features of instructions into nine categories shown in Table <ref type="table" target="#tab_0">1</ref>. (1) Data dependency related features. An error occurred in one variable can propagate to multiple variables by data dependencies among the instructions. Variables with a long data propagation distance or large fanout usually have a higher SDC vulnerability. (2) Type of end points of data dependency chains related features. The SDC proneness of a variable depends on (1) the fault propagation in its data dependency chain, and (2) the SDC proneness of the end point of that chain. (3) Memory address calculation related features. Memory address calculation instructions are usually used for pointer dereferences and are likely to cause SDCs and segmentation faults which crash the application. (4) Sub-word operations related features. Sub-word operations only utilize a fraction of the bits in the incoming values. Thus, fault occurred in the not utilized bits will be masked and SDC proneness of the source operands will decrease by a certain extent. (5) Logical operations related features. Logical operations derate errors that occur in AND operations when the corresponding bit in the other operand is 0, as well as OR operations when the corresponding bit in the other operand is 1. (6) Successor instruction related features. If SDC-masked instructions exist in the successor instruction of an instruction I, the SDC proneness of I will be derated. <ref type="bibr" target="#b6">(7)</ref> Code structure related features. SDC causing code tends to be on the hot paths of the application. BBs with a higher in-degree or within a loop usually tend to be on the hot paths. (8) Data width related features. Data width is the number of bits in values, and is a major feature affecting the SDC proneness. (9) Execution time related features. Generally speaking, the instructions with a higher dynamic count ratio (DCR) have a higher SDC proneness. Our experimental results show that those instructions on the long path of DDG usually have a higher SDC vulnerability.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Fault Injection and Training Data Generation</head><p>The goal of fault injection is to create a training set for the machine learning regression mode. The fault injection experiment is conducted using LLFI, a program level fault injection tool, which has been shown to be accurate for measuring SDCs in programs <ref type="bibr" target="#b18">[19]</ref>. LLFI works at the LLVM compiler's intermediate code level <ref type="bibr" target="#b8">[9]</ref>, and allows fault injections to be performed at specific program points, and into specific data types. It also enables tracing the propagation of the fault in the program by instrumenting the program at selected points. LLFI is closely integrated with the LLVM compiler, and can hence support a wide variety of programs.</p><p>We selected a set of 12 benchmarks which are drawn from SPEC benchmarks <ref type="bibr" target="#b19">[20]</ref>, Stanford benchmarks <ref type="bibr" target="#b20">[21]</ref>, Parboil benchmarks <ref type="bibr" target="#b21">[22]</ref> and PARSEC benchmarks <ref type="bibr" target="#b22">[23]</ref>. We divide the 15 applications into two groups; one group for training and the other for testing.</p><p>We choose these benchmarks to represent a wide range of commodity and scientific applications. Tables <ref type="table" target="#tab_2">2 and 3</ref> illustrate the characteristics of the benchmarks. These benchmarks are compiled by LLVM compiler with standard optimization level (−O2). We compile the IR file and feed the produced executable file to LLFI after linking.</p><p>The experiments are carried out on an Intel core i7 based machine, with 8 GB of RAM and 400 GB Hard drive. The machine is running Debian Linux Version 6.0.</p><p>The previous research results show that SDC proneness is highly influenced by data dependencies among the instructions and a considerable number of program instructions have no effect on the program results. In this paper, we use the staticslicing technique <ref type="bibr" target="#b23">[24]</ref> to transform a program to an identical but smaller and simpler executable version. The executable slice of a program is a subset of program instructions that can be executed. First, we run LLFI on each executable slice of program, and select specific instructions as fault injection targets.</p><p>Second, we use statistical fault injection to implement fault injection. We corrupt the instruction's source register by flipping a single bit in it and each bit flips one time. In each run, a fault, i.e., a single bit flip, is injected into the source register of exactly one dynamic instance of an instruction, and the outcome of the fault is classified by comparing the final output with the fault free outcome. The fault-free or baseline outcome is obtained by running the original executable with the same input, but without any injected faults. We classify the outcome into four categories: (1) Crash, meaning that the program threw an exception, (2) SDC, which means the program's output deviated from the fault-free outcome, (3) Hang, which means the program took significantly longer to execute than a fault-free run, and (4) Benign, which means the program completed successfully and its output matched the fault-free outcome. The above outcomes are mutually exclusive and exhaustive.</p><p>Third, the SDC proneness PðSDCÞ of each instruction is gathered and computed by Eq. ( <ref type="formula" target="#formula_0">1</ref>):</p><formula xml:id="formula_0">PðSDCÞ ¼ N SDC N fault Â DðIÞ ð<label>1Þ</label></formula><p>where N SDC is the SDC count caused by instruction I, N fault is the total number of initial faults attributed to the instruction I, DðIÞ is the dynamic count ratio of the instruction I. Meanwhile, we gather and compute the average SDC impact of each instruction by Eq. ( <ref type="formula" target="#formula_1">2</ref>):</p><formula xml:id="formula_1">ImpactðIÞ ¼ 1 N SDC ð X N SDC i¼1 CIO i CO Þ ð<label>2Þ</label></formula><p>where CIO i is the number of incorrect program caused by i-th SDC, CO is the total number of program output during the execution. In this paper, we treat the store operation as program output. Finally, we obtain the SDC vulnerability of instruction I by equation VulnerabilityðIÞ ¼ PðSDCÞ Â ImpactðIÞ. Thus, training data set fF; Cg is generated, where F is the extracted features vector, and C is the annotated class labels (i.e., SDC vulnerability).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Regression Model Training Training Random Regression Forests</head><p>We train the models from a set of training instructions with the above features. The SDC vulnerability of these instructions depends on the extracted features. The full training samples have 8146 training instructions. Based on the 8146 training instructions, a random regression forest is constructed. The random forest is an ensemble learner consisting of a collection of tree-structured base learners. Each base learner is a classification and regression tree (CART), and for regression, each tree individually predicts the target response while the forest predicts the target as the average of the individual tree predictions. Let F¼ff i 2 Rji¼ 1; 2;::: , Ng denote the extracted features, and let C ¼ fc 1 ; c 2 ; . . .; c N g denote the annotated class labels of the training samples (i.e., SDC vulnerability). We build the trees following the random forest framework <ref type="bibr" target="#b24">[25]</ref>. For each tree in the random forest, a subset of samples is randomly chosen by bootstrap from the training samples, while the remaining is used to test the prediction accuracy of the random forest. The random selection of features is done at each node split for building the tree. Typically this setting is ffiffi ffi n p</p><p>, where n is the number of features. In our method the number of features is 8.</p><p>Furthermore, once a tree is built, we evaluate its quality to determine whether the tree should be retained or discarded. Only the trees which have sufficiently high accuracy will be kept. As mentioned above, the bootstrap method is used to randomly choose a subset of samples from the given training samples to construct a tree. These chosen samples are called in-of-bag (IOB) data, while the remainder is called out-ofbag (OOB) data. The OOB data are utilized to evaluate the tree constructed based on the IOB data. Given a tree regressor h k ðxÞ built from the kth training data subset, we define the mean square error (denoted by MSE) of the tree h k ðxÞ as</p><formula xml:id="formula_2">MSE ¼ P NÀN s i¼1 ðh k ðx i Þ À C i Þ 2 N À N s<label>ð3Þ</label></formula><p>where x i is a sample in the OOB data and C i is the class label of the sample x i . It is obvious that the tree with low MSE has high accuracy. Hence, we accept a tree whose MSE on the OOB data is below the prespecified threshold. In this way, the trees constructed in the forest are all with lower MSE, and a better random forest can be obtained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Choose the Instructions to Protect and Design Detector</head><p>After predicting the SDC vulnerability for each instruction, we then choose instructions to minimize the SDC impact subject to a given performance overhead, using a standard dynamic programming algorithm <ref type="bibr" target="#b26">[27]</ref>. Once we identify a set of instructions to protect, the next step is to insert error detectors at these instructions. Our detectors are based on duplicating the backward slices of the instructions to protect, similar to prior work <ref type="bibr" target="#b15">[16]</ref>.</p><p>We insert a check immediately after the instructions to be protected, which compares the original value computed by the instruction with the value computed by the duplicated instructions. Any difference in these values is deemed to be error detection and the program is stopped.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Evaluation</head><p>SDC vulnerability accuracy, SDC coverage, SDC detection efficiency and SDC impact are imperative parameters for evaluating our approach. So all of these parameters are measured and reported.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">SDC Vulnerability Accuracy</head><p>There are primarily 3 parameters which can be tuned to improve the predictive power of the random regression forests model: (1) maximum number of features in individual tree, and (2) number of trees, and (3) minimum sample leaf size of an individual tree.</p><p>We set the value of first parameter as ffiffi ffi n p , where n is the total number of features. As for the number of trees, we gradually increased it from 150 with a step-size 5 until the prediction accuracy becomes stable or decreasing. Finally, this value is determined to be 285. There are primarily 3 parameters which can be tuned to improve the predictive power of the random regression forests model: (1) maximum number of features in individual tree, and (2) number of trees, and (3) minimum sample leaf size of an individual tree. We set the value of first parameter as ffiffi ffi n p , where n is the total number of features. As for the number of trees, we gradually increased it from 150 with a step-size 5 until the prediction accuracy becomes stable or decreasing. Finally, this value is determined to be 285.</p><p>In order to avoid over-fitting problem, we set the third parameter as 50. To evaluate the predicting results of SDC vulnerability for each instruction, we calculate the average squared errors for testing dataset and the accuracy (the percentage of the samples whose SDC vulnerability estimation error is less than 10%) of SDC vulnerability estimation.</p><p>Table <ref type="table" target="#tab_3">4</ref> shows the accuracy and MSE of SDC vulnerability on the four testing benchmarks. It can be observed that our models are highly accurate in predicting the SDCs vulnerability. The high accuracy benefits from that we strengthen the generalization error of a tree by choosing features according to their weights when building the tree of random forests. Besides, the SDC vulnerability of testing programs is closely to real probability because we use statistical fault injection method to implement fault injection. In addition, we optimize the parameters of the random forests which improve the prediction accuracy.</p><p>Thus, it can guide detector placement to obtain high coverage at low performance overheads. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">SDC Impact</head><p>The SDC impact is defined as the rate of the number of incorrect program outcome caused by SDC over the total number fault-free program outcome during the execution. We apply our approach to predict the SDC vulnerability for different instructions to satisfy the performance overhead bounds provided by the user. Figure <ref type="figure">3</ref> shows the SDC impact obtained by our approach (SCDPredictor) and SDCAuto for each benchmark under three different performance overhead bounds: 20%, 40% and 60%. As it can be seen in Fig. <ref type="figure">3</ref>, the averages SDC impact for SCDPredictor and SDCAuto are 74.70% and 79.31% respectively for the 20% performance overhead bound, the corresponding averages SDC impact are 59.20% and 66.30% for the 40% performance overhead bound, and 39.81% and 42.50% for the 60% performance overhead bound. It is obvious that the SCDPredictor obtains lower SDC impact at the same performance overhead bound than SDCAuto. The reason is that SCDPredictor is SDC impact sensitive. It not only concerns about the SDC proneness, but also the SDC impact of program instructions. SCDPredictor protects instructions with high SDC proneness and high SDC impact. While SDCAuto only concerns about the SDC proneness and ignore the SDC severity of instructions. Besides, the prediction model of SDCAuto is built using CART. It is well known that the tree of CART is easy to be biased. It is hard to keep robust and stable prediction accuracy for CART. Unlike SDCAuto, the prediction model of SCDPredictor is built using random forests, which hardly cause over-fitting and are less sensitive to noisy due to it constructs a series of tree-based learners. Thus, SCDPredictor can offer more stable and accurate prediction performance than SDCAuto.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">SDC Coverage and Detection Efficiency</head><p>The SDC coverage is defined as the fraction of SDC causing errors detected by our detectors. Figure <ref type="figure">4</ref> shows the SDC coverage obtained by our approach and SDCAuto for each benchmark under three different performance overhead bounds: 20%, 40% and 60%. As it can be seen in Fig. <ref type="figure">4</ref>, the averages SDC coverage for SCDPredictor and SDCAuto are 33.08% and 38.10% respectively for the 20% performance overhead bound, the corresponding averages SDC coverage are 50.30% and 51.90% for the 40% performance overhead bound, and 66.10% and 65.76% for the 60% performance overhead bound. As mentioned before, SDC coverage, SDC detection efficiency and SDC impact are imperative parameters for evaluating our approach. In literature <ref type="bibr" target="#b15">[16]</ref>, the SDC detection efficiency (DE) is defined as the ratio between SDC coverage and performance overhead. However, the SDC impact is not taken into account. We redefined the SDC detection efficiency; the new definition of SDC detection efficiency is showed in Eq. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SDC detection efficiency ¼ SDC coverage Â ð1 À SDC impactÞ performance overhead ð4Þ</head><p>The averages SDC detection efficiency for SCDPredictor and SDCAuto are 0.418 and 0.394 respectively for the 20% performance overhead bound, the corresponding averages SDC detection efficiency are 0.513 and 0.438 for the 40% performance overhead bound, and 0.663 and 0.630 for the 60% performance overhead bound. Thus, SCDPredictor is comparable in the SDC coverage obtained with SDCAuto. Meanwhile it has a higher SDC detection efficiency because of lower SDC impact compared with SDCAuto.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions and Future Research</head><p>In this article, a random forests based SDC-vulnerable instructions identifying technique SCDPredictor is proposed. SDCPredictor not only concerns about the probability that a fault in instruction will lead to SDC, but also the severity of SDC. The proposed solution does not require fault injections to predict the SDC vulnerability of each instruction. The experimental results demonstrate that SDCPredictor can obtain higher detection efficiency than previous similar techniques.</p><p>Research is underway to develop more excellent methods to improve fault coverage and reduce performance overhead. Invariant based techniques typically have lower overhead than duplication-based techniques as the assertions consist of much fewer instructions than the entire backward slice of the variables; therefore development of invariant based techniques is the new research topic for our research group.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Block diagram of the proposed method</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Example code of Blackscholes benchmark</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>Fig. 3. The comparison of SDC impact under different performance overhead bounds: 20%, 40% and 60%</figDesc><graphic url="image-3.png" coords="13,64.46,59.53,324.62,216.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Some features extracted for model building.</figDesc><table><row><cell></cell><cell cols="2">Predicting SDC Vulnerability of Instructions</cell></row><row><cell>Feature group</cell><cell>Feature</cell><cell>Description</cell></row><row><cell>Data dependency related</cell><cell>destination_operand_fanout</cell><cell>the fanout of destination</cell></row><row><cell>features</cell><cell></cell><cell>operand</cell></row><row><cell></cell><cell>destination_operand_cover</cell><cell>the cover of destination</cell></row><row><cell></cell><cell></cell><cell>operand</cell></row><row><cell>Type of end points of data</cell><cell>is_stroe</cell><cell>whether the operation is used</cell></row><row><cell>dependency chains related</cell><cell></cell><cell>to write to memory</cell></row><row><cell>features</cell><cell>is_function_call</cell><cell>whether the operation is a</cell></row><row><cell></cell><cell></cell><cell>function-call operation</cell></row><row><cell></cell><cell>is_cmp</cell><cell>whether the comparison is</cell></row><row><cell></cell><cell></cell><cell>made between primitive data</cell></row><row><cell>Memory access and</cell><cell>is_load</cell><cell>whether the operation is used</cell></row><row><cell>addressing related features</cell><cell></cell><cell>to read from memory</cell></row><row><cell></cell><cell>is_memory_addressing</cell><cell>whether the operation is a</cell></row><row><cell></cell><cell></cell><cell>memory addressing operation</cell></row><row><cell>Sub-word operations</cell><cell>is_shl</cell><cell>whether the operation is a shift</cell></row><row><cell>related features</cell><cell></cell><cell>left operation</cell></row><row><cell></cell><cell>is_lshr</cell><cell>whether the operation is a</cell></row><row><cell></cell><cell></cell><cell>logicalshift right operation</cell></row><row><cell></cell><cell>is_ashr</cell><cell>whether the operation is a</cell></row><row><cell></cell><cell></cell><cell>arithmetic shift right operation</cell></row><row><cell>Logical operations related</cell><cell>is_and</cell><cell>whether the operation is a logic</cell></row><row><cell>features</cell><cell></cell><cell>"and" operation</cell></row><row><cell></cell><cell>is_or</cell><cell>whether the operation is a logic</cell></row><row><cell></cell><cell></cell><cell>"or" operation</cell></row><row><cell>Successor instruction</cell><cell>shl_instructions_count</cell><cell>the number of left shift</cell></row><row><cell>related features</cell><cell></cell><cell>instructions contained in</cell></row><row><cell></cell><cell></cell><cell>successor instruction</cell></row><row><cell></cell><cell>shr_instructions_count</cell><cell>the number of right shift</cell></row><row><cell></cell><cell></cell><cell>instructions contained in</cell></row><row><cell></cell><cell></cell><cell>successor instruction</cell></row><row><cell>Code structure related</cell><cell>number_of_pred _BBs</cell><cell>number of predecessor BBs</cell></row><row><cell>features</cell><cell>number_of_suc _BBs</cell><cell>number of successor BBs</cell></row><row><cell></cell><cell>is_within_loop</cell><cell>basic blocks is within a loop</cell></row><row><cell></cell><cell>is_loop_terminator</cell><cell>whether the result can break a</cell></row><row><cell></cell><cell></cell><cell>loop execution</cell></row><row><cell></cell><cell>is_accumulative_computation</cell><cell>whether the operation is a</cell></row><row><cell></cell><cell></cell><cell>accumulative-computation</cell></row><row><cell></cell><cell></cell><cell>operation</cell></row><row><cell cols="2">Data width related features data_width_Source _operand</cell><cell>the data width of source</cell></row><row><cell></cell><cell></cell><cell>operand</cell></row><row><cell></cell><cell cols="2">data_width_destination_operand the data width of destination</cell></row><row><cell></cell><cell></cell><cell>operand</cell></row><row><cell>Execution time related</cell><cell>dynamic_count_ratio</cell><cell>dynamic count ratio</cell></row><row><cell>features</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Characteristics of the training benchmarks</figDesc><table><row><cell>Program</cell><cell>Description</cell><cell>Benchmark suite</cell></row><row><cell>Bzip2</cell><cell>File compression and decompression program</cell><cell>SPEC benchmarks</cell></row><row><cell>Perlbench</cell><cell>SPEC benchmark for perl interpreter</cell><cell>SPEC benchmarks</cell></row><row><cell cols="2">Blackscholes Financial Analysis</cell><cell>PARSEC benchmarks</cell></row><row><cell>Swaptions</cell><cell>Price portfolio of swaptions</cell><cell>PARSEC benchmarks</cell></row><row><cell>TSP</cell><cell>Solving the classic TSP problem</cell><cell>Stanford benchmarks</cell></row><row><cell>Qsort</cell><cell cols="2">Sorting the a list of random numbers by quick-sort Stanford benchmarks</cell></row><row><cell>BFS</cell><cell>Breadth-First Search</cell><cell>Parboil benchmarks</cell></row><row><cell>LBM</cell><cell>Fluid dynamics</cell><cell>Parboil benchmarks</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 .</head><label>3</label><figDesc>Characteristics of the testing benchmarks</figDesc><table><row><cell cols="2">Program Description</cell><cell>Benchmark suite</cell></row><row><cell>Gzip</cell><cell>Compression</cell><cell>SPEC benchmarks</cell></row><row><cell>Ferret</cell><cell>Similarity Search</cell><cell>PARSEC benchmarks</cell></row><row><cell cols="3">Queens Solving the classic n-queens problem Stanford benchmarks</cell></row><row><cell>MM</cell><cell>Dense Matrix-Matrix Multiply</cell><cell>Parboil benchmarks</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 .</head><label>4</label><figDesc>The MSE and accuracy of the testing programs</figDesc><table><row><cell cols="2">Program MSE</cell><cell>Accuracy</cell></row><row><cell>Gzip</cell><cell cols="2">0.00549 88.76%</cell></row><row><cell>Ferret</cell><cell cols="2">0.00247 94.56%</cell></row><row><cell cols="3">Queens 0.00178 95.28%</cell></row><row><cell>MM</cell><cell cols="2">0.00428 90.13%</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0">Predicting SDC Vulnerability of Instructions</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="596" xml:id="foot_1">L. Liu et al.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="602" xml:id="foot_2">L. Liu et al.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgment. This research was supported by the National Natural Science Foundation of China under grant No. 61370134, the National High Technology Research and Development Program of China (863 Program) under grant No. 2013AA013901.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">RADJAM: a novel approach for reduction of soft errors in logic circuits</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bhattacharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ranganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on VlSI Design</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="453" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Perturbation-based fault screening</title>
		<author>
			<persName><forename type="first">P</forename><surname>Racunas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Constantinides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Manne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE, International Symposium on High PERFORMANCE Computer Architecture</title>
				<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Configurable detection of SDC-causing errors in programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Embed. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">88</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Selective SWIFT-R: a flexible software-based technique for soft error mitigation in low-cost embedded systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Restrepocalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Martnezlvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cuencaasensi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Electron. Test</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="825" to="838" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Chielle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Azambuja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Barth</surname></persName>
		</author>
		<title level="m">Evaluating selective redundancy in data-flow software-based techniques. Radiation and ITS Effects on Components and Systems</title>
				<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Assuring application-level correctness against soft errors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gururaj</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="150" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient fault tolerance in multi-media applications through selective instruction replication</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aakel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lockhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Workshop on Radiation Effects and Fault Tolerance in Nanometer Technologies</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="339" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Low-cost program-level detectors for reducing silent data corruptions</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K S</forename><surname>Hari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Naeimi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/IFIP International Conference on Dependable Systems and Networks</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Error detector placement for soft computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pattabiraman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/IFIP International Conference on Dependable Systems and Networks</title>
				<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Understanding soft error propagation using efficient vulnerability-driven fault injection</title>
	</analytic>
	<monogr>
		<title level="m">IEEE/IFIP International Conference on Dependable Systems and Networks</title>
				<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Relyzer: application resiliency analyzer for transient faults</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K S</forename><surname>Hari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Naeimi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="58" to="66" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">SmartInjector: exploiting intelligent fault injection for SDC rate analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Defect and Fault Tolerance in VLSI and Nanotechnology Systems</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="236" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Shoestring: probabilistic soft error reliability on the cheap</title>
		<author>
			<persName><forename type="first">S</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ansari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="385" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SymPLFIED: symbolic programlevel fault injection and error detection framework</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pattabiraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Nakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">T</forename><surname>Kalbarczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2292" to="2307" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An efficient vulnerability-driven method for hardening a program against soft-error using genetic algorithm</title>
		<author>
			<persName><forename type="first">B</forename><surname>Arasteh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bouyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pirahesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Electr. Eng</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="25" to="43" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Configurable detection of SDC-causing errors in programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Embed. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">88</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A characterization of instruction-level error derating and its implications for error detection</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zilles</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="482" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">IPAS: intelligent protection against silent output corruption in scientific applications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Laguna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Richards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Symposium on Code Generation and Optimization</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="227" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Quantifying the accuracy of high-level fault injection techniques for hardware faults</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/IFIP International Conference on Dependable Systems and Networks</title>
				<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="375" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SPEC CPU2006 benchmark descriptions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Henning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fault injection techniques and tools</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Hsueh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">K</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="75" to="82" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Parboil: a revised benchmark suite for scientific and commercial throughput computing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Stratton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Sung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The PARSEC benchmark suite: characterization and architectural implications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bienia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Parallel Architectures and Compilation Techniques</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="72" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Program slicing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng. SE</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="352" to="357" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Random forests</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mach. Learn</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="32" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Feature weighting random forest for detection of hidden web search interfaces</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Deng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Linguist. Chin. Lang. Process</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="387" to="404" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Knapsack problems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Martello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990-11">Nov 1990</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
