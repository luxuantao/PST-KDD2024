<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorand: Scaling Byzantine Agreements for Cryptocurrencies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yossi</forename><surname>Gilad</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Rotem</forename><surname>Hemo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Georgios</forename><surname>Vlachos</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mit</forename><surname>Csail</surname></persName>
						</author>
						<title level="a" type="main">Algorand: Scaling Byzantine Agreements for Cryptocurrencies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F8DA02035470100A6B3D3B45CEC8D42A</idno>
					<idno type="DOI">10.1145/3132747.3132757</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Algorand is a new cryptocurrency that confirms transactions with latency on the order of a minute while scaling to many users. Algorand ensures that users never have divergent views of confirmed transactions, even if some of the users are malicious and the network is temporarily partitioned. In contrast, existing cryptocurrencies allow for temporary forks and therefore require a long time, on the order of an hour, to confirm transactions with high confidence.</p><p>Algorand uses a new Byzantine Agreement (BA) protocol to reach consensus among users on the next set of transactions. To scale the consensus to many users, Algorand uses a novel mechanism based on Verifiable Random Functions that allows users to privately check whether they are selected to participate in the BA to agree on the next set of transactions, and to include a proof of their selection in their network messages. In Algorand's BA protocol, users do not keep any private state except for their private keys, which allows Algorand to replace participants immediately after they send a message. This mitigates targeted attacks on chosen participants after their identity is revealed.</p><p>We implement Algorand and evaluate its performance on 1,000 EC2 virtual machines, simulating up to 500,000 users. Experimental results show that Algorand confirms transactions in under a minute, achieves 125× Bitcoin's throughput, and incurs almost no penalty for scaling to more users.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Cryptographic currencies such as Bitcoin can enable new applications, such as smart contracts <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b49">50]</ref> and fair protocols <ref type="bibr" target="#b1">[2]</ref>, can simplify currency conversions <ref type="bibr" target="#b11">[12]</ref>, and can avoid trusted centralized authorities that regulate transactions. However, current proposals suffer from a trade-off between latency and confidence in a transaction. For example, achieving a high confidence that a transaction has been confirmed in Bitcoin requires about an hour long wait <ref type="bibr" target="#b6">[7]</ref>. On the other hand, applications that require low latency cannot be certain that their transaction will be confirmed, and must trust the payer to not double-spend <ref type="bibr" target="#b45">[46]</ref>. Double-spending is the core problem faced by any cryptocurrency, where an adversary holding $1 gives his $1 to two different users. Cryptocurrencies prevent double-spending by reaching consensus on an ordered log ("blockchain") of transactions. Reaching consensus is difficult because of the open setting: since anyone can participate, an adversary can create an arbitrary number of pseudonyms ("Sybils") <ref type="bibr" target="#b20">[21]</ref>, making it infeasible to rely on traditional consensus protocols <ref type="bibr" target="#b14">[15]</ref> that require a fraction of honest users.</p><p>Bitcoin <ref type="bibr" target="#b41">[42]</ref> and other cryptocurrencies <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b53">54]</ref> address this problem using proof-of-work (PoW), where users must repeatedly compute hashes to grow the blockchain, and the longest chain is considered authoritative. PoW ensures that an adversary does not gain any advantage by creating pseudonyms. However, PoW allows the possibility of forks, where two different blockchains have the same length, and neither one supersedes the other. Mitigating forks requires two unfortunate sacrifices: the time to grow the chain by one block must be reasonably high (e.g., 10 minutes in Bitcoin), and applications must wait for several blocks in order to ensure their transaction remains on the authoritative chain (6 blocks are recommended in Bitcoin <ref type="bibr" target="#b6">[7]</ref>). The result is that it takes about an hour to confirm a transaction in Bitcoin. This paper presents Algorand, a new cryptocurrency designed to confirm transactions on the order of one minute. The core of Algorand uses a Byzantine agreement protocol called BA⋆ that scales to many users, which allows Algorand to reach consensus on a new block with low latency and without the possibility of forks. A key technique that makes BA⋆ suitable for Algorand is the use of verifiable random functions (VRFs) <ref type="bibr" target="#b38">[39]</ref> to randomly select users in a private and non-interactive way. BA⋆ was previously presented at a workshop at a high level <ref type="bibr" target="#b37">[38]</ref>, and a technical report by Chen and Micali <ref type="bibr" target="#b15">[16]</ref> described an earlier version of Algorand.</p><p>Algorand faces three challenges. First, Algorand must avoid Sybil attacks, where an adversary creates many pseudonyms to influence the Byzantine agreement protocol. Second, BA⋆ must scale to millions of users, which is far higher than the scale at which state-of-the-art Byzantine agreement protocols operate. Finally, Algorand must be re-silient to denial-of-service attacks, and continue to operate even if an adversary disconnects some of the users <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b51">52]</ref>.</p><p>Algorand addresses these challenges using several techniques, as follows.</p><p>Weighted users. To prevent Sybil attacks, Algorand assigns a weight to each user. BA⋆ is designed to guarantee consensus as long as a weighted fraction (a constant greater than 2/3) of the users are honest. In Algorand, we weigh users based on the money in their account. Thus, as long as more than some fraction (over 2/3) of the money is owned by honest users, Algorand can avoid forks and double-spending.</p><p>Consensus by committee. BA⋆ achieves scalability by choosing a committee-a small set of representatives randomly selected from the total set of users-to run each step of its protocol. All other users observe the protocol messages, which allows them to learn the agreed-upon block. BA⋆ chooses committee members randomly among all users based on the users' weights. This allows Algorand to ensure that a sufficient fraction of committee members are honest. However, relying on a committee creates the possibility of targeted attacks against the chosen committee members.</p><p>Cryptographic sortition. To prevent an adversary from targeting committee members, BA⋆ selects committee members in a private and non-interactive way. This means that every user in the system can independently determine if they are chosen to be on the committee, by computing a function (a VRF <ref type="bibr" target="#b38">[39]</ref>) of their private key and public information from the blockchain. If the function indicates that the user is chosen, it returns a short string that proves this user's committee membership to other users, which the user can include in his network messages. Since membership selection is non-interactive, an adversary does not know which user to target until that user starts participating in BA⋆.</p><p>Participant replacement. Finally, an adversary may target a committee member once that member sends a message in BA⋆. BA⋆ mitigates this attack by requiring committee members to speak just once. Thus, once a committee member sends his message (exposing his identity to an adversary), the committee member becomes irrelevant to BA⋆. BA⋆ achieves this property by avoiding any private state (except for the user's private key), which makes all users equally capable of participating, and by electing new committee members for each step of the Byzantine agreement protocol.</p><p>We implement a prototype of Algorand and BA⋆, and use it to empirically evaluate Algorand's performance. Experimental results running on 1,000 Amazon EC2 VMs demonstrate that Algorand can confirm a 1 MByte block of transactions in ∼22 seconds with 50,000 users, that Algorand's latency remains nearly constant when scaling to half a million users, that Algorand achieves 125× the transaction throughput of Bitcoin, and that Algorand achieves acceptable latency even in the presence of actively malicious users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Proof-of-work. Bitcoin <ref type="bibr" target="#b41">[42]</ref>, the predominant cryptocurrency, uses proof-of-work to ensure that everyone agrees on the set of approved transactions; this approach is often called "Nakamoto consensus. " Bitcoin must balance the length of time to compute a new block with the possibility of wasted work <ref type="bibr" target="#b41">[42]</ref>, and sets parameters to generate a new block every 10 minutes on average. Nonetheless, due to the possibility of forks, it is widely suggested that users wait for the blockchain to grow by at least six blocks before considering their transaction to be confirmed <ref type="bibr" target="#b6">[7]</ref>. This means transactions in Bitcoin take on the order of an hour to be confirmed. Many follow-on cryptocurrencies adopt Bitcoin's proof-of-work approach and inherit its limitations. The possibility of forks also makes it difficult for new users to bootstrap securely: an adversary that isolates the user's network can convince the user to use a particular fork of the blockchain <ref type="bibr" target="#b28">[29]</ref>.</p><p>By relying on Byzantine agreement, Algorand eliminates the possibility of forks, and avoids the need to reason about mining strategies <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b46">47]</ref>. As a result, transactions are confirmed on the order of a minute. To make the Byzantine agreement robust to Sybil attacks, Algorand associates weights with users according to the money they hold. Other techniques have been proposed in the past to resist Sybil attacks in Byzantine-agreement-based cryptocurrencies, including having participants submit security deposits and punishing those who deviate from the protocol <ref type="bibr" target="#b12">[13]</ref>.</p><p>Byzantine consensus. Byzantine agreement protocols have been used to replicate a service across a small group of servers, such as in PBFT <ref type="bibr" target="#b14">[15]</ref>. Follow-on work has shown how to make Byzantine fault tolerance perform well and scale to dozens of servers <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b33">34]</ref>. One downside of Byzantine fault tolerance protocols used in this setting is that they require a fixed set of servers to be determined ahead of time; allowing anyone to join the set of servers would open up the protocols to Sybil attacks. These protocols also do not scale to the large number of users targeted by Algorand. BA⋆ is a Byzantine consensus protocol that does not rely on a fixed set of servers, which avoids the possibility of targeted attacks on well-known servers. By weighing users according to their currency balance, BA⋆ allows users to join the cryptocurrency without risking Sybil attacks, as long as the fraction of the money held by honest users is at least a constant greater than 2/3. BA⋆'s design also allows it to scale to many users (e.g., 500,000 shown in our evaluation) using VRFs to fairly select a random committee.</p><p>Most Byzantine consensus protocols require more than 2/3 of servers to be honest, and Algorand's BA⋆ inherits this limitation (in the form of 2/3 of the money being held by honest users). BFT2F <ref type="bibr" target="#b35">[36]</ref> shows that it is possible to achieve "fork * -consensus" with just over half of the servers being honest, but fork * -consensus would allow an adversary to double-spend on the two forked blockchains, which Algorand avoids.</p><p>Honey Badger <ref type="bibr" target="#b39">[40]</ref> demonstrated how Byzantine fault tolerance can be used to build a cryptocurrency. Specifically, Honey Badger designates a set of servers to be in charge of reaching consensus on the set of approved transactions. This allows Honey Badger to reach consensus within 5 minutes and achieve a throughput of 200 KBytes/sec of data appended to the ledger using 10 MByte blocks and 104 participating servers. One downside of this design is that the cryptocurrency is no longer decentralized; there are a fixed set of servers chosen when the system is first configured. Fixed servers are also problematic in terms of targeted attacks that either compromise the servers or disconnect them from the network. Algorand achieves better performance (confirming transactions in about a minute, reaching similar throughput) without having to choose a fixed set of servers ahead of time.</p><p>Bitcoin-NG <ref type="bibr" target="#b25">[26]</ref> suggests using the Nakamoto consensus to elect a leader, and then have that leader publish blocks of transactions, resulting in an order of magnitude of improvement in latency of confirming transactions over Bitcoin. Hybrid consensus <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b42">43]</ref> refines the approach of using the Nakamoto consensus to periodically select a group of participants (e.g., every day), and runs a Byzantine agreement between selected participants to confirm transactions until new servers are selected. This allows improving performance over standard Nakamoto consensus (e.g., Bitcoin); for example, ByzCoin <ref type="bibr" target="#b32">[33]</ref> provides a latency of about 35 seconds and a throughput of 230 KBytes/sec of data appended to the ledger with an 8 MByte block size and 1000 participants in the Byzantine agreement. Although Hybrid consensus makes the set of Byzantine servers dynamic, it opens up the possibility of forks, due to the use of proof-of-work consensus to agree on the set of servers; this problem cannot arise in Algorand.</p><p>Pass and Shi's paper <ref type="bibr" target="#b42">[43]</ref> acknowledges that the Hybrid consensus design is secure only with respect to a "mildly adaptive" adversary that cannot compromise the selected servers within a day (the participant selection interval), and explicitly calls out the open problem of handling fully adaptive adversaries. Algorand's BA⋆ explicitly addresses this open problem by immediately replacing any chosen committee members. As a result, Algorand is not susceptible to either targeted compromises or targeted DoS attacks.</p><p>Stellar <ref type="bibr" target="#b36">[37]</ref> takes an alternative approach to using Byzantine consensus in a cryptocurrency, where each user can trust quorums of other users, forming a trust hierarchy. Consistency is ensured as long as all transactions share at least one transitively trusted quorum of users, and sufficiently many of these users are honest. Algorand avoids this assumption, which means that users do not have to make complex trust decisions when configuring their client software.</p><p>Proof of stake. Algorand assigns weights to users proportionally to the monetary value they have in the system, inspired by proof-of-stake approaches, suggested as an alternative or enhancement to proof-of-work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10]</ref>. There is a key difference, however, between Algorand using monetary value as weights and many proof-of-stake cryptocurrencies. In many proof-of-stake cryptocurrencies, a malicious leader (who assembles a new block) can create a fork in the network, but if caught (e.g., since two versions of the new block are signed with his key), the leader loses his money. The weights in Algorand, however, are only to ensure that the attacker cannot amplify his power by using pseudonyms; as long as the attacker controls less than 1/3 of the monetary value, Algorand can guarantee that the probability for forks is negligible. Algorand may be extended to "detect and punish" malicious users, but this is not required to prevent forks or double spending.</p><p>Proof-of-stake avoids the computational overhead of proof-of-work and therefore allows reducing transaction confirmation time. However, realizing proof-of-stake in practice is challenging <ref type="bibr" target="#b3">[4]</ref>. Since no work is involved in generating blocks, a malicious leader can announce one block, and then present some other block to isolated users. Attackers may also split their credits among several "users", who might get selected as leaders, to minimize the penalty when a bad leader is caught. Therefore some proof-of-stake cryptocurrencies require a master key to periodically sign the correct branch of the ledger in order to mitigate forks <ref type="bibr" target="#b31">[32]</ref>. This raises significant trust concerns regarding the currency, and has also caused accidental forks in the past <ref type="bibr" target="#b43">[44]</ref>. Algorand answers this challenge by avoiding forks, even if the leader turns out to be malicious.</p><p>Ouroboros <ref type="bibr" target="#b30">[31]</ref> is a recent proposal for realizing proof-ofstake. For security, Ouroboros assumes that honest users can communicate within some bounded delay (i.e., a strongly synchronous network). Furthermore, it selects some users to participate in a joint-coin-flipping protocol and assumes that most of them are incorruptible by the adversary for a significant epoch (such as a day). In contrast Algorand assumes that the adversary may temporarily fully control the network and immediately corrupt users in targeted attacks.</p><p>Trees and DAGs instead of chains. GHOST <ref type="bibr" target="#b47">[48]</ref>, SPEC-TRE <ref type="bibr" target="#b48">[49]</ref>, and Meshcash <ref type="bibr" target="#b4">[5]</ref> are recent proposals for increasing Bitcoin's throughput by replacing the underlying chainstructured ledger with a tree or directed acyclic graph (DAG) structures, and resolving conflicts in the forks of these data structures. These protocols rely on the Nakamoto consensus using proof-of-work. By carefully designing the selection rule between branches of the trees/DAGs, they are able to substantially increase the throughput. In contrast, Algorand is focused on eliminating forks; in future work, it may be interesting to explore whether tree or DAG structures can similarly increase Algorand's throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">GOALS AND ASSUMPTIONS</head><p>Algorand allows users to agree on an ordered log of transactions, and achieves two goals with respect to the log: Safety goal. With overwhelming probability, all users agree on the same transactions. More precisely, if one honest user accepts transaction A (i.e., it appears in the log), then any future transactions accepted by other honest users will appear in a log that already contains A. This holds even for isolated users that are disconnected from the network-e.g., by Eclipse attacks <ref type="bibr" target="#b28">[29]</ref>.</p><p>Liveness goal. In addition to safety, Algorand also makes progress (i.e., allows new transactions to be added to the log) under additional assumptions about network reachability that we describe below. Algorand aims to reach consensus on a new set of transactions within roughly one minute.</p><p>Assumptions. Algorand makes standard cryptographic assumptions such as public-key signatures and hash functions. Algorand assumes that honest users run bug-free software. As mentioned earlier, Algorand assumes that the fraction of money held by honest users is above some threshold h (a constant greater than 2/3), but that an adversary can participate in Algorand and own some money. We believe that this assumption is reasonable, since it means that in order to successfully attack Algorand, the attacker must invest substantial financial resources in it. Algorand assumes that an adversary can corrupt targeted users, but that an adversary cannot corrupt a large number of users that hold a significant fraction of the money (i.e., the amount of money held by honest, non-compromised users must remain over the threshold).</p><p>To achieve liveness, Algorand makes a "strong synchrony" assumption that most honest users (e.g., 95%) can send messages that will be received by most other honest users (e.g., 95%) within a known time bound. This assumption allows the adversary to control the network of a few honest users, but does not allow the adversary to manipulate the network at a large scale, and does not allow network partitions.</p><p>Algorand achieves safety with a "weak synchrony" assumption: the network can be asynchronous (i.e., entirely controlled by the adversary) for a long but bounded period of time (e.g., at most 1 day or 1 week). After an asynchrony period, the network must be strongly synchronous for a reasonably long period again (e.g., a few hours or a day) for Algorand to ensure safety. More formally, the weak synchrony assumption is that in every period of length b (think of b as a day or a week), there must be a strongly synchronous period of length s &lt; b (an s of a few hours suffices).</p><p>Finally, Algorand assumes loosely synchronized clocks across all users (e.g., using NTP) in order to recover liveness after weak synchrony. Specifically, the clocks must be close enough in order for most honest users to kick off the recovery protocol at approximately the same time. If the clocks are out of sync, the recovery protocol does not succeed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">OVERVIEW</head><p>Algorand requires each user to have a public key. Algorand maintains a log of transactions, called a blockchain. Each transaction is a payment signed by one user's public key transferring money to another user's public key. Algorand grows the blockchain in asynchronous rounds, similar to Bitcoin. In every round, a new block, containing a set of transactions and a pointer to the previous block, is appended to the blockchain. In the rest of this paper, we refer to Algorand software running on a user's computer as that user.</p><p>Algorand users communicate through a gossip protocol. The gossip protocol is used by users to submit new transactions. Each user collects a block of pending transactions that they hear about, in case they are chosen to propose the next block, as shown in Figure <ref type="figure" target="#fig_0">1</ref>. Algorand uses BA⋆ to reach consensus on one of these pending blocks.</p><p>BA⋆ executes in steps, communicates over the same gossip protocol, and produces a new agreed-upon block. BA⋆ can produce two kinds of consensus: final consensus and tentative consensus. If one user reaches final consensus, this means that any other user that reaches final or tentative consensus in the same round must agree on the same block value (regardless of whether the strong synchrony assumption held). This ensures Algorand's safety, since this means that all future transactions will be chained to this final block (and, transitively, to its predecessors). Thus, Algorand confirms a transaction when the transaction's block (or any successor block) reaches final consensus. On the other hand, tentative consensus means that other users may have reached tentative consensus on a different block (as long as no user reached final consensus). A user will confirm a transaction from a tentative block only if and when a successor block reaches final consensus.</p><p>BA⋆ produces tentative consensus in two cases. First, if the network is strongly synchronous, an adversary may, with small probability, be able to cause BA⋆ to reach tentative consensus on a block. In this case, BA⋆ will not reach consensus on two different blocks, but is simply unable to confirm that the network was strongly synchronous. Algorand will eventually (in a few rounds) reach final consensus on a successor block, with overwhelming probability, and thus confirm these earlier transactions.</p><p>The second case is that the network was only weakly synchronous (i.e., it was entirely controlled by the adversary, with an upper bound on how long the adversary can keep control). In this case, BA⋆ can reach tentative consensus on two different blocks, forming multiple forks. This can in turn prevent BA⋆ from reaching consensus again, because the users are split into different groups that disagree about previous blocks. To recover liveness, Algorand periodically invokes BA⋆ to reach consensus on which fork should be used going forward. Once the network regains strong synchrony, this will allow Algorand to choose one of the forks, and then reach final consensus on a subsequent block on that fork.</p><p>We now describe how Algorand's components fit together.</p><p>Gossip protocol. Algorand implements a gossip network (similar to Bitcoin) where each user selects a small random set of peers to gossip messages to. To ensure messages cannot be forged, every message is signed by the private key of its original sender; other users check that the signature is valid before relaying it. To avoid forwarding loops, users do not Block proposal ( §6). All Algorand users execute cryptographic sortition to determine if they are selected to propose a block in a given round. We describe sortition in §5, but at a high level, sortition ensures that a small fraction of users are selected at random, weighed by their account balance, and provides each selected user with a priority, which can be compared between users, and a proof of the chosen user's priority. Since sortition is random, there may be multiple users selected to propose a block, and the priority determines which block everyone should adopt. Selected users distribute their block of pending transactions through the gossip protocol, together with their priority and proof. To ensure that users converge on one block with high probability, block proposals are prioritized based on the proposing user's priority, and users wait for a certain amount of time to receive the block.</p><p>Agreement using BA⋆ ( §7). Block proposal does not guarantee that all users received the same block, and Algorand does not rely on the block proposal protocol for safety. To reach consensus on a single block, Algorand uses BA⋆. Each user initializes BA⋆ with the highest-priority block that they received. BA⋆ executes in repeated steps, illustrated in Figure <ref type="figure" target="#fig_1">2</ref>. Each step begins with sortition ( §5), where all users check whether they have been selected as committee members in that step. Committee members then broadcast a message which includes their proof of selection. These steps repeat until, in some step of BA⋆, enough users in the committee reach consensus. (Steps are not synchronized across users; each user checks for selection as soon as he observes the previous step had ended.) As discussed earlier, an important feature of BA⋆ is that committee members do not keep private state except their private keys, and so can be replaced after every step, to mitigate targeted attacks on them.</p><p>Efficiency. When the network is strongly synchronous, BA⋆ guarantees that if all honest users start with the same initial block (i.e., the highest priority block proposer was honest), then BA⋆ establishes final consensus over that block Under the same network conditions, and in the worst case of a particularly lucky adversary, all honest users reach consensus on the next block within expected 13 steps, as analyzed in Appendix C of the technical report <ref type="bibr" target="#b26">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CRYPTOGRAPHIC SORTITION</head><p>Cryptographic sortition is an algorithm for choosing a random subset of users according to per-user weights; that is, given a set of weights w i and the weight of all users W = i w i , the probability that user i is selected is proportional to w i /W . The randomness in the sortition algorithm comes from a publicly known random seed; we describe later how this seed is chosen. To allow a user to prove that they were chosen, sortition requires each user i to have a public/private key pair, (pk i ,sk i ).</p><p>Sortition is implemented using verifiable random functions (VRFs) <ref type="bibr" target="#b38">[39]</ref>. Informally, on any input string x, VRF sk (x) returns two values: a hash and a proof. The hash is a hashlenbit-long value that is uniquely determined by sk and x, but is indistinguishable from random to anyone that does not know sk. The proof π enables anyone that knows pk to check that the hash indeed corresponds to x, without having to know sk. For security, we require that the VRF provides these properties even if pk and sk are chosen by an attacker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Selection procedure</head><p>Using VRFs, Algorand implements cryptographic sortition as shown in Algorithm 1. Sortition requires a role parameter that distinguishes the different roles that a user may be selected for; for example, the user may be selected to propose a block in some round, or they may be selected to be the member of the committee at a certain step of BA⋆. Algorand specifies a threshold τ that determines the expected number of users selected for that role.</p><p>It is important that sortition selects users in proportion to their weight; otherwise, sortition would not defend against Sybil attacks. One subtle implication is that users may be chosen more than once by sortition (e.g., because they have a high weight). Sortition addresses this by returning the j parameter, which indicates how many times the user was procedure Sortition(sk, seed,τ , role,w,W ):</p><formula xml:id="formula_0">⟨hash, π ⟩ ← VRF sk (seed||role) p ← τ W j ← 0 while hash 2 hashlen j k=0 B(k;w,p), j+1</formula><p>k =0 B(k;w,p) do j++ return ⟨hash, π , j⟩ Algorithm 1: The cryptographic sortition algorithm. chosen. Being chosen j times means that the user gets to participate as j different "sub-users. "</p><p>To select users in proportion to their money, we consider each unit of Algorand as a different "sub-user." If user i owns w i (integral) units of Algorand, then simulated user (i, j) with j ∈ {1, . . . ,w i } represents the j t h unit of currency i owns, and is selected with probability p = τ W , where W is the total amount of currency units in Algorand.</p><p>As shown in Algorithm 1, a user performs sortition by computing ⟨hash, π ⟩ ← V RF sk (seed||role), where sk is the user's secret key. The pseudo-random hash determines how many sub-users are selected, as follows. The probability that exactly k out of the w (the user's weight) sub-users are selected follows the binomial distribution,</p><formula xml:id="formula_1">B(k;w,p) = w k p k (1-p) w -k , where w k =0 B(k;w,p) = 1. Since B(k 1 ;n 1 ,p) + B(k 2 ;n 2 ,p) = B(k 1 + k 2 ;n 1 + n 2 ,p)</formula><p>, splitting a user's weight (currency) among Sybils does not affect the number of selected sub-users under his/her control.</p><p>To determine how many of a user's w sub-users are selected, the sortition algorithm divides the interval [0, 1) into consecutive intervals of the form</p><formula xml:id="formula_2">I j = j k =0 B(k;w,p), j+1</formula><p>k =0 B(k;w,p) for j ∈ {0, 1, . . . ,w }. If hash/2 hashlen (where hashlen is the bit-length of hash) falls in the interval I j , then the user has exactly j selected sub-users. The number of selected sub-users is publicly verifiable using the proof π (from the VRF output).</p><p>Sortition provides two important properties. First, given a random seed, the VRF outputs a pseudo-random hash value, which is essentially uniformly distributed between 0 and 2 hashlen -1. As a result, users are selected at random based on their weights. Second, an adversary that does not know sk i cannot guess how many times user i is chosen, or if i was chosen at all (more precisely, the adversary cannot guess any better than just by randomly guessing based on the weights).</p><p>The pseudocode for verifying a sortition proof, shown in Algorithm 2, follows the same structure to check if that user was selected (the weight of the user's public key is obtained from the ledger). The function returns the number of selected sub-users (or zero if the user was not selected at all).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Choosing the seed</head><p>Sortition requires a seed that is chosen at random and publicly known. For Algorand, each round requires a seed that is publicly known by everyone for that round, but cannot be controlled by the adversary; otherwise, an adversary may procedure VerifySort(pk, hash, π , seed,τ , role,w,W ): if ¬VerifyVRF pk (hash, π , seed||role) then return 0;</p><formula xml:id="formula_3">p ← τ W j ← 0 while hash 2 hashlen j k =0 B(k;w,p), j+1</formula><p>k =0 B(k;w,p) do j++ return j Algorithm 2: Pseudocode for verifying sortition of a user with public key pk.</p><p>be able to choose a seed that favors selection of corrupted users.</p><p>In each round of Algorand a new seed is published. The seed published at Algorand's round r is determined using VRFs with the seed of the previous round r -1. More specifically, during the block proposal stage of round r -1, every user u selected for block proposal also computes a proposed seed for round r as ⟨seed r , π ⟩ ← VRF sk u (seed r -1 ||r ). Algorand requires that sk u be chosen by u well in advance of the seed for that round being determined ( §5.3). This ensures that even if u is malicious, the resulting seed r is pseudo-random.</p><p>This seed (and the corresponding VRF proof π ) is included in every proposed block, so that once Algorand reaches agreement on the block for round r -1, everyone knows seed r at the start of round r . If the block does not contain a valid seed (e.g., because the block was proposed by a malicious user and included invalid transactions), users treat the entire proposed block as if it were empty, and use a cryptographic hash function H (which we assume is a random oracle) to compute the associated seed for round r as seed r = H(seed r -1 ||r ). The value of seed 0 , which bootstraps seed selection, can be chosen at random at the start of Algorand by the initial participants (after their public keys are declared) using distributed random number generation <ref type="bibr" target="#b13">[14]</ref>.</p><p>To limit the adversary's ability to manipulate sortition, and thus manipulate the selection of users for different committees, the selection seed (passed to Algorithm 1 and Algorithm 2) is refreshed once every R rounds. Namely, at round r Algorand calls the sortition functions with seed r -1-(r mod R) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Choosing sk u well in advance of the seed</head><p>Computing seed r requires that every user's secret key sk u is chosen well in advance of the selection seed used in that round, i.e., seed r -1-(r mod R) . When the network is not strongly synchronous, the attacker has complete control over the links, and can therefore drop block proposals and force users to agree on empty blocks, such that future selection seeds can be computed. To mitigate such attacks Algorand relies on the weak synchrony assumption (in every period of length b, there must be a strongly synchronous period of length s &lt; b). Whenever Algorand performs cryptographic sortition for round r , it checks the timestamp included in the agreed-upon block for round r -1 -(r mod R), and uses the keys (and associated weights) from the last block that was created b-time before block r -1 -(r mod R). The lower bound s on the length of a strongly synchronous period should allow for sufficiently many blocks to be created in order to ensure with overwhelming probability that at least one block was honest. This ensures that, as long as s is suitably large, an adversary u choosing a key sk u cannot predict the seed for round r .</p><p>This look-back period b has the following trade-off: a large b mitigates the risk that attackers are able break the weak synchronicity assumption, yet it increases the chance that users have transferred their currency to someone else and therefore have nothing to lose if the system's security breaks. This is colloquially known as the "nothing at stake" problem; one possible way to avoid this trade-off, which we do not explore in Algorand, is to take the minimum of a user's current balance and the user's balance from the look-back block as the user's weight.</p><p>Appendix A of the technical report <ref type="bibr" target="#b26">[27]</ref> formally analyzes the number of blocks that Algorand needs to be created in the period s when the network is strongly connected. We show that to ensure a small probability of failure F , the number of blocks is logarithmic in 1  F , which allows us to obtain high security with a reasonably low number of required blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">BLOCK PROPOSAL</head><p>To ensure that some block is proposed in each round, Algorand sets the sortition threshold for the block-proposal role, τ proposer , to be greater than 1 (although Algorand will reach consensus on at most one of these proposed blocks). Appendix B of the technical report <ref type="bibr" target="#b26">[27]</ref> proves that choosing τ proposer = 26 ensures that a reasonable number of proposers (at least one, and no more than 70, as a plausible upper bound) are chosen with very high probability (e.g., 1 -10 -11 ).</p><p>Minimizing unnecessary block transmissions. One risk of choosing several proposers is that each will gossip their own proposed block. For a large block (say, 1 MByte), this can incur a significant communication cost. To reduce this cost, the sortition hash is used to prioritize block proposals: For each selected sub-user 1, . . . , j of user i, the priority for the block proposal is obtained by hashing the (verifiably random) hash output of VRF concatenated with the sub-user index. The highest priority of all the block proposer's selected sub-users is the priority of the block.</p><p>Algorand users discard messages about blocks that do not have the highest priority seen by that user so far. Algorand also gossips two kinds of messages: one contains just the priorities and proofs of the chosen block proposers (from sortition), and the other contains the entire block, which also includes the proposer's sortition hash, and proof. The first kind of message is small (about 200 Bytes), and propagates quickly through the gossip network. These messages enable most users to learn who is the highest priority proposer, and thus quickly discard other proposed blocks.</p><p>Waiting for block proposals. Each user must wait a certain amount of time to receive block proposals via the gossip protocol. Choosing this time interval does not impact Algorand's safety guarantees but is important for performance. Waiting a short amount of time will mean no received proposals. If the user receives no block proposals, he or she initializes BA⋆ with the empty block, and if many users do so, Algorand will reach consensus on an empty block. On the other hand, waiting too long will receive all block proposals but also unnecessarily increase the confirmation latency.</p><p>To determine the appropriate amount of time to wait for block proposals, we consider the plausible scenarios that a user might find themselves in. When a user starts waiting for block proposals for round r , they may be one of the first users to reach consensus in round r -1. Since that user completed round r -1, sufficiently many users sent a message for the last step of BA⋆ in that round, and therefore, most of the network is at most one step behind this user. Thus, the user must somehow wait for others to finish the last step of BA⋆ from round r -1. At this point, some proposer in round r that happens to have the highest priority will gossip their priority and proof message, and the user must somehow wait to receive that message. Then, the user can simply wait until they receive the block corresponding to the highest priority proof (with a timeout λ block , on the order of a minute, after which the user will fall back to the empty block).</p><p>It is impossible for a user to wait exactly the correct amount for the first two steps of the above scenario. Thus, Algorand estimates these quantities (λ stepvar , the variance in how long it takes different users to finish the last step of BA⋆, and λ priority , the time taken to gossip the priority and proof message), and waits for λ stepvar + λ priority time to identify the highest priority. §10 experimentally shows that these parameters are, conservatively, 5 seconds each. As mentioned above, Algorand would remain safe even if these estimates were inaccurate.</p><p>Malicious proposers. Even if some block proposers are malicious, the worst-case scenario is that they trick different Algorand users into initializing BA⋆ with different blocks. This could in turn cause Algorand to reach consensus on an empty block, and possibly take additional steps in doing so. However, it turns out that even this scenario is relatively unlikely. In particular, if the adversary is not the highest priority proposer in a round, then the highest priority proposer will gossip a consistent version of their block to all users. If the adversary is the highest priority proposer in a round, they can propose the empty block, and thus prevent any real transactions from being confirmed. However, this happens with probability of at most 1 -h, by Algorand's assumption that at least h &gt; 2/3 of the weighted user are honest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">BA⋆</head><p>The execution of BA⋆ consists of two phases. In the first phase, BA⋆ reduces the problem of agreeing on a block to agreement on one of two options. In the second phase, BA⋆ reaches agreement on one of these options: either agreeing on a proposed block, or agreeing on an empty block.</p><p>Each phase consists of several interactive steps; the first phase always takes two steps, and the second phase takes two steps if the highest-priority block proposer was honest (sent the same block to all users), and as we show in our analysis an expected 11 steps in the worst case of a malicious highest-priority proposer colluding with a large fraction of committee participants at every step.</p><p>In each step, every committee member casts a vote for some value, and all users count the votes. Users that receive more than a threshold of votes for some value will vote for that value in the next step (if selected as a committee member). If the users do not receive enough votes for any value, they time out, and their choice of vote for the next step is determined by the step number.</p><p>In the common case, when the network is strongly synchronous and the highest-priority block proposer was honest, BA⋆ reaches final consensus by using its final step to confirm that there cannot be any other agreed-upon block in the same round. Otherwise, BA⋆ may declare tentative consensus if it cannot confirm the absence of other blocks due to possible network asynchrony.</p><p>A key aspect of BA⋆'s design is that it keeps no secrets, except for user private keys. This allows any user observing the messages to "passively participate" in the protocol: verify signatures, count votes, and reach the agreement decision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Main procedure of BA⋆</head><p>The top-level procedure implementing BA⋆, as invoked by Algorand, is shown in Algorithm 3. The procedure takes a context ctx, which captures the current state of the ledger, a round number, and a new proposed block, from the highestpriority block proposer ( §6). Algorand is responsible for ensuring that the block is valid (by checking the proposed block's contents and using an empty block if it is invalid, as described in §8). The context consists of the seed for sortition, the user weights, and the last agreed-upon block.</p><p>For efficiency, BA⋆ votes for hashes of blocks, instead of entire block contents. At the end of the BA⋆ algorithm, we use the BlockOfHash() function to indicate that, if BA⋆ has not yet received the pre-image of the agreed-upon hash, it must obtain it from other users (and, since the block was agreed upon, many of the honest users must have received it during block proposal).</p><p>The BA⋆ algorithm also determines whether it established final or tentative consensus. We will discuss this check in detail when we discuss Algorithm 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Voting</head><p>Sending votes (Algorithm 4). Algorithm 4 shows the pseudocode for CommitteeVote(), which checks if the user is selected for the committee in a given round and step of BA⋆. The CommitteeVote() procedure invokes Sortition() from Algorithm 1 to check if the user is chosen to participate in the committee. If the user is chosen for this step, the user gossips a signed message containing the value passed to CommitteeVote(), which is typically the hash of some block. To bind the vote to the context, the signed message includes the hash of the previous block.</p><p>Counting votes (Algorithm 5 and Algorithm 6). The CountVotes() procedure (Algorithm 5) reads messages that belong to the current round and step from the incomingMsgs buffer. (For simplicity, our pseudocode assumes that a background procedure takes incoming votes and stores them into that buffer, indexed by the messages' round and step.) It processes the votes by calling the ProcessMsg() procedure for every message (Algorithm 6), which ensures that the vote is valid. Note that no private state is required to process these messages. ProcessMsg() returns not just the value contained in the message, but also the number of votes associated with that value. If the message was not from a chosen committee member, ProcessMsg() returns zero votes. If the committee member was chosen several times (see §5), the number of votes returned by ProcessMsg() reflects that as well. Pro-cessMsg() also returns the sortition hash, which we will use later in Algorithm 9.</p><p>As soon as one value has more than T • τ votes, CountVotes() returns that value. τ is the expected number of users that Sortition() selects for the committee, and is the same for each step (τ step ) with the exception of the final step (τ final ). T is a fraction of that expected committee size (T &gt; 2</p><p>3 ) that defines BA⋆'s voting threshold; this is also the same for every step except the final step, and we analyze it in §7. The threshold ensures that if one honest user's CountVotes() returns a particular value, then all other honest users will return either the same value or timeout, even under the weak synchrony assumption (see Lemma 1 in Appendix C.2 of the technical report <ref type="bibr" target="#b26">[27]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Reduction</head><p>The Reduction() procedure, shown in Algorithm 7, converts the problem of reaching consensus on an arbitrary value (the hash of a block) to reaching consensus on one of two values: either a specific proposed block hash, or the hash of an empty block. Our reduction is inspired by Turpin and Coan's two-step technique <ref type="bibr" target="#b50">[51]</ref>. This reduction is important to ensure liveness.</p><p>In the first step of the reduction, each committee member votes for the hash of the block passed to Reduction() by BA⋆(). In the second step, committee members vote for the hash that received at least T • τ votes in the first step, or the hash of the default empty block if no hash received enough votes. Reduction() ensures that there is at most one non-empty block that can be returned by Reduction() for all honest users. Algorithm 7: The two-step reduction.</p><p>In the common case when the network is strongly synchronous and the highest-priority block proposer was honest, most (e.g., 95%) of the users will call Reduction() with the same hblock parameter, and Reduction() will return that same hblock result to most users as well.</p><p>On the other hand, if the highest-priority block proposer was dishonest, different users may start Reduction() with different hblock parameters. In this case, no single hblock value may be popular enough to cross the threshold of votes. As a result, Reduction() will return empty_hash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Binary agreement</head><p>Algorithm 8 shows BinaryBA⋆(), which reaches consensus on one of two values: either the hash passed to BinaryBA⋆() or the hash of the empty block. BinaryBA⋆() relies on Reduction() to ensure that at most one non-empty block hash is passed to BinaryBA⋆() by all honest users. Safety with strong synchrony. In each step of BinaryBA⋆(), a user who has seen more than T • τ votes for some value will vote for that same value in the next step (if selected). However, if no value receives enough votes, BinaryBA⋆() chooses the next vote in a way that ensures consensus in a strongly synchronous network.</p><p>Specifically, user A may receive votes from an adversary that push the votes observed by A past the threshold, but the adversary might not send the same votes to other users (or might not send them in time). As a result, A returns consensus on a block, but other users timed out in that step. It is crucial that BinaryBA⋆() chooses the votes for the next step in a way that will match the block already returned by A. <ref type="bibr">Algorithm</ref>  is coupled with a check for timeout that sets the next-step vote to the same value that could have been returned.</p><p>It is also crucial that BinaryBA⋆() is able to collect enough votes in the next step to carry forward the value that A already reached consensus on. If there are many users like A that have already returned consensus, BinaryBA⋆() may not have enough users to push CountVotes() in the next step past the threshold. To avoid this problem, whenever a user returns consensus, that user votes in the next three steps with the value they reached consensus on.</p><p>In the common case, when the network is strongly synchronous and the block proposer was honest, BinaryBA⋆() will start with the same block_hash for most users, and will reach consensus in the first step, since most committee members vote for the same block_hash value.</p><p>Safety with weak synchrony. If the network is not strongly synchronous (e.g., there is a partition), BinaryBA⋆() may return consensus on two different blocks. For example, suppose that, in the first step of BinaryBA⋆(), all users vote for block_hash, but only one honest user, A, receives those votes. In this case, A will return consensus on block_hash, but all other users will move on to the next step. Now, the other users vote for block_hash again, because CountVotes() returned timeout. However, let's assume the network drops all of these votes. Finally, the users vote for empty_hash in the third step, the network becomes well behaved, and all votes are delivered. As a result, the users will keep voting for empty_hash until the next iteration of the loop, at which point they reach consensus on empty_hash. This is undesirable because BinaryBA⋆() returned consensus on two different hashes to different honest users.</p><p>BA⋆() addresses this problem by introducing the notion of final and tentative consensus. Final consensus means that BA⋆() will not reach consensus on any other block for that round. Tentative consensus means that BA⋆() was unable to guarantee safety, either because of network asynchrony or due to a malicious block proposer.</p><p>BA⋆() designates consensus on value V as "final" if BinaryBA⋆() reached consensus on V in the very first step, and if enough users observed this consensus being reached. Specifically, BinaryBA⋆() sends out a vote for the special final step to indicate that a user reached consensus on some value in the very first step, and BA⋆() collects these votes to determine whether final consensus was achieved. In a strongly synchronous network with an honest block proposer, BinaryBA⋆() will reach consensus in the first step, most committee members will vote for the consensus block in the special final step in BinaryBA⋆(), and will receive more than a threshold of such votes in BA⋆(), thus declaring the block as final. The final step is analogous to the final confirmation step implemented in many Byzantine-resilient protocols <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b34">35]</ref>.</p><p>Intuitively, this guarantees safety because a large threshold of users have already declared consensus for V , and will not vote for any other value in the same round. In our example above, where user A reached consensus on a different block than all other users, neither block would be designated as final, because only one user (namely, A) observed consensus at the first step, and there would never be enough votes to mark that block as final. Appendix C.1 of the technical report <ref type="bibr" target="#b26">[27]</ref> formalizes and proves this safety property.</p><p>One subtle issue arises due to the fact that BA⋆ relies on a committee to declare final consensus, instead of relying on all participants. As a result, even if one user observes final consensus, an adversary that controls the network may be able to prevent a small fraction of other users from reaching any kind of consensus (final or tentative) for an arbitrary number of steps. Each of these steps give the adversary an additional small probability of reaching consensus on a different value (e.g., the empty block). To bound the total procedure CommonCoin(ctx, round, step, τ ): minhash ← 2 hashlen for m ∈ incomingMsgs[round, step] do ⟨votes, value, sorthash⟩ ← ProcessMsg(ctx,τ ,m) for 1 ≤ j &lt; votes do h ← H (sorthash||j) if h &lt; minhash then minhash ← h; return minhash mod 2 Algorithm 9: Computing a coin common to all users.</p><p>probability of an adversary doing so, BA⋆ limits the total number of allowed steps; Appendix C.1 of the technical report <ref type="bibr" target="#b26">[27]</ref> relies on this. If the protocol runs for more than MaxSteps steps, BA⋆ halts without consensus and relies on the recovery protocol described in §8.2 to recover liveness.</p><p>Getting unstuck. One remaining issue is that consensus could get stuck if the honest users are split into two groups, A and B, and the users in the two groups vote for different values (say, we are in step 1, A votes for empty_hash, and B votes for block_hash). Neither group is large enough to gather enough votes on their own, but together with the adversary's votes, group A is large enough. In this situation, the adversary can determine what every user will vote for in the next step. To make some user vote for empty_hash in the next step, the adversary sends that user the adversary's own votes for empty_hash just before the timeout expires, which, together with A's votes, crosses the threshold. To make the user vote for block_hash, the adversary does not send any votes to that user; as a result, that user's CountVotes() will return timeout, and the user will choose block_hash for the next step's vote, according to the BinaryBA⋆() algorithm. This way, the adversary can split the users into two groups in the next step as well, and continue this attack indefinitely. The attack described above requires the adversary to know how a user will vote after receiving timeout from CountVotes(). The third step of BinaryBA⋆() is designed to avoid this attack by pushing towards accepting either block_hash or empty_hash based on a random "common coin, " meaning a binary value that is predominantly the same for all users. Although this may sound circular, the users need not reach formal consensus on this common coin. As long as enough users observe the same coin bit, and the bit was not known to the attacker in advance of the step, BinaryBA⋆() will reach consensus in the next iteration of the loop with probability 1/2 (i.e., the probability that the attacker guessed wrong). By repeating these steps, the probability of consensus quickly approaches 1.</p><p>To implement this coin we take advantage of the VRFbased committee member hashes attached to all of the messages. Every user sets the common coin to be the leastsignificant bit of the lowest hash it observed in this step, as shown in Algorithm 9. If a user gets multiple votes (i.e., several of their sub-users were selected), then Common-Coin() considers multiple hashes from that user, by hashing that user's sortition hash with the sub-user index. Notice that hashes are random (since they are produced by hashing the pseudo-random VRF output), so their least-significant bits are also random. The common coin is used only when CountVotes() times out, giving sufficient time for all votes to propagate through the network. If the committee member with the lowest hash is honest, then all users that received his message observe the same coin.</p><p>If a malicious committee-member happens to hold the lowest hash, then he might send it to only some users. This may result in users observing different coin values, and thus will not help in reaching consensus. However, since sortition hashes are pseudo-random, the probability that an honest user has the lowest hash is h (the fraction of money held by honest users), and thus there is at least an h &gt; 2  3 probability that the lowest sortition hash holder will be honest, which leads to consensus with probability 1  2 •h &gt; 1 3 at each loop iteration. This allows Appendix C.3 of the technical report <ref type="bibr" target="#b26">[27]</ref> to show that, with strong synchrony, BA⋆ does not exceed MaxSteps with overwhelming probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Committee size</head><p>The fraction h &gt; 2 3 of weighted honest users in Algorand must translate into a "sufficiently honest" committee for BA⋆. BA⋆ has two parameters at its disposal: τ , which controls the expected committee size, and T , which controls the number of votes needed to reach consensus (T •τ ). We would like T to be as small as possible for liveness, but the smaller T is, the larger τ needs to be, to ensure that an adversary does not obtain enough votes by chance. Since a larger committee translates into a higher bandwidth cost, we choose two different parameter sets: T final and τ final for the final step, which ensures an overwhelming probability of safety regardless of strong synchrony, and T step and τ step for all other steps, which achieve a reasonable trade-off between liveness, safety, and performance.</p><p>To make the constraints on τ step and T step precise, let us denote the number of honest committee members by д and the malicious ones by b; in expectation, b +д = τ step , but b +д can vary since it is chosen by sortition. To ensure liveness, as we prove in Appendix C.2 of the technical report <ref type="bibr" target="#b26">[27]</ref>, BA⋆ requires 1  2 д +b ≤ T step • τ step and д &gt; T step • τ step . Due to the probabilistic nature of how committee members are chosen, there is always some small chance that the b and д for some step fail to satisfy the above constraints, and BA⋆'s goal is to make this probability negligible. Figure <ref type="figure">3</ref> plots the expected committee size τ step that is needed to satisfy both constraints, as a function of h, for a probability of violation of 5 × 10 -9 ; Appendix B of the technical report <ref type="bibr" target="#b26">[27]</ref> describes this computation in more detail. The figure shows a trade-off: the weaker the assumption on the fraction of money held by honest users (h), the larger the committee size needs to be. The results show that, as h approaches 2  3 , the committee size grows quickly. However, at h = 80%, τ step = 2, 000 can ensure that these constraints hold with probability 1-5×10 -9 (using T step = 0.685). Figure <ref type="figure">3</ref>: The committee size, τ , sufficient to limit the probability of violating safety to 5×10 -9 . The x-axis specifies h, the weighted fraction of honest users. ⋆ marks the parameters selected in our implementation.</p><p>The constraints on τ final and T final are dictated by the proof of safety under weak synchrony; Appendix C.1 of the technical report <ref type="bibr" target="#b26">[27]</ref> shows that τ final = 10, 000 suffices with T final = 0.74.</p><p>With these parameters, BA⋆ ensures safety even if the lowest-priority block proposer is malicious (proposes different blocks). Appendix C of the technical report <ref type="bibr" target="#b26">[27]</ref> provides proofs of BA⋆'s safety under weak synchrony ( §C.1), liveness under strong synchrony ( §C.2), and efficiency ( §C.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">ALGORAND</head><p>Building Algorand on top of the primitives we have described so far requires Algorand to address a number of higher-level issues, which this section discusses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Block format</head><p>Algorand's blocks consist of a list of transactions, along with metadata needed by BA⋆. Specifically, the metadata consists of the round number, the proposer's VRF-based seed ( §6), a hash of the previous block in the ledger, and a timestamp indicating when the block was proposed. The list of transactions in a block logically translates to a set of weights for each user's public key (based on the balance of currency for that key), along with the total weight of all outstanding currency.</p><p>Once a user receives a block from the highest-priority proposer, the user validates the block contents before passing it on to BA⋆. In particular, the user checks that all transactions are valid; that the seed is valid; that the previous block hash is correct; that the block round number is correct; and that the timestamp is greater than that of the previous block and also approximately current (say, within an hour). If any of them are incorrect, the user passes an empty block to BA⋆.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Safety and liveness</head><p>To a large extent, Algorand relies on BA⋆ to reach consensus on blocks in the ledger. Algorand confirms transactions only when they appear in a final block, or in the predecessor of a final block. Final blocks guarantee that no other block could have reached consensus in the same round. This means that all final blocks are totally ordered with respect to one another, since (1) blocks form a linear chain, and (2) there can be exactly one final block at any given position in the chain. In other words, given two final blocks, one of them (the one with the smaller round number r 1 ) must be a predecessor of the other (the one with the higher round number r 2 ), since there must be some predecessor of the r 2 block in round r 1 , and the safety condition guarantees that the r 1 block is the only possible such block.</p><p>The remaining issue is that, if the network is not strongly synchronous, BA⋆ may create forks (i.e., different users reach consensus on different blocks). This does not violate safety, because BA⋆ will return tentative consensus in this situation. However, forks do impact liveness: users on different forks will have different ctx.last_block values, which means they will not count each others' votes. As a result, at least one of the forks (and possibly all of the forks) will not have enough participants to cross the vote threshold, and BA⋆ will not be able to reach consensus on any more blocks on that fork.</p><p>To resolve these forks, Algorand periodically proposes a fork that all users should agree on, and uses BA⋆ to reach consensus on whether all users should, indeed, switch to this fork. To determine the set of possible forks, Algorand users passively monitor all BA⋆ votes (i.e., even votes whose prev_hash value does not match the current user's chain), and keep track of all forks. Users then use loosely synchronized clocks to stop regular block processing and kick off the recovery protocol at every time interval (e.g., every hour), which will propose one of these forks as the fork that everyone should agree on.</p><p>The recovery protocol starts by having users propose a fork using the block proposal mechanism ( §6). Specifically, if a user is chosen to be a "fork proposer, " that user proposes an empty block whose predecessor hash is the longest fork (by the number of blocks) observed by the user so far. Each user waits for the highest-priority fork proposal, much as in the block proposal mechanism. Each user validates the proposed block, by ensuring that the block's parent pointer is a chain that is as long as the longest chain seen by that user. Choosing the longest fork ensures that this fork will include all final blocks. Finally, the user invokes BA⋆ to reach consensus on this block, passing the round number found in the proposed block.</p><p>In order for BA⋆ to reach consensus on one of the forks, all Algorand users must use the same seed and user weights. This means that Algorand must use user weights and seeds from before any possible forks occurred. To do this, Algorand relies on the weak synchrony assumption-namely, that in every period of length b (think of b as 1 day), there must be a strongly synchronous period of length s &lt; b (think of s as a few hours). Under this assumption, using the block timestamps, Algorand quantizes time into b-long periods (think days), and finds the most recent block from the nextto-last complete b-long period. Algorand then uses the seed from this block, and uses user weights from the last block that was agreed upon at least b-long time before it ( §5.3).</p><p>Algorand takes the seed from the block from the nextto-last b-long period because the most recent b-long period may still have an unresolved fork. Such a fork would prevent users from agreeing on the seed and weights used in the recovery. However, as long as Algorand can recover within the s-long strongly synchronous period in the most recent b-long period, all users will agree on the same block from the next-to-last period (as long as their clocks are roughly synchronized).</p><p>To ensure that Algorand recovers from a fork (i.e., most honest users switch to the same fork) within the s-long synchronous period, Algorand users repeatedly attempt to reach consensus on a fork (applying a hash function to the seed each time to produce a different set of proposers and committee members), until they achieve consensus. Since, by assumption, Algorand is operating in a strongly synchronous period, it is not important whether BA⋆ returns "final" or "tentative" consensus in this case. When Algorand is recovering outside of a strongly synchronous period, we cannot ensure recovery within s time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Bootstrapping</head><p>Bootstrapping the system. To deploy Algorand, a common genesis block must be provided to all users, along with the initial cryptographic sortition seed. The value of seed 0 specified in the genesis block is decided using distributed random number generation <ref type="bibr" target="#b13">[14]</ref>, after the public keys and weights for the initial set of participants are publicly known.</p><p>Bootstrapping new users. Users that join the system need to learn the current state of the system, which is defined to be the result of a chain of BA⋆ consensus outcomes. To help users catch up, Algorand generates a certificate for every block that was agreed upon by BA⋆ (including empty blocks). The certificate is an aggregate of the votes from the last step of BinaryBA⋆() (not including the final step) that would be sufficient to allow any user to reach the same conclusion by processing these votes (i.e., there must be at least ⌊T step • τ step ⌋ + 1 votes). Importantly, the users must check the sortition hashes and proofs just like in Algorithm 6, and that all messages in the certificate are for the same Algorand round and BA⋆ step.</p><p>Certificates allow new users to validate prior blocks. Users validate blocks in order, starting from the genesis block. This ensures that the user knows the correct weights for verifying sortition proofs in any given round. Users can also request a certificate proving the safety of a block; this is simply the collection of votes for the final step. Since final blocks are totally ordered, users need to check the safety of only the most recent block.</p><p>One potential risk created by the use of certificates is that an adversary can provide a certificate that appears to show that BA⋆ completed after some large number of steps. This gives the adversary a chance to find a BA⋆ step number (up to MaxSteps) in which the adversary controls more than a threshold of the selected committee members (and to then create a signed certificate using their private keys). We set the committee size to be sufficiently large to ensure the attacker has negligible probability of finding such a step number. For τ step &gt; 1, 000, the probability of this attack is less than 2 -166 at every step, making this attack infeasible.</p><p>Storage. The block history and matching certificates allow new users to catch-up, and are not required for users who are already up-to-date with the current ledger. Therefore Algorand distributes certificate and block storage across users. For N shards, users store blocks/certificates whose round number equals their public key modulo N.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Communication</head><p>Gossiping blocks and relaying messages. Algorand's block proposal protocol ( §6) assumed that chosen users can gossip new blocks before an adversary can learn the user's identity and mount a targeted DoS attack against them. In practice, Algorand's blocks are larger than the maximum packet size, so it is inevitable that some packets from a chosen block proposer will be sent before others. A particularly fast adversary could take advantage of this to immediately DoS any user that starts sending multiple packets, on the presumption that the user is a block proposer.</p><p>Formally, this means that Algorand's liveness guarantees are slightly different in practice: instead of providing liveness in the face of immediate targeted DoS attacks, Algorand ensures liveness as long as an adversary cannot mount a targeted DoS attack within the time it takes for the victim to send a block over a TCP connection (a few seconds). We believe this does not matter significantly; an adversary with such a quick reaction time likely also has broad control over the network, and thus can prevent Algorand nodes from communicating at all. Another approach may be to rely on Tor <ref type="bibr" target="#b18">[19]</ref> to make it difficult for an adversary to quickly disconnect a user.</p><p>To avoid an adversary from sending garbage messages and overwhelming Algorand's gossip network, Algorand nodes must validate messages before relaying them. Specifically, Algorand nodes should validate each message using Algorithm 6, and avoid relaying more than one message signed by a given public key per ⟨round, step⟩.</p><p>Scalability. The communication costs for each user depend on the expected size of the committee and the number of block proposers, which Algorand sets through τ proposer , τ step , and τ final (independent of the number of users). As more users join, it takes a message longer to disseminate in the gossip network. Algorand's gossip network forms a random network graph (each user connects to random peers). Our theoretical analysis suggests that almost all users will be part of one connected component in the graph, and that dissemination time grows with the diameter of that component, which is logarithmic in the number of users <ref type="bibr" target="#b44">[45]</ref>. Experi-ments confirm that Algorand's performance is only slightly affected by more users ( §10).</p><p>Since our random graph uses a fixed number of peers, one potential concern is that it may contain disconnected components <ref type="bibr" target="#b21">[22]</ref>. However, only a small fraction of users might end up in a disconnected component, which does not pose a problem for BA⋆. Moreover, Algorand replaces gossip peers each round, which helps users recover from being possibly disconnected in a previous round.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">IMPLEMENTATION</head><p>We implemented a prototype of Algorand in C++, consisting of approximately 5,000 lines of code. We use the Boost ASIO library for networking. Signatures and VRFs are implemented over Curve 25519 <ref type="bibr" target="#b5">[6]</ref>, and we use SHA-256 for a hash function. We use the VRF outlined in Goldberg et al <ref type="bibr">[28: §4]</ref>.</p><p>In our implementation each user connects to 4 random peers, accepts incoming connections from other peers, and gossips messages to all of them. This gives us 8 peers on average. We currently provide each user with an "address book" file listing the IP address and port number for every user's public key. In a real-world deployment we imagine users could gossip this information, signed by their keys, or distribute it via a public bulletin board. This naïve design of the gossip protocol in our prototype implementation is potentially susceptible to Sybil attacks, since it does not prevent an adversary from joining the gossip network with a large number of identities. We leave the problem of implementing a Sybil-resistant gossip network to future work.</p><p>One difference between our implementation and the pseudocode shown in §7 lies in the BinaryBA⋆() function. The pseudocode in Algorithm 8 votes in the next 3 steps after reaching consensus. For efficiency, our implementation instead looks back to the previous 3 steps before possibly returning consensus in a future step. This logic produces equivalent results but is more difficult to express in pseudocode.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the parameters in our prototype of Algorand; we experimentally validate the timeout parameters in §10. h = 80% means that an adversary would need to control 20% of Algorand's currency in order to create a fork. By analogy, in the US, the top 0.1% of people own about 20% of the wealth <ref type="bibr" target="#b40">[41]</ref>, so the richest 300,000 people would have to collude to create a fork. λ priority should be large enough to allow block proposers to gossip their priorities and proofs. Measurements of message propagation in Bitcoin's network <ref type="bibr" target="#b17">[18]</ref> suggest that gossiping 1 KB to 90% of the Bitcoin peer-to-peer network takes about 1 second. We conservatively set λ priority to 5 seconds.</p><p>λ block ensures that Algorand can make progress even if the block proposer does not send the block. Our experiments ( §10) show that about 10 seconds suffices to gossip a 1 MB block. We conservatively set λ block to be a minute.</p><p>λ step should be high enough to allow users to receive messages from committee members, but low enough to allow  Algorand to make progress (move to the next step) if it does not hear from sufficiently many committee members. We conservatively set λ step to 20 seconds. We set λ stepvar , the estimated variance in BA⋆ completion times, to 10 seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">EVALUATION</head><p>Our evaluation quantitatively answers the following:</p><p>• What is the latency that Algorand can achieve for confirming transactions, and how does it scale as the number of users grows? ( §10.1)</p><p>• What throughput can Algorand achieve in terms of transactions per second? ( §10.2)</p><p>• What are Algorand's CPU, bandwidth, and storage costs? ( §10.3)</p><p>• How does Algorand perform when users misbehave? ( §10.4)</p><p>• Does Algorand choose reasonable timeout parameters? ( §10.5)</p><p>To answer these questions, we deploy our prototype of Algorand on Amazon's EC2 using 1,000 m4.2xlarge virtual machines (VMs), each of which has 8 cores and up to 1 Gbps network throughput. To measure the performance of Algorand with a large number of users, we run multiple Algorand users (each user is a process) on the same VM. By default, we run 50 users per VM, and users propose a 1 MByte block. To simulate commodity network links, we cap the bandwidth for each Algorand process to 20 Mbps. To model network latency we use inter-city latency and jitter measurements <ref type="bibr" target="#b52">[53]</ref> and assign each machine to one of 20 major cities around the world; latency within the same city is modeled as negligible. We assign an equal share of money to each user; the equal distribution of money maximizes the number of messages that users need to process. Graphs in the rest of this section plot the time it takes for Algorand to complete an entire round, and include the minimum, median, maximum, 25th, and 75th percentile times across all users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">Latency</head><p>Figure <ref type="figure" target="#fig_5">5</ref> shows results with the number of users varying from 5,000 to 50,000 (by varying the number of active VMs from 100 to 1,000). The results show that Algorand can confirm    transactions in well under a minute, and the latency is nearconstant as the number of users grows. (Since τ final = 10, 000, the time it takes to complete the final step increases until there are 10,000 users in the system; before this point, users are selected more than once and send fewer votes with higher weights.)</p><p>To determine if Algorand continues to scale to even more users, we run an experiment with 500 Algorand user processes per VM. This configuration runs into two bottlenecks: CPU time and bandwidth. Most of the CPU time is spent verifying signatures and VRFs. To alleviate this bottleneck in our experimental setup, for this experiment we replace verifications with sleeps of the same duration. We are unable to alleviate the bandwidth bottleneck, since each VM's network interface is maxed out; instead, we increase λ step to 1 minute.</p><p>Figure <ref type="figure" target="#fig_7">6</ref> shows the results of this experiment, scaling the number of users from 50,000 to 500,000 (by varying the number of VMs from 100 to 1,000). The latency in this experiment is about 4× higher than in Figure <ref type="figure" target="#fig_5">5</ref>, even for the same number of users, owing to the bandwidth bottleneck. However, the scaling performance remains roughly flat all the way to 500,000 users, suggesting that Algorand scales well. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Throughput</head><p>In the following set of experiments we deploy 50,000 users on our 1,000 VMs (50 users per machine). Figure <ref type="figure" target="#fig_8">7</ref> shows the results with a varying block size. The figure breaks the Algorand round into three parts. Block proposal ( §6), at the bottom of the graph, is the time it takes a user to obtain the proposed block. The block proposal time for small block sizes is dominated by the λ priority + λ stepvar wait time. For large block sizes, the time to gossip the large block contents dominates. BA⋆ except for the final step, in the middle of the graph, is the time it takes for BA⋆ to reach the final step. Finally, BA⋆'s final step, at the top of the graph, is the time it takes BA⋆ to complete the final step. We break out the final step separately because, for the purposes of throughput, it could be pipelined with the next round (although our prototype does not do so).</p><p>The results show that Algorand's agreement time (i.e., BA⋆) is independent of the block size, and stays about the same (12 seconds) even for large blocks. The throughput can be further increased by pipelining the final step, which takes about 6 seconds, with the next round of Algorand. The fixed time for running BA⋆ and the linear growth in block propagation time (with the size of the block) suggest that increasing the block size allows one to amortize the time it takes to run BA⋆ to commit more data, and therefore reach a throughput that maximizes the network capability.</p><p>At its lowest latency, Algorand commits a 2 MByte block in about 22 seconds, which means it can commit 327 MBytes of transactions per hour. For comparison, Bitcoin commits a 1 MByte block every 10 minutes, which means it can commit 6 MBytes of transactions per hour <ref type="bibr" target="#b8">[9]</ref>. As Algorand's block size grows, Algorand achieves higher throughput at the cost of some increase to latency. For example, with a 10 MByte block size, Algorand commits about 750 MBytes of transactions per hour, which is 125× Bitcoin's throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3">Costs of running Algorand</head><p>Users running Algorand incur CPU, network, and storage costs. The CPU cost of running Algorand is modest; when running 50 users per VM, CPU usage on the 8-core VM was about 40% (most of it for verifying signatures and VRFs),  meaning each Algorand process uses about 6.5% of a core. In terms of bandwidth, each user in our experiment with 1 MByte blocks and 50,000 users uses about 10 Mbit/sec (empirically computed as the total amount of data sent, divided by the duration of the experiment). We note that the communication cost per user is independent of the number of users running Algorand, since users have an expected fixed number of neighbors they gossip messages to, and the number of messages in the consensus protocol depends on the committee size (rather than the total number of users).</p><p>In terms of storage cost, Algorand stores block certificates in order to prove to new users that a block was committed. This storage cost is in addition to the blocks themselves. Each block certificate is 300 KBytes, independent of the block size; for 1 MByte blocks, this would be a ∼30% storage overhead. Sharding block storage across users ( §8.3) reduces storage costs proportionally. For example, sharding modulo 10 would require each user to store, on average, 130 KB for every 1MB block that is appended to the ledger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.4">Misbehaving users</head><p>Algorand's safety is guaranteed by BA⋆ ( §7), but proving this experimentally would require testing all possible attacker strategies, which is infeasible. However, to experimentally show that our Algorand prototype handles malicious users, we choose one particular attack strategy. We force the block proposer with the highest priority to equivocate about the proposed block: namely, the proposer sends one version of the block to half of its peers, and another version to others (note that as an optimization, if a user receives to conflicting versions of a block from the highest priority block proposer before the block proposal step is complete, he discards both proposals and starts BA⋆ with the empty block). Malicious users that are chosen to be part of the BA⋆ committee vote for both blocks. Figure <ref type="figure" target="#fig_10">8</ref> shows how Algorand's performance is affected by the weighted fraction of malicious users. The results show that, at least empirically for this particular attack, Algorand is not significantly affected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.5">Timeout parameters</head><p>The above results confirm that BA⋆ steps finish in well under λ step (20 seconds), that the difference between 25th and 75th percentiles of BA⋆ completion times is under λ stepvar (5 seconds), and that blocks are gossiped within λ block (1 minute). We separately measure the time taken to propagate a block proposer's priority and proof; it is consistently around 1 second, well under λ priority (5 seconds), confirming the measurements by Decker and Wattenhofer <ref type="bibr" target="#b17">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">FUTURE WORK</head><p>This paper focused on the consensus mechanism for committing transactions, and addressing the associated scalability and security challenges. There remain a number of open problems in designing permissionless cryptocurrencies:</p><p>Incentives. In order to encourage Algorand users to participate, i.e., be online when selected and pay the network cost of operating Algorand, the system may need to include incentives, possibly in form of a reward mechanism. Designing and analyzing an incentive mechanism includes many challenges, such as ensuring that users do not have perverse incentives (e.g., to withhold votes), and that malicious users cannot "game the system" to obtain more rewards than users who follow the protocol (e.g., by influencing seed selection).</p><p>Cost of joining. To join Algorand, new users fetch all existing blocks with their accompanying certificates, which can comprise a large amount of data. Other cryptocurrencies face a similar problem, but since the throughput of Algorand is relatively high, this may create a scalability challenge.</p><p>Forward security. Attackers may attempt to corrupt users over time, since identities of committee members are revealed after they send a message. If an attacker manages to obtain enough user keys, he could construct a fake certificate to create a fork. One solution would be for users to forget the signing key before sending out a signed message (and commit to a series of signing keys ahead of time, perhaps using identity-based encryption <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b19">20]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">CONCLUSION</head><p>Algorand is a new cryptocurrency that confirms transactions on the order of a minute with a negligible probability of forking. Algorand's design is based on a cryptographic sortition mechanism combined with the BA⋆ Byzantine agreement protocol. Algorand avoids targeted attacks at chosen participants using participant replacement at every step. Experimental results with a prototype of Algorand demonstrate that it achieves sub-minute latency and 125× the throughput of Bitcoin, and scales well to 500,000 users.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An overview of transaction flow in Algorand.</figDesc><graphic coords="5,66.00,54.00,216.04,141.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: An overview of one step of BA⋆. To simplify the figure, each user is shown twice: once at the top of the diagram and once at the bottom. Each arrow color indicates a message from a particular user.</figDesc><graphic coords="5,329.96,54.00,216.05,115.22" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Implementation parameters.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Latency for one round of Algorand, with 5,000 to 50,000 users.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Latency for one round of Algorand in a configuration with 500 users per VM, using 100 to 1,000 VMs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Latency for one round of Algorand as a function of the block size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Latency for one round of Algorand with a varying fraction of malicious users, out of a total of 50,000 users.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>procedure BA⋆(ctx, round, block): hblock ← Reduction(ctx, round,H (block)) hblock ⋆ ← BinaryBA⋆(ctx, round, hblock) // Check if we reached "final" or "tentative" consensus r ← CountVotes(ctx, round, final,T final ,τ final ,λ step ) if hblock ⋆ = r then return ⟨final, BlockOfHash(hblock ⋆ )⟩ else return ⟨tentative, BlockOfHash(hblock ⋆ )⟩ Algorithm 3: Running BA⋆ for the next round, with a proposed block. H is a cryptographic hash function. procedure CommitteeVote(ctx, round, step,τ , value): // check if user is in committee using Sortition (Alg. 1) role ← ⟨"committee", round, step⟩ ⟨sorthash, π , j⟩ ← Sortition(user.sk, ctx.seed,τ , role, ctx.weight[user.pk], ctx.W ) // only committee members originate a message if j &gt; 0 then Gossip(⟨user.pk, Signed user.</figDesc><table /><note><p>sk (round, step, sorthash, π ,H (ctx.last_block), value)⟩) Algorithm 4: Voting for value by committee members. user.sk and user.pk are the user's private and public keys.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Counting votes for round and step.</figDesc><table><row><cell>procedure CountVotes(ctx, round, step,T ,τ ,λ):</cell></row><row><cell>start ← Time()</cell></row><row><cell>counts ← {} // hash table, new keys mapped to 0</cell></row><row><cell>voters ← {}</cell></row><row><cell>msgs ← incomingMsgs[round, step].iterator()</cell></row><row><cell>while True do</cell></row><row><cell>m ← msgs.next()</cell></row><row><cell>if m = ⊥ then</cell></row><row><cell>if Time() &gt; start + λ then return timeout;</cell></row><row><cell>else</cell></row><row><cell>⟨votes, value, sorthash⟩ ← ProcessMsg(ctx,τ ,m)</cell></row><row><cell>if pk ∈ voters or votes = 0 then continue;</cell></row><row><cell>voters ∪ = {pk}</cell></row><row><cell>counts[value] + = votes</cell></row><row><cell>// if we got enough votes, then output this value</cell></row><row><cell>if counts[value] &gt; T • τ then</cell></row><row><cell>return value</cell></row><row><cell>Algorithm 5:</cell></row></table><note><p>5. If not enough messages were received within the allocated λ time window, then CountVotes() produces timeout. procedure ProcessMsg(ctx,τ ,m): ⟨pk, signed_m⟩ ← m if VerifySignature(pk, signed_m) OK then return ⟨0, ⊥, ⊥⟩ ⟨round, step, sorthash, π , hprev, value⟩ ← signed_m // discard messages that do not extend this chain if hprev H (ctx.last_block) then return ⟨0, ⊥, ⊥⟩; votes ← VerifySort(pk, sorthash, π , ctx.seed,τ , ⟨"committee", round, step⟩, ctx.weight[pk], ctx.W ) return ⟨votes, value, sorthash⟩ Algorithm 6: Validating incoming vote message m.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>procedure Reduction(ctx, round, hblock): // step 1: gossip the block hash CommitteeVote(ctx, round, reduction_one, τ step , hblock) // other users might still be waiting for block proposals, // so set timeout for λ block + λ step hblock 1 ← CountVotes(ctx, round, reduction_one, T step ,τ step ,λ block + λ step ) CountVotes(ctx, round, reduction_two, T step ,τ step ,λ step ) if hblock 2 = timeout then return empty_hash ; else return hblock 2 ;</figDesc><table><row><cell>// step 2: re-gossip the popular block hash</cell></row><row><cell>empty_hash ← H (Empty(round,H (ctx.last_block)))</cell></row><row><cell>if hblock 1 = timeout then</cell></row><row><cell>CommitteeVote(ctx, round, reduction_two,</cell></row><row><cell>τ step , empty_hash)</cell></row><row><cell>else</cell></row><row><cell>CommitteeVote(ctx, round, reduction_two,</cell></row><row><cell>τ step , hblock 1 )</cell></row><row><cell>hblock 2 ←</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>8 follows this rule: every return statement procedure BinaryBA⋆(ctx, round, block_hash): step ← 1 r ← block_hash empty_hash ← H (Empty(round,H (ctx.last_block))) while step &lt; MaxSteps do CommitteeVote(ctx, round, step, τ step , r) r ← CountVotes(ctx, round, step,T step ,τ step ,λ step ) if r = timeout then r ← block_hash else if r empty_hash then for step &lt; s ′ ≤ step + 3 do CommitteeVote(ctx, round, s ′ , τ step , r ) if step = 1 then CommitteeVote(ctx, round, final, τ final , r ) return r step++ CommitteeVote(ctx, round, step, τ step , r) r ← CountVotes(ctx, round, step,T step ,τ step ,λ</figDesc><table><row><cell>else</cell></row><row><cell>r ← empty_hash</cell></row><row><cell>step++</cell></row><row><cell>// No consensus after MaxSteps; assume network</cell></row><row><cell>// problem, and rely on  §8.2 to recover liveness.</cell></row><row><cell>HangForever()</cell></row><row><cell>Algorithm 8: BinaryBA⋆ executes until consensus is</cell></row><row><cell>reached on either block_hash or empty_hash.</cell></row></table><note><p><p>step ) if r = timeout then r ← empty_hash else if r = empty_hash then for step &lt; s ′ ≤ step + 3 do CommitteeVote(ctx, round, s ′ , τ step , r ) return r step++ CommitteeVote(ctx, round, step, τ step , r) r ← CountVotes(ctx, round, step,T step ,τ step ,λ step ) if r = timeout then</p>if CommonCoin(ctx, round, step,τ step ) = 0 then r ← block_hash</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>This work is licensed under a Creative Commons Attribution International 4.0 License.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>Thanks to Iddo Bentov, Ethan Heilman, Jelle van den Hooff, and our shepherd, Robbert van Renesse, for their helpful comments and suggestions. Gilad, Hemo, and Zeldovich were supported by NSF awards CNS-1413920 and CNS-1414119.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fault-scalable Byzantine faulttolerant services</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abd-El-Malek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Wylie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the 20th ACM Symposium on Operating Systems Principles (SOSP)<address><addrLine>Brighton, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-10">Oct. 2005</date>
			<biblScope unit="page" from="59" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">How to use Bitcoin to design fair protocols</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual International Cryptology Conference (CRYPTO)</title>
		<meeting>the 34th Annual International Cryptology Conference (CRYPTO)<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-08">Aug. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Proof of activity: Extending Bitcoin&apos;s proof of work via proof of stake</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mizrahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Joint Workshop on Pricing and Incentives in Networks and Systems</title>
		<meeting>the 2014 Joint Workshop on Pricing and Incentives in Networks and Systems<address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-06">June 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Cryptocurrencies without proof of work</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gabizon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mizrahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Financial Cryptography and Data Security Conference</title>
		<meeting>the 2016 Financial Cryptography and Data Security Conference</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Tortoise and hares consensus: the Meshcash framework for incentive-compatible, scalable cryptocurrencies</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hubáček</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nadler</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2017-04">2017/300, Apr. 2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Curve25519: New Diffie-Hellman speed records</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Conference on Theory and Practice in Public-Key Cryptography (PKC)</title>
		<meeting>the 9th International Conference on Theory and Practice in Public-Key Cryptography (PKC)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-04">Apr. 2006</date>
			<biblScope unit="page" from="207" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Bitcoin</forename><surname>Wiki</surname></persName>
		</author>
		<ptr target="https://en.bitcoin.it/wiki/Confirmation" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Mining hardware comparison</title>
		<author>
			<persName><surname>Bitcoinwiki</surname></persName>
		</author>
		<ptr target="https://en.bitcoin.it/wiki/Mining_hardware_comparison" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Bitcoin scalability</title>
		<author>
			<persName><surname>Bitcoinwiki</surname></persName>
		</author>
		<ptr target="https://en.bitcoin.it/wiki/Scalability" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Proof of stake</title>
		<author>
			<persName><surname>Bitcoinwiki</surname></persName>
		</author>
		<ptr target="https://en.bitcoin.it/wiki/Proof_of_Stake" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the Weil pairing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual International Cryptology Conference (CRYPTO)</title>
		<meeting>the 21st Annual International Cryptology Conference (CRYPTO)<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Brockman</surname></persName>
		</author>
		<author>
			<persName><surname>Stellar</surname></persName>
		</author>
		<ptr target="https://stripe.com/blog/stellar" />
		<imprint>
			<date type="published" when="2014-07">July 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">V</forename><surname>Buterin</surname></persName>
		</author>
		<ptr target="https://medium.com/@VitalikButerin/minimal-slashing-conditions" />
		<title level="m">Minimal slashing conditions</title>
		<imprint>
			<date type="published" when="2017-03">20f0b500fc6c, Mar. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Secure and efficient asynchronous broadcast protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Petzold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual International Cryptology Conference (CRYPTO)</title>
		<meeting>the 21st Annual International Cryptology Conference (CRYPTO)<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-08">Aug. 2001</date>
			<biblScope unit="page" from="524" to="541" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Practical Byzantine fault tolerance and proactive recovery</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><surname>Algorand</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1607.01341" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Making Byzantine fault tolerant systems tolerate Byzantine faults</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marchetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>the 6th Symposium on Networked Systems Design and Implementation (NSDI)<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-04">Apr. 2009</date>
			<biblScope unit="page" from="153" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Information propagation in the Bitcoin network</title>
		<author>
			<persName><forename type="first">C</forename><surname>Decker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th IEEE International Conference on Peer-to-Peer Computing</title>
		<meeting>the 13th IEEE International Conference on Peer-to-Peer Computing</meeting>
		<imprint>
			<date type="published" when="2013-09">Sept. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Tor: The second-generation onion router</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dingledine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mathewson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Syverson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Usenix Security Symposium</title>
		<meeting>the 13th Usenix Security Symposium<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-08">Aug. 2004</date>
			<biblScope unit="page" from="303" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the Diffie-Hellman assumption</title>
		<author>
			<persName><forename type="first">N</forename><surname>Döttling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual International Cryptology Conference (CRYPTO)</title>
		<meeting>the 37th Annual International Cryptology Conference (CRYPTO)<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-08">Aug. 2017</date>
			<biblScope unit="page" from="537" to="569" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Sybil attack</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Workshop on Peer-to-Peer Systems (IPTPS &apos;02)</title>
		<meeting>the 1st International Workshop on Peer-to-Peer Systems (IPTPS &apos;02)<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-03">Mar. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the evolution of random graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Erdős</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rényi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Publications of the Mathematical Institute of the Hungarian Academy of Sciences</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="17" to="61" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">Ethereum Foundation. Ethereum</orgName>
		</author>
		<ptr target="https://www.ethereum.org/" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<ptr target="https://www.ethereum.org/dao" />
		<title level="m">Ethereum Foundation. Create a democracy contract in Ethereum</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Majority is not enough: Bitcoin mining is vulnerable</title>
		<author>
			<persName><forename type="first">I</forename><surname>Eyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Sirer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 Financial Cryptography and Data Security Conference</title>
		<meeting>the 2013 Financial Cryptography and Data Security Conference</meeting>
		<imprint>
			<date type="published" when="2014-03">Mar. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Bitcoin-NG: A scalable blockchain protocol</title>
		<author>
			<persName><forename type="first">I</forename><surname>Eyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Gencer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Sirer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>the 13th Symposium on Networked Systems Design and Implementation (NSDI)<address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-03">Mar. 2016</date>
			<biblScope unit="page" from="45" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Algorand: Scaling Byzantine agreements for cryptocurrencies</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gilad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hemo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vlachos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2017">2017/454, Version 20170924:210956. Sept. 2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">NSEC5 from elliptic curves: Provably preventing DNSSEC zone enumeration with shorter responses</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Reyzin</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016-03-83">2016/083, Mar. 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Eclipse attacks on Bitcoin&apos;s peer-to-peer network</title>
		<author>
			<persName><forename type="first">E</forename><surname>Heilman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zohar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Usenix Security Symposium</title>
		<meeting>the 24th Usenix Security Symposium<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08">Aug. 2015</date>
			<biblScope unit="page" from="129" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Bitcoin mining pools targeted in wave of DDoS attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Higgins</surname></persName>
		</author>
		<ptr target="https://www.coindesk.com/bitcoin-mining-pools-ddos-attacks/" />
		<imprint>
			<date type="published" when="2015-03">Mar. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Ouroboros: A provably secure proof-ofstake blockchain protocol</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Konstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oliynykov</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016">2016/889, 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">PPCoin: Peer-to-peer cryptocurrency with proof-of-stake</title>
		<author>
			<persName><forename type="first">S</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<ptr target="https://peercoin.net/assets/paper/peercoin-paper.pdf" />
		<imprint>
			<date type="published" when="2012-08">Aug. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Enhancing Bitcoin security and performance with strong consistency via collective signing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kokoris-Kogias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gailly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Khoffi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Usenix Security Symposium</title>
		<meeting>the 25th Usenix Security Symposium<address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-08">Aug. 2016</date>
			<biblScope unit="page" from="279" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Zyzzyva: Speculative Byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kotla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The part-time parliament</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Beyond one-third faulty replicas in Byzantine fault tolerant systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>the 4th Symposium on Networked Systems Design and Implementation (NSDI)<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-04">Apr. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<ptr target="https://www.stellar.org/papers/stellar-consensus-protocol.pdf" />
		<title level="m">The Stellar consensus protocol: A federated model for internet-level consensus</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Fast and furious Byzantine agreement</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Innovations in Theoretical Computer Science (ITCS) Conference</title>
		<meeting>the Innovations in Theoretical Computer Science (ITCS) Conference</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Verifiable random functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual IEEE Symposium on Foundations of Computer Science (FOCS)</title>
		<meeting>the 40th Annual IEEE Symposium on Foundations of Computer Science (FOCS)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-10">Oct. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The Honey Badger of BFT protocols</title>
		<author>
			<persName><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Croman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 23rd ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-10">Oct. 2016</date>
			<biblScope unit="page" from="31" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Monaghan</surname></persName>
		</author>
		<ptr target="https://www.theguardian.com/business/2014/nov/13/us-wealth-inequality-top-01-worth-as-much-as-the-bottom-90" />
		<title level="m">US wealth inequality: top 0.1% worth as much as the bottom 90%</title>
		<imprint>
			<date type="published" when="2014-11">Nov. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Bitcoin: A peer-to-peer electronic cash system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nakamoto</surname></persName>
		</author>
		<ptr target="https://bitcoin.org/bitcoin.pdf" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Hybrid consensus: Efficient consensus in the permissionless model</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016">2016/917, 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Peercoin invalid checkpoint</title>
		<author>
			<persName><surname>Peercointalk</surname></persName>
		</author>
		<ptr target="https://www.peercointalk.org/t/invalid-checkpoint/3691" />
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The diameter of sparse random graphs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Riordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wormald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorics, Probability and Computing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="835" to="926" />
			<date type="published" when="2010-11">Nov. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">BitGo launches &quot;instant&quot; Bitcoin transaction tool</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rizzo</surname></persName>
		</author>
		<ptr target="http://www.coindesk.com/bitgo-instant-bitcoin-transaction-tool/" />
		<imprint>
			<date type="published" when="2016-01">Jan. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">The problem of ASICBOOST</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rubin</surname></persName>
		</author>
		<ptr target="http://www.mit.edu/~jlrubin/public/pdfs/Asicboost.pdf" />
		<imprint>
			<date type="published" when="2017-04">Apr. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Secure high-rate transaction processing in Bitcoin</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sompolinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zohar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Financial Cryptography and Data Security Conference</title>
		<meeting>the 2015 Financial Cryptography and Data Security Conference</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">SPECTRE: A fast and scalable cryptocurrency protocol</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sompolinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lewenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zohar</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="1159">2016/1159, 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Smart contracts: Formalizing and securing relationships on public networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Szabo</surname></persName>
		</author>
		<ptr target="http://firstmonday.org/ojs/index.php/fm/article/view/548/469" />
	</analytic>
	<monogr>
		<title level="j">First Monday</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>Sept</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Extending binary Byzantine agreement to multivalued Byzantine agreement</title>
		<author>
			<persName><forename type="first">R</forename><surname>Turpin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Coan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="73" to="76" />
			<date type="published" when="1984-02">Feb. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Empirical analysis of denial-of-service attacks in the Bitcoin ecosystem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vasek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thornton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Financial Cryptography and Data Security Conference</title>
		<meeting>the 18th International Financial Cryptography and Data Security Conference<address><addrLine>Barbados</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-03">Mar. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Global ping statistics: Ping times between WonderNetwork servers</title>
		<author>
			<persName><surname>Wondernetwork</surname></persName>
		</author>
		<ptr target="https://wondernetwork.com/pings" />
		<imprint>
			<date type="published" when="2017-04">Apr. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">ZCash: All coins are created equal</title>
		<author>
			<orgName type="collaboration">Zerocoin Electric Coin Company</orgName>
		</author>
		<ptr target="https://z.cash" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
