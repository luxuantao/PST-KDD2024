<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalable Recognition with a Vocabulary Tree</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><surname>Nistér</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Visualization and Virtual Environments Department of Computer Science</orgName>
								<orgName type="institution">University of Kentucky</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Henrik</forename><surname>Stewénius</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Visualization and Virtual Environments Department of Computer Science</orgName>
								<orgName type="institution">University of Kentucky</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Scalable Recognition with a Vocabulary Tree</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1E7D278695AFAA3C2C07DB8ED70CE31C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A recognition scheme that scales efficiently to a large number of objects is presented. The efficiency and quality is exhibited in a live demonstration that recognizes CD-covers from a database of 40000 images of popular music CD's.</p><p>The scheme builds upon popular techniques of indexing descriptors extracted from local regions, and is robust to background clutter and occlusion. The local region descriptors are hierarchically quantized in a vocabulary tree. The vocabulary tree allows a larger and more discriminatory vocabulary to be used efficiently, which we show experimentally leads to a dramatic improvement in retrieval quality. The most significant property of the scheme is that the tree directly defines the quantization. The quantization and the indexing are therefore fully integrated, essentially being one and the same.</p><p>The recognition quality is evaluated through retrieval on a database with ground truth, showing the power of the vocabulary tree approach, going as high as 1 million images.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Object recognition is one of the core problems in computer vision, and it is a very extensively investigated topic.</p><p>Due to appearance variabilities caused for example by non-rigidity, background clutter, differences in viewpoint, orientation, scale or lighting conditions, it is a hard problem.</p><p>One of the important challenges is to construct methods that scale well with the size of the database, and can select one out of a large number of objects in acceptable time. In this paper, a method handling a large number of objects is presented. The approach belongs to a currently very popular class of algorithms that work with local image regions and Figure <ref type="figure">1</ref>. A vocabulary tree with branch factor three and only two levels for illustration purposes. A large number of elliptical regions are extracted from the image and warped to canonical positions. A descriptor vector is computed for each region. The descriptor vector is then hierarchically quantized by the vocabulary tree. In the first quantization layer, the descriptor is assigned to the closest of the three green centers. In the second layer, it is assigned to the closest of the three blue descendants to the green center. With each node in the vocabulary tree there is an associated inverted file with references to the images containing an instance of that node. The images in the database are scored hierarchically using the inverted files at multiple levels of the vocabulary tree.</p><p>represent an object with descriptors extracted from these local regions <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b17">18]</ref>. The strength of this class of algorithms is natural robustness against occlusion and background clutter.</p><p>The most important contribution of this paper is an indexing mechanism that enables extremely efficient retrieval. In the current implementation of the proposed scheme, feature extraction on a 640 × 480 video frame takes around 0.2 seconds and the database query takes 25ms on a database with 50000 images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Approach and its Relation to Previous Work</head><p>Our work is largely inspired by Sivic and Zisserman <ref type="bibr" target="#b16">[17]</ref>. They perform retrieval of shots from a movie using a text retrieval approach. Descriptors extracted from local affine invariant regions are quantized into visual words, which are defined by k-means performed on the descriptor vectors from a number of training frames. The collection of visual words are used in Term Frequency Inverse Document Frequency (TF-IDF) scoring of the relevance of an image to the query. The scoring is accomplished using inverted files.</p><p>We propose a hierarchical TF-IDF scoring using hierarchically defined visual words that form a vocabulary tree. This allows much more efficient lookup of visual words, which enables the use of a larger vocabulary, which is shown to result in a significant improvement of retrieval quality. In particular, we show high quality retrieval results without any consideration of the geometric layout of visual words within the frame, while <ref type="bibr" target="#b16">[17]</ref> reports that the geometric layout is crucial for retrieval quality, which we also find to be true when using a smaller vocabulary. We will concentrate on showing the quality of the pre-geometry stage of retrieval, which we believe is important in order to scale up to large databases.</p><p>The recognition quality is evaluated through retrieval on a database with ground truth consisting of known groups of images of the same object or location, but under different viewpoint, rotation, scale and lighting conditions. This evaluation shows that the vocabulary tree allows us to achieve significantly better than previous methods, both in terms of quality and efficiency.</p><p>The use of a larger vocabulary also unleashes the true power of the inverted file approach by decreasing the fraction of images in the database that have to be explicitly considered. In <ref type="bibr" target="#b16">[17]</ref>, a vocabulary with on the order of 10000 visual words are used. With on the order of 1000 visual words per frame, this means that approximately a tenth of the database is traversed during a query, even if the occupancy of visual words in the database is uniformly distributed. We show that better retrieval quality is obtained with a larger vocabulary, even as large as a vocabulary tree with 16 million leaf nodes. With this size of vocabulary, several orders of magnitude less features from the database have to be explicitly considered. Thus both higher retrieval quality and efficiency is obtained. In particular, we obtain sub-second retrieval times for a database of a million images, while in <ref type="bibr" target="#b16">[17]</ref>, only on the order of a few thousand frames was attempted. We use hierarchical scoring, meaning that other nodes than the leaf nodes are considered, but the number of images attached to the inverted file of a node are limited to a fixed number, since larger inverted files are expensive and provide little entropy in the TF-IDF scoring.</p><p>The vocabulary tree also provides more efficient training by using a hierarchical k-means approach. In <ref type="bibr" target="#b16">[17]</ref>, 400 training frames are used, while here we go as high as 35000, which we show improves the quality when using a large vocabulary.</p><p>While <ref type="bibr" target="#b16">[17]</ref> uses an offline crawling stage to index the video, which takes at least 10 seconds per frame, we can insert images into the database at the same rate as reported for the feature extraction, i.e. around 5Hz for 640 × 480 resolution. This potential for on-the-fly insertion of new objects into the database is a result of the quantization into visual words, which is defined once and for all, while still allowing general high retrieval performance. This feature is important, but rather uncommon in previous work. We plan to use it for vision-based simultaneous localization and mapping, where new locations need to be added on-the-fly.</p><p>Several authors have shown that trees present an efficient way to index local image regions. For example, Lepetit, Lagger and Fua <ref type="bibr" target="#b6">[7]</ref> use re-rendering of image patches to train multiple decision trees that are used to index keypoints, somewhat reminiscent of locality sensitive hashing <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b2">3]</ref>. The measurements used in their trees are ratios of pixel intensities. In contrast, we use proximity of the descriptor vectors to various cluster centers defining the vocabulary tree. Their method provides very fast online operation. It is focused on detection of a single object, but could potentially be used for more objects. With their method, training optimally for a new object takes 10-15 minutes, and their fastest method takes one minute for training a new object. We use an offline unsupervised training stage to define the vocabulary tree, but once the vocabulary tree is determined, new images can be inserted on-the-fly into the database.</p><p>Decision trees are also used by Obdrzalek and Matas <ref type="bibr" target="#b13">[14]</ref> to index keypoints. They use pixel measurements, each aimed at splitting the descriptor distribution roughly in half. They have shown online recognition of on the order of 100 to 1000 objects with this method. Insertion of new objects requires offline training of the decision tree.</p><p>Lowe <ref type="bibr" target="#b8">[9]</ref> uses a k-d tree with a best-bin-first modification to find approximate nearest neighbors to the descriptor vectors of the query. Lowe presents results with up to around 100000 keypoint descriptors in the database, which with the cited number of 2000 stable features per frame amounts to about 50 training images in the database. Lowe's approach has been used on around 5000 objects in a commercial application, but we are not aware of an academic reference describing these results.</p><p>For the most part, the above approaches keep amounts of data around in the database that is on the order of magnitude as large as the image patches themselves, or at least the region descriptors. However, the compactness of the database is very important for query efficiency in a large database. With our vocabulary tree approach, the representation of an image patch is simply one or two integers, which should be contrasted to the hundreds of bytes or floats used for a descriptor vector.</p><p>Compactness is also the most important difference between our approach and the hierarchical approach used by Grauman and Darrell <ref type="bibr" target="#b4">[5]</ref>. They use a pyramid of histograms, at each level doubling the number of bins along each axis without considering the distribution of data. By using a vocabulary adapted to the likely distribution of data, we can use a much smaller tree, resulting in better resolution while maintaining a compact representation. We also estimate that our approach is around a factor 1000 faster.</p><p>For feature extraction, we use our own implementation of Maximally Stable Extremal Regions (MSERs) <ref type="bibr" target="#b9">[10]</ref>. They have been found to perform well in thorough performance evaluation <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b3">4]</ref>. We warp an elliptical patch around each MSER region into a circular patch. The remaining portion of our feature extraction is then implemented according to the SIFT feature extraction pipeline by Lowe <ref type="bibr" target="#b8">[9]</ref>. Canonical directions are found based on an orientation histogram formed on the image gradients. SIFT descriptors are then extracted relative to the canonical directions. The SIFT descriptors have been found highly distinctive in performance evaluation <ref type="bibr" target="#b11">[12]</ref>. The normalized SIFT descriptors are then quantized with the vocabulary tree. Finally, a hierarchical scoring scheme is applied to retrieve images from a database.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Building and Using the Vocabulary Tree</head><p>The vocabulary tree defines a hierarchical quantization that is built by hierarchical k-means clustering. A large set of representative descriptor vectors are used in the unsupervised training of the tree.</p><p>Instead of k defining the final number of clusters or quantization cells, k defines the branch factor (number of children of each node) of the tree. First, an initial kmeans process is run on the training data, defining k cluster centers. The training data is then partitioned into k groups, where each group consists of the descriptor vectors closest to a particular cluster center.</p><p>The same process is then recursively applied to each group of descriptor vectors, recursively defining quantization cells by splitting each quantization cell into k new parts. The tree is determined level by level, up to some maximum number of levels L, and each division into k parts is only defined by the distribution of the descriptor vectors that belong to the parent quantization cell. The process is illustrated in Figure <ref type="figure" target="#fig_0">2</ref>.</p><p>In the online phase, each descriptor vector is simply propagated down the tree by at each level comparing the descriptor vector to the k candidate cluster centers (represented by k children in the tree) and choosing the closest one. This is a simple matter of performing k dot products at each level, resulting in a total of kL dot products, which is very efficient if k is not too large. The path down the tree can be encoded by a single integer and is then available for use in scoring.</p><p>Note that the tree directly defines the visual vocabulary and an efficient search procedure in an integrated manner. This is different from for example defining a visual vocabulary non-hierarchically, and then devising an approximate nearest neighbor search in order to find visual words efficiently. We find the seamless choice more appealing, although the latter approach also defines quantization cells in the original space if used consistently and deterministically. The hierarchical approach also gives more flexibility to the subsequent scoring procedure.</p><p>While the computational cost of increasing the size of the vocabulary in a non-hierarchical manner would be very high, the computational cost in the hierarchical approach is logarithmic in the number of leaf nodes. The memory usage is linear in the number of leaf nodes k L . The total number of descriptor vectors that must be represented is</p><formula xml:id="formula_0">L i=1 k i = k L+1 -k k-1 ≈ k L .</formula><p>For D-dimensional descriptors represented as char the size of the tree is approximately Dk L bytes. With our current implementation, a tree with D = 128, L = 6 and k = 10, resulting in 1M leaf nodes, uses 143M B of memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Definition of Scoring</head><p>Once the quantization is defined, we wish to determine the relevance of a database image to the query image based on how similar the paths down the vocabulary tree are for the descriptors from the database image and the query image. An illustration of this representation of an image is given in Figure <ref type="figure" target="#fig_1">3</ref>. There is a myriad of options here, and we have compared a number of variants empirically.</p><p>Most of the schemes we have tried can be thought of as assigning a weight w i to each node i in the vocabulary tree, typically based on entropy, and then define both query q i and database vectors d i according to the assigned weights as</p><formula xml:id="formula_1">q i = n i w i<label>(1)</label></formula><formula xml:id="formula_2">d i = m i w i<label>(2)</label></formula><p>where n i and m i are the number of descriptor vectors of the query and database image, respectively, with a path through node i. A database image is then given a relevance score s based on the normalized difference between the query and database vectors:</p><formula xml:id="formula_3">s(q, d) = q q - d d .<label>(3)</label></formula><p>The normalization can be in any desired norm and is used to achieve fairness between database images with few and many descriptor vectors. We have found that L 1 -norm gives better results than the more standard L 2 -norm.</p><p>In the simplest case, the weights w i are set to a constant, but retrieval performance is typically improved by an entropy weighting like</p><formula xml:id="formula_4">w i = ln N N i , (<label>4</label></formula><formula xml:id="formula_5">)</formula><p>where N is the number of images in the database, and N i is the number of images in the database with at least one descriptor vector path through node i. This results in a TF-IDF scheme. We have also tried to use the frequency of occurrence of node i in place of N i , but it seems not to make much difference.</p><p>The weights for the different levels of the vocabulary tree can be handled in various ways. Intuitively, it seems correct to assign the entropy of each node relative to the node above it in the path, but we have, perhaps somewhat surprisingly, found that it is better to use the entropy relative to the root of the tree and ignore dependencies within the path. It is also possible to block some of the levels in the tree by setting their weights to zero and only use the levels closest to the leaves.</p><p>We have found that most important for the retrieval quality is to have a large vocabulary (large number of leaf nodes), and not give overly strong weights to the inner nodes of the vocabulary tree. In principle, the vocabulary size must eventually grow too large, so that the variability and noise in the descriptor vectors frequently move the descriptor vectors between different quantization cells. The trade-off here is of course distinctiveness (requiring small quantization cells and a deep vocabulary tree) versus repeatability (requiring large quantization cells). However, a benefit of hierarchical scoring is that the risk of overdoing the size of the vocabulary is lessened. Moreover, we have found that for a large range of vocabulary sizes (up to somewhere between 1 and 16 million leaf nodes), the retrieval performance increases with the number of leaf nodes. This is probably also the explanation to why it is better to assign entropy directly relative to the root node. The leaf nodes are simply much more powerful than the inner nodes.</p><p>It is also possible to use stop lists, where w i is set to zero for the most frequent and/or infrequent symbols. When using inverted files, we block the longer lists. This can be done since symbols in very densely populated lists do not contribute much entropy. We do this mainly to retain efficiency, but it sometimes even improves retrieval performance. Stop lists were indicated in <ref type="bibr" target="#b16">[17]</ref> to remove mismatches from the correspondence set. However, in most cases we have not been able to improve retrieval quality by using stop lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Implementation of Scoring</head><p>To score efficiently with large databases we use inverted files. Every node in the vocabulary tree is associated with an inverted file. The inverted files store the id-numbers of the images in which a particular node occurs, as well as for each image the term frequency m i . Forward files can also be used as a complement, in order to look up which visual words are present in a particular image.</p><p>Only the leaf nodes are explicitly represented in our implementation, while the inverted files of inner nodes simply are the concatenation of the inverted files of the leaf nodes, see Figure <ref type="figure">4</ref>. The length of the inverted file is stored in each node of the vocabulary tree. This length is essentially the document frequency with which the entropy of the node is determined. As discussed above, inverted files above a certain length are blocked from scoring.</p><p>While it is very straightforward to implement scoring with fully expanded forward files, it takes some more thought to score efficiently using inverted files. Assume that the entropy of each node is fixed and known, which can be accomplished with a pre-computation for a particular database, or by using a large representative database to determine the entropies. The vectors representing database images can then be pre-computed and normalized to unit magnitude, for example when images are entered into the database. Similarly, the query vector is normalized to unit magnitude. To compute the normalized difference in L pnorm it can be used that</p><formula xml:id="formula_6">q-d p p = i |q i -d i | p (5) = i|di=0 |q i | p + i|qi=0 |d i | p + i|qi =0,di =0 |q i -d i | p = q p p + d p p + i|qi =0,di =0 (|q i -d i | p -|q i | p -|d i | p ) = 2 + i|qi =0,di =0 (|q i -d i | p -|q i | p -|d i | p ),</formula><p>since the query and database vectors are normalized. This makes it possible to use inverted files, since for each non-zero query dimension q i = 0, the inverted file can be used to traverse the corresponding non-zero database entries d i = 0 and accumulate to the sum. The query is implemented by populating a tree representing the query. This both computes the query vector dimensions q i and sorts them. When using virtual inverted files, the database vector dimensions d i are further fragmented into multiple independent parts d ij such that d i = j d ij , where the values d ij come from the inverted files of the leaf nodes. For the case of L 2 -norm, Equation 5 simplifies further to</p><formula xml:id="formula_7">q -d 2 2 = 2 -2 i|qi =0,di =0 q i d i ,<label>(6)</label></formula><p>List List List List Virtual Virtual Virtual Figure <ref type="figure">4</ref>. The database structure shown with two levels and a branch factor of two. The leaf nodes have explicit inverted files and the inner nodes have virtual inverted files that are computed as the concatenation of the inverted files of the leaf nodes. which can easily be partitioned since the scalar product is linear in d i . For other norms, the situation is more complicated. The best option is then to first compose d i , which can be done by for each database image remembering which node i was last touched, and the amount of d i accumulated so far. The accumulated d i is then used in Equation <ref type="formula">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Results</head><p>The method was tested by performing queries on a database either consisting entirely of, or containing a subset of images with known relation. The image set with ground truth contains 6376 images in groups of four that belong together, see Figure <ref type="figure">5</ref> for examples. The database is queried with every image in the test set and our quality measures are based on how the other three images in the block perform.</p><p>It is natural to use the geometry of the matched keypoints in a post-verification step of the top n candidates from the initial query. This will improve the retrieval quality. However, when considering really large scale databases, such as 2 billion images, a post-verification step would have to access the top n images from n random places on disk. With disk seek times of around 10ms, this can only be done for around 100 images per second and disk. Thus, the initial query has to more or less put the right images at the top of the query. We therefore focus on the initial query results and especially how many percent of the other three images in each block are found perfectly, which is our default, quite unforgiving, performance measure.</p><p>Figure <ref type="figure">6</ref> shows retrieval results for a large number of</p><p>The images used in the experiments are available on the homepages of the authors. Figure <ref type="figure">5</ref>. The retrieval performance is evaluated using a large ground truth database (6376 images) with groups of four images known to be taken of the same object, but under different conditions. Each image in turn is used as query image, and the three remaining images from its group should ideally be at the top of the query result. In order to compare against less efficient non-hierarchical schemes we also use a subset of the database consisting of around 1400 images. settings with a 1400 image subset of the test images. The curves show the distribution of how far the wanted images drop in the query rankings. The points where a larger number of methods meet the y-axis are given in Table <ref type="table" target="#tab_0">1</ref>. Note especially that the use of a larger vocabulary and also L 1 -norm gives performance improvements over the Figure <ref type="figure">6</ref>. Curves showing percentage (y-axis) of the ground truth query images that make it into the top x percent (x-axis) frames of the query for a 1400 image database. The curves are shown up to 5% of the database size. As discussed in the text, it is crucial for scalable retrieval that the correct images from the database make it to the very top of the query, since verification is feasible only for a tiny fraction of the database when the database grows large. Hence, we are mainly interested in where the curves meet the y-axis. To avoid clutter, this number is given in Table <ref type="table" target="#tab_0">1</ref> for a larger number of settings. A number of conclusions can be drawn from these results: A larger vocabulary improves retrieval performance. L1-norm gives better retrieval performance than L2-norm. Entropy weighting is important, at least for smaller vocabularies. Our best setting is method A, which gives much better performance than the setting used by <ref type="bibr" target="#b16">[17]</ref>, which is setting T. settings used by <ref type="bibr" target="#b16">[17]</ref>.</p><p>The performance with various settings was also tested on the full 6376 image database. It is important to note that the scores decrease with increasing database size as there are more images to confuse with. The effect of the shape of the vocabulary tree is shown in Figure <ref type="figure">7</ref>. The effects of defining the vocabulary tree with varying amounts of data and training cycles are investigated in Figure <ref type="figure">8</ref>.</p><p>Figure <ref type="figure" target="#fig_4">10</ref> shows a snapshot of a demonstration of the method, running real-time on a 40000 image database of CD covers, some connected to music. We have so far tested the method with a database size as high as 1 million images, more than one order of magnitude larger than any other work we are aware of, at least in this category of method. The results are shown in Figure <ref type="figure" target="#fig_3">9</ref>. As we could not obtain ground truth for that size of database, the 6376 image ground truth set was embedded in a database that also contains several movies: The Bourne Identity, The Matrix, Braveheart, Collateral, Resident Evil, Almost Famous and Monsters Inc. Note that all frames from the movies are in the database, each as a separate image unrelated to the rest. This is in contrast to <ref type="bibr" target="#b16">[17]</ref>, where only 1Hz keyframes from two movies were used. The queries were run in RAM on a 8GB machine and take about 1 second each. Database creation (mainly feature extraction) took 2.5 days. Two search results with images that are not in the movies are shown in Figure <ref type="figure" target="#fig_5">11</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>A recognition approach with an indexing scheme significantly more powerful than the state-of-the-art has been presented. The approach is built upon a vocabulary tree that hierarchically quantizes descriptors from image  The most important case is where entropy is defined with video independent of the database. For comparison, the result of using the ground truth target subset of images is also shown.  keypoints. It was shown that retrieval results are improved with a larger vocabulary and with L 1 -norm in the image similarity definition. A real-time demonstration working with 40K images of CD covers was produced based on the approach, and second timing queries were shown on a 1M image database. These results make us hopeful that the approach may lead to an internet-scale content based image search engine.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. An illustration of the process of building the vocabulary tree. The hierarchical quantization is defined at each level by k centers (in this case k = 3) and their Voronoi regions.</figDesc><graphic coords="3,309.48,182.35,116.20,108.89" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Three levels of a vocabulary tree with branch factor 10 populated to represent an image with 400 features.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 7 .Figure 8 .</head><label>78</label><figDesc>Figure 7. Vocabulary tree shapes tested on the 6376 ground truth image set. Left: Performance vs number of leaf nodes with branch factor k = 8, 10 and 16. Right: Performance vs k for 1M leaf nodes. Performance increases significantly with number of leaf nodes, and some, but not dramatically with the branch factor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Performance with respect to increasing database size, up to 1 million images. The vocabulary tree was defined with video separate from the database. Results are shown for two different ways of defining the entropy weighting of the vocabulary tree. The most important case is where entropy is defined with video independent of the database. For comparison, the result of using the ground truth target subset of images is also shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. A snapshot of the CD-cover recognition running. With 40000 images in the database, the retrieval is still real-time and robust to occlusion, specularities, viewpoint, rotation and scale changes. The camera is directly connected to the laptop via firewire. The captured frames are shown on the top left, and the top of the query is displayed on the bottom right. Some of the CDcovers are also connected to music that is played upon successful recognition.</figDesc><graphic coords="8,54.84,317.11,226.93,104.21" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11.  Top: An example of searching the one million image database including all the frames of seven movies and 6376 ground truth images. Searching for a region-rich rigid object such as a CD-cover, book, building or location works quite well even for this size of database. The colosseum search easily finds the frames from a short clip in The Bourne Identity. However, searching for example on faces is less reliable. A lucky shot is shown on the bottom. This search was performed on a smaller database size of 300K frames. Both searches were performed with images separate from the movies.</figDesc><graphic coords="8,54.84,422.06,226.70,100.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="1,317.76,227.75,218.50,303.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="6,66.24,72.19,204.00,446.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Table showing percent of the queries that result in perfect</figDesc><table><row><cell>Me</cell><cell>En</cell><cell cols="2">No S%</cell><cell>Voc-Tree</cell><cell cols="2">Le Eb Perf</cell></row><row><cell cols="3">A y/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>1</cell><cell>ir 90.6</cell></row><row><cell>B</cell><cell cols="2">y/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>1</cell><cell>vr 90.6</cell></row><row><cell>C</cell><cell cols="2">y/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>2</cell><cell>ir 90.4</cell></row><row><cell cols="3">D n/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>2</cell><cell>ir 90.4</cell></row><row><cell>E</cell><cell cols="2">y/n L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>2</cell><cell>ir 90.4</cell></row><row><cell>F</cell><cell cols="2">n/n L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>2</cell><cell>ir 90.4</cell></row><row><cell cols="3">G n/n L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>1</cell><cell>ir 90.2</cell></row><row><cell cols="4">H y/y L1 m2</cell><cell>6x10=1M</cell><cell>1</cell><cell>ir 90.0</cell></row><row><cell>I</cell><cell cols="2">y/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>3</cell><cell>ir 89.9</cell></row><row><cell>J</cell><cell cols="2">y/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>4</cell><cell>ir 89.9</cell></row><row><cell cols="3">K y/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>2</cell><cell>vr 89.8</cell></row><row><cell>L</cell><cell cols="2">y/y L1</cell><cell>0</cell><cell>6x10=1M</cell><cell>2</cell><cell>ip 89.0</cell></row><row><cell cols="4">M y/y L1 m5</cell><cell>6x10=1M</cell><cell>1</cell><cell>ir 89.1</cell></row><row><cell cols="3">N y/y L2</cell><cell>0</cell><cell>6x10=1M</cell><cell>1</cell><cell>ir 87.9</cell></row><row><cell cols="3">O y/y L2</cell><cell>0</cell><cell>6x10=1M</cell><cell>2</cell><cell>ir 86.6</cell></row><row><cell>P</cell><cell cols="3">y/y L1 l10</cell><cell>6x10=1M</cell><cell>2</cell><cell>ir 86.5</cell></row><row><cell cols="3">Q y/y L1</cell><cell>0</cell><cell cols="2">1x10K=10K 1</cell><cell>-</cell><cell>86.0</cell></row><row><cell cols="3">R y/y L1</cell><cell>0</cell><cell>4x10=10K</cell><cell>2</cell><cell>ir 81.3</cell></row><row><cell>S</cell><cell cols="2">y/y L1</cell><cell>0</cell><cell>4x10=10K</cell><cell>1</cell><cell>ir 80.9</cell></row><row><cell>T</cell><cell cols="2">y/y L2</cell><cell>0</cell><cell cols="2">1x10K=10K 1</cell><cell>-</cell><cell>76.0</cell></row><row><cell cols="3">U y/y L2</cell><cell>0</cell><cell>4x10=10K</cell><cell>1</cell><cell>ir 74.4</cell></row><row><cell cols="3">V y/y L2</cell><cell>0</cell><cell>4x10=10K</cell><cell>2</cell><cell>ir 72.5</cell></row><row><cell cols="3">W n/n L2</cell><cell>0</cell><cell cols="2">1x10K=10K 1</cell><cell>-</cell><cell>70.1</cell></row></table><note><p><p><p><p><p><p><p>retrieval (where the various scoring methods meet the y-axis in Figure</p>6</p>). The settings plotted in Figure</p>6</p>are shown in bold. From left to right, the columns indicate Me: Scoring Method A-W, En: Entropy weighting used for query/database, No: Norm used for the normalized difference in Equation 3, S%: Percentage of visual words put on stop list (m-most frequent, l-least frequent), Voc-Tree: Shape of vocabulary tree (Nr levels L x branch factor k=Nr leaf nodes). Le: Nr of levels (starting from the leaf nodes) used in hierarchical scoring. Eb: Method for assigning entropy to nodes (i=image frequency or v=visual word frequency used to define Ni in Equation</p>4</p>, r=entropy assigned relative to root node or p=parent node. Perf: Performance in %.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>This work was supported in part by the National Science Foundation under award number IIS-0545920, Faculty Early Career Development (CAREER) Program.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reliable feature matching across widely separated views</title>
		<author>
			<persName><forename type="first">A</forename><surname>Baumberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="774" to="781" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Shape matching and object recognition using low distortion correspondence</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Localitysensitive hashing scheme based on p-stable distributions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Datar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Immorlica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mirrokni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Computational Geometry</title>
		<meeting>ACM Symp. on Computational Geometry</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="253" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Evaluation of local detectors on non-planar scenes</title>
		<author>
			<persName><forename type="first">F</forename><surname>Fraundorfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bischof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th workshop of the Austrian Association for Pattern Recognition</title>
		<meeting>28th workshop of the Austrian Association for Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="125" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The pyramid match kernel: Discriminative classification with sets of image features</title>
		<author>
			<persName><forename type="first">K</forename><surname>Grauman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Approximate nearest neighbors: Towards removing the curse of dimensionality. In 30th Ann</title>
		<author>
			<persName><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Symp. on Theory of Computing</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Randomized trees for realtime keypoint recognition</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lepetit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lagger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Shape-adapted smoothing in estimation of 3-d depth cues from affine distortions of local 2-d brightness structure</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lindeberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gårding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="389" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Distinctive image features from scale-invariant keypoints</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCV</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="91" to="110" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Robust wide baseline stereo from maximally stable extremal regions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Matas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Chum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pajdla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BMVC</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="384" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Scale and affine invariant interest point detectors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mikolajczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCV</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">60</biblScope>
			<biblScope unit="page" from="63" to="86" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A performance evaluation of local descriptors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mikolajczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PAMI</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1615" to="1630" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A comparison of affine region detectors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mikolajczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tuytelaars</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Matas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Schaffalitzky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kadir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V</forename><surname>Gool</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCV</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="43" to="72" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Sub-linear indexing for large scale object recognition</title>
		<author>
			<persName><forename type="first">S</forename><surname>Obdrzalek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Matas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BMVC</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Object modeling and recognition using local affine-invariant image descriptors and multi-view spatial contraints</title>
		<author>
			<persName><forename type="first">F</forename><surname>Rothganger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lazebnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ponce</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Accepted to IJCV</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Evaluation of interest point detectors</title>
		<author>
			<persName><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bauckhage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCV</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="151" to="172" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Video Google: A text retrieval approach to object matching in videos</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sivic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Matching widely separated views based on affine invariant regions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Tuytelaars</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V</forename><surname>Gool</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCV</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">59</biblScope>
			<biblScope unit="page" from="61" to="85" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
