<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Extending Access Control Models with Break-glass</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Achim</forename><forename type="middle">D</forename><surname>Brucker</surname></persName>
							<email>achim.brucker@sap.com</email>
							<affiliation key="aff0">
								<orgName type="laboratory">SAP Research Vincenz</orgName>
								<address>
									<addrLine>Priessnitz-Str. 1</addrLine>
									<postCode>76131</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Helmut</forename><surname>Petritsch</surname></persName>
							<email>helmut.petritsch@sap.com</email>
							<affiliation key="aff1">
								<orgName type="laboratory">SAP Research Vincenz</orgName>
								<address>
									<addrLine>Priessnitz-Str. 1</addrLine>
									<postCode>76131</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Extending Access Control Models with Break-glass</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">37B76F90364B0E8B35E6976750E6B600</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.6 [Software]: Operating Systems-Security and Protection security</term>
					<term>languages disaster management</term>
					<term>access-control</term>
					<term>break-glass</term>
					<term>model-driven security</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Access control models are usually static, i. e., permissions are granted based on a policy that only changes seldom. Especially for scenarios in health care and disaster management, a more flexible support of access control, i. e., the underlying policy, is needed.</p><p>Break-glass is one approach for such a flexible support of policies which helps to prevent system stagnation that could harm lives or otherwise result in losses. Today, breakglass techniques are usually added on top of standard access control solutions in an ad-hoc manner and, therefore, lack an integration into the underlying access control paradigm and the systems' access control enforcement architecture.</p><p>We present an approach for integrating, in a fine-grained manner, break-glass strategies into standard access control models and their accompanying enforcement architecture. This integration provides means for specifying break-glass policies precisely and supporting model-driven development techniques based on such policies.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Today's IT systems comprise a fine-grained access control mechanism based on complex policies. The strict enforcement of these policies, at runtime, always contains the risk of hindering people in their regular work. Thus, writing security policies is always a trade-off between the risk of unintentionally revealing secured data or operations and the benefit gained by using them. This is especially true in exceptional cases where, by definition, seldom used (and thus not well tested) processes are executed.</p><p>Motivated by use cases from the disaster management domain, the break-glass principle <ref type="bibr" target="#b1">[1]</ref> was introduced as one approach for resolving this conflict. Break-glass allows users to override access control decisions on demand. While originally introduced for applications in the disaster management <ref type="bibr" target="#b1">[1]</ref> and health care domain <ref type="bibr" target="#b22">[21]</ref>, break-glass is becoming more and more important for general IT systems. The implementation of recent legitimate regulations, especially in the financial world, like Basel II <ref type="bibr" target="#b4">[4]</ref> or Sarbanes-Oxley Act (SOX) <ref type="bibr" target="#b34">[32]</ref>, requires complicated dynamic access control policies <ref type="bibr" target="#b17">[16]</ref>. This increase in policy complexity, together with the overall increase in complexity of IT systems and the increasing requirement to protect sensitive resources in a world wide connected network, also increases the risk of preventing important, business related, processes. To reduce this risk, break-glass concepts are implemented in major business software, e. g., Virsa Firefighter for SAP or Oracle's Role Manager.</p><p>Usually, break-glass solutions are implemented by issuing temporary accounts that comprise more powerful access rights (e. g., "root" accounts) on one hand and a more detailed logging on the other hand. While this approach provides a clear separation of the regular policy and the emergency mode, it complicates the a priori analysis of the security policy being effective. This also resembles the traditional software engineering practice where the development of a design model (business logic) and a security model are treated as different tasks. As a consequence, security features are often built into an existing system in an ad-hoc manner during the system administration phase. While the underlying motivation of this practice, to desire a separation of concerns, is understandable, the conflict between security requirements and availability of services cannot be systematically analyzed and reasonably balanced in this approach. Solving this problem requires both an integration of break-glass into access control models and the integration of access control models into the early stages of the software development process. Such an integration into one unified methodology is necessary, ranging from the modeling over the implementation to the deployment and the maintenance phase of a system.</p><p>To meet this challenge, Basin et al. <ref type="bibr" target="#b6">[6]</ref> present a modeldriven approach which is built upon the SecureUML lan-guage. SecureUML provides a core security language for access control that can be easily combined with a system modeling language, e. g., UML class diagrams or UML statecharts. SecureUML allows to specify system models and security models within the same visual modeling tool. Moreover, SecureUML is supported by a security-aware modeldriven development process, called Model-driven Security (MDS). We extend both SecureUML and MDS with support for break-glass strategies.</p><p>Our contributions are four-fold: first, we present a generic break-glass model. Second, we present a SecureUML extension supporting break-glass. Third, we present a security architecture supporting break-glass and, finally, a transformation from break-glass SecureUML policies to XACML.</p><p>The rest of the paper is structured as follows: after introducing the preliminaries of our work in Section 2, we present a generic break-glass model which can be integrated into a large class of access control models in Section 3. In the same section, we also present, as an example for such an integration, an extension for SecureUML supporting break-glass. We present a security architecture supporting break-glass in Section 4. This architecture is the target of the transformation of break-glass SecureUML policies to XACML which we present in Section 5. Finally report on related work in Section 6 and present our conclusions in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>In this section, we introduce the technical background of our work: the break-glass principle and SecureUML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Break-glass</head><p>Introduced in <ref type="bibr" target="#b1">[1]</ref>, break-glass<ref type="foot" target="#foot_0">1</ref> refers to quick means for extending a person's access rights in exceptional cases. Usually, the usage of emergency access rights needs to be documented for later audits and reviews. Typically, a special audit trail is created to monitor such override access. Moreover, the regular access control policies should be established in a way minimizing the need for break-glass events.</p><p>Usually, break-glass solutions are based on pre-staged user accounts. On one hand, these user accounts need to be available in exceptional cases with reasonable administrative overhead and, on the other hand, misuse of these accounts should be prevented. Typically, a strategy for implementing the break-glass is comprised of the following steps <ref type="bibr" target="#b1">[1]</ref>:</p><p>1. Pre-staging break-glass accounts: Emergency accounts are created in advance to allow careful thought about the access control policies and audit trails associated with them. 2. Distributing pre-staged accounts needs to be carefully managed to provide timely access when needed: Breakglass requires the emergency accounts be made available in an appropriate and reasonable manner. The account details may be provided on media such as a printed page, a magnetic-stripe card, a smart card or a token.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Monitoring the use of break-glass accounts:</head><p>The use of emergency accounts needs to be carefully monitored. Audit mechanisms should be used and a procedure defined to examine the security audit trails on a regular basis to identify any use of the emergency accounts. In addition, systems can alert the security administrator in the event an emergency account is activated. 4. Cleaning up after break-glass: A procedure should be established to clean up after an emergency account has been used. Traditional break-glass solutions store such emergency accounts either completely electronically or printed on paper and, e. g., stored in a glass cabinet. In contrast, the integration of break-glass into the access control model we are suggesting makes pre-staging accounts unnecessary. And as such, solves the problems of creating and distributing such accounts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">SecureUML</head><p>SecureUML <ref type="bibr" target="#b6">[6,</ref><ref type="bibr">9]</ref> is a security modeling language based on a generalized Role-based Access Control (RBAC) <ref type="bibr" target="#b15">[14,</ref><ref type="bibr" target="#b33">31]</ref> model. SecureUML is defined using OMG's meta-modeling approach, i. e., the abstract syntax is given as MOF <ref type="bibr" target="#b24">[23]</ref> compliant meta-model. Figure <ref type="figure">1</ref> illustrates the meta-model of SecureUML and its abstract syntax. SecureUML supports notions of users, roles and permissions, as well as assignments between them: Users can be assigned to roles, and roles are assigned to specific permissions. Users acquire permissions through the roles they are assigned to. Moreover, users are organized into a hierarchy of groups, and roles are organized into a role hierarchy. In addition to this RBAC model, permissions can be restricted by Authorization Constraints (expressed in a language similar to OCL <ref type="bibr" target="#b25">[24]</ref>), which have to hold to allow access. Permissions specify which Role may perform which Action on which Resource. SecureUML is generic in that it does not specify the type of actions and resources itself. Instead, these are defined in the design modeling language which is then "plugged" into SecureUML as a SecureUML dialect. This dialect specifies exactly which elements of the design modeling language are protected resources and what actions are available on them. A dialect may also specify a hierarchy on these actions, so that actions, such as reading a class, can be expressed as lower-level actions, such as reading an attribute of the class or executing a side-effect-free method. Furthermore, a dialect specifies a default policy, i. e., whether access for a particular action is allowed or denied in the case that no permission is specified. Usually, and so did we in this paper, one specifies a default policy of deny to simplify the security specification.</p><p>Basin et al. <ref type="bibr" target="#b6">[6]</ref> present two SecureUML dialects: One for a component-based design modeling language, and one for a state-machine based modeling language. Due to limitations of space, we will not address the issue of dialect definitions further in this paper, and refer to <ref type="bibr" target="#b6">[6]</ref> for more details. Instead we will assume as given, without presenting in detail, a SecureUML dialect definition for UML class diagrams in the spirit of the ComponentUML dialect. This means that the dialect specifies classes, attributes and operations to be resources. The dialect also specifies, among others, the actions create, read, update, and delete on classes, read and update on attributes, and execute on operations.</p><p>Moreover, SecureUML is integrated into a Model-driven Engineering (MDE) toolchain <ref type="bibr">[9]</ref> supporting the design of SecureUML policies in the context of UML <ref type="bibr" target="#b26">[25]</ref> design models, the formal analysis of these models, and the transformation of these models into (executable) code and configuration for access control enforcement architectures. The SecureUML metamodel describes a language supporting users, roles and permissions, as well as assignments between them, e. g., Users can be assigned to roles, and roles are assigned to specific permission.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subject</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A GENERIC BREAK-GLASS MODEL</head><p>In this section, we present a generalized break-glass solution that can integrate various access control models. In more detail, we provide an approach of break-glass that is based on the notion of emergency levels which allow a finegrained control of policies (rules) that can be overridden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Emergency Levels</head><p>Compared with traditional break-glass approaches based on pre-staged accounts, our break-glass approach provides:</p><p>1. The ability to override access-control decisions on a per permission basis and not on a per role or per subject basis, 2. Several levels of emergency providing a classification on the kind of violation with respect to the regular policy. This classification can be used, for example, for informing users about their actions or for a finegrained run-time configuration which kind of violations are currently tolerated. In the following, we assume an access control model A in which an access control policy p is represented. A policy maps access control relevant information, e. g., subjects, resources, actions, and context information to an access control decision, e. g., deny or allow. In particular, we do neither restrict the expressiveness nor the structure of the policies.</p><p>As a prerequisite of introducing emergency levels, we need to introduce a notion of refinement of access control policies. Similar to trace refinement of CSP <ref type="bibr" target="#b32">[30]</ref>, we define: Definition 1. A policy p refines a policy p (written p p ) if and only if the set of system traces that are allowed under p is a subset of the system traces that are allowed under p .</p><p>Informally, a policy p refines a policy p if and only if p is at least as restrictive as p . We write p for the policy that allows all actions and p ⊥ for the policy that allows no action. The relation _ _ defines a partial order on a set of policies where p ⊥ refines all policies and every policy is a refinement of p . Therefore, (PA, , p ⊥ , p ) is a lattice, where PA be the set of all policies of the access control model A.</p><p>We refer to the regular policy, i. e., the policy that should be obeyed in normal operations, as p reg and we refer to the set of policies that are refined by the regular policy, i. e.,</p><formula xml:id="formula_0">LA = {p | p ∈ PA ∧ p reg p ∧ p = p reg }</formula><p>as emergency levels or emergency policies of the policy p reg . We require that (PA\p ⊥ , , p reg , p ) is a lattice, i. e., inf(PA\ p ⊥ ) = p reg . At runtime, an emergency level can be active or inactive and only active emergency levels contribute to the access control decision. Obviously, the regular policy is always active.</p><p>An access that is only granted by an emergency policy ∈ LA (i. e., the regular policy evaluates to "deny" for this access) is called override access. Such an override access is granted if and only if there is an active policy ∈ LA allowing this access. As we will discuss later, an interactive confirmation for applying the override access can be required from the end user.</p><p>Overall, a system can have several regular sub-policies active at the same time (e. g., addressing different business divisions). In these cases, we require that the different policies are disjoint, i. e., for a given request the corresponding policy can be efficiently determined. For simplifying the presentation, we assume in the rest of this paper, that there is only one, uniquely defined, p reg .</p><p>Finally, obligations can be attached to an (emergency) policy. Examples for such obligations are logging requirements that allow the a-posteriori audit of override accesses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Implementing Break-glass</head><p>Implementing break-glass based on emergency levels instead of using special accounts allows a dynamic adaption of the current system policy and requires only little support from the underlying access control model. In more detail, we propose the following workflow:</p><p>• First, we derive the regular policy p reg without taking break-glass situations into account, • Second, we derive the set LA of emergency policies together with a hierarchy of these policies from the domain requirements, • Finally, a special policy is defined, describing the subjects allowed to activate and de-activate emergency policies during runtime. Depending on the actual access control model and enforcement architecture, the policy describing the activation of emergency policies can be integrated into the regular policy p reg . To ease analysis of the access control specification, we prefer to treat it, conceptually, as a separate policy.</p><p>As we understand the hierarchy of emergency policies as a requirement that is derived from the application domain, we enforce the desired refinement relation by a policy-level combining algorithm. For this, we sort all policies in topological order based on the refinement relations. The policy-level combining algorithm evaluates a given access request on all active policies. If all policies deny the request, the algorithm also denies the request. If at least one active policies allows the request, the policy combining algorithm returns the first allow (with respect to the topological sorting) together with the obligation attached to the corresponding policy. This construction obviously ensures the required refinement relation and prefers emergency policies with minimal distance to the regular policy and thus, avoid the need for special- ized algorithms for combining obligations, as, for example, developed by Alqatawna et al. <ref type="bibr" target="#b2">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Permission</head><p>As our refinement notion is only a partial order on the set of policies, the result of the topological sorting is not uniquely defined, i. e., if two active emergency policies allowing the actual request are equidistant from the regular policy, it depends on the implementation which one is chosen (and thus, which obligations are returned together with the policy evaluation result). This ambiguity arises, if two policies, equidistant from the regular policy, define rules for the same target, but require different obligations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Break-glass for SecureUML</head><p>For supporting our notion of break-glass, SecureUML is mainly missing the notion of expressing a hierarchy of exception levels. As exception levels can be directly represented by policy sets, we extended the SecureUML metamodel with means for expressing hierarchy of policies (where a SecureUML policy is a set of permissions).</p><p>Figure <ref type="figure" target="#fig_0">2</ref> illustrates the extension with respect to the original SecureUML metamodel (see Figure <ref type="figure">1</ref>). First, our extension introduces the concept of policies, i. e., a set of permissions. Second, policies can be organized into a hierarchy and every policy can be associated to obligations. Here, an obligation describes a requirement (e. g., log all upcoming actions with a certain level of detail) that the system must fulfill whenever a permission of the policy grants access.</p><p>SecureUML provides a concrete syntax based on UML class diagrams using a UML profile consisting of custom stereotypes. Users, Groups and Roles are represented by classes with stereotypes «secuml.user», «secuml.group», and «secuml.role» (Figure <ref type="figure" target="#fig_4">3</ref>). Assignments between them are represented by ordinary UML associations, whereas the role hierarchy is represented by a generalization relationship. Permissions are represented as association classes with the stereotype «secureuml.permission» connecting the role and a permission anchor. The attributes of the association class specify which action (the attribute's type) on which resource (the attribute's name) is permitted by this permission. Authorization constraints are constraints attached to the association class. Attributes or operations on roles as well as operations on permission have no semantics in SecureUML and are therefore not allowed in the UML notation. We extend this notation with a policy hierarchy. Policies are represented by UML classes with stereotype «secuml.policy» and the hierarchy is represented as a generalization relationship, similar to the role hierarchy of SecureUML. Finally, we support obligations (represented by UML classes with stereotype «secuml.obligation») on a per policy basis, i. e., we can assign a set of obligations to every policy.</p><p>Figure <ref type="figure" target="#fig_4">3</ref> shows a small example of a system design in UML (i. e., ComponentUML) annotated with an access control policy with break-glass permissions. The design model describes the relation between a MedicalRecord and the Patient who owns the record. The role-based access control model consists of a role hierarchy and two permissions. In more detail, we have a role for regular users (UserRole) and another role for the system administrator AdministratorRole. The latter inherits all permissions of regular users. The regular, i. e., non-emergency, policy p reg allows only the owner to update and delete his MedicalRecord. This requirement is expressed by an additional constraint attached to the permission OwnerMedicalRecord.</p><p>This regular SecureUML policy is extended by two exemplary emergency levels (LowEmergencyLevel and HighEmer-gencyLevel) and emergency permission EmergenyOwnerMed-icalRecord allowing every user to read any MedicalRecord. For example, this emergency permission allows everyone to check the medication of a patient in an emergency situation.</p><p>For simplicity reasons, we omit the obligations attached to the emergency levels in this example. Such obligations are represented as classes that are associated to a policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A BREAK-GLASS ARCHITECTURE</head><p>In this section, we present an access control enforcement architecture supporting our notion of break-glass. First, we introduce an abstract view of the architecture and, second, we discuss an exemplary system architecture implementing break-glass access control.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Standard Enforcement Architectures</head><p>Figure <ref type="figure" target="#fig_2">4</ref> shows a common architecture for enforcing access control policies. Such an architecture is usually comprised of the following components: PDP: The Policy Decision Point (PDP) manages the policies (e. g., written in XACML <ref type="bibr" target="#b23">[22]</ref> or PERMIS <ref type="bibr" target="#b12">[11]</ref>) and evaluates the policy for concrete access requests. Some implementations provide further services such as • a context provider providing information about the environment to the PDP, e. g., the current system time or a list of currently logged in users. • support for obligations that are specified in the policy and must be enforced by the Policy Enforcement Point (PEP). Examples for such obligations are raising log level or sending a notification to the administrator. PEP: The Policy Enforcement Point (PEP) is usually directly linked to the protected resource (e. g., as a library running within the same process). The PEP is responsible for querying the PDP and the enforcement of the returned access decisions. Moreover, if the answer from the PDP includes obligations, the PEP has to ensure that the system obeys them. Protected Resources: Examples of protected resources are services, business processes, function calls, and files.</p><p>All accesses to such resources must be executed via the PEP which enforces the decisions of the PDP. UI: The User Interface (UI) is responsible for informing the user about access restrictions that concern his interactions with the system. The workflow in Figure <ref type="figure" target="#fig_2">4</ref> resembles a client requesting access to a resource <ref type="bibr" target="#b1">(1)</ref>. The PEP queries the PDP (2), which evaluates the policies. The access decision is returned to the PEP (3), which enforces the result. Either the result of the executed action or an according permission denied message is returned to the client (4). User authentication is an orthogonal problem which can be treated separately. Within our implementation, the client authenticates itself by passing a security token to the verifying PEP; whereas a single-sign-on engine provides a security token for the client and verifies this token for the PEP. The (existing) PDPs are (without modifying them) encapsulated by a break-glass PDP. Such a break-glass PDP provides the interface to the PEPs, uses the emergency policy manager to evaluate the request on the active emergency policies, and executes the policy combination algorithm on the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Break-Glass Enforcement Architecture</head><p>The emergency policy manager is responsible for executing the policy-level combining algorithm based on the active emergency levels and providing an interface to activate and deactivate emergency levels. The means for activating or deactivating emergency is, usually, also subject to access control.</p><p>By integrating the policy-level combining algorithm and the emergency policy manager, we achieve two crucial properties of our approach. First, the policy refinement is given by construction, i. e., there is no need to formally analyze the emergency policies. As such, it is guaranteed that access rights are never "lost" when activating a higher emergency level. Second, the policies can be considered as black boxes, i. e., they can be used without modification. Although, in a concrete implementation, it is reasonable to exploit features of the used policy language.</p><p>This architecture can be extended stepwise with support for obligations and support for user confirmations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Obligation Support.</head><p>Supporting obligations requires both the support of obligations in the (break-glass) PDP and in the PEP (Figure <ref type="figure" target="#fig_2">4</ref>, step (3)). Moreover, break-glass accesses may need to be monitored for later evaluation, i. e., logged (e. g., with additional information such as emergency level used, justification provided by the user, etc.) to a secure medium in a format suitable for later evaluation and approval.</p><p>The obligations defined for an emergency level are, as part of the access decision, returned to the PEP. The PEP has to ensure that all obligations are fulfilled. If the compliance to all obligations is not possible, the access decision has to be treated as a deny. Thus, access control frameworks implementing break-glass techniques with support for, e. g., extended logging have to support obligations (or a comparable mechanism which ensures the execution of access restrictions by the PEP).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>User Confirmation.</head><p>Implementations of break-glass may require the user to confirm an override access, for example, in cases where only the user can decide if an access is legitimate or not. Usually, even for experienced users it is not self-evident which actions are justifiable and which are not. Therefore, the system should give him or her the information required to decide what exactly he or she is not permitted to do, why he or she is not permitted to do so, and what the possible consequences (risks) of overriding the access control are.</p><p>Overall, break-glass should be part of the (normal) work process: if a user tries to access a resource he or she is, under normal circumstances (i. e., under policy p reg ), not permitted to, but an (active) emergency level ( ∈ LA) could grant access, he should be informed about the denied permission and the possibility to override access. If the user is willing to take the risk and is sure his access is legitimate, he has to confirm the break-glass access. The intuition of a breakglass policy requiring a user confirmation is: "the user is permitted to access the resource, if he is willing to accept that he is overriding his normal competences and willing to accept the responsibilities in case of misuse."</p><p>In cases not requiring a user confirmation (e. g., a crises management system being more permissible during a major disaster), no such obligation is attached to the corresponding emergency level.</p><p>For supporting user confirmation, the PEP requires access to the UI. If the PEP receives a user conformation obligation in step (3), the PEP accesses the user interface in step (3) and informs the user about the denied permission and the possibility to override access. If the user confirms that the access is justifiable, the UI delivers a confirmation as part of the response in step (3b). This message may contain further (obligated) information, e. g., a justification message from the user. If the user confirms the override access and the PEP is able to enforce all other obligations, in step 4 the result of the access is returned to the client. If the user does not confirm the override, the PEP returns a "permission denied" message back to the client.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">MODEL TO CODE TRANSFORMATION</head><p>In this section, we first present an encoding of breakglass policies in XACML and, second, we present a codegeneration for both the security model and the design model given as SecureUML model.</p><p>For our implementation, we restrict ourselves to a twovalued OCL-like language for specifying SecureUML permission constraint, i. e., we only support</p><p>• calls to public attributes and the result of calling sideeffect-free public operation of the current resource (object), • the special SecureUML keyword caller referring to the subject executing an action, • a limited set of functions for comparing values, e. g., _ = _, _ &lt;= _, _ &lt; _, and • the Boolean operations _ and _, _ or _, and _ not _.</p><p>In particular, we do not support recursive OCL expressions and iterator-based expressions like -&gt;forAll( _ | _ ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Encoding Break-glass in XACML</head><p>XACML <ref type="bibr" target="#b23">[22]</ref> is a widely used access control language that is supported by freely available frameworks, e. g., an open source XACML PDP is provided by Sun (http://sunxacml. sourceforge.net/). In particular, XACML has a built-in support for obligations and context providers, which simplifies the implementation of our break-glass architecture.</p><p>For mapping break-glass SecureUML to XACML we need to implement (partially) the Emergency Policy Manager and provide a mapping of SecureUML elements (e. g., permissions, roles) to XACML. In more detail:</p><p>• We need to implement an Emergency Policy Manager:</p><p>implementing a persistence layer that allows for storing and updating the set of active emergency levels and provides the set of active emergency levels to the XACML PDP implementing an externally accessible interface to activate and deactivate emergency levels, protected by an internal policy As XACML supports sets of policies and the (userconfigurable) combination thereof as built-in, this minimal infrastructure is sufficient.</p><p>• For mapping the core SecureUML constructs to XACML and Java, we follow the presentation in <ref type="bibr" target="#b6">[6]</ref>. In particular, we need to map OCL-like formulae to XACML (the required attributes for the formulae evaluation are provided in the XACML request from the PEP) and to expand the role hierarchy similar to the approach taken in <ref type="bibr" target="#b6">[6]</ref> for the EJB platform. Thus, all permissions belonging to the regular policy will be mapped on the "top" policy of the policy set, followed by the rules belonging to the first emergency level. Therefore, the policy combining algorithm "firstapplicable," which is provided by standard XACML can be used for evaluating the policy. We generate policies for an arbitrary XACML PDP (we only require the corresponding context provider). The XACML policies generated by our framework are only based on the standard XACML tool set, i. e., no extensions of the language are required. The policy, defining the access control for the Emergency Policy Manager, can be specified in SecureUML itself. Thus, the access controls required for updating the set of active emergency levels is also generated automatically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Code Generation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Generating XACML Policies</head><p>Listing 1 shows the policy for the MedicalRecord from Figure <ref type="figure" target="#fig_4">3</ref>, using a reduced form of XACML: for simplifying the presentation, we removed namespaces, shortened attribute names and values, eliminated empty target, subject (role), resource, and action declarations, and simplified condition and obligation definitions (e. g., the Target definition in line 2 does not contain a subject or action definition and is therefore reduced to the Resource definition).</p><p>The PolicySet generated for every UML class is saved in a separate policy file. If the permissions of one class are altered, only the file for this class has to be updated. The Target definition of the policy set matches the UML class (line 2-4). All permissions defined for this class are con-</p><formula xml:id="formula_1">&lt; PolicySet PolicyCombAlg = " first -applicable " &gt; &lt; Target &gt; &lt; Resource &gt; MedicalRecord &lt;/ Resource &gt; &lt;/ Target &gt; &lt; Policy RuleCombAlg = " first -applicable " &gt; &lt; Rule Effect = " Permit " &gt; &lt; Target &gt; &lt; Role &gt; UserRole &lt;/ Role &gt; &lt; Action &gt; update &lt;/ Action &gt; &lt;/ Target &gt; &lt; Condition FunctionId = " string -equal " &gt; &lt; Attribute &gt; subject &lt;/ Attribute &gt; &lt; Attribute &gt; owner . name &lt;/ Attribute &gt; &lt;/ Condition &gt; &lt;/ Rule &gt; &lt; Rule Effect = " Permit " &gt; &lt; Target &gt; &lt; Role &gt; UserRole &lt;/ Role &gt; &lt; Action &gt; write &lt;/ Action &gt; 20 &lt;/ Target &gt; &lt; Condition FunctionId = " string -equal " &gt; &lt; Attribute &gt; subject &lt;/ Attribute &gt; &lt; Attribute &gt; owner . name &lt;/ Attribute &gt; &lt;/ Condition &gt; &lt;/ Rule &gt; &lt; Policy &gt; &lt; Policy RuleCombAlg = " first -applicable " &gt; &lt; Rule Effect = " Permit " &gt; &lt; Target &gt; &lt; Role &gt; UserRole &lt;/ Role &gt; &lt; Action &gt; read &lt;/ Action &gt; &lt;/ Target &gt; &lt; Condition &gt; Low Eme rge ncyL eve l &lt;/ Condition &gt; &lt;/ Rule &gt; &lt; Obligation Id = " log " FulfillOn = " Permit " &gt; 35 &lt; LogLevel &gt; DEBUG &lt;/ LogLevel &gt; &lt;/ Obligation &gt; &lt; Obligation Id = " confirm " FulfillOn = " Permit " &gt; &lt; EmergencyLevel &gt; Low Eme rge ncyL eve l &lt;/ EmergencyLevel &gt; &lt;/ Obligation &gt; 40 &lt;/ Policy &gt; &lt; Policy &gt;</formula><p>&lt; Rule Effect = " Deny " / &gt; &lt; Policy &gt; &lt;/ PolicySet &gt; Listing 1: A break-glass PolicySet: default policy, policy for the LowEmergencyLevel with confirmation and log obligation, and final deny policy tained in this policy set, so the target matches to AnySubject and AnyAction.</p><p>The policy set contains the default policy (line 5-25), the emergency policies ordered by the hierarchy of emergency levels (line 26-40), and the final deny policy (line 41-43). If an emergency level does not define any permission for the UML class defined by the policy set, the complete policy describing this emergency level can be left out (e. g., no Policy for HighEmergencyLevel in Listing 1 as no permission is assigned to this emergency level in Figure <ref type="figure" target="#fig_4">3</ref>). The policies match the same resource as the policy set, thus, we do not need to restrict the target of the policies.</p><p>Attached to the emergency policy is the log obligation (line <ref type="bibr" target="#b36">[34]</ref><ref type="bibr" target="#b37">[35]</ref> and the user confirmation obligation (line 36-39). The definition of the emergency level is attached to the rule (line 27-33) as a condition (line 32).</p><p>Additionally to the policy set for every UML class, the policy for the emergency policy manager is generated (which has to be modeled in SecureUML with OCL constraints). The generated files are imported into a prepared PDP, which provides the emergency policy manager, protected by the generated policies. Either a jar file is generated, which can be integrated in any environment, or a war file, which can be deployed in a servlet container (providing the interfaces as web service).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>public interface UserContext { // returns a u t h e n t i c a t i o n i n f o r m a t i o n AuthnInfo getAuthn (); }</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Generating Java</head><p>In our presentation of the code generation, we focus on the break-glass concepts effecting the PEP and the communication with the PDP. The dependencies of the PEP to the environment are represented by context interfaces (Listing 2): the UserContext interface helps to abstract from the authentication mechanism (i. e., the authentication technique used in the target application must be encapsulated by a class implementing this interface). The ObligationContext interface is used to provide the implementation of obligations for the PEP. For example, the UIContext interface helps to acquire the confirmation from the user (i. e., this interface must be implemented by a UI class if user confirmation obligations are used).</p><p>For our implementation, we use a simple Java based user interface which implements the UIContext interface and authenticates the user at the startup of the application. As the source files of our model are generated, the code accessing the PEP is directly integrated into the Java source files of the entities (Listing 3). The PEP itself is a Java API which is attached as a jar file to the compiled class files. Of course, the PEP API can be used for any (manual, non-generated) implementation.</p><p>The PEP is the representation of the Policy Enforcement Point which is initialized at application startup and available for every class by singleton. It is part of an API and therefore not generated. During the initialization of the pep, the dependencies to the environment must be resolved, depending on the used obligations, e. g., a valid UIContext object for user confirmation obligations. For further obligations (e. g., logging), a key-value pair of ObligationId and implementing ObligationContext interface must be provided (supporting the obligation, identified by an ObligationId).</p><p>The PEP is responsible for resolving the required attributes for the evaluation of the OCL formulae associated with the evaluated permission (e. g., the "owner name" from this, passed as first parameter to the PEP.update() function). As both the resolving code and the policies for the PDP </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>The problem of access control unable to handle exceptional situations has been known for at least ten years <ref type="bibr" target="#b7">[7]</ref>. One solution is to pre-stage accounts, permitted to access more sensitive resources. These accounts (e. g., username/password pairs) are kept in sealed covers or protected by glass panels, which have to be broken in case of emergency <ref type="bibr" target="#b1">[1]</ref>. Similar approaches are implemented by commercial GRC solutions, e. g., Virsa Firefighter for SAP or Oracle's Role Manager.</p><p>Optimistic security <ref type="bibr" target="#b28">[27]</ref> and a posteriori compliance control <ref type="bibr" target="#b14">[13]</ref> delay the access control after access by providing an infrastructure which allows securely auditing and rolling back in case of a denied access, focusing on risks of not granting privileges <ref type="bibr" target="#b27">[26]</ref>. Similarly, risk-based access control models, e. g., <ref type="bibr" target="#b13">[12]</ref>, are based on risk or models. This allows for integrating the risk of granting access into the access control decision. While this usually results in a more flexible access control decision, we see these techniques as a concept being orthogonal to break-glass. As such, both concepts may benefit from each other. For example, estimating the risk of different emergency levels could, by allowing different risk classes depending on the current emergency level, minimize the need for user confirmations within emergency situations.</p><p>Existing work using the term break-glass <ref type="bibr" target="#b1">[1]</ref> implements break-glass in an ad-hoc, application specific manner on top of the underlying access control mechanism. Ferreira et al. <ref type="bibr" target="#b16">[15]</ref> implement the break-glass mechanism in the source code of the business logic, i. e., the decision is not defined in a policy but directly in the accessed entity. Longstaff et al. <ref type="bibr" target="#b22">[21]</ref> focus on a specific health care application with an application specific authorization mechanism.</p><p>Stevens et al. <ref type="bibr" target="#b35">[33]</ref> distinguish in the point of time when permissions are defined: ex-ante (before access), uno-tempore (during access), and ex-post (after access). Rissanen et al. <ref type="bibr" target="#b29">[28]</ref> combine this with Access Control Spaces <ref type="bibr" target="#b20">[19]</ref> and propose a model which has, additional to permit and deny, a further access decision: possibility-with-override, allowing the user to override the access restrictions. Furthermore, Rissanen et al. <ref type="bibr" target="#b31">[29]</ref> describe a technique called Authority Resolution (finding, with a given override and the XACML policy, a person who is in position to approve the override).</p><p>Based on the work of Rissanen et al. <ref type="bibr" target="#b29">[28,</ref><ref type="bibr" target="#b31">29]</ref>, Alqatawna et al. <ref type="bibr" target="#b2">[2]</ref> present an approach for overriding access control in XACML with obligations. They introduce a specific type of obligation, override-obligation, and, in addition to the effects-combining algorithms in standard XACML, an obligations-combining algorithm to be able to distinguish between normal and override obligations. Thus, if a permit rule is available, no possible-with-override rule is used.</p><p>A more universal approach, related to break-glass, is to make the decision process more flexible, thus expanding the expressiveness of rules and its describing language (such as Generalized Temporal RBAC <ref type="bibr" target="#b21">[20]</ref>, context aware RBAC <ref type="bibr" target="#b36">[34,</ref><ref type="bibr" target="#b19">18]</ref>). For example, XACML allows to take the environment into concern (such as system time, or physician-injured ratio). Alam et al. <ref type="bibr" target="#b18">[17]</ref> model pre-defined conditions which have to be true before break-glass access is permitted, e. g., during an emergency visit. These concepts help to define more accurate policies, but also raise complexity-"a wide variety of access control models have the expressive power to represent almost arbitrary policies, few are ever used by others due to their complexity" <ref type="bibr" target="#b20">[19]</ref>.</p><p>A further approach to temporarily increase access rights is delegation <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b37">35]</ref>. There are major analogies: different delegation approaches have to solve the question which rights are delegated; i. e., the rights to access a function or the rights to access the resources, this function will work on. As for delegation the delegate should only delegate a task one time (and not be asked again, if an additionally required permission should be granted), even in the case of break-glass policies the user should break the glass only once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">DISCUSSION AND FUTURE WORK</head><p>We presented an access control model agnostic approach for implementing break-glass policies. As an example for the integration of our approach into an existing access control model, we extended SecureUML with our notion of breakglass. This extension is the basis for a model-driven development approach supporting role-based access control policies with break-glass. In particular, our approach supports the generation of break-glass SecureUML policies for a concrete security architecture based on Java and XACML.</p><p>Compared with existing solutions, we avoid the need for special accounts which cause additional administrative overhead and are also an additional security threat (e. g., due to loss or theft of the pre-staged accounts). Moreover, our approach integrates means for monitoring and logging the usage of emergency rights using obligations.</p><p>In this paper, we assume that in emergencies the rights of subjects are extended (i. e., they have at least their normal rights); in fact, our notion of break-glass guarantees this property by construction (instead of requiring a formal proof). While, for example, this is a strict requirement in the disaster management or health-care domain, there are applications where the opposite behavior is required. For these situation, extend our model by the set L deny A of policies that refine the regular policy</p><formula xml:id="formula_2">L deny A = {p | p ∈ PA ∧ p p reg ∧ p = p reg }</formula><p>and adapt our construction accordingly, i. e., an access is only granted, if it is granted by the regular policy and not denied by any active emergency polices.</p><p>Although we implemented our approach using XACML (and exploiting its support for obligations and generic policy combining algorithms), our approach can be transferred to a large class of policy languages. First, by using an external emergency policy manager and extending, if necessary, the PEP with support for obligations, our notion of breakglass can be added on top of arbitrary policy languages and frameworks. Optionally, users can be asked for confirmations. For supporting such confirmations, the PEP needs to be integrated in the user interface. Notably, the policy combination algorithms and obligation support can be encapsulated in the emergency policy manager. Second, the core idea of our notion of break class, i. e., a hierarchy of policies with a partial order can be encoded directly in many policy languages. Recall our running example (see Figure <ref type="figure" target="#fig_4">3</ref>); for example for Prolog-like languages like Datalog, we can write re adM edic alR eco rd (P , medicalRecord )</p><p>: -role (P , userRole ) , owner ( P ). re adM edic alR eco rd (P , medicalRecord )</p><p>: -role (P , userRole ) , emergencyLevel ( low ).</p><p>for modeling that in emergency cases not only the owner of a medical record is allowed to read it. Similarly, by extending XACML with an additional "emergency level" attribute for Policy elements, the ordering of the emergency levels can be done by an additional component within the PDP.</p><p>Our approach provides means for specifying a fine-grained hierarchy of emergency policies together with a policy restricting the activation and deactivation of the emergency policies. A fine-grained policy hierarchy is a prerequisite for both a careful monitoring and for providing detailed feedback to the user. Nevertheless, for practical reasons the policy the activation and deactivation of emergency policy should be coarse-grained, i. e., most emergency levels should be active by default. Otherwise, the set of subjects that are able to activate the emergency levels are becoming a bottle-neck. Such activation of emergency levels can also be implemented without user intervention, based on context information such as time, monitoring information, or sensor values. For example, a hospital could, automatically, increase the set of activated emergency levels on weekends where only a reduced number of doctors is on duty.</p><p>We see several lines of future research motivated by the integration of break-glass support into traditional access control models. On the practical side, we see the need for better means of informing users about the effect of overriding regular policies.</p><p>On the analytical side, we plan to extend existing analysis methods for SecureUML <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b10">10]</ref> to our extension of SecureUML. The (formal) access control specification with different emergency levels should also allow for a more detailed and automated post-mortem analysis techniques and information flow across emergency levels.</p><p>While our approach for supporting break-glass is, in principle, access control model agnostic, extending systems based on data labeling, e. g., Bell-LaPadula, with break-glass needs to be investigated in more detail. Moreover, a classification of long-living vs. short living data (or different abstraction level of data) could simplify the audit, i. e., the post-mortem analysis. This could result in combinations of role-based access control and approaches based on data-labeling.</p><p>Finally, support for dynamic (i. e., additional checks at runtime are necessary) access control specifications like sep-aration of duty or binding of duty has to be developed. Integrating such dynamic requirements into a break-glass framework makes a controlled transition from an exception level to normal behavior particular challenging. Of course, static (i. e., properties that can be ensured statically by the policy set) separation of duty or binding of duty constraints are supported by our framework.</p><p>The concrete (UML-based) syntax of SecureUML is quite lengthy. For working with large models, an integration of SecureUML concepts into a CASE tool is available <ref type="bibr" target="#b8">[8]</ref>. This extension allows for directly specifying access control within the GUI of ArgoUML. This extension needs to be extended for supporting our SecureUML extension, i. e., a notion of policies and obligations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Extending SecureUML with support for break-glass support requires only means for expressing a hierarchy of policies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: An example of a SecureUML policy for medical records utelizing our extension for supporting policy hierarchies. In particular, allowing every user to read patient data in case of an emergency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4</head><label>4</label><figDesc>Figure4illustrates the required extension for supporting our notion of break-glass on top of a standard access control architecture. The optional, expanding extensions are used for obligations and user confirmation.The (existing) PDPs are (without modifying them) encapsulated by a break-glass PDP. Such a break-glass PDP provides the interface to the PEPs, uses the emergency policy manager to evaluate the request on the active emergency policies, and executes the policy combination algorithm on the results.The emergency policy manager is responsible for executing the policy-level combining algorithm based on the active emergency levels and providing an interface to activate and deactivate emergency levels. The means for activating or</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>5 10 /Listing 2 :</head><label>102</label><figDesc>public interface O b l i g a t i o n C o n t e x t { ObligResult fulfill ( Obligation obligation ); } public interface UIContext extends O b l i g a t i o n C o n t e x t { / confirm override -access by the user C o n f i r m a t i o n R e s u l t confirm ( Obligation c o n f i r m O b l i g a t i o n ); } PEP Context Interfaces: supplying the PEP with environment related authentication information and obligation implementations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Listing 3 :</head><label>3</label><figDesc>public class MedicalRecord { private static PEP pep ; // model related class -v a r i a b l e s public void update ( MedicalRecord record ) { } } A generated Java class, using a PEP are generated from the same source (i. e., the SecureUML model), only the required attributes are passed to the PDP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>•</head><label></label><figDesc>Permissions from the SecureUML model are mapped to XACML permit rules. As our mapping only uses permit rules within one policy (i. e., in each emergency policy and in the regular policy), we can use the "firstapplicable combining algorithm" for joining the rule sets into one policy.• Obligations are, as defined by the model, assigned to policies. • In case of XACML, it is not necessary to implement a custom policy level combining algorithm. Instead, we can re-use the XACML infrastructure and resolve the ordering during the model-to-code transformation. In</figDesc><table /><note><p>particular, for each class of the design model, we generate a policy set (XACML element PolicySet) containing the permissions (Rule) assigned to emergency policies (Policy) for this class ordered with respect to the topological sorting of the emergency policies.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The term "break-glass" is derived from fire alarms that require breaking a glass cover for triggering an alarm.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We would like to thank Adam J. Lee and the anonymous referees for helpful comments on the paper.</p><p>This work has been supported by the German "Federal Ministry of Education and Research" in the context of the project "SoKNOS." The authors are responsible for the content of this publication.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Break-glass: An approach to granting emergency access to healthcare systems</title>
	</analytic>
	<monogr>
		<title level="m">Joint NEMA/COCIR/JIRA Security and Privacy Committee (SPC)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>White paper</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Overriding of access control in XACML</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alqatawna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rissanen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sadighi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY)</title>
		<meeting>the Eighth IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY)<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="87" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Framework for role-based delegation models</title>
		<author>
			<persName><forename type="first">E</forename><surname>Barka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sandhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Computer Security Applications Conference</title>
		<meeting>the 16th Annual Computer Security Applications Conference<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Basel II: International convergence of capital measurement and capital standards</title>
		<author>
			<orgName type="collaboration">Basel Committee on Banking Supervision</orgName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bank for International Settlements</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>Basel, Switzerland</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automated analysis of security-design models</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Egea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special Issue on Model-Driven Development for Secure Information Systems</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="815" to="831" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Model driven security: From uml models to access control infrastructures</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lodderstedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="91" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Requirements for access control: US healthcare domain</title>
		<author>
			<persName><forename type="first">K</forename><surname>Beznosov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the third ACM workshop on Role-based access control (RBAC)</title>
		<meeting>the third ACM workshop on Role-based access control (RBAC)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page">43</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Metamodel-based UML notations for domain-specific languages</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Brucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International Workshop on Software Language Engineering</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Favre</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Gasevic</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Lämmel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Winter</surname></persName>
		</editor>
		<imprint>
			<publisher>ATEM</publisher>
			<date type="published" when="2007-10">2007. Oct. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An MDA framework supporting OCL</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Brucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wolff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Communications of the EASST</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A model transformation semantics and analysis methodology for SecureUML</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Brucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wolff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MoDELS 2006: Model Driven Engineering Languages and Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Whittle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Reggio</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="306" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer-Verlag</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>An extended version of this paper is available as ETH Technical Report, no. 524</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The PERMIS X.509 role based privilege management infrastructure</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Chadwick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Otenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the seventh ACM symposium on Access control models and technologies (SACMAT)</title>
		<meeting>the seventh ACM symposium on Access control models and technologies (SACMAT)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="135" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Using trust and risk in role-based access control policies</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dimmock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Belokosztolszki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Eyers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bacon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Moody</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ninth ACM symposium on Access control models and technologies (SACMAT)</title>
		<meeting>the ninth ACM symposium on Access control models and technologies (SACMAT)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="156" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A posteriori compliance control</title>
		<author>
			<persName><forename type="first">S</forename><surname>Etalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">H</forename><surname>Winsborough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM symposium on Access control models and technologies (SACMAT)</title>
		<meeting>the 12th ACM symposium on Access control models and technologies (SACMAT)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Proposed NIST standard for role-based access control</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Ferraiolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename><surname>Gavrila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chandramouli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="224" to="274" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">How to break access control in a controlled manner</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cruz-Correia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Antunes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Farinha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Oliveira-Palhares</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chadwick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Costa-Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th IEEE International Symposium on Computer-Based Medical Systems (CBMS)</title>
		<meeting>the 19th IEEE International Symposium on Computer-Based Medical Systems (CBMS)<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="847" to="854" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">IT Control Objectives for Sarbanes-Oxley: The Role of IT in the Design and Implementation of Internal Control Over Financial Reporting</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Zonneveld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IT Governance Institute</title>
		<imprint>
			<date type="published" when="2006-09">Sept. 2006</date>
			<pubPlace>Rolling Meadows, IL, USA</pubPlace>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Modeling and enforcing advanced access control policies in healthcare systems with Sectet</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hafner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Memon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MoDELS Workshops</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">5002</biblScope>
			<biblScope unit="page" from="132" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dynamic, context-aware access control for distributed healthcare applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Weaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Workshop on Pervasive Security, Privacy and Trust (PSPT)</title>
		<meeting>the First Workshop on Pervasive Security, Privacy and Trust (PSPT)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Managing access control policies using access control spaces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the seventh ACM symposium on Access control models and technologies (SACMAT)</title>
		<meeting>the seventh ACM symposium on Access control models and technologies (SACMAT)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A generalized temporal role-based access control model</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bertino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Latif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ghafoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transaction on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="4" to="23" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A model of accountability, confidentiality and override for healthcare and other applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Logstaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lockyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fifth ACM workshop on Role-based access control</title>
		<meeting>the fifth ACM workshop on Role-based access control<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="71" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m">eXtensible Access Control Markup Language (XACML), version 2.0</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">OMG XML metadata interchange (XMI) specification (version 1.1)</title>
		<idno>OMG document formal/00-11-02</idno>
		<imprint>
			<date type="published" when="2000-11">Nov. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Available as OMG document ptc</title>
		<idno>UML 2.0</idno>
		<imprint>
			<date type="published" when="2003-10">Oct. 2003</date>
			<biblScope unit="page" from="3" to="10" />
		</imprint>
	</monogr>
	<note>OCL specification</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">superstructure specification</title>
		<idno>OMG document formal/05-07-04</idno>
		<imprint>
			<date type="published" when="2005-07">July 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Enforcing well-formed and partially-formed transactions for Unix</title>
		<author>
			<persName><forename type="first">D</forename><surname>Povey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th conference on USENIX Security Symposium</title>
		<meeting>the 8th conference on USENIX Security Symposium</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="5" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Optimistic security: A new access control paradigm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Povey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 workshop on New security paradigms</title>
		<meeting>the 1999 workshop on New security paradigms<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="40" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Towards a mechanism for discretionary overriding of access control</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rissanen</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>transcript of discussion</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Workshop on Security Protocols</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Christianson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Crispo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Malcolm</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Roe</surname></persName>
		</editor>
		<meeting>the 12th International Workshop on Security Protocols<address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-03">Mar. 2004</date>
			<biblScope unit="volume">3957</biblScope>
			<biblScope unit="page" from="320" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Discretionary overriding of access control in the privilege calculus</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rissanen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Firozabadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Sergot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Formal Aspects Security and Trust (FAST)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Dimitrakos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Martinelli</surname></persName>
		</editor>
		<meeting>the Workshop on Formal Aspects Security and Trust (FAST)<address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">173</biblScope>
			<biblScope unit="page" from="219" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Theory and Practice of Concurrency</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roscoe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Role-based access control models</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Coyne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Feinstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Youman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="38" to="47" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Sarbanes-Oxley Act of</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sarbanes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Oxley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="page" from="107" to="610" />
		</imprint>
	</monogr>
	<note>th Congress Report, House of Representatives, 2nd Session</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A new dimension in access control: studying maintenance engineering across organizational boundaries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Wulf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM conference on Computer supported cooperative work (CSCW)</title>
		<meeting>the ACM conference on Computer supported cooperative work (CSCW)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="196" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A context-related authorization and access control method based on RBAC: A case study from the health care domain</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wilikens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Feriti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Masera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the seventh ACM symposium on Access control models and technologies (SACMAT)</title>
		<meeting>the seventh ACM symposium on Access control models and technologies (SACMAT)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="117" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A role-based delegation framework for healthcare information systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-J</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-T</forename><surname>Chu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the seventh ACM symposium on Access control models and technologies (SACMAT)</title>
		<meeting>the seventh ACM symposium on Access control models and technologies (SACMAT)<address><addrLine>New York, NY USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="125" to="134" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
