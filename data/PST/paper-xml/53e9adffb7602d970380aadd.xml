<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Zero-Knowledge Argument for Correctness of a Shuffle</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stephanie</forename><surname>Bayer</surname></persName>
							<email>s.bayer@cs.ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jens</forename><surname>Groth</surname></persName>
							<email>j.groth@cs.ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Zero-Knowledge Argument for Correctness of a Shuffle</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2806680A981508B73C0BFF52E63E94AB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Shuffle</term>
					<term>zero-knowledge</term>
					<term>ElGamal encryption</term>
					<term>mix-net</term>
					<term>voting</term>
					<term>anonymous broadcast</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Mix-nets are used in e-voting schemes and other applications that require anonymity. Shuffles of homomorphic encryptions are often used in the construction of mix-nets. A shuffle permutes and re-encrypts a set of ciphertexts, but as the plaintexts are encrypted it is not possible to verify directly whether the shuffle operation was done correctly or not. Therefore, to prove the correctness of a shuffle it is often necessary to use zero-knowledge arguments.</p><p>We propose an honest verifier zero-knowledge argument for the correctness of a shuffle of homomorphic encryptions. The suggested argument has sublinear communication complexity that is much smaller than the size of the shuffle itself. In addition the suggested argument matches the lowest computation cost for the verifier compared to previous work and also has an efficient prover. As a result our scheme is significantly more efficient than previous zero-knowledge schemes in literature.</p><p>We give performance measures from an implementation where the correctness of a shuffle of 100,000 ElGamal ciphertexts is proved and verified in around 2 minutes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A mix-net <ref type="bibr" target="#b4">[4]</ref> is a multi-party protocol which is used in e-voting or other applications which require anonymity. It allows a group of senders to input a number of encrypted messages to the mix-net, which then outputs the messages in random order. It is common to construct mix-nets from shuffles.</p><p>Informally, a shuffle of ciphertexts C 1 , . . . , C N is a set of ciphertexts C 1 , . . . , C N with the same plaintexts in permuted order. In our work we will examine shuffle protocols constructed from homomorphic encryption schemes. That means for a given public key pk, messages M 1 , M 2 , and randomness ρ 1 , ρ 2 the encryption function satisfies E pk (M 1 M 2 ; ρ 1 + ρ 2 ) = E pk (M 1 ; ρ 1 )E pk (M 2 ; ρ 2 ). Thus, we may construct a shuffle of C 1 , . . . , C N by selecting a permutation π ∈ Σ N and randomizers ρ 1 , . . . ρ N , and calculating C 1 = C π(1) E pk (1; ρ 1 ), . . . , C N = C π(N ) E pk (1; ρ N ).</p><p>A common construction of mix-nets is to let the mix-servers take turns in shuffling the ciphertexts. If the encryption scheme is semantically secure the shuffle C 1 , . . . , C N output by a mix-server does not reveal the permutation or the messages. But this also means that a malicious mix-server in the mix-net could substitute some of the ciphertexts without being detected. In a voting protocol, it could for instance replace all ciphertexts with encrypted votes for candidate X. Therefore, our goal is to construct an interactive zero-knowledge argument that makes it possible to verify that the shuffle was done correctly (soundness), but reveals nothing about the permutation or the randomizers used (zero-knowledge).</p><p>Efficiency is a major concern in arguments for the correctness of a shuffle. In large elections it is realistic to end up shuffling millions of votes. This places considerable strain on the performance of the zero-knowledge argument both in terms of communication and computation. We will construct an honest verifier zero-knowledge argument for correctness of a shuffle that is highly efficient both in terms of communication and computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>The idea of a shuffle was introduced by Chaum <ref type="bibr" target="#b4">[4]</ref> but he didn't give any method to guarantee the correctness. Many suggestions had been made how to build mix-nets or prove the correctness of a shuffle since then, but many of these approaches have been partially or fully broken, and the remaining schemes sometimes suffer from other drawbacks. None of these drawbacks are suffered by the shuffle scheme of Wikström <ref type="bibr" target="#b27">[27]</ref> and approaches based on zero-knowledge arguments. Since zero-knowledge arguments achieve better efficiency they will be the focus of our paper.</p><p>Early contributions using zero-knowledge arguments were made by Sako and Killian <ref type="bibr" target="#b23">[23]</ref>, and Abe <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b2">[2]</ref><ref type="bibr" target="#b3">[3]</ref>. Furukawa and Sako <ref type="bibr" target="#b10">[10]</ref> and Neff <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b21">21]</ref> proposed the first shuffle arguments for ElGamal encryption with a complexity that depends linearly on the number of ciphertexts.</p><p>Furukawa and Sako's approach is based on permutation matrices and has been refined further <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b16">16]</ref>. Furukawa, Miyachi, Mori, Obana, and Sako <ref type="bibr" target="#b8">[8]</ref> presented an implementation of a shuffle argument based on permutation matrices and tested it on mixnets handling 100,000 ElGamal ciphertexts. Recently, Furukawa and Sako <ref type="bibr" target="#b9">[9]</ref> have reported on another implementation based on elliptic curve groups.</p><p>Wikström <ref type="bibr" target="#b29">[28]</ref> also used the idea of permutation matrices and suggested a shuffle argument which splits in an offline and online phase. Furthermore, Terelius and Wikström <ref type="bibr" target="#b25">[25]</ref> constructed conceptually simple shuffle arguments that allowed the restriction of the shuffles to certain classes of permutations. Both protocols are implemented in the Verificatum mix-net library <ref type="bibr" target="#b30">[29]</ref>.</p><p>Neff's approach <ref type="bibr" target="#b20">[20]</ref> is based on the invariance of polynomials under permutation of the roots. This idea was picked up by Groth who suggested a perfect honest verifier zero-knowledge protocol <ref type="bibr" target="#b14">[14]</ref>. Later Groth and Ishai <ref type="bibr" target="#b15">[15]</ref> proposed the first shuffle argument where the communication complexity is sublinear in the number of ciphertexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Contribution</head><p>Results. We propose a practical efficient honest verifier zero-knowledge argument for the correctness of a shuffle. Our argument is very efficient; in particular we drastically decrease the communication complexity compared to previous shuffle arguments. We cover the case of shuffles of ElGamal ciphertexts but it is possible to adapt our argument to other homomorphic cryptosystems as well.</p><p>Our argument has sublinear communication complexity. When shuffling N ciphertexts, arranged in an m × n matrix, our argument transmits O(m + n) group elements giving a minimal communication complexity of O( √ N ) if we choose m = n. In comparison, Groth and Ishai's argument <ref type="bibr" target="#b15">[15]</ref> communicates Θ(m 2 +n) group elements and all other state of the art shuffle arguments communicate Θ(N ) elements.</p><p>The disadvantage of Groth and Ishai's argument compared to the schemes with linear communication was that the prover's computational complexity was on the order of O(N m) exponentiations. It was therefore only possible to choose small m. In comparison, our prover's computational complexity is O(N log m) exponentiations for constant round arguments and O(N ) exponentiations if we allow a logarithmic number of rounds. In practice, we do not need to increase the round complexity until m gets quite large, so the speedup in the prover's computation is significant compared to Groth and Ishai's work and is comparable to the complexity seen in arguments with linear communication. Moreover, the verifier is fast in our argument making the entire process very light from the verifier's point of view.</p><p>In Sect. 6 we report on an implementation of our shuffle argument using shuffles of 100,000 ElGamal ciphertexts. We compare this implementation on the parameter setting for ElGamal encryption used in <ref type="bibr" target="#b8">[8]</ref> and find significant improvements in both communication and computation. We also compare our implementation to the shuffle argument in the Verificatum mix-net <ref type="bibr" target="#b30">[29]</ref> and find significant improvements in communication and moderate improvements in computation.</p><p>New Techniques. Groth <ref type="bibr" target="#b13">[13]</ref> proposed efficient sublinear size arguments to be used in connection with linear algebra over a finite field. We combine these techniques with Groth and Ishai's sublinear size shuffle argument. The main problem in applying Groth's techniques to shuffling is that they were designed for use in finite fields and not for use with group elements or ciphertexts. It turns out though that the operations are mostly linear and therefore it is possible to carry them out "in the exponent"; somewhat similar to what is often done in threshold cryptography. Using this adaptation we are able to construct an efficient multi-exponentiation argument that a ciphertext C is the product of a set of known ciphertexts C 1 , . . . , C N raised to a set of hidden committed values a 1 , . . . , a N . This is the main bottleneck in our shuffle argument and therefore gives us a significant performance improvement.</p><p>Groth's sublinear size zero-knowledge arguments also suffered from a performance bottleneck in the prover's computation. At some juncture it is necessary to compute the sums of the diagonal strips in a product of two matrices. This problem is made even worse in our setting because when working with group elements we have to compute these sums in the exponents. By adapting techniques for polynomial multiplication such as Toom-Cook <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b26">26]</ref> and the Fast Fourier Transform <ref type="bibr" target="#b6">[6]</ref> we are able to reduce this computation. Moreover, we generalize the interactive technique of Groth <ref type="bibr" target="#b13">[13]</ref> to further reduce the prover's computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We use vector notation in the paper, and we write xy = (x 1 y 1 , . . . , x n y n ) for the entrywise product and correspondingly x z = (x z 1 , . . . , x z n ) for vectors of group elements. Similar, we write x π if the entries of vector x are permuted by the permutation π, i.e., x π = (x π(1) , . . . , x π(n) ). We use the standard inner product x • y = n i=1 x i y i for vectors of field elements .</p><p>Our shuffle argument is constructed with homomorphic encryption. An encryption scheme is homomorphic if for a public key pk, messages M 1 , M 2 , and randomness ρ 1 , ρ 2 the encryption function satisfies E pk (M 1 M 2 ; ρ 1 + ρ 2 ) = E pk (M 1 ; ρ 1 )E pk (M 2 ; ρ 2 ). We will focus on ElGamal encryption, but our construction works with many different homomorphic encryption schemes where the message space has large prime order q. To simplify the presentation, we will use notation from linear algebra. We define</p><formula xml:id="formula_0">C a = n i=1 C ai i for vectors (C 1 , . . . , C n ) ∈ H n and (a 1 , . . . , a n ) T ∈ Z n q</formula><p>, where H is the ciphertext space. Likewise, we need a homomorphic commitment scheme in our protocol. Again informally, a commitment scheme is homomorphic if for a commitment key ck, messages a, b, and randomizers r, s it holds that com ck (a + b; r + s) = com ck (a; r)com ck (b; s). We also demand that it is possible to commit to n elements in Z q , where q is a large prime, at the same time. I.e., given a vector (a 1 , . . . , a n ) T ∈ Z n q we can compute a single short commitment c = com ck (a; r) ∈ G, where G is the commitment space. The length-reducing property of the commitment scheme mapping n elements to a single commitment is what allows us to get sublinear communication complexity. Many homomorphic commitment schemes with this property can be used, but for convenience we just focus on a generalization of the Pedersen commitment scheme <ref type="bibr" target="#b22">[22]</ref>. To simplify notation, we write c A = com ck (A; r) for the vector (c A1 , . . . , c Am ) = (com ck (a 1 ; r 1 ), . . . , com ck (a m ; r m ) when A is a matrix with column vectors a 1 , . . . , a m .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Special Honest Verifier Zero-Knowledge Argument of Knowledge</head><p>In the shuffle arguments we consider a prover P and a verifier V both of which are probabilistic polynomial time interactive algorithms. We assume the existence of a probabilistic polynomial time setup algorithm G that when given a security parameter λ returns a common reference string σ.</p><p>The common reference string will be σ = (pk, ck), where pk and ck are public keys for the ElGamal encryption scheme and the generalized Pedersen commitment scheme. The encryption scheme and the commitment scheme may use different underlying groups, but we require that they have the same prime order q. We will write G for the group used by the commitment scheme and write H for the ciphertext space.</p><p>The setup algorithm can also return some side-information that may be used by an adversary; however, we require that even with this side-information the commitment scheme should remain computationally binding. The side-information models that the keys may be set up using some multi-party computation protocol that leaks some information, the adversary may see some decryptions or even learn the decryption key, etc. Our protocol for verifying the correctness of a shuffle is secure in the presence of such leaks as long as the commitment scheme is computationally binding.</p><p>Let R be a polynomial time decidable ternary relation, we call w a witness for a statement x if (σ, x, w) ∈ R. We define the language</p><formula xml:id="formula_1">L σ := {x | ∃w : (σ, x, w) ∈ R}</formula><p>as the set of statements x that have a witness w for the relation R.</p><p>The public transcript produced by P and V when interacting on inputs s and t is denoted by tr ← P(s), V(t) . The last part of the transcript is either accept or reject from the verifier. We write P(s), V(t) = b, b ∈ {0, 1} for rejection or acceptance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Argument). The triple (G, P, V) is called an argument for a relation R with perfect completeness if for all non-uniform polynomial time interactive adversaries</head><p>A we have: Perfect completeness:</p><formula xml:id="formula_2">Pr[(σ, hist) ← G(1 λ ); (x, w) ← A(σ, hist) : (σ, x, w) ∈ R or P(σ, x, w), V(σ, x) = 1] = 1</formula><p>Computational soundness:</p><formula xml:id="formula_3">Pr[(σ, hist) ← G(1 λ ); x ← A(σ, hist) : x ∈ L σ and A, V(σ, x) = 1] ≈ 0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Public coin). An argument (G, P, V) is called public coin if the verifier chooses his messages uniformly at random and independently of the messages sent by the prover, i.e., the challenges correspond to the verifier's randomness ρ.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Special honest verifier zero-knowledge). A public coin argument (G, P, V) is called a perfect special honest verifier zero knowledge (SHVZK) argument for R with common reference string generator G if there exists a probabilistic polynomial time simulator S such that for all non-uniform polynomial time interactive adversaries A we have</head><formula xml:id="formula_4">Pr[(σ, hist) ← G(1 λ ); (x, w, ρ) ← A(σ, hist); tr ← P(σ, x, w), V(σ, x; ρ) : (σ, x, w) ∈ R and A(tr) = 1] = Pr[(σ, hist) ← G(1 λ ); (x, w, ρ) ← A(σ, hist); tr ← S(σ, x, ρ) : (σ, x, w) ∈ R and A(tr) = 1]</formula><p>To construct a fully zero-knowledge argument secure against arbitrary verifiers in the common reference string model one can first construct a SHVZK argument and then convert it into a fully zero-knowledge argument <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b12">12]</ref>. This conversion has constant additive overhead, so it is very efficient and allows us to focus on the simpler problem of getting SHVZK against honest verifiers.</p><p>To define an argument of knowledge we follow the approach of Groth and Ishai <ref type="bibr" target="#b15">[15]</ref> and do it through witness-extended emulation first introduced by Lindell <ref type="bibr" target="#b19">[19]</ref>. This definition informally says that given an adversary that produces an acceptable argument with some probability, there exist an emulator that produces a similar argument with the same probability and at the same time provides a witness w.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Witness-extended emulation).</head><p>A public coin argument (G, P, V) has witness extended emulation if for all deterministic polynomial time P * there exists an expected polynomial time emulator X such that for all non-uniform polynomial time interactive adversaries A we have</p><formula xml:id="formula_5">Pr[(σ, hist) ← G(1 λ ); (x, s) ← A(σ, hist); tr ← P * (σ, x, s), V(σ, x) : A(tr)= 1] ≈ Pr[(σ, hist) ← G(1 λ ); (x, s) ← A(σ, hist); (tr, w) ← X P * (σ,x,s),V(σ,x) (σ, x, ρ) : A(tr) = 1 and if tr is accepting then (σ, x, w) ∈ R].</formula><p>In the definition, s can be interpreted as the state of P * , including the randomness. So whenever P * is able to make a convincing argument when in state s, the emulator can extract a witness at the same time giving us an argument of knowledge. This definition automatically implies soundness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Shuffle Argument</head><p>We will give an argument of knowledge of a permutation π ∈ Σ N and randomness</p><formula xml:id="formula_6">{ρ i } N i=1 such that for given ciphertexts {C i } N i=1 , {C i } N i=1 we have C i = C π(i) E pk (1; ρ i ).</formula><p>The shuffle argument combines a multi-exponentiation argument, which allows us to prove that the product of a set of ciphertexts raised to a set of committed exponents yields a particular ciphertext, and a product argument, which allows us to prove that a set of committed values has a particular product. The multi-exponentiation argument is given in Sect. 4 and the product argument is given in Sect. 5. In this section, we will give an overview of the protocol and explain how a multi-exponentiation argument can be combined with a product argument to yield an argument for the correctness of a shuffle.</p><p>The first step for the prover is to commit to the permutation. This is done by committing to π(1), . . . , π(N ). The prover will now receive a challenge x and commit to x π (1) , . . . , x π(N ) . The prover will give an argument of knowledge of openings of the commitments to permutations of 1, . . . , N and x 1 , . . . , x N and demonstrate that the same permutation has been used in both cases. This means the prover has a commitment to x 1 , . . . , x N permuted in an order that was fixed before the prover saw x.</p><p>To check that the same permutation has been used in both commitments the verifier sends random challenges y and z. By using the homomorphic properties of the commitment scheme the prover can in a verifiable manner compute commitments to</p><formula xml:id="formula_7">d 1 -z = yπ(1) + x π(1) -z, . . . , d N -z = yπ(N ) + x π(N ) -z.</formula><p>Using the product argument from Sect. 5 the prover shows that</p><formula xml:id="formula_8">N i=1 (d i -z) = N i=1 (yi + x i -z).</formula><p>Observe that we have two identical degree N polynomials in z since the only difference is that the roots have been permuted. The verifier does not know a priori that the two polynomials are identical but can by the Schwartz-Zippel lemma deduce that the prover has negligible chance over the choice of z of making a convincing argument unless indeed there is a permutation π such that d 1 = yπ(1) + x π (1) , . . . , d N = yπ(N ) + x π(N ) . Furthermore, there is negligible probability over the choice of y of this being true unless the first commitment contains π(1), . . . , π(N ) and the second commitment contains x π (1) , . . . , x π(N ) .</p><p>The prover has commitments to x π (1) , . . . , x π(N ) and uses the multi-exponentiation argument from Sect. 4 to demonstrate that there exists a ρ such that (i) . The verifier does not see the committed values and thus does not learn what the permutation is. However, from the homomorphic properties of the encryption scheme the verifier can deduce</p><formula xml:id="formula_9">N i=1 C x i i = E pk (1; ρ) N i=1 (C i ) x π</formula><formula xml:id="formula_10">N i=1 M x i i = N i=1 (M i ) x π(i)</formula><p>for some permutation π that was chosen before the challenge x was sent to the prover. Taking discrete logarithms we have the polynomial identity</p><formula xml:id="formula_11">N i=1 log(M i )x i = N i=1 log(M π -1 (i) )x i .</formula><p>There is negligible probability over the choice of x of this equality holding true unless</p><formula xml:id="formula_12">M 1 = M π(1) , . . . , M N = M π(N )</formula><p>. This shows that we have a correct shuffle.</p><p>Common reference string: pk, ck. </p><formula xml:id="formula_13">Statement: C, C ∈ H N with N = mn. Prover's witness: π ∈ Σ N and ρ ∈ Z N q such that C = E pk (1; ρ)C π . Initial message: Pick r ← Z m q , set a = {π(i)} N i=1 and compute c A = com ck (a; r). Send: c A Challenge: x ← Z * q . Answer Pick s ∈ Z m q , set b = {x π(i) } N i=1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5 (Full paper). The protocol is a public coin perfect SHVZK argument of knowledge of</head><formula xml:id="formula_14">π ∈ Σ N and ρ ∈ Z N q such that C = E pk (1; ρ)C π .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Multi-exponentiation Argument</head><p>Given ciphertexts C 11 , . . . , C mn , and C we will in this section give an argument of knowledge of openings of commitments c A to A = {a ij } n,m i,j=1 such that</p><formula xml:id="formula_15">C = E pk (1; ρ) m i=1 C ai i and c A = com ck (A; r) ,</formula><p>where C i = (C i1 , . . . , C in ) and a j = (a 1j , . . . , a nj ) T .</p><p>To explain the idea in the protocol let us for simplicity assume ρ = 0 and the prover knows the openings of c A , and leave the question of SHVZK for later. In other words, we will for now just explain how to convince the verifier in a communication-efficient manner that C = m i=1 C ai i . The prover can calculate the ciphertexts</p><formula xml:id="formula_16">E k = 1≤i,j≤m j=(k-m)+i C aj i</formula><p>, where E m = C. To visualize this consider the following matrix</p><formula xml:id="formula_17">a 1 . . . a m ⎛ ⎜ ⎜ ⎜ ⎝ C 1 C 2 . . . C m ⎞ ⎟ ⎟ ⎟ ⎠ ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ C a1 1 . . . C am 1 C a1 2 . . . C am 2 . . . . . . . . . . . . C a1 m . . . C am m ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ E 2m-1 . . . E m+1 E 1 . . . E m-1 E m</formula><p>The prover sends the ciphertexts E 1 , . . . , E 2m-1 to the verifier. The ciphertext C = E m is the product of the main diagonal and the other E k 's are the products of the other diagonals. The prover will use a batch-proof to simultaneously convince the verifier that all the diagonal products give their corresponding E k . The verifier selects a challenge x ← Z * q . The prover sets x = (x, x 2 , . . . , x m ) T , opens c x A to a = m j=1 x j a j , and the verifier checks</p><formula xml:id="formula_18">C x m 2m-1 k=1 k =m E x k k = m i=1 C (x m-i a) i .</formula><p>Since x is chosen at random, the prover has negligible probability of convincing the verifier unless the x k -related terms match on each side of the equality for all k. In particular, since a = m j=1 x j a j the x m -related terms give us</p><formula xml:id="formula_19">C x m = m i=1 C x m-i 1≤j≤m m=m-i+j x j aj i = m i=1 C ai i x m</formula><p>and allow the verifier to conclude C = m i=1 C ai i . Finally, to make the argument honest verifier zero-knowledge we have to avoid leaking information about the exponent vectors a 1 , . . . , a m . The prover therefore commits to a random vector a 0 ← Z n q and after she sees the challenge x she reveals a = a 0 + m j=1 x j a j . Since a 0 is chosen at random this vector does not leak any information about the exponents.</p><p>Another possible source of leakage is the products of the diagonals. The prover will therefore randomize each E k by multiplying it with a random ciphertext E pk (G b k ; τ k ). Now each E k is a uniformly random group element in H and will therefore not leak information about the exponents. Of course, this would make it possible to encrypt anything in the E k and allow cheating. To get around this problem the prover has to commit to the b k 's used in the random encryptions and the verifier will check that the prover uses b m = 0. The full argument that also covers the case ρ = 0 can be found below.</p><p>Common reference string: pk, ck.</p><formula xml:id="formula_20">Statement: C 1 , . . . , C m ∈ H n , C ∈ H, and c A ∈ G m Prover's witness: A = {a j } m j=1 ∈ Z n×m q</formula><p>, r ∈ Z m q , and ρ ∈ Z q such that</p><formula xml:id="formula_21">C = E pk (1; ρ) m i=1 C ai i and c A = com ck (A; r)</formula><p>Initial message: Pick a 0 ← Z n q , r 0 ← Z q , and b 0 , s 0 , τ 0 . . . , b 2m-1 , s 2m-1 , τ 2m-1 ← Z q and set b m = 0, s m = 0, τ m = ρ. Compute for k = 0, . . . , 2m -1</p><formula xml:id="formula_22">c A0 = com ck (a 0 ; r 0 ) , c B k = com ck (b k ; s k ) , E k = E pk (G b k ; τ k ) m,m i=1,j=0 j=(k-m)+i C aj i Send: c A0 , {c B k } 2m-1 k=0 , {E k } 2m-1 k=0 . Challenge: x ← Z *</formula><p>q . Answer: Set x = (x, x 2 , . . . , x m ) T and compute</p><formula xml:id="formula_23">a = a 0 + Ax r = r 0 + r • x b = b 0 + 2m-1 k=1 b k x k s = s 0 + 2m-1 k=1 s k x k τ = τ 0 + 2m-1 k=1 τ k x k .</formula><p>Send: a, r, b, s, τ. Verification: Check c A0 , c B0 , . . . , c B2m-1 ∈ G, and E 0 , . . . , E 2m-1 ∈ H, and a ∈ Z n q , and r, b, s, τ ∈ Z q , and accept if c Bm = com ck (0; 0) and E m = C, and</p><formula xml:id="formula_24">c A0 c x A = com ck (a; r) c B0 2m-1 k=1 c x k B k = com ck (b; s) E 0 2m-1 k=1 E x k k = E pk (G b ; τ ) m i=1 C x m-i a i .</formula><p>Theorem 6 (Full paper). The protocol above is a public coin perfect SHVZK argument of knowledge of openings a 1 , . . . , a m , r and randomness ρ such that</p><formula xml:id="formula_25">C = E pk (1; ρ) m i=1 C ai i .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Prover's Computation</head><p>The argument we just described has efficient verification and very low communication complexity, but the prover has to compute E 0 , . . . , E 2m-1 .</p><p>In this section we will for clarity ignore the randomization needed to get honest verifier zero-knowledge, which can be added in a straightforward manner at little extra computational cost. So let us say we need to compute for k = 1, . . . , 2m -1 the elements</p><formula xml:id="formula_26">E k = m,m i=1,j=1 j=(k-m)+i C aj i .</formula><p>This can be done by first computing the m 2 products C aj i and then computing the E k 's as suitable products of some of these values. Since each product</p><formula xml:id="formula_27">C aj i is of the form n =1 C a j i</formula><p>this gives a total of m 2 n exponentiations in H. For large m this cost is prohibitive.</p><p>It turns out that we can do much better by using techniques inspired by multiplication of integers and polynomials, such as Karatsuba <ref type="bibr" target="#b17">[17]</ref>, Toom-Cook <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b26">26]</ref> and using the Fast Fourier Transform <ref type="bibr" target="#b6">[6]</ref>. A common theme in these techniques is to compute the coefficients of the product p(x)q(x) of two degree m -1 polynomials p(x) and q(x) by evaluating p(x)q(x) in 2m -1 points ω 0 , . . . , ω 2m-2 and using polynomial interpolation to recover the coefficients of p(x)q(x) from p(ω 0 )q(ω 0 ), . . . , p(ω 2m-2 )q(ω 2m-2 ).</p><p>If we pick ω ∈ Z q we can evaluate the vectors</p><formula xml:id="formula_28">m i=1 C ω m-i i and m j=1 ω j-1 a j .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This gives us</head><formula xml:id="formula_29">m i=1 C ω m-i i m j=1 ω j-1 aj = 2m-1 k=1 ⎛ ⎜ ⎜ ⎝ m,m i=1,j=1 j=(k-m)+i C aj i ⎞ ⎟ ⎟ ⎠ ω k-1 = 2m-1 k=1 E ω k-1 k . Picking 2m -1 different ω 0 , . . . , ω 2m-2 ∈ Z q we get the 2m -1 ciphertexts 2m-1 k=1 E ω k-1 0 k , . . . , 2m-1 k=1 E ω k-1 2m-2 k .</formula><p>The ω 0 , . . . , ω 2m-2 are different and therefore the transposed Vandermonde matrix ⎛ ⎜ ⎝</p><formula xml:id="formula_30">1 . . . 1 . . . . . . ω 2m-2 0 . . . ω 2m-2 2m-2 ⎞ ⎟ ⎠</formula><p>is invertible. Let y i = (y 0 , . . . , y 2m-2 ) T be the ith column of the inverse matrix. We can now compute E i as</p><formula xml:id="formula_31">E i = 2m-2 =0 2m-1 k=1 E ω k-1 k y = 2m-2 =0 m i=1 C ω m-i i m j=1 ω j-1 aj y .</formula><p>This means the prover can compute E 1 , . . . , E 2m-1 as linear combinations of</p><formula xml:id="formula_32">m i=1 C ω m-i 0 i m j=1 ω j-1 0 aj . . . m i=1 C ω m-i 2m-2 i m j=1 ω j-1 2m-2 aj</formula><p>.</p><p>The expensive step in this computation is to compute</p><formula xml:id="formula_33">m i=1 C ω m-i 0 i , . . . , m i=1 C ω m-i 2m-2 i . If 2m -2 is</formula><p>a power of 2 and 2m -2|q -1 we can pick ω 1 , . . . , ω 2m-2 as roots of unity, i.e., ω 2m-2 k = 1. This allows us to use the Fast Fourier Transformation "in the exponent" to simultaneously calculate</p><formula xml:id="formula_34">m i=1 C ω m-i k i</formula><p>in all of the roots of unity using only O(mn log m) exponentiations. This is asymptotically the fastest technique we know for computing E 0 , . . . , E 2m-2 .</p><p>Unfortunately, the FFT is not well suited for being used in combination with multiexponentiation techniques and in practice it therefore takes a while before the asymptotic behavior kicks in. For small m it is therefore useful to consider other strategies. Inspired by the Toom-Cook method for integer multiplication, we may for instance choose ω 0 , ω 1 , . . . , ω 2m-2 to be small integers. When m is small even the largest exponent ω 2m-2 k will remain small. For instance, if m = 4 we may choose ω k ∈ {0, -1, 1, -2, 2, -3, 3}, which makes the largest exponent ω m-1 k = 3 3 = 27. This makes it cheap to compute each</p><formula xml:id="formula_35">m i=1 C ω m-i k i</formula><p>because the exponents are very small. The basic step of Toom-Cook sketched above can be optimized by choosing the evaluation points carefully. However, the performance degrades quickly as m grows. Using recursion it is possible to get subquadratic complexity also for large m, however, the cost still grows relatively fast. In the next section we will therefore describe an interactive technique for reducing the prover's computation. In our implementation, see Sect. 6, we have used a combination of the interactive technique and Toom-Cook as the two techniques work well together.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Trading Computation for Interaction</head><p>We will present an interactive technique that can be used to reduce the prover's computation. The prover wants to show that C has the same plaintext as the product of the main diagonal of following matrix (here illustrated for m = 16). </p><formula xml:id="formula_36">⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ C a1 1 C a2 1 C a3 1 C a4 1 C a1 2 C a2 2 C a3 2 C a4 2 . . . C a1 3 C a2 3 C a3 3 C a4 3 C a1 4 C a2 4 C a3 4 C a4 4 . . . C a13</formula><formula xml:id="formula_37">⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠</formula><p>In the previous section the prover calculated all m 2 entries of the matrix. But we are only interested in the product along the diagonal so we can save computation by just focusing on the blocks close to the main diagonal.</p><p>Let us explain the idea in the case of m = 16. We can divide the matrix into 4 × 4 blocks and only use the four blocks that are on the main diagonal. Suppose the prover wants to demonstrate C = 16 i=1 C ai i . Let us for now just focus on soundness and return to the question of honest verifier zero-knowledge later. The prover starts by sending E 0 , E 1 , E 2 , E 3 , E 4 , E 5 , E 6 that are the products along the diagonals of the elements in the blocks that we are interested in. I.e., E 0 =</p><formula xml:id="formula_38">4 i=1 C a4i-3 4i , . . . , E 6 = 4 i=1 C a4i 4i-3</formula><p>and E 3 = C. The verifier sends a random challenge x and using the homomorphic properties of the encryption scheme and of the commitment scheme both the prover and the verifier can compute C 1 , . . . , C 4 and c A 1 , . . . , c A 4 as</p><formula xml:id="formula_39">C i = C x 3 4i-3 C x 2 4i-2 C x 4i-1 C 4i c A j = c A4j-3 c x A4j-2 c x 2 A4j-1 c x 3 A4j .</formula><p>They can also both compute C = 6 k=0 E x k k . The prover and the verifier now engage in an SHVZK argument for the smaller statement</p><formula xml:id="formula_40">C = 4 i=1 C a i i</formula><p>. The prover can compute a witness for this statement with a i = a 4i-3 + xa 4i-2 + x 2 a 4i-1 + x 3 a 4i . This shows</p><formula xml:id="formula_41">C x 3 6 k=0 k =3 E x k k = 4 i=1 (C x 3 4i-3 C x 2 4i-2 C x 4i-1 C 4i ) (a4i-3+xa4i-2+x 2 a4i-1+x 3 a4i) .</formula><p>Looking at the x 3 -related terms, we see this has negligible chance of holding for a random x unless C = 16 i=1 C ai i , which is what the prover wanted to demonstrate. We will generalize the technique to reduce a statement C 1 , . . . , C m , C, c A1 , . . . , c Am with a factor μ to a statement C 1 , . . . , C m , C , c A 1 , . . . , c A m , where m = μm . To add honest verifier zero-knowledge to the protocol, we have to prevent the E k 's from leaking information about a 1 , . . . , a m . We do this by randomizing each E k with a random ciphertext E pk (G b k ; t k ). To prevent the prover to use the randomization to cheat she will have to commit the b k 's before seeing the challenge x.  and set b μ-1 = 0, s μ-1 = 0, τ μ-1 = ρ. Compute for k = 0, . . . , 2μ -2 We give an argument of knowledge that B is true, i.e., it contains m i=1 a i1 , . . . , m i=1 a in . Groth <ref type="bibr" target="#b13">[13]</ref> described how to do this efficiently. Next, we give an argument of knowledge that b is the product of the values inside B. This can be done using an argument given in <ref type="bibr" target="#b14">[14]</ref>. Here, we just give an overview of the protocol.  The proof along with details of the underlying arguments can be found in the full paper.</p><formula xml:id="formula_42">c b k = com ck (b k ; s k ) E k = E pk (G b k ; τ k ) m -1 =0 μ,μ i=1,j=1 j=(k+1-μ)+i</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Implementation and Comparison</head><p>We will now compare our protocol with the most efficient shuffle arguments for ElGamal encryption. First, we compare the theoretical performance of the schemes without any optimization. Second, we compare an implementation of our protocol with the implementation by Furukawa et al. <ref type="bibr" target="#b8">[8]</ref> and with the implementation in the Verificatum mix-net library <ref type="bibr" target="#b30">[29]</ref>.</p><p>Theoretical Comparison. Previous work in the literature mainly investigated the case where we use ElGamal encryption and commitments over the same group G, i.e., H = G × G. Table <ref type="table" target="#tab_3">1</ref> gives the asymptotic behavior of these protocols compared to our protocol for N = mn as m and n grows.</p><p>In our protocol, we may as detailed in Sect. 4.1 use FFT techniques to reduce the prover's computation to O(N log m) exponentiations as listed in Table <ref type="table" target="#tab_3">1</ref>. Furthermore, by increasing the round complexity as in Sect. 4.2 we could even get a linear complexity of O(N ) exponentiations. These techniques do not apply to the other shuffle arguments; in particular it is not possible to use FFT techniques to reduce the factor m in the shuffle by Groth and Ishai <ref type="bibr" target="#b15">[15]</ref>. </p><formula xml:id="formula_43">8N 10N 5N G+ N Z q [8] 5 9N 10N 5N G + N Z q [14] 7 6N 6N 3N Z q [7] 3 7N 8N N G+ 2N Z q [25] 5 9N 11N 3N G + 4N Z q [15] 7 3mN 4N 3m 2 G+ 3n Z q This paper 9 2 log(m)N 4N 11m G+ 5n Z q</formula><p>As the multi-exponentiation argument, which is the most expensive step, already starts in round 3 we can insert two rounds of interactive reduction as described in Sect. 4.2 without increasing the round complexity above 9 rounds. For practical parameters this would give us enough of a reduction to make the prover's computation comparable to the schemes with linear O(N ) computation.</p><p>The figures in Table <ref type="table" target="#tab_3">1</ref> are for non-optimized versions of the schemes. All of the schemes may for instance benefit from the use of multi-exponentiation techniques, see e.g. Lim <ref type="bibr" target="#b18">[18]</ref> for how to compute a product of n exponentiations using only O( n log n ) multiplications. The schemes may also benefit from randomization techniques, where the verifier does a batch verification of all the equations it has to check.</p><p>Experimental Results. We implemented our shuffle argument in C++ using the NTL library by Shoup <ref type="bibr" target="#b24">[24]</ref> for the underlying modular arithmetic. We experimented with five different implementations to compare their relative merit: In our experiments we used ElGamal encryption and commitments over the same group G, which was chosen as an order q subgroup of Z * p , where |q| = 160 and |p| = 1024. These security parameters are on the low end for present day use but facilitate comparison with earlier work. The results can be found in Table <ref type="table" target="#tab_4">2</ref> for N = 100, 000, m = 8, 16, 64 on our machine. We see that the plain multi-exponentiation techniques yield better results than the FFT method for small m; the better asymptotic behavior of the FFT only kicks in for m &gt; 16. As expected the Toom-Cook inspired version with added interaction has the best running time and communication cost. Comparison with Other Implementations. Furukawa, Miyauchi, Mori, Obana, and Sako <ref type="bibr" target="#b8">[8]</ref> gave performance results for a mix-net using a version of the Furukawa-Sako <ref type="bibr" target="#b10">[10]</ref> shuffle arguments. They optimized the mix-net by combining the shuffling and decryption operations into one. They used three shuffle centers communicating with each other and their results included both the process of shuffling and the cost of the arguments. So, to compare the values we multiply our shuffle argument times with 3 and add the cost of our shuffling operation on top of that. The comparison can be found in Table <ref type="table" target="#tab_5">3</ref>. We expected to get better performance than they did and indeed we see that our argument is faster and the communication is a factor 100 smaller. When adding the cost of shuffling and decryption to our argument we still have a speedup of a factor 3 in Table <ref type="table" target="#tab_5">3</ref> when comparing the two mix-net implementations and taking the difference in the machines into account.</p><p>Recently, Furukawa et al. <ref type="bibr" target="#b9">[9]</ref> announced a new implementation based on elliptic curve groups. Due to the speed of using elliptic curves this gave them a speedup of a factor 3. A similar speedup can be expected for our shuffle argument if we switch to using elliptic curves in our implementation.</p><p>Recently Wikström made a complete implementation of a mix-net in Java in <ref type="bibr" target="#b30">[29]</ref> called Verificatum, which is based on the shuffle argument in <ref type="bibr" target="#b25">[25]</ref>. To produce comparable data, we ran the demo file with only one mix party in the non-interactive mode Table <ref type="table">4</ref>. Runtime comparison of <ref type="bibr" target="#b25">[25]</ref> to our shuffle argument on our machine (CPU: 2.53 GHz, 4 GB) N = 100, 000 <ref type="bibr" target="#b25">[25]</ref> This paper Toom-Cook Single argument 5 min 2 min Argument size 37.7 MB 0.7 MB using the same modular group as in our protocol. Verificatum is a full mix-net implementation; for fairness in the comparison we only counted the time of the relevant parts for the shuffle argument. As described in Table <ref type="table" target="#tab_3">1</ref> the theoretical performance of Verificatum's shuffle argument is 20N exponentiations, while our prover with Toom-Cook and 2 extra rounds of interaction uses 12N exponentiations and our verifier 4N , so in total 16N exponentiations. So we expect a similar running time for the Verificatum mix-net. As shown in Table <ref type="table">4</ref> we perform better, but due to the different programming languages used and different levels of optimization in the code we will not draw any conclusion except that both protocols are efficient and usable in current applications. In terms of size it is clear that our arguments leave a much smaller footprint than Verificatum; we save a factor 50 in the communication.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>and compute c B = com ck (b; s). Send: c B Challenge: y, z ← Z * q . Answer: Define c -z = com ck (-z, . . . , -z; 0) and c D = c y A c B . Compute d = ya + b, and t = yr+s. Engage in a product argument as described in Sect. 5 of openings d 1z, . . . , d Nz and t such thatc D c -z = com ck (dz; t ) and N i=1 (d iz) = N i=1 (yi + x iz) .Compute ρ = -ρ•b and set x = (x, x 2 , . . . , x N ) T . Engage in a multi-exponentiation argument as described in Sect. 4 of b, s and ρ such that C x = E pk (1; ρ)C b and c B = com ck (b; s) The two arguments can be run in parallel. Furthermore, the multi-exponentiation argument can be started in round 3 after the computation of the commitments c B . Verification: The verifier checks c A , c B ∈ G m and computes c -z , c D as described above and computes N i=1 (yi + x iz) and C x . The verifier accepts if the product and multi-exponentiation arguments both are valid.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>com ck (A; r) . Initial message: Pick b = (b 0 , . . . , b 2μ-2 ), s, τ ← Z 2μ-1 q</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>C a μc x j- 1 ATheorem 7 (</head><label>17</label><figDesc>+j μ +i . Send: c b = (c b0 , . . . , c b2μ-2 ) and E = (E 0 , . . . , E 2μ-2 ). Challenge: x ← Z * q . Answer: Set x = (1, x, . . . , x 2μ-2 ) T and send b = b • x and s = s • x to the verifier. Compute for = 1, . . . , m 1 r μ( -1)+j ρ = τ • x . Define C 1 , . . . , C m and c A 1 , . . . , c A m and C by μ( -1)+jC = E pk (G -b ; 0)E x .Engage in an SHVZK argument of openings a 1 , . . . , a m , r , and ρ such thatC = E pk (1; ρ ) Check c b ∈ G 2μ-1 and E 0 , . . . , E 2μ-2 ∈ H and b, s ∈ Z q . Accept if c bμ-1 = com ck (0; 0) E μ-1 = C c x b = com ck (b; s) and if the SHVZK argument for C 1 , . . . , C m , C , c A 1 , . . . , c A m is valid. Full paper).The protocol above is a public coin perfect SHVZK argument of knowledge of a 1 , . . . , a m , r such that C = E pk (1; ρ)We will sketch an argument that a set of committed values have a particular product. More precisely, given commitments A 1 , . . . , A m to a 11 , . . . , a mn and a value b we want to give an argument of knowledge for m i=1 n j=1 a ij = b. Our strategy is to compute a commitment B = com ck ( m i=1 a i1 , . . . , m i=1 a in ; s) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>aTheorem 8 .</head><label>8</label><figDesc>ij = b . Initial message: Pick s ← Z q and compute B = com ck ( m i=1 a i1 , . . . , m i=1 a in ; s). Send B to the verifier. Engage in an SHVZK argument of knowledge as described in [13] of B = com ck ( m i=1 a i1 , . . . , m i=1 a in ; s), where a 11 , . . . , a mn are the committed values in A 1 , . . . , A m . Engage (in parallel) in an SHVZK argument of knowledge as described in [14] of b being the product of the values in B. Verification: The verifier accepts if B ∈ G and both SHVZK arguments are valid. The protocol is a public coin perfect SHVZK argument of knowledge of openings a 11 , . . . , a mn , r 1 , . . . , r m ∈ Z q such that b = m i=1 n i=1 a ij .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 .</head><label>1</label><figDesc>Without any optimizations at all. 2. Using multi-exponentiation techniques. 3. Using multi-exponentiation and the Fast Fourier transform. 4. Using multi-exponentiation and a round of the interactive technique with μ = 4 and Toom-Cook for m = 4 giving m = μm = 16. 5. Using multi-exponentiation and two rounds of the interactive technique first with μ = 4 and Toom-Cook for m = 4 giving m = μ 2 m = 64.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Common Reference string: pk, ck. Statement: C 1 , . . . , C m ∈ H n and C ∈ H and c A1 , . . . , c Am ∈ G where m = μm .</figDesc><table><row><cell>Prover's witness: A ∈ Z n×m q</cell><cell>, r ∈ Z m q and ρ ∈ Z q such that</cell></row><row><cell>C = E pk (1; ρ)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Common reference string: pk, ck. Statement: A 1 , . . . , A m ∈ G and b ∈ Z q . Prover's witness: a 11 , . . . , a mn , r 1 , . . . , r m ∈ Z q such that A 1 = com ck (a 11 , . . . , a 1n ; r 1 ) . . . . . .A m = com ck (a m1 , . . . , a mn ; r m ) ,</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 .</head><label>1</label><figDesc>Comparison of the protocols with ElGamal encryption</figDesc><table><row><cell cols="2">SHVZK Rounds Time P</cell><cell>Time V Size</cell></row><row><cell>argument</cell><cell>Expos</cell><cell>Expos Elements</cell></row><row><cell>[10]</cell><cell>3</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 .</head><label>2</label><figDesc>Run time of the shuffle arguments in seconds on a Core2Duo 2.53 GHz, 3 MB L2-Cache, 4 GB Ram machine for N = 100, 000 and m = 8, 16, 64 Optimization Total time Time P Time V Size</figDesc><table><row><cell>m = 8 Unoptimized</cell><cell>570</cell><cell>462</cell><cell>108 4.3 MB</cell></row><row><cell>Multi-expo</cell><cell>162</cell><cell>125</cell><cell>37</cell></row><row><cell>FFT</cell><cell>228</cell><cell>190</cell><cell>38</cell></row><row><cell>m = 16 Unoptimized</cell><cell>900</cell><cell>803</cell><cell>97 2.2 MB</cell></row><row><cell>Multi-expo</cell><cell>193</cell><cell>169</cell><cell>24</cell></row><row><cell>FFT</cell><cell>245</cell><cell>221</cell><cell>24</cell></row><row><cell>Toom-Cook</cell><cell>139</cell><cell>101</cell><cell>38</cell></row><row><cell>m = 64 Multi-expo</cell><cell>615</cell><cell>594</cell><cell>21 0.7MB</cell></row><row><cell>FFT</cell><cell>328</cell><cell>307</cell><cell>20</cell></row><row><cell>Toom-Cook</cell><cell>128</cell><cell>91</cell><cell>18</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 .</head><label>3</label><figDesc>Runtime comparison of [8] (CPU: 1 GHz, 256 MB) to our shuffle argument (Toom-Cook with m = 64, CPU: 1.4 GHz, 256 MB)</figDesc><table><row><cell>N = 100, 000</cell><cell>[8]</cell><cell>This paper</cell></row><row><cell>Single argument</cell><cell>51 min</cell><cell>15 min</cell></row><row><cell>Argument size</cell><cell>66 MB</cell><cell>0.7 MB</cell></row><row><cell cols="3">Total mix-net time 3 hrs 44 min 53 min</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgment. We would like to thank Douglas Wikström for discussions and help regarding our comparison with the shuffle argument used in Verificatum <ref type="bibr" target="#b30">[29]</ref>.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Universally Verifiable Mix-Net with Verification Work Independent of the Number of Mix-Servers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1998</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1403</biblScope>
			<biblScope unit="page" from="437" to="447" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Mix-Networks on Permutation Networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 1999</title>
		<editor>
			<persName><forename type="first">K.-Y</forename><surname>Lam</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Okamoto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Xing</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1716</biblScope>
			<biblScope unit="page" from="258" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Remarks on Mix-Network Based on Permutation Networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hoshino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2001</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1992</biblScope>
			<biblScope unit="page" from="317" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Untraceable electronic mail, return addresses, and digital pseudonyms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="88" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">On the minimum computation time of functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
		<ptr target="http://cr.yp.to/bib/1966/cook.html" />
		<imprint>
			<date type="published" when="1966">1966</date>
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics, Harvard University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An algorithm for the machine calculation of complex fourier series</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Cooley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Tukey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="297" to="301" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient and verifiable shuffling and shuffle-decryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Furukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Transactions</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="172" to="188" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Implementation of a Universally Verifiable Electronic Voting Scheme Based on Shuffling</title>
		<author>
			<persName><forename type="first">J</forename><surname>Furukawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Miyauchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Obana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FC 2002</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Blaze</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2357</biblScope>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An Implementation of a Mix-Net Based Network Voting Scheme and Its Use in a Private Organization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Furukawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Towards Trustworthy Elections</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Jakobsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Y A</forename><surname>Ryan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Benaloh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Kutylowski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Adida</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6000</biblScope>
			<biblScope unit="page" from="141" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Efficient Scheme for Proving a Shuffle</title>
		<author>
			<persName><forename type="first">J</forename><surname>Furukawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2001</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="368" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Strengthening zero-knowledge protocols using signatures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="169" to="209" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Honest verifier zero-knowledge arguments applied</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<idno>DS-04-3</idno>
	</analytic>
	<monogr>
		<title level="j">BRICS</title>
		<imprint>
			<biblScope unit="page">119</biblScope>
			<date type="published" when="2004">2004. 2004</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Linear Algebra with Sub-linear Zero-Knowledge Arguments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5677</biblScope>
			<biblScope unit="page" from="192" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A verifiable secret shuffle of homomorphic encryptions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="546" to="579" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Sub-linear Zero-Knowledge Argument for Correctness of a Shuffle</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2008</title>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="379" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Verifiable Shuffle of Large Size Ciphertexts</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2007</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4450</biblScope>
			<biblScope unit="page" from="377" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multiplication of multidigit numbers on automata</title>
		<author>
			<persName><forename type="first">A</forename><surname>Karatsuba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ofman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Soviet Physics Dokl</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="595" to="596" />
			<date type="published" when="1963">1963</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Efficient multi-exponentiation and application to batch verification of digital signatures</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lim</surname></persName>
		</author>
		<ptr target="http://dasan.sejong.ac.kr/˜chlim/pub/multiexp.ps" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Parallel coin-tossing and constant-round secure two-party computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="143" to="184" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A verifiable secret shuffle and its application to e-voting</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Neff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>ACM CCS</publisher>
			<biblScope unit="page" from="116" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Verifiable mixing (shuffling) of elgamal pairs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Neff</surname></persName>
		</author>
		<ptr target="http://people.csail.mit.edu/rivest/voting/papers/Neff-2004-04-21-ElGamalShuffles.pdf" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Non-interactive and Information-Theoretic Secure Verifiable Secret Sharing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1991</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="129" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Receipt-Free Mix-Type Voting Scheme -A Practical Solution to the Implementation of a Voting Booth</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1995</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Guillou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">921</biblScope>
			<biblScope unit="page" from="393" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<ptr target="http://www.shoup.net/ntl/" />
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Ntl library</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Proofs of Restricted Shuffles</title>
		<author>
			<persName><forename type="first">B</forename><surname>Terelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wikström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AFRICACRYPT 2010</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6055</biblScope>
			<biblScope unit="page" from="100" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">The complexity of a scheme of functional elements realizing the multiplication of integers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Toom</surname></persName>
		</author>
		<ptr target="http://www.de.ufpe.br/˜toom/my_articles/engmat/MULT-E.PDF" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The Security of a Mix-Center Based on a Semantically Secure Cryptosystem</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wikström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INDOCRYPT 2002</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2551</biblScope>
			<biblScope unit="page" from="368" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A Commitment-Consistent Proof of a Shuffle</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wikström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACISP 2009</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boyd</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>González Nieto</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5594</biblScope>
			<biblScope unit="page" from="407" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Wikström</surname></persName>
		</author>
		<ptr target="http://www.verificatum.com/" />
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Verificatum</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
