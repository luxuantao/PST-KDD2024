<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Making Mashups with Marmite: Towards End-User Programming for the Web</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jeffrey</forename><surname>Wong</surname></persName>
							<email>jeffwong@cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Human-Computer Interaction Institute</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jason</forename><forename type="middle">I</forename><surname>Hong</surname></persName>
							<email>jasonh@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Human-Computer Interaction Institute</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Making Mashups with Marmite: Towards End-User Programming for the Web</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B7E0F7C4B4C4B7A4949B868115EF1171</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>mashup</term>
					<term>end-user programming</term>
					<term>web</term>
					<term>spreadsheet</term>
					<term>user study H5.m. Information interfaces and presentation (e.g.</term>
					<term>HCI): Miscellaneous</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>There is a tremendous amount of web content available today, but it is not always in a form that supports end-users' needs. In many cases, all of the data and services needed to accomplish a goal already exist, but are not in a form amenable to an end-user. To address this problem, we have developed an end-user programming tool called Marmite, which lets end-users create so-called mashups that repurpose and combine existing web content and services. In this paper, we present the design, implementation, and evaluation of Marmite. An informal user study found that programmers and some spreadsheet users had little difficulty using the system.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>There is a tremendous amount of web content available today, but it is not always in a form that supports end-users' needs. For example, it is easy to find a list of hotels in San Jose, but it is not so easy to sort them by distance to the San Jose convention center. To do this today, an end-user would have to manually enter in each address into a mapping service and write down the distances for each, or manually construct software to do the same. There are two key observations here. First, all of the data and services needed to accomplish the goal above already exist, but they are not in a form amenable to her needs. Second, it is extremely unlikely that a web site will be able to support all the needs of all of its end-users. For these cases, we argue that it is better to provide tools that can help end-users help themselves.</p><p>What is interesting is that there is a rapidly growing community of web programmers creating so-called "mashups" that combine existing web-based content and services to create new applications. One of the earliest and best known mashups is housingmaps.com, which crawls rental listings from the Craigslist community web site and puts them on top of Google Maps. Rather than having to go through each of the text listings and manually entering each address into a map service, this mashup makes it easy for end-users to see a map of all the available rentals.</p><p>The desire to create mashups is strong. As of September 2006, ProgrammableWeb.com listed 1019 mashups created since the housingmaps.com mashup was deployed in April 2005, which is fairly rapid growth by any metric.</p><p>A key problem here, however, is that creating mashups requires a great deal of programming expertise in areas such as web crawling, text parsing, pattern matching, databases, and HTML. Thus, it takes a great deal of time and skill to create such services. Most tools to help endusers create mashups tend to emphasize low-level data processing or programming techniques that are beyond the ability of average web users. Furthermore, most end-user programming tools tend to focus on GUIs (e.g. automating repetitive actions) rather than processing existing webbased content and services, and are thus inappropriate for these kinds of online tasks.</p><p>To address this problem, we are designing, implementing, and evaluating Marmite, a tool that will let everyday endusers create these kinds of mashups (see Figure <ref type="figure" target="#fig_0">1</ref>). Marmite supports a data flow architecture, where data is processed by a series of operators in a manner similar to Unix pipes. For example, one scenario we are designing Marmite to support is, "find all of the addresses on this set of web pages, keep only the ones in Pennsylvania, and then put them all onto Google Maps." Another scenario that would let end-users create custom calendars is, "Every week, crawl through these five different web sites, extract all calendar events, sort them by date, and publish them on our intranet as a custom web page."</p><p>More specifically, Marmite lets end-users:</p><p>• Easily extract interesting content from one or more web pages (for example, names, addresses, dates, phone numbers, URLs, and other kinds of data types)</p><p>• Process it in a data flow manner, for example filtering out values or adding metadata</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>•</head><p>Integrate it with other data sources, either from local or remote databases, from other existing web pages or services (similar to a database join operation)</p><p>• Direct the output to a variety of sinks, such as databases, map services, text files, web pages, or compilable source code that can be further customized In this paper, we present the design, implementation, and evaluation of Marmite. We introduce a linked data flow / spreadsheet view that shows people how the data is being processed and what the current values of the data are. In other words, Marmite's linked view shows both the program and the data simultaneously. Our initial user study showed that some users were able to use this system and to construct programs with web services quickly without programming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>In this section, we position Marmite with respect to previous work in end-user programming, selecting content from web pages, website integration, the semantic web, and web services.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>End-User Programming</head><p>There has been a great deal of past work in end-user programming. For example, Cypher <ref type="bibr" target="#b4">[5]</ref> and Lieberman <ref type="bibr" target="#b19">[20]</ref> describe numerous programming-by-demonstration and programming-by-example systems. Kelleher and Pausch <ref type="bibr" target="#b12">[13]</ref> have also published a survey of programming languages and environments for novice programmers.</p><p>Creating a data flow to manipulate large data sets requires a user to engage in some form of programming. Research on end-user programming has found that programming is difficult for novices for a number of reasons <ref type="bibr" target="#b15">[16]</ref>. They must: enter syntactically correct code, find appropriate operations, and understand any programming errors that may arise <ref type="bibr" target="#b14">[15]</ref>. There are a variety of solutions to these problems (for a review, see <ref type="bibr" target="#b12">[13]</ref>). Marmite minimizes code entry problems by having users work with graphical dialog boxes that represent operations. While this does limit what users can do, it helps prevent errors by allowing users to incrementally add steps to their program and observe changes made to their data. Marmite also suggests what operators they might want to use next, based on what data is currently being processed.</p><p>The closest existing work to Marmite in the area of enduser programming is Apple's Automator <ref type="bibr" target="#b0">[1]</ref>, a tool that lets end-users create scripts for automating repetitive actions. Automator provides a large set of reusable operations that can be assembled into a data flow. Marmite was inspired by Automator, and builds on its ideas by focusing on end-user programming for the web rather than the desktop GUI, repurposing existing content and services rather than just repeating actions, and providing operations for parsing content. Marmite also introduces a linked spreadsheet/dataflow metaphor to help end-users understand what the current state of the data is.</p><p>An example of a programming system from the mashup community is DataMashups <ref type="bibr" target="#b6">[7]</ref>. DataMashups is a visual programming environment that lets the user create a website with common widgets that he or she might find in a web application. However, DataMashups is more similar to interface builders like Visual Basic than a data extraction and processing tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Website Integration</head><p>Anthracite <ref type="bibr" target="#b21">[22]</ref> is a "web mining desktop toolkit" with design goals similar to our own. It provides a graphical programming environment that lets users create data-flow automation over web pages. However, Anthracite is inaccessible to many end-users because using it requires understanding systems concepts such as regular expressions, databases, and HTML. While Anthracite is an improvement over the textual programming tools, our goal with Marmite is to lower the bar even more by simplifying the programming model, providing suggestions as to what the next step is, and providing better intermediate feedback so that end-users do not have to execute programs in their entirety to verify that they are correct.</p><p>C3W provides an interface for automating data flows in web applications <ref type="bibr" target="#b9">[10]</ref> using the metaphor of spreadsheet cells. With C3W, users can include functionality from any web application where the user fills out a web form and receives a result page. User can encapsulate a web form into a function by creating "cells" that map to the inputs of the form. The user then tells C3W how to find the data of interest in the resulting page and assigns a function name to encapsulated form. The function can then be used in spreadsheet formulas. For example, the user can take a company's stock trading symbol as input, find its dollar price by creating a function out of a web page that looks up the stock quote, and then convert this price into Japanese Yen by flowing this data through another web site.</p><p>Hunter Gatherer <ref type="bibr" target="#b29">[31]</ref> and the Internet Scrapbook <ref type="bibr" target="#b31">[33]</ref> are tools that enable users to interactively extract components of multiple web pages and assemble them into a single web page or a collection.</p><p>Our work differs from these systems in that we focus on extracting masses of typed data from web pages or even entire web sites, identifying data types of attributes of each item of data, providing a set of operations for the relevant data types found, and applying operations to a large set of data. For example, a listing of movies from a web site may be spread over several pages and have attributes such as the title (a string), rating (a number), and running time (also a number). When data is extracted from web pages and is broken down into constituent attributes and types, users can manipulate extracted web content with more flexibility and power. Listings can be sorted or filtered by an attribute and attributes can be operated on. If we have a listing of books with title and publication date attributes, we can look up price for the correct edition of each book in a bookseller's web service.</p><p>Hunter Gatherer and Internet Scrapbook focus on extraction of textual clips from web pages, without specifically breaking down extracted web pages into data items with typed attributes. Although C3W can make a function out of nearly any web form, it does not appear to be easy to work with larger sets of data (for instance, applying a function to a large listing of items). Users must invoke functions using a syntax for spreadsheet formulas. Furthermore, our Marmite focuses on providing an interface to web services. Some web services provide access to the core functionality that may be more flexible and lower-level than what a user would encounter using the web interface. Working with and remixing the sub-components of multiple websites is how most programmers create mashups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Web Content Selection</head><p>We argue that one of the key challenges of end-user programming for the web is making it easy for end-users to specify what parts of a page or set of pages they want. This is difficult because there is such a wide range of possibilities. For example, by selecting a single link from a page, a person might want just that link, all links in that group, all links on that page that are not part of the overall navigation, all links on that page, or all of the aforementioned possibilities but for a set of pages. It is possible to apply well-known machine learning techniques or programming by demonstration techniques here; however, the challenge is to find the right combination of simplicity and flexibility that will help end-users succeed.</p><p>Identifying patterns of relevant information on a web page can be done with web page parsing APIs, frameworks for existing programming languages <ref type="bibr" target="#b23">[25]</ref>, or specialized languages <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b13">14]</ref>. There has also been a great deal of work in developing data wrappers, programs that extract data from a web site so that it can be manipulated by traditional database systems <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. However, most of these tools are aimed at programmers.</p><p>Recent work has attempted to mitigate these problems. Chickenfoot <ref type="bibr" target="#b2">[3]</ref> can match text using natural language expressions (e.g. "just before the text box") but requires programming in JavaScript. PiggyBank <ref type="bibr" target="#b10">[11]</ref> extracts data from websites that are augmented with semantic data but requires JavaScript to extract data from normal websites. There has also been a great deal of work in automatically inferring structure in freeform text (for example, <ref type="bibr" target="#b27">[29,</ref><ref type="bibr" target="#b28">30,</ref><ref type="bibr">23,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b7">8]</ref>). Our goal with Marmite is not to innovate in these areas, but rather to use these algorithms to facilitate data extraction. Our current implementation of Marmite uses a pattern-matching algorithms from Sifter <ref type="bibr" target="#b11">[12]</ref> and Solvent <ref type="bibr" target="#b30">[32]</ref> , which uses XPath <ref type="bibr" target="#b32">[34]</ref> queries to help the user select and extract multiple data of interest from a single page. Creo and Miro <ref type="bibr" target="#b8">[9]</ref> compose a system which helps users extract information using a combination of programming-by-demonstration (PBD) and semantic libraries <ref type="bibr" target="#b20">[21]</ref>.</p><p>Dapper <ref type="bibr" target="#b5">[6]</ref> is a tool for creating screen-scrapers that allows a user to access any web page as if it was structured data in an XML document. Although it is an excellent way to avoid having to write a screen-scraper, it is geared more towards programmers who can make use of its output.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Semantic Web and Web Services</head><p>There is also some related work in the area of the Semantic Web <ref type="bibr" target="#b32">[34]</ref>, an effort to embed machine-readable meaning and semantics to the large body of information that exists on the web. The goal is to transform this knowledge into a machine readable form so that computers can reason based on this information. Our goal with Marmite is orthogonal to Semantic Web efforts. If the Semantic Web takes off, then we can later adapt Marmite so that it can make use of those technologies. However, it is important to point out that there is a great deal of existing content already available, and that even if the Semantic Web takes off, we still have the same problem as before, namely that content and service providers cannot always predict all end-users' needs in advance.</p><p>Web services are a programmatic interface to the web, using the web as a medium for providing services through well-defined APIs with clear semantics (meant for computers) rather than just HTML (meant for people). The problem is that web services are again aimed at programmers rather than end-users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FORMATIVE DESIGN</head><p>To quickly explore the design space, we conducted a series of small studies to inform our design, consisting of a user test of Apple's Automator <ref type="bibr" target="#b0">[1]</ref>, a blank paper study, and a series of low-fidelity paper prototypes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Automator Usability Study</head><p>Marmite was inspired by Automator, but is focused more on extraction and processing of web data. Thus, we felt that a running basic usability test with Automator would help us understand some potential usability problems that Marmite might encounter.</p><p>In Automator, end-users create a workflow by chaining together a series of operations. End-users can choose operations from desktop applications they are familiar with, such as getting email addresses from the address book application or retrieving a web page with the the Web browser. We asked three participants to complete three tasks. The first task was a simple warm-up task and the other two were operations that involved traversing a large number of links and downloading a large number of images.</p><p>We found the following problems:  <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Blank Paper Study</head><p>To design a method for interactively extracting text from a web page, we conducted a blank paper study, inspired by similar studies in natural programming designs <ref type="bibr" target="#b26">[28]</ref>. In these blank paper studies, three participants were asked to write down unambiguous instructions for another person that would extract multiple instances of a data type (such as a company or hotel name) from a web page. They used semantic references such as "get all of the names of companies." Some participants used drawings and referred to the typographical features (e.g. "all of link text up until the hyphen").</p><p>This finding suggests that since users would most likely extract information based on semantics, typographic, or other features that can be difficult for a computer to understand or even ambiguous for a human being, the system must use a variety of heuristics, data detectors, or semantic detectors <ref type="bibr" target="#b8">[9]</ref> to come up with some guesses about what data the user wants. The system and the user can then engage in a negotiation to navigate between guesses and the parameters of guess to arrive at what is actually desired (or close to it).</p><p>We address this problem in Marmite's design by having the user interactively detect relevant data. The system should try to guess what patterns of information are desired and find the user's intent is through negotiation. This feature is only partially supported in the current implementation of Marmite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Paper Prototypes</head><p>We conducted six rounds of paper prototypes with twenty participants. The paper prototype allowed users to assemble a sequence of operators (a data flow) that performed some tasks on a set of data. When an operator executes, its output is available as input for the following operation. Users could see the results of operations in tables to the right of the data flow. Each operator was associated with a beforeand-after view of the data.</p><p>Our vision for our design was that users would be able to interact with web services as graphical operators. The operators would be built and connected to web services by programmers who could add their operators to Marmite operator pool. Some of these might be provided by web service providers themselves, who might be interested in increasing the use of their services.</p><p>As we were evaluating the paper prototypes, we noticed that even though users might understand how Marmite worked conceptually, the usability of Marmite was still very sensitive to the design of the individual operators. This was a major concern Marmite's operators would be created by programmers. We decided to address this in our high-fidelity prototype by creating a code framework where the interface was generated for the developers simply by specifying their inputs and outputs. This enables Marmite operators to be consistent and lets programmers concentrate on connecting to the web services.</p><p>Users also felt that it was difficult to know where to start. We modified the paper design to include template dataflows for common tasks. Some participants using our low-fi prototypes commented that it would be easier to use Marmite if they had examples to examine or modify. Template data-flows can be included to show the range of tasks that can be accomplished. This feature is not implemented in the current version of Marmite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THE MARMITE SYSTEM</head><p>Marmite is currently implemented as a Firefox plug-in using JavaScript and XUL. We choose to make Marmite a part of Firefox rather than a standalone application for several reasons. First, we thought that close integration with a common web-browser would be beneficial for usability, adoption, and development. Being in the web browser, Marmite would be very close to the user's web browsing experience. If the user were to find some data that he or she would like to manipulate, the user would not have to launch a separate program to begin using Marmite. Second, integrating Marmite with the browser also makes it easier to manipulate private or protected data that is guarded by passwords, cookies, or other web security mechanisms that the browser is normally used to access. Third, we felt that a browser plug-in would have lower barriers to adoption than traditional applications. Installation of a Firefox extension can be done by simply clicking on a link and restarting Firefox. The Firefox platform also automatically tracks updates for plug-ins and notifies the user when new versions are available.</p><p>Marmite's interface (see Figure <ref type="figure" target="#fig_0">1</ref>) consists of three major areas: the operator selection area (left, not shown in Figure <ref type="figure" target="#fig_1">3</ref> below), the data flow area (middle), and the spreadsheet display (right). Users select operators from the operator selection area, place them into the data flow, and view the current state of the data at a particular operator in a table, which shows what the data looks like after it has passed through an operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data Flow View of Operations</head><p>Operators represent pieces of code that either access web services or are functions that operate locally on data. Operators are chained together in a data flow where the results of one operation are passed as input to the next operation, similar to Apple Automator <ref type="bibr" target="#b0">[1]</ref> and Anthracite <ref type="bibr" target="#b21">[22]</ref>. The data that flows through the operators is represented in a table. The basic unit of work for each operator is a row in the table (as opposed to columns or a single cell). Each piece of data has various attributes which are represented by different columns in the table.  Figure <ref type="figure" target="#fig_1">3</ref> shows an example. The first operator retrieves event information from a web service. The event objects have 6 attributes: the name of the event (column A), the date of the event (column B), the event venue (column C), the city where it is being held (column D), and latitude and longitude coordinates (offscreen). By adding objects to the data-flow, the first operator creates a schema for the data table, where each column is internally labeled with a data type. Subsequent operators add to this schema when they add columns, which might happen if additional attributes are retrieved for each piece of data.</p><p>The second operator is an event filter that removes rows from the data if they meet a certain criteria. It has a single argument; it needs to know which column to use as the date field. If the operator's inputs and the previous operator's outputs use the same label for their types, inputs and outputs can be matched automatically and connected. However, Marmite is intended to be an open platform where individuals and providers of web services create their own operators and may have different ways of labels for their data types. For example, a web service that provides event listings may have a field called "time" that indicates when an event is starting. An operator from a calendar service may call that same a field called "start time." In this case, Marmite would not automatically connect these listings service output to the calendar input; user would have to do that manually.</p><p>Some operators provide alternative displays of the data. For example, Figure <ref type="figure" target="#fig_2">4</ref> shows a continuation of our data flow, with a third operator that displays all of the events on top of a map. Each operator can also be collapsed to save space. For example, in Figure <ref type="figure" target="#fig_2">4</ref>, steps 1 and 2 are collapsed.</p><p>Each operator comes with three buttons to control the execution of the operator: Reload, Pause, and Play. Operators do not execute immediately after being placed into the data flow because they may have arguments that need to be set before any meaningful execution can occur. The user then needs to press the "Play" button for the operator to begin its work.</p><p>These controls were motivated by our user study of Apple Automator. We found that users had trouble creating correct sequences of operations because the user would typically create a data flow and test it as a single unit. Unless the user had planned in advance to restrict the initial data set to a few small items, the data flow would operate on the entire set of data and errors would only be visible at the end of the process. When operations involved accesses to the network, specifically to web pages or web services, this increased the time it took to debug a process. Consequently, Marmite allows the user more control over execution, making it easier to test a data flow on a small sample of the data before committing to executing the data flow on a much larger dataset.</p><p>Operators are written in JavaScript and XBL (Extensible Binding Language). XBL encapsulates the JavaScript code for an operator, and is the glue that links JavaScript code to Marmite's operator framework. XBL makes it easy to provide some basic GUI controls and minimizes the amount of work required to interact with other operators in a data flow as well as the rest of Marmite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Spreadsheet View of Data</head><p>In the Marmite interface, each operator is associated with a table that shows the state of the data after the operator has been run (see Figure <ref type="figure" target="#fig_1">3</ref>). The table is displayed in the results/display area on the right. Each row in the table corresponds to a piece of data with multiple attributes. Users can view the current state of the data after executing each step. This lets the user see the effects of operations right away and identify problems immediately.</p><p>It should be noted that our spreadsheet view is currently read-only, in that end-users cannot click on a cell and modify the data. This may change in later versions of Marmite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inputs and Outputs</head><p>Marmite currently has three categories of operators:</p><p>Sources: These operators add data into Marmite by querying databases, extracting information from web pages, and so on.</p><p>Processors: These operators modify, combine, or delete existing rows. Example operators include geocoding (converting street addresses to latitude and longitude) and filtering. Processor operators might add or remove columns as well.</p><p>Sinks: These operators redirect the flow the data out of Marmite. Examples include showing data on a map, saving it to a file, or to a web page. In Marmite, each of these columns is associated with a data type that is defined by the operator that created that column. Each operator is visually divided into controls for inputs and controls for outputs. Operators that accept input from the previous operators have input parameters. Some of these may be taken from a column in the data flow and some of these may be fixed parameters that aren't specific to the row being operated on. Since data types are defined by operator authors, inputs for one operator have to be matched with the outputs for the previous operator. If Marmite cannot perform this match automatically, the user has to tell the operator where to take each argument from. For example, Figure <ref type="figure" target="#fig_1">3</ref> shows the visual details of two operators. The second operator is a filter for removing rows from the data flow. It has an argument which it accepts from each row, the date of the event, and an argument which applies to all rows, the date which should be used to filter the events. The argument for the date of the event is set to column "B," which is known as "Time" to the previous operator.</p><p>Although we could have made the operators in this version of Marmite all use the same set of types, operators can be used represent function calls to web service APIs. Web service APIs, in turn, all define their own data type. We also don't expect future operator writers to all agree on type compatibility. Although we hope to encourage operator writers to all agree on a single way to refer to data types, the design decision to allow manual type matching between operators in a data flow is based on the conservative assumption that type standardization is not guaranteed in the future.</p><p>Currently, Marmite has a small set of pre-defined data types, such as time, address, and number. Marmite also has a very basic data type resolution system. For Marmite to achieve wide-scale traction, it will require a larger set of useful data types that most authors of operators can agree on. This issue is beyond the scope of this current paper, but it is important to note that this is a fundamental and wellknown problem in many domains, including federating databases, XML schemas, and the semantic web.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Operator Groupings</head><p>The operator list contains a set of operators which can be added to the data flow. But rather than using a simple list, we implemented the operator as a tree that grouped similar operators together. This was intended to help users find operators more quickly because they are able to skip over that are inapplicable to their task. Figure <ref type="figure" target="#fig_3">5</ref> shows the operator menu.</p><p>Because Marmite knows what data types are currently in the data flow, it can provide a list of "suggested operators." This list only includes operators that are compatible with the data types. We incorporated this feature to make it easier for end-users to find relevant operators.   <ref type="figure"></ref>and<ref type="figure" target="#fig_2">4</ref> show a highly specific source operator that makes it easy to extract information from a pre-specified web site, in this case, the event site upcoming.org. To extract more general information from arbitrary web pages, we also provide an operator that, when played, opens a new browser window. Users are then led through a series of wizard screens (see Figure <ref type="figure" target="#fig_5">6</ref>) that let the user select an example of the items of interest, provide some feedback on the system's guess about the items of interest, and finally manually add or remove items that were either unintentionally picked or not included.</p><p>Currently, this operator only uses a simple XPath pattern matcher based on the one found in Solvent <ref type="bibr" target="#b30">[32]</ref> to select links that might be similar enough to the user's example. Figure <ref type="figure" target="#fig_5">6</ref> shows a screen with the controls of the wizard laid on top. XPath pattern matching tends to work well for web pages where individual items of data in listings are in their own HTML tags.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FORMATIVE EVALUATION</head><p>We conducted a user study with 6 people to identify usability issues and how usable our design was for different classes of users. Since we incorporated some aspects of spreadsheets to make Marmite more familiar to certain types of users, we also wanted to determine how understandable these were. Note that we made two minor modifications to the user interface during the evaluation phase, as described later.</p><p>We divided our participants into three groups: users familiar with programming, users familiar with spreadsheets but not programming, and users who were not familiar with spreadsheets or programming.</p><p>We recruited participants by posting an advertisement on our local Craigslist website as well as a popular university bulletin board. Using email surveys, we asked our participants about Internet use and familiarity with spreadsheets and programming. We had two people in each of the following groups:</p><p>• Little or no spreadsheet or programming familiarity ("no-experience" group)</p><p>• Familiar with spreadsheets (including formulas)</p><p>• Familiar with programming Participants who had taken programming classes in the past but claimed to be bad or unfamiliar with programming were not included in the programming group.</p><p>The testing was conducted on a 12-inch Apple Powerbook G4. A mouse was provided and was used by most users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tasks</head><p>Because Marmite is not intended as a walk-up-and-use system, users were provided with a warm-up task to help familiarize them with the system. The instruction sheet for the warm-up task explained what actions were needed to retrieve a set of addresses and how to geocode an address (that is, transform a street address into latitude and longitude, a prerequisite before putting items onto a map).</p><p>After completing the warm-up task, users were asked to complete three more tasks of increasing complexity. The three tasks were:</p><p>1. Search for events and filter out events further than a week away. Here, we wanted to see if participants could use two operators to achieve a result, and to assess the basic usability of the system.</p><p>2. Compile a list of events from multiple event services and plot them on a map. (The two event services have different output schemas, can users make sure they are merged?)</p><p>3. Given a web page with links to some apartment rental listings, plot those apartments on a map. We wanted to understand if our design for screen-scraping links from a page was usable. This is similar to the functionality offered by the mashup HousingMaps.com. Figure <ref type="figure" target="#fig_6">7</ref> shows an example of a completed data flow for this task.</p><p>Our first two participants were unable to do most of the tasks due to labeling problems in the operators. We added some labeling to indicate that the column-selection menus would tell the operator which column should be examined for each argument that it needed. Of the four remaining users, both users in the programming group and one user in the spreadsheet group were able to complete the tasks with little difficulty.</p><p>We also decided to turn off the automatic appearance of suggested operators after the first test when the user got extremely disoriented by apparently unexplainable changes. We changed this so that instead of appearing automatically, user would have to ask for them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Observations</head><p>Three of the participants were able to complete most of the tasks without difficulty: one from the spreadsheets group and two from the programming group. Participants who were able to complete all of the tasks completed them in under an hour.</p><p>The users in the programming group seemed enthusiastic about the tool and wanted to be notified when Marmite was complete. One user mentioned that it would be possible to use a tool like this to replicate the some of the functionality data aggregation and visualization services such as the Multiple Listing Service real estate database, which he remarked was too expensive for ordinary people.</p><p>If users were to do this in a programming environment, they would have to figure out how to access web services represented by our operators or replicate the code they represent, write the code, and debug it. Furthermore, this would have been impossible for the users in the spreadsheet group. It is also worth noting that the housingmaps.com mashup replicated in this task was developed by a highly skilled professional programmer.</p><p>Since the focus of our user study was to identify usability problems in our current tool, the rest of this section discusses problems we uncovered.</p><p>For the 3 participants who were unable to complete the tasks, the main barrier was understanding the concept of a data flow. These users were puzzled by the meaning of selecting inputs and outputs. Users deleted operators they had successfully used not knowing that they were erasing data. These users believed that an operator was no longer needed once it had been used to produce a result in the spreadsheet view. They also did not seem to believe that there was any particular order to the operators, viewing them as highly interactive tools to simply change the current state of the data, not as pieces of a sequence that needed to be built up.</p><p>For the most part, users had several did not attempt to have the same model of how the operators interacted with the results tables that were displayed on the right. When these users played an operator, they believed that operator has made some changes to that copy of the table. In our system, each operator has its own copy of the data, which is present in the third column. Deleting an operator would delete the table associated with that operator. The operator after it in the data flow would have no prior operator to fetch the data from. Similarly, users who were stuck would close operators and lose all of the results from those operators. One possible solution is to change operators so that they do not own tables and instead to make tables objects in their own right.</p><p>One of the non-programming users did not like trying to accomplish their tasks with primitive operators. She said that they preferred richer interactions where, once the data type was introduced to the table, helpful displays about that data should made visible. For example, one user commented that once he extracted a list of URLs to web pages that each had rental listings, he would have liked to have immediately other useful attributes such as price, location to be extracted without having to use separate operators to get each piece of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FUTURE DIRECTIONS</head><p>Our user tests revealed a number of directions for improvement:</p><p>In this version of Marmite, we only had a very basic screenscraping operator. We plan add more sophisticated screenscraping functionality and incorporate a more diverse set of heuristics and data detection algorithms.</p><p>Another direction that we are looking at is to significantly expand the set of operators, and create a way to transform a data flow into a mashup website. The recent explosion of mashup-making activity was caused by the increased availability of web services APIs. A similar increase in the number of available operators might encourage experimentation. One method of doing this is to automatically generate operators from machine-readable web service descriptions (WSDL) offered by web services providers.</p><p>We also plan to make some changes in operator feedback or the placement of the data tables on the screen to address the usability problems encountered by some of the nonprogrammer users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSIONS</head><p>It is important to note that there is a growing need for a tool like Marmite. Existing web sites and cannot always predict the needs of all of its end-users. Thus, it is important to provide tools that can help end-users help themselves.</p><p>In this paper, we presented the design, implementation, and evaluation of Marmite, a tool for end-user programming on the web. Marmite works by displaying a linked data flow / spreadsheet view, letting people see the program as well as the data simultaneously. A small user study showed it was possible to replicate the functionality of a popular mashup website.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Marmite is an end-user programming tool for creating web-based mashups. On the left is a set of operators that users can select to extract and process data from web pages. In the middle is the data flow, and on the right is a spreadsheet view that shows the current values of the data.</figDesc><graphic coords="1,312.72,453.64,299.04,196.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. A data flow showing an operator which retrieves event records from a web service and passes it to an operator which filters the records by date. Note that this screenshot does not show the operator selection area, that is the set of possible operators that can be added.</figDesc><graphic coords="5,58.56,269.80,242.88,182.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. This figure shows the same data flow as in Figure 3 but with an extra operator added. The final operator is showing a map view rather than the default spreadsheet view.</figDesc><graphic coords="5,61.92,517.72,236.16,171.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5</head><label>5</label><figDesc>Figure 5 Operators are placed in groups to improve browsing. The menu above the list allows the user select to select alternative groupings (e.g. show only operators that can take the current data as input)</figDesc><graphic coords="7,116.64,439.24,115.68,240.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figures 3</head><label>3</label><figDesc>Figures3 and 4show a highly specific source operator that makes it easy to extract information from a pre-specified web site, in this case, the event site upcoming.org. To extract more general information from arbitrary web pages, we also provide an operator that, when played, opens a new</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. This figure shows our wizard for selecting items of interest from a web page.</figDesc><graphic coords="7,315.12,126.04,242.88,251.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 A</head><label>7</label><figDesc>Figure 7 A dataflow that mimics the functionality of the housingmaps.com website. Note that Step 1 and 2 are collapsed to save space.</figDesc><graphic coords="8,315.12,194.44,252.00,186.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Since it can take a large amount of time to execute programs that involve large amounts of data, it was difficult to rapidly iterate on programs and ensure that the programs do the right thing. This was especially problematic for programs that copied or downloaded files, since the copies would have to be deleted before trying again.</figDesc><table><row><cell>Solution: Show results of intermediate steps. Many end-user programming tools take either a program-centric view, where the program itself is the main view, or a data-centric view (most notably spreadsheets), which emphasizes the data over the program. In our paper prototypes, we developed a linked data flow / spreadsheet view that shows the program itself (data flow) as well as the effects of a given step in that data flow (spreadsheet view). 3. Solution: Support incremental execution. Participants in the Automator study and in our paper-prototype study found the operators fairly easy to understand and use, as they made programming easier by letting people build programs incrementally and correct errors earlier. 4. Participants often generated theories about why problems occurred but were not effective at coming up with theories to test them. This is consistent with prior work on end-user programming [16]. Solution: Incremental execution and showing intermediate results helps alleviate this problem somewhat because it is easier to see where the problem occurred. Automatic generation of theories for programming bugs is currently an open problem in software engineering</cell></row></table><note><p>1. Participants had a hard time knowing what operation to select. This was especially when for creating a new dataflow. Although we showed our participants several examples of how to chain operations together, they often had a hard time selecting the first operation to get started. Solution: Suggest relevant next actions. In our prototypes, we developed a few ways of having Marmite suggest what kinds of operations they may want to do next, based on the data currently available. For example, if there was street address data available, Marmite would suggest generating a map as one of the next operations. 2. Participants had no feedback about what the state of the data was in between operations.</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work is supported in part by a National Science Foundation grant IIS-0646526 and Intel Research. We also thank Duen-Horng (Polo) Chau for his support and assistance. We thank Michael Twidale and Cameron Jones for their enthusiasm and support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">Automator</forename><surname>Apple</surname></persName>
		</author>
		<ptr target="http://www.apple.com/macosx/features/automator/" />
		<title level="m">Personal Automation Assistant</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">How to Personalize the Web</title>
		<author>
			<persName><forename type="first">R</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Maglio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kellem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CHI&apos;97</title>
		<meeting>CHI&apos;97</meeting>
		<imprint>
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automation and customization of rendered web pages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Webber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UIST &apos;05</title>
		<meeting>UIST &apos;05</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="163" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Methods for Identifying Names and Ontological Relations in Text using Heuristics for Inducing Regularities from Data</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><surname>Minorthird</surname></persName>
		</author>
		<ptr target="http://minorthird.sourceforge.net" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Watch What I Do: Programming by Demonstration</title>
		<author>
			<persName><forename type="first">Allen</forename><surname>Cypher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="http://www.dappit.com" />
		<title level="m">Dapper</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="http://www.datamashups.com" />
		<title level="m">DataMashups</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Addressgrabber</forename><surname>Egrabber</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-02-03">Business 3.2.1</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A goal-oriented web browser</title>
		<author>
			<persName><forename type="first">A</forename><surname>Faaborg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lieberman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CHI</title>
		<meeting>CHI</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="page" from="751" to="760" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Clip, Connect, Clone: Combining Application Elements to Build Custom Interfaces for Information Access</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fujima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lunzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hornbaek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tanaka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UIST2004</title>
		<meeting>UIST2004</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="175" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Piggy Bank: Experience the Semantic Web Inside Your Web Browser</title>
		<author>
			<persName><forename type="first">D</forename><surname>Huynh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Mazzocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Karger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference (ISWC)</title>
		<meeting><address><addrLine>Galway, Ireland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-11">November 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Enabling web browsers to augment web sites&apos; filtering and sorting functionalities</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Huynh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UIST &apos;06</title>
		<meeting>UIST &apos;06</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="125" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Lowering the barriers to programming: A taxonomy of programming environments and languages for novice programmers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kelleher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pausch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="83" to="137" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">WebL -a programming language for the Web</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kistler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Marais</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. WWW</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="259" to="270" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Human Factors Affecting Dependability in End-User Programming. 1st Workshop on End-User Software Engineering</title>
		<imprint>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2005">2005</date>
			<pubPlace>St. Louis, MI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Six Learning Barriers in End-User Programming Systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Aung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Symp. On VLHCC</title>
		<imprint>
			<biblScope unit="page" from="199" to="206" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Designing the Whyline: A Debugging Interface for Asking Questions About Program Failures</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CHI 2004</title>
		<meeting>of CHI 2004</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Toolkits for Generating Wrappers -A Survey of Software Toolkits fo Automated Data Extraction from Web Sites</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kuhlins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tredwell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="page" from="184" to="198" />
			<date type="published" when="2003">2591 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Brief Survey of Web Data Extraction Tools</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H F</forename><surname>Laender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Ribeiro-Neto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S D</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Teixeira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="93" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Your Wish is My Command: Programming by Example</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lieberman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Morgan Kaufmann</publisher>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">ConceptNet -A Practical Commonsense Reasoning Tool-Kit</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BT Technology Journal</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="211" to="226" />
			<date type="published" when="2004-10">October 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Metafy</forename><surname>Anthracite</surname></persName>
		</author>
		<ptr target="http://www.metafy.com/products/anthracite" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Lightweight Structure in Text</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Pittsburgh</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note>Unpublished PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">SPHINX: A Framework for Creating Personal</title>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Bharat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Site-Specific Web Crawlers. Proc</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="119" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<ptr target="http://www.mozilla.org/projects/xbl/xbl.html" />
		<title level="m">Mozilla Foundation, XBL (Extensible Binding Language)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<ptr target="http://www.mozilla.org/projects/xul/" />
		<title level="m">Mozilla Foundation, XUL (XML User Interface Language)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Natural Programming Languages and Environments</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Pane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. Of the ACM</title>
		<imprint>
			<biblScope unit="page" from="47" to="52" />
			<date type="published" when="2004-09">Sept. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Collaborative Programmable Intelligent Agents</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="96" to="104" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The Selection Recognition Agent: Instant Access to Relevant Information and Operations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Pandit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kalbag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Intelligent User Interfaces</title>
		<meeting>International Conference on Intelligent User Interfaces<address><addrLine>Orlando, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="47" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Interaction support for the creation and management of within-Web-page collections</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Modjeska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wigdor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hunter</surname></persName>
		</author>
		<author>
			<persName><surname>Gatherer</surname></persName>
		</author>
		<idno>CSRG-437</idno>
		<imprint>
			<date type="published" when="2001-10">October 2001</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<ptr target="http://simile.mit.edu/solvent/" />
		<title level="m">Solvent</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Internet scrapbook: automating Web browsing tasks by demonstration</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sugiura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Koseki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc UIST &apos;98</title>
		<meeting>UIST &apos;98</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="9" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">Xpath</forename><surname>W3c</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/xpath" />
		<title level="m">XML Path Language</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Semantic</forename><surname>W3c</surname></persName>
		</author>
		<author>
			<persName><surname>Web</surname></persName>
		</author>
		<ptr target="http://www.w3.org/2001/sw/" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
