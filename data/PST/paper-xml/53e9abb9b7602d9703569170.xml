<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Feature Construction for Inverse Reinforcement Learning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sergey</forename><surname>Levine</surname></persName>
							<email>svlevine@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zoran</forename><surname>Popović</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Washington</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vladlen</forename><surname>Koltun</surname></persName>
							<email>vladlen@cs.stanford.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Feature Construction for Inverse Reinforcement Learning</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3647DB51AFA50F645384FB84BCD0AE2D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The goal of inverse reinforcement learning is to find a reward function for a Markov decision process, given example traces from its optimal policy. Current IRL techniques generally rely on user-supplied features that form a concise basis for the reward. We present an algorithm that instead constructs reward features from a large collection of component features, by building logical conjunctions of those component features that are relevant to the example policy. Given example traces, the algorithm returns a reward function as well as the constructed features. The reward function can be used to recover a full, deterministic, stationary policy, and the features can be used to transplant the reward function into any novel environment on which the component features are well defined.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Inverse reinforcement learning aims to find a reward function for a Markov decision process, given only example traces from its optimal policy. IRL solves the general problem of apprenticeship learning, in which the goal is to learn the policy from which the examples were taken. The MDP formalism provides a compact method for specifying a task in terms of a reward function, and IRL further simplifies task specification by requiring only a demonstration of the task being performed. However, current IRL methods generally require not just expert demonstrations, but also a set of features or basis functions that concisely capture the structure of the reward function <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>.</p><p>Incorporating feature construction into IRL has been recognized as an important problem for some time <ref type="bibr" target="#b0">[1]</ref>. It is often easier to enumerate all potentially relevant component features ("components") than to manually specify a set of features that is both complete and fully relevant. For example, when emulating a human driver, it is easier to list all known aspects of the environment than to construct a complete and fully relevant reward basis. The difficulty of performing IRL given only such components is that many of them may have important logical relationships that make it impossible to represent the reward function as their linear combination, while enumerating all possible relationships is intractable. In our example, some of the components, like the color of the road, may be irrelevant. Others, like the car's speed and the presence of police, might have an important logical relationship for a driver who prefers to speed.</p><p>We present an IRL algorithm that constructs reward features out of a large collection of component features, many of which may be irrelevant for the expert's policy. The Feature construction for Inverse Reinforcement Learning (FIRL) algorithm constructs features as logical conjunctions of the components that are most relevant for the observed examples, thus capturing their logical relationships. At the same time, it finds a reward function for which the optimal policy matches the examples. The reward function can be used to recover a deterministic, stationary policy for the expert, and the features can be used to transplant the reward to any novel environment on which the component features are well defined. In this way, the features act as a portable explanation for the expert's policy, enabling the expert's behavior to be predicted in unfamiliar surroundings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Algorithm Overview</head><p>We define a Markov decision process as M = {S, A, θ, γ, R}, where S is a state space, A is a set of actions, θ sas is the probability of a transition from s ∈ S to s ∈ S under action a ∈ A, γ ∈ [0, 1) is a discount factor, and R(s, a) is a reward function. The optimal policy π * is the policy that maximizes the expected discounted sum of rewards E [ ∞ t=0 γ t R(s t , a t )|π * , θ]. FIRL takes as input M \ R, as well as a set of traces from π * , denoted by D = {(s 1,1 , a 1,1 ), ..., (s n,T , a n,T )}, where s i,t is the t th state in the i th trace. FIRL also accepts a set of component features of the form δ : S → Z, which are used to construct a set of relevant features for representing R.</p><p>The algorithm iteratively constructs both the features and the reward function. Each iteration consists of an optimization step and a fitting step. The algorithm begins with an empty feature set Φ (0) . The optimization step of the i th iteration computes a reward function R (i) using the current set of features Φ (i-1) , and the following fitting step determines a new set of features Φ (i) .</p><p>The objective of the optimization step is to find a reward function R (i) that best fits the last feature hypothesis Φ (i-1) while remaining consistent with the examples D. This appears similar to the objective of standard IRL methods. However, prior IRL algorithms generally minimize some measure of deviation from the examples, subject to the constraints of the provided features <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>. In contrast, the FIRL optimization step aims to discover regions where the current features are insufficient, and must be able to step outside of the constraints of the these features. To this end, the reward function R (i) is found by solving a quadratic program, with constraints that keep R (i) consistent with D, and an objective that penalizes the deviation of R (i) from its projection onto the linear basis formed by the features Φ (i-1) . The fitting step analyzes the reward function R (i) to generate a new feature hypothesis Φ (i) that better captures the variation in the reward function. Intuitively, the regions where R (i) is poorly represented by Φ (i-1) correspond to features that must be refined further, while regions where different features take on similar rewards are indicative of redundant features that should be merged. The hypothesis is constructed by building a regression tree on S for R (i) , with the components acting as tests at each node. Each leaf contains some subset of S, denoted φ . The new features are the set of indicator functions for membership in φ . A simple explanation of the reward function is often more likely to be the correct one <ref type="bibr" target="#b6">[7]</ref>, so we prefer the smallest tree that produces a sufficiently rich feature set to represent a reward function consistent with the examples. To obtain such a tree, we stop subdividing a node when setting the reward for all states in φ to their average induces an optimal policy consistent with the examples.</p><p>The constructed features are iteratively improved through the interaction between the optimization and fitting steps. Since the optimization is constrained to be consistent with D, if the current set of features is insufficient to represent a consistent reward function, R (i) will not be well-represented by the features Φ (i-1) . This intra-feature reward variance is detected in the fitting step, and the features that were insufficiently refined are subdivided further, while redundant features that have little variance between them are merged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Optimization Step</head><p>During the i th optimization step, we compute a reward function R (i) using the examples D and the current feature set Φ (i-1) . This reward function is chosen so that the optimal policy under the reward is consistent with the examples D and so that it minimizes the sum of squared errors between R (i) and its projection onto the linear basis of features Φ (i-1) . Formally, let T R→Φ be a |Φ (i-1) | by |S| matrix for which T R→Φ (φ, s) = |φ| -1 if s ∈ φ, and 0 otherwise, and let T Φ→R be a |S| by |Φ (i-1) | matrix for which T Φ→R (s, φ) = 1 if s ∈ φ, and 0 otherwise. Thus, T Φ→R T R→Φ R is a vector where the reward in each state is the average over all rewards in the feature that state belongs to. Letting π R denote the optimal policy under R, the reward optimization problem can be expressed as:</p><formula xml:id="formula_0">min R R -T Φ→R T R→Φ R 2 s.t. π R (s) = a ∀ (s, a) ∈ D<label>(1)</label></formula><p>Unfortunately, the constraint (1) is not convex, making it difficult to solve the optimization efficiently. We can equivalently express it in terms of the value function corresponding to R as</p><formula xml:id="formula_1">V (s) = R(s, a) + γ s θ sas V (s ) ∀ (s, a) ∈ D V (s) = max a R(s, a) + γ s θ sas V (s ) ∀ s ∈ S<label>(2)</label></formula><p>These constraints are also not convex, but we can construct a convex relaxation by using a pseudovalue function that bounds the value function from above, replacing (2) with the linear constraint</p><formula xml:id="formula_2">V (s) ≥ R(s, a) + γ s θ sas V (s ) ∀ s / ∈ D</formula><p>In the special case that the MDP transition probabilities θ are deterministic, these constraints are equivalent to the original constraint <ref type="bibr" target="#b0">(1)</ref>. We prove this by considering the true value function V * obtained by value iteration, initialized with the pseudo-value function V . Let V be the result obtained by performing one step of value iteration. Note that V (s) ≤ V (s) for all s ∈ S: since V (s) ≥ R(s, a) + γ s θ sas V (s ), we must have</p><formula xml:id="formula_3">V (s) ≥ max a [R(s, a) + γ s θ sas V (s )] = V (s).</formula><p>Since the MDP is deterministic and the example set D consists of traces from the optimal policy, we have a unique next state for each stateaction pair. Let (s i,t , a i,t ) ∈ D be the t th state-action pair from the i th expert trace. Since the constraints ensure that V (s i,t ) = max a [R(s i,t , a) + γV (s i,t+1 )], we have V (s i,t ) = V (s i,t ) for all i, t, and since V (s) for s / ∈ D can only decrease, we know that the optimal actions in all s i,t must remain the same. Therefore, for each example state s i,t , a i,t remains the optimal action under the true value function V * , and the convex relaxation is equivalent to the original constraint (1).</p><p>In the case that θ is not deterministic, not all successors of an example state s i,t are always observed, and their values under the pseudo-value function may not be sufficiently constrained. However, empirical tests presented in Figure <ref type="figure" target="#fig_1">2</ref>(b) suggest that the constraint (1) is rarely violated under the convex relaxation, even in highly non-deterministic MDPs.</p><p>In practice, we prefer a reward function under which the examples are not just part of an optimal policy, but are part of the unique optimal policy <ref type="bibr" target="#b6">[7]</ref>. To prevent rewards under which example actions "tie" for the optimal choice, we require that a i,t be better than all other actions in state s i,t by some margin ε, which we accomplish by adding ε to all inequality constraints for state s i,t . The precise value of ε is not important, since changing it only scales the reward function by a constant.</p><p>All of the constraints in the final optimization are sparse, but the matrix T Φ→R T R→Φ in the original objective can be arbitrarily dense (if, for instance, there is only one feature which contains all states). Since both T Φ→R and T R→Φ are sparse, and in fact only contain |S||A| non-zero entries, we can make the optimization fully sparse by introducing a new set of variables R Φ defined as</p><formula xml:id="formula_4">R Φ = T R→Φ R, yielding the sparse objective R -T Φ→R R Φ 2 .</formula><p>Recall that the fitting step must determine not only which features must be refined further, but also which features can be merged. We therefore add a second term to the objective to discourage nearby features from taking on different values when it is unnecessary. To that end, we construct a sparse matrix N , where each row k of N corresponds to a pair of features φ k1 and φ k2 (for a total of K rows). We define</p><formula xml:id="formula_5">N as N k,φ k 1 = -N k,φ k 2 = ∆(φ k1 , φ k2 ), so that [N R Φ ] k = (R Φφ k 1 -R Φφ k 2 )∆(φ k1 , φ k2 ).</formula><p>The loss factor ∆(φ k1 , φ k2 ) indicates how much we believe a priori that the features φ k1 and φ k2 should be merged, and is discussed further in Section 4.</p><p>Since the purpose of the added term is to allow superfluous features to be merged because they take on similar values, we prefer for a feature to be very similar to one of its neighbors, rather than to have minimal distance to all of them. We therefore use a linear rather than quadratic penalty. Since we would like to make nearby features similar so long as it does not adversely impact the primary objective, we give this adjacency penalty a low weight. In our implementation, this weight was set to w N = 10 -5 . Normalizing the two objectives by the number of entries, we get the following sparse quadratic program:</p><formula xml:id="formula_6">min R,RΦ,V 1 |S||A| R -T Φ→R R Φ 2 2 + w N K N R Φ 1 s.t. R Φ = T R→Φ R V (s) = R(s, a) + γ s θ sas V (s ) ∀ (s, a) ∈ D V (s) ≥ R(s, a) + γ s θ sas V (s ) + ε ∀ s ∈ D, (s, a) / ∈ D V (s) ≥ R(s, a) + γ s θ sas V (s ) ∀ s / ∈ D</formula><p>This program can be solved efficiently with any quadratic programming solver. It contains on the order of |S||A| variables and constraints, and the constraint matrix is sparse with O(|S||A|µ a ) nonzero entries, where µ a is the average sparsity of θ sa -that is, the average number of states s that have a non-zero probability of being reached from s using action a. In our implementation, we use the cvx Matlab package <ref type="bibr" target="#b5">[6]</ref> to solve this optimization efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Fitting Step</head><p>Once the reward function R (i) for the current feature set Φ (i-1) is computed, we formulate a new feature hypothesis Φ (i) that is better able to represent this reward function. The objective of this step is to construct a set of features that gives greater resolution in regions where the old features are too coarse, and lower resolution in regions where the old features are unnecessarily fine. We obtain Φ (i) by building a regression tree for R (i) over the state-space S, using the standard intra-cluster variance splitting criterion <ref type="bibr" target="#b2">[3]</ref>. The tree is rooted at the node t 0 , and each node of the tree is defined as t j = {δ j , φ j , t j-, t j+ }. t j-and t j+ are the left and right subtrees, φ j ⊆ S is the set of states belonging to node j (initialized as φ 0 = S), and δ j is the component feature that acts as the splitting test at node j. States s ∈ φ j for which δ j (s) = 0 are assigned to the left subtree, and states for which δ j (s) = 1 are assigned to the right subtree. In our implementation, all component features are binary, though the generalization to multivariate components and non-binary trees is straightforward. The new set of features consists of indicators for each of the leaf clusters φ (where t is a leaf node), and can be equivalently expressed as a conjunction of components: letting j 0 , ..., j n , be the sequence of nodes on the path from the root to t , and defining r 0 , ..., r n so that r k is 1 if t j k+1 = t j k + and 0 otherwise, s ∈ φ if and only if δ j k (s) = r k for all k ∈ {0, ..., n}.</p><p>As discussed in Section 2, we prefer the smallest tree that produces a rich enough feature set to represent a reward function consistent with the examples D. We therefore terminate the splitting procedure at node t when we detect that further splitting of the node is unnecessary to maintain consistency with the example set. This is done by constructing a new reward function</p><formula xml:id="formula_7">R(i) for which R(i) (s, a) = |φ | -1 s∈φ R (i) (s, a) if s ∈ φ , and R(i) (s, a) = R (i) (s, a)</formula><p>otherwise. The optimal policy under R(i) is determined with value iteration and, if the policy is consistent with the examples D, t becomes a leaf and R (i) is updated to be equal to R(i) . Although value iteration ordinarily can take many iterations, since the changes we are considering often make small, local changes to the optimal policy compared to the current reward function R (i) , we can often converge in only a few iterations by starting with the value function V (i) for the current reward R (i) . We therefore store this value function and update it along with R (i) .</p><p>In addition to this stopping criterion, we can also employ the loss factor ∆(φ k1 , φ k2 ) to encourage the next optimization step to assign similar values to nearby features, allowing them to be merged in subsequent iterations. Recall that ∆(φ k1 , φ k2 ) is a linear penalty on the difference between the average rewards of states in φ k1 and φ k2 , and can be used to drive the rewards in these features closer together so that they can be merged in a subsequent iteration. Features found deeper in the tree exhibit greater complexity, since they are formed by a conjunction of a larger number of components. These complex features are more likely to be the result of overfitting, and can be merged to form smaller trees. To encourage such mergers, we set ∆(φ k1 , φ k2 ) to be proportional to the depth of the deepest common ancestor of φ k1 and φ k2 . The loss factor is therefore set to</p><formula xml:id="formula_8">∆(φ k1 , φ k2 ) = D a (k 1 , k 2 )/D t ,</formula><p>where D a gives the depth of the deepest common ancestor of two nodes, and D t is the total depth of the tree.</p><p>Finally, we found that limiting the depth of the tree and iteratively increasing that limit reduced overfitting and produced features that more accurately described the true reward function, since the optimization and fitting steps could communicate more frequently before committing to a set of complex features. We therefore begin with a depth limit of one, and increase the limit by one on each successive iteration. We experimented with a variety of other depth limiting schemes and found that this simple iterative deepening procedure produced the best results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Gridworld</head><p>In the first experiment, we compare FIRL with the MMP algorithm <ref type="bibr" target="#b8">[9]</ref>, the LPAL algorithm <ref type="bibr" target="#b9">[10]</ref>, and the algorithm of Abbeel &amp; Ng <ref type="bibr" target="#b0">[1]</ref> on a gridworld modeled after the one used by Abbeel &amp; Ng.</p><p>The purpose of this experiment is to determine how well FIRL performs on a standard IRL example, without knowledge of the relevant features. A gridworld consists of an N×N grid of states, with five actions possible in each state, corresponding to movement in each of the compass directions and standing in place. In the deterministic gridworld, each action deterministically moves the agent into the corresponding state. In the non-deterministic world, each action has a 30% chance of causing a transition to another random neighboring state. The world is partitioned into 64 equal-sized regions, and all the cells in a single region are assigned the same randomly selected reward. The expert's policy is the optimal policy under this reward. The example set D is generated by randomly sampling states and following the expert's policy for 100 steps.</p><p>Since the prior algorithms do not perform feature construction, they were tested either with indicators for each of the 64 regions (referred to as "perfect" features), or with indicators for each state (the "primitive" features). FIRL was instead provided with 2N component features corresponding to splits on the x and y axes, so that δ x,i (s x,y ) = 1 if x ≥ i, and δ y,i (s x,y ) = 1 if y ≥ i. By composing such splits, it is possible to represent any rectangular partitioning of the state space.</p><p>We first compare the running times of the algorithms (using perfect features for prior methods) on gridworlds of varying sizes, shown in Table <ref type="table" target="#tab_0">1</ref>. Performance was tested on an Intel Core i7 2.66 GHz computer. Each trial was repeated 10 times on random gridworlds, with average running times presented. For FIRL, running time is given for 15 iterations, and is also broken down into the average length of each optimization and fitting step. Although FIRL is often slower than methods that do not perform feature construction, the results suggest that it scales gracefully with the size of the problem. The optimization time scales almost linearly, while the tree construction scales worse than linearly but better than quadratically. The latter can likely be improved for large problems by using heuristics to minimize evaluations of the expensive stopping test.</p><p>In the second experiment, shown in Figure <ref type="figure" target="#fig_0">1</ref>, we evaluate accuracy on 64 × 64 gridworlds with varying numbers of examples, again repeating each trial 10 times. We measured the percentage of states in which each algorithm failed to predict the expert's optimal action ("percent misprediction"), as well as the Euclidean distance between the expectations of the perfect features under the learned policy and the expert's policy (normalized by (1 -γ) as suggested by Abbeel &amp; Ng <ref type="bibr" target="#b0">[1]</ref>). For the mixed policies produced by Abbeel &amp; Ng, we computed the metrics for each policy and mixed them using the policy weights λ <ref type="bibr" target="#b0">[1]</ref>. For the non-deterministic policies of LPAL, percent misprediction is  the mean probability of taking an incorrect action in each state. Results for prior methods are shown with both the perfect and primitive features. FIRL again ran for 15 iterations, and generally achieved comparable accuracy to prior algorithms, even when they were provided with perfect features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Transfer Between Environments</head><p>While the gridworld experiments demonstrate that FIRL performs comparably to existing methods on this standard example, even without knowing the correct features, they do not evaluate the two key advantages of FIRL: its ability to construct features from primitive components, and its ability to generalize learned rewards to different environments. To evaluate reward transfer and see how the method performs with more realistic component features, we populated a world with objects. This environment also consists of an N×N grid of states, with the same actions as the gridworld. Objects are randomly placed with 5% probability in each state, and each object has 1 of C "inner" and "outer" colors, selected uniformly at random. The algorithm was provided with components of the form "is the nearest X at most n units away," where X is a wall or an object with a specific inner or outer color, giving a total of (2C + 1)N component features. The expert received a reward of -2 for being within 3 units of an object with inner color 1, otherwise a reward of -1 for being within 2 units of a wall, otherwise a reward of 1 for being within 1 unit of an object with inner color 2, and 0 otherwise. All other colors acted as distractors, allowing us to evaluate the robustness of feature construction to irrelevant components. For each trial, the learned reward tree was used to test accuracy on 10 more random environments, by specifying a reward for each state according to the regression tree. We will refer to these experiments as "transfer." Each trial was repeated 10 times.  In Figure <ref type="figure" target="#fig_1">2</ref>(a), we evaluate how FIRL performs with varying numbers of iterations on both the training and transfer environments, as well as on the gridworld from the previous section. The results indicate that FIRL converged to a stable hypothesis more quickly than in the gridworld, since the square regions in the gridworld required many more partitions than the objectrelative features. However, the required number of iterations was low on both environments.</p><p>In Figure <ref type="figure" target="#fig_1">2</ref>(b), we evaluate how often the nonconvex constraints discussed in Section 3 are violated under our convex approximation. We measure the percent of examples that are violated with varying amounts of non-determinism, by varying the probability β with which an action moves the agent to the desired state. β = 1 is deterministic, and β = 0.2 gives a uniform distribution over neighboring states. The results suggest that the constraint is rarely violated under the convex relaxation, even in highly non-deterministic MDPs, and the number of violations decreases sharply as the MDP becomes more deterministic.</p><p>We compared FIRL's accuracy on the transfer task with Abbeel &amp; Ng and MMP. LPAL was not used in the comparison because it does not return a reward function, and therefore cannot transfer its policy to new environments. Since prior methods do not perform feature construction, they were provided with all of the component features. The experiments used 64 × 64 environments and 64 examples. The number of colors C was varied from 2 to 20 to test how well the algorithms handle irrelevant "distractors." FIRL ran for 10 iterations on each trial. The results in Figure <ref type="figure" target="#fig_2">3</ref> indicate that accuracy on the training environment remained largely stable, while transfer accuracy gradually decreased with more colors due to the ambiguity caused by large numbers of distractors. Prior algorithms were more affected by distractors on the training environments, and their inability to construct features prevented them from capturing a portable "explanation" of the expert's reward. They therefore could not transfer the learned policy to other environments with comparable accuracy. In contrast to the gridworld experiments, the expert's reward function in these environments was encoded in terms of logical relationships between the component features, which standard IRL algorithms cannot capture. In the next section, we examine another environment that also exemplifies the need for feature construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Highway Driving Behaviors</head><p>To demonstrate FIRL's ability to learn meaningful behaviors, we implemented a driving simulator inspired by the environments in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b9">[10]</ref>. The task is to navigate a car on a three-lane highway. All other vehicles are moving at speed 1. The agent can drive at speeds 1 through 4, and can move one lane left or one lane right. The other vehicles can be cars or motorcycles, and can be either civilian or police, for a total of 4 possibilities. The component features take the form "is a vehicle of type X at most n car-lengths in front/behind me," where X can be either all vehicles, cars, motorcycles, police, or civilian, and n is in the range from 0 to 5 car-lengths. There are equivalent features for checking for cars in front or behind in the lanes to the left and to the right of the agent's, as well as a feature for each of the four speeds and each lane the agent can occupy.</p><p>The rich feature set of this driving simulator enables interesting behaviors to be demonstrated. For this experiment, we implemented expert policies for two behaviors: a "lawful" driver and an "outlaw" driver. The lawful driver prefers to drive fast, but does not exceed speed 2 in the right lane, or speed 3 in the middle lane. The outlaw driver also prefers to drive fast, but slows down to speed 2 or below when within 2 car-lengths of a police vehicle (to avoid arrest).</p><p>In Table <ref type="table" target="#tab_4">2</ref>, we compare the policies learned from traces of the two experts by FIRL, MMP, and Abbeel &amp; Ng's algorithm. As before, prior methods were provided with all of the component features. All algorithms were trained on 30 traces on a stretch of highway 100 car-lengths long, and tested on 10 novel highways. As can be seen in the supplemental videos, the policy learned by FIRL closely matched that of the expert, maintaining a high speed whenever possible but not driving fast in the wrong lane or near police vehicles. The policies learned by Abbeel &amp; Ng's algorithm and MMP drove at the minimum speed when trained on either the lawful or outlaw expert traces. Because prior methods only represented the reward as a linear combination of the provided features, they were unable to determine the logical connection between speed and the other features. The policies learned by these methods found the nearest "optimal" position with respect to their learned feature weights, accepting the cost of violating the speed expectation in exchange for best matching the expectation of all other (largely irrelevant) features. FIRL, on the other hand, correctly established  The policies learned by FIRL closely match the expert's average speed, while those of other methods do not. The difference between the policies is particularly apparent in the supplemental videos, which can be found at http://graphics.stanford.edu/projects/firl/index.htm the logical connection between speed and police vehicles or lanes, and drove fast when appropriate, as indicated by the average speed in Table <ref type="table" target="#tab_4">2</ref>. As a baseline, the table also shows the performance of a random policy generated by picking weights for the component features uniformly at random.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion and Future Work</head><p>This paper presents an IRL algorithm that constructs reward features, represented as a regression tree, out of a large collection of component features. By combining relevant components into logical conjunctions, the FIRL algorithm is able to discover logical precedence relationships that would not otherwise be apparent. The learned regression tree concisely captures the structure of the reward function and acts as a portable "explanation" of the observed behavior in terms of the provided components, allowing the learned reward function to be transplanted onto different environments.</p><p>Feature construction for IRL may be a valuable tool for analyzing the motivations of an agent (such as a human or an animal) from observed behavior. Research indicates that animals learn optimal policies for a pattern of rewards <ref type="bibr" target="#b3">[4]</ref>, suggesting that it may be possible to learn such behavior with IRL. While it can be difficult to manually construct a complete list of relevant reward features for such an agent, it is comparatively easier to list all aspects of the environment that a human or animal is aware of. With FIRL, such a list can be used to form hypotheses about reward features, possibly leading to increased understanding of the agent's motivations. In fact, models that perform a variant of IRL have been shown to correspond well to goal inference in humans <ref type="bibr" target="#b1">[2]</ref>.</p><p>While FIRL achieves good performance on discrete MDPs, in its present form it is unable to handle continuous state spaces, since the optimization constraints require an enumeration of all states in S.</p><p>Approximate linear programming has been used to solve MDPs with continuous state spaces <ref type="bibr" target="#b4">[5]</ref>, and a similar approach could be used to construct a tractable set of constraints for the optimization step, making it possible to perform feature construction on continuous or extremely large state spaces.</p><p>Although we found that FIRL converged to a stable hypothesis quickly, it is difficult to provide an accurate convergence test. Theoretical analysis of convergence is complicated by the fact that regression trees provide few guarantees. The conventional training error metric is not a good measure of convergence, because the optimization constraints keep training error consistently low. Instead, we can use cross-validation, or heuristics such as leaf count and tree depth, to estimate convergence. In practice, we found this unnecessary, as FIRL consistently converged in very few iterations. Defining a practical convergence test and analyzing convergence is an interesting avenue for future work.</p><p>FIRL may also benefit from future work on the fitting step. A more intelligent hypothesis proposal scheme, perhaps with a Bayesian approach, could more readily incorporate priors on potential features to penalize excessively deep trees or prevent improbable conjunctions of components. Furthermore, while regression trees provide a principled method for constructing logical conjunctions of component features, if the desired features are not readily expressible as conjunctions of simple components, other regression methods may be used in the fitting step. For example, the algorithm could be modified to perform feature adaptation by using the fitting step to adapt a set of continuously-parameterized features to best fit the reward function.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure1: Accuracy comparison between FIRL, LPAL, MMP, and Abbeel &amp; Ng, the latter provided with either perfect or primitive features. Shaded regions show standard error. Although FIRL was not provided the perfect features, it achieved similar accuracy to prior methods that were.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 (</head><label>2</label><figDesc>Figure 2(b): Constraint violation was low in nondeterministic MDPs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Comparison of FIRL and Abbeel &amp; Ng on training environments and randomly generated transfer environments, with increasing numbers of component features. FIRL maintained higher transfer accuracy in the presence of distractors by constructing features out of relevant components.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Performance comparison of FIRL, LPAL, MMP, and Abbeel &amp; Ng on gridworlds of varying size. FIRL ran for 15 iterations. Individual iterations were comparable in length to prior methods.</figDesc><table><row><cell>Gridworld</cell><cell cols="4">Total LPAL MMP Abbeel &amp; Ng</cell><cell cols="2">FIRL Optimization</cell><cell>Fitting</cell></row><row><cell>size</cell><cell>states</cell><cell>(sec)</cell><cell>(sec)</cell><cell cols="2">(sec) (sec total)</cell><cell cols="2">(sec each) (sec each)</cell></row><row><cell>16×16</cell><cell>256</cell><cell>0.29</cell><cell>0.24</cell><cell>27.05</cell><cell>8.34</cell><cell>0.39</cell><cell>0.11</cell></row><row><cell>32×32</cell><cell>1024</cell><cell>0.66</cell><cell>0.42</cell><cell>74.66</cell><cell>29.00</cell><cell>1.01</cell><cell>0.73</cell></row><row><cell>64×64</cell><cell>4096</cell><cell>2.22</cell><cell>1.26</cell><cell>272.10</cell><cell>165.29</cell><cell>4.26</cell><cell>5.80</cell></row><row><cell cols="3">128×128 16384 19.33</cell><cell>7.58</cell><cell>876.18</cell><cell>1208.47</cell><cell>24.44</cell><cell>48.44</cell></row><row><cell cols="4">256×256 65536 52.60 81.26</cell><cell>1339.87</cell><cell>10389.59</cell><cell>170.14</cell><cell>428.49</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Comparison of FIRL, MMP and Abbeel &amp; Ng on the highway environment (left).</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We thank Andrew Y. Ng, Emanuel Todorov, and Sameer Agarwal for helpful feedback and discussion. This work was supported in part by NSF grant CCF-0641402.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Apprenticeship learning via inverse reinforcement learning</title>
		<author>
			<persName><forename type="first">P</forename><surname>Abbeel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML &apos;04: Proceedings of the 21st International Conference on Machine Learning</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Goal inference as inverse planning</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Saxe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual Conference of the Cognitive Science Society</title>
		<meeting>the 29th Annual Conference of the Cognitive Science Society</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Classification and Regression Trees</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Olshen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Wadsworth and Brooks</publisher>
			<pubPlace>Monterey, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Reward, motivation, and reinforcement learning</title>
		<author>
			<persName><forename type="first">P</forename><surname>Dayan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Balleine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neuron</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="285" to="298" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The linear programming approach to approximate dynamic programming</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>De Farias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Van Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="850" to="865" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">CVX: Matlab Software for Disciplined Convex Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Boyd</surname></persName>
		</author>
		<ptr target="http://stanford.edu/˜boyd/cvx" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>web page and software</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Algorithms for inverse reinforcement learning</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Russell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML &apos;00: Proceedings of the 17th International Conference on Machine Learning</title>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="663" to="670" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bayesian inverse reinforcement learning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ramachandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Amir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI&apos;07: Proceedings of the 20th International Joint Conference on Artifical Intelligence</title>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="2586" to="2591" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Maximum margin planning</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Ratliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bagnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Zinkevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML &apos;06: Proceedings of the 23rd International Conference on Machine Learning</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="729" to="736" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Apprenticeship learning using linear programming</title>
		<author>
			<persName><forename type="first">U</forename><surname>Syed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bowling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML &apos;08: Proceedings of the 25th International Conference on Machine Learning</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1032" to="1039" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
