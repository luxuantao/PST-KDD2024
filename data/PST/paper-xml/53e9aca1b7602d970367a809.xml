<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">T-Check: Bug Finding for Sensor Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Peng</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">University of Utah</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">John</forename><surname>Regehr</surname></persName>
							<email>regehr@cs.utah.edu</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">University of Utah</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">T-Check: Bug Finding for Sensor Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">82928469509E27B36A94276ECCF6F6C8</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:12+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.3 [Special-purpose and Application-based Systems]: Real-time and Embedded Systems; D.2.4 [Software Engineering]: Software/Program Verification-Validation Performance</term>
					<term>Verification sensor networks</term>
					<term>T-Check</term>
					<term>model checking</term>
					<term>random walk</term>
					<term>TinyOS</term>
					<term>safety</term>
					<term>liveness</term>
					<term>event-driven</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Sensor nodes are resource poor and failure-prone. Sensor networks are composed of many such nodes that are often hard to physically reach and that are connected by unreliable wireless links. Together, these factors make sensor network debugging into a challenging activity, and in fact it is not uncommon for a deployed sensornet to encounter sporadic faults that are effectively impossible to locate, reproduce, and fix.</p><p>We developed T-Check, a tool that uses random walks and explicit state model checking to find safety and liveness errors in sensor network applications running on TinyOS. By building upon TOSSIM-an event-driven simulator that abstracts away interrupt-driven concurrency and other lowlevel hardware interaction-T-Check loses the ability to detect certain low-level errors, but gains enough scalability to detect distributed errors such as a collection tree protocol's failure to properly repair when a node dies. We have used T-Check to find previously unknown bugs in TinyOS.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Creating and deploying a highly reliable sensor network is difficult, and it is not uncommon for a real network to have a data yield well below 100%. For example, the median node in Werner-Allen et al.'s volcano monitoring network <ref type="bibr" target="#b29">[29]</ref> successfully downloaded 68.5% of detected events to a base-station. Of course, there are many kinds of root cause for a network's failure to deliver data: hardware failure, battery problems, software bugs, network link quality and variability, etc.</p><p>We developed T-Check to support early detection of software bugs in sensor network applications. Early detection is important because it can be very painful to find and fix a bug that sneaks into a deployment. We believe that bugs survive laboratory sensornet testing for the simple reason that the deployment environment is inevitably different from a controlled testbed or simulator. The apparent inadequacy of testing motivated us to choose an approach based on state space exploration: exhaustive enumeration of the states that a sensor network can find itself in. This approach can-in principle-find all possible violations of some kinds of program properties, regardless of the characteristics of the environment the sensornet is eventually deployed in.</p><p>T-Check employs model checking and random exploration of a sensornet's state space to find violations of safety and liveness properties. Safety properties, of the form "the sensornet never does X," can be specified by developers, and we also inherit a large number of compiler-generated safety properties from Safe TinyOS <ref type="bibr" target="#b7">[7]</ref>. For example, a typical Safe TinyOS assertion would be "the array index is in the range 0..9." Liveness properties, of the form "the sensornet eventually does Y," must be provided by developers. Typical examples are "the buffer eventually becomes unlocked" or "the node eventually finds a place in the routing tree."</p><p>Due to complications such as interrupt-driven concurrency and free-running timer registers, the state space of even a single sensor node may be extremely large. For example, the [mc]square model checker <ref type="bibr" target="#b28">[28]</ref> performs explicit-state checking of binaries for AVR microcontrollers. Although this approach has been used to check small industrial applications, it is unclear how to scale it up to networks of sophisticated sensornet programs. Therefore, we decided it was necessary to simplify the problem by abstracting away some low-level details. We settled on TOSSIM <ref type="bibr" target="#b22">[22]</ref> as a suitable basis for T-Check.</p><p>TOSSIM is an event-driven simulator for networks of nodes running TinyOS; it gains simplicity and speed by not supporting concurrent execution and by emulating hardware devices at the level of a TinyOS interface, rather than at the level of hardware registers. This design means that TOSSIM cannot find, for example, timing errors, call stack overflows, and race conditions caused by interrupt preemptions. On the other hand, a coarse-grained, event-based execution model lends itself well to efficient state space exploration. Even so, in some cases we found TOSSIM to be too high-level to support effective bug-finding, and so we extended the ADC, serial, and SPI subsystems to model more low-level behavior.</p><p>The research questions that motivate our work include: What safety and liveness properties should be checked in sensornet executions? How can we efficiently explore the very large state space of a sensornet? Is it a good tradeoff to abstract away low-level details in order to find higherlevel bugs? What sources of non-determinism in sensornet execution should be used as the basis for state space exploration? What are the tradeoffs between random testing and model checking? Can we effectively find bugs in the heavily used and generally high-quality TinyOS 2 code base?</p><p>Using T-Check, we found 12 previously unknown bugs in TinyOS 2. Most of these have been confirmed by developers, fixed in the TinyOS source code repository, and will be part of the upcoming 2.1.1 release.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>This section provides some background on the systems and techniques on which T-Check is built.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">TinyOS</head><p>TinyOS <ref type="bibr" target="#b15">[15]</ref> is a wireless sensornet operating system. Its mechanisms and abstractions are designed for ultra-low-power microcontrollers with limited RAM and no hardware support for memory isolation. TinyOS typically runs at 1-8 MHz on 16-bit microcontrollers that have 4-10 kB of SRAM and 40-128 kB of flash memory <ref type="bibr" target="#b25">[25]</ref>.</p><p>The operating system uses components as the unit of software composition <ref type="bibr" target="#b15">[15]</ref>. Like objects, components couple code and data. Unlike objects, however, they can only be instantiated at compile time. TinyOS components, written in a dialect of C called nesC <ref type="bibr" target="#b8">[8]</ref>, have interfaces which define downcalls ("commands") and upcalls ("events"). Upcalls and downcalls are bound statically: the absence of function pointers simplifies call graph analysis. Each TinyOS component is either a module, containing code, or a configuration: a container wiring together other modules and configurations.</p><p>The TinyOS core has a highly restricted, purely eventdriven execution model. Using a single stack, it supports only interrupt handlers and run-to-completion deferred procedure calls called tasks. Tasks are similar to bottom-half handlers in UNIX implementations: they run at lower priority than interrupts and do not preempt each other.</p><p>Since TinyOS uses a single stack, computations cannot block. Instead, a split-phase idiom is used to permit concurrency during potentially long-running operations. For example, to send a packet, an application would invoke a Send command, which initiates the send operation and then returns. Later, the network subsystem delivers a sendDone event to the application, notifying it that the operation has finished.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">TOSSIM</head><p>TOSSIM <ref type="bibr" target="#b22">[22]</ref> is a simulator for TinyOS wireless sensor networks; it achieves high performance and good scalability in three ways. First, it compiles TinyOS source code into native host platform code, as opposed to simulating a sensor node at the instruction level. Second, it employs high-level device models that are very efficient, for example dealing with an entire radio packet at a time rather than simulating byte-wise or bit-wise transmission over the medium. Third, TOSSIM has a non-preemptive execution model: it does not simulate interrupts in a direct fashion.</p><p>As far as T-Check is concerned, the most important property of TOSSIM is that its simulation events execute atomically. In other words-unlike real sensornet nodes-code running on TOSSIM is never preempted by interrupts. This change to the TinyOS execution model greatly reduces the size of the state space that T-Check needs to explore. The cost of this choice is that certain kinds of errors, including timing errors, concurrency errors, and bugs in low-level device drivers cannot be detected by TOSSIM, and therefore not by T-Check either.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Safe TinyOS</head><p>Since nesC is an unsafe language and TinyOS nodes lack memory protection hardware, pointer and array bugs lead to corrupted RAM and difficult debugging. Some microcontrollers place their registers in the bottom of the memory map, exacerbating the problem. On these architectures, null pointer dereferences corrupt the register file.</p><p>Safe TinyOS <ref type="bibr" target="#b7">[7]</ref> uses the Deputy compiler <ref type="bibr" target="#b6">[6]</ref> to enforce type and memory safety using static and dynamic checks. Deputy is based on a dependent type system that exploits array bounds information already stored in memory. Therefore, unlike other memory-safe versions of C, it has no RAM overhead on a Harvard-architecture microcontroller.</p><p>From the point of view of T-Check, the main benefit that Safe TinyOS provides is the large number of assertions that it inserts into application code. These serve as inline safety property checks. T-Check can look for violations of these properties without additional help from the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Model Checking</head><p>A model checker <ref type="bibr" target="#b5">[5]</ref> explores the state space of a computer system. For any given state, it is possible to define a predicate over that state: a formula that evaluates to true or false, indicating that the system in that state either holds or fails to hold some interesting property. An execution is a path through the state space that corresponds to an execution of the actual system.</p><p>A safety property is true if something bad never happens. If any state in an execution violates the safety property, the entire execution violates that property. A liveness property holds if something good will eventually happen. An execution satisfies a liveness property if the execution will encounter a live state in finite time. Conversely, an execution violates a liveness property if it contains an infinite sequence of states that does not hold the property.</p><p>T-Check builds on Killian et al.'s work <ref type="bibr" target="#b18">[18]</ref>, which is based on the idea that liveness violations can be detected heuristically by looking for sufficiently long violations of the property. Based on this intuition, liveness violations are separated into two categories: transient liveness violations that may eventually reach a live state, and dead liveness viola-Figure <ref type="figure">1</ref>: T-Check uses both random walks and depth-bounded model checking to look for violations of safety and liveness properties in sensor network applications tions that will never reach a live state. The critical transition is the last state transition that is transiently dead. Finding the critical transition is useful because this point of no return usually has something to do with the root cause of the liveness violation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">T-Check</head><p>T-Check is a state space exploration tool that builds on TOSSIM. TOSSIM is a scriptable simulator, typically driven by a Python program. T-Check inherits this structure: a script is used to specify the number of nodes, their topology, etc.</p><p>T-Check supports two major modes of operation. First, it can act as a random tester. Second, it can act as a model checker whose overall strategy builds on work by Killian et al. <ref type="bibr" target="#b18">[18]</ref>. In model-checking mode, T-Check runs in distinct phases:</p><p>1. Random execution is used to get the sensor network past its initialization phase and into a steady state.</p><p>2. Depth-bounded explicit state model checking is used to exhaustively explore the state space of the system up to some depth.</p><p>3. Random walks through the state space are used to find additional safety violations and to verify that potential liveness violations are real.</p><p>4. Additional random walks are used to find the critical transitions leading to liveness violations.</p><p>Figure <ref type="figure">1</ref> illustrates these steps. The following subsections describe T-Check in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Safety and Liveness Properties</head><p>T-Check exploits the type safety checks inserted by Safe TinyOS and also any user-written assertions already present in the source code. Liveness properties and additional safety properties may be provided by developers; T-Check ensures that each property holds at every state transition.</p><p>Table <ref type="table" target="#tab_0">1</ref> shows the properties that we checked in TinyOS applications. We developed these properties by reading code, papers, and other documentation. It is likely that the authors or maintainers of these subsystems could do a better job than we did at characterizing the most important properties. To be integrated into T-Check, a property must be expressed as executable code; some examples are given in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Exposing Non-determinism</head><p>Although TOSSIM incorporates some randomness, for example in its network model, it is generally a deterministic simulator. The firing times for events are determined by the expected real-world latencies of actions being simulated, and TOSSIM has a single mechanism for choosing the next event: it fires the event with the smallest time.</p><p>In contrast to TOSSIM, to successfully explore the state space of a sensornet-regardless of whether model checking or random walk is used-T-Check should exploit all available sources of non-determinism. If a non-deterministic choice is missed, we will fail to explore some part of the state space and may miss bugs. On the other hand, if nondeterminism is added where it was not present in the original system, we will explore false paths and report errors that do not actually exist.</p><p>The first kind of non-determinism that T-Check uses is communication non-determinism. For example, a sent packet is non-deterministically delivered or dropped; a received packet is non-deterministically successful or corrupted. At the implementation level, each call to the radio model has to be replaced with a non-deterministic choice operator. In model checking mode, the non-deterministic choice operator explores both alternatives. In random walk mode, the nondeterministic choice operator returns a random alternative.</p><p>The second kind of non-determinism supported by T-Check is coarse-grain node-level non-determinism, which includes node arrival, death, and reboot. The third kind of nondeterminism is event ordering non-determinism, which exploits the lack of ordering guarantees within a single TinyOS node. For example, if an application initiates two splitphase operations, such as sending a packet and reading a block from flash memory, the completion events can arrive in either order. However, events cannot be arbitrarily reordered. For example, within a node, if an application posts two tasks, the TinyOS scheduler guarantees that they run in the order in which they were posted.</p><p>To model the TinyOS execution semantics, T-Check maintains multiple event queues for each node that it simulates; Figure <ref type="figure" target="#fig_0">2</ref> illustrates this. Events from different queues may be arbitrarily reordered, but events in a single queue must execute in order. The event at the head of a queue is enabled, and the enable set for a node is just the set of all enabled events.</p><p>To determine the proper mapping of events to queues, we observed that the basic source of non-determinism in microcontroller execution is interrupts. Thus, T-Check maintains one queue for each interrupt-generating device, in addition to a queue for the TinyOS pending tasks. Recall that T-Check, like TOSSIM, does not support preemptive interrupts. Rather, interrupts are modeled as atomic events whose firing may be interleaved with the firing of tasks and  TOSSIM models only the timer interrupt. While creating T-Check, we extended TOSSIM to model more interrupt sources: ADC (analog to digital converter), UART (serial port) transmit and receive, and SPI (serial peripheral interface). These extensions provide two benefits in terms of bug-finding. First, they permit additional low-level device driver components to be tested. Second, they permit nondeterministic executions driven by these interrupt sources to be explored by T-Check.</p><p>Since T-Check does not support preemptive execution of interrupts, and since (on a real mote) interrupts must always be enabled in between executing adjacent tasks, we do not need to model the processor's global interrupt enable flag. On the other hand, the individual enable bits associated with interrupt sources must be modeled in order to avoid exploring infeasible parts of the state space. For example, on AVR platforms the ADC interrupt can only fire when the ADIE hardware bit is set. T-Check models this behavior and considers events in the ADC event queue to be enabled only when the bit is set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Depth-bounded Explicit State Model Checking</head><p>T-Check is an execution driven model checker: it actually runs the code, as opposed to symbolically evaluating it. T-Check uses stateless depth-bounded depth-first search with partial order reduction. Illustrated by Figure <ref type="figure">1</ref>, starting from an initial state or steady state, all reachable states are explored using DFS. Stateless execution means that backtracking is implemented by returning to the initial or steady state and re-executing down some new path, as opposed to returning to a saved checkpoint other than the initial state. This approach is relatively simple to implement and conserves RAM, at the expense of wasting CPU time in redundant re-execution.</p><p>A naïve exploration of the state space of a distributed system is wasteful. For example, consider a network of two nodes that both have pending ADC interrupt handlers. The model checker has two choices: it can execute node 0's interrupt handler and then node 1's, or vice versa. However, since there is no dependency between the ADC interrupt handlers on two different nodes, the final system state is the same regardless of which handler runs first. Partial order reduction (POR) <ref type="bibr" target="#b10">[10]</ref> is a family of strategies for avoiding exploration of redundant states. T-Check implements a form of static POR, which requires advance knowledge of which state transitions are potentially dependent. The following rules are used:</p><p>• A pair of transitions on the same node is always dependent.</p><p>• A pair of transitions on different nodes is independent unless the events are a matched send/receive pair.</p><p>The goal of T-Check is to explore all non-redundant states of the distributed system that can be reached within a predetermined number of state transitions. It works as follows. Initially, the sleep set and transition stack are empty. The sleep set supports POR and the transition stack records the sequence of state transitions currently being explored. Also, the initial state for the run is saved so that the model checker can return to it later.</p><p>A model checking step starts by checking if any safety property is violated. If so, T-Check prints an error message and dumps the current transition stack, which serves as a counterexample for the property. Next, T-Check builds a ready set: the set difference of the union of all nodes' enable sets and the sleep set. If the ready set is empty, the system backtracks. Otherwise, T-Check removes an element t from this set, pushes t onto the transition stack, and executes the corresponding code. Next, all events dependent on t are removed from the sleep set. Finally, as long as the depth of the transition stack does not exceed the pre-determined depth bound, the model checking step code is recursively invoked.</p><p>To backtrack, either because the depth bound is reached or the ready set is empty, T-Check pops the last transition from the transition stack, inserts it into the sleep set, restores the system to its saved (initial or steady) state, and then executes the state transitions determined by the contents of the transition stack. Once all state transitions have been performed, the model checking step operation is invoked.</p><p>Resetting the sensornet to a saved state requires restoring all nodes' state variables, register values, and event queues. We modified the nesC compiler to generate code to help save and restore nodes' states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Randomly Exploring the State Space</head><p>The advantage of model checking is that it guarantees that any bugs within the depth bound can be found. However, the exponential size of the space imposes strong limits on the utility of this technique. In practice, random execution is a useful counterpart to model checking <ref type="bibr" target="#b12">[12]</ref>. As shown in Figure <ref type="figure">1</ref>, when the system reaches the depth bound, T-Check can also continue with a random walk phase to catch more safety errors and identify the potential liveness violations. Our random walk algorithm is to repeat these steps until a safety bug is found or until the user gets tired of waiting.</p><p>First, check if any safety properties are violated. If so, dump the current event trace and terminate. Otherwise, for each liveness property and each node, clear the violation count for any satisfied property and increment the violation count for any violated property. If the violation count for any liveness property exceeds a heuristic threshold (100,000 events has worked well for us), signal a liveness violation. Finally, choose a random event from a random node's enable set and execute it.</p><p>A tricky aspect of random testing is assigning appropriate probabilities to various event choice operators. If probabilities are chosen poorly, testing will waste time in uninteresting parts of the state space and miss interesting parts. By default, T-Check assigns uniform probabilities to all enabled events, since during each state, the enable event set for each node is similar, and thus the whole simulation execution topology is not irregular, resulting in relatively uniform trace sampling probability. Although this has worked well so far, in the future we plan to look for other probability assignments that find property violations more rapidly. T-Check also permits users to specify their own probability distributions if they so choose.</p><p>T-Check implements Killian et al.'s critical transition algorithm <ref type="bibr" target="#b18">[18]</ref>. This is a binary search where each transition in a liveness-violating trace is used as the starting point for a random walk that tests for eventual liveness. The critical transition occurs between the last state from which a live state can be reached, and the subsequent state, which is the first state that is definitely dead. Once an execution trace is considered as liveness-violating, T-Check will dump a trace starting from the first transition of random walk to critical </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Finding Short Error Traces</head><p>Error traces found while model checking tend to be short, and in fact if the model checker runs to completion, the shortest possible error trace for each violated property is guaranteed to be among the errors found. On the other hand, random execution tends to lead to long error traces, making it difficult for users to understand the sequence of events that lead to the problem.</p><p>To shorten an error trace found during random execution, T-Check uses an algorithm loosely inspired by delta debugging <ref type="bibr" target="#b30">[30]</ref>. At all times, the shortest-known trace to the error is saved. First, one of the state transitions in the error trace is chosen as a change point. All transitions before the change point come from the saved error trace, whereas transitions after it are chosen randomly. The change point is chosen heuristically: we use both an exponential search and pure random choice. If the new trace reaches the length of the saved trace without finding the error, the new trace is discarded and the current iteration ends. If the new trace finds the error more quickly, it becomes the new shortest trace and the current iteration ends. The algorithm terminates after a fixed number of iterations. Another heuristic we have found to be effective is to bias execution following the choice point to give increased probability to events on the node that is expected to show the property violation. Although it is simple, when iterated tens of thousands of times this technique is quite effective at reducing the length of error traces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">USING T-CHECK</head><p>Figure <ref type="figure" target="#fig_1">3</ref> shows the T-Check toolchain; it is used as follows. First, if a developer wishes to provide high-level properties, these take the form of nesC components providing the Sim-Property interface, which has two commands: safetyProp-ertyCheck and livenessPropertyCheck. T-Check provides a script that automatically wires property components into the application. The first property listed in Second, a developer configures T-Check using an extended version of TOSSIM's configuration mechanism, via a Python script. New configuration parameters include probabilities used in random execution, depth of model checking, whether to use partial order reduction, etc.</p><p>Finally, the application is compiled as usual, for example by make micaz safe sim, and run. If a T-Check-enabled application encounters a safety violation, it will dump an execution trace leading to the violation. If a liveness violation is found, T-Check searches for the critical transition and dumps an execution trace leading to this transition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RESULTS</head><p>This section demonstrates the effectiveness of T-Check as a bug-finding tool and evaluates its performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Bugs Found</head><p>We evaluated T-Check by using it to look for bugs in TinyOS applications from the publicly accessible tinyos-2.x and tinyos-2.x-contrib CVS repositories. Table <ref type="table" target="#tab_2">2</ref> summarizes our results: we found 12 previously unknown bugs, some of them in core services and in applications that have been used for several years.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Serial Stack Bug #1</head><p>Typically, a sensor network contains one or more base station nodes that communicate occasionally or continuously with a PC using a serial link. To support this, TinyOS has a  serial stack <ref type="bibr" target="#b11">[11]</ref>. The SerialDispatcherP component aggregates incoming bytes into packets and dispatches them to the appropriate higher-level component. It uses double buffering so that a node can receive data into one buffer while application code is processing the other buffer. Figure <ref type="figure" target="#fig_2">4</ref> shows the data structure representing this component's internal state, and also a utility function for checking whether the current buffer is locked. A buffer is locked if it is being used by the application or the serial stack, and unlocked when it is idle and ready to be used.</p><p>We used T-Check to test the following safety property: if a packet is arriving over the wire, and the current buffer is unlocked, it should be possible to successfully receive the packet and deliver it to the application level. T-Check found a violation of this property when buffer0 is the current buffer, and is receiving a serial packet from the PC. When packet reception ends, the current buffer is switched to buffer1 and the serial stack posts a task to notify the application level that buffer0 is ready to be used.</p><p>There is a period of time, then, when buffer0 is locked while the application is processing the serial data. If, during this time period, the serial stack starts receiving more data, it attempts to lock buffer1 so that it can be filled with data. However, isCurrentBufferLocked (shown in Figure <ref type="figure" target="#fig_2">4</ref>) contains a flaw that causes it to erroneously report the lock status of buffer0 instead of buffer1, causing the serial stack to fail to receive the new incoming packet, violating the safety property.</p><p>The fix is obvious: the if and else branches of isCurrent-BufferLocked need to be switched around. The TinyOS 2 maintainers committed this fix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Serial Stack Bug #2</head><p>This bug is also in SerialDispatcherP. Figure <ref type="figure">5</ref> shows the actions taken by the serial stack when the last byte of a packet is received. If the receive was successful, and if the serial stack is not currently waiting for the application to process the other buffer, a buffer swap is performed and a task is posted which will signal application-level code that a packet was received.</p><p>A high-level liveness property for serial stack is that eventually, both buffer0 and buffer1 become unlocked. The serial stack contains a bug that permits it to deadlock, violating this property. The bug is triggered by a failed packet  receive, for example due to a failing CRC. In this case, the buffer never gets unlocked, nor does the buffer swapping logic execute. Thus, all subsequent serial packets find the current buffer locked, and they are dropped. The fix is to release the lock on the current buffer when an erroneous packet is received. The TinyOS 2 maintainers have committed this fix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">DIP Bug #1</head><p>DIP <ref type="bibr" target="#b23">[23]</ref> is a data discovery and dissemination protocol. Figure <ref type="figure" target="#fig_3">6</ref> shows the code to send the DipSummary message, which is to summarize and hash the version information of the data items within a range. The getPayloadPtr command may return NULL, causing the subsequent line to dereference a NULL pointer with unpredictable results (or with a safety violation, if Safe TinyOS is being used). The fix-committed by the TinyOS 2 maintainers-is to add a check which fails the send command when getPayloadPtr returns NULL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.4">More DIP Bugs</head><p>Figure <ref type="figure" target="#fig_4">7</ref> shows the code of findRangeShadow, which calculates left and right indices in the array shadowEstimates for subsequent hash computation. This code contains two bugs that permits out-of-bounds array accesses to occur. The fix for these problems is slightly involved and we describe the  process of finding and fixing these bugs in three steps.</p><p>First, a developer changed</p><formula xml:id="formula_0">est2 = shadowEstimates[i + len] to est2 = shadowEstimates[i + len -1]</formula><p>If the maximum of RBound is exactly UQCOUNT_DIP, then there would be no out-of-bounds access. T-Check then found a trace where RBound can go over UQCOUNT_DIP, causing another safety violation.</p><p>Second, a developer changed the</p><formula xml:id="formula_1">LBound + len &gt; UQCOUNT_DIP test to highIndex + len &gt; UQCOUNT_DIP</formula><p>After this change, is it guaranteed that RBound is not beyond UQCOUNT_DIP. Although this fix eliminated one array bounds violation, T-Check subsequently found a case where the residual value in right was incorrect, causing an array access error in a different function.</p><p>Finally, to avoid the incorrect value of right, i + len &lt;= RBound was changed to i + len &lt; RBound, and shadowEstimates[i + len -1] was restored to shadowEstimates[i + len]. T-Check has found no further problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.5">A Link Estimator Bug</head><p>The Collection Tree Protocol (CTP) <ref type="bibr">[9]</ref> computes anycast routes to a single or a small number of designated sinks in a wireless sensor network. Figure <ref type="figure">8</ref>(a) shows an example of a collection tree computed by CTP during a T-Check run. The first liveness property that we wrote for CTP is that eventually, all cycles are removed from the collection tree. We found no violations of that property. The second property that we wrote checks that for any node that is transitively connected to some sink, it should eventually become part of some collection tree. Our initial CTP tests found no violations of this property either. However, at one point a CTP developer committed a change to the TinyOS estimation component that prevented a dead node's children from joining the CTP tree, as shown in Figure <ref type="figure">8</ref>(c), as opposed to the desired behavior shown in Figure <ref type="figure">8(b)</ref>. T-Check found that the critical transition was the death of node 1.</p><p>The code responsible for this problem is shown in Figure <ref type="figure">9</ref>. The problem is that to rejoin the network, the updateNeigh-borTableEst function must be invoked, but for this to happen, a number of packets must be lost. In an insufficiently lossy network, packetGap never reaches BLQ_PKT_WINDOW and the node remains disconnected forever. We discovered this bug in parallel with other developers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.6">An Array Bounds Bug</head><p>Figure <ref type="figure" target="#fig_6">10</ref> shows code that relies on a timing race to reset an array index in the MultihopOscilloscope application. The timer fired event initiates a sensor read under the assumption that the readDone event will happen before the next timer arrives. If the timer expires first, it is possible for the variable reading to be used as an array index  when it is larger than NREADINGS-1. If the Read interface is wired directly to a sensor, there is no bug: the second call to Read.read will fail because the resource is still busy, and the extra readDone event cannot happen. On the other hand, if Read is wired through a resource arbiter, as it is on the MicaZ platform, then the extra read command succeeds after being placed into the arbiter's queue, creating the possibility that two readDone events will be signaled before the timer has a chance to reset the index, causing the out-ofbounds access. This bug is also present in the Oscilloscope and TestMultihopLqi applications. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Effectiveness of Partial Order Reduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Comparing TOSSIM, Random Walk, and Model Checking</head><p>Table <ref type="table">3</ref> compares bug-finding power of TOSSIM against T-Check in both model-checking and random walk modes, for two-node and eight-node topologies. For TOSSIM with Safe TinyOS, we ran 500,000 steps. For T-Check in model checking mode, we randomly executed 30,000 steps to get a steady state, then performed model checking with a 50step bound, timing out after 10 hours. For T-Check in random walk mode the maximum number of steps was irrelevant since the bug was always found. Since only the model checker is deterministic, the for TOSSIM and for T-Check in random walk mode are averaged over 25 runs.</p><p>TOSSIM only found four of the 10 safety bugs, and its traces were always longer than our shortened traces. There are two factors at work. First, T-Check models each sensornet node at a slightly more detailed level than TOSSIM (while still falling well short of modeling all the detail of a real mote). Second, T-Check exploits the abundant nondeterminism in sensornet executions, whereas TOSSIM is largely deterministic.</p><p>We were surprised to find that random testing out-performs model checking in terms of bug-finding power. It is possible that additional optimizations to our model checker, such as exploiting the independence of some pairs of events inside a node, or implementing dynamic POR, would reverse this trend. As things stand, the main advantage of model checking is that if it finds an error, the event trace leading to that error is guaranteed to be the shortest one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Unchecked Code</head><p>Table <ref type="table">4</ref> summarizes the kinds of code that T-Check does and does not check. The main components that we miss are the drivers for timers and for the CC2420 radio chip. All of these components are heavily-used and seem quite solid in practice. Even so, it would be worthwhile devising ways to locate any residual bugs in them, for example using the [mc]square model checker for AVR object code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Our work is most closely related to MaceMC <ref type="bibr" target="#b18">[18]</ref>. Like TinyOS, Mace provides an event-driven infrastructure for constructing distributed systems. Unlike TinyOS, but like TOSSIM, Mace's events run to completion, providing a good match for an explicit state model checker. T-Check directly implements MaceMC's algorithm for finding the critical transition, and has adapted Mace's overall blend of random testing and model checking.</p><p>Harbor <ref type="bibr" target="#b21">[21]</ref>, t-kernel <ref type="bibr" target="#b13">[13]</ref>, and Safe TinyOS <ref type="bibr" target="#b7">[7]</ref> all aim to catch memory safety errors in sensor network applications by adding runtime safety checks. T-Check is complementary to these efforts: regardless of how safety checks are added, a state space explorer provides a good way to look for violations of them.</p><p>KleeNet <ref type="bibr" target="#b27">[27]</ref> uses symbolic analysis to generate test cases for sensor network code, and has been used to find new bugs. KleeNet and T-Check each have advantages and disadvantages; it would be interesting to find out which bugs we found can also be found using KleeNet, and vice versa.</p><p>EnviroLog <ref type="bibr" target="#b24">[24]</ref> automatically and accurately records all events generated by lower-layer and can replay them for system tuning and performance evaluation of sensornets. Tra-cePoint <ref type="bibr" target="#b4">[4]</ref> and NodeMD <ref type="bibr" target="#b20">[20]</ref> both use user-provided annotations and logging to effectively detect, trace, and debug the software faults in sensor network. Dustminer <ref type="bibr" target="#b17">[17]</ref> and Khan et al.'s work <ref type="bibr" target="#b16">[16]</ref> apply data mining techniques to logs to detect and catch complex interactive bugs.</p><p>Nguyet and Soffa <ref type="bibr" target="#b26">[26]</ref> looked at ways to represent the internal structure of TinyOS applications. This kind of work should be directly useful to efforts like T-Check, for example to support inference of independent tasks and interrupts on the same node to perform better partial order reduction. Similarly, Kothari et al. <ref type="bibr" target="#b19">[19]</ref> inferred the state machines hidden inside TinyOS applications. These machines probably abstract away too many details to be directly useful in model checking, but they may provide convenient states for T-Check's high-level property specifications to use. TinyOS interface contracts <ref type="bibr" target="#b1">[1]</ref> add many safety conditions to TinyOS applications. We would have liked to use T-Check to look for contract violations, but significant work would have been required to port contracts to TinyOS 2.</p><p>Symbolic model checkers like BLAST <ref type="bibr" target="#b3">[3]</ref> and SLAM <ref type="bibr" target="#b2">[2]</ref> generate abstract models from source code, and reason about them. In contrast, execution-driven model checkers like Verisoft <ref type="bibr" target="#b10">[10]</ref> and Java Pathfinder <ref type="bibr" target="#b14">[14]</ref> execute the code directly. T-Check is an example of the latter family of model checkers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>We have presented T-Check, a tool that exploits both explicit state model checking and random walks to find bugs in sensor network applications running on TinyOS. T-Check offers users a good value proposition: by exploiting safety checks inserted by Safe TinyOS, users can find bugs without any extra annotation effort. However, if users provide additional, higher level safety and liveness properties, these can also be checked. User-specified properties may be in terms of a single node (e.g., "packets are eventually received") or in terms of the entire network (e.g., "eventually, all nodes are part of the routing tree"). We have used T-Check to find 12 previously unknown bugs in TinyOS 2.1, and we plan to make T-Check available to the sensor network community as open-source software.</p><p>Table <ref type="table">4</ref>: Summary of the number of modules, and total lines of code, from various directories in the TinyOS tree. "Hardware-only" modules do not run in TOSSIM and are not checked by T-Check. "Simulation-only" modules do not run on mote platforms. The remaining modules run on motes and in TOSSIM/T-Check.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: T-Check maintains multiple event queues per node to model event-ordering non-determinism</figDesc><graphic coords="4,53.76,274.54,239.10,112.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The T-Check toolchain</figDesc><graphic coords="5,316.80,53.89,239.10,199.67" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Code for serial bug #1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Code for DIP bug #1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Code for DIP bugs #2 and #3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: Example collection tree. Neighbors are connected by dotted lines, parents and children are connected by solid lines. (a) denotes a collection tree computed by CTP; (b) shows the desired repaired tree after node failure; (c) shows the actual collection tree after node failure, for a buggy version of TinyOS</figDesc><graphic coords="8,53.76,54.15,239.10,155.61" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Code for a bug in MultihopOscilloscope</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Time to model check three applications with and without partial order reduction. For Ra-dioCountToLeds and MultihopOscilloscope, a twonode topology was used. TestSerial is single-mote application and therefore fails to benefit from POR.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11</head><label>11</label><figDesc>Figure 11 clearly shows the exponential relation between the depth bound and the time required to run the model checker. For a 13-step model checking run, POR speeds up T-Check by a factor of 449 for MultihopOscilloscope and a factor of 138 for RadioCountToLeds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>TinyOS 2 properties that we checked</figDesc><table /><note><p>Application Type Property Serial Stack Liveness ∀n ∈ nodes : ¬n.buf ZeroLocked ∧ ¬n.buf OneLocked Eventually, each of two buffers becomes unlocked Safety ∀n ∈ nodes : ¬n.isCurrentBuf f erLocked() ∧ PKT COMING IN → RECV BEGIN The current buffer, if unlocked, should successfully receive an incoming packet CTP Liveness ∀n ∈ nodes : n(.parent) * = n Eventually, there is no loop in the routing tree Liveness ∀n ∈ nodes : n has no path to sink ∨ n ∈ trees Eventually, all nodes that have a path to a sink become part of some collection tree Drip Liveness ∀n ∈ nodes : (n.valueCache =) * VALUE Eventually, all nodes have consistent values Dip Liveness ∀n ∈ nodes : (n.valueCache =) * VALUE Eventually, all nodes have consistent values Dhv Liveness ∀n ∈ nodes : (n.valueCache =) * VALUE Eventually, all nodes have consistent values FTSP Liveness ∀n ∈ nodes : (n.synchronized =) * TRUE Eventually, all nodes achieve time synchronization</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 ,</head><label>1</label><figDesc>which requires that the serial stack eventually unlocks its buffers, is implemented as:</figDesc><table><row><cell>Component</cell><cell cols="2">Safety Liveness</cell></row><row><cell>MultihopOscilloscopeC</cell><cell>1</cell><cell>0</cell></row><row><cell>LinkEstimatorP</cell><cell>0</cell><cell>1</cell></row><row><cell>SerialDispatcherP</cell><cell>1</cell><cell>1</cell></row><row><cell>DipSummaryP</cell><cell>2</cell><cell>0</cell></row><row><cell>DipVersionP</cell><cell>1</cell><cell>0</cell></row><row><cell>MHPacketM</cell><cell>1</cell><cell>0</cell></row><row><cell>DhvSummaryP</cell><cell>1</cell><cell>0</cell></row><row><cell>DhvVBitP</cell><cell>2</cell><cell>0</cell></row><row><cell>DhvHSumP</cell><cell>1</cell><cell>0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Summary of bugs found by T-CheckChecks that inspect the state of multiple nodes are slightly more complex and the sim_set_node utility function is needed to change the current context. For example, the third property listed in Table1can be implemented as:</figDesc><table><row><cell>command bool SimProperty.livenessPropertyCheck() {</cell></row><row><cell>return !receiveState.bufZeroLocked &amp;&amp;</cell></row><row><cell>!receiveState.bufOneLocked;</cell></row><row><cell>}</cell></row><row><cell>command bool SimProperty.livenessPropertyCheck() {</cell></row><row><cell>int tmpMote = sim_node(), mote;</cell></row><row><cell>for (mote = 0; mote &lt; sim_simulated_mote_num(); mote++) {</cell></row><row><cell>sim_set_node (mote);</cell></row><row><cell>if (sim_mote_forms_loop (mote)) {</cell></row><row><cell>sim_set_node (tmpMote);</cell></row><row><cell>return FALSE;</cell></row><row><cell>}</cell></row><row><cell>}</cell></row><row><cell>sim_set_node (tmpMote);</cell></row><row><cell>return TRUE;</cell></row><row><cell>}</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>The authors would like to thank Adam Dunkels (our shepherd), David Gay, Phil Levis, Eric Mercer, Raimondas Sasnauskas, Bastian Schlich, and Matthias Woehrle for much useful feedback on our work. This material is based upon work supported by the National Science Foundation under Grant No. 0615367.</p></div>
			</div>


			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>apps/tests/TestSerial(1/75) system(2/168) lib/tossim(2/178) system(1/101), platforms(2/43) chips/atm128/adc(2/100) chips/atm128/adc/sim(2/132) lib/net/ctp(7/1375) chips/atm128/timer(7/513) chips/atm128/timer/sim(4/748) lib/serial(5/1083) chips/atm128(2/307) chips/atm128/sim(2/397) chips/atm128/adc(1/85), system(10/677) MultihopOscilloscope chips/atm128/pins(5/141) chips/atm128/pins/sim(1/24) chips/atm128/timer(1/160) chips/cc2420(12/2494) lib/tossim(4/980) apps/MultihopOscilloscope(1/185) system(6/331) lib/tossim(3/216) lib/net/4bitle(1/496) platforms(2/89) platforms(2/43) lib/timer(2/168) lib/timer(3/200) chips/atm128/timer(6/380) chips/atm128/timer/sim(1/415) lib/net/drip(4/249), lib/timer(3/200) chips/atm128/pins(5/141) chips/atm128/pins/sim(1/24) chips/atm128/timer(1/160) TestDissemination chips/cc2420(12/2494) lib/tossim(4/980) system(6/384) system(6/331) lib/tossim(3/216) TrickleTimerMilliC.nc(1/179) platforms(2/89) platforms(2/43) lib/timer(2/168) apps/tests/TestDissemination(1/70) chips/atm128/timer(6/380) chips/atm128/timer/sim(1/415) lib/net/dip(8/898), lib/timer(3/200) chips/atm128/pins(5/141) chips/atm128/pins/sim(1/24) chips/atm128/timer(1/160) TestDip chips/cc2420(12/2494) lib/tossim(4/980) system(6/384) system(6/331) lib/tossim(3/216) TrickleTimerMilliC.nc(1/179) platforms(2/89) platforms(2/43) lib/timer(2/168) apps/tests/TestDip(1/400) chips/atm128/timer(6/380) chips/atm128/timer/sim(1/415) lib/net/dhv(10/1205), lib/timer(3/200) chips/atm128/pins(5/141) chips/atm128/pins/sim(1/24) chips/atm128/timer(1/160) TestDhv chips/cc2420(12/2494) lib/tossim(4/980) system(6/384) system(6/331) lib/tossim(3/216) TrickleTimerMilliC.nc(1/179) platforms(2/89) platforms(2/43) lib/timer(2/168) apps/tests/TestDhv(1/406) chips/atm128/timer(6/380) chips/atm128/timer/sim(1/415) lib/ftsp(1/399), lib/timer(4/267) chips/atm128/pins(5/141) chips/atm128/pins/sim(1/24) chips/atm128/timer(1/160) TestFtsp chips/cc2420(13/2671) lib/tossim(5/1229) system(6/384) system(6/331) lib/tossim(3/216) platforms(2/43) platforms(2/89) apps/tests/TestFtsp(1/53) lib/timer(1/101)</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Interface contracts for TinyOS</title>
		<author>
			<persName><forename type="first">Will</forename><surname>Archer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Conf. on Information Processing in Sensor Networks (IPSN&apos;07), SPOTS Track</title>
		<meeting>of the Intl. Conf. on Information essing in Sensor Networks (IPSN&apos;07), SPOTS Track<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-04">April 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The SLAM project: Debugging system software via static analysis</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sriram</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 29th ACM Symp. on Principles of Programming Languages (POPL)</title>
		<meeting>of the 29th ACM Symp. on Principles of Programming Languages (POPL)<address><addrLine>Portland, OR, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The software model checker Blast: Applications to software engineering</title>
		<author>
			<persName><forename type="first">Dirk</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ranjit</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rupak</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<date type="published" when="2007-10">October 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Declarative tracepoints: A programmable and application independent debugging system for wireless sensor networks</title>
		<author>
			<persName><forename type="first">Qing</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tarek</forename><surname>Abdelzaher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Stankovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kamin</forename><surname>Whitehouse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liqian</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th ACM Conf. on Embedded Networked Sensor Systems (SenSys)</title>
		<meeting>of the 6th ACM Conf. on Embedded Networked Sensor Systems (SenSys)<address><addrLine>Raleigh, NC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-11">November 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic verification of finite-state concurrent systems using temporal logic specifications</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="244" to="263" />
			<date type="published" when="1986-04">April 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dependent types for low-level programming</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 16th European Symp. on Programming (ESOP)</title>
		<meeting>of the 16th European Symp. on Programming (ESOP)<address><addrLine>Braga, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-04">March-April 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient memory safety for TinyOS</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Cooprider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Archer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th ACM Conf. on Embedded Networked Sensor Systems (SenSys)</title>
		<meeting>of the 5th ACM Conf. on Embedded Networked Sensor Systems (SenSys)<address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-11">November 2007</date>
			<biblScope unit="page" from="205" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The nesC language: A holistic approach to networked embedded systems</title>
		<author>
			<persName><forename type="first">David</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phil</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matt</forename><surname>Robert Von Behren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGPLAN 2003 Conf. on Programming Language Design and Implementation (PLDI)</title>
		<meeting>of the ACM SIGPLAN 2003 Conf. on Programming Language Design and Implementation (PLDI)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Collection tree protocol</title>
		<author>
			<persName><forename type="first">Omprakash</forename><surname>Gnawali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rodrigo</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyle</forename><surname>Jamieson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Levis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th ACM Conference on Embedded Networked Sensor Systems (SenSys)</title>
		<meeting>of the 7th ACM Conference on Embedded Networked Sensor Systems (SenSys)<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-11">November 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Model checking for programming languages using Verisoft</title>
		<author>
			<persName><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Symp. on Principles of Programming Languages</title>
		<meeting>of the Symp. on Principles of Programming Languages<address><addrLine>Nice, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-01">January 1997</date>
			<biblScope unit="page" from="174" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">TinyOS Extension Proposal (TEP) 113: Serial Communication</title>
		<author>
			<persName><forename type="first">Ben</forename><surname>Greenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Levis</surname></persName>
		</author>
		<ptr target="http://www.tinyos.net/tinyos-2.x/doc/html/tep113.html" />
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Random testing and model checking: Building a common framework for nondeterministic exploration</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Joshi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th Intl. Workshop on Dynamic Analysis (WODA)</title>
		<meeting>of the 6th Intl. Workshop on Dynamic Analysis (WODA)<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-07">July 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">t-kernel: Providing reliable OS support to wireless sensor networks</title>
		<author>
			<persName><forename type="first">Lin</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">A</forename><surname>Stankovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4th ACM Conf. on Embedded Networked Sensor Systems (SenSys)</title>
		<meeting>of the 4th ACM Conf. on Embedded Networked Sensor Systems (SenSys)<address><addrLine>Boulder, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11">November 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Model checking Java programs using Java PathFinder</title>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Pressburger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2000-03">March 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">System architecture directions for networked sensors</title>
		<author>
			<persName><forename type="first">Jason</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Szewczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alec</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seth</forename><surname>Hollar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristofer</forename><surname>Pister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Intl. Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>of the 9th Intl. Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS)<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-11">November 2000</date>
			<biblScope unit="page" from="93" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Towards diagnostic simulation in sensor networks</title>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Maifi Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tarek</forename><surname>Abdelzaher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kamal Kant</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Conf. on Distributed Computing in Sensor Systems (DCOSS)</title>
		<meeting>of the Intl. Conf. on Distributed Computing in Sensor Systems (DCOSS)<address><addrLine>Santorini Island, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06">June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Troubleshooting interactive complexity bugs in sensor networks</title>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Maifi Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hieu</forename><surname>Khac Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hossein</forename><surname>Ahmadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tarek</forename><forename type="middle">F</forename><surname>Abdelzaher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><surname>Dustminer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th ACM Conf. on Embedded Networked Sensor Systems (SenSys)</title>
		<meeting>of the 6th ACM Conf. on Embedded Networked Sensor Systems (SenSys)<address><addrLine>Raleigh, NC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-11">November 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Life, death, and the critical transition: Detecting liveness bugs in systems code</title>
		<author>
			<persName><forename type="first">Charles</forename><surname>Killian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">W</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ranjit</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amin</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4th Symp. on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>of the 4th Symp. on Networked Systems Design and Implementation (NSDI)<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-04">April 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Deriving state machines from TinyOS programs using symbolic execution</title>
		<author>
			<persName><forename type="first">Nupur</forename><surname>Kothari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramesh</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th Intl. Conf. on Information Processing in Sensor Networks (IPSN 2008)</title>
		<meeting>of the 7th Intl. Conf. on Information essing in Sensor Networks (IPSN 2008)<address><addrLine>St. Louis, MO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">NodeMD: Diagnosing node-level faults in remote wireless sensor systems</title>
		<author>
			<persName><forename type="first">Veljko</forename><surname>Krunic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Trumpler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th International Conference on Mobile Systems, Applications, and Services (Mobisys)</title>
		<meeting>of the 5th International Conference on Mobile Systems, Applications, and Services (Mobisys)<address><addrLine>San Juan, Puerto Rico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Harbor: software-based memory protection for sensor nodes</title>
		<author>
			<persName><forename type="first">Ram</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eddie</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mani</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th Intl. Conf. on Information Processing in Sensor Networks (IPSN07)</title>
		<meeting>of the 6th Intl. Conf. on Information essing in Sensor Networks (IPSN07)<address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">TOSSIM: Accurate and scalable simulation of entire TinyOS applications</title>
		<author>
			<persName><forename type="first">Philip</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nelson</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matt</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1st ACM Conf. on Embedded Networked Sensor Systems (SenSys)</title>
		<meeting>of the 1st ACM Conf. on Embedded Networked Sensor Systems (SenSys)<address><addrLine>Los Angeles, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-11">November 2003</date>
			<biblScope unit="page" from="126" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Data discovery and dissemination with DIP</title>
		<author>
			<persName><forename type="first">Kaisen</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Levis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th Intl. Conf. on Information Processing in Sensor Networks (IPSN08)</title>
		<meeting>of the 7th Intl. Conf. on Information essing in Sensor Networks (IPSN08)<address><addrLine>St. Louis, MO, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-04">April 2008</date>
			<biblScope unit="page" from="433" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Achieving repeatability of asynchronous events in wireless sensor networks with EnviroLog</title>
		<author>
			<persName><forename type="first">Liqian</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tian</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tarek</forename><forename type="middle">F</forename><surname>Abdelzaher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">A</forename><surname>Stankovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25th Conf. on Computer Communications (INFOCOM)</title>
		<meeting>of the 25th Conf. on Computer Communications (INFOCOM)<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-04">April 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title/>
		<ptr target="http://www.moteiv.com" />
	</analytic>
	<monogr>
		<title level="j">Moteiv. Telos rev. B datasheet</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Program representations for testing wireless sensor network applications</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Nguyet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><forename type="middle">Lou</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><surname>Soffa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Workshop on Domain Specific Approaches to Software Test Automation (DoSTA&apos;07)</title>
		<meeting>of the Workshop on Domain Specific Approaches to Software Test Automation (DoSTA&apos;07)<address><addrLine>Dubrovnik, Croatia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">KleeNet: Discovering insidious interaction bugs in wireless sensor networks before deployment</title>
		<author>
			<persName><forename type="first">Raimondas</forename><surname>Sasnauskas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olaf</forename><surname>Landsiedel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Hamad Alizai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Weise</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Kowalewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Wehrle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th ACM/IEEE International Conference on Information Processing in Sensor Networks (IPSN)</title>
		<meeting>of the 9th ACM/IEEE International Conference on Information essing in Sensor Networks (IPSN)<address><addrLine>Stockholm, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-04">April 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Model Checking of Software for Microcontrollers</title>
		<author>
			<persName><forename type="first">Bastian</forename><surname>Schlich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-06">June 2008</date>
			<pubPlace>Aachen, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>RWTH Aachen University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Dissertation</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Fidelity and yield in a volcano monitoring sensor network</title>
		<author>
			<persName><forename type="first">Geoff</forename><surname>Werner-Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konrad</forename><surname>Lorincz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Lees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matt</forename><surname>Welsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th USENIX Symp. on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>of the 7th USENIX Symp. on Operating Systems Design and Implementation (OSDI)<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11">November 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Simplifying and isolating failure-inducing input</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralf</forename><surname>Hildebrandt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="200" />
			<date type="published" when="2002-02">February 2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
