<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards the Semantics and Verification of BPEL4WS 1</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Geguang</forename><surname>Pu</surname></persName>
							<email>ggpu@math.pku.edu.cn</email>
						</author>
						<author>
							<persName><forename type="first">Zhao</forename><surname>Xiangpeng</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wang</forename><surname>Shuling</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Qiu</forename><surname>Zongyan</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">†LMAM and Department of Informatics</orgName>
								<orgName type="department" key="dep2">School of Mathematics Peking University</orgName>
								<address>
									<postCode>100871</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">P. R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">‡Software Engineering Institute East</orgName>
								<orgName type="institution">China Normal University</orgName>
								<address>
									<postCode>200062</postCode>
									<settlement>Shanghai</settlement>
									<country key="CN">P. R. China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards the Semantics and Verification of BPEL4WS 1</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C0CCF082467267FAE9765EE0D8F6A1E9</idno>
					<idno type="DOI">10.1016/j.entcs.2005.07.035</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Web Service</term>
					<term>BPEL4WS</term>
					<term>Operational Semantics</term>
					<term>Verification</term>
					<term>Timed Automata</term>
					<term>Uppaal</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we discuss the semantics of BPEL4WS language which is a de facto standard for specifying and execution workflow specification for web service composition and orchestration. We propose a language μ-BPEL that includes most primitive and structured activities of BPEL4WS, and define its semantics. As the Timed Automata (TA) is powerful in designing real-time models with multiple clocks and has well developed automatic tool support, we define a map from μ-BPEL into composable TA. Therefore, the properties we want to check can be verified in TA network correspondingly. Furthermore, we prove that the mapping from μ-BPEL to TA is a simulation, which means that the TA network simulates correctly the corresponding μ-BPEL specification. The case study with model checker Uppaal shows that our method is effective, and a Java supporting tool based on Uppaal model checker engine has been developed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The goal of the web services effort is to achieve universal interoperability between applications by using web standards. More and more organizations are adopting web service protocols, such as SOAP (Simple Object Access Protocol), and WSDL (Web Service Description Language), which are slowly becoming the standards for describing communication-level mappings of web service messages to communication protocols. Likewise, business process modelling languages such as XLANG <ref type="bibr" target="#b21">[22]</ref>, WSFL <ref type="bibr" target="#b15">[16]</ref>, most recently, Business Process Execution for Web Service(BPEL4WS) <ref type="bibr" target="#b8">[9]</ref>, have been developed to model business process by describing workflows and interfaces, as well as specifying the technical infrastructure for carrying out business transactions.</p><p>BPEL4WS is a de facto standard for specifying and execution workflow specification for web services, and composing kinds of web services defined by WSDL. It is a language with rich expressivity when compared to other languages for business process modelling, in particular those supported by workflow management systems <ref type="bibr" target="#b0">[1]</ref>. It contains a number of primitive activities as well as structured activities. On the other hand, this leads to the complexity of BPEL4WS. In addition, the semantics of BPEL4WS is not always clear, as its informal semantics given in the specification. Some recent efforts <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref> have attempted to formalize other workflow languages which are similar to BPEL4WS to some extent, but not as complex. Another important feature of BPEL4WS is that it supports the stateful, long-running interactions involving many parties. Therefore, it provides the ability to define fault handling and compensation in an application-specific manner, resulting in a feature called Long-Running Transaction. The concept compensation is due to the use of Sagas <ref type="bibr" target="#b11">[12]</ref> and open nested transactions <ref type="bibr" target="#b16">[17]</ref>. Recently, some researchers attempted to offer a theoretical foundation of compensation in flow compensation languages, such as <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b5">6]</ref>, that adopted the CCS-like experimental languages by adding some operators to deal with compensation.</p><p>Here we focus on the rich set of operators of BPEL4WS, including the primitive activities and structured activities, which can be used to compose and orchestrate the web services. We first abstract the syntax of BPEL4WS from the XML-based forms, and present a new langauge called μ-BPEL, which is a simplified version of BPEL4WS involving not the compensation handlers with scope. The fault handlers in a simplified way will be discussed as well. This simplification makes it possible to verify μ-BPEL in a complete automatical framework. <ref type="bibr" target="#b6">[7]</ref> is a recent try to verify BPEL4WS with full compensation support. But due to its complexity, the verification is done in B and is not automatical. To the best of our knowledge, there is no work currently in automatical verification of BPEL4WS that supports compensation completely.</p><p>The notations used in μ-BPEL are inspired by <ref type="bibr" target="#b12">[13]</ref>. The full structural operational semantics are presented. Another target of our work is to check and verify the BPEL4WS specification at semantic level, which is valuable in providing a simulated workflow mechanism to visually compare expected with simulated results of workflow invocation which can increase expectations of a successful outcome prior to deployment <ref type="bibr" target="#b17">[18]</ref>. Some approaches for the verification of web service composition and interaction based on BPEL4WS were proposed recently, such as <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b10">11]</ref>. But these researchers mainly focus on the control flow of service composition and orchestration, and omit the time information which is also an important element in BPEL4WS. To analyze and verify the control flow of BPEL4WS as well as its time property, we propose a new approach using Timed Automata <ref type="bibr" target="#b1">[2]</ref> as the foundation of the formalization for BPEL4WS in this paper.</p><p>Timed Automata (TA) is powerful in designing real-time models with multiple clocks and has well developed tools support the verification, such as Uppaal <ref type="bibr" target="#b3">[4]</ref>. We define a map from μ-BPEL constructs into the composable Timed Automata here. Therefore, many properties we want to check within μ-BPEL can be verified in TA network correspondingly. Furthermore, we prove the mapping from μ-BPEL to TA is a simulation which means the TA network simulates correctly the corresponding μ-BPEL specification.</p><p>This paper is organized as follows. Section 2 introduces the μ-BPEL language and its operational semantics. Section 3 describes the timed automata and its corresponding semantics. Section 4 presents the transformation rules with the simulation property between μ-BPEL and timed automata. Section 5 conducts a case study from BPEL4WS specification using Uppaal model checker. The last section gives the conclusion and future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The μ-BPEL Language</head><p>The behaviors of business process are constructed by BPEL4WS activities. The declaration part is mainly specified by WSDL, that is not the focus here. When we refer to variables in business process, we suppose that they are already defined somewhere. In this section, we propose a simplified version of BPEL4WS called μ-BPEL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Syntax of μ-BPEL</head><p>Here we list the syntax of μ-BPEL.</p><formula xml:id="formula_0">BA ::= skip | throw n | x := ē | wait tc | waitill tc | rec a x | rep a v | inv a x y | A ::= BA | b { ľ1 , ľ2 } • A | A • {b 1 l1 , b 2 l2 } | A; A | A b A | b * A | c → A[]c → A | A L A c ::= rec a x | wait tc | waitill tc</formula><p>The basic activity skip does nothing but entering the terminated state. throw generates a fault named n from inside the business process explicitly.</p><p>x := ē is a multiple assignment corresponding to the assign activity. Activities wait and waitill represent two different mechanisms of wait activity, which allow us to wait for a given time period or until a certain time. rec a x and rep a v stand for receive and reply respectively to communicate data with the environment of the business process. inv a x y denotes the invoke activity to call some web service offered by its environment. Here we assume inv as two-way operation, and the behavior of one-way inv is similar to that of skip. For the convenience of defining the semantics of μ-BPEL, we introduce the terminated form standing for the empty text.</p><p>The activities A; A, A b A and b * A stand for sequential composition, conditional and iterative constructs respectively. External choice c → A[]c → A denotes the pick activity, allowing us to block and wait for a suitable message to arrive or for a time-out alarm to go off. When one of these triggers takes place, the associated activity is performed and the pick activity completes.</p><p>An interesting thing in BPEL4WS is the link construct providing the synchronization in flow activity. Each link introduced in a flow activity must have exactly one activity as its source and one activity as its target. The source and target of a link may appear in any structures nested arbitrarily deeply within the flow, except for the boundary-crossing restrictions <ref type="bibr" target="#b8">[9]</ref>. This mechanism is quite different from the hand-shaking adopted by CSP. To model this, structures b { ľ1 , ľ2 } • A and A • {b 1 l1 , b 2 l2 } are added into μ-BPEL. The first is called target link, while the second as source link. At the same time, flow activity A L B should synchronize on the set L of links.</p><p>We briefly describe the link semantics within flow activity from BPEL4WS specification <ref type="bibr" target="#b8">[9]</ref> here. Assume activity B is the target of a link that has A as the source. When A completes, the status of all outgoing links from A is determined by evaluating the transition condition for each link. On the other hand, activity B will check whether the status of all incoming links are determined and it is ready to start. When both conditions are true for B, then the join condition is evaluated for B. If the join condition ia false, a standard fault is thrown, otherwise B is started. We use construct b { ľ1 , ľ2 } • B to represent B is the target of links l 1 and l 2 with condition b, while A • {b 1 l1 , b 2 l2 } denotes that A is the source of l 1 and l 2 which are assigned boolean values b after the completion of A. Notation l and ľ stand for the source and target of link l respectively.</p><p>In μ-BPEL, we introduce the link set L, and regard l ∈ L as a special variable to record the status of the link, the valuation of which is from link set to three-values set {true, f alse, }, where denotes the status of l is not decided. The following table shows the results of computation for three values set under conjunction operator. The other boolean operators are defined similarly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>∧</head><p>true f alse true true f alse f alse f alse f alse</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Operational Semantics</head><p>In this section, the small step operational semantics of μ-BPEL is presented.</p><p>In the semantics, the configuration is defined as a tuple:</p><formula xml:id="formula_1">A, σ, t ∈ Activity × State × T ime</formula><p>where Activity is some text, and State a function from variables to values.</p><p>Here the continuous time set T ime is adopted. Configuration , σ, t denotes the terminated configuration. Two kinds of events are distinguished: the visible events and silent event τ . The visible event set contains not only the events communicating with the external environment, but also those updating the state, such as assignment activities etc. The event about time elapsing is denoted as δ. We use the set Alpha to denote all possible transition events (excluding δ) and Action as the set of all visible events: Alpha = Action ∪ {τ }.</p><p>In the following definition, we have that event a ∈ Action and α ∈ Alpha.</p><p>The behaviors of some basic activities are defined as follows:</p><formula xml:id="formula_2">skip, σ, t τ -→ , σ, t inv a x y, σ, t δ -→ inv a x y, σ, t + δ inv a x y, σ, t a.v -→ , σ[y → v], t x := ē, σ, t a -→ , σ[x → σ(ē)], t</formula><p>where event a equals [x := ē]</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Communication</head><p>The receive activity just receives the value v to be stored in variable x with the event a.v through channel a. If the environment is not ready to offer the event, this activity just be in waiting state, and the time elapses.</p><formula xml:id="formula_3">rec a x, σ, t a.v -→ , σ[x → v], t if v ∈ V a rec a x, σ, t δ -→ rec a x, σ, t + δ</formula><p>Where set V a stands for those values which can be passed through channel a.</p><p>The behavior of reply is similar to that of receive.</p><formula xml:id="formula_4">rep a v, σ, t a.v -→ , σ, t if v ∈ V a rep a v, σ, t δ -→ rep a v, σ, t + δ</formula><p>The following transition rules are about the wait activity in BPEL4WS.</p><formula xml:id="formula_5">wait tc, σ, t δ -→ wait(tc -δ), σ, t + δ if δ &lt; tc wait tc, σ, t δ -→ , σ, t + δ if δ = tc waitill tc, σ, t δ -→ waitill tc, σ, t + δ if t + δ &lt; tc waitill tc, σ, t δ -→ , σ, t + δ if t + δ = tc</formula><p>Next we define the semantics of structural activities.</p><p>Sequence</p><formula xml:id="formula_6">A, σ, t δ -→ A , σ , t + δ A; B, σ, t δ -→ A ; B, σ , t + δ A, σ, t α -→ A , σ , t A; B, σ, t α -→ A ; B, σ , t ; A, σ, t τ -→ A, σ, t Switch σ(b) -→ true A b B, σ, t τ -→ A, σ, t σ(b) -→ f alse A b B, σ, t τ -→ B, σ, t Iteration σ(b) -→ true b * A, σ, t τ -→ A; b * A, σ, t σ(b) -→ f alse b * A, σ, t τ -→ , σ, t Link A, σ, t α -→ A , σ , t A • {b 1 l1 , b 2 l2 }, σ, t α -→ A • {b 1 l1 , b 2 l2 }, σ , t • {b 1 l1 , b 2 l2 }, σ, t a -→ , σ[l 1 → σ(b 1 ), l 2 → σ(b 2 )], t</formula><p>Where event a equals [l</p><formula xml:id="formula_7">1 := b 1 , l 2 := b 2 ] A, σ, t δ -→ A , σ , t + δ A • {b 1 l1 , b 2 l2 }, σ, t δ -→ A • {b 1 l1 , b 2 l2 }, σ , t + δ σ(b{ ľ1 , ľ2 }) -→ true b{ ľ1 , ľ2 } • A, σ, t τ -→ A, σ, t</formula><p>From the rules about link structures above, when the link variables are updated, the observable updating event takes place as what the assignment activity does. If the valuation of boolean variable in target link is f alse, as what is said in BPEL4WS specification, one standard fault will be thrown out. This situation will be taken into account in the next subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>External Choice</head><formula xml:id="formula_8">rec a x → A, σ, t a.v -→ A, σ[x → v], t rec a x → A[]c → C, σ, t a.v -→ A, σ[x → v], t rec a x → A, σ, t δ -→ rec a x → A, σ, t + δ , c → C, σ, t δ -→ c → C, σ, t + δ rec a x → A[]c → C, σ, t δ -→ rec a x → A[]c → C, σ, t + δ wait tc → A, σ, t δ -→ wait (tc -δ) → A, σ, t + δ , c → C, σ, t δ -→ c → C, σ, t + δ , δ&lt;t c wait tc → A [] c → C, σ, t δ -→ wait (tc -δ) → A [] c → C, σ, t + δ wait tc → A, σ, t δ -→ A, σ, t + δ , δ = tc wait tc → A [] c → C, σ, t δ -→ A, σ, t + δ waitill tc → A, σ, t δ -→ waitill tc → A, σ, t + δ , c → C, σ, t δ -→ c → C, σ, t + δ , δ &lt; tc -t waitill tc → A [] c → C, σ, t δ -→ waitill tc → A [] c → C, σ, t + δ waitill tc → A, σ, t δ -→ A, σ, t + δ , δ = tc -t waitill tc → A [] c → C, σ, t δ -→ A, σ, t + δ,</formula><p>We omit similar rules where guards appear to the right of [] due to symmetry.</p><formula xml:id="formula_9">Flow(Parallel) A, σ, t δ -→ A , σ , t + δ , C, σ, t δ -→ C , σ , t + δ A L C, σ, t δ -→ A L C , σ , t + δ A, σ, t α -→ A , σ , t A L C, σ, t α -→ A L C, σ , t C, σ, t α -→ C , σ , t A L C, σ, t α -→ A L C , σ , t L , σ, t τ -→ , σ, t</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fault Handler</head><p>As the scope is not introduced here, we just relate the fault handler with the outmost activity, which means the nesting fault handler is not allowed here. The syntax is modified slightly by adding fault handler structure:</p><formula xml:id="formula_10">F A ::= A ? F F = catch n 1 → A n 1 [] f catch n 2 → A n 2</formula><p>To handle the possible error occurring in business process, we introduce a new configuration to denote the error state. In our operational model, when one kind error takes place, it could be catched by fault handler if this error name is matched to one of catch branches in fault handler. If this error cannot be catched, or one happens in fault handler, the whole FA reaches the error state. For simplicity, variable n denotes the error name when such error occurs.</p><formula xml:id="formula_11">A, σ, t α -→ A , σ , t A?F , σ , t α -→ A ?F , σ , t ?F , σ , t τ -→ , σ , t A, σ, t δ -→ A , σ , t + δ A?F , σ , t δ -→ A ?F , σ , t + δ A, σ, t n 1 -→ A?F , σ , t n 1 -→ A n 1 , σ , t A, σ, t n 2 -→ A?F , σ , t n 2 -→ A n 2 , σ , t</formula><p>Then we should add some rules to deal with the occurrence of error in kinds of activities, and the composition of error with other structural activities. Due to the limited space, these rules are omitted here, and can be referred in our technical report <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Timed Automata</head><p>We map the μ-BPEL specification into the network of timed automata. Before introducing the mapping, we present the syntax and semantics of timed automata formally, which is little departure from the standard TA to fit the need of model checker Uppaal. We call it Extended Timed Automata (ETA), which is similar to the model used in Uppaal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Syntax of ETA and ETA network</head><p>An ETA has an initial state, an ending state, synchronization channels, and variable besides clocks.</p><formula xml:id="formula_12">standard T A : (S, S 0 , Σ, X, E) E ⊆ S × S × Σ × 2 X × Φ(X) ET A : (S, i, e, C, V, X, E) E ⊆ S × S × Guard × Action ∪ {τ } × Update</formula><p>where S: States, C: Channels, V : Variables, X: Clocks, E: Edges, i ∈ S: Initial State, e ∈ S: Ending State.</p><formula xml:id="formula_13">Guard ::= BExp Action ::= a? | a! Update ::= {x → e 1 , y → e 2 } (x, y ∈ V ∪ X)</formula><p>Both clock variables and data variables in Guard and Update.</p><p>If several automata run in parallel, then we call them an ETA network. They share variables and clocks in V and X, but keep their own states.</p><formula xml:id="formula_14">ET A 1 ET A 2 • • • ET A n = (S, I, E, n i=1 C i , n i=1 V i , n i=1 X i , n i=1 E i ) S = {S 1 , • • • , S n } I = {i 1 , • • • , i n } E = {e 1 , • • • , e n }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Semantics of ETA Network</head><p>For the construction of an abstract transition system for our target formalism, timed automata, we use the following configuration to define the semantics:</p><formula xml:id="formula_15">Conf = s, ν, σ</formula><p>where s : {i → st | i ∈ 1..n, st ∈ S i } denotes the status of each automaton in the network. For example, s(i) ∈ S i is the ith automaton's current state.</p><p>ν : X → R + denotes the clock valuation.</p><p>σ : V → Z ∪ {true, f alse} denotes the variable valuation.</p><p>The three transition rules are defined as follows:</p><p>• Time passing:</p><formula xml:id="formula_16">s, ν, σ δ -→ s, ν + δ, σ • Transition: ∃i ∈ N, e ∈ E . e = s(i), s(i) , g, α, u ∧ ν, σ |= g s, ν, σ α -→ s , ν , σ where α ∈ Action ∪ {τ } s (x) = ⎧ ⎨ ⎩ s(i) x = i s(x) else ν (x) = ⎧ ⎨ ⎩ σ(u(x)) x ∈ dom(u) ν(x) else σ (x) = ⎧ ⎨ ⎩ σ(u(x)) x ∈ dom(u) σ(x) else • Synchronized transition: ∃i, j ∈ N, e 1 , e 2 ∈ E . e 1 = (s(i), s(i) , g 1 , a?, u 1 ), e 2 = (s(j), s(j) , g 2 , a!, u 2 ) ∧ ν, σ |= g 1 ∧ ν, σ |= g 2 s, ν, σ a -→ s , ν , σ where s (x) = ⎧ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎩ s(i) x = i s(j) x = j s(x) else ν (x) = ⎧ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎩ σ(u 1 (x)) x ∈ dom(u 1 ) σ(u 2 (x)) x ∈ dom(u 2 ) ν(x) else σ (x) = ⎧ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎩ σ(u 1 (x)) x ∈ dom(u 1 ) σ(u 2 (x)) x ∈ dom(u 2 )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>σ(x) else</head><p>Within the transition, we require that the valuation of clocks and variables meets the guard. In synchronized transition, we require that there exist a sending signal and a receiving signal on two edges, and the valuation of clocks and variables meets both guards as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Mapping from μ-BPEL to ETA Network</head><p>In this section, we present the approach to translating μ-BPEL specification into ETA network. Moreover, the mapping between them is proved to be as simulation relation formally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Mapping</head><p>The core of a μ-BPEL process is its main activity. We also add an automaton representing external web services into our model, which gives a clear view of the interactions between the process and the environment. Some extra control variables denoted as set CV are introduced to help to define the parallel operation. Besides, we use synchronized channels to represent invocation of web services. We map a process written in μ-BPEL language to an ETA network:</p><p>System ::= Main W ebServices F aultHandler F lowedActivities where F lowedActivities = P 1 P 2 • • • P k denotes all the parallel activities within each embedded f low activity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Main Activity</head><p>Main is defined recursively as an ETA:</p><formula xml:id="formula_17">Main = (S, i, e, C, V, X ∪ {x global }, E)</formula><p>by the following transformation rules.  Most rules defined above are straight forward and can be understood easily with the aid of Figure <ref type="figure" target="#fig_0">1</ref>. For example, "wait tc" is transformed into an automaton with three states and one clock. Along the transition from i to w we reset the clock. Then the automaton has to wait for tc time units before moving to the state e, as the guard "x &gt; tc" specifies. The communication activities, like inv, exchange messages with the environment. We use channels to represent such behaviors. For the variable input/output, we simply add an updating activity x := v to simulate the return of value from the web service, and omit the input of value to the web service.</p><p>Note that in the definitions of receive, invoke and reply, the timing information is not included in the syntax. However, in order to check timed properties of the system, we add timing information to each web service call. For ex- ample, inv tc means the inv operation will take tc time units to perform. The synchronous invoke should be transformed into inv tc , while the asynchronous invoke into inv. Besides, since throw is quite similar to inv, we have omitted the corresponding figure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Structural activities</head><p>The following transformation rules deal with the structured activities. The rules above are compositional rules. Note that in Figure <ref type="figure" target="#fig_1">2</ref>, the automata contain such state that is annotated by a letter "P" or "Q", which means the state is an individual activity, i.e. another ETA. Take P ; Q as an example: we simply add one edge from P 's ending state to Q's initial state.</p><formula xml:id="formula_18">P ; Q " P.S ∪ Q.S, P.i, Q.e, P.C ∪ Q.C, P.V ∪ Q.V, P.X ∪ Q.X, P.E ∪ Q.E ∪ {(P.e, Q.i,</formula><p>One may notice that the representation of external choice is slightly different from the previous definition. We omit the form wait tc 1 → P [] wait tc 2 → Q, since it can be modelled similarly in timed automata as well.</p><p>The corresponding automata of the last two rules are in Figure <ref type="figure" target="#fig_3">3</ref>, since these rules are flow-related. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Web Services</head><p>The automaton W ebServices represents the environment that interacts with the μ-BPEL process. It is defined as a flower-like ETA as shown in Figure <ref type="figure" target="#fig_3">3</ref>. Currently, there is only channel synchronization in our model. However, if the user knows the behavior of some web service, he may add the details into the model. Note that plop means "partner link : operation" in the BPEL4WS specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Flow</head><p>As shown in the third automaton of Figure <ref type="figure" target="#fig_3">3</ref>,</p><formula xml:id="formula_19">A 1 L A 2 L • • • L A m , L = {l 1 , l 2 , • • • , l k } is converted into: {i, w, e}, i, e, ∅, {f begin , f end } ∪ L, ∅, ∅, {(i, w, true, τ, {f begin → true}), (w, e, f end = m, τ, ∅)} Note that f begin , l 1 , l 2 , • • • , l k are boolean variables, while f end is an integer variable.</formula><p>For each activity A j (j = 1, 2, • • • , m) in the flow, we convert it into a timed automata P using the method defined in the previous subsection. Then we convert P again into the following ETA, adding synchronization variables P.S ∪ {i, e}, i, e, P.C, P.V, P.X, P.E ∪ {(i, P.i, f begin , τ, ∅), (P.e, e, true, τ, {f end → f end + 1}</p><p>In the transformation defined above, we use boolean variables to denote links. Variables f begin and f end are used to synchronize the activities in the flow, which can only start after the flow starts (i.e. f begin is true). When one parallel activity finishes, it adds f end by one. Therefore, the whole flow can finish only after each activity finishes, which implies that f end equals to m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.4">Fault Handler</head><p>Suppose the fault handler is:</p><formula xml:id="formula_20">catch n 1 → A n 1 [] f catch n 2 → A n 2</formula><p>We can use external choice to capture its behavior:</p><formula xml:id="formula_21">F aultHandler = n 1 → A n 1 [] n 2 → A n 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.5">Optimization</head><p>It is worthwhile to point out that, in the transformation process, some nodes in the automata can be eliminated to obtain a more concise and efficient model of the original BPEL4WS specification. As shown in the Figure <ref type="figure" target="#fig_5">4</ref>, the code "x := e b skip" requires only two nodes after optimization.</p><p>Such optimization techniques are not mentioned in our transformation rules, since those rules defined earlier are more understandable. However, when the tool supporting the transformation were developed, we can adopted some optimization rules to reduce the complexity of ETA network which will improve the efficiency and performance of model checkers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Simulation</head><p>Now we construct the simulation between μ-BPEL and ETA, and provide the correctness property for this transformation, which means the ETA network can simulate the behaviors of corresponding μ-BPEL processes correctly. However, in this part, we do not consider the fault handler, as the fault event is trigged by abnormal elements which cannot be modelled precisely in ETA at present (as a future work). Let bp ∈ BP and ta ∈ ET A denote the configurations of μ-BPEL and ETA respectively. Then, We introduce the concept of simulation S . Theorem 4.2 For any μ-BPEL activity A and its corresponding timed automaton ETA, the simulation relation A, σ 0 , t 0 S i, ν 0 , σ 0 establishes , where they have the same σ 0 , while i and ν 0 are the initial state of ETA and the zero valuation respectively.</p><p>Proof. See <ref type="bibr" target="#b19">[20]</ref>. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Case Study</head><p>In this section, we give an example to show the verification of μ-BPEL in timed automata using model checker Uppaal <ref type="bibr" target="#b3">[4]</ref>, which is a popular tool for modelling, simulation and verification of real-time systems <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b9">10</ref>]. The auction house example is based on the example given in Chapter 16.3 of the BPEL4WS Specification <ref type="bibr" target="#b8">[9]</ref>, with some simplification to fit in the paper. The XML source is listed as below.</p><p>&lt;process name="auctionService"&gt; &lt;sequence&gt; &lt;flow&gt; &lt;receive name="acceptSellerInformation" partnerLink="seller" portType="as:sellerPT" Fig. <ref type="figure">5</ref>. Auction house example operation="provide" variable="sellerData" createInstance="yes"&gt; &lt;/receive&gt; &lt;receive name="acceptBuyerInformation" partnerLink="buyer" portType="as:buyerPT" operation="provide" variable="buyerData" createInstance="yes"&gt; &lt;/receive&gt; &lt;/flow&gt; &lt;assign&gt; &lt;copy&gt; &lt;from&gt; &lt;wsa:EndpointReference&gt; &lt;wsa:Address&gt;xs:anyURI&lt;/wsa:Address&gt; &lt;wsa:ServiceName&gt;ars:RegistrationService&lt;/wsa:ServiceName&gt; &lt;/wsa:EndpointReference&gt; &lt;/from&gt; &lt;to partnerLink="auctionRegistrationService"/&gt; &lt;/copy&gt; &lt;/assign&gt; &lt;assign&gt; &lt;copy&gt; &lt;from partnerLink="auctionRegistrationService" endpointReference="myRole"/&gt; &lt;to variable="auctionData" part="auctionHouseServiceRef"/&gt; &lt;/copy&gt; &lt;/assign&gt; &lt;invoke name="registerAuctionResults" partnerLink="auctionRegistrationService" portType="as:auctionRegistrationPT" operation="process" inputVariable="auctionData"&gt; &lt;/invoke&gt; &lt;receive name="receiveAuctionRegistrationInformation" partnerLink="auctionRegistrationService" portType="as:auctionRegistrationAnswerPT" operation="answer" variable="auctionAnswerData"&gt; &lt;/receive&gt; &lt;flow&gt; &lt;sequence&gt; &lt;assign&gt; &lt;copy&gt; &lt;from variable="sellerData" part="endpointReference"/&gt; &lt;to partnerLink="seller"/&gt; &lt;/copy&gt; &lt;/assign&gt; &lt;invoke name="respondToSeller" partnerLink="seller" portType="as:sellerAnswerPT" operation="answer" inputVariable="sellerAnswerData"/&gt; &lt;/sequence&gt; &lt;sequence&gt; &lt;assign&gt; &lt;copy&gt; &lt;from variable="buyerData" part="endpointReference"/&gt; &lt;to partnerLink="buyer"/&gt; &lt;/copy&gt; &lt;/assign&gt; &lt;invoke name="respondToBuyer" partnerLink="buyer" portType="as:buyerAnswerPT" operation="answer" inputVariable="buyerAnswerData"/&gt; &lt;/sequence&gt; &lt;/flow&gt; &lt;/sequence&gt; &lt;/process&gt; As we could see in Figure <ref type="figure">5</ref>, the business process is transformed into six automata. (This figure is taken as a snapshot of Uppaal.) We can easily simulate the running of the process, which gives an intuitional view of the whole model. Also we can verify properties stated in CTL. Firstly, we verify whether it is possible for the workflow to be finished within given time:</p><p>prop1 : E &lt;&gt; Main.e and global x &lt; 40 This CTL expression states that there exists a trace in which automaton Main eventually reaches ending state and the time consumed is less than 40 time units. The verification result shows it is true. If we change the latter part of the expression to global x &lt; 5, then Uppaal returns "Property not satisfied".</p><p>Secondly, we verify that whether the workflow can always be finished within a given time:</p><p>prop2 : A[] global x&gt;50 imply Main.e This property is stronger than the previous one. prop1 can be used to detect the minimum time needed for the workflow to complete, while prop2 is used to detect the maximum time needed.</p><p>Thirdly, we can verify if every participant will eventually receive an answer after sending a request:</p><p>prop3a: A[] (buyerprovide imply A&lt;&gt; buyeranswer) prop3b: A[] (sellerprovide imply A&lt;&gt; selleranswer) As expected, these expressions are true. The variables like "buyerprovide" are boolean variables that are assigned to true when the corresponding channels are synchronized.</p><p>We have implemented a mapping tool in Java language. The user only needs to give a BPEL4WS XML file as its input, then the tool will automatically convert it into timed automata, and output a file in Uppaal's XML format. The user can then use Uppaal to simulate the running process, and model-check various properties they need.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>This paper presents an operational semantics of μ-BPEL which is a simplified version of BPEL4WS. A formal mapping from μ-BPEL to timed automata is presented and the correctness of the transformation is ensured by the simulation relation proved. After the transformation, we can simulate the run of the processed, and verify time-related properties in model checker Uppaal. The experiments results show that the verification method is quite effective and can check many interesting kinds of safety properties.</p><p>One of the future work may be adding more language characters of BPEL4WS to μ-BPEL, although we have developed a semantic model handling the compensation in BPEL4WS <ref type="bibr" target="#b20">[21]</ref>. Besides, we want to to investigate further the verification problem as well.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. skip, assign, invoke/reply, receive, wait, waitill</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. sequential composition, loop, if-else, external choice</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>true, τ, ∅)} " b * P " P.S ∪ {i, e}, i, e, P.C, P.V, P.X, P.E∪ {(i, P.i, b, τ, ∅), (i, e, !b, τ, ∅), (P.e, i, true, τ, ∅), } " P ¡ b £ Q " P.S ∪ Q.S ∪ {i, e}, i, e, P.C ∪ Q.C, P.V ∪ Q.V, P.X ∪ Q.X, P.E ∪ Q.E ∪ {(i, P.i, b, τ, ∅), (i, Q.i, !b, τ, ∅), (P.e, e, true, τ, ∅), (Q.e, e, true, τ, ∅)} " c1 → P [] c2 → Q " P.S ∪ Q.S ∪ {i, e}, i, e, P.C ∪ Q.C ∪ {c1, c2}, P.V ∪ Q.V, P.X ∪ Q.X, P.E ∪ Q.E ∪ {(i, P.i, true, c1?, ∅), (i, Q.i, true, c2?, ∅), (P.e, e, true, τ, ∅), (Q.e, e, true, τ, ∅)} " b {lt1, lt2} • P " P.S ∪ {i}, i, P.e, P.C, P.V, P.X, P.E ∪ {(i, P.i, b, τ, ∅)} " P • {ls1 b1, ls2 b2} " P.S ∪ {e}, P.i, e, P.C, P.V, P.X, P.E∪ {(P.e, e, true, τ, {ls1 → b1, ls2 → b2})} "</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Web services; Target and source links; flow body and an activity in the flow</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>W ebServices = {ws}, ws, ws, ∅, ∅, ∅, Edges Edges = Receives ∪ Replies ∪ Invokes Invokes = {(ws, ws, true, plop?, ∅) | i = 1..n inv } Replies = {(ws, ws, true, plop?, ∅) | i = 1..n rep } Receives = {(ws, ws, true, plop!, ∅) | i = 1..n rec }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Optimization f begin and f end to it, as shown in the last automaton of Figure 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Definition 4 . 1 A</head><label>41</label><figDesc>binary relation S ∈ BP ×ET A over the two configurations is a simulation if it satisfies the following conditions:1. { bp, ta | Π 1 (bp) = ∧ Π 1 (ta) = e ∧ Π 2 (bp) = Π 3 (ta)\CV } ∈ S 2.If bp, ta ∈ S and bp λ =⇒ bp , implies there exists ta , such that ta λ =⇒ ta and bp , ta ∈ S, where λ , λ∈ Action ∪ {δ} ∪ {τ } Π i denotes the projection function on the configuration with i part, and CV is the extra control variable set introduced in ETA.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="17,86.29,62.61,299.86,213.35" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>We are grateful to Prof. He Jifeng for helpful discussions and suggestions for the improvement of the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Analysis of web services composition languages: The case of BPEL4WS</title>
		<author>
			<persName><forename type="first">W</forename><surname>Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hofstede</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wohed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ER&apos;03</title>
		<title level="s">LNCS</title>
		<meeting>of ER&apos;03</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2813</biblScope>
			<biblScope unit="page" from="200" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A theory of timed automata</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="page" from="183" to="235" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Petri net-based model for web service composition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Benatallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hamadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ADC&apos;03</title>
		<meeting>of ADC&apos;03</meeting>
		<imprint>
			<publisher>Australian Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="191" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">UPPAAL -a tool suite for automatic verification of real-time systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bengtsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Larsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems III: Verification and Control</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="232" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Formalizing web services choreographies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Brogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Canal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pimentel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vallecillo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Prof. of WS-FM&apos;04</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>To appear as ENTCS</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An operational semantics for StAC, a language for modelling longrunning business transactions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Coordination&apos;04</title>
		<title level="s">LNCS</title>
		<meeting>of Coordination&apos;04</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2949</biblScope>
			<biblScope unit="page" from="87" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Precise Modelling of Compensating Business Transactions and its Application to BPEL</title>
		<author>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muan</forename><forename type="middle">Y N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Journal of Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Theoritical Foundations for Compensation in Flow Composition Languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Melgratti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM POPL&apos;05</title>
		<meeting>of ACM POPL&apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><surname>Bpel4ws</surname></persName>
		</author>
		<ptr target="http://www.siebel.com/bpel" />
		<title level="m">Business Process Execution Language for Web Service</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Timed Patterns: TCOZ to Timed Automata</title>
		<author>
			<persName><forename type="first">Jin</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ping</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shengchao</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICFEM&apos;04</title>
		<meeting>of ICFEM&apos;04</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="483" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Analysis of interacting BPEL web services</title>
		<author>
			<persName><forename type="first">X</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bultan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of WWW&apos;04</title>
		<meeting>of WWW&apos;04</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="621" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Salem</surname></persName>
		</author>
		<author>
			<persName><surname>Sagas</surname></persName>
		</author>
		<title level="m">Proc. of ACM SIGMOD&apos;87</title>
		<meeting>of ACM SIGMOD&apos;87</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="249" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Unifying Theories of Programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">He</forename><surname>Jifeng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Guided Synthesis of Control Programs Using UPPAAL</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pttersson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Workshop on verification and Control of Hybrid Systems III</title>
		<meeting>of Workshop on verification and Control of Hybrid Systems III</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>ppE15-E22</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Modelling and verifying web service orchestration by means of the concurrency workbench</title>
		<author>
			<persName><forename type="first">M</forename><surname>Koshkina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Breugel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGSOFT Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Leymann</surname></persName>
		</author>
		<ptr target="http://www-3.ibm.com/software/solutions/webservices/pdf/WSDL.pdf" />
		<title level="m">WSFL: Web Serices Flow Language</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Nested Transactions: An Approach to Reliable Distributed Computing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dept. of Electrical Eng. and Computer Sci</title>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
	<note>MIT</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Model-Checking Verification for Reliable Web Service</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nakajima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2002 Workshop on Object-Oriented Web Services</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An Optimal Approach to Hardware/Software Partitioning for Synchronous Model</title>
		<author>
			<persName><forename type="first">Pu</forename><surname>Geguang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dang</forename><surname>Van Hung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jifeng</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IFM&apos;04</title>
		<meeting>of IFM&apos;04</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="363" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Towards the semantics and verification of BPEL4WS</title>
		<author>
			<persName><forename type="first">Pu</forename><surname>Geguang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhao</forename><surname>Xiangpeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Shuling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiu</forename><surname>Zongyan</surname></persName>
		</author>
		<ptr target="http://www.math.pku.edu.cn:8080/printdoc/585.pdf" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Peking University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technique Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Semantics of BPEL4WS-like Fault and Compensation Handling</title>
		<author>
			<persName><forename type="first">Qiu</forename><surname>Zongyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Shuling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pu</forename><surname>Geguang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhao</forename><surname>Xiangpeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FM2005</title>
		<meeting>of FM2005</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-07">2005.7</date>
			<biblScope unit="volume">3582</biblScope>
			<biblScope unit="page" from="350" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">XLANG: Web Service for Business Process Design</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thatte</surname></persName>
		</author>
		<ptr target="http://www.gotdotnt.com/team/xmlwsspecs/xlang-c/default.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Transforming BPEL into annotated deterministic finite state automata for service discovery</title>
		<author>
			<persName><forename type="first">A</forename><surname>Wombacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fankhauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Neuhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICWS&apos;04</title>
		<meeting>of ICWS&apos;04</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
