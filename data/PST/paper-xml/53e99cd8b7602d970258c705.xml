<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Describing Software Architecture Styles Using Graph Grammars</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Daniel</forename><surname>Le Métayer</surname></persName>
							<email>lemetayer@irisa.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">IRISA/INRIA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35042</postCode>
									<settlement>Rennes, Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IRISA/INRIA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35042</postCode>
									<settlement>Rennes, Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Describing Software Architecture Styles Using Graph Grammars</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E0DB8726D15754C2B953CEA0F4F0124B</idno>
					<note type="submission">received 14 Aug. 1997; revised 20 Feb. 1998. Recommended for acceptance by D. Garlan.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Coordination</term>
					<term>graph rewriting</term>
					<term>software architecture</term>
					<term>static verification</term>
					<term>views</term>
					<term>refinement</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We believe that software architectures should provide an appropriate basis for the proof of properties of large software. This goal can be achieved through a clearcut separation between computation and communication and a formal definition of the interactions between individual components. We present a formalism for the definition of software architectures in terms of graphs. Nodes represent the individual agents and edges define their interconnection. Individual agents can communicate only along the links specified by the architecture. The dynamic evolution of an architecture is defined independently by a "coordinator." An architecture style is a class of architectures specified by a graph grammar. The class characterizes a set of architectures sharing a common communication pattern. The rules of the coordinator are statically checked to ensure that they preserve the constraints imposed by the architecture style.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION-MOTIVATION AND APPROACH</head><p>OFTWARE systems tend to grow in size and complexity; they are often developed through a long period of time and become extremely difficult to understand and to maintain. The cost incurred by this complexity is becoming a serious concern and a major challenge today is to provide ways of organizing software in order to make large applications manageable and to favor the reuse of existing products. Several languages or systems have been proposed recently to tackle these problems: they are called software architecture languages <ref type="bibr" target="#b13">[13]</ref>, configuration languages <ref type="bibr" target="#b20">[20]</ref>, or coordination languages <ref type="bibr" target="#b6">[6]</ref>, <ref type="bibr" target="#b15">[15]</ref>. Despite some differences of emphasis, these works share a common point of view: The definition of a software application should make a clear distinction between individual components and their interaction in the overall software organization.</p><p>Several authors <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b18">[18]</ref>, <ref type="bibr" target="#b29">[29]</ref> have emphasized the importance of a framework for the formal definition of software architectures. Not only is it a prerequisite for a rigorous analysis of architectures, but it also increases their usefulness and reusability by removing the sources of ambiguity which are unavoidable in informal descriptions. Another major requirement for a software architecture model is its ability to express standard software design choices in a natural way. The common practice of software engineers is to represent architectures informally as "box and line" drawings <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b19">[19]</ref>. Starting from this observation, we propose to define software architectures formally in terms of graphs, which constitute the mathematical model closest to the intuition conveyed by "box and line" drawings. The nodes of the graph represent the individual entities which can themselves be described in conventional programming languages. An entity can be a procedure, a module, a process, etc. depending on the underlying programming language and the level of granularity of the architecture. The edges correspond to the communication links between entities. An architecture style is a class (or set) of architectures exhibiting a common shape. For example: are two architectures of a style "pipeline" (with e i representing entity names and S directed links between entities). Technically, architecture styles are defined as context-free graph grammars.</p><p>The architecture can be seen as the skeleton of an application. In order to be executable, it must be "fleshed out," or completed with a mapping from nodes to entities defined in a given language. This complete description is called an architecture instance. The specification of the computation of an architecture instance mirrors its hierarchical organization:</p><p>• The evolution of the local states of the entities follows the rules of the operational semantics of their programming language. • A "coordinator" is used to pilot the overall application.</p><p>The coordinator is in charge of managing the architecture itself (creating and removing entities and links).</p><p>Entities involve two kinds of variables: private variables, which are not visible from outside, and public variables, which can be read (but not modified) by the coordinator. The coordinator is expressed in terms of conditional graph rewriting <ref type="bibr" target="#b11">[11]</ref>, <ref type="bibr" target="#b30">[30]</ref>. The conditions bear on the public variables of the entities and represent the only possible interactions between a coordinator and the individual components (apart from the creation and destruction of links and entities).</p><p>The architecture style can be seen as the "type" (or form) that the architecture must have at run time, that is to say the possible interconnections between its individual components. This description is comprehensive, which means that two components can communicate only through the links specified by the style. This is a relevant piece of information in itself (for example, to check confidentiality properties like noninterference), but it is also a prerequisite to prove most interesting properties of distributed systems (like deadlock freeness).</p><p>The standard way to describe distributed systems is to resort to traditional sequential programming languages enhanced with facilities for defining processes and communications (possibly through operating system procedure calls). On the other hand, specification languages like CSP <ref type="bibr" target="#b14">[14]</ref>, and the π-calculus <ref type="bibr" target="#b26">[26]</ref> provide powerful and integrated constructions for parallelism and synchronization. None of these approaches makes it easy to extract the underlying communication topology from the application. As an illustration, <ref type="bibr" target="#b25">[25]</ref>, <ref type="bibr" target="#b28">[28]</ref> propose sophisticated analyses to derive information about the topology of CSP and CML programs. We believe that a better basis for mastering large software systems is to ensure that they respect the desired topology and properties by construction rather than trying to try to prove it a posteriori.</p><p>Among the benefits of our approach, let us mention the following:</p><p>• It makes it possible to reconcile a dynamic view of the architecture, which is crucial for a large class of applications, with the possibility of static checking, ensuring that the evolution of the architecture conforms to its style. This verification can be seen as a form of static type checking of the coordinator (the type being the graph grammar defining the architecture style). In our framework, this amounts to a proof of convergence of graph rewrite rules.</p><p>• It provides a high-level view of software systems which is both intuitive and formally based. On one hand, graphs are commonly used as informal means to convey the general organization of an application. On the other hand, their formal definition and the clean separation between the computation of the individual entities and their coordination make it easier to check global properties of the system. In particular, properties about the information flows in an application can be derived from the architecture style. This is of prime importance to be able to enforce the requirements imposed by a given security policy (confidentiality, integrity).</p><p>The presentation of the paper follows this two-level decomposition. In the next section, we introduce our view of architectures as graphs and architecture styles as graph grammars. Section 3 defines coordination as conditional graph rewriting and describes an algorithm for the static checking of a coordinator with respect to a given style. Sections 2 and 3 are independent of the definition of the atomic components of the architecture. In Section 4, we complete the picture with a language for programming the individual entities. We provide a structural operational semantics of this language and we show how it cooperates with the semantics of coordination.</p><p>We use the "client-server" model as a case study throughout the paper. Following the top-down presentation of the material, the client-server architecture style itself is introduced in Section 2; a first version of the coordinator is presented in Section 3 and the complete application is described in Section 4 (Fig. <ref type="figure" target="#fig_2">1</ref>). A second example is presented in Section 5 (a distributed hospital ward monitoring system inspired by <ref type="bibr" target="#b20">[20]</ref>, <ref type="bibr" target="#b16">[16]</ref>). In Section 6, we relate our approach to previous work in this area. We conclude in Section 7 with a sketch of several avenues for further research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">ARCHITECTURE STYLES</head><p>Our notion of graphs is inspired by previous work on the chemical reaction model <ref type="bibr" target="#b3">[3]</ref>, <ref type="bibr" target="#b4">[4]</ref>, <ref type="bibr" target="#b11">[11]</ref> and set-theoretic graph rewriting <ref type="bibr" target="#b30">[30]</ref>. Formally, a graph is a set of relation tuples noted R(e 1 , …, e n ) where R is a n-ary relation name and e i are entity names (we assume appropriate countable sets of names). We consider only binary and unary relations here. In our context, a binary relation L(e 1 , e 2 ) represents a directed link of name L between e 1 and e 2 . A unary relation U(e) characterizes the role of an entity e in the architecture. As an illustration, the following (unconnected) graph represents an example of a client-server architecture.</p><p>Unary relations are represented by circles and binary relations by arrows. C, S, M, and X correspond, respectively, to client, server, manager and external entities. The external entity stands for the external world; it records requests for new clients wanting to be registered in the system. CR and CA correspond to client request links and client answer links, respectively (SR and SA are the dual links for servers). The architecture represented by the above graph involves two clients c 1 and c 2 , two servers s 1 and s 2 , a manager m 0 and x 0 . It is formally defined as the set ∆:</p><formula xml:id="formula_0">{CR(c 1 , m 0 ), CA(m 0 , c 1 ), C(c 1 ), CR(c 2 , m 0 ), CA(m 0 , c 2 ), C(c 2 ), SR(m 0 , s 1 ), SA(s 1 , m 0 ), S(s 1 ), SR(m 0 , s 2 ), SA(s 2 , m 0 ), S(s 2 ), X(x 0 ), M(m 0 )}</formula><p>It should be clear that ∆ is just one particular representative of a more general class of client-server architectures. Architectures belonging to this class must include values X(x 0 ) and M(m 0 ) and any number of servers and clients. Furthermore, they must follow the communication link pattern exhibited by ∆. We propose to specify such a class as a context-free graph grammar. Different notions of context-free graph grammars have been studied in the literature. They are defined either in terms of node replacement <ref type="bibr" target="#b10">[10]</ref> or in terms of hyperedge replacement <ref type="bibr">[7]</ref>. Graph rewriting is also used in <ref type="bibr" target="#b9">[9]</ref> as a model for distributed systems, but a dual approach is taken, with hyperedges representing processes and nodes representing ports (also the process rewrite rules are essentially used to model synchronization requirements).</p><p>Our definition of graphs as sets allows us to express hyperedge replacement in a very natural way. A grammar is a 4-tuple [NT, T, PR, AX] where NT and T are sets of nonterminal and terminal symbols (each one with a given arity), PR is a finite set of production rules and AX a specific nonterminal called the axiom (the origin of the derivation). Terminal symbols correspond to the relations of the architecture. The production rules are pairs (l, r) where l is a singleton {A(x 1 , …, x i )} (with A a nonterminal of arity i) and r is a set of terms B(y 1 , …, y j ) with B ∈ NT ʜ T.</p><p>Continuing our example, the client-server architecture style is defined as:</p><formula xml:id="formula_1">H CS = [{CS, CS 1 }, {M, X, C, S, CR, CA, SR, SA}, R, CS]</formula><p>with R the following set of rules (we use the concrete syntax Left ⇒ Right to represent a pair ({Left}, {Right}):</p><formula xml:id="formula_2">CS ⇒ CS 1 (m) (1) CS 1 (m) ⇒ CR(c, m), CA(m, c), C(c), CS 1 (m) (2) CS 1 (m) ⇒ SR(m, s), SA(s, m), S(s), CS 1 (m) (3) CS 1 (m) ⇒ M(m), X(x)<label>(4)</label></formula><p>Note that, following our terminology, client-server is an architecture style, not an architecture. An architecture is a specific element of the style with a given number of clients and servers.</p><p>1 Formally, a graph grammar H = [NT, T, PR, AX] defines a rewrite system → H between sets:</p><formula xml:id="formula_3">M → H M′ ⇔ M′ = M -m l + m r</formula><p>with the following conditions:</p><formula xml:id="formula_4">1) m l ⊆ M 2) ( ( ) ( )) ( ) N m N m N M O e r</formula><p>e l e -=/ ʝ 3) m l = σ l, m r = σ r, with σ an injective substitution and (l, r) ∈ PR.</p><p>The intuition is that M′ is obtained from M by removing elements (m l ) matching the left-hand side of a rule of PR and adding the corresponding right-hand side (m r ). The substitution σ maps variables to entity names. N e (M) is the set of entity names occurring in the set M. The second condition ensures that new variables occurring in the righthand side of a rule are instantiated with entity names that are distinct from all other existing names. This constraint, which is usual in graph rewriting <ref type="bibr" target="#b30">[30]</ref>, is necessary to avoid unexpected variable sharing. It is crucial in our context to stick to our choice to specify exactly the actual connections between entities. 2 As an illustration of this constraint, the name associated with variable c in the right-hand side of</p><formula xml:id="formula_5">CS 1 (m) ⇒ CR(c, m), CA(m, c), C(c), CS 1 (m) 1.</formula><p>Obviously clients and server should be able to enter or quit the system during its execution: this is what we call the evolution of the architecture, which is defined by the coordinator.</p><p>2. The impact of ignoring this constraint would be a different interpretation of the definition of a style, which would then specify the minimal (rather than the exact) set of connections in an architecture. For example, in the client-server architecture, nothing would then prevent an entity from playing both the role of a client and a server.</p><p>should not occur anywhere else in the set to preclude the existence of additional links to a client c in the architecture. The injectivity of σ is required for the same reason. A noninjective substitution could map different variables onto the same name, entailing a considerable loss of precision in the specification of the topology associated with a style.</p><p>The style defined by a grammar H = [NT, T, PR, AX] is the set of all terminal graphs (graphs containing only terminal relation symbols) produced by → H rewritings:</p><formula xml:id="formula_6">Class H G AX G G H ( ) { |{ } and terminal} * = →</formula><p>As an illustration, we show that the graph ∆ defined above belongs to the client-server class, that is to say ∆ ∈ Class(H CS ). We use → CS to denote the rewrite system defined by H CS and we apply the rules of H CS in the following order: (1), (2) twice, (3) twice, and (4).</p><formula xml:id="formula_7">{CS} → CS {CS 1 (m 0 )} → CS {CR(c 1 , m 0 ), CA(m 0 , c 1 ), C(c 1 ), CS 1 (m 0 )} → CS {CR(c 1 , m 0 ), CA(m 0 , c 1 ), C(c 1 ), CR(c 2 , m 0 ), CA(m 0 , c 2 ), C(c 2 ), CS 1 (m 0 )} → CS {CR(c 1 , m 0 ), CA(m 0 , c 1 ), C(c 1 ), CR(c 2 , m 0 ), CA(m 0 , c 2 ), C(c 2 ), SR(m 0 , s 1 ), SA(s 1 , m 0 ), S(s 1 ), CS 1 (m 0 )} → CS {CR(c 1 , m 0 ), CA(m 0 , c 1 ), C(c 1 ), CR(c 2 , m 0 ), CA(m 0 , c 2 ), C(c 2 ), SR(m 0 , s 1 ), SA(s 1 , m 0 ), S(s 1 ), SR(m 0 , s 2 ), SA(s 2 , m 0 ), S(s 2 ), CS 1 (m 0 )} → CS {CR(c 1 , m 0 ), CA(m 0 , c 1 ), C(c 1 ), CR(c 2 , m 0 ), CA(m 0 , c 2 ), C(c 2 )</formula><p>SR(m 0 , s 1 ), SA(s 1 ,m 0 ), S(s 1 ), SR(m 0 , s 2 ), SA(s 2 , m 0 ), S(s 2 ),</p><formula xml:id="formula_8">X(x 0 ), M(m 0 )} = ∆</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">COORDINATION</head><p>As mentioned in the introduction, it is often the case that the architecture of an application should be able to evolve dynamically. For instance, a client-server organization must allow for the introduction of new clients or their departure, a pipeline may grow or shrink, facilities for dealing with mobile computing may be required. In our framework, the evolution of the architecture is defined by a coordinator. The task of the coordinator is expressed by conditional graph rewrite rules in the style of <ref type="bibr" target="#b3">[3]</ref>, <ref type="bibr" target="#b4">[4]</ref>, <ref type="bibr" target="#b11">[11]</ref>. The semantics of the rules is similar to the definition used above for the rewrite system associated with graph grammars, except that we may have additional side conditions in coordination rules. These conditions bear on the local states of the individual entities; they do not play any role at this stage, so we do not consider them until the next section.</p><p>As an illustration, we introduce the following coordinator Coo CS which applies to a client-server architecture:</p><formula xml:id="formula_9">X x M m X x M m CR c m CA m c C c CR c m CA m c C c O ( ), ( ) ( ), ( ),<label>( , ), ( , ), ( ) ( , ), ( , ), ( ) → ′</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>→ /</head><p>The two rules describe, respectively, the introduction of a new client in the architecture and its departure. Note that these rules are completed with side conditions on the states of the entities in the complete version of the coordinator presented in the Section 4 (Fig. <ref type="figure" target="#fig_2">1</ref>); otherwise, the coordinator could add or remove entities without any consideration of the current state of the system, which is obviously not the intended behavior. The possibility of expressing architecture transformations is definitely a useful feature but it also raises a new question: Is it possible to ensure that a coordinator does not break the constraints of a given architecture style? For example, had we forgotten, say CR(c, m) in the right-hand side of the first rule, then the coordinator would have been able to transform a client-server architecture into an architecture which would not belong any longer to the clientserver class defined by H CS . What is needed is a static style checker which would be the counterpart for coordinators of the type checking algorithms of classical languages.</p><p>In order to define a checking algorithm for a given style</p><formula xml:id="formula_10">H = [NT, T, PR, AX]</formula><p>we first consider the graph rewrite system → -H</p><p>1 obtained by a right-to-left reading of the rules in PR (with the appropriate dual restrictions on variables appearing only on the right-hand side of a rule). Obviously, if G is a graph be-</p><formula xml:id="formula_11">longing to the style H, then G AX H → - * { } 1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The coordinator</head><p>Coo defines a second graph rewrite relation → Coo and the checking algorithm must ensure that for all G, we have:</p><formula xml:id="formula_12">G AX G G G AX H Coo H → → ′ ⇒ ′ → - - * * { } and { } 1 1</formula><p>which means that if a graph G belongs to the style H (which</p><formula xml:id="formula_13">is expressed by G AX H → - * { } 1</formula><p>) and G can be transformed into <ref type="figure"></ref>and<ref type="figure">C</ref> → C′ is the instantiation of a rule of the coordinator. The checking algorithm is based on the observation that</p><formula xml:id="formula_14">G′ by Coo (that is to say G → Coo G′), then G′ also belongs to the style H (thus ′ → - G A X H * { } 1 ). The relation G → Coo G′ holds if G = M + C, G′ = M + C′,</formula><formula xml:id="formula_15">any reduction chain M C AX H + → - * { } 1 can be reorganized as M C X C AX H H + → + → - - * * 1 { } 1 where • No element of C is involved in the reduction chain M C X C H + → + - * 1 . • Each reduction of X C AX H + → - * { } 1 involves at least one element of a residual of C. A residual of C is either C or the result of a rewriting involving one element of a residual of C. The intuition is that M C X C H + → + - * 1</formula><p>gathers all the reduction steps that do not depend on C and X C AX</p><formula xml:id="formula_16">H + → - * { } 1</formula><p>contains only the steps depending on C. This reorganization is possible because it involves independent reduction steps.</p><p>The algorithm proceeds in two phases. The first phase consists in computing a representation of all the possible contexts X for each left-hand side C of a coordination rule C → Coo C′. The contexts X can be derived from C = C 0 by considering all the possible reductions of the following form: </p><formula xml:id="formula_17">X C C X C C X C AZ o o H i H n n H + → + → + → - - - * { } 1 1 1 1 2 1 L ( ) Each step</formula><formula xml:id="formula_18">tion rule. Let X = X n + L + X 0 then X C X X C X X C A X n H n H H + = + + + → + + + → → - - - L L L 0 1 1 1 1 1 { } so X C AX H + → -1 * { }.</formula><p>The contexts X are obtained through the construction of a reduction graph gathering all possible reductions chains of the form ( ). The origin of the reduction graph is C and the terminal node is {AX}. The internal nodes are the residuals</p><formula xml:id="formula_19">C i and a transition X C C i i H i + → - + 1 1 is represented by an edge C C i X i i → +1 .</formula><p>The basic contexts X i are computed by constructing all the possible superpositions (nonempty intersections) of C i with left-hand sides of → -H</p><p>1 rules. For example, there is only one superposition between</p><formula xml:id="formula_20">C i = CR(c, m), CA(m, c), C(c)</formula><p>and the left-hand side of the rule:</p><formula xml:id="formula_21">CR c m CA m c C c CS m CS m CS ( , ),<label>( , ), ( ), ( ) ( ) 1 1 1</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>→</head><p>which is C i itself and the associated basic context X i is CS 1 (m). To ensure termination, we consider residuals C i up to renaming of variables. So, instead of adding a new node for a term C i that is isomorphic to an already existing node ′ C i , we introduce an edge to ′ C i . This technique may lead to the introduction of cycles in the reduction graph. However, the construction of the reduction graph always terminates because the reductions cannot increase the size of a term and the number of terms of a given size is finite (up to variable renaming). "Impossible contexts" (contexts which cannot lead to the axiom AX), are removed during the course of this process for a better precision of the analysis.</p><p>The second phase of the algorithm consists in checking the property</p><formula xml:id="formula_22">X C AX H + ′ → - * { } 1</formula><p>for all the possible contexts X = X 0 + … + X n . This is because</p><formula xml:id="formula_23">M C AX H + → - * { } 1 if and only if M C X C AX H H + → + → - - * * { } 1 1</formula><p>and, since the first phase of the derivation does not depend on C, we then have</p><formula xml:id="formula_24">M C X C H + ′ → + ′ - * 1</formula><p>and, therefore,</p><formula xml:id="formula_25">X C AX H + ′ → - * { } 1 implies M C AX H + ′ → - * { } 1 .</formula><p>But the number of possible contexts X is unbounded, which is manifested by the possibility of cycles in the reduction graph. To get a terminating algorithm, we have to make conservative approximations (it is shown in <ref type="bibr" target="#b11">[11]</ref> that the general problem is undecidable). For every path with con-</p><formula xml:id="formula_26">text X = X 0 + … X i-1 from the root to a residual C i belonging to a cycle, we check that X C C H i + ′ → - * 1</formula><p>. This algorithm can in fact be improved by removing redundant loops, that is to</p><formula xml:id="formula_27">say edges C C i X i i → such that X X X i j H j + → - * 1</formula><p>with X j the context associated with an edge on a path leading to C i. .</p><note type="other">3</note><p>The correctness of the algorithm is proven in <ref type="bibr" target="#b11">[11]</ref>. As an illustration, let us apply it to check the coordinator Coo CS presented above with respect to the client-server architecture style. From the definition of the CS style in Section 2, the rewriting rules for → -CS 1 are the following:</p><formula xml:id="formula_28">CS m CS R CR c m CA m c C c CS m CS m R SR m s SA s m S s CS m CS m R M m X x CS m R CS CS CS CS 1 1 1 1 1 1 2 1 1 1 3 1<label>1 4 ( ) ( ) ( , ), ( , ), ( ), ( ) ( ) ( ) ( , ), ( , ), ( ), ( ) ( ) ( )</label></formula><formula xml:id="formula_29">( ), ( ) ( ) ( ) → → → → - - - -</formula><p>The first rule of Coo CS is:</p><formula xml:id="formula_30">X(x), M(m) → X(x′), M(m), CR(c, m), CA(m, c), C(c)</formula><p>The origin of the reduction graph is thus {X(x), M(m)}.</p><p>There is only one superposition of X(x), M(m) with lefthand sides of → -CS 1 , , namely X(x), M(m) itself (rule R 4 ). The basic context X 0 is thus empty and the first edge in the reduction graph is:</p><formula xml:id="formula_31">{ ( ), ( )} { ( )} X x M m CS m → / 0 1 .</formula><p>There are three superpositions of {CS 1 (m)} with left-hand sides of → -CS 1 , the three of them being equal to {CS 1 (m)} itself (because {CS 1 (m)} is included in the left-hand sides of R 1 , R 2 , and R 3 ). R 1 leads to the axiom {CS}, so the edge</p><formula xml:id="formula_32">{ ( )} { } CS m CS 1 0 → /</formula><p>is added to the graph. The label is / 0 because the left-hand side of R 1 is exactly {CS 1 (m)}. Rules R 2 and R 3 lead to {CS 1 (m)}, which is already a node in the graph. So, two looping edges are added in the graph from (and to) {CS 1 (m)} with labels equal to {CR(c, m), CA(m, c), C(c)} and {SR(m, s), SA(s, m), S(s)} which are the basic contexts for the application of R 2 and R 3 . This concludes the construction of 3. The justification for this simplification is that This edge comes from the superposition of CR(c, m), CA(m, c), C(c) with the right-hand side of R 2 , which requires the context {CS 1 (m)}. So {CS 1 (m)} is added to / 0 , which is the right-hand side of the rule of Coo CS and we obviously have</p><formula xml:id="formula_33">X j + X′ + C′ → - * H 1 C i im- plies X j + X i + X′ + C′ → - * H 1 C i .</formula><formula xml:id="formula_34">{ ( )} { ( )} * CS m CS m CS 1 1 1 → - .</formula><p>This concludes the verification that Coo CS is a correct coordinator with respect to the client-server style CS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ARCHITECTURE INSTANCES</head><p>We have presented architecture styles and architecture transformations without any assumption on the individual entities so far. This section completes the picture by introducing a small language for entities. We provide its formal definition in terms of a structural operational semantics and we show how it interacts with the actions of the coordinator.</p><p>The syntax of the language of entities is better introduced through the complete version of the client-server application in Fig. <ref type="figure" target="#fig_2">1</ref>. First note that the relations defining the links of the architecture are typed (and so are the variables they bear on). The basic types are names of entities (client, server, manager, external here). For instance, the type attached to CR specifies a link from a client entity to a manager entity. Each entity defines public and private variables, output and input links and entity names. The public variables can be checked (but not assigned) by the coordinator. The public variable v of an entity a is denoted by a.v in the definition of the coordinator. For example, the complete definition of Coo CS creates a new client only if the boolean variable newc of the entity x is true. A new instance x′ of the external entity is created in the same rule (which prevents the immediate reapplication of the rule). Similarly, clients use a public variable leave to indicate their intention to leave the system. The output and input links of the entities must conform to the edges of the architecture (this can be checked statically).</p><p>The commands of the language are very much in the spirit of CSP (*[] denoting the repetitive command and G → C a guarded command) except for the following generalisation: the semantics of input and output commands of the form a ∈ L ? v and a ∈ L ! E correspond to the establishment of a rendezvous with any entity a linked to the current entity through a link of name L. For example, the command c ∈ CR ? r of the manager m is matched with the command m ∈ CR ! r in any of the clients c i such that CR(c i , m) is an edge of the architecture. The effect of this communication is to assign c i to m.c in addition to the expected assignment of c i .r to m.r. This facility makes it possible for an entity to communicate with an unbounded number of other entities. 4 (without knowing their number or their name), relying only on the topology of the architecture. Commands of the form a : L ? v and a : L ! E are closer to the standard CSP rendezvous since the names of the partner entity is explicitly specified. This facility is necessary for an entity to realize a series of communications with the same partner: for instance, the manager must send the answer to the client which has issued the initial request. The complete syntax of the commands of the language of entities is the following:  A repetitive command terminates when each guard includes a false boolean condition. Note that we do not follow the original CSP convention indicating the termination of the repetitive command when all processes addressed in the input/output guards have terminated <ref type="bibr" target="#b14">[14]</ref>. This option would not make sense in our setting since, as explained above, a communication command may avoid naming the partner process explicitly and new processes and links can be added by the coordinator.</p><formula xml:id="formula_35">C v E skip C C Com G C G C G C G C Com H E H v H a L</formula><p>Let us now focus on the bottom part of Fig. <ref type="figure" target="#fig_3">2</ref> which defines the semantics of the coordinator and show how it fits with the semantics of the underlying language of entities. Global configurations are triples <ref type="bibr">[Coo, G, Val]</ref> where Coo is the set of conditional rewrite rules defining the coordinator, G is the graph representing the architecture and Val is a function mapping entity names onto local configurations (pairs &lt;C, S&gt;). The three rules defining the semantics of coordination correspond to the following cases:</p><p>• The first rule simply propagates at the level of global configurations the silent transitions of local configurations. • The second rule ensures proper matching of local transitions involving communications. • The third case is the transformation of the architecture according to a rule (l, r, c) of the coordinator: l and r stand, respectively, for the left-hand side and the right-hand side of a rule and c is the condition. The value of c is evaluated with respect to the local states of the entities: In the definition of V Val c σ ( , ), σ is used to get the entity name associated with a variable w, Val returns the local configuration of the corresponding entity, and ↑S extracts its store component. The names of N e (σ r) -N e (σ l) correspond to new entities created by the rule: their original configuration is the pair &lt;C i , Ќ&gt; where Ќ is the undefined store and C i is the body of the entity which constitutes the type of the new variable (remember that the relations defining links and their variables are typed with entities). As an illustration, the type of C in the client-server application is client which means that the occurrence of a new variable c in the first rule of Coo CS results in the creation of a new entity of type client and its initialisation with the undefined store.</p><p>In order to illustrate this semantics, we consider its application to the client-server architecture introduced in Section 2. We assume that the coordinator is Coo CS (as defined in Fig. <ref type="figure" target="#fig_2">1</ref> Applying similar rules to the body of the manager m 0 (with state S m 0 ), we get the following:</p><formula xml:id="formula_36">&lt; ∈ → &gt; → &lt; ∈ → &gt; * [ ? ] ,</formula><p>; An important observation concerning the process language described here is that it is very minimal indeed: it does not provide any facility for parallelism (no process creation, no parallel construct). This follows our original design choice of keeping a clear separation between the computation at the level of entities and the management of concurrency and communication at the level of the coordinator. We should emphasize however that what we have introduced in this section is just one example of a language of entities. As can be seen from the semantics of coordination (bottom of Fig. <ref type="figure" target="#fig_3">2</ref>), the only requirement concerning this language is to have a semantics defined in terms of a relation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LC LC</head><p>Com → ′ between local configurations. This fits with our view of introducing a clear separation between the description of the architecture (and its manipulation through the coordinator) and the definition of the individual entities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXAMPLE: A HOSPITAL WARD MONITORING SYSTEM</head><p>In Section 5, we illustrate our framework with another example, the distributed monitoring of a hospital ward system, that was used as a case study in <ref type="bibr" target="#b20">[20]</ref>, <ref type="bibr" target="#b16">[16]</ref>. The system consists of a number of nurses, beds and a secretary. Each nurse is in charge of a collection of beds and some of them are occupied by a patient. Nurses check the state of health of their patients regularly and decide when they are allowed to leave the hospital. Patients can also send an alarm to their nurse when their state becomes critical. The following graph represents a possible configuration with two nurses n 1 and n 2 . Nurse n 1 has two free beds f 1 and f 2 and one occupied bed b 1 . Nurse n 2 has one occupied bed b 2 and one free bed f 3 . Links C, R, L are used, respectively, for asking the state (e.g., temperature) of a patient, receiving his/her state and sending back the decision taken by the nurse (a boolean value indicating if the patient is allowed to leave the hospital). A is the alarm link, and E is used to connect a nurse with his/her free beds.</p><p>Fig. <ref type="figure" target="#fig_8">3</ref> shows the architecture style of the application, the coordinator and the programs defining the individual entities.</p><p>The intuition behind the definition of the grammar is the following:</p><p>• H ⇒ H 1 , S(s) imposes that the architecture includes a secretary S(s) without any link to other entities (because s is a new variable with a single occurrence in the rule). In contrast, the variable n is not new in the right-hand side of the rules defining H 2 and H 3 ; so, the recursive calls to H 2 (n) and H 3 (n) in their definitions ensure that all the occurrences of n in these calls refer to the same entity.</p><formula xml:id="formula_37">• H 1 ⇒ N(n), H 2 (n), H 3 (n),</formula><p>6</p><p>The secretary plays a role similar to the external entity in the client-server architecture. When its newp variable is set to true, the coordinator allocates a new patient to a nurse who has a bed available (first rule of the coordinator). To achieve this goal, the terminal F(f) corresponding to the free bed and the associated link E(n, f) are replaced by an occupied bed B(b) with the links required by the architecture (C(n, b), L(n, b), R(b, n), A(b, n)). The second rule of the coordinator is the inverse operation: It replaces bed B(b) whose patient is allowed to leave (b.leave = true) by a free bed F(f).</p><p>When receiving the temperature of a patient on the alarm link, a nurse takes an appropriate action (b ∈ A ? t → Action(b, t)). A nurse can also receive the temperature t of a patient upon request (b ∈ C ! true → b : R ? t) and use it to decide whether the patient is allowed to leave the hospital (b : L ! F(t)). The patient receives the decision and stores it in the public variable leave which is used by the coordinator to modify the architecture according to this decision. Otherwise, patients can also send their temperature on the alarm link when a given condition</p><formula xml:id="formula_38">Cond 2 is satisfied ((¬ leave ∧ Cond 2 ) → n ∈ A ! t) or remain quiet ((¬ leave ∧ Cond 1 ) → C 1 ).</formula><p>Free beds are inactive entities and the associated program body is the skip command.</p><p>We now apply the checking algorithm described in Section 3 to the coordinator Coo H of the hospital ward application. Since the values of entity variables do not play any role in the verification process, the checking algorithm starts with</p><formula xml:id="formula_39">lhs 1 = {N(n), S(s), F(f), E(n, f)}</formula><p>as the left-hand side of the first rule of Coo H . The reduction graph constructed for this term by the algorithm can be pictured as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>lhs N n S s H n H S s H</head><p>H n H n H  </p><formula xml:id="formula_40">1 3 1 3 2 1 → → → { ( )} { ( ), }<label>{</label></formula><formula xml:id="formula_41">{F(f ), E(n, f )} + {H 2 (n), N(n), H 3 (n), H 1 , S(s)} → - * { } H H 1</formula><p>It is also interesting to consider the behavior of the algorithm when applied to an incorrect coordinator. Let us imagine for example that the programmer has forgotten to remove a free bed when a new patient is allocated to a nurse. The first rule of the coordinator becomes:</p><formula xml:id="formula_42">N(n), S(s), s.newp = true → N(n), S(s′), B(b), E(n, f ) C(n, b), L(n, b) R(b, n), A(b, n)</formula><p>and we have:</p><formula xml:id="formula_43">lhs N n S s E n f ′ = 1 { ( ), ( ), ( , )}</formula><p>The first phase of the algorithm yields a unique context for lhs′ 1 :</p><formula xml:id="formula_44">{F(f ), H 3 (n), H 2 (n), H 1 }</formula><p>The second phase constructs the following derivation:</p><formula xml:id="formula_45">{N(n), S(s′), B(b), C(n, b), R(b, n), L(n, b), A(b, n)} + {F(f ), H 3 (n), H 2 (n), H 1 } → - * { ( ), } H F f H 1</formula><p>The derivation does not lead to H, the origin of the grammar and the bug is detected by the verification algorithm. Note that the result of the derivation also provides a useful hint about the origin of the bug since it contains F(f ), which is precisely the missing term in the right-hand side of the coordination rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK</head><p>The need for specific languages and formal frameworks for describing the overall organization of large software systems has triggered a considerable interest for software architectures and coordination languages during the last decade. Up-to-date surveys of formalisms and current trends can be found in <ref type="bibr" target="#b13">[13]</ref>, <ref type="bibr" target="#b31">[31]</ref>. In order to relate our contribution to previous work in this area, let us focus on two complementary issues: the formal models used to describe software architectures and the features provided by specific software architecture or coordination languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Formal Models</head><p>Among the formal frameworks used to specify software architectures, let us mention the specification language Z <ref type="bibr" target="#b0">[1]</ref>, CSP <ref type="bibr" target="#b1">[2]</ref>, the chemical abstract machine <ref type="bibr" target="#b18">[18]</ref>, the πcalculus <ref type="bibr" target="#b24">[24]</ref>, partial ordered sets of events <ref type="bibr" target="#b23">[23]</ref>, and firstorder logical theories <ref type="bibr" target="#b27">[27]</ref>. These formalisms have been extensively studied and their respective advantages have been identified: Z is a widely used state-based specification language which allows for a clean decomposition of applications into collections of schemas (in the context of software architectures, schemas can be components, connectors, configurations <ref type="bibr" target="#b0">[1]</ref>); CSP <ref type="bibr" target="#b14">[14]</ref> and the π-calculus <ref type="bibr" target="#b26">[26]</ref> are process algebras which highlight the concurrency and communication issues; the π-calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine <ref type="bibr" target="#b5">[5]</ref> is based on the chemical reaction metaphor <ref type="bibr" target="#b4">[4]</ref> which allows for a higher level of abstraction promoting parallelism as a basic computational model; the event-based structures of <ref type="bibr" target="#b23">[23]</ref> are well suited to the explicit representation of timing properties; the logical theories used in <ref type="bibr" target="#b27">[27]</ref> form the basis of a definition of a notion of architecture refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Software Architecture Languages</head><p>There is a great variety of needs for software architectures <ref type="bibr" target="#b31">[31]</ref> and this fact is reflected in the variety of papers published in this active area during the last few years. Aesop <ref type="bibr" target="#b12">[12]</ref> provides facilities for the design and graphical visualisation of architectures following the rules prescribed by specific styles. Architecture styles are defined in a generic object model and include the specification of a vocabulary and constraints on the connections between elements. Unicon <ref type="bibr" target="#b32">[32]</ref> supports a variety of components (such as "shared data," "filter," "sequential file") and connectors (such as "pipes," "remote procedure calls") which have been implemented and used as a testbed for experimenting system construction mechanisms. Other proposals put more emphasis on the dynamic aspects of the system, introducing a separation between the sequential computation of individual agents and their coordination expressed in a specific languages <ref type="bibr" target="#b6">[6]</ref>, <ref type="bibr" target="#b15">[15]</ref>, <ref type="bibr" target="#b20">[20]</ref>. In Linda <ref type="bibr" target="#b6">[6]</ref>, activities cooperate through a global tuple space using specific associative access primitives. The Conic environment <ref type="bibr" target="#b20">[20]</ref> provides a neat separation between individual tasks with explicit interfaces and a configuration level describing the overall application (which involves specifying the task components and establishing links between their ports). The Conic environment supports graphic tools for configuration programming and monitoring. Concoord <ref type="bibr" target="#b15">[15]</ref> introduces a notion of coordinator which is in charge of a collection of processes. A coordinator has access to the state variables of its processes and can test them to trigger the creation (or deletion) of processes and the binding (and unbinding) of ports.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Comparative Study</head><p>As far as formalization is concerned, our approach to software architectures is in the spirit of previous proposals based on process calculi like CSP <ref type="bibr" target="#b1">[2]</ref> or the π-calculus <ref type="bibr" target="#b26">[26]</ref>. On the other hand, our computational model based on a clean separation between individual entities and a coordinator is inspired by <ref type="bibr" target="#b15">[15]</ref> (but no formal model is provided for Concoord <ref type="bibr" target="#b15">[15]</ref> and a number of technical choices differ from our own approach).</p><p>The main departure of our contribution with respect to the above process calculi based proposals is the emphasis put on the geometry of the architecture (following the "box and line" drawing analogy), promoting it as an independent object. We believe that graph grammars provide a useful device for an intuitive and unambiguous understanding of the overall organization of a system and form a suitable basis for various analyses. We observe, for example, that any powerful proof technique for parallel languages must include some form of analysis to obtain information about the communication topology of the program. The difficulty of this task is illustrated in various papers <ref type="bibr" target="#b25">[25]</ref>, <ref type="bibr" target="#b28">[28]</ref>. Such analyses are not necessary following our approach because the topology is directly available from the specification of the architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CURRENT WORK AND PERSPECTIVES</head><p>As an illustration of the relevance of our approach for the analysis of nonfunctional properties, let us consider a simplified version of the well-known "Bell and LaPadula" security model <ref type="bibr" target="#b22">[22]</ref>. The following graph represents in our setting a small platform with two levels of confidentiality (Confidential and Secret with Confidential &lt; Secret). This example shows that software architectures can make it easier to prove certain properties of a system because they impose a particular organization making the relevant pieces of information explicit. But the designer of a software system usually has several, if not many, requirements to satisfy. As a consequence, he may want to use the architecture to serve as a basis for proving various sorts of properties. There is no reason however, why a single description of the architecture would be appropriate for each of these properties. Basically, the architecture is an abstraction of the software and there are many possible ways of abstracting a software. For this reason, we believe that the notion of architectural view <ref type="bibr" target="#b29">[29]</ref> is crucial. Ideally, a view should focus on one specific aspect of the software and it should be possible to show the coherence of different views of the same software. An example of a successful industrial model based on the notion of view is the 4 + 1 View Model introduced in <ref type="bibr" target="#b21">[21]</ref>. The five views are the logical view, the process view, the physical view, the development view and the scenarios which are used to illustrate the first four. Obviously graph grammars are not necessarily the best vehicle for expressing all these concerns, but preliminary work has been done to increase their expressive power through the notion of multiple views <ref type="bibr" target="#b17">[17]</ref>. The idea is to use a collection of grammars H 1 , …, H n rather than a single grammar as we have done here. Each grammar defines a style focusing one one specific aspect and each aspect of the software must satisfy the corresponding style to conform to the family. More formally, the class of architectures defined by the family of grammars H 1 , …, H n whose sets of terminals are, respectively, T 1 , … T n , is defined as follows: In other words, the conformance to a style in the family is considered only with respect to the set of terminals T i of the grammar H i defining it. Note that two grammars may share some terminals (we may have T i ʝ T j ≠ / O with i ≠ j). The interested reader can find in <ref type="bibr" target="#b17">[17]</ref> the treatment of an industrial case study proposed by the Signal company <ref type="bibr" target="#b8">[8]</ref> using the multiple views extension of the formalism suggested here. The goal of the work was the specification of a railway network system. The static verification of coordination rules with respect to the grammars was deemed the most attractive feature of the formalism <ref type="bibr" target="#b17">[17]</ref>. Among the limitations that were pointed out by this case study, let us mention:</p><p>• The difficulty of understanding the class of architectures that a grammar can produce: one solution to this problem would be to provide animation tools to display representative values of a class. • The restriction to context free graph grammars which precludes, for instance, the specification of a tree of entities with an unbounded number of levels and interactions between siblings. The square grid is another example of architecture that is out of reach of context free graph grammars. It is possible to extend our approach to context sensitive grammars but further work is needed to adapt our verification algorithm accordingly.</p><p>• The definition of coordinators as set rewriting rules prevents us from expressing global conditions on the architecture (like the absence of link between two given entities, or the existence of a specific (but non constant) number of entities. The local nature of set rewriting is an essential feature of the framework 7 and the verification algorithm presented here. The underlying motivation is that the expression of a computation as a set of local rules leads to more tractable semantics and reasoning techniques. An extension is suggested in <ref type="bibr" target="#b17">[17]</ref> to alleviate this limitation by integrating arithmetic computations within grammars.</p><p>Another important issue is the possibility of defining formally a notion of refinement between software architectures. We proposed in <ref type="bibr" target="#b11">[11]</ref> a refinement relation which corresponds to class containment and which can be checked statically on the rules of the graph grammar. This notion of refinement was used to optimize the implementation of parallel programs. We are now exploring its applicability to software architectures. There does not seem to be a single answer to this problem because different usages may put different requirements on the notion of refinement. For instance, security-related properties may be preserved through refinements corresponding to set inclusion (because removing links or entities decrease the global information flow), but this form of refinement may not be acceptable for functional properties (because removing links or entities may alter the services provided by the system).</p><p>The fact that very few constraints are imposed on the language used to define the individual entities naturally leads to considering the possibility of having different languages to program different entities. Our framework tackles the coordination problems only so far, and it should be complemented with an appropriate interface to manage the data conversions required to support interoperability. One natural solution would be to rely on the interface definition language of a standard platform like CORBA.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>the reduction graph for {X(x), M(m)} which can be pictured as follows:This graph shows the (infinite) set of all possible contexts of the term {X(x), M(m)} in the style. These contexts contain arbitrary numbers of clients and servers. Any path from the origin {X(x), M(m)} to the terminal node {CS} goes through {CS 1 (m)} which is a looping node. Furthermore, there is only one path from {X(x), M(m)} to {CS 1 (m)} with / 0 as a label. Since {X(x′), M(m), CR(c, m), CA(m, c), C(c)} is the right-hand side of the first rule of Coo CS , the only property to be checked is: in two rewrite steps: {X(x′), M(m), CR(c, m), CA(m, c), C(c)} → -CS CS m CR c m CA m c C c we forgotten, say CR(c, m) in the right-hand side of the coordination rule, then the last reduction would not have been possible and the verification would have failed. The second rule of Coo CS CR c m CA m c C c O ( , ), ( , ), ( ) → / is treated in a similar way. {CS 1 (m)} is again a looping node in the reduction graph and the only useful path in the graph is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>4 .</head><label>4</label><figDesc>Com, E, and B denote, respectively, commands, communication commands, expressions (of any type) and boolean expressions. In the definition of communication commands, L is a link symbol (declared in the out or in section) and a is an entity variable. Variables of arbitrary type are denoted by v. As in CSP, a guard G may be a boolean expression B, a communication command Com, or a combination of those (denoted (B, Com)).The semantics of the language is presented in the top part of Fig.2as a labeled transition system defining a relation LC LC Com → ′ on local configurations. A local configuration LC has the form &lt;C, S&gt;, with C a command and S a store. The expression Com in LC LC Com → ′ is the communication associated with the transition. As usual, the label ⑀ is used for silent transitions (transitions involving no communication). Sem [E] S is the semantics of expression E in store S and S[val/v] is the same as S except that variable v This is not possible in a language like CSP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The complete client-server application.</figDesc><graphic coords="6,24.60,61.50,251.52,537.79" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Semantics of the language of entities and coordination.</figDesc><graphic coords="7,33.41,61.50,245.85,492.01" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>B</head><label></label><figDesc>= s ∈ SR ! r ; s : SA ? a ; c : CA ! a Receive = c k : CR ? val. Since CR(c 1 , m 0 ) ∈ ∆, we can apply the second rule of the semantics of coordination (Fig. 2), unifying c k with c 1 , m j with m 0 , and val with Sem [r] S c 1 . We get [Coo CS , ∆, Val] ‫ۋ‬ [Coo CS , ∆, Val′] computation illustrates the relationship between the two levels of the semantics of Fig. 2. In order to show how the architecture itself can be modified by the coordinator, let us consider a further execution step when the client c 1 has completed its terminal command leave := true. Then, the second rule of the coordinator Coo CS can be applied (with c and m instantiated with, respectively, c 1 and m 0 ). The last rule of Fig. 2 allows us to derive: [Coo CS , ∆, Val"] ‫ۋ‬ [Coo CS , ∆′, Val"] with ∆′ = ∆ -{C(c 1 ), CR(c 1 , m 0 ), CA(m 0 , c 1 )}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>5 5 .</head><label>5</label><figDesc>The coordinator manages concurrency in the sense that it is in charge of creating (and stopping) concurrently executing entities.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Fig.3shows the architecture style of the application, the coordinator and the programs defining the individual entities.The intuition behind the definition of the grammar is the following:• H ⇒ H 1 , S(s) imposes that the architecture includes a secretary S(s) without any link to other entities (because s is a new variable with a single occurrence in the rule).• H 1 ⇒ N(n), H 2 (n), H 3 (n),H 1 shows that the style allows any number of nurses N(n), each one linked to a number of occupied beds and a number of free beds specified, respectively, by H 2 (n) and H 3 (n).</figDesc><graphic coords="8,351.89,435.64,125.01,144.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>→</head><label></label><figDesc>are not included in the graph following the optimization described in Section 3. From this graph, we get{H 3 (n), H 2 (n), H 1 }as the only possible context for lhs 1 . The second phase of the verification amounts to checking that the corresponding right-hand side of the coordinator rule, added to this context, reduces to {H}. This is done as follows:6. But n is new in the right hand-side of the first rule of H 1 , which is responsible for the creation of different instances of nurses (n 1 and n 2 in the figure).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The hospital ward application.</figDesc><graphic coords="9,30.38,61.50,240.01,518.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>is a server for subjects of clearance Confidential and M z s s ( ) is a server for subjects of clearance Secret (and similarly for M y o c ( ) and M t o s ( ) which are object servers). The links W, R, and A represent respectively write requests, read requests and answers to read requests. The links specified by the architecture ensure that:• No subject has read access to any object that has a classification greater than the clearance of the subject.• No subject has write access to any object that has a classification less than the clearance of the subject.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Class({H 1 ,</head><label>1</label><figDesc>…, H n }) = {G | G ʝ T 1 ∈ Class(H 1 ) and … and G ʝ T n ∈ Class(H n )}</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was partly supported by the Esprit Basic Research Project 9102 Coordination. Most of the inspiration for this paper emerged from previous work on Structured Gamma in collaboration with Pascal Fradet <ref type="bibr" target="#b11">[11]</ref>. Jean-Pierre Banâtre, Pascal Fradet, Alexandra Holzbacher, Valérie Issarny, and Mario Südholt provided valuable feedback on an earlier version of this paper. The case study referred to in Section 7.1 was conducted by Alexandra Holzbacher, Michaël Périn, and Mario Südholt.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Using Style to Understand Descriptions of Software Architecture</title>
		<author>
			<persName><forename type="first">G</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGSOFT&apos;93: Foundations of Software Eng</title>
		<title level="s">Software Eng. Notes</title>
		<meeting>SIGSOFT&apos;93: Foundations of Software Eng</meeting>
		<imprint>
			<date type="published" when="1993-12">Dec. 1993</date>
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Formalizing Architectural Connection</title>
		<author>
			<persName><forename type="first">R</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Int&apos;l Conf. Software Eng</title>
		<meeting>16th Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="71" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">This feature is inherited from previous work on Gamma [4] and graph grammars</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Programming by Multiset Transformation</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Banâtre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>Métayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="98" to="111" />
			<date type="published" when="1993-01">Jan. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Gamma and the Chemical Reaction Model: Ten Years After</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Banâtre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>Métayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Coordination Programming: Mechanisms, Models and Semantics</title>
		<imprint>
			<publisher>Imperial College Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="3" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Chemical Abstract Machine</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="217" to="248" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Linda in Context</title>
		<author>
			<persName><forename type="first">N</forename><surname>Carriero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="444" to="458" />
			<date type="published" when="1989-04">Apr. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Graph Rewriting: an Algebraic and Logic Approach</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Elsevier Science</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Industrial Case Study: A Railway Control System</title>
		<author>
			<persName><forename type="first">E</forename><surname>Jong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int&apos;l Conf. Coordination Models, Languages and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Second Int&apos;l Conf. Coordination Models, Languages and Applications</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1282</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Model for Distributed Systems Based on Graph Rewritings</title>
		<author>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="411" to="449" />
			<date type="published" when="1987-04">Apr. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Context-Free Graph Grammars</title>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Della</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="207" to="233" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Structured Gamma</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>Métayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Exploiting Style in Architectural Design Environment</title>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ockerbloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGSOFT&apos;94, Foundations of Software Eng</title>
		<meeting>SIGSOFT&apos;94, Foundations of Software Eng</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Editor&apos;s Introduction</title>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng., Special Issue on Software Architectures</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="269" to="274" />
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Communicating Sequential Processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="666" to="677" />
			<date type="published" when="1978-08">Aug. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Software Environment for Concurrent Coordinated Programming</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Holzbacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First Int&apos;l Conf. Coordination Models, Languages and Applications</title>
		<title level="s">Lecture Notes in Computer Science 1061</title>
		<meeting>First Int&apos;l Conf. Coordination Models, Languages and Applications</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996-04">Apr. 1996</date>
			<biblScope unit="page" from="249" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Coordination of Distributed and Parallel Programs in Concoord</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Holzbacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Coordination Programming: Mechanisms, Models and Semantics</title>
		<imprint>
			<publisher>Imperial College Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="349" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Modeling Railway Control Systems Using Graph Grammars: A Case Study</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Holzbacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Périn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int&apos;l Conf. Coordination Models, Languages and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Second Int&apos;l Conf. Coordination Models, Languages and Applications</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1282</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Formal Specification and Analysis of Software Architectures Using the Chemical Abstract Machine Model</title>
		<author>
			<persName><forename type="first">P</forename><surname>Inverardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SAAM: A Method for Analysing the Properties of Software Architectures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Int&apos;l Conf. Software Eng</title>
		<meeting>16th Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Configuration Programming. A Framework for the Development of Distributable Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. COMPEURO&apos;90</title>
		<meeting>COMPEURO&apos;90</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="374" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The 4 + 1 View Model of Architecture</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Kruchten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="page" from="42" to="50" />
			<date type="published" when="1995-11">Nov. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Formal Models of Computer Security</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Landwehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="247" to="277" />
			<date type="published" when="1981-09">Sept. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Specification and Analysis of System Architecture Using Rapide</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Luckham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Kenney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Augustin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Mann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="336" to="355" />
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Modelling Distributed Software Architectures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<idno>CMU- CS-95-151</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. First Int&apos;l Workshop Architectures for Software Systems, 17th Int&apos;l Conf. Software Eng., CMU Technical Report</title>
		<meeting>First Int&apos;l Workshop Architectures for Software Systems, 17th Int&apos;l Conf. Software Eng., CMU Technical Report</meeting>
		<imprint>
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An Algorithm for Analysing Communicating Processes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mercouroff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Seventh Int&apos;l Conf. Math. Foundations of Programming Semantics</title>
		<meeting>Seventh Int&apos;l Conf. Math. Foundations of Programming Semantics</meeting>
		<imprint>
			<date type="published" when="1991-03">Mar. 1991</date>
			<biblScope unit="page" from="312" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Calculus of Mobile Processes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Information and Computation</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="1" to="77" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Correct Architecture Refinement</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moriconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Riemenschneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="356" to="372" />
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Higher-Order Concurrent Programs with Finite Communication Topology</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st ACM Symp Principles of Programming Languages</title>
		<meeting>21st ACM Symp Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1994-01">Jan. 1994</date>
			<biblScope unit="page" from="84" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Foundations for the Study of Software Architecture</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGSOFT, Software Eng. Notes</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="40" to="52" />
			<date type="published" when="1992-10">Oct. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Set-Theoretic Graph Rewriting</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Raoult</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Voisin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Int&apos;l Workshop Graph Transformations in Computer Science</title>
		<imprint>
			<biblScope unit="volume">776</biblScope>
			<biblScope unit="page" from="312" to="325" />
			<date type="published" when="1993">1993</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Formulations and Formalisms in Software Architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Science Today, Recent Trends and Developments</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1000</biblScope>
			<biblScope unit="page" from="307" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Abstractions for Software Architecture and Tools to Support Them</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zelesnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="314" to="335" />
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Métayer is currently research director at IRISA/INRIA. He is in charge of the &quot;Lande&quot; research group in Rennes, France. His main interest is the application of formal methods to the design of automatic software engineering tools. This broad area includes program analysis, program verification</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Le</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>software testing, software architectures, and high-level languages</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
