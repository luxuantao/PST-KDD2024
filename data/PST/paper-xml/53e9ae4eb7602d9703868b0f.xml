<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">NetKAT: Semantic Foundations for Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Carolyn</forename><forename type="middle">Jane</forename><surname>Anderson</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Swarthmore</forename><surname>College</surname></persName>
							<affiliation key="aff5">
								<orgName type="department">This work performed</orgName>
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Arjun</forename><surname>Guha</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Carnegie</forename><surname>Mellon University</surname></persName>
							<affiliation key="aff5">
								<orgName type="department">This work performed</orgName>
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Cole</forename><surname>Schlesinger</surname></persName>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Walker</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Nate Foster Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Massachusetts Amherst * Jean-Baptiste Jeannin</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">NetKAT: Semantic Foundations for Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EC5C3C24D2B3B452CEDD18817156BA18</idno>
					<idno type="DOI">10.1145/2535838.2535862</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.2 [Programming Languages]: Language Classifications-Specialized application languages Software-defined networking</term>
					<term>Frenetic</term>
					<term>Network programming languages</term>
					<term>Domain-specific languages</term>
					<term>Kleene algebra with tests</term>
					<term>NetKAT</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Recent years have seen growing interest in high-level languages for programming networks. But the design of these languages has been largely ad hoc, driven more by the needs of applications and the capabilities of network hardware than by foundational principles. The lack of a semantic foundation has left language designers with little guidance in determining how to incorporate new features, and programmers without a means to reason precisely about their code.</p><p>This paper presents NetKAT, a new network programming language that is based on a solid mathematical foundation and comes equipped with a sound and complete equational theory. We describe the design of NetKAT, including primitives for filtering, modifying, and transmitting packets; union and sequential composition operators; and a Kleene star operator that iterates programs. We show that NetKAT is an instance of a canonical and well-studied mathematical structure called a Kleene algebra with tests (KAT) and prove that its equational theory is sound and complete with respect to its denotational semantics. Finally, we present practical applications of the equational theory including syntactic techniques for checking reachability, proving non-interference properties that ensure isolation between programs, and establishing the correctness of compilation algorithms.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Traditional network devices have been called "the last bastion of mainframe computing" <ref type="bibr" target="#b8">[9]</ref>. Unlike modern computers, which are implemented with commodity hardware and programmed using standard interfaces, networks have been built the same way since the 1970s: out of special-purpose devices such as routers, switches, firewalls, load balancers, and middle-boxes, each implemented with custom hardware and programmed using proprietary interfaces. This design makes it difficult to extend networks with new functionality and effectively impossible to reason precisely about their behavior.</p><p>However, a revolution has taken place with the recent rise of software-defined networking (SDN). In SDN, a general-purpose controller machine manages a collection of programmable switches. The controller responds to network events such as new connections from hosts, topology changes, and shifts in traffic load by re-programming the switches accordingly. Because the controller has a global view of the network, it is easy to use SDN to implement a wide variety of standard applications such as shortest-path routing, traffic monitoring, and access control, as well as more sophisticated applications such as load balancing, intrusion detection, and fault-tolerance.</p><p>A major appeal of SDN is that it defines open standards that any vendor can implement. For example, the OpenFlow API <ref type="bibr" target="#b20">[21]</ref> clearly specifies the capabilities and behavior of switch hardware and defines a low-level language for manipulating their configurations. However, programs written directly for SDN platforms such as OpenFlow are akin to assembly: easy for hardware to implement, but difficult for humans to write.</p><p>Network programming languages. In recent years, several different research groups have proposed domain-specific languages for SDN <ref type="bibr">[5-7, 23-25, 31, 32]</ref>. The goal of these network programming languages is to raise the level of abstraction of network programs above hardware-oriented APIs such as OpenFlow, thereby making it easier to build sophisticated and reliable SDN applications. For example, the languages developed in the Frenetic project <ref type="bibr" target="#b29">[30]</ref> support a two-phase programming model: (i) a generalpurpose program responds to network events by generating a static forwarding policy; and (ii) the static policy is compiled and passed to a run-time system that configures the switches using OpenFlow messages. This model balances expressiveness-dynamic policies can be expressed by having the general-purpose program generate a sequence of static policies-and simplicity-forwarding policies are written in a simple domain-specific language with a clear semantics, so programs can be analyzed and even verified using automated tools <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b25">26]</ref>.</p><p>Still, it has never been clear what features a static policy language should support. The initial version of Frenetic <ref type="bibr" target="#b5">[6]</ref> used simple lists of predicate-action rules as policies, where the actions in-cluded constructs for filtering, forwarding, duplicating, and modifying packets. Subsequent versions of the language added (and later removed) the ability to embed arbitrary packet-processing functions in policies <ref type="bibr" target="#b22">[23]</ref>, as well as constructs for composing policies in parallel and sequence <ref type="bibr" target="#b23">[24]</ref>. As Frenetic evolved, its designers added, removed, and modified the meaning of primitives as dictated by the needs of applications. Without principles or metatheory to guide its development, its evolution has lacked clear direction and foresight. The ad hoc semantics has not made clear which primitives are essential and which ones can be derived, and when new constructs have been added to the language, it has not been clear how they should interact with existing constructs and what behavioral laws they should obey.</p><p>An even more pressing issue is that these static policy languages only specify the forwarding behavior of the switches in the network. However, when a network program is actually executed, end-to-end functionality is determined both by the behavior of the switches and by the structure of the network topology. To answer almost any interesting question about the network such as "Can X connect to Y?", "Is traffic from A to B routed through Z?", or "Is there a loop involving S?", the programmer must step outside the confines of the linguistic model and the abstractions it provides.</p><p>To summarize, we believe that a foundational model for network programming languages is essential. Such a model should (i) identify the essential constructs for programming networks, (ii) provide guidelines for incorporating new features, and (iii) unify reasoning about switches, topology and end-to-end behavior.</p><p>Semantic foundations. This paper presents the first network programming language that meets these criteria. To begin, we focus on the global behavior of the network, unlike previous network programming languages, which have focused on the local behavior of individual switches. Abstractly, a network can be seen as an automaton that moves packets from node to node along the links in its topology. Hence, from a linguistic perspective, it is natural to use regular expressions, the language of finite automata. Regular expressions are a standard way to specify the packet-processing behavior of a network: a path is encoded as a concatenation of processing steps (p•q•• • • ), a set of paths is encoded as a union of paths (p + q + • • • ), and iterated processing is encoded using Kleene star. Moreover, by modeling the network in this way, we get a readymade theory for reasoning about formal properties: Kleene algebra (KA), a decades-old sound and complete equational theory of regular expressions.</p><p>With Kleene algebra as the choice for representing global network structure, we can turn our attention to specifying local switch-processing functionality. Fundamentally, a switch implements predicates to match packets and actions that transform and forward matching packets. Existing languages build various abstractions atop the predicates and actions supplied by the hardware, but predicates and actions are essential. As a consequence, a foundational model for SDN must incorporate both Kleene algebra for reasoning about network structure and Boolean algebra for reasoning about the predicates that define switch behavior. Fortunately, these classic mathematical structures have already been unified in previous work on Kleene algebra with tests (KAT) <ref type="bibr" target="#b13">[14]</ref>.</p><p>By now KAT has a well-developed metatheory, including an extensive model theory and results on expressiveness, deductive completeness, and complexity. The axioms of KAT are sound and complete over a variety of popular semantic models, including language, relational, and trace models, and KAT has been applied successfully in a number of application areas, including compiler, device driver, and communication protocol verification <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b21">22]</ref>. Moreover, equivalence in KAT has a PSPACE decision procedure. This paper applies this theory to a new domain: networks. NetKAT. NetKAT is a new framework for specifying, programming, and reasoning about networks based on Kleene algebra with tests. As a programming language, NetKAT has a simple denotational semantics inspired by NetCore <ref type="bibr" target="#b22">[23]</ref>, but modified and extended in key ways to make it sound for KAT (which NetCore is not). In this respect, the semantic foundation provided by KAT has delivered true guidance: the axioms of KAT dictate the interactions between primitive program actions, predicates, and other operators. Moreover, any future proposed primitive that violates a KAT axiom can be summarily rejected for breaking the equations that allow us to reason effectively about the network. NetKAT thus provides a foundational structure and consistent reasoning principles that other network programming languages lack.</p><p>For specification and reasoning, NetKAT also provides a finite set of equations that capture equivalences between NetKAT programs. The equational theory includes the axioms of KAT, as well as domain-specific axioms that capture transformations on packets. This set of axioms enables reasoning about local switch processing functionality (needed in compilation and optimization) as well as global network behavior (needed to check reachability and traffic isolation properties). We prove that the equational theory is sound and complete with respect to the denotational semantics. While the soundness proof is straightforward, our proof of completeness is novel: we construct an alternate language model for NetKAT and leverage the completeness of KA.</p><p>To evaluate the practical utility of our theory and the expressive power of NetKAT, we demonstrate how it can be used to reason about a diverse collection of applications. First, we show that NetKAT can answer a variety of interesting reachability queries useful to network operators. Next, we state and prove a noninterference property for networks that provides a strong form of isolation between NetKAT programs. Finally, we prove that NetKAT can be correctly compiled to a low-level form analogous to switch flow tables.</p><p>In summary, the contributions of this paper are as follows:</p><p>• We develop a new semantic foundation for network programming languages based on Kleene algebra with tests (KAT). • We formalize the NetKAT language in terms of a denotational semantics and an axiomatic semantics based on KAT; we prove the equational axioms sound and complete with respect to the denotational semantics. • We apply the equational theory in several diverse domains including reasoning about reachability, traffic isolation, and compiler correctness.</p><p>The next section presents a simple example to motivate NetKAT and introduces the key elements of its design. The subsequent sections define the language formally, develop its main theoretical properties, and present applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview</head><p>This section introduces the syntax and semantics of NetKAT using a simple example. Consider the network shown in Figure <ref type="figure" target="#fig_0">1</ref>. It consists of switches A and B, each with ports labeled 1 and 2, and two hosts. The switches and hosts are connected together in series. Suppose we want to configure the network to implement the following policies:</p><p>• Forwarding: transfer packets between hosts, but</p><p>• Access control: block SSH packets.</p><p>The forwarding component is straightforward-configure both switches to forward packets destined for host 1 out port 1, and likewise for host 2-but there are several ways to implement the access control component. We will develop two implementations and prove them equivalent using NetKAT's equational theory.</p><p>Forwarding. To warm up, let us define a simple NetKAT policy that implements the forwarding component. To a first approximation, a NetKAT policy can be thought of as a function from packets to sets of packets. (In the next section we will generalize this type to functions from lists of packets to sets of lists of packets, where the lists encode packet-processing histories, to support reasoning about network-wide properties.) We represent a packet as a record with fields for standard headers such as source address (src), destination address (dst), and protocol type (typ), as well as two fields, switch (sw) and port (pt), that identify the current location of the packet in the network. Atomic NetKAT policies filter and modify packets. A filter (f = n) takes any input packet pk and yields the singleton set {pk } if field f of pk equals n, and {} otherwise. A modification (f ← n) takes any input packet pk and yields the singleton set {pk }, where pk is the packet obtained from pk by setting f to n.</p><p>To allow programmers to express more sophisticated policies, NetKAT also has policy combinators that build bigger policies out of smaller ones. The union combinator (p + q) generates the union of the sets produced by applying each of p and q to the input packet, while the sequential composition combinator (p•q) first applies p to the input packet, then applies q to each packet in the resulting set, and finally takes the union of all of the resulting sets. With these operators, we can implement the forwarding policy as follows:</p><formula xml:id="formula_0">p (dst = H1 • pt ← 1) + (dst = H2 • pt ← 2)</formula><p>At the top level, this policy is the union of two sub-policies. The first updates the pt field of all packets destined for H1 to 1 and drops all other packets, while the second updates the pt field of all packets destined for H2 to 2. The union of the two generates the union of their behaviors-in other words, the policy forwards packets across switches A and B in both directions.</p><p>Access control. Next, we extend the policy with access control. The simplest way to do this is to compose a filter that blocks SSH traffic with the forwarding policy in sequence:</p><formula xml:id="formula_1">pAC ¬(typ = SSH) • p</formula><p>This policy drops the input packet if its typ field is SSH and otherwise forwards it using p. Of course, a quick inspection of the network topology shows that it is not necessary to test all packets at all locations in the network to block SSH traffic-packets traveling between host 1 and host 2 must traverse both switches, so it is sufficient to filter only at switch A,</p><formula xml:id="formula_2">pA (sw = A • ¬(typ = SSH) • p) + (sw = B • p) or at switch B: pB (sw = A • p) + (sw = B • ¬(typ = SSH) • p)</formula><p>Both of these policies are more complicated than the original policy, but more efficient because they avoid having to store and enforce the access control policy at both switches. Naturally, we would prefer one of the optimized policies. In addition, we would like to be able to answer the following questions:</p><p>• "Are non-SSH packets forwarded?"</p><p>• "Are SSH packets dropped?"</p><p>• "Are pAC, pA, and pB equivalent?" Network administrators ask these sorts of questions whenever they write a network policy. However, note that we cannot answer them by inspecting the policies alone-the answers depend fundamentally on the network topology. We will see how to incorporate topology information into a NetKAT program next.</p><p>Topology. A network topology is a directed graph with hosts and switches as nodes and links as edges. We can model the topology as the union of smaller policies that encode the behavior of each link. To model an internal link, we use the sequential composition of a filter that retains packets located at one end of the link and a modification that updates the sw and pt fields to the location at the other end of the link, thereby capturing the effect of sending a packet across the link. To model a link at the perimeter of the network, we simply use a filter that retains packets located at the ingress port. We assume that links are uni-directional, and encode bi-directional links using pairs of uni-directional links. For example, the following policy models the internal links between switches A and B, and the links at the perimeter to hosts 1 and 2:</p><formula xml:id="formula_3">t = (sw = A • pt = 2 • sw ← B • pt ← 1) + (sw = B • pt = 1 • sw ← A • pt ← 2) + (sw = A • pt = 1) + (sw = B • pt = 2)</formula><p>Note that although we represent the links as policies, unlike switch policies, these link policies cannot actually be controlled programmatically-they must be consistent with the structure of the underlying physical topology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Switches meet topology.</head><p>A packet traverses the network in interleaved steps of processing by the switches and topology. In our example, if host 1 sends a non-SSH packet to host 2, it is first processed by switch A, then the link between A and B, and finally by switch B. This can be encoded by the NetKAT term pAC•t•pAC. More generally, a packet may require an arbitrary number of steps-in particular, if the topology has a cycle. Using the Kleene star operator, which iterates a policy zero or more times, we can encode the overall behavior of the network:</p><formula xml:id="formula_4">(pAC • t)*</formula><p>Note however that this policy processes packets that enter and exit the network at arbitrary locations, including at internal locations such as on the link between switches A and B. It is often useful to restrict attention to packets that enter and exit the network at specified external locations e:</p><formula xml:id="formula_5">e (sw = A • pt = 1) + (sw = B • pt = 2)</formula><p>Using this predicate, we can restrict the policy to packets sent or received by one of the hosts:</p><formula xml:id="formula_6">pnet e • (pAC • t)* • e</formula><p>More generally, the input and output predicates may be distinct:</p><formula xml:id="formula_7">in • (p • t)* • out</formula><p>This encoding is inspired by the model used in Header Space Analysis <ref type="bibr" target="#b9">[10]</ref>. We call a network modeled in this way a logical crossbar <ref type="bibr" target="#b19">[20]</ref>, since it encodes end-to-end processing behavior (and elides internal processing steps). Section 3 discusses a more refined model that encodes hop-by-hop processing.</p><p>Formal reasoning. We now turn to formal reasoning and investigate whether the logical crossbar correctly implements the specified forwarding and access control policies. It turns out that these Syntax questions, and many others, can be reduced to policy equivalence. We write p ≡ q when p and q return the same set of packets on all inputs, and p ≤ q when p returns a subset of the packets returned by q on all inputs. (Note that p ≤ q can be treated as an abbreviation for p + q ≡ q.) To establish that pnet correctly filters all SSH packets going from port 1 on switch A to port 2 on switch B, we check the following equivalence, where 0 is the filtering policy that drops all packets:</p><formula xml:id="formula_8">Fields f ::= f1 | • • • | f k Packets pk ::= {f1 = v1, • • • , f k = v k } Histories h ::= pk :: | pk ::h Predicates a, b ::= 1 Identity | 0 Drop | f = n Test | a + b Disjunction | a • b Conjunction | ¬a Negation Policies p, q ::= a Filter | f ← n Modification | p + q Union | p • q Sequential composition | p* Kleene star | dup Duplication Semantics p ∈ H → P(H) 1 h {h} 0 h {} f = n (pk ::h)  {pk ::h} if pk .f = n {} otherwise ¬a h {h} \ ( a h) f ← n (pk ::h) {pk [f := n]::h} p + q h p h ∪ q h p • q h ( p q ) h p* h S i∈N F i h where F 0 h {h} and F i+1 h ( p F i ) h dup (pk ::h) {pk ::(pk ::h)} Kleene Algebra Axioms p + (q + r) ≡ (p + q) + r KA-PLUS-ASSOC p + q ≡ q + p KA-PLUS-COMM p + 0 ≡ p KA-PLUS-ZERO p + p ≡ p KA-PLUS-IDEM p • (q • r) ≡ (p • q) • r KA-SEQ-ASSOC 1 • p ≡ p KA-ONE-SEQ p • 1 ≡ p KA-SEQ-ONE p • (q + r) ≡ p • q + p • r KA-SEQ-DIST-L (p + q) • r ≡ p • r + q • r KA-SEQ-DIST-R 0 • p ≡ 0 KA-ZERO-SEQ p • 0 ≡ 0 KA-SEQ-ZERO 1 + p • p* ≡ p* KA-UNROLL-L q + p • r ≤ r ⇒ p* • q ≤ r KA-LFP-L 1 + p* • p ≡ p* KA-UNROLL-R p + q • r ≤ q ⇒ p • r* ≤ q KA-LFP-R Additional Boolean Algebra Axioms a + (b • c) ≡ (a + b) • (a + c) BA-PLUS-DIST a + 1 ≡ 1 BA-PLUS-ONE a + ¬a ≡ 1 BA-EXCL-MID a • b ≡ b • a BA-SEQ-COMM a • ¬a ≡ 0 BA-CONTRA a • a ≡ a BA-SEQ-IDEM Packet Algebra Axioms f ← n • f ← n ≡ f ← n • f ← n, if f = f PA-MOD-MOD-COMM f ← n • f = n ≡ f = n • f ← n, if f = f PA-MOD-FILTER-COMM dup • f = n ≡ f = n • dup PA-DUP-FILTER-COMM f ← n • f = n ≡ f ← n PA-MOD-FILTER f = n • f ← n ≡ f = n PA-FILTER-MOD f ← n • f ← n ≡ f ← n PA-MOD-MOD f = n • f = n ≡ 0, if n = n PA-CONTRA P i f = i ≡ 1 PA-MATCH-ALL</formula><formula xml:id="formula_9">0 @ typ = SSH • sw = A • pt = 1 • (pAC • t)* • sw = B • pt = 2 1 A ≡ 0</formula><p>To establish that the optimized policies pA and pB correctly filter SSH packets going from port 1 on switch A to port 2 on switch B, we check the following equivalences,</p><formula xml:id="formula_10">0 @ typ = SSH • sw = A • pt = 1 • (pA • t)* • sw = B • pt = 2 1 A ≡ 0 and: 0 @ typ = SSH • sw = A • pt = 1 • (pB • t)* • sw = B • pt = 2 1 A ≡ 0</formula><p>Finally, to establish that pAC correctly forwards non-SSH packets from H1 to H2, we check the following inclusion:</p><formula xml:id="formula_11">(¬(typ = SSH) • sw = A • pt = 1 • sw ← B • pt ← 2) ≤ (pAC • t)*</formula><p>and similarly for non-SSH packets H2 to H1.</p><p>Of course, to actually check these equivalences formally, we need a proof system. NetKAT is designed to not only be an expressive programming language, but also one that satisfies the axioms of a Kleene algebra with tests (KAT). Moreover, by extending KAT with additional axioms that capture the domain-specific features of networks, the equational theory is complete-i.e., it can answer all the questions posed in this section, and many more. The following sections present the syntax, semantics, and equational theory of NetKAT formally (Section 3); prove that the equational theory is sound and complete with respect to the semantics (Section 4); and illustrate its effectiveness on a broad range of questions including additional reachability properties (Section 5), program isolation (Section 6) and compiler correctness (Section 7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">NetKAT</head><p>This section defines the syntax and semantics of NetKAT formally.</p><p>Preliminaries. A packet pk is a record with fields f1, . . . , f k mapping to fixed-width integers n. We assume a finite set of packet headers, including Ethernet source and destination addresses, VLAN tag, IP source and destination addresses, TCP and UDP source and destination ports, along with special fields for the switch (sw), port (pt), and payload. For simplicity, we assume that every packet contains the same fields. We write pk .f for the value in field f of pk , and pk [f := n] for the packet obtained from pk by updating field f to n.</p><p>To facilitate reasoning about the paths a packet takes through the network, we maintain a packet history that records the state of each packet as it travels from switch to switch. Formally, a packet history h is a non-empty sequence of packets. We write pk :: to denote a history with one element, pk ::h to denote the history constructed by prepending pk on to h, and pk 1 , . . . , pk n for the history with elements pk 1 to pk n . By convention, the first element of a history is the current packet; other elements represent previously-processed packets. We write H for the set of all histories, and P(H) for the powerset of H.</p><p>Syntax. Syntactically, NetKAT expressions are divided into two categories: predicates (a, b) and policies (p, q). Predicates include constants true (1) and false (0), tests (f = n), and negation (¬a), disjunction (a+b), and conjunction (a•b) operators. Policies include predicates, modifications (f ← n), union (p + q) and sequential composition (p • q), iteration (p*), and a special policy that records the current packet in the history (dup). The complete syntax of NetKAT is given in Figure <ref type="figure" target="#fig_1">2</ref>. By convention, (*) binds tighter than (•), which binds tighter than (+). Hence, a</p><formula xml:id="formula_12">• b + c • d* is the same as (a • b) + (c • (d*)).</formula><p>Semantics. Semantically, every NetKAT predicate and policy denotes a function that takes a history h and produces a (possibly empty) set of histories {h1, . . . , hn}. Producing the empty set models dropping the packet (and its history); producing a singleton set models modifying or forwarding the packet to a single location; and producing a set with multiple histories models modifying the packet in several ways or forwarding the packet to multiple locations. Note that policies only ever inspect or modify the first (current) packet in the history. This means that an implementation need not actually record histories-they are only needed for reasoning.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> defines the denotational semantics of NetKAT. Note that there is no separate definition for predicates-every predicate is a policy, and the semantics of (•) and (+) are the same whether they are composing policies or predicates. The syntactic distinction between policies and predicates arises solely to ensure that negation is only applied to a predicate, and not, for example, to a policy such as p*. Formally, a predicate denotes a function that returns either the singleton {h} or the empty set {} when applied to a history h. Hence, predicates behave like filters. A modification (f ← n) denotes a function that returns a singleton history in which the field f of the current packet has been updated to n. The union operator (p + q) denotes a function that produces the union of the sets generated by p and q, and sequential composition (p•q) denotes the Kleisli composition ( ) of the functions p and q, where the Kleisli composition of functions of type H → P(H) is defined as:</p><formula xml:id="formula_13">(f g) x [ {g y | y ∈ f x} .</formula><p>Policy iteration p* is interpreted as a union of semantic functions Fi of h, where each Fi is the Kleisli composition of function denoted by p i times. Finally, dup denotes a function that duplicates the current packet and adds it to the history. Since modification updates the packet at the head of the history, dup "freezes" the current state of the packet and makes it observable. Readers familiar with Frenetic and NetCore may notice some differences between the syntax used in previous network programming languages. This paper focuses on theoretical foundations, so we use the traditional "algebraic" syntax for KAT, which conflates the (•) and (+) operators for predicates and programs and has constants 0 and 1. Figure <ref type="figure" target="#fig_2">3</ref> shows the relationship between this algebraic syntax and the surface syntax we use in programs.</p><formula xml:id="formula_14">a, b ::= 1 | 0 | f = n | a + b | a • b | ¬a p, q ::= a | f ← n | p + q | p • q | p* | dup</formula><p>Equational theory. As its name suggests, NetKAT is a Kleene algebra with tests. Formally, a Kleene algebra (KA) is an algebraic structure, (K, +, •, *, 0, 1) where K is an idempotent semiring under (+, •, 0, 1), and p* • q (respectively q•p*) is the least solution of the affine linear inequality p • r + q ≤ r (respectively r • p + q ≤ r), where p ≤ q is an abbreviation for p + q = q. The axioms of KA are listed in Figure <ref type="figure" target="#fig_1">2</ref>. A Kleene algebra with tests (KAT) is a two-sorted algebraic structure,</p><formula xml:id="formula_15">(K, B, +, •, *, 0, 1, ¬)</formula><p>where ¬ is a unary operator defined only on B, such that • (K, +, •, *, 0, 1) is a Kleene algebra,</p><p>• (B, +, •, ¬ , 0, 1) is a Boolean algebra, and</p><p>• (B, +, •, 0, 1) is a subalgebra of (K, +, •, 0, 1).</p><p>The axioms of Boolean algebra consist of the axioms of idempotent semirings (already listed as KA axioms) and the additional axioms listed in Figure <ref type="figure" target="#fig_1">2</ref>. In previous work on KAT, the elements of B and K have usually been called tests and actions respectively; in this paper we will refer to them as predicates and policies.</p><p>It is easy to see that NetKAT has the required syntactic structure to be a KAT. However, the KAT axioms are not complete for the underlying NetKAT packet model. To establish completeness, we also need the packet algebra axioms listed in Figure <ref type="figure" target="#fig_1">2</ref>. The first three axioms specify commutativity conditions. For example, the axiom PA-MOD-MOD-COMM states that assignments src ← X and dst ← Y can be applied in either order, as src and dst are different:</p><formula xml:id="formula_16">src ← X • dst ← Y ≡ dst ← Y • src ← X</formula><p>Similarly, axiom PA-MOD-FILTER-COMM states that the assignment src ← X and predicate sw = A can be applied in either order. The axiom PA-DUP-FILTER-COMM states that every predicate commutes with dup. Interestingly, only this single axiom is needed to characterize dup in the equational theory. The next few axioms characterize modifications. The PA-MOD-FILTER axiom states that modifying a field f to n and then filtering on packets with f equal to n is equivalent to the modification alone. Similarly, the axiom PA-FILTER-MOD states that filtering on packets with field f equal to n and then modifying that field to n is equivalent to just the filter. PA-MOD-MOD states that only the last assignment in a sequence of assignments to the same f has any effect. The final two axioms characterize filters. The axiom PA-CONTRA states that a field cannot be equal to two different values at the same time, while the axiom PA-MATCH-ALL states that the sum of filters on every possible value is equivalent to the identity. This implies packet values are drawn from a finite domain, such as fixed-width integers.</p><formula xml:id="formula_17">KAT-INVARIANT If a • p ≡ p • a then a • p* ≡ a • (p • a)* Lemma 2.3.2 in [14] KAT-SLIDING p • (q • p)* ≡ (p • q)* • p Identity 19 in [14] KAT-DENESTING p* • (q • p*)* ≡ (p + q)* Identity 20 in [14] KAT-COMMUTE If for all atomic x in q, x • p ≡ p • x then q • p ≡ p • q Corollary of Lemma 4.4 in [2]</formula><p>Example: access control. To illustrate the NetKAT equational theory, we prove a simple equivalence in Figure <ref type="figure" target="#fig_4">5</ref> using the policies from Section 2. Recall that the policy pA filters SSH packets on switch A while pB filters SSH packets on switch B. We prove that these programs are equivalent on SSH traffic going from left to right across the network topology shown in Figure <ref type="figure" target="#fig_0">1</ref>. This can be seen as a simple form of code motion-relocating the filter from switch A to switch B. We use the logical crossbar encoding with the following input and output predicates:</p><formula xml:id="formula_18">in (sw = A • pt = 1) out (sw = B • pt = 2)</formula><p>As a warm up, we first prove two simpler lemmas that will be useful for the main code motion proof. The proofs of these lemmas are straightforward calculations using the NetKAT axioms and some standard KAT theorems (given in Figure <ref type="figure" target="#fig_3">4</ref>). We shade the term(s) on each line that will be changed on the next step of the proof. To lighten the notation, we elide uses of axioms related to associativity, and use the following abbreviations:</p><formula xml:id="formula_19">aA (sw = A) a1 (pt = 1) aB (sw = B) a2 (pt = 2) mA (sw ← A) m1 (pt ← 1) mB (sw ← B) m2 (pt ← 2) SSH (typ = SSH)</formula><p>Lemma 1 states that the sequential composition of the input predicate, the predicate aB, and an arbitrary policy q is equivalent to the policy that drops all packets. Intuitively this holds because the input predicate matches packets on switch A and aB matches packets on switch B. Lemma 2 states that the sequential composition of an arbitrary policy q, the predicate aA, the topology t from Section 2, and the output predicate is equivalent to the policy that drops all packets. Intuitively this holds because the topology does not forward packets located on any port of switch A to port 2 of switch B. The proof is essentially a case analysis on the links in the topology. Using these lemmas, we then prove Lemma 3, which states that pA and pB both drop SSH traffic going from host 1 to host 2. Formal statements of these lemmas and proofs using the NetKAT equational axioms can be found in Figure <ref type="figure" target="#fig_4">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Soundness, Completeness, and Decidability</head><p>This section proves the soundness and completeness of the NetKAT axioms with respect to the denotational semantics defined in Section 3. More formally, these results state that every equivalence provable using the NetKAT axioms also holds in the denotational model (Theorem 1), and that every equivalence which holds in the denotational model is provable using the axioms (Theorem 2). We also prove the decidability of NetKAT equivalence, and show that the problem is PSPACE-complete.</p><p>To obtain these results, we prove theorems that are stronger and more enlightening from a theoretical point of view. For soundness, we prove that the packet-history model used in the denotational semantics is isomorphic to a model based on binary relations, and appeal to the soundness of KAT over binary relation models. For completeness, we develop a language model for NetKAT that plays the same role as regular sets of strings and guarded strings do for KA and KAT respectively. We then relate the packet-history and language models, which allows us to leverage the completeness of KA to prove the completeness of the NetKAT axioms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Soundness</head><p>To prove soundness, we begin by reformulating the standard packet-history semantics introduced in Section 3 in terms of binary relations. In the standard semantics, policies and predicates are modeled as functions p ∈ H → P(H). This semantics is isomorphic to a relational semantics [•] in which each policy and predicate is interpreted as a binary relation [p] ⊆ H × H:</p><formula xml:id="formula_20">(h1, h2) ∈ [p] ⇔ h2 ∈ p (h1).</formula><p>Intuitively, [p] is the set of input-output pairs of the policy p.</p><p>Formally, the maps p ∈ H → P(H) are morphisms of type H → H in Kl P, the Kleisli category of the powerset monad. It is well known that the Kleisli category Kl P is isomorphic to the category Rel of sets and binary relations, as witnessed by currying:</p><formula xml:id="formula_21">X → P(Y ) ∼ = X → Y → 2 ∼ = X × Y → 2 ∼ = P(X × Y ).</formula><p>In the relational model [•], product is interpreted as ordinary relational composition, and the remaining KAT operations translate under the isomorphism to the usual KAT operations on binary relations. Since the relational model with these distinguished operations satisfies the axioms of KAT (see e.g. <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">17]</ref>), so do NetKAT models with the packet-history semantics of Section 3.</p><p>Let denote provability in NetKAT. The following Theorem states the soundness of the NetKAT axioms.</p><p>Theorem 1 (Soundness). The KAT axioms and packet algebra axioms listed in Figure <ref type="figure" target="#fig_1">2</ref> are sound with respect to the semantics of Section 3. That is, if p ≡ q, then p = q .</p><p>Proof sketch. We have already argued that the packet-history semantics is isomorphic to a relational KAT, and therefore satisfies the KAT axioms listed in Figure <ref type="figure" target="#fig_1">2</ref>. It remains to show that the additional packet algebra axioms on the right-hand side of Figure <ref type="figure" target="#fig_1">2</ref> are also satisfied. These can all be verified by elementary arguments in relational algebra (see e.g. <ref type="bibr" target="#b27">[28]</ref>). Some are special cases of [2, Equations ( <ref type="formula">6</ref>)-( <ref type="formula">11</ref>)], whose soundness is proved in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">Theorem 4.3]</ref>. See the long version of this paper for the full proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Completeness</head><p>The proof of completeness proceeds in four steps:</p><p>1. We first define reduced NetKAT, a subset of NetKAT where policies are regular expressions over complete tests (a normal form for sequences of tests), complete assignments (a normal form for sequences of modifications), and dup. We show that every NetKAT policy is provably equivalent to a reduced NetKAT policy and that reduced terms have a simplified set of axioms pertaining to assignments and tests.</p><p>2. Inspired by past proofs of completeness for KA and KAT, we then develop a language model for reduced NetKAT. This language model gives semantics to policies via sets of guarded strings. We prove the language model and the standard model of NetKAT given by the denotational semantics are isomorphic.</p><formula xml:id="formula_22">Lemma 1. in • aB • ≡ 0 Proof. in • aB • q ≡ { definition in } aA • a1 • aB • q ≡ { KAT-COMMUTE } aA • aB • a1 • q ≡ { PA-CONTRA } 0 • a1 • q ≡ { KA-ZERO-SEQ } 0 Lemma 2. q • aA • t • out ≡ 0 Proof. q • aA • t • out ≡ { definition t } q • aA • (aA • a2 • mB • m1 + aB • a1 • mA • m2 + aA • a1 + aB • a2) • out ≡ { KA-SEQ-DIST-L, KA-SEQ-DIST-R } q • aA • aA • a2 • mB • m1 • out + q • aA • aB • a1 • mA • m2 • out + q • aA • aA • a1 • out + q • aA • aB • a2 • out ≡ { definition out } q • aA • aA • a2 • mB • m1 • aB • a2 + q • aA • aB • a1 • mA • m2 • aB • a2 + q • aA • aA • a1 • aB • a2 + q • aA • aB • a2 • aB • a2 ≡ { PA-MOD-FILTER } q • aA • aA • a2 • mB • m1 • a1 • aB • a2 + q • aA • aB • a1 • mA • aA • m2 • aB • a2 + q • aA • aA • a1 • aB • a2 + q • aA • aB • a2 • aB • a2 ≡ { KAT-COMMUTE } q • aA • aA • a2 • mB • m1 • aB • a1 • a2 + q • aA • aB • a1 • mA • m2 • aA • aB • a2 + q • aA • aA • aB • a1 • a2 + q • aA • aB • a2 • aB • a2 ≡ { PA-CONTRA } q • aA • aA • a2 • mB • m1 • aB • 0 + q • aA • aB • a1 • mA • m2 • 0 • a2 + q • aA • aA • aB • 0 + q • 0 • a2 • aB • a2 ≡ { KA-SEQ-ZERO, KA-ZERO-SEQ } 0 + 0 + 0 + 0 ≡ { KA-PLUS-IDEM } 0 Lemma 3. in • SSH • (pA • t)* • out ≡ in • SSH • (pB • t)* • out Proof. in • SSH • (pA • t)* • out ≡ { KAT-INVARIANT, definition pA } in • SSH • ((aA • ¬SSH • p + aB • p) • t • SSH)* • out ≡ { KA-SEQ-DIST-R } in • SSH • (aA • ¬SSH • p • t • SSH + aB • p • t • SSH)* • out ≡ { KAT-COMMUTE } in • SSH • (aA • ¬SSH • SSH • p • t + aB • p • t • SSH)* • out ≡ { BA-CONTRA } in • SSH • (aA • 0 • p • t + aB • p • t • SSH)* • out ≡ { KA-SEQ-ZERO/ZERO-SEQ, KA-PLUS-COMM, KA-PLUS-ZERO } in • SSH • (aB • p • t • SSH)* • out ≡ { KA-UNROLL-L } in • SSH • (1 + (aB • p • t • SSH) • (aB • p • t • SSH)*) • out ≡ { KA-SEQ-DIST-L, KA-SEQ-DIST-R, definition out } in • SSH • aB • a2 + in • SSH • aB • p • t • SSH • (aB • p • t • SSH)* • aB • a2 ≡ { KAT-COMMUTE } in • aB • SSH • a2 + in • aB • SSH • p • t • SSH • (aB • p • t • SSH)* • aB • a2 ≡ { Lemma 1 } 0 + 0 ≡ { KA-PLUS-IDEM } 0 ≡ { KA-PLUS-IDEM } 0 + 0 ≡ { Lemma 1, Lemma 2 } in • aB • SSH • a2 + in • SSH • (aA • p • t • SSH)* • p • SSH • aA • t • out ≡ { KAT-COMMUTE, definition out } in • SSH • out + in • SSH • (aA • p • t • SSH)* • aA • p • t • SSH • out ≡ { KA-SEQ-DIST-L, KA-SEQ-DIST-R } in • SSH • (1 + (aA • p • t • SSH)* • (aA • p • t • SSH)) • out ≡ { KA-UNROLL-R } in • SSH • (aA • p • t • SSH)* • out ≡ { KA-SEQ-ZERO/ZERO-SEQ, KA-PLUS-ZERO } in • SSH • (aA • p • t • SSH + aB • 0 • p • t)* • out ≡ { BA-CONTRA } in • SSH • (aA • p • t • SSH + aB • ¬SSH • SSH • p • t)* • out ≡ { KAT-COMMUTE } in • SSH • (aA • p • t • SSH + aB • ¬SSH • p • t • SSH)* • out ≡ { KA-SEQ-DIST-R } in • SSH • ((aA • p + aB • ¬SSH • p) • t • SSH)* • out ≡ { KAT-INVARIANT, definition pB } in • SSH • (pB • t)* • out</formula><p>3. We then define a normal form for NetKAT policies, and show that every policy is provably equivalent to its normal form.</p><p>4. Finally, we relate NetKAT normal forms to regular sets of guarded strings, and obtain the completeness of NetKAT from the completeness of KA.</p><p>The rest of this section outlines the key steps of this proof. The long version of this paper gives further details.</p><p>Step 1: Reduced NetKAT. Let f1, . . . , f k be a list of all fields of a packet in some (fixed) order. For each tuple n = n1, . . . , n k of values, let f = n and f ← n denote the expressions respectively. We call these expressions complete tests and complete assignments respectively. We often call complete tests atoms because they are atoms (minimal nonzero elements) of the Boolean algebra generated by the tests. Note that complete tests and complete assignments are in one-to-one correspondence according to the values n. Hence, if α is an atom, we denote the corresponding complete assignment by πα , and if π is a complete assignment, we denote the corresponding atom by απ . We let A denote the set of atoms and Π the set of complete assignments. Now that we have defined atoms and complete assignments, we investigate their properties. Figure <ref type="figure">6</ref> gives a collection of simple axioms for reduced policies that are easily provable using the full NetKAT axioms. One useful consequence of these axioms is P α∈A α • πα ≡ 1. Any policy is provably equivalent to a in which all atomic assignments f ← n appear in the context of a complete assignment. The proof of this fact is straightforward.</p><formula xml:id="formula_23">f1 = n1 • • • f k = n k f1 ← n1 • • • f k ← n k , NetKAT syntax Complete assignments π f1 ← n1 • • • f k ← n k Complete tests α, β f1 = n1 • • • f k = n k Reduced terms p, q ::= α Complete test | π Complete assignment | p + q Union | p • q Sequence | p* Kleene star | dup Duplication Simplified axioms for A and P π ≡ π • απ α • dup ≡ dup • α P α α ≡ 1, α ≡ α • πα π • π ≡ π α • β ≡ 0, α = β Regular interpretation: R(p) ⊆ (Π + A + dup)* R(π) = {π} R(p + q) = R(p) ∪ R(q) R(α) = {α} R(p • q) = {xy | x ∈ R(p), y ∈ R(q)} R(dup) = {dup} R(p*) = [ n≥0 R(p n ) Figure 6. Reduced NetKAT. Language model: G(p) ⊆ I = A • (Π • dup)* • Π G(π) = {α • π | α ∈ A} G(p + q) = G(p) ∪ G(q) G(α) = {α • πα } G(p • q) = G(p) G(q) G(dup) = {α • πα • dup • πα | α ∈ A} G(p*) = [ n≥0 G(p n ) Guarded concatenation α • p • π β • q • π = ( α • p • q • π if β = απ undefined if β = απ A B = {p q | p ∈ A, q ∈ B} ⊆ I</formula><formula xml:id="formula_24">f ← n ≡ 1 • f ← n ≡ ( P α∈A α • πα ) • (f ← n) ≡ P α∈A α</formula><p>• π α where π α is πα with the assignment to f replaced by f ← n. Similarly, every test is equivalent to a sum of complete tests: b ≡ P α≤b α Since all modifications can be replaced by complete assignments and all tests by atoms, any NetKAT policy p can be viewed as a regular expression over the alphabet Π ∪ A ∪ {dup}. The bottom of Figure <ref type="figure">6</ref> shows this by defining a mapping R from reduced NetKAT to regular sets over this alphabet. We assume for the remainder of this section that all NetKAT policies are in reduced form.</p><p>Step 2: Language model. Both KA and KAT have language models in which expressions are interpreted as regular sets of minimal nonzero terms (often called join-irreducible terms). For KA, the language model is the regular sets of strings, and for KAT, it is the regular sets of guarded strings <ref type="bibr" target="#b16">[17]</ref>. NetKAT also has a language model. It consists of regular subsets of a restricted class of guarded strings</p><formula xml:id="formula_25">I = A • (Π • dup)* • Π. Each string in this set has the form α • π0 • dup • π1 • dup • • • dup • πn</formula><p>for some n ≥ 0. These strings represent the minimal nonzero elements of the standard model of NetKAT.</p><p>Figure <ref type="figure" target="#fig_5">7</ref> defines the language model as a mapping G from reduced NetKAT expressions to regular subsets of I. The case for sequential composition makes use of the concatenation operator ( ) over strings from I, which we lift to concatenation of sets of guarded strings from I. Both definitions appear at the bottom of Figure <ref type="figure" target="#fig_5">7</ref>. Note that is a partial function on strings but a total function on sets of strings. Using the simplified axioms of Figure <ref type="figure">6</ref>, it is easy to show that is associative on strings and sets, distributes over union, and has two-sided identity {α</p><formula xml:id="formula_26">• πα | α ∈ A}. Also note that if α • p • π β • q • π exists, then α • p • π • β • q • π ≡ α • p • π β • q • π ∈ I and otherwise: α • p • π • β • q • π ≡ 0</formula><p>Having defined the language model, we now show that it is isomorphic to the standard packet model presented in Section 3. We first show that the standard semantics of every NetKAT expression is equal to the union of its minimal nonzero terms. 1 The proof is straightforward by induction on p. Finally, using Lemmas 4 and 5, we conclude that the language model is isomorphic to the denotational model presented earlier.</p><p>Lemma 6. For all policies p and q, we have p = q if and only if G(p) = G(q). 1 We abuse notation slightly here by applying the union operator S to functions H → P(H). This is interpreted pointwise: S p = λs . S p (s).</p><p>Step 3: Normal forms. Next we a normal form for NetKAT policies and prove that every policy is provably equivalent to one in normal form.</p><formula xml:id="formula_27">Definition 1. A NetKAT policy p is in normal form if R(p) ⊆ I.</formula><p>A policy is normalizable if it is provably equivalent to a policy in normal form.</p><p>Lemma 7. Every policy p is normalizable.</p><p>Proof. The inductive proof requires a slightly strengthened inductive hypothesis. Let us say that a policy is in strong normal form if it is in normal form and is a sum of zero or more guarded policies, where a policy is guarded if it is of the form either α</p><formula xml:id="formula_28">• π • x • π or α • π.</formula><p>We show by induction on p that every policy is equivalent to a policy in strong normal form.</p><p>The cases for atomic policies are straightforward:</p><formula xml:id="formula_29">h ← n ≡ P α∈A α • π α dup ≡ P α∈A α • πα • dup • πα b ≡ P α≤b α • πα</formula><p>The case for union is trivial, and the case for sequential composition follows by a simple argument:</p><formula xml:id="formula_30">" P i si « • P j tj ! ≡ P i P j si • tj ≡ P i P j si tj.</formula><p>The most interesting case is for Kleene star. Consider an expression p*, where p is in strong normal form. We first prove the uniform case: when all guarded terms in p have the same initial atom α, that is, p = α • t where t is a union of terms each with a leading and trailing π, and R(t) ⊆ Π • (dup • Π)*. Let u be t with all terms whose trailing π is not πα deleted and with the trailing πα deleted from all remaining terms. By the simplified axioms of Figure <ref type="figure">6</ref>, we have t</p><formula xml:id="formula_31">• α • t ≡ u • t, therefore t • α • t • α ≡ u • t • α. Using KAT-COMMUTE [2, Lemma 4.4], (t • α)* • t ≡ t + t • α • (t • α)* • t ≡ t + u* • t • α • t ≡ t + u* • u • t ≡ u* • t,</formula><p>and hence</p><formula xml:id="formula_32">p* ≡ 1 + p* • p ≡ 1 + (α • t)* • α • t ≡ 1 + α • (t • α)* • t ≡ 1 + α • u* • t ≡ 1 + α • t + α • u • u* • t,</formula><p>which after normalizing the 1 is in strong normal form. For the case p* where the initial tests in p are not uniform, the argument is by induction on the number of terms in the union. If p = α •x+q, then by the inductive hypothesis, q* has an equivalent strong normal form q*. Using KAT-DENESTING (Figure <ref type="figure" target="#fig_3">4</ref>), we obtain</p><formula xml:id="formula_33">p* ≡ (α • x + q)* ≡ q* • (α • x • q*)* ≡ q* • (α • x • q*)*,</formula><p>then proceed as in the previous case.</p><p>Step 4: Completeness. We need just one more lemma before delivering the completeness result, which says that the regular interpretation and language model coincide for NetKAT policies in normal form.</p><formula xml:id="formula_34">Lemma 8. If R(p) ⊆ I, then R(p) = G(p).</formula><p>Proof. Suppose R(p) ⊆ I. It is straightforward to show that G(p) is equal to the union of the elements of R(p), by induction on p:</p><formula xml:id="formula_35">G(p) = [ x∈R(p) G(x).</formula><p>Then, since G(x) = {x} for x ∈ I, we have</p><formula xml:id="formula_36">G(p) = [ x∈R(p) {x} = R(p).</formula><p>The proof of completeness for NetKAT now follows from the completeness of KA <ref type="bibr" target="#b11">[12]</ref>.</p><p>Theorem 2 (Completeness). Every semantically equivalent pair of NetKAT expressions is provably equivalent using the NetKAT axioms. That is, if p = q , then p ≡ q.</p><p>Proof. Let p and q be the normal forms of p and q. By Lemma 7, we can prove that each is equivalent to its normal form: p ≡ p and q ≡ q. By soundness we have p = p and q = q , hence p = q . By Lemma 6, we have G(p) = G(q). Moreover, by Lemma 8, we have G(p) = R(p) and G(q) = R(q), thus R(p) = R(q). Since R(p) and R(q) are regular sets, we have p ≡ q by the completeness of KA. Finally, as p ≡ p and q ≡ q and p ≡ q, we conclude that p ≡ q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Decidability</head><p>The final theorem presented in this section shows that deciding the equational theory of NetKAT is no more nor less difficult than for KA or KAT. Theorem 3. The equational theory of NetKAT is PSPACE-complete.</p><p>Proof sketch. To show PSPACE-hardness, reduce KA to NetKAT as follows. Let Σ be a finite alphabet. For a regular expression e over Σ, let R(e) be the regular set of strings over Σ as defined in §4. Transform e to a NetKAT expression e by replacing each occurrence in e of a symbol p ∈ Σ with (p • dup) and prepending with an arbitrary but fixed atom α. It follows from Lemmas 6 and 8 that R(e1) = R(e2) if and only if R(e 1 ) = R(e 2 ) if and only if G(e 1 ) = G(e 2 ) if and only if e 1 = e 2 .</p><p>To show that the problem is in PSPACE, given two NetKAT expressions e1 and e2, we know that e1 = e2 if and only if there is a packet pk and packet history h such that h ∈ e1 (pk ) \ e2 (pk ) or h ∈ e2 (pk ) \ e1 (pk ); let us say the former without loss of generality. We guess pk nondeterministically and follow a nondeterministically-guessed trajectory through e1 that produces some h ∈ e1 (pk ). At the same time, we trace all possible trajectories through e2 that could generate a prefix of h, ensuring that none of these produce h ∈ e2 . It takes only polynomial space to represent the current values of the fields of the head packet and the possible positions in e2 for the current prefix of h. The algorithm is nondeterministic, but can be made deterministic using Savitch's theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Reachability Properties</head><p>Network administrators often ask questions such as, "Can all hosts talk to each other?", or "Are managed hosts kept separate from unmanaged hosts?", or "Does all untrusted traffic traverse the intrusion detection system?", and so on. Automated tools for answering these and other questions about reachability properties have been the focus of several recent research projects <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b18">19]</ref>. Most existing tools work by encoding the topology and policy as a logical structure, and then translating the reachability property into a formula whose satisfiability can be checked using a SAT solver or other tool. This section presents a different approach: we show how to encode two important classes of reachability properties as NetKAT equations. We then prove the equations are sound and complete with respect to intuitive, semantic definitions of reachability using the language model developed in Section 4.</p><p>The simplest reachability properties answer questions such as, "Can host A send packets to host B?" If A can send packets to B, then the denotational model of the network must include a packet history that starts from host A and ends at host B: pk B , • • • , pk A . More generally, we can ask if packets satisfying some predicate a can be transformed so that they satisfy some predicate b. These predicates may denote single hosts, groups of hosts, or even arbitrary classes of traffic, such as Web traffic.</p><p>To reason about reachability, we use a small generalization of the logical crossbar model introduced in Section 2. In the logical crossbar model, we model the end-to-end behavior of the network using the following NetKAT expression,</p><formula xml:id="formula_37">in • (p • t)* • out</formula><p>where p and t define the behavior of switches and links as dupfree NetKAT policies. Because the policy does not contain dup, it does not record the individual "hops" that packets take as they go through the network. To do this, we must augment the logical crossbar to record the state of the packet at each intermediate hop:</p><formula xml:id="formula_38">in • dup • (p • t • dup)* • out</formula><p>Using this encoding, we can define reachability as follows:</p><p>Definition 2 (Reachability). We say b is reachable from a if and only if there exists a trace</p><formula xml:id="formula_39">pk 1 , • • • , pk n ∈ rng( dup • (p • t • dup)* ) such that a pk n = { pk n } and b pk 1 = { pk 1 }.</formula><p>To decide whether b is reachable from a we check the following NetKAT equivalence:</p><formula xml:id="formula_40">a • dup • (p • t • dup)* • b ≡ 0</formula><p>Intuitively, the prefix predicate, a, filters the policy to only include histories that begin with packets satisfying a. Similarly, the postfix predicate, b, filters the policy to only include histories that end with packets satisfying b. We do need to prove that this equation holds if and only if b is reachable from a. The key to the proof is to translate both the denotational definition of reachability and the reachability equation to the language model, where they are easy to relate. Theorem 4 (Reachability Correctness). For predicates a and b, policy p, and topology t, a</p><formula xml:id="formula_41">• dup • (p • t • dup)* • b ≡ 0, if and only if b is reachable from a.</formula><p>Proof. We translate the NetKAT equation into the language model:</p><formula xml:id="formula_42">a • dup • (p • t • dup)* • b ≡ 0 ⇒ ∃α, πn, • • • , π1. α • πn • dup • • • dup • π1 ∈ G(a • dup • (p • t • dup)* • b)</formula><p>We also translate each term in the semantic definition of reachability into the language model:</p><formula xml:id="formula_43">∃pk 1 , • • • , pk n . pk 1 , • • • , pk n ∈ rng( dup • (p • t • dup)* ), a pk n = { pk n } and b pk 1 = { pk 1 } ⇒ ∃π 1 , • • • , π m . α π m • π m • dup • • • dup • π 1 ∈ G(dup • (p • t • dup)*), α π m • π m ∈ G(a) and α π 1 • π 1 ∈ G(b)</formula><p>To prove soundness we let α = απ n and m = n to show that if Waypointing. A waypoint, w, from a to b is a location that all packets traverse en route from a to b. For example, a network operator might want to ensure that all traffic from untrusted hosts to trusted hosts traverses a firewall.</p><formula xml:id="formula_44">α • πn • dup • • • dup • π1 ∈ G(a • dup • (p • t • dup)* • b) then, α π m • π m • dup • • • dup • π 1 ∈ G(dup • (p • t • dup)*)</formula><p>Definition 3 (Waypoint). We say w is a waypoint from a to b, if and only if, for all histories</p><formula xml:id="formula_45">pk 1 • • • pk n ∈ rng( dup • (p • t • dup)* )</formula><p>where a pk n = { pk n } and b pk 1 = { pk 1 }, there exists a pk x ∈ pk 1 • • • pk n such that:</p><formula xml:id="formula_46">• w pk x = { pk x },</formula><p>• b pk i = {} for all 1 &lt; i &lt; x, and • a pk j = {} for all x &lt; j &lt; n.</p><p>To decide whether w is a waypoint from a to b, we check the following NetKAT inequality:</p><formula xml:id="formula_47">a • dup • (p • t • dup)* • b ≤ a • dup • (¬b • p • t • dup)* • w • (¬a • p • t • dup)* • b</formula><p>The left-hand side is exactly hop-by-hop reachability from a to b. The right-hand side is also a hop-by-hop expression, but it has a predicate to check that packets traverse w. Furthermore, it tests that packets do not prematurely visit b before w or return to a after reaching w.</p><p>Theorem 5 (Waypoint Correctness). For predicates a, b, and w,</p><formula xml:id="formula_48">a • dup • (p • t • dup)* • b ≤ a • dup • (¬b • p • t • dup)* • w • (¬a • p • t • dup)* • b</formula><p>if and only if all packets from a to b are waypointed through w.</p><p>Proof. Similar to the proof of reachability correctness above. See the long version of this paper for the full proofs.</p><p>Using these encodings and theorems as building blocks, we can develop techniques for checking other reachability properties as well. For example, we can check for self-loops, test whether a firewall policy is correctly implemented, and string together multiple waypoints into composite tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Traffic Isolation</head><p>NetKAT's policy combinators help programmers construct complex network policies out of simple parts. The most basic combinator is union, which combines two policies by taking the union of the results generated by the sub-policies. However, naive use of union can lead to undesirable results, because each sub-policy may receive and modify packets intended for the other sub-policy.</p><p>Example. Consider the network in Figure Suppose the task of routing traffic between hosts 1 and 2 has been assigned to one programmer, while the task of routing traffic between hosts 3 and 4 has been assigned to another programmer. The first programmer might produce the following policy for switch B,</p><formula xml:id="formula_49">pB1 sw = B • (pt = 6 • pt ← 2 + pt = 2 • pt ← 6)</formula><p>and the second programmer might produce a similar switch policy for B. This second policy differs from the first only by sending traffic from port 6 out port 4 rather than port 2:</p><formula xml:id="formula_50">pB2 sw = B • (pt = 6 • pt ← 4 + pt = 4 • pt ← 6)</formula><p>Similar policies pA1 and pA2 define the behavior at switch A. Now, if we assume t captures the topology of the network properly, then</p><formula xml:id="formula_51">((pA1 + pB1) • t)*</formula><p>correctly sends traffic from host 1 to host 2. However, when the second policy is added in, (((pA1 + pB1) + (pA2 + pB2)) • t)* packets sent from host 1 will be copied to host 4 as well as host 2. In this instance, union actually produces too many behaviors. In the best case, sending additional packets to host 4 from host 1 leads to unnecessary congestion. In the worst case, it may violate the security policy for host 1. Either alternative demonstrates the need for better ways of composing forwarding policies.</p><p>Slices. A network slice <ref type="bibr" target="#b7">[8]</ref> is a lightweight abstraction that facilitates modular construction of policies. Intuitively, a slice defines a piece of the network that can be programmed independently of the rest of the network. The boundaries of a slice are defined by ingress (in) and egress (out) predicates, while the behavior in the slice is determined by the internal policy p. Each slice also has unique identifier (w) to differentiate it from other slices. <ref type="foot" target="#foot_0">2</ref>Packets that match in are injected into the slice. Once in a slice, packets stay in the slice and obey p until they match the predicate out, at which point they are ejected. We write slices as follows:</p><formula xml:id="formula_52">{in} w : (p) {out}</formula><p>where in and out are the ingress and egress predicates and p defines the internal policy.</p><p>To define slices in NetKAT, we begin by picking a header field, for example, tag, to record the packet's current slice. <ref type="foot" target="#foot_1">3</ref> In order for our elaboration to have the desired properties, however, the tag field must not be used elsewhere in the policy or in the ingress or egress predicates. We call a predicate tag-free if it commutes with any modification of the tag field, and a policy tag-free if it commutes with any test of the tag field.</p><p>Given tag-free predicates in, out and policy p, and a tag w0 representing packets not in any slice, we can compile a slice into NetKAT as follows:</p><formula xml:id="formula_53">{in} w : (p) {out} w 0 let pre = (tag = w0 • in • tag ← w + tag = w) in let post = (out • tag ← w0 + ¬out) in (pre • p • post)</formula><p>Compilation wraps the slice policy with pre-and post-processing policies, pre and post. The pre policy tests whether a packet (i) is outside the slice (tagged with w0) and matches the ingress predicate, in which case it is injected by tagging it with w, or (ii) has already been injected (already tagged with w). Once injected, packets are processed by p. If p emits a packet that matches the egress predicate out, then post strips the tag, restoring w0. Otherwise, the packet remains in the slice and is left unmodified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Isolation.</head><p>A key property of slices is that once a packet enters a slice, it is processed solely by the policy of that one slice until it is ejected, even across multiple hops in the topology. The following theorem captures this idea more precisely.</p><p>Theorem 6 (Slice Composition). For all tag-free slice ingress and egress predicates in and out, identifiers w, policies s, q, tag-free policies p, and topologies t, if</p><formula xml:id="formula_54">• s = {in} w : (p) {out} w 0 , • w = w0, • out • t • dup • q ≡ 0, • q • t • dup • in ≡ 0,</formula><p>• q drops w-tagged traffic, then</p><formula xml:id="formula_55">((s + q) • t • dup)* ≡ (s • t • dup)* + (q • t • dup)*.</formula><p>In a nutshell, this theorem says that executing the union of s and q is the same as sending packets through two separate copies of the network, one containing the slice and the other containing q. The proof of the theorem is by equational reasoning and makes use of the KAT-DENESTING theorem from Figure <ref type="figure" target="#fig_3">4</ref>.</p><p>An interesting corollary of the result above is that when the ingress slice boundary of s and the domain of q do not overlap, for traffic destined for the ingress of s, the union of s and q is equivalent to s alone.</p><p>Corollary 1. For all tag-free slice ingress and egress predicates in and out, identifiers w, policies s, q, and topologies t, such that</p><formula xml:id="formula_56">• s = {in} w : (p) {out} w 0 , • w = w0, • out • t • dup • q ≡ 0, • q • t • dup • in ≡ 0, • in • q ≡ 0, then in • tag = w0 • ((s + q) • t • dup)* ≡ in • tag = w0 • (s • t • dup)*</formula><p>Corollary 1 connects to traditional language-based information flow properties <ref type="bibr" target="#b26">[27]</ref>. If s defines public, low-security data and q defines private, high security data, the corollary implies that the observable behavior of the network remains unchanged regardless of whether the high-security data (q) is present, absent, or replaced by some alternate high security data (q ). Example, redux. Slices provide a solution to the scenario described in the example at the beginning of the section. We can assign each programmer a unique slice with boundaries that correspond to the locations of the end hosts under control of that slice. For instance, the first programmer's in and out predicates include the network access points for hosts 1 and 2, while the second programmer's in and out predicates include the network access points for hosts 3 and 4.  The original difficulty with this example was caused by packet duplication when, for example, a packet was sent from host 1 to host 2. Corollary 1 proves that we can use slices to solve the problem: host 1 is connected to slice 1, and restricting the input to that of slice 1 implies that the behavior of the entire program is precisely that of slice 1 alone.</p><formula xml:id="formula_57">in1 sw = A • pt = 1 + sw = B • pt = 2 out1 sw = A • pt = 1 + sw = B • pt = 2 s1 {in1} w1 : (pA1 + pB1) {out1} in2 sw = A • pt = 3 + sw = B • pt = 4 out2 sw = A • pt = 3 + sw = B • pt = 4 s2 {in2} w2 : (pA2 + pB2) {out2}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Compilation</head><p>In order to execute a NetKAT program on an OpenFlow switch, we must compile it to a flow table, the low-level programming abstraction that OpenFlow supports. A flow table is a prioritized list of rules, where each rule consists of a pattern to match packet headers and actions to apply to matching packets. When a packet arrives at a switch, the actions associated with the highest priority matching rule are applied to it.</p><p>For example, the flow table on the left-hand side of figure 9 blocks SSH packets, but forwards all other traffic between ports 1 and 2. Alongside the flow table is an equivalent NetKAT policy. To make the connection between these two equivalent representations obvious, we introduce a conditional construct as shorthand:</p><formula xml:id="formula_58">if b then as else def = (b as) + (¬b • )</formula><p>Logically, a flow table pattern is a conjunction of positive literals, and each action is a combination of modifications. We can interpret prioritized rules as cascades of conditional expressions. In this section we describe the design of a compiler based on this idea.</p><p>The input to the compiler is NetKAT without dup or sw := n terms. These constructs are necessary to model network topology, but the output produced by the compiler is meant to execute on switches. Therefore, it is reasonable to exclude these features. The output of the compiler is a stylized subset of NetKAT called Open-Flow Normal Form (ONF). An ONF policy is a sum of conditional cascades, where each cascade is guarded by a test for a switch:</p><formula xml:id="formula_59">(sw = sw 1 • 1) + • • • + (sw = sw n • n)</formula><p>Each term can be interpreted as a complete flow table for a given switch. Figure <ref type="figure" target="#fig_0">10</ref> presents the full grammar for ONF. Mapping ONF to flow tables, is mostly straightforward, and many of the low-level details have been addressed in previous work <ref type="bibr" target="#b6">[7]</ref>.</p><p>The rest of this section outlines the major steps required to compile NetKAT to ONF. Each step eliminates or restricts an element of NetKAT syntax. In other words, each step translates from one intermediate representation to another until we arrive at ONF. We write NetKAT -(op) to denote NetKAT expressions that do not use the op operator. For example, if: p ∈ NetKAT -(dup,sw←) then p does not contain dup and does not modify the sw field. This is the source language for the compiler, as described above.</p><p>Step 1: Star elimination. The first step is to eliminate Kleene star from the input policy. This step is critical as switches do not support iterated processing of packets-indeed, many switches only support a single phase of processing by a table! Formally, we prove that any program without dup, or, less importantly, assignment to sw, is equivalent to a Kleene star-free program (again without the dup primitive or assignments to sw).</p><p>Lemma 9 (Star Elimination). If p ∈ NetKAT -(dup,sw←) , then there exists p ∈ NetKAT -(dup,sw←, * ) where p ≡ p .</p><p>Proof. We show that p can be obtained from the normal form used in the completeness theorem. More specifically, let p be the policy obtained from p by the normalization construction of Lemma 7. By construction, dup can only appear in the normal form of an expression already containing dup, so p cannot contain dup. R(p ) ⊆ I and p does not contain dup, so R(p ) ⊆ At • P . Therefore, p does not contain Kleene star.</p><p>Let us now prove that any assignment of the form sw ← swi in p is preceded in the same term by the corresponding test sw = swi. Because p does not contain any assignment of the form sw ← sw i, it commutes with any test of the form sw = sw i. Therefore p also commutes with any test of the form sw = sw i. It follows that p can be written as a sum of α •p for some atom α and complete assignment p. Suppose for a contradiction that term, α contains a test sw = sw i, and p contains an assignment sw ← sw j , with sw i = sw j . Then</p><formula xml:id="formula_60">α • (sw = sw i) • p • (sw = sw j ) ≥ α • p = 0 α • (sw = sw j ) • p • (sw = sw i) = 0</formula><p>but those two terms are also equal, which is a contradiction.</p><p>Therefore any assignment of the form sw ← swi in p is preceded, in the same term, by the corresponding test sw = swi, and can be removed using axiom PA-FILTER-MOD to produce the desired p . Tests and assignments to other fields than sw could appear in between, but we can use the commutativity axioms PA-MOD-MOD-COMM and PA-MOD-FILTER-COMM to move the assignment sw ← swi to just after the test sw = swi.</p><p>Step 2: Switch specialization. Next, we show that every star-free policy can be specialized for the switches in the network. This transformation allows us to remove nested tests of the sw field and put the policy into a form where it can easily be compiled into a flow table for each switch.</p><p>Lemma 10 (Switch Specialization). If p ∈ NetKAT -(dup,sw←, * ) , then for all switches sw i, there exists p ∈ NetKAT -(dup,sw←, * ,sw) such that sw = sw i • p ≡ sw = sw i • p .</p><p>Proof. Let g be the unique homomorphism of NetKAT defined on primitive programs by:</p><formula xml:id="formula_61">g(sw = sw ) ( 1 if sw = sw i 0 otherwise g(f ← v) f ← v g(dup) dup</formula><p>For every primitive program element x of NetKAT -(dup,sw←, * ) , we have both: By the definition of g, any occurrence of sw = v in p is replaced by either 1 or 0 in g(p). Moreover, since p ∈ NetKAT -(dup,sw←, * ) , it follows that g(p) does not contain any occurrence of sw = v and since p = g(p) ∈ NetKAT -(dup,sw←, * ,sw) we also have</p><formula xml:id="formula_62">sw = sw i • x ≡ g(x) • sw = sw i g(x) • sw = sw i ≡ sw = sw i • g(x) (if dst = A then pt 1 else 0) + (if src = B then pt := 2 else 0) = if dst = A • src = B</formula><formula xml:id="formula_63">sw = sw i • p ≡ sw = sw i • p</formula><p>Step 3: Converting to ONF. The third step is to compile policies in NetKAT -(dup,sw←, * ,sw) to ONF. This is a recursive procedure that first compiles sub-policies to ONF.</p><p>To calculate the union of two ONF policies, we take the crossproduct of the predicates and actions. This procedure is based on earlier work <ref type="bibr" target="#b22">[23]</ref>, but we present a purely syntactic proof of correctness. Figure <ref type="figure" target="#fig_0">11</ref> shows an example of compiling policy union, which illustrates why the cross-product construction is necessary.</p><p>Calculating the sequence of two ONF policies is more involved, since we have to commute the modifications in the first policy with the tests in the second policy to produce a single if-thenelse cascade, as illustrated in figure <ref type="figure" target="#fig_1">12</ref>. As the NetKAT axiom PA-MOD-FILTER-COMM shows, modifications and tests commute naively only if they affect distinct fields. The compiler has several transformations to ensure that various kinds of overlapping tests and modifications do commute.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 11 (Switch-local Compilation).</head><p>If p ∈ NetKAT -(dup,sw←, * ,sw) then there exists a policy p such that p ≡ p and p ∈ ONF.</p><p>The proof goes by induction on the structure of p.</p><p>Step 4: Combining results. Lemmas 9, 10 and 11 suffice to prove any policy p in NetKAT -(dup,sw←) may be converted to OpenFlow normal form.</p><p>Theorem 7 (ONF). If pin ∈ NetKAT -(dup,sw←) then there exists pout ≡ pin such that pout ∈ ONF.</p><p>Optimizations. Naive compilation of network programs can produce flow tables that are unmanageably large <ref type="bibr" target="#b22">[23]</ref>. Hence, existing systems implement optimizations to generate smaller tables. For example, the following lemma describes a common optimization called fall-through elimination, which removes unnecessary rules from the table.</p><p>Lemma 12 (Fall-through Elimination). If b1 ≤ b2 then if b1 then as else if b2 then as else ≡ if b2 then as else</p><p>We plan to study further optimizations in future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related Work</head><p>Kleene algebra is named for its inventor, Stephen Cole Kleene. Much of the basic algebraic theory of KA was developed by John Horton Conway <ref type="bibr" target="#b3">[4]</ref>. Kleene algebra with tests was introduced by Kozen <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>. KA and KAT have been successfully applied in many practical verification tasks, including verification of compiler optimizations <ref type="bibr" target="#b15">[16]</ref>, pointer analysis <ref type="bibr" target="#b21">[22]</ref>, concurrency control <ref type="bibr" target="#b2">[3]</ref>, and device drivers <ref type="bibr" target="#b14">[15]</ref>. This is the first time KA has been used as a network programming language or applied to verification of networks. The proof of the main result in this paper-completeness of the equational axioms-is based on a novel model of KAT.</p><p>While many other systems have been proposed for analyzing networks, we believe ours is the first to provide a complete, highlevel algebra for reasoning about network programs as they are written. Systems such as Anteater <ref type="bibr" target="#b18">[19]</ref>, FlowChecker <ref type="bibr" target="#b0">[1]</ref>, Header Space Analysis <ref type="bibr" target="#b9">[10]</ref>, VeriFlow <ref type="bibr" target="#b10">[11]</ref>, and Formally Verifiable Networking <ref type="bibr" target="#b32">[33]</ref>, encode information about network topology and forwarding policies into SAT formulae (Anteater), graph-based representations (VeriFlow, Header Space Analysis), or higher-order logic (Formally Verifiable Networking). These systems then define custom algorithms over these models to check specific properties such as reachability or packet loss. Such systems can check for violations of important network invariants, but do not provide sound and complete systems for reasoning directly about programs. Moreover, although these systems have expressive languages for encoding properties, they do not connect these encodings back to denotational or operational models of the network. In contrast, in section 5, we show how to encode a reachability property as a NetKAT equation and then prove that the reachability equation is equivalent to a semantic definition of reachability.</p><p>As a programming language, NetKAT is most similar to Net-Core <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b22">23]</ref> and Pyretic <ref type="bibr" target="#b23">[24]</ref>, which both stemmed from earlier work on Frenetic <ref type="bibr" target="#b5">[6]</ref>. NetCore defined the fragment of NetKAT with filters, modification and union, and Pyretic extended NetCore with sequential composition (although Pyretic has neither a formal semantics nor a compiler). Neither language defined an equational theory for reasoning about programs, nor did they include Kleene star-unlike these previous languages, NetKAT programs can describe potentially infinite behaviors.</p><p>NDLog <ref type="bibr" target="#b17">[18]</ref> is a logic programming language with an explicit notion of location and a distributed execution model. In contrast to NDLog, NetKAT and NetCore are designed for programming centralized (not distributed) SDN controllers. Because NDLog is based around Datalog (with general recursion and pragmatic extensions that complicate its semantics), equivalence of NDLog programs is undecidable <ref type="bibr" target="#b28">[29]</ref>. NetKAT's Kleene star is able to model network behavior, but has decidable (PSPACE-complete) equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusion</head><p>This paper presents NetKAT, a new language for SDN programming and reasoning that is based on a solid semantic foundation-Kleene algebra with tests. NetKAT's denotational semantics describes network programs as functions from packet histories to sets of packets histories and its equational theory is sound and complete with respect to this model. The language enables programmers to create expressive, compositional network programs and reason effectively about their semantics. We demonstrate the power of our framework on a range of practical applications including reachability, traffic isolation, access control, and compiler correctness.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Example network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. NetKAT: syntax, semantics, and equational axioms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. NetKAT algebraic and surface syntax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. KAT theorems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Code motion proofs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. NetKAT language model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 4 .Lemma 5 .</head><label>45</label><figDesc>For all policies p, we have p = S x∈G(p) x . Next we prove that every x in I is completely determined by x . If x, y ∈ I, then x = y if and only if x = y.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. A simple network controlled by two parties.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 .Figure 10 .</head><label>910</label><figDesc>Figure 9. A flow table and an equivalent NetKAT policy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 .Figure 12 .</head><label>1112</label><figDesc>Figure 11. Compiling ONF policy union.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The unique identifier w may be defined by the compiler and need not appear in the surface syntax.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>In practice, the vlan field is often used to differentiate different classes of network traffic<ref type="bibr" target="#b33">[34]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The authors wish to thank Timothy Griffin, Shriram Krishnamurthi, Nick McKeown, Jennifer Rexford, the members of the Cornell PLDG, and the POPL reviewers for helpful comments, as well as Alec Story and Stephen Gutz for work on a preliminary version of slices. This work is supported in part by the NSF under grants CNS-1111698, CNS-0931985, CNS-1111520, and SHF-1016937, the ONR under award N00014-12-1-0757, a Sloan Research Fellowship, and a Google Research Award.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">FlowChecker: Configuration analysis and verification of federated OpenFlow infrastructures</title>
		<author>
			<persName><forename type="first">Ehab</forename><surname>Al</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-Shaer</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Saeed</forename><surname>Al-Haj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Safe-Config</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Kleene algebra with tests and program schematology</title>
		<author>
			<persName><forename type="first">Allegra</forename><surname>Angus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
		<idno>TR2001-1844</idno>
		<imprint>
			<date type="published" when="2001-07">July 2001</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Using Kleene algebra to reason about concurrency control</title>
		<author>
			<persName><forename type="first">Ernie</forename><surname>Cohen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>Telcordia, Morristown, N.J.</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">John</forename><surname>Horton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Conway</forename></persName>
		</author>
		<title level="m">Regular Algebra and Finite Machines. Chapman and Hall</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Participatory networking: An API for application control of SDNs</title>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">D</forename><surname>Ferguson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arjun</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rodrigo</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shriram</forename><surname>Krishnamurthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Frenetic: A network programming language</title>
		<author>
			<persName><forename type="first">Nate</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alec</forename><surname>Story</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2011-09">September 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Machine-verified network controllers</title>
		<author>
			<persName><forename type="first">Arjun</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Reitblatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nate</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2013-06">June 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Splendid isolation: A slice abstraction for software-defined networks</title>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Gutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alec</forename><surname>Story</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cole</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nate</forename><surname>Foster</surname></persName>
		</author>
		<editor>HotSDN</editor>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Networking: The last bastion of mainframe computing</title>
		<author>
			<persName><forename type="first">James</forename><surname>Hamilton</surname></persName>
		</author>
		<ptr target="http://tinyurl.com/y9uz64e" />
		<imprint>
			<date type="published" when="2009-12">December 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Header space analysis: Static checking for networks</title>
		<author>
			<persName><forename type="first">Peyman</forename><surname>Kazemian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">VeriFlow: Verifying network-wide invariants in real time</title>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuan</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenxuan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Caesar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Brighten</forename><surname>Godfrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A completeness theorem for Kleene algebras and the algebra of regular events</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">I&amp;C</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="366" to="390" />
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Kleene algebra with tests and commutativity conditions</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<meeting><address><addrLine>Passau, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-03">March 1996</date>
			<biblScope unit="page" from="14" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Kleene algebra with tests</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="427" to="443" />
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Kleene algebras with tests and the static analysis of programs</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
		<idno>TR2003-1915</idno>
		<imprint>
			<date type="published" when="2003-11">November 2003</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Certification of compiler optimizations using Kleene algebra with tests</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maria-Cristina</forename><surname>Patron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CL</title>
		<imprint>
			<date type="published" when="2000-07">July 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Kleene algebra with tests: Completeness and decidability</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frederick</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSL</title>
		<imprint>
			<date type="published" when="1996-09">September 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Ion Stoica, and Raghu Ramakrishnan. Declarative routing: Extensible routing with declarative queries</title>
		<author>
			<persName><forename type="first">Thau</forename><surname>Boon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Debugging the data plane with Anteater</title>
		<author>
			<persName><forename type="first">Haohui</forename><surname>Mai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghit</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Caesar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Brighten</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><forename type="middle">Talmadge</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Extending SDN to large-scale networks</title>
		<author>
			<persName><forename type="first">James</forename><surname>Mccauley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aurojit</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Teemu</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ONS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">OpenFlow: Enabling innovation in campus networks</title>
		<author>
			<persName><forename type="first">Nick</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guru</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Computing Communications Review</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="69" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Calculating with pointer structures</title>
		<author>
			<persName><forename type="first">B</forename><surname>Möller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algorithmic Languages and Calculi. Proc. IFIP TC2/WG2.1 Working Conference</title>
		<imprint>
			<date type="published" when="1997-02">February 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A compiler and run-time system for network programming languages</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nate</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2012-01">January 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Composing software-defined networks</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><surname>Reich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nate</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2013-04">April 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A balance of power: Expressive, analyzable controller programming</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arjun</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Dougherty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathi</forename><surname>Fisler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shriram</forename><surname>Krishnamurthi</surname></persName>
		</author>
		<editor>HotSDN</editor>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Abstractions for network update</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Reitblatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nate</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cole</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Language-based informationflow security</title>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="19" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">Gunther</forename><surname>Schmidt</surname></persName>
		</author>
		<title level="m">Relational Mathematics</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Decidability and expressiveness aspects of logic queries</title>
		<author>
			<persName><forename type="first">O</forename><surname>Shmueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="237" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title/>
		<ptr target="http://frenetic-lang.org" />
	</analytic>
	<monogr>
		<title level="j">The Frenetic Project</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Nettle: Functional reactive programming of OpenFlow networks</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PADL</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Maple: Simplifying SDN programming using algorithmic policies</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junchang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Richard</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bryan</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Boon Thau Loo, Oleg Sokolsky, and Prithwish Basu. Formally veriable networking</title>
		<author>
			<persName><forename type="first">Anduo</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Limin</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changbin</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotNets</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A survey of virtual LAN usage in campus networks</title>
		<author>
			<persName><forename type="first">Minlan</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sanjay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><surname>Feamster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Magazine</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="98" to="103" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
