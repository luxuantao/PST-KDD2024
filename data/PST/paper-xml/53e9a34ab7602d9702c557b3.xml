<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Predictive Dynamic Thermal Management for Multicore Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Chih</roleName><forename type="first">Inchoon</forename><surname>Yeo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Texas A&amp;M University College Station</orgName>
								<address>
									<postCode>77840</postCode>
									<region>TX</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chun</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Texas A&amp;M University College Station</orgName>
								<address>
									<postCode>77840</postCode>
									<region>TX</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Eun</forename><forename type="middle">Jung</forename><surname>Kim</surname></persName>
							<email>ejkim@cs.tamu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Texas A&amp;M University College Station</orgName>
								<address>
									<postCode>77840</postCode>
									<region>TX</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Predictive Dynamic Thermal Management for Multicore Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FA274DC43E364A8D4930D46F41598811</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Reliability</term>
					<term>Availability</term>
					<term>and Serviceability Design</term>
					<term>Experimentation</term>
					<term>Temperature</term>
					<term>Performance Dynamic Thermal Management</term>
					<term>Operating System</term>
					<term>Temperature</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Recently, processor power density has been increasing at an alarming rate resulting in high on-chip temperature. Higher temperature increases current leakage and causes poor reliability. In this paper, we propose a Predictive Dynamic Thermal Management (PDTM) based on Application-based Thermal Model (ABTM) and Core-based Thermal Model (CBTM) in the multicore systems. ABTM predicts future temperature based on the application specific thermal behavior, while CBTM estimates core temperature pattern by steady state temperature and workload. The accuracy of our prediction model is 1.6% error in average compared to the model in HybDTM <ref type="bibr" target="#b8">[8]</ref>, which has at most 5% error. Based on predicted temperature from ABTM and CBTM, the proposed PDTM can maintain the system temperature below a desired level by moving the running application from the possible overheated core to the future coolest core (migration) and reducing the processor resources (priority scheduling) within multicore systems. PDTM enables the exploration of the tradeoff between throughput and fairness in temperature-constrained multicore systems. We implement PDTM on Intel's Quad-Core system with a specific device driver to access Digital Thermal Sensor (DTS). Compared against Linux standard scheduler, PDTM can decrease average temperature about 10%, and peak temperature by 5 • C with negligible impact of performance under 1%, while running single SPEC2006 benchmark. Moreover, our PDTM outperforms HRTM [10] in reducing average temperature by about 7% and peak temperature by about 3 • C with performance overhead by 0.15% when running single benchmark.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Chip multiprocessors (CMPs) have already been employed as the main trend in new generation processors. A CMP includes multiple cores within one single die area to increase the microprocessors' performance. However, the increased complexity and decreased feature sizes have caused very high power density in modern processors. The power dissipated is converted into heat and the processors are pushing the limits of packaging and cooling solutions. The increased operating temperature potentially affects the system reliability. Moreover, leakage power increases exponentially with operating temperature. Increasing leakage power can further raise the temperature resulting in a thermal runaway <ref type="bibr" target="#b3">[3]</ref>. Hence, there is a need to control temperature at all levels of system design.</p><p>Recently, many hardware and software-based Dynamic Thermal Management (DTM) <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14]</ref> techniques have been proposed in sense of that they, except <ref type="bibr" target="#b14">[14]</ref>, start to control the temperature after the current temperature reaches at the critical temperature threshold. Dynamic Thermal Management can be characterized as temporal or spatial. Temporal management schemes, such as Dynamic Frequency Scaling (DFS), Dynamic Voltage Scaling (DVS), clock gating, slowdown the CPU computation to reduce heat dissipation. Although they could effectively reduce temperature, they incur significant performance overhead. On the other hand, spatial management schemes, such as thread migration, can reduce the temperature without throttling the computation <ref type="bibr" target="#b10">[10]</ref>. However, neighboring thermal effect and application thermal behavior are not considered in prior works. Due to packaging technology in CMP, the temperature of each core will be affected by other cores. The temperature differential between cores can be as much as 10 ∼ 15</p><p>• C <ref type="bibr" target="#b11">[11]</ref>. There are significant variations in the thermal behavior among different applications <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b14">14]</ref>.</p><p>Motivated by these facts, we propose a Predictive Dynamic Thermal Management (PDTM) in the context of multicore systems. Our PDTM scheme utilizes an advanced future temperature prediction model for each core to estimate the thermal behavior considering both core temperature and applications temperature variations and take appropriate measures to avoid thermal emergencies. To the authors' best knowledge, no prior attempt has been made to implement the temperature prediction model along with the thermal-aware scheduling on a real four-core product under Linux environment. The experimental results on Intel's Quad-Core system running two SPEC2006 benchmarks simultaneously show the proposed PDTM lowers temperature by about 5% in average and reduces up to 3 • C in peak temperature with only at most 8% performance overhead compared to Linux standard scheduler without DTM. Moreover, to validate the presented PDTM, we also rebuilt HRTM <ref type="bibr" target="#b10">[10]</ref>, and our PDTM outperforms HRTM in reducing average temperature by about 7%, performance overhead by 0.15%, and peak temperature by about 3 • C, while running single benchmark. The main contributions of this paper are summarized as follows:</p><p>• We propose an advanced future temperature prediction model for multicore systems with only 1.6% error in average.</p><p>• We demonstrate that our scheme outperforms the existing DTM schemes (HRTM and HybDTM) and provides thermal fairness among cores.</p><p>• The proposed PDTM incurs low performance overhead which is only 1% when running single benchmark, and 8% when running two benchmarks simultaneously.</p><p>• Most importantly, there is no additional hardware unit required for our prediction model and thermal-aware scheme. It means that our model and scheme is scalable for all the multicore systems and can be applied to real-world CMP products.</p><p>The remainder of the paper is organized as follows : The existing DTM will be introduced in Section 2. Section 3 provides the explanation of proposed temperature prediction model-ABTM and CBTM in detail. In Section 4, we explain the system overview of PDTM and how to apply PDTM in multicore systems. In Section 5, the implementation and analysis results are discussed and conclusions are provided in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Several thermal control techniques have been proposed and applied in modern processors via either hardware-based or software mechanisms <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b12">12]</ref>. Hardware-based DTM mechanisms, such as Dynamic Frequency Scaling (DFS) and Dynamic Voltage Scaling (DVS), as well as clock gating, are able to effectively reduce processor's temperature and guarantee thermal safety, but with high execution performance overhead. Therefore, as the multicore processors become popular, some software-based mechanisms, such as power density management in a CMP has been studied in <ref type="bibr" target="#b10">[10]</ref>. The proposed mechanism, called heat-and-run, has two key components: SMT thread assignment and CMP thread migration. Within heat-and-run the SMT thread assignment attempts to increase processor-resource utilization by coscheduling threads which use complementary resources; on the other hand, the CMP thread migration cools overheated cores by migrating threads away from overheated cores and assigning them to free SMT contexts on alternate cores to maintain throughput while allowing cooling overheated cores. They showed that for four cores CMP running five threads, heat-and-run thread assignment (HRTA) and heat-and-run thread migration (HRTM) achieve 9% higher average throughput than stop-go and 6% higher average throughput than DVS. Moreover, when performance is constrained by temperature, the performance gains brought by thread migration and the importance of limiting the migration frequency to reduce performance overhead has been confirmed in <ref type="bibr" target="#b9">[9]</ref>. In <ref type="bibr" target="#b9">[9]</ref>, a new migration method for temperature-constrained multicore is proposed to exchange threads whenever the simultaneous occurrence of a cold and a hot core is detected. The authors demonstrate that their method yields the same throughput with HRTM, but requires much less migrations. However, both of these two works above are based on simulated results, and neglect the thermal-correlation between cores. The power dissipated by the rest of the chip is assumed to be negligible. Most importantly, the migration action in <ref type="bibr" target="#b9">[9]</ref> above is triggered by the current temperature (when the temperature is higher than maximum allowed temperature) in these two papers; however, instead of considering the current temperature, we believe that an accurate future temperature prediction model could perform better in lowering the peak temperature.</p><p>In <ref type="bibr" target="#b8">[8]</ref>, HybDTM, a methodology for fine-grained, coordinated thermal management using both software (priority scheduling) and hardware (clock gating) techniques, is proposed. In order to estimate temperature, HybDTM proposed a regression-based thermal model based on using hardware performance counters. However, HybDTM can not effectively reduce overheat temperature without performance overhead, because real temperature cannot be estimated solely by hardware performance counter, and both of priority scheduling and clock gating will introduce high performance overhead. Their performance overhead is 9.9% compared to the case without any DTM. Therefore, we propose PDTM which includes an advanced future temperature prediction model with very low performance overhead for the real-world product (Intel's Quad-Core). Rather than using the performance counter for temperature, we utilize the regression analysis for application-based thermal behavior as fine-grained scheme, and core-based thermal behavior as coarse-grained scheme to provide very accurate temperature prediction model for DTM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PREDICTIVE THERMAL MODEL</head><p>In this section, we present a thermal model to predict the future temperature at any point during the execution of a specific application. The model is based on our observation that the rate of change in temperature during the execution of an application depends on the difference between the current temperature and the steady state temperature of the application<ref type="foot" target="#foot_1">1</ref> . Moreover, the thermal behavior is different among applications. Since the system temperature is affected by both each application's thermal behavior and each processors thermal pattern, we define the applicationbased thermal model and the processor-based thermal model in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Application-based Thermal Model</head><p>The Application-based Thermal Model (ABTM) accommodates short-term thermal behavior in order to predict the future temperature in fine-grained. As shown in Figure <ref type="figure" target="#fig_0">1</ref>, there are rapid temperature changes even when the workload is statically 100%. Specifically, this model first derives the thermal behavior from local intervals (short term temperature reactions) and then predicts the future temperature by incorporating this behavior into a regression based approach that is known as the Recursive Least Square Method (RLSM). In the general least-squares problem, the output of a linear model y is given by the linear parameterized expression</p><formula xml:id="formula_0">y = θ1f1(u) + θ2f2(u) + • • • + θnfn(u),<label>(1)</label></formula><p>where u = [u1 ,u2 ,• • • ,un ] is the model's input vector, f1,...,fn are known functions of u, and θ1, θ2,...,θn are unknown parameters to be estimated. In our study, let the input vector, u, and the output vector, y, be time units and working temperature respectively. To identify the unknown parameters θi, experiments usually have to be performed to obtain a training data set composed of data pairs (ui ;yi ), i = 1,• • • ,m}. Expressed in matrix notation, the following equation can be obtained: Y = Xθ where X is an m × n matrix:</p><formula xml:id="formula_1">X =    f1(u1) • • • fn(u1) . . . . . . . . . f1(um) • • • fn(um)   <label>(2)</label></formula><p>θ is a n × 1 unknown parameter vector:</p><formula xml:id="formula_2">θ = [θ1, θ2, ..., θn] T (<label>3</label></formula><formula xml:id="formula_3">)</formula><p>and Y is a n×1 output vector:</p><formula xml:id="formula_4">Y = [Y1, Y2, ..., Yn] T (4)</formula><p>If X T X is nonsingular, the least square estimator can be derived as</p><formula xml:id="formula_5">θ = (X T X) -1 X T Y,<label>(5)</label></formula><p>Denote the i th row of the joint data matrix [X : Y ] by [X T i : Yi]. Suppose that a new data pair [X T k+1 : Y k+1 ] becomes available as the (k + 1) th entry in the data set. To avoid recalculating the least squares estimator using all input and output data samples, let P k = (X T X) -1 for the k th in Equation <ref type="bibr" target="#b5">(5)</ref>. Likewise, the recursive least square method at (k + 1) th can be developed as where y k+1 is the output vector and x k+1 is input vector of of f k+1 .</p><formula xml:id="formula_6">P k+1 = P k - P k x k+1 x T k+1 P k 1 + y T k+1 P k y k+1 ,<label>(6)</label></formula><formula xml:id="formula_7">θ k+1 = θ k + P k+1 x k+1 (y k+1 -x T k+1 θ k )<label>( 7 )</label></formula><p>where matrix P is an intermediate variable in the algorithm. Eventually, we get future temperature, yn, by an application thermal behavior using the current θ vector. Detailed descriptions of the Least Square Method and Recursive Least Square Method can be found in the literatures <ref type="bibr" target="#b4">[4]</ref>. With Equation ( <ref type="formula" target="#formula_0">1</ref>), ABTM can predict future temperature for an application as shown in Figure <ref type="figure" target="#fig_1">2</ref>. How the ABTM applied in PDTM is explained in 3.3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Core-based Thermal Model</head><p>The heat transfer equations model the steady state temperature of systems with heat sources <ref type="bibr">[7]</ref>. It has been observed in those models that the temperature changes exponentially to the steady state starting from any initial temperature. In other words, the rate of temperature change is proportional to the difference between the current temperature and the steady state <ref type="bibr">[7]</ref>. We initially assume that the steady state temperature of the application is known. Later we will relax this constraint. Let Tss be the steady state temperature of an application. Let T (t) represent the temperature at time t and let Tinit be the temperature when an application starts execution (T (0)=Tinit). The prediction model assumes that the rate of change of temperature is proportional to the difference between the current temperature and the steady state temperature of the application <ref type="bibr" target="#b15">[15]</ref>. Thus</p><formula xml:id="formula_8">dT dt = b × (Tss -T ). (<label>8</label></formula><formula xml:id="formula_9">)</formula><p>Solving Equation ( <ref type="formula" target="#formula_8">8</ref>) with T (0) = Tinit and T (∞)=Tss, we get</p><formula xml:id="formula_10">T (t) = Tss -(Tss -Tinit) × e -bt (<label>9</label></formula><formula xml:id="formula_11">)</formula><p>where b is a processor-specific constant. The value of b is determined using Equation ( <ref type="formula" target="#formula_8">8</ref>) by observing heating and cooling curves corresponding to all SPEC2006 benchmarks on the core. Also, since the value of b is different to the amount of workload, b should be determined by the workload on each processor. Running several benchmarks, we obtained b = 0.009 when the workload is 100%. We precompute the steady state temperature of an application offline. Then by rearranging Equation ( <ref type="formula" target="#formula_10">9</ref>), we get the steady state tempera- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Workload</head><formula xml:id="formula_12">Tss = T (t) -Tinit × e -bt (1 -e -bt )<label>(10)</label></formula><p>Therefore, with Equation ( <ref type="formula" target="#formula_10">9</ref>) and ( <ref type="formula" target="#formula_12">10</ref>), we get the future temperature after time t and the steady state temperature, Tss, of each core.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Predictive Thermal Model</head><p>Our approach, which towards characterizing the thermal contribution of individual processor, uses ABTM and CBTM at run-time as the input for the overall thermal model to directly estimate the future temperature. For each application, we exploit both short-term (ABTM) and long-term (CBTM) future temperature values to prevent Ping-Pong effect 2 . The application-based temperature Tapp predicts the transient variations in application temperature which includes the temperature contribution at the running period on the core before being migrated into other core. On the other hand, the core-based temperature Tcore is calculated with the aggregated temperature by workload. The overall predictive temperature is then given as:</p><formula xml:id="formula_13">T predict = wsTapp + w l Tcore (<label>11</label></formula><formula xml:id="formula_14">)</formula><p>where T predict is determined as the overall predictive temperature, ws is a weighting factor of ABTM, and w l is a weighting factor of CBTM. Note that ws and w l should be adjusted according to the application workload. Since the benchmarks we used in this study maintain 100% workload in most time, we found that the optimal values for ws and w l are 0.7 and 0.3 respectively based on our experimental results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PDTM SCHEDULER</head><p>The Linux standard scheduler is designed to compromise two opposing aspects: response time and throughput. Interactive processes such as shell programming are built to run in a satisfactory response time. On the other hand, CPUintensive programs needs to ensure throughput. To keep up with this corollary in multi-cores, a certain process is rarely migrated into another core in Linux standard scheduler. This is mainly because an active process uses running information like TLB for the process through cache memory <ref type="bibr" target="#b2">[2]</ref>. However, when the workload is noticeably unbalanced, 2 Process is migrated among several cores very frequently.  for j = 1 to MAXcores do 5:</p><p>T cbtm ← CBTM(∆tm) 6:</p><p>T abtm ← ABTM(∆tm) 7:</p><p>T Increment priority(processi) until priority = 0 20: end if 21: end for the Linux standard scheduler initiates process migrations despite migration overhead. However, the Linux standard scheduler does not take the temperature behavior into account. To resolve this issue, the proposed PDTM enables the scheduling policy to accommodate the temperature behavior as well as workloads in a multicore environment.</p><p>Our PDTM mainly composes of three components as shown in Figure <ref type="figure" target="#fig_2">3</ref>. In the monitoring part, application workload (CPU utilization) is monitored for application's migration to balance workload by Linux standard scheduler. However, it is not aware of temperature. Our PDTM uses Digital Thermal Sensor (DTS) to detect temperature at run-time. The detected temperature information will be used in the future temperature prediction model.</p><p>As shown in Algorithm (1), PDTM determines that migration is necessary when the predicted temperature exceeds the migration threshold (Ttmt). When the current temperature (Tcur) reaches the temperature trigger threshold (Tttt), ∆tm, the time to which the migration threshold, is calculated by ABTM. PDTM begins to calculate the future temperature via ABTM and CBTM for other cores after ∆tm. The core with minimum value among future temperature  <ref type="figure" target="#fig_4">4</ref>, our goal is to find the future coolest core after ∆tm with our prediction. If the prediction temperature, T pred is also larger than priority scheduling temperature(Tpst), the priority of application should be adjusted as well as migration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION AND ANALYSIS</head><p>In order to estimate working temperature through Digital Thermal Sensor (DTS) for multicore systems, we develop a specific driver to access them in runtime. In a chipmultiprocessor (CMP) silicon die, each core has a unique thermal sensor that triggers independently. The trigger point of these thermal sensors is not programmable by software since it is set during the fabrication of the processor <ref type="bibr" target="#b1">[1]</ref>.</p><p>In our experiments, we set temperature trigger threshold as 60 • C to start PDTM, and the migration threshold as 70 • C to migrate applications when the predicted temperature exceeds the migration threshold. Also, priority scheduling threshold is 82 • C. When predicted temperature is reached at priority scheduling threshold, the priority of application can be adjusted as lower value. All experiments are tested under ambient temperature control and fixed fan speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Digital Thermal Sensor for Core 2 Quad</head><p>In Intel's Core Architecture, the DTS can be accessed by a Machine Specific Register (MSR). The value in the MSR is an unsigned number and the unit is Celsius ( • C).</p><p>In MSR, we use IA32_THERM_STATUS register in order to get temperature of each core. Within the register, it uses 7 bits where the value of DTS is stored. We can get temperature for four cores by Equation <ref type="bibr" target="#b12">(12)</ref>. Tcore = Tjunction -DT S value <ref type="bibr" target="#b12">(12)</ref> Tjunction is a manufactural value by Intel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experimental Analysis</head><p>To demonstrate the proposed PDTM, we conduct our experiments with a single SPEC2006 benchmark and a set of two SPEC2006 benchmarks as shown in Table <ref type="table" target="#tab_1">1</ref>. Running the single benchmark, the presented PTDM can decrease 8% temperature in average (Figure <ref type="figure" target="#fig_7">5</ref>), and reduces up to 5 • C in peak temperature with only under 1% performance overhead compared to Linux standard scheduler without DTM as shown in Figure <ref type="figure">7</ref>. Running two benchmarks simultaneously, the proposed PDTM can even lower about 10% temperature in average and reduces up to 3 • C in peak temperature while running a set of benchmarks with only under 8% performance overhead compared to Linux standard scheduler without DTM (Figure <ref type="figure" target="#fig_8">6</ref>). It means PDTM can be more effective to control temperature than Linux standard scheduler when temperature and workload is higher.</p><p>In order to make comparison, we also rebuilt HybDTM <ref type="bibr" target="#b8">[8]</ref> (the software scheme-changing priority) and HRTM <ref type="bibr" target="#b10">[10]</ref>   on our Quad-Core system. HybDTM uses priority-based scheme and HRTM uses migration-based scheme. HybDTM scheme relies on hardware performance counter, while HRTM relies on current temperature information. The experimental results show our PDTM outperforms HRTM in reducing average temperature by about 7%, performance overhead by 0.15%, and peak temperature by about 3 • C. Additionally, our future temperature prediction model provides more accurate prediction with only less than 1.6% error as shown in Figure <ref type="figure" target="#fig_6">8</ref>; on the other hand, the estimation model, introduced in HybDTM, has at most 5% average error. The main reason of the accuracy in our prediction model is that we consider not only the core-based temperature at each core, but also the application thermal behavior. Therefore, PDTM is capable to manage the temperature fairness and controls the overall temperature lower than other schemes even in CPU intensive situation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>In this paper, we propose the Predictive Dynamic Thermal Management with an advanced future temperature prediction model for multicore systems, and implement PDTM on Intel Quad-Core with a specific device driver to access the Digital Thermal Sensor. We demonstrate that our scheme is able to reduce the overall temperature and provide thermal fairness among four cores. The proposed temperature prediction model can provide more accurate prediction and  more efficient temperature management by using ABTM and CBTM with lower performance overhead compared to other schemes (HRTM and HybDTM). Most importantly, there is no additional hardware unit required for our prediction models and scheduler. For the future work, we will test our schemes in different platforms with various benchmark such as JBB2005, and WEB2005 to verify their scalability in more general environment.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Real temperature of one core on running bzip2 benchmark</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The calculation of ∆t(migration time) using ABTM</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: System Overview</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: PDTM utilizes ABTM and CBTM simultaneously to predict both short-term and long-term future temperature for multicore</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure 7: Performance Overhead:PDTM incurs only under 1% performance overhead in average while running single benchmark</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: The prediction model can estimate future temperature with only less than 1.6% error on running bzip2 benchmark</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Comparisons among without DTM, HRTM, and PDTM using libquantum benchmarks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Comparisons among without DTM, HRTM, and PDTM using bzip2 and libquantum benchmarks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>[j] ← ωs•T abtm +ω l •T cbtm</figDesc><table><row><cell>8:</cell><cell>end for</cell></row><row><cell>9:</cell><cell>Migrated Core ← MIN CORE(T [])</cell></row><row><cell>10:</cell><cell>T pred ← MIN TEMP(T [])</cell></row><row><cell>11:</cell><cell></cell></row><row><cell>12:</cell><cell>if Current Core = Migrated Core then</cell></row><row><cell>13:</cell><cell>MIGRATION(processi → Migrated Core)</cell></row><row><cell>14:</cell><cell>end if</cell></row><row><cell>15:</cell><cell></cell></row><row><cell>16:</cell><cell>if T pred ≥ Tpst then</cell></row><row><cell>17:</cell><cell>Decrement priority(processi)</cell></row><row><cell>18:</cell><cell>else</cell></row><row><cell>19:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : A set of benchmarks list</head><label>1</label><figDesc></figDesc><table><row><cell>Benchmarks</cell><cell cols="2">Temperature Memory Usage</cell></row><row><cell>perlbench+hmmer</cell><cell>Low</cell><cell>Low</cell></row><row><cell>perlbench+bzip2</cell><cell>Low</cell><cell>High</cell></row><row><cell>libquantum+hmmer</cell><cell>High</cell><cell>Low</cell></row><row><cell>libquantum+bzip2</cell><cell>High</cell><cell>High</cell></row><row><cell cols="3">(T []) is selected as new core for migration. As shown in Fig-</cell></row><row><cell>ure</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>41.2</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>The steady state temperature of an application is defined as the temperature the system would reach if the application is executed infinitely.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Intel 64 and IA-32 Architectures Software Developer&apos;s Manual</title>
		<ptr target="http://support.intel.com/design/processor/manuals/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Understaning the Linux Kernel</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bovet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cesati</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>O&apos;Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Dynamic Thermal Management for High-Performance Microprocessors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Recursive Least-Squares Method with Membership Functions</title>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine learning and Cybernetics</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Managing the Impact of increasing Microprocessor Power Consumption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gunther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Binns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carmean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intel Technology Journal</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reducing Power Density through Activity Migration</title>
		<author>
			<persName><forename type="first">S</forename><surname>Heo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISLPED</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Principles of Heat Transfer</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kreith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Bohn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>CENGAGE-Engineering</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">HybDTM: A Coordinated Hardware-Software Approach for Dynamic Thermal Management</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-S</forename><surname>Peh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Study of Thread Migration in Temperature-Constrained Multicores</title>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sazeides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Constantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Architecture and Code Optimization</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Heat-and-Run: Leveraging SMT and CMP to Manage Power Density Through the Operating System</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Powell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gomaa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Vijaykumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>ASPLOS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Temperature-Aware Microarchitecture: Modeling and Implementation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Skadron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Velusamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TACO</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<author>
			<persName><forename type="first">K</forename><surname>Skadron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Velusamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Temperature-Aware Microarchitecture</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Hybrid Architectural Dynamic Thermal Management</title>
		<author>
			<persName><forename type="first">K</forename><surname>Skadron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DATE</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Predictive Dynamic Thermal Management for Multimedia Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Reactive Speed Control in Temperature-Constrained Real-Time Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bettati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECRTS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
