<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Architectural Support for Server-Side PHP Processing</title>
				<funder ref="#_Rmk7385 #_SUmc27m">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Dibakar</forename><surname>Gope</surname></persName>
							<email>gope@wisc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of Wisconsin -Madison Madison</orgName>
								<address>
									<region>WI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Electri-cal and Computer Engineering</orgName>
								<orgName type="institution">University of Wisconsin -Madison Madison</orgName>
								<address>
									<region>WI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Schlais</surname></persName>
							<email>schlais2@wisc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of Wisconsin -Madison Madison</orgName>
								<address>
									<region>WI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Electri-cal and Computer Engineering</orgName>
								<orgName type="institution">University of Wisconsin -Madison Madison</orgName>
								<address>
									<region>WI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mikko</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of Wisconsin -Madison Madison</orgName>
								<address>
									<region>WI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Electri-cal and Computer Engineering</orgName>
								<orgName type="institution">University of Wisconsin -Madison Madison</orgName>
								<address>
									<region>WI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Architectural Support for Server-Side PHP Processing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3079856.3080234</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>PHP</term>
					<term>dynamic languages</term>
					<term>domain-specific accelerators</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>PHP is the dominant server-side scripting language used to implement dynamic web content. Just-in-time compilation, as implemented in Facebook's state-of-the-art HipHopVM, helps mitigate the poor performance of PHP, but substantial overheads remain, especially for realistic, large-scale PHP applications. This paper analyzes such applications and shows that there is little opportunity for conventional microarchitectural enhancements. Furthermore, prior approaches for function-level hardware acceleration present many challenges due to the extremely flat distribution of execution time across a large number of functions in these complex applications. In-depth analysis reveals a more promising alternative: targeted acceleration of four fine-grained PHP activities: hash table accesses, heap management, string manipulation, and regular expression handling. We highlight a set of guiding principles and then propose and evaluate inexpensive hardware accelerators for these activities that accrue substantial performance and energy gains across dozens of functions. Our results reflect an average 17.93% improvement in performance and 21.01% reduction in energy while executing these complex PHP workloads on a state-of-the-art software and hardware platform.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>has grown considerably. Among all scripting languages used for server-side web development, PHP is the most commonly used <ref type="bibr" target="#b69">[70,</ref><ref type="bibr" target="#b71">72]</ref>, representing about 82.3% <ref type="bibr" target="#b11">[13]</ref> of all web applications. In particular, server-side PHP web applications have created an ecosystem of their own in the world of web development. They are used to build and maintain websites and web applications of all sizes and complexity, ranging from small websites to complex large scale enterprise management systems. PHP powers many of the most popular web applications, such as Facebook and Wikipedia. Despite their considerable increase in popularity, their performance is still the main impediment for deploying large applications. Since these PHP applications run on live datacenters hosting millions of such web applications, even small improvements in performance or utilization will translate into immense cost savings.</p><p>The desire to reduce datacenter load inspired the design of the HipHop JIT compiler (HHVM) <ref type="bibr" target="#b17">[19,</ref><ref type="bibr" target="#b71">72]</ref>, which translates PHP to native code. HHVM demonstrates a significant performance increase for a set of micro-benchmark suites. However, runtime characteristics of popular real-world PHP web applications (e-commerce platforms, social networking sites, online news forums, banking servers, etc.) are found to be dramatically different than the defacto benchmark suites SPECWeb2005 <ref type="bibr" target="#b8">[10]</ref>, bench.php <ref type="bibr" target="#b16">[18]</ref>, and the computer language benchmarks <ref type="bibr" target="#b0">[1]</ref> used so far for evaluating the performance of web servers. These micro-benchmark suites have been the primary focus for most architectural optimizations of web servers <ref type="bibr" target="#b18">[20]</ref>. Furthermore, these micro-benchmarks spend most of their time in JIT-generated compiled code, contrary to the real-world PHP applications that tend to spend most of their time in various library routines of the VM.</p><p>Figure <ref type="figure" target="#fig_1">1</ref> depicts the distribution of CPU cycles spent in the hottest leaf functions of a few real-world PHP applications compared to SPECWeb2005's banking and e-commerce workloads. Clearly, the SPECWeb2005 workloads contain significant hotspots -with very few functions responsible for about 90% of their execution time. However, the PHP web applications exhibit significant diversity, having very flat execution profiles -the hottest single function (JIT compiled code) is responsible for only 10 -12% of cycles, and they take about 100 functions to account for about 65% of cycles. This tail-heavy behavior presents few obvious or compelling opportunities for microarchitectural optimizations.</p><p>In order to understand the microarchitectural implications (performance and energy-efficiency bottlenecks) of these workloads with hundreds of leaf functions, we undertook a detailed architectural characterization of these applications. Despite our best effort, we could not find any obvious target or easy opportunity for architectural optimization. 11 16 21 26  Hottest: JIT-compiled code: ~10% As the processor industry continues to lean towards customization and heterogeneity <ref type="bibr" target="#b39">[41,</ref><ref type="bibr" target="#b52">54,</ref><ref type="bibr" target="#b63">65,</ref><ref type="bibr" target="#b65">67]</ref> to improve performance and energy efficiency, we seek to embrace domain-specific specializations for these real-world PHP applications. We note function level specialization is not a viable solution for these applications given their very flat execution profiles. However, a closer look into the leaf functions' overall distribution reveals that many leaf functions suffer from either the abstraction overheads of scripting languages (such as type checking <ref type="bibr" target="#b20">[22]</ref>, hash table accesses for user-defined types <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b30">32]</ref>, etc.) or the associated overhead of garbage collected languages <ref type="bibr" target="#b23">[25]</ref>. These observations guide us to apply several hardware and software optimization techniques from prior works <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b38">40]</ref> together to these PHP applications in order to minimize those overheads. After applying these optimizations, a considerable fraction of their execution time falls into four major categories of activities -hash map access, heap management, string manipulation, and regular expression processing. These four categories show the potential to improve the performance and energy efficiency of many leaf functions in their overall distribution. This motivates us to develop specialized hardware to accelerate these four major activities.</p><p>Hash Table <ref type="table">Access</ref>. Unlike micro-benchmarks that mostly accesses hash maps with static literal names, these real-world applications often tend to exercise hash maps in their execution environment with dynamic key names. These accesses cannot be converted to regular offset accesses by software methods <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b38">40]</ref>. Programmability and flexibility in writing code are two of several reasons to use dynamic key names. In order to reduce the overhead and inherent sources of energy inefficiency from hash map accesses in these PHP applications, we propose to deploy a hash table in hardware. This hash table processes both GET and SET requests entirely in hardware to satisfy the unique access pattern of these PHP applications, contrary to prior works deploying a hash table that supports only GET requests in a memcached environment <ref type="bibr" target="#b53">[55]</ref>. Furthermore, supporting such a hash table in the PHP environment presents a new set of challenges in order to support a rich set of PHP features communicating with hash maps that these real-world PHP applications tend to exercise often. Heap Management. A significant fraction of execution time in these applications come from memory allocation and deallocation, despite significant efforts to optimize them in software <ref type="bibr" target="#b35">[37,</ref><ref type="bibr" target="#b49">51]</ref>. Current software implementations mostly rely on recursive data structures and interact with the operating system, which makes them non-trivial to implement in hardware. However, these applications exhibit an unique memory usage pattern that allows us to develop a heap manager with its most frequently accessed components in hardware. It can respond to most of the memory allocation and deallocation requests from this small and simple hardware structure.</p><p>String Functions. These PHP applications exercise a variety of string copying, matching, and modifying functions to turn large volumes of unstructured textual data (such as social media updates, web documents, blog posts, news articles, and system logs) into appropriate HTML format. Prior works <ref type="bibr" target="#b66">[68]</ref> have realized the potential of hardware specialization for string matching, but do not support all the necessary string functions frequently used in these PHP applications. Nevertheless, designing separate accelerators to support all the necessary string functions will deter their commercial deployment. Surprisingly, all the necessary string functions can be supported with a few common sub-operations. We propose a string accelerator that supports these string functions by accelerating the common sub-operations rather than accelerating each function. It processes multiple bytes per cycle for concurrency to outperform the currently optimal software with SSE extensions.</p><p>Regular Expressions. These PHP applications also use regular expressions (regexps) to dynamically generate HTML content from the unstructured textual data described above. Software-based regexp engines <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b55">57]</ref> or recent hardware regexp accelerators <ref type="bibr" target="#b32">[34,</ref><ref type="bibr" target="#b37">39,</ref><ref type="bibr" target="#b56">58,</ref><ref type="bibr" target="#b64">66]</ref> are overly generic in nature for these PHP applications as they do not take into consideration the inherent characteristics of the regular expressions in them. We introduce two novel techniques -Content Sifting and Content Reuse -to accelerate the execution of regexp processing in these PHP applications and achieve high performance and energy efficiency. These two techniques significantly reduce the repetitive processing of textual data during regular expression matching. They essentially exploit the content locality across a particular or a series of consecutive regular expressions in these PHP applications.</p><p>The remainder of this paper is organized as follows. Section 2 performs an in-depth microarchitectural analysis of the PHP applications. Failing to find any clear microarchitectural opportunities shifts our focus towards designing specialized hardware. We discover the potential candidates for specialization in Section 3. In Section 4 we design specialized hardware accelerators for them. Section 5 presents results. Section 6 discusses related work and Section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MICROARCHITECTURAL ANALYSIS</head><p>We begin by performing an in-depth architectural characterization of the PHP applications to identify performance and energy-efficiency bottlenecks (if any) in them. We use gem5 <ref type="bibr" target="#b3">[4]</ref> for our architectural simulation. Surprisingly, the most significant bottlenecks lie in the processor front-end, with poor branch predictor and branch target buffer performance. Neither increased memory bandwidth, nor larger  instruction or data caches show significant opportunity for improving performance.</p><p>Branch predictor bottlenecks. We experimented with the stateof-the-art TAGE branch predictor <ref type="bibr" target="#b61">[63]</ref> 1 with 32KB storage budget. The branch mispredictions per kilo-instructions (MPKI) for the three PHP applications considered in this work are 17.26, 14.48, and 15.14. Compared to the 2.9 MPKI average for the SPEC CPU2006 benchmarks, these applications clearly suffer from high misprediction rates. The poor predictor performance is primarily due to the presence of large number of data-dependent branches in the PHP applications. The outcomes of data-dependent branches depend solely on unpredictable data that the PHP applications require to process during most of their execution time. Prior work on predicting data-dependent branches <ref type="bibr" target="#b33">[35]</ref> may improve the MPKI of the PHP applications.</p><p>Branch target buffer bottlenecks. Real-world PHP applications suffer significantly from the poor performance of branch target buffers (BTBs) in server cores. We simulate a BTB that resembles the BTB found in modern Intel server cores with 4K entries and 2-way set associativity. Such behavior stems from the large number of branches in the PHP applications. Around 12% of all dynamic instructions are branches in the SPEC CPU2006 workloads <ref type="bibr" target="#b72">[73]</ref>, whereas in the PHP applications about 22% of all instructions are branches, thus adding more pressure on BTB. Figure <ref type="figure" target="#fig_2">2(a)</ref> shows the execution time of one of the PHP applications, as the BTB size is progressively increased from 4K entries to 64K entries for different sizes of I-cache. However even with 64K entries, the PHP application obtains a modest BTB hit rate of 95.85%. Deploying such large BTBs is not currently feasible in server cores due to power constraints.</p><p>Cache analysis. Figure <ref type="figure" target="#fig_2">2</ref>(b) presents the cache performance. L1 instruction and data cache behavior are more typical of SPEC CPU-like workloads contrary to the instruction cache behavior observed in prior works with other server-side applications (serversside Javascript applications <ref type="bibr" target="#b72">[73]</ref> or memcached workloads <ref type="bibr" target="#b53">[55]</ref>). Note that we simulate an aggressive memory system with prefetchers at every cache level. Although there are hundreds of leaf functions in the execution time distribution of these PHP applications, they are 1 The branch prediction accuracy observed on Intel server processors and TAGE are in the same range <ref type="bibr" target="#b58">[60]</ref> compact enough that can be effectively cached in the L1. Besides, the numerous data structures in these PHP applications do not appear to stress the data cache heavily. The L2 cache has very low MPKI, as the L1 filters out most of the cache references. Figure <ref type="figure" target="#fig_2">2</ref>(a) shows the potential of minor performance gain with very large instruction caches.</p><p>In-order vs. out-of-order. Figure <ref type="figure" target="#fig_2">2c</ref> shows the impact four different architectures (2-wide in-order, 2-wide out-of-order (OoO), 4-wide OoO, and 8-wide OoO) had on workload execution time. Changing from in-order to OoO cores shows a significant increase in performance. We also note that the 4-wide OoO shows fairly significant performance gains over the 2-wide OoO architecture, hinting that some ILP exists in these workloads. However, increasing to an 8-wide OoO machine shows very little (&lt; 3%) performance increase, hinting that ILP cannot be exploited for large performance benefits beyond 4-wide OoO cores.</p><p>Overall, our analysis suggests that PHP applications require far more BTB capacity and much larger caches than server cores currently provide to obtain even minor performance benefit. In short, our analysis does not present any obvious potential target for microarchitectural optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MITIGATE ABSTRACTION OVERHEAD</head><p>As microarchitectural analysis fails to reveal any clear opportunities for improvement, we shift our focus towards augmenting the base processor with specialized hardware accelerators. However, function-level acceleration is not an appealing solution for these applications given their very flat execution profiles. Nevertheless, it is commonly known that PHP-like scripting languages suffer from the high abstraction overheads of managed languages. Overhead examples include dynamic type checks for primitive types, and hash table accesses for user-defined types. Furthermore PHP, like all garbage collected languages, suffers from the overhead of reference counting.</p><p>While there are many research proposals <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b38">40]</ref> from the academic community in mitigating each of these abstraction overheads separately, most of them have not been adopted so far by the industry into commercial server processors. Considering the fact that these abstraction overheads constitute a significant source of performance and energy overhead in these PHP applications (as our results indicate), we believe the industry is more likely to embrace these  proposals sooner than later. So in order to mitigate the abstraction overheads and get a clear view of what other fundamental activities are going to dominate the execution time of these PHP applications in near future, we apply several hardware and software optimizations from prior research together to these applications in our simulated environment. Note that the objective of this exercise is not only to move the abstraction overheads towards the tail of the distribution of these applications, but also to determine the fundamental dominant activities in many of the leaf functions which were obscured by these overheads that have known solutions. Next, we describe briefly those optimizations from prior research proposals.</p><p>Inline Caching <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b30">32]</ref> and Hash Map Inlining <ref type="bibr" target="#b38">[40]</ref>. Modern JIT compilers <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b17">19]</ref> use inline caching (IC) to specialize code that accesses members in dynamically-typed objects. With IC, access to a dynamically-typed object is specialized to a simple offset access from the start of the object. A type check around that offset access ensures that the assumptions used in the generation of specialized code hold at runtime. We extend the IC technique to specialize these PHP applications' accesses to hash maps as done in <ref type="bibr" target="#b38">[40]</ref>. Further, we adopt the recent proposal on hash map inlining <ref type="bibr" target="#b38">[40]</ref> (HMI) to specialize hash map accesses with variable though predictable key names.</p><p>Type Checking. As discussed above, specialized code for accessing variables of primitive or user-defined types now requires run-time type checks. We adopted a technique from prior work <ref type="bibr" target="#b20">[22]</ref> to mitigate this overhead in hardware. With this technique, the cache subsystem performs the required type check for a variable before returning its value.</p><p>Reference Counting. Reference counting constitutes a major source of overhead in these PHP applications as it is spread across compiled code and many library functions. We adopted a hardware proposal from prior work that introduces minimal changes to the cache subsystem to mitigate this overhead <ref type="bibr" target="#b44">[46]</ref>.</p><p>In addition to applying the above four optimizations, we tuned the applications to reduce their overhead from expensive memory allocation and deallocation calls to the kernel.</p><p>Figure <ref type="figure">3</ref> demonstrates the effect of applying these above optimizations to the leaf functions of one of the PHP applications, WordPress <ref type="bibr" target="#b13">[15]</ref>. The left bar shows the contribution of the leaf functions to the overall execution time before applying the optimizations, whereas the right bar shows their corresponding contribution after applying the optimizations. Clearly, the contribution of many leaf functions diminishes with these optimizations (indicated by arrows), and as a result, the contributions of the remaining functions in the overall distribution have gone up. More interestingly, many of the leaf functions in the overall distribution now fall into four major categories -hash map access, heap management, string manipulation, and regular expression processing, as shown by the different color coding in Figure <ref type="figure" target="#fig_3">4</ref>. This consequently presents opportunities to accelerate them in hardware to obtain performance and energy efficiency. Figure <ref type="figure" target="#fig_4">5</ref> shows the execution time breakdown of a few real-world PHP applications after applying the above optimizations. If a function contained aspects of one of the four categories, we grouped it into execution time for that category. <ref type="foot" target="#foot_0">2</ref> Since these four categories show the potential to improve the execution efficiency of many leaf functions, we propose specialized hardware to accelerate these activities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SPECIALIZING THE GENERAL-PURPOSE CORE</head><p>In this section, we propose accelerators for the four major hot spots observed in the PHP applications. We first describe the design principles that we followed while developing these accelerators and then describe their hardware design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Accelerator Design Principles</head><p>Recent explorations in cache-friendly accelerator design demonstrate the criticality and feasibility of balancing the efficiency of application specific specializations with general-purpose programmability using tightly-coupled accelerators <ref type="bibr" target="#b62">[64]</ref>. We espouse a similar accelerator design philosophy, and propose accelerators that adhere to the following design principles so that they fit naturally into multi-core server SoCs. a) They are VM and OS agnostic. The VM still observes the same view of software data structures in memory.</p><p>b) They have cache interfaces and participate in the cache coherence mechanism. c) They only accelerate the frequently-executed common path through each function. Any unusual or unexpected condition is relegated to a software handler. e) They rely on a shared virtual address space and maintain a coherent view of memory to avoid the need for explicitly managed scratchpad memories. Our evaluation shows that most memory references from these accelerators are small and fall within the boundaries of a single 4KB page, so a single TLB lookup performed by the invoking instruction is sufficient. The hardware for managing coherence is necessarily somewhat complex, but, in our view, well worth the effort since it dramatically simplifies deployment of these accelerators in a realistic multicore system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Hash Table</head><p>In order to reduce the overhead from hash map accesses, we deploy a hash table in hardware.</p><p>Overview Real-world PHP applications frequently access hash maps with dynamic key names; such accesses cannot be converted to efficient offset references by software methods <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b38">40]</ref>. Typically, these applications use many PHP commands that access shortlived hash maps using dynamic key names. For example, the PHP extract command is commonly used to import key-value pairs from a hash map into a local symbol table 3 in order to communicate their values later to an appropriate application template that is responsible for generating some dynamic content. Populating such a symbol table always occurs using dynamic key names. Furthermore, these PHP applications often store key-value pairs in a global or local symbol table to communicate their values to other functions in the appropriate scope. For example, the regular expression manager shares a search pattern (key) and its FSM table (value) with other appropriate functions through a hash map. Accesses to all such hash maps occur using dynamic key names. More importantly, such accesses to hash maps ease programming while developing large applications.</p><p>Proposed design Figure <ref type="figure">6</ref> shows the hash table accelerator design. A critical requirement with hardware-traversable hash tables is to bound the number of hash table entries accessed per lookup. Thus, when a key is looked up in the hash table in our design, several consecutive entries are accessed in parallel, starting from the first indexed entry, to find a match. A hash table lookup in hardware thus 3 A symbol table is implemented using a hash map. reduces control-flow divergence and exploits parallelism with hash map accesses. Note that it is not easy to extract parallelism from a serial hash map walk in software because of the complex control flow, memory aliasing, and numerous loop-carried dependencies. Each hash table entry contains a string field to store a key, an 8-byte address (base address of a hash map structure in memory), a pointer to the memory location of the value, a dirty bit to indicate if the hash map structure in memory is required to be updated with the corresponding key, and a valid bit. The valid and dirty bits assist in replacing entries and making space for new incoming keys. The 8-byte address field contains the base address of a hash map data structure, accesses to which for a key-value pair the hash table attempts to provide a fast lookup. Thus, in response to a request, the hash table performs a hash on the combined value of the key and the base address of the requested hash map to index into an entry and begin the lookup process. Starting with the entry, when a hash table lookup is performed, each entry has its key and 8-byte base address compared with the key and the base address of the request. Upon a match, the hash table updates the entry's last-access time stamp (for LRU replacement) and sends the response to the request. If no match is found, control falls back to the software to perform the regular hash map access in memory.</p><p>Design considerations The HHVM JIT compiler <ref type="bibr" target="#b17">[19]</ref> already uses an efficient hash computation function that can operate on variable length strings (in our case the combination of a hash map base address and a key in it). However, we used a simplified hash function for the hash table without compromising its hit rate. This is because the HHVM hash function is overly complex to map into an efficient hardware module and it requires many processor cycles to compute a hash. Our design leverages several inherent characteristics of these PHP applications.</p><p>First, in contrast to the most large-scale memcached deployments <ref type="bibr" target="#b21">[23,</ref><ref type="bibr" target="#b53">55]</ref> where the GET requests vastly outnumber the SET and other request types, these PHP applications observe relatively higher percentage of SET requests (ranging from 15 -25%) when generating dynamic contents for web pages. As a result, a hash table deployed for such applications should respond to both GET and SET requests in order to take full advantage of the hardware hash table and offload most operations associated with hash map accesses from the core.</p><p>Second, the majority (about 95%) of the hash map keys accessed in these PHP applications are at most 24 bytes in length. As a result, we store the keys in the hash table itself, unlike the hash table designed for memcached deployments <ref type="bibr" target="#b53">[55]</ref>. Storing the keys directly in the hash table eases the traversal of the hash table in hardware.</p><p>We next discuss typical operations offloaded from a traditional software hash map to our hardware hash table. Note that the allocation or the deallocation of a hash map structure in memory is still handled by software.</p><p>GET: A GET request attempts to retrieve a key-value pair of the requested hash map from the hash table without any software interaction. Upon a match, the hash table updates the entry's lastaccess time stamp. If the key is not found for the requested hash map, control transfers to the software to retrieve the key-value pair from memory and places it into the hash table. In order to make space for the retrieved key, if an invalid entry is not found, then a clean entry (dirty bit not set) is given more priority for replacement. This avoids any costly software involvement associated with replacing a dirty entry from the hardware hash table. The hash map of a dirty entry is not up-to-date in memory with the key-value pair and therefore requires software intervention in our design to be updated when the entry is evicted. If none is found, the LRU dirty entry is replaced with incurring the associated software cost.</p><p>SET: A SET request attempts to insert a key-value pair of the requested hash map into the hash table without any software interaction. Upon finding a match, SET simply updates the value pointer and the entry's last-access time stamp. If the key is not found, then the key-value is inserted into the hash table and the entry's dirty bit is set. If an eviction is necessary (due to hash table overflow), the same replacement policy as described for GET is followed. Note that a SET operation silently updates the hash table in our design without updating the memory. Figure <ref type="figure">7</ref> demonstrates the hit rate of such a hash table. Even a hash table with only 256 entries observes a high hit rate of about 80%. Since SET operations never miss in our design, a hash table with very few entries (1, 2 or 4) shows such a decent hit rate. Having support of a SET operation in hardware helps in serving a major fraction of the short-lived hash map accesses from the hash table.</p><p>Free: In response to deallocating a hash map from the memory, the hardware hash table would (in a naive implementation) need to scan the entire table to determine the set of entries belonging to the requested hash map. The reverse translation table (RTT) in Figure <ref type="figure">6</ref> assists the hash table during this seemingly expensive operation. The RTT is indexed by the base address of a requested hash map. Each RTT entry stores back pointers to the set of hash table entries containing key-value pairs of a hash map. Each RTT entry also has a write pointer. The write pointer assists in adding these back-pointers associated with different key-value pairs of a hash map into the RTT entry in the same order as they are inserted into the hash table. As a result, a SET operation adds a back pointer in a RTT entry using the associated write pointer and increments it to point to the next available position in the RTT entry. Consequently, each entry in the RTT is implemented using a circular buffer. When an entry is evicted from the hash table, its back pointer in the RTT is invalidated. Hence in response to a Free request, the RTT invalidates the hash table entries of the requested hash map. This way, short-lived hash maps mostly stay in the hash table throughout their lifetime without ever being written back to the memory.</p><p>Replacement: Replacement is handled by software as discussed above.</p><p>foreach: The foreach array iterator in PHP iterates over the keyvalue pairs of a hash map in their order of insertion. The RTT assists in performing this operation. It captures the order of insertion and later updates the memory of the hash map using it in response to a foreach command. Even if an inserted key-value pair is evicted from the hash table and re-inserted later, the RTT can still guarantee the required insertion order invariant.</p><p>Ensure coherence Each hash map in the hardware hash table has an equivalent software hash map laid out in the conventional address space. The two are kept coherent by enforcing a writeback policy from the hardware hash map, and by requiring inclusion of the software equivalent at the L2 level. When a hash map is first inserted into the hardware hash table, the accelerator acquires exclusive coherence permission to the entire address range (depending on the size of the hash map this could be several cache lines). If remote coherence requests arrive for any hardware hash map entries, they are forwarded via the RTT to the accelerator, which flushes out any entries corresponding to the address range of the hash map (the same thing happens for L2 evictions to enforce inclusion). In practice, the hash maps we target are small (requiring a handful of cache lines), process private, and exhibit a lot of temporal locality (small hash maps are freed and reallocated from the process-local heap), so there is virtually no coherence activity due to the hash map accelerator. The software hash map stores each key/value pair in a table ordered  based on insertion, and also stores a pointer to that </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Heap Manager</head><p>Memory allocations and deallocations are ubiquitous in real-world PHP applications. They consume a substantial fraction of the execution time and are spread across many leaf functions. To handle dynamic memory management, the VM typically uses the well-known slab allocation technique. In slab allocation, the VM allocates a large chunk of memory and breaks it up into smaller segments of a fixed size according to the slab class's size and stores the pointer to those segments in the associated free list.</p><p>Overview We propose a heap manager with its most frequently accessed components in hardware to improve its performance and energy-efficiency. Our hardware heap manager is motivated by the unique memory usage pattern of these PHP applications.</p><p>First, a majority of the allocation and deallocation requests retrieve at most 128 bytes, which reflects heavy usage of small memory objects. Figure <ref type="figure" target="#fig_6">8a</ref> shows the cumulative distribution of memory usage with different memory allocation slabs.</p><p>Second, these applications exhibit strong memory reuse. Such strong memory reuse is due to the following reasons: (a) these applications insert many HTML tags while generating dynamic contents for web pages. HTML tags are the keywords within a web page that define how the browser must format and display the content. Generating and formatting these HTML tags often require retrieving many attribute values from the database, storing them in string objects and later concatenating those values to form the overall formatted tag. Once a HTML tag is produced with all its required attributes, the memory associated with these strings are recycled. (b) These applications typically process large volumes of textual data, URL etc. Such processing commonly parses the content through many string functions and regular expressions with frequent memory allocations and deallocations to hold the string contents.  this, Figure <ref type="figure" target="#fig_6">8b</ref> and Figure <ref type="figure" target="#fig_6">8c</ref> show memory usage pattern of two workloads during the course of their execution. We see that memory usage stays flat for the four smallest slabs of 0 -32, 32 -64, 64 -96, and 96 -128 bytes, demonstrating their strong memory reuse for the slabs that dominate the total memory usage.</p><p>Proposed design We deploy a heap manager with only its size class table and a few free lists in hardware to capture the heavy memory usage of small objects and their strong memory reuse. Figure <ref type="figure" target="#fig_7">9</ref> shows the high-level block diagram. The comparator limits the maximum size of a memory allocation request that the hardware heap manager can satisfy. The size class table chooses an appropriate free list for an incoming request depending on its request size. Typically, a memory allocation request accesses the size class table and retrieves an available memory block from the chosen hardware free list without any software involvement. The free list for each size class has head and tail pointers to orchestrate allocation and deallocation of memory blocks. The core uses the head pointer for push and pop requests, and the prefetcher pushes to the location of the tail pointer. Upon finding a miss in the hardware free list, control transfers to software to satisfy the memory allocation request. At the start of a program, upon finding a miss for an available memory block in the hardware free list, the runtime retrieves memory blocks from the software heap manager and places it into the appropriate hardware free list. A prefetcher ensures that the free lists stay populated with available memory blocks so that a request for memory allocation can hide the latency of software involvement whenever possible. We use a pointer-based prefetcher to prefetch the next available memory blocks from the software heap manager structure. Design considerations Since a major fraction of the requests attempt to retrieve at most 128 bytes, the hardware heap manager is restricted to serve requests that are at most 128 bytes in size. It uses only 8 memory allocation slabs to perform this, resulting in a very small, power-efficient hardware heap manager. Furthermore, the strong memory reuse means that in the common case it satisfies the requests from the hardware free list, resulting in very infrequent fall-backs to the software routine that handles any complex cases. Concurrent research work on accelerating memory allocation <ref type="bibr" target="#b46">[48]</ref> eagerly updates the memory's head pointer and linked list on all malloc and free requests to keep coherency with the memory's data structure. However, due to the high memory reuse of these workloads, we instead lazily update the memory's heap manager data structure only on overflow or during context switches. This avoids the overheads of constantly updating memory to be coherent with the hardware table during periods that the heap manager accelerator is servicing the common case requests, while not causing any correctness errors or memory leaks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">String Accelerator</head><p>In order to reduce the cost of searching, modifying, or otherwise processing text in PHP applications, we propose a generalized string accelerator. Although a significant portion of execution time comes from this category of functions, the execution time is spread out through numerous different string operations. These tasks include string finding, matching, replacing, trimming, comparing, etc. Previous work, such as <ref type="bibr" target="#b66">[68]</ref>, propose methods for string matching in hardware. However, the hardware proposed processes a single character every cycle, leaving large opportunities for parallelism and higher throughput. Prior designs also do not support the large variety of string operations we wish to accelerate.</p><p>Proposed design We note that although string processing is an aggregation of many functions, their overall operation can be broken down into common hardware sub-blocks. By sharing hardware resources, we propose a single string accelerator that can perform several of these operations, as opposed to creating a separate accelerator for every string function.</p><p>In addition to matching, our accelerator can substitute characters, perform priority encoding of matches, and determine ranges of character types (useful for detecting lower case, upper case, alphanumeric, etc. characters). We also design our accelerator to process multiple bytes per cycle to exploit concurrency that is not utilized in sequential (single-byte) string accelerators. Figure <ref type="figure" target="#fig_8">10</ref> shows a block diagram of some of the sub-blocks used within our accelerator design.</p><p>ASCII compare uses combinational logic to find the presence of pattern characters within the subject string to populate a matching matrix. This operation is done in parallel, and can process as many characters per cycle as is supported by the table width and the width of subject string reads. Operations that require matching of multiple characters use AND gates of diagonal entries within the matching matrix to find the position of consecutive character matches. For example, Figure <ref type="figure" target="#fig_8">10</ref> shows the subject string 'babc' doing a string_find for 'abc.' String operations that require index calculation of pattern/character matches use a priority encoder to find the first instance of a valid match. Output logic forwards the updated ASCII value to the final output for string functions writing new characters to the result string. Shifting logic aligns the subject string to the correct address offset for string manipulation that requires (re-)writing a resulting string to memory. The datapath is organized in such a way that control logic determines the correct combination of sub-blocks enabled based on the incoming string operation. Multi-byte character sets (Unicode) can be handled by grouping the single-byte characters comparisons in the simplified ASCII example shown.</p><p>Our accelerator design extracts concurrency by processing many bytes of the subject string in parallel. Our design is not limited to sequential text processing, and therefore can significantly increase string processing throughput. This is because each element in the matching matrix does not require any other element's output for correct calculation. Additionally, due to the commonalities between the string manipulation functions, our generalized accelerator supports many different operations with low overheads.</p><p>Design considerations There are several important implementation details that are required for correct operation. First, it is important to support wrap-around in string matching operation, since a match is possible between read text-block boundaries. We support this by buffering previous matching matrix values, and feeding them into the glue-logic sub-block. Second, since a few string functions such as string_to_upper and string_to_lower are dependent on a range of many ASCII characters, we allow 6 of our matching matrix rows to also support inequality comparisons, as opposed to exclusively equal comparisons. We also allow our pattern length (rows in the matching matrix) and size of subject string processed per cycle (columns in the matching matrix) to be configurable. Entries within the ASCII compare matrix that are unused during a given operation can be clock-gated to further reduce energy consumption. Coherence for writes to destination strings are handled by standard coherence mechanisms, while ordering of memory writes with respect to trailing loads is handled with a hardware interlock similar to a store queue in an out-of-order processor. Since PHP strings are of known length (rather than null-terminated), this coherence and consistency logic is straightforward to implement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Regular Expression Accelerator</head><p>Traditional regular expression (regexp) processing engines <ref type="bibr" target="#b6">[8]</ref> are built around a character-at-a-time sequential processing model that introduces high microarchitectural costs. Straightforward parallelization to multi-character inputs leads to exponential growth in the state space <ref type="bibr" target="#b42">[44]</ref>. Recent software-based solutions <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b59">61]</ref> use SIMD parallelism to mitigate that and accelerate regexp processing, but they fail to exploit the regexp-intrinsic characteristics in real-world PHP applications. On the other hand, the high hardware cost associated with parallel regexp accelerators <ref type="bibr" target="#b37">[39,</ref><ref type="bibr" target="#b56">58,</ref><ref type="bibr" target="#b64">66]</ref> may deter their commercial deployment in the near future. Instead, we exploit the inherent characteristics of the regexps in the PHP applications to skip regexp processing of large volumes of textual data and thus improve the overall execution efficiency. We exploit the following two key insights to achieve that. We believe the two key observations exploited here are generic enough to apply across a wide range of real-world PHP applications.</p><p>Content Sifting. The PHP applications process the same unstructured textual content through a series of several regexps during their execution. Furthermore, it is common for most of the regexps among them to seek the presence of some special characters in the source content to convert them into appropriate HTML format or tags. In this work, we classify the following characters {A-Za-z0-9_.,-} as regular characters and the remaining ASCII characters as special characters. Figure <ref type="figure" target="#fig_9">11</ref> illustrates a set of consecutive regexps from an example function of one of the PHP applications. First, all four regexps in the example function process the same content one after another and second, they all look for special characters -apostrophe, double quote, newline character and opening angle bracket character in the source content <ref type="foot" target="#foot_1">4</ref> . For the sake of simplicity, we assume now that these four regexps do not change the content, and relax this restriction later. We name the first regexp in the set as the sieve regexp and the following ones as shadow regexps. Now if the sieve regexp can confirm the presence of no special character in the incoming content, the following shadow regexps can effectively skip scanning the content regardless of the different special characters they look for. Although the sieve regexp must sift (hence the name sieve) the incoming content to observe such a case, this approach can dramatically improve the overall execution efficiency by preventing the shadow regexps from processing the entire source content. In order to exploit this key observation, we use y-axis shows the percentage of total textual content in the entire application regexps can skip processing using content sifting or content reuse.</p><p>our proposed string accelerator to sift the incoming source content in search of special characters during the course of executing the sieve regexp. This outputs a bit vector indicating segments (of some granularity) in the incoming content that may have some special characters. We name these bit vectors as hint vectors, or HVs. Later, the shadow regexps can solely examine the HV to orchestrate skipping the content. The X86 ISA's count leading zeros instruction is used to find the next segment in the HV that requires regexp processing. This way the shadow regexps can skip repeated processing of the similar content and thus can avoid character-at-a-time sequential processing. The VM performs function level data flow analysis to determine the dependency relationships between a set of consecutive regexps inside a function and reveals this opportunity for content sifting. However, if the shadow regexps update the initial content, it can change the segment boundaries in the content for which the sieve regexp has generated the HV. This poses a problem because it thwarts content sifting's strategy of processing the source content once during the sieve regexp and leverage the generated HV for all of the following regexps to improve execution efficiency.</p><p>Whitespace padding in HTML content Fortunately, we can exploit the HTML specification, which allows an arbitrary number of linear white spaces in the response body, to embed the appropriate number of whitespace characters in the updated content to realign the segment boundaries to the existing HV. This ensures the seamless use of the once generated HVs without reprocessing the updated content. For example, when an HTML tag or new characters are inserted into a given text segment, (SEGMENT _SIZE -inserted_text.length()) whitespace characters will be added to the text segment so that subsequent hint vectors remain aligned within the segment boundaries.</p><p>Content Reuse. There exist regexps in the PHP applications that often process almost similar content over and over during their execution. For example, they sometimes scan URLs (https://locahost/?author=abc) of two author names with only the name field (last field) in them changing from 'abc' to 'xyz'. Furthermore, in these PHP applications, HTML tags often observe similar attribute values, leading to generating almost same content for the regexps that process them.</p><p>As a result, during the course of scanning the second URL, if the regexp can remember observing the almost same content before, it can effectively skip parsing the content up to which it has not changed from last time. Note that with content reuse the regexps can skip processing content even in the presence of special characters  <ref type="figure" target="#fig_1">13</ref> shows the appearance of the content reuse table from the example listed above. The 'Content' field in the reuse table is limited to a maximum of 32 bytes for efficiency reasons. Figure <ref type="figure" target="#fig_10">12</ref> shows the percentage of textual content that regexps can avoid processing using either content sifting or content reuse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">ISA Extensions</head><p>In order to invoke our tightly-coupled accelerators, we add ISA extensions. We added hashtableget and hashtableset instructions to invoke GET and SET requests to the hash table. The zero flag is raised upon a miss of a GET, or hash table overflow of a SET, in which case the code branches to the software handler fallback. The state of the hash table is hardware coherent, so no cleanup operations are required during context switches. We also added hmmalloc and hmfree instructions in order to invoke malloc and free requests through our hardware. Similar to the hash table, the zero flag is used to conditionally branch to the software handler fallback. For hmmalloc, the flag is set if the hardware's requested size class is empty and requires involvement of the software handler to gain the next free block. For hmfree, the flag is set if adding the new block overflows the maximum number of entries for the given size class. In this case, the software handler updates the content of the second-to-last block (which becomes the last block for the given size class post-eviction) in memory to point to the evicted block (which can be done using a single str instruction). At context switches, the hardware heap manager must flush its entries to the memory's heap manager data structure. We do this by adding the instruction hmflush. hmflush is resumable in order to guarantee forward progress in the case that multiple page faults occur during the flush.</p><p>We create the stringop[op] instruction to invoke our string accelerator. Six bits are used as an extra opcode to specify which function (eg. trim, find, translate, etc. -denoted [op]) the accelerator should perform, in addition to the source and destination registers. For most of the string functions, the accelerator has a straightforward invocation based on the source register passed. For complex string functions<ref type="foot" target="#foot_2">5</ref> we create the strreadconfig instruction, which populates the string accelerator's matching matrix rows if it is not already configured. Additionally, the string accelerator should return to its previous configuration after a context switch. For this reason, we create a strwriteconfig instruction to store the string accelerator's current configuration. strreadconfig is used to reinitialize the string accelerator after a context switch.</p><p>To perform any regular expression matching, we replace the Perl Compatible Regular Expression (PCRE) library calls with our own APIs -We separate regular expression matching into regexp_sieve and regexp_shadow. regexp_sieve is called on the first regular expression for a set of data. It does the traditional regexp matching, in addition to populating the HV (stored in memory) by invoking our string accelerator. Future calls are made with regexp_shadow in order to optimize regexp searching in light of the populated HV. In order to make use of the content reuse table, we create a regexlookup instruction. It searches the table for a PC, ASID, and content match. In order to update the FSM state value, we create a regexset instruction, which the software handler invokes after a duplicate substring is found. The details of how and when the hardware is updated are explained in Section 4.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTAL FRAMEWORK AND RESULTS</head><p>Our evaluation is divided into two subsections. Section 5.2 presents the performance and energy benefits obtained with deploying our specialized hardware. Section 5.3 illustrates the detailed breakdown of performance benefits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Methodology</head><p>We study three popular real-world PHP web applications -Word-Press <ref type="bibr" target="#b13">[15]</ref>, Drupal <ref type="bibr" target="#b1">[2]</ref>, and MediaWiki <ref type="bibr" target="#b5">[7]</ref> from the oss-performance suite <ref type="bibr">[5]</ref>. WordPress is reportedly the easiest and most popular blogging platform in use today supporting more than 60 million websites <ref type="bibr" target="#b14">[16]</ref>. Drupal powers at least 2.2% of all web sites worldwide, including some of the busiest sites on the web, ranging from discussion forums and personal blogs to corporate sites <ref type="bibr" target="#b2">[3]</ref>. MediaWiki serves as the platform for Wikipedia and many other wikis, including some of the largest and most popular ones.</p><p>In order to understand the characteristics of the PHP applications and guide the subsequent architectural simulations, we conduct a system-level performance analysis using the linux perf command on an Intel Xeon processor running 64-bit Ubuntu 12.04. We used the load generator available with the oss-performance suite to generate client requests. The load generator emulates load from a large pool of client clusters, closely imitating the environment of commercial servers. It generates 300 warmup requests, then as many requests as possible in next one minute. These experiments use the nginx web server, configured to use the HHVM (with all its optimizations turned on) via FastCGI.</p><p>We use gem5 <ref type="bibr" target="#b3">[4]</ref> for microarchitectural characterization of the PHP applications. We evaluate our proposal using an in-house tracedriven simulator. Our simulated server processor is configured similarly to the Intel Xeon-based (4 wide out-of-order) server. Among the proposed accelerators, we implement the string accelerator in Verilog and synthesize using TMSC 45nm standard cell library operating at 2GHz. At 2GHz, the string accelerator requires a maximum of 3 cycles to process up to 64 character blocks. We use CACTI 6.5+ <ref type="bibr" target="#b50">[52]</ref> to estimate the access latency, energy and area of the remaining proposed accelerators. The combined area overhead of the specialized hardware accelerators is 0.22 mm 2 . An Intel Nehalem core (precursor to the Xeon core with same fetch and issue width) measures 24.7 mm 2 including private L1 and L2 caches. If integrated into a Nehalem or Xeon-based core, our proposed specialized hardware is merely 0.89% of the core area. The hardware hash table has 512 entries in our design. In response to a hash table access request, only 4 consecutive entries are accessed (and in parallel) with the computed hash. This restricts the hash table access latency to a constant 1 cycle after performing the initial hash computation. If no match is found, control falls back to the software to perform the regular hash map access in memory. The hardware heap manager has 8 size classes, each having 32 entries in its corresponding free list. 32 entries provides enough flexibility to the prefetcher in hiding the prefetch latency. The heap manager requires 1 cycle to satisfy a request from a hardware free list. The content reuse table has 32 entries. We use McPAT <ref type="bibr" target="#b50">[52]</ref> to collect core power and energy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance and Energy Improvement</head><p>Figure <ref type="figure" target="#fig_3">14</ref> shows the improvement in execution from our specialized architecture. Applying the prior research proposals as discussed in Section 3 brings down the average execution time to about 88.15% of the time obtained with unmodified HHVM, whereas our specialized core brings down the execution time further to 70.22%. Behind the 11.85% improvement in execution time from mitigating abstraction overheads, reducing the overheads of the frequent reference counting mechanism contributes the most (on average 4.42%). Among the three applications, Drupal shows the least opportunity (Figure <ref type="figure" target="#fig_4">5</ref>), and naturally benefits less from our proposed accelerators. Note that the performance benefit from our accelerators will be even more prominent (19.79% on average) as future server processors incorporate the prior optimizations.</p><p>We consider the reduction of dynamic CPU instructions (after using our accelerators) as a simple proxy for estimating the CPU energy savings. We calculate total energy consumption of our accelerators by using simulation counters of the cycles offloaded to each accelerator, in combination with the accelerator energy numbers provided by CACTI and Verilog synthesis. On average, our specialized hardware delivers about 21.01% energy savings on top of the energy savings obtained from deploying the prior proposals. Among the three PHP applications, the energy consumption for WordPress, Drupal, and MediaWiki drops by 26.06%, 16.75%, and 19.81% respectively. Most of the energy savings are attributed to the reduction in the execution of instructions. Note that the specialized architecture may also gain additional energy benefit from fewer data cache accesses, since it now traverses hash table and heap manager data structures in hardware. Memory allocation requests (malloc and free) require on average 69 and 37 x86 micro-ops, respectively, in software to execute (assuming cache hits). Hash map walks in software require on average 90.66 x86 micro-ops. Our specialized architecture saves energy from accelerating the frequently executed paths of these operations in hardware. The string accelerator reduces instruction count by exploiting concurrency, whereas our regular expression accelerator processes less content and thus performs less work by leveraging the two content filtering techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Breakdown of Execution Time</head><p>Figure <ref type="figure" target="#fig_4">15</ref> shows the breakdown of execution time for the PHP applications. The different entries in the legend denote the time consumed in corresponding activities. We observe that in general, the hardware heap manager delivers the biggest benefit (7.29% on average) among all four accelerators. First, it is spread across many leaf functions, and second, the hardware traversal of the size class table and the free lists not only reduces contention in memory system, but also sometimes helps in avoiding cache misses otherwise occurring with accessing those structures in memory. The hardware hash table also delivers significant benefit of 6.45% on average across applications. The string accelerator and the regular expression accelerator deliver 4.51% and 1.96% performance benefit respectively. WordPress observes considerable benefit from the regexp accelerator, whereas MediaWiki obtains modest benefit. Although Drupal demonstrates significant opportunity in Figure <ref type="figure" target="#fig_10">12</ref> from the two regexp acceleration techniques, it does not translate into performance gain, as it does not spend much time either in regexp processing or in string functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK</head><p>Server core design. In recent years, numerous research efforts have been devoted to optimizing warehouse-scale(WSC) and big data workloads <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b34">36,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b51">53,</ref><ref type="bibr" target="#b53">55,</ref><ref type="bibr" target="#b54">56,</ref><ref type="bibr" target="#b68">69]</ref> developed in C++-like compiled languages. <ref type="bibr" target="#b45">[47]</ref> has demonstrated in-depth microarchitectural characterization of WSC workloads and provided several possible directions for architects to accelerate them. Further, there have been multiple recent efforts to address instruction cache bottlenecks <ref type="bibr" target="#b43">[45,</ref><ref type="bibr" target="#b48">50]</ref> in datacenter workloads.</p><p>However, the software community is increasingly leaning towards scripting languages due to their high programmer productivity <ref type="bibr" target="#b25">[27]</ref>. As these live datacenters host millions of web applications developed primarily in scripting languages (typically PHP and Javascript), even small improvements in performance or utilization will translate into immense cost savings. Prior work <ref type="bibr" target="#b72">[73]</ref> concentrated on server-side Javascript applications. However, PHP is most commonly used <ref type="bibr" target="#b69">[70,</ref><ref type="bibr" target="#b71">72]</ref>, representing 82.3% <ref type="bibr" target="#b11">[13]</ref> of all web applications. In this context, our work is the first to present a comprehensive analysis of the microarchitectural bottlenecks of real-world server-side PHP applications.</p><p>Scripting language optimizations. There is a large body of research in optimizing the performance of scripting languages from the software side. Prior works <ref type="bibr">[21, 31-33, 38, 40, 42, 43, 49, 62, 71]</ref> attempt to mitigate abstraction overheads (see Section 3) associated with these languages.</p><p>In recent years, research interest in developing new architectural support for server-side and client-side scripting applications has gone up significantly. In the client side, Javascript is used predominantly whereas PHP is the language of choice for server-side web development <ref type="bibr" target="#b11">[13]</ref>. <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b57">59]</ref> propose microarchitectural changes to avoid runtime checks in jitted execution of Javascript programs. <ref type="bibr" target="#b25">[27]</ref> demonstrates the potential of asymmetric multiprocessors in mitigating the abstraction overheads even further. Front-end bottlenecks, more specifically instruction cache misses are observed to be a major source of performance bottlenecks in real-world Javascript applications. Prior works propose instruction prefetching <ref type="bibr" target="#b26">[28]</ref>, preexecution techniques <ref type="bibr" target="#b27">[29]</ref> and modifying cache insertion policy <ref type="bibr" target="#b72">[73]</ref> to mitigate this. However, surprisingly the real-world PHP applications in our work do not observe instruction cache misses causing a performance bottleneck despite having the presence of hundreds of leaf functions in their distribution. There are very few works in exploring architectural support for PHP applications and they mainly experiment with micro-benchmarks <ref type="bibr" target="#b18">[20]</ref>. <ref type="bibr" target="#b18">[20]</ref> improves the energy efficiency of SPECWeb2005 workloads by aligning the execution of similar requests together. Instead our work focuses on real-world PHP web applications and studies its implications on general-purpose server cores that host those. Specialization alternatives. A hash table that supports only GET operation has been deployed in hardware before for memcached workloads <ref type="bibr" target="#b53">[55]</ref>. Furthermore, <ref type="bibr" target="#b28">[30]</ref> deployed the entire memcached algorithm (supporting both GET and SET) in an FPGA platform. However in addition to the two operations, the PHP applications require support for other important PHP operations (for example, foreach) on hash maps. Without these features, such a hash table in PHP environment will be highly inefficient and not safe to operate on. Our hash table design supports these features, ensures CMP coherence of such table in a multicore server platform and obtains efficiency by exploiting the inherent characteristics (for example, short-lived hash maps) of PHP applications.</p><p>Dynamic heap management in its entirety is non-trivial to implement in hardware <ref type="bibr" target="#b45">[47]</ref>. Our heap manager on the other hand relies on hardware only for the common case, allowing software to provide full-featured dynamic heap management. It achieves that goal by capturing the application-intrinsic characteristics: the strong memory reuse of the principal data structures observed in the PHP applications.</p><p>There is a large body of research in accelerating regular expression (regexp) processing <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b37">39,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b56">58,</ref><ref type="bibr" target="#b59">61,</ref><ref type="bibr" target="#b64">66]</ref>. In recent years, several works <ref type="bibr" target="#b37">[39,</ref><ref type="bibr" target="#b56">58,</ref><ref type="bibr" target="#b64">66]</ref> attempt to parallelize processing by running the regexp separately on separate substrings of the input or by splitting the regexp into multiple sub-regexps and later combining the results appropriately. Our proposed regexp acceleration technique that exploits regexp-intrinsic characteristics of the PHP applications can benefit further by adopting these prior proposals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>Server-side PHP applications occupy a huge footprint in the world of web development. By performing an in-depth analysis, we found potential for specialized hardware to accelerate these PHP applications in a future server SoC. We believe the behavioral characteristics that we found for three popular PHP applications in this work exist across a wide-range of other PHP applications such as Laravel <ref type="bibr" target="#b4">[6]</ref>, Symfony <ref type="bibr" target="#b9">[11]</ref>, Yii <ref type="bibr" target="#b15">[17]</ref>, Phalcon <ref type="bibr" target="#b7">[9]</ref> etc. and hence will all gain execution efficiency when using our proposed accelerators.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Distribution of CPU cycles of SPECWeb2005 workloads and few real-world PHP web applications over leaf functions (details in evaluation section).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Microarchitectural characterization of the PHP applications.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Categorization of leaf functions of WordPress into major categories.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Execution time breakdown after mitigating the abstraction overheads.</figDesc><graphic url="image-15.png" coords="5,385.57,101.62,90.58,108.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Memory usage of MediaWiki.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Memory usage pattern of the PHP applications.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Hardware heap manager.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: String accelerator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>/Figure 11 :</head><label>11</label><figDesc>Figure 11: Code snippet from WordPress. All four regexps look for special characters -apostrophe, double quote, newline character and opening angle bracket (highlighted in red).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure12: Opportunity with content sifting and content reuse. y-axis shows the percentage of total textual content in the entire application regexps can skip processing using content sifting or content reuse.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 :Figure 15 :</head><label>1415</label><figDesc>Figure 14: Improvement in execution time with applying prior optimizations and our specialized hardware. Execution time is normalized to unmodified HHVM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>table in a hash table for fast lookup. The hardware hash table only writes back to the former table while flushing out entries, and marks a flag in the software hash map to indicate that the hash table of the software hash map is now stale. Subsequent software accesses to the software hash map check this flag and reconstruct the hash table if the flag is set. This is exceedingly rare in practice (triggered only by process migration), so the reconstruction mechanism is necessary only for correctness.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>To illustrate</figDesc><table><row><cell></cell><cell></cell><cell>Size</cell><cell></cell></row><row><cell>Comparator</cell><cell>&gt;&gt;</cell><cell>Class Table</cell><cell>Freelist</cell></row><row><cell>Set zero</cell><cell></cell><cell></cell><cell></cell></row><row><cell>flag</cell><cell></cell><cell></cell><cell>Prefetcher</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Figure 13: Hardware content reuse tablewhich content sifting technique can not. We use a reuse table to capture this opportunity. The reuse table is indexed by a regexp PC value, and address space identifier (ASID). Each entry in the table has three fields -the first stores the matching content seen last time when the regexp was executed, the second captures the content size, and the third captures the state in the FSM table that the regexp can advance to if the incoming content finds a match with the first field. When accessing the content reuse table, there are three possible scenarios. First, there could be a PC, ASID, and content match. In this case, the software can automatically jumpto the FSM state located in the hardware table. Second, if there is a PC miss, ASID miss, or the first byte of content doesn't match, we consider that an invalid-miss. In this case, the new content is placed in the table (or overwriting the previous entry if a PC + ASID hit), and the size and FSM fields in the table are cleared. The software handler then traverses the FSM normally. In the last case, if there is a PC + ASID hit, and a non-zero matching size differs from the size listed in the table (or size is currently cleared), then the content and size fields are updated, and the software handler will traverse the FSM to determine the new FSM state to jumpto in future hits of that size. Once this state is determined, the software handler writes the FSM state in the table for future accesses. Figure</figDesc><table><row><cell>PC</cell><cell>ASID</cell><cell>Content</cell><cell cols="2">Size Next Valid</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>FSM State</cell></row><row><cell>...</cell><cell></cell><cell>...</cell><cell>...</cell><cell>...</cell></row><row><cell cols="2">PC X ASID X</cell><cell>https://localhost/?author=</cell><cell>26</cell><cell>State Y</cell></row><row><cell>...</cell><cell></cell><cell>...</cell><cell>...</cell><cell>...</cell></row><row><cell>...</cell><cell></cell><cell>...</cell><cell>...</cell><cell>...</cell></row><row><cell cols="2">Content reuse</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>For the few functions containing aspects of multiple categories, it was placed in the category it spent more of its execution time.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>First two regexps look for an apostrophe or double quote before they look behind<ref type="bibr" target="#b10">[12]</ref> to find a match for the first segment inside the parenthesis.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>We denote complex string functions to require multiple row initializations of the string accelerator's matching matrix that are not determined by source operands (eg. string_to_upper and creating the HVs for the regexp accelerator). These configurations can be large and may not be practical or feasible to pass as a source operand, and therefore require the matching matrix to be loaded from memory using a separate instruction, strreadconfig. strreadconfig is involved at the start of the program and after context switches.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We thank our anonymous reviewers for their insightful comments and feedback on the paper. This work was supported in part by <rs type="funder">NSF</rs> grants <rs type="grantNumber">CCF-1318298</rs> and <rs type="grantNumber">CCF-1615014</rs>. <rs type="person">Mikko Lipasti</rs> has a financial interest in Thalchemy Corp.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_Rmk7385">
					<idno type="grant-number">CCF-1318298</idno>
				</org>
				<org type="funding" xml:id="_SUmc27m">
					<idno type="grant-number">CCF-1615014</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://shootout.alioth.debian.org/" />
		<title level="m">The Computer Language Benchmarks Game</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Drupal</surname></persName>
		</author>
		<ptr target="https://www.drupal.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="https://en.wikipedia.org/wiki/Drupal" />
		<title level="m">Drupal wikipedia</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://gem5.org/" />
		<title level="m">The Gem5 simulator</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><surname>Laravel</surname></persName>
		</author>
		<ptr target="https://laravel.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><surname>Mediawiki</surname></persName>
		</author>
		<ptr target="https://www.mediawiki.org/wiki/MediaWiki" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><surname>Pcre -Perl</surname></persName>
		</author>
		<ptr target="http://www.pcre.org/" />
		<title level="m">Compatible Regular Expressions</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><surname>Phalcon</surname></persName>
		</author>
		<ptr target="https://phalconphp.com/en/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Standard Performance Evaluation Corporation. SPECweb</title>
		<ptr target="https://www.spec.org/web2005/" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName><surname>Symfony</surname></persName>
		</author>
		<ptr target="https://symfony.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://www.regular-expressions.info/lookaround.html" />
		<title level="m">Tutorial on Regular Expressions</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Usage of server-side programming languages for websites</title>
		<ptr target="https://w3techs.com/technologies/overview/programming_language/all" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Javascript</forename><surname>V8</surname></persName>
		</author>
		<author>
			<persName><surname>Engine</surname></persName>
		</author>
		<ptr target="https://developers.google.com/v8/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><surname>Wordpress</surname></persName>
		</author>
		<ptr target="https://wordpress.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="https://en.wikipedia.org/wiki/WordPress" />
		<title level="m">WordPress wikipedia</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><surname>Yii</surname></persName>
		</author>
		<ptr target="http://www.yiiframework.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Php</forename><surname>Zend</surname></persName>
		</author>
		<ptr target="http://php.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The Hiphop Virtual Machine</title>
		<author>
			<persName><forename type="first">Keith</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bertrand</forename><surname>Maher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guilherme</forename><surname>Ottoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Paroski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brett</forename><surname>Simmers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edwin</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Owen</forename><surname>Yamauchi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2660193.2660199</idno>
		<ptr target="https://doi.org/10.1145/2660193.2660199" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;14)</title>
		<meeting>the 2014 ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;14)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="777" to="790" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Rhythm: Harnessing Data Parallel Hardware for Server Workloads</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sandeep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valentin</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Pistol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alvin</forename><forename type="middle">R</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><surname>Lebeck</surname></persName>
		</author>
		<idno type="DOI">10.1145/2541940.2541956</idno>
		<ptr target="https://doi.org/10.1145/2541940.2541956" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;14)</title>
		<meeting>the 19th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;14)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="19" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Improving JavaScript Performance by Deconstructing the Type System</title>
		<author>
			<persName><forename type="first">Wonsun</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiho</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Shull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mar?a</forename><forename type="middle">J</forename><surname>Garzar?n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josep</forename><surname>Torrellas</surname></persName>
		</author>
		<idno type="DOI">10.1145/2594291.2594332</idno>
		<ptr target="https://doi.org/10.1145/2594291.2594332" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;14)</title>
		<meeting>the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;14)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="496" to="507" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Checked Load: Architectural Support for JavaScript Type-checking on Mobile Processors</title>
		<author>
			<persName><forename type="first">Owen</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emily</forename><surname>Fortuna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><surname>Eggers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 IEEE 17th International Symposium on High Performance Computer Architecture (HPCA &apos;11)</title>
		<meeting>the 2011 IEEE 17th International Symposium on High Performance Computer Architecture (HPCA &apos;11)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="419" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Workload Analysis of a Large-scale Key-value Store</title>
		<author>
			<persName><forename type="first">Berk</forename><surname>Atikoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuehai</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eitan</forename><surname>Frachtenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Song</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Paleczny</surname></persName>
		</author>
		<idno type="DOI">10.1145/2254756.2254766</idno>
		<ptr target="https://doi.org/10.1145/2254756.2254766" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM SIGMETRICS/PERFORMANCE Joint International Conference on Measurement and Modeling of Computer Systems (SIGMETRICS &apos;12)</title>
		<meeting>the 12th ACM SIGMETRICS/PERFORMANCE Joint International Conference on Measurement and Modeling of Computer Systems (SIGMETRICS &apos;12)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="53" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">SLICC: Self-Assembly of Instruction Cache Collectives for OLTP Workloads</title>
		<author>
			<persName><forename type="first">Pinar</forename><surname>Islam Atta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Tozun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><surname>Moshovos</surname></persName>
		</author>
		<idno type="DOI">10.1109/MICRO.2012.26</idno>
		<ptr target="https://doi.org/10.1109/MICRO.2012.26" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 45th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 2012 45th Annual IEEE/ACM International Symposium on Microarchitecture<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="188" to="198" />
		</imprint>
	</monogr>
	<note>-45)</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Myths and Realities: The Performance Impact of Garbage Collection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Perry</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathryn</forename><forename type="middle">S</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><surname>Mckinley</surname></persName>
		</author>
		<idno type="DOI">10.1145/1005686.1005693</idno>
		<ptr target="https://doi.org/10.1145/1005686.1005693" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint International Conference on Measurement and Modeling of Computer Systems (SIGMETRICS &apos;04/Performance &apos;04)</title>
		<meeting>the Joint International Conference on Measurement and Modeling of Computer Systems (SIGMETRICS &apos;04/Performance &apos;04)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Architectural Support for SWAR Text Processing with Parallel Bit Streams: The Inductive Doubling Principle</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">D</forename><surname>Cameron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Lin</surname></persName>
		</author>
		<idno type="DOI">10.1145/1508244.1508283</idno>
		<ptr target="https://doi.org/10.1145/1508244.1508283" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIV)</title>
		<meeting>the 14th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIV)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The Yin and Yang of Power and Performance for Asymmetric Hardware and Managed Software</title>
		<author>
			<persName><forename type="first">Ting</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tiejun</forename><surname>Stephen M Blackburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathryn</forename><forename type="middle">S</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><surname>Mckinley</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2337159.2337185" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th Annual International Symposium on Computer Architecture (ISCA &apos;12)</title>
		<meeting>the 39th Annual International Symposium on Computer Architecture (ISCA &apos;12)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="225" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">EFetch: Optimizing Instruction Fetch for Event-driven Webapplications</title>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Chadha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satish</forename><surname>Narayanasamy</surname></persName>
		</author>
		<idno type="DOI">10.1145/2628071.2628103</idno>
		<ptr target="https://doi.org/10.1145/2628071.2628103" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Parallel Architectures and Compilation (PACT &apos;14)</title>
		<meeting>the 23rd International Conference on Parallel Architectures and Compilation (PACT &apos;14)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="75" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Accelerating Asynchronous Programs Through Event Sneak Peek</title>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Chadha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satish</forename><surname>Narayanasamy</surname></persName>
		</author>
		<idno type="DOI">10.1145/2749469.2750373</idno>
		<ptr target="https://doi.org/10.1145/2749469.2750373" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42Nd Annual International Symposium on Computer Architecture (ISCA &apos;15)</title>
		<meeting>the 42Nd Annual International Symposium on Computer Architecture (ISCA &apos;15)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="642" to="654" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">An FPGA Memcached Appliance</title>
		<author>
			<persName><forename type="first">Rahul</forename><surname>Sai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Chalamalasetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mitch</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alvin</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><surname>Auyoung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Parthasarathy Ranganathan</surname></persName>
		</author>
		<author>
			<persName><surname>Margala</surname></persName>
		</author>
		<idno type="DOI">10.1145/2435264.2435306</idno>
		<ptr target="https://doi.org/10.1145/2435264.2435306" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM/SIGDA International Symposium on Field Programmable Gate Arrays (FPGA &apos;13)</title>
		<meeting>the ACM/SIGDA International Symposium on Field Programmable Gate Arrays (FPGA &apos;13)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="245" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Customization: Optimizing Compiler Technology for SELF, a Dynamically-typed Object-oriented Programming Language</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Ungar</surname></persName>
		</author>
		<idno type="DOI">10.1145/73141.74831</idno>
		<ptr target="https://doi.org/10.1145/73141.74831" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 1989 Conference on Programming Language Design and Implementation (PLDI &apos;89)</title>
		<meeting>the ACM SIGPLAN 1989 Conference on Programming Language Design and Implementation (PLDI &apos;89)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="146" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An Efficient Implementation of SELF a Dynamically-typed Object-oriented Language Based on Prototypes</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Ungar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elgin</forename><surname>Lee</surname></persName>
		</author>
		<idno type="DOI">10.1145/74877.74884</idno>
		<ptr target="https://doi.org/10.1145/74877.74884" />
	</analytic>
	<monogr>
		<title level="m">Conference Proceedings on Object-oriented Programming Systems, Languages and Applications (OOPSLA &apos;89)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="49" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient Implementation of the Smalltalk-80 System</title>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Allan</forename><forename type="middle">M</forename><surname>Schiffman</surname></persName>
		</author>
		<idno type="DOI">10.1145/800017.800542</idno>
		<ptr target="https://doi.org/10.1145/800017.800542" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;84)</title>
		<meeting>the 11th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;84)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="297" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Fast Support for Unstructured Data Processing: The Unified Automata Processor</title>
		<author>
			<persName><forename type="first">Yuanwei</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michela</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">A</forename><surname>Becchi</surname></persName>
		</author>
		<author>
			<persName><surname>Chien</surname></persName>
		</author>
		<idno type="DOI">10.1145/2830772.2830809</idno>
		<ptr target="https://doi.org/10.1145/2830772.2830809" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Microarchitecture (MICRO-48)</title>
		<meeting>the 48th International Symposium on Microarchitecture (MICRO-48)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="533" to="545" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Store-Load-Branch (SLB) Predictor: A Compiler Assisted Branch Prediction for Data Dependent Branches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Umar Farooq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizy</forename><forename type="middle">K</forename><surname>Khubaib</surname></persName>
		</author>
		<author>
			<persName><surname>John</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2013.6522307</idno>
		<ptr target="https://doi.org/10.1109/HPCA.2013.6522307" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 IEEE 19th International Symposium on High Performance Computer Architecture (HPCA) (HPCA &apos;13)</title>
		<meeting>the 2013 IEEE 19th International Symposium on High Performance Computer Architecture (HPCA) (HPCA &apos;13)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Clearing the Clouds: A Study of Emerging Scale-out Workloads on Modern Hardware</title>
		<author>
			<persName><forename type="first">Almutaz</forename><surname>Michael Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Adileh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stavros</forename><surname>Kocberber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Djordje</forename><surname>Alisafaee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cansu</forename><surname>Jevdjic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><forename type="middle">Daniel</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Babak</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><surname>Falsafi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2150976.2150982</idno>
		<ptr target="https://doi.org/10.1145/2150976.2150982" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XVII)</title>
		<meeting>the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XVII)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An experimental study on memory allocators in multicore and multithreaded applications</title>
		<author>
			<persName><forename type="first">Rivalino</forename><surname>Tais B Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Autran</forename><surname>Matias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucio</forename><forename type="middle">B</forename><surname>Macedo</surname></persName>
		</author>
		<author>
			<persName><surname>Araujo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 12th international conference on parallel and distributed computing, applications and technologies (pdcat)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="92" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Trace-based Just-in-time Type Specialization for Dynamic Languages</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brendan</forename><surname>Eich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Shaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mandelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><forename type="middle">R</forename><surname>Haghighat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Blake</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Graydon</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Zbarsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Orendorff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesse</forename><surname>Ruderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edwin</forename><forename type="middle">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rick</forename><surname>Reitmaier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Bebenita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mason</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
		<idno type="DOI">10.1145/1542476.1542528</idno>
		<ptr target="https://doi.org/10.1145/1542476.1542528" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09)</title>
		<meeting>the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="465" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">HARE: Hardware Accelerator for Regular Expressions</title>
		<author>
			<persName><forename type="first">Aasheesh</forename><surname>Vaibhav Gogte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Kolli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Loris</forename><forename type="middle">D</forename><surname>Cafarella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>'antoni</surname></persName>
		</author>
		<author>
			<persName><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 49th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 2016 49th Annual IEEE/ACM International Symposium on Microarchitecture<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>-49)</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Hash Map Inlining</title>
		<author>
			<persName><forename type="first">Dibakar</forename><surname>Gope</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mikko</surname></persName>
		</author>
		<author>
			<persName><surname>Lipasti</surname></persName>
		</author>
		<idno type="DOI">10.1145/2967938.2967949</idno>
		<ptr target="https://doi.org/10.1145/2967938.2967949" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Parallel Architectures and Compilation (PACT &apos;16)</title>
		<meeting>the 2016 International Conference on Parallel Architectures and Compilation (PACT &apos;16)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="235" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The GreenDroid Mobile Application Processor: An Architecture for Silicon&apos;s Dark Future</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Goulding-Hotta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ganesh</forename><surname>Venkatesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saturnino</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joe</forename><surname>Auricchio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Po-Chao</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manish</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddhartha</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vikram</forename><surname>Bhatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Babb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Swanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Taylor</surname></persName>
		</author>
		<idno type="DOI">10.1109/MM.2011.18</idno>
		<ptr target="https://doi.org/10.1109/MM.2011.18" />
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="86" to="95" />
			<date type="published" when="2011-03">2011. March 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Fast and Precise Hybrid Type Inference for JavaScript</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Hackett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shu-Yu</forename><surname>Guo</surname></persName>
		</author>
		<idno type="DOI">10.1145/2254064.2254094</idno>
		<ptr target="https://doi.org/10.1145/2254064.2254094" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;12)</title>
		<meeting>the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;12)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="239" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches</title>
		<author>
			<persName><forename type="first">Urs</forename><surname>H?lzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Ungar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Object-Oriented Programming</title>
		<meeting>the European Conference on Object-Oriented Programming</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page">91</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Variable-stride multi-pattern matching for scalable deep packet inspection</title>
		<author>
			<persName><forename type="first">Nan</forename><surname>Hua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haoyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><surname>Lakshman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM 2009</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="415" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">High performing cache hierarchies for server workloads: Relaxing inclusion to capture the latency benefits of exclusive caches</title>
		<author>
			<persName><forename type="first">Aamer</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Nuzman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Moga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">C</forename><surname>Steely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE 21st International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="343" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Flexible Reference-countingbased Hardware Acceleration for Garbage Collection</title>
		<author>
			<persName><forename type="first">Jos?</forename><forename type="middle">A</forename><surname>Joao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yale</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
		<idno type="DOI">10.1145/1555754.1555806</idno>
		<ptr target="https://doi.org/10.1145/1555754.1555806" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual International Symposium on Computer Architecture (ISCA &apos;09)</title>
		<meeting>the 36th Annual International Symposium on Computer Architecture (ISCA &apos;09)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="418" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Profiling a Warehousescale Computer</title>
		<author>
			<persName><forename type="first">Svilen</forename><surname>Kanev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Darago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><surname>Hazelwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tipp</forename><surname>Parthasarathy Ranganathan</surname></persName>
		</author>
		<author>
			<persName><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName><surname>Gu-Yeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><surname>Brooks</surname></persName>
		</author>
		<idno type="DOI">10.1145/2749469.2750392</idno>
		<ptr target="https://doi.org/10.1145/2749469.2750392" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42Nd Annual International Symposium on Computer Architecture (ISCA &apos;15)</title>
		<meeting>the 42Nd Annual International Symposium on Computer Architecture (ISCA &apos;15)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="158" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Mallacc: Accelerating Memory Allocation</title>
		<author>
			<persName><forename type="first">Svilen</forename><surname>Kanev</surname></persName>
		</author>
		<author>
			<persName><surname>Sam Likun Xi</surname></persName>
		</author>
		<author>
			<persName><surname>Gu-Yeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><surname>Brooks</surname></persName>
		</author>
		<idno type="DOI">10.1145/3037697.3037736</idno>
		<ptr target="https://doi.org/10.1145/3037697.3037736" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)</title>
		<meeting>the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="33" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Improved Type Specialization for Dynamic Scripting Languages</title>
		<author>
			<persName><forename type="first">N</forename><surname>Madhukar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jared</forename><surname>Kedlaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Behnam</forename><surname>Roesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehrdad</forename><surname>Robatmili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Reshadi</surname></persName>
		</author>
		<author>
			<persName><surname>Hardekopf</surname></persName>
		</author>
		<idno type="DOI">10.1145/2508168.2508177</idno>
		<ptr target="https://doi.org/10.1145/2508168.2508177" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Symposium on Dynamic Languages (DLS &apos;13)</title>
		<meeting>the 9th Symposium on Dynamic Languages (DLS &apos;13)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">RDIP: Returnaddress-stack Directed Instruction Prefetching</title>
		<author>
			<persName><forename type="first">Aasheesh</forename><surname>Kolli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<idno type="DOI">10.1145/2540708.2540731</idno>
		<ptr target="https://doi.org/10.1145/2540708.2540731" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-46)</title>
		<meeting>the 46th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-46)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="260" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Feedback Directed Optimization of TCMalloc</title>
		<author>
			<persName><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Teresa</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Easwaran</forename><surname>Raman</surname></persName>
		</author>
		<idno type="DOI">10.1145/2618128.2618131</idno>
		<ptr target="https://doi.org/10.1145/2618128.2618131" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Memory Systems Performance and Correctness (MSPC &apos;14)</title>
		<meeting>the Workshop on Memory Systems Performance and Correctness (MSPC &apos;14)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>Article 3, 8 pages</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">McPAT: An Integrated Power, Area, and Timing Modeling Framework for Multicore and Manycore Architectures</title>
		<author>
			<persName><forename type="first">Sheng</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jung</forename><surname>Ho Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">D</forename><surname>Strong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jay</forename><forename type="middle">B</forename><surname>Brockman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dean</forename><forename type="middle">M</forename><surname>Tullsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norman</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<idno type="DOI">10.1145/1669112.1669172</idno>
		<ptr target="https://doi.org/10.1145/1669112.1669172" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42Nd Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 42Nd Annual IEEE/ACM International Symposium on Microarchitecture<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="469" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Architecting to Achieve a Billion Requests Per Second Throughput on a Single Key-value Store Server Platform</title>
		<author>
			<persName><forename type="first">Sheng</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyeontaek</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><forename type="middle">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jung</forename><surname>Ho Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anuj</forename><surname>Kalia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">G</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Seongil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sukhan</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pradeep</forename><surname>Dubey</surname></persName>
		</author>
		<idno type="DOI">10.1145/2749469.2750416</idno>
		<ptr target="https://doi.org/10.1145/2749469.2750416" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42Nd Annual International Symposium on Computer Architecture (ISCA &apos;15)</title>
		<meeting>the 42Nd Annual International Symposium on Computer Architecture (ISCA &apos;15)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="476" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Operating system support for overlapping-ISA heterogeneous multicore architectures</title>
		<author>
			<persName><forename type="first">Tong</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Brett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Knauerhase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Koufaty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dheeraj</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Hahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 IEEE 16th International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Thin Servers with Smart Pipes: Designing SoC Accelerators for Memcached</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Meisner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><forename type="middle">G</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Parthasarathy Ranganathan</surname></persName>
		</author>
		<author>
			<persName><surname>Wenisch</surname></persName>
		</author>
		<idno type="DOI">10.1145/2485922.2485926</idno>
		<ptr target="https://doi.org/10.1145/2485922.2485926" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual International Symposium on Computer Architecture (ISCA &apos;13)</title>
		<meeting>the 40th Annual International Symposium on Computer Architecture (ISCA &apos;13)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="36" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Understanding and Designing New Server Architectures for Emerging Warehouse-Computing Environments</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jichuan</forename><surname>Parthasarathy Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chandrakant</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Mudge</surname></persName>
		</author>
		<author>
			<persName><surname>Reinhardt</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISCA.2008.37</idno>
		<ptr target="https://doi.org/10.1109/ISCA.2008.37" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual International Symposium on Computer Architecture (ISCA &apos;08)</title>
		<meeting>the 35th Annual International Symposium on Computer Architecture (ISCA &apos;08)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="315" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Parabix: Boosting the efficiency of text processing on commodity processors</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nigel</forename><surname>Medforth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kenneth</forename><forename type="middle">S</forename><surname>Herdy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arrvindh</forename><surname>Shriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">D</forename><surname>Cameron</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2012.6169041</idno>
		<ptr target="https://doi.org/10.1109/HPCA.2012.6169041" />
	</analytic>
	<monogr>
		<title level="m">18th IEEE International Symposium on High Performance Computer Architecture</title>
		<meeting><address><addrLine>New Orleans, LA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-02-29">2012. 25-29 February, 2012</date>
			<biblScope unit="volume">2012</biblScope>
			<biblScope unit="page" from="373" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Designing a Programmable Wire-Speed Regular-Expression Matching Accelerator</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Lunteren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Hagleitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Heil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giora</forename><surname>Biran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uzi</forename><surname>Shvadron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kubilay</forename><surname>Atasu</surname></persName>
		</author>
		<idno type="DOI">10.1109/MICRO.2012.49</idno>
		<ptr target="https://doi.org/10.1109/MICRO.2012.49" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 45th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 2012 45th Annual IEEE/ACM International Symposium on Microarchitecture<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="461" to="472" />
		</imprint>
	</monogr>
	<note>-45)</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Dynamically Accelerating Client-side Web Applications Through Decoupled Execution</title>
		<author>
			<persName><forename type="first">Mojtaba</forename><surname>Mehrara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual IEEE/ACM International Symposium on Code Generation and Optimization</title>
		<meeting>the 9th Annual IEEE/ACM International Symposium on Code Generation and Optimization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="74" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Branch Prediction and the Performance of Interpreters: Don&apos;T Trust Folklore</title>
		<author>
			<persName><forename type="first">Erven</forename><surname>Rohou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bharath</forename><surname>Narasimha Swamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andr?</forename><surname>Seznec</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2738600.2738614" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO &apos;15)</title>
		<meeting>the 13th Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO &apos;15)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="103" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Accelerating Business Analytics Applications</title>
		<author>
			<persName><forename type="first">Valentina</forename><surname>Salapura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tejas</forename><surname>Karkhanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Priya</forename><surname>Nagpurkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose</forename><surname>Moreira</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2012.6169044</idno>
		<ptr target="https://doi.org/10.1109/HPCA.2012.6169044" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 IEEE 18th International Symposium on High-Performance Computer Architecture (HPCA &apos;12)</title>
		<meeting>the 2012 IEEE 18th International Symposium on High-Performance Computer Architecture (HPCA &apos;12)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Just-in-time Value Specialization</title>
		<author>
			<persName><forename type="first">Henrique</forename><surname>Nazare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santos</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Pericles</forename><surname>Alves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><surname>Magno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quintao</forename><surname>Pereira</surname></persName>
		</author>
		<idno type="DOI">10.1109/CGO.2013.6495006</idno>
		<ptr target="https://doi.org/10.1109/CGO.2013.6495006" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO) (CGO &apos;13)</title>
		<meeting>the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO) (CGO &apos;13)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">A New Case for the TAGE Branch Predictor</title>
		<author>
			<persName><forename type="first">Andr?</forename><surname>Seznec</surname></persName>
		</author>
		<idno type="DOI">10.1145/2155620.2155635</idno>
		<ptr target="https://doi.org/10.1145/2155620.2155635" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-44)</title>
		<meeting>the 44th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-44)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="117" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Sophia</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Xi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Viji</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><surname>Gu-Yeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><surname>Brooks</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Toward cache-friendly hardware accelerators</note>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Accelerating Critical Section Execution with Asymmetric Multi-core Architectures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Aater Suleman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moinuddin</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yale</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
		<idno type="DOI">10.1145/1508244.1508274</idno>
		<ptr target="https://doi.org/10.1145/1508244.1508274" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIV)</title>
		<meeting>the 14th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIV)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="253" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Hawk: Hardware support for unstructured log processing</title>
		<author>
			<persName><surname>Prateek Tandon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Faissal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Sleiman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Cafarella</surname></persName>
		</author>
		<author>
			<persName><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE 32nd International Conference on Data Engineering (ICDE)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="469" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Conservation Cores: Reducing the Energy of Mature Computations</title>
		<author>
			<persName><forename type="first">Ganesh</forename><surname>Venkatesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Goulding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saturnino</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladyslav</forename><surname>Bryksin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose</forename><surname>Lugo-Martinez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Swanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Bedford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taylor</forename></persName>
		</author>
		<idno type="DOI">10.1145/1736020.1736044</idno>
		<ptr target="https://doi.org/10.1145/1736020.1736044" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems (ASPLOS XV)</title>
		<meeting>the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems (ASPLOS XV)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="205" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Hardware Accelerators for Regular Expression Matching and Approximate String Matching</title>
		<author>
			<persName><forename type="first">Shin'ichi</forename><surname>Wakabayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shinobu</forename><surname>Nagayama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yosuke</forename><surname>Kawanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sadatoshi</forename><surname>Mikami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: APSIPA ASC 2009: Asia-Pacific Signal and Information Processing Association, 2009 Annual Summit and Conference</title>
		<meeting>APSIPA ASC 2009: Asia-Pacific Signal and Information Processing Association, 2009 Annual Summit and Conference</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title level="m">Asia-Pacific Signal and Information Processing Association, 2009 Annual Summit and Conference</title>
		<imprint>
			<publisher>International Organizing Committee</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Bigdatabench: A big data benchmark suite from internet services</title>
		<author>
			<persName><forename type="first">Lei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianfeng</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chunjie</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuqing</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongqiang</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wanling</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhen</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yingjie</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shujie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><surname>Others</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE 20th International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="488" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">SPECweb2005 in the real world: Using IIS and PHP</title>
		<author>
			<persName><forename type="first">R</forename><surname>Samuel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">Steven</forename><surname>Warner</surname></persName>
		</author>
		<author>
			<persName><surname>Worley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SPEC Benchmark Workshop</title>
		<meeting>SPEC Benchmark Workshop</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Dynamic Interpretation for Dynamic Scripting Languages</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Mccandless</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Gregg</surname></persName>
		</author>
		<idno type="DOI">10.1145/1772954.1772993</idno>
		<ptr target="https://doi.org/10.1145/1772954.1772993" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO &apos;10)</title>
		<meeting>the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO &apos;10)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="278" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">The HipHop Compiler for PHP</title>
		<author>
			<persName><forename type="first">Haiping</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iain</forename><surname>Proctor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minghui</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qi</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guilherme</forename><surname>Ottoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Paroski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Macvicar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Tu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2384616.2384658</idno>
		<ptr target="https://doi.org/10.1145/2384616.2384658" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;12)</title>
		<meeting>the ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;12)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="575" to="586" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Microarchitectural Implications of Event-driven Server-side Web Applications</title>
		<author>
			<persName><forename type="first">Yuhao</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Richins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Halpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><forename type="middle">Janapa</forename><surname>Reddi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2830772.2830792</idno>
		<ptr target="https://doi.org/10.1145/2830772.2830792" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Microarchitecture (MICRO-48)</title>
		<meeting>the 48th International Symposium on Microarchitecture (MICRO-48)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="762" to="774" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
