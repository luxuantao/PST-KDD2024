<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Cyber-Physical System Design Contracts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Patricia</forename><surname>Derler</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Edward</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Martin</forename><surname>Törngren</surname></persName>
							<email>martin@md.kth.se</email>
							<affiliation key="aff2">
								<orgName type="institution">KTH Royal Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Stavros</forename><surname>Tripakis</surname></persName>
							<email>stavros@eecs.berkeley.edu</email>
							<affiliation key="aff3">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Cyber-Physical System Design Contracts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">97EBBF52DC4D5627D36E2BFF41F9AFEF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>C.3 [Computer Systems Organization]: Special-purpose and Application based Systems-Real-time and embedded systems</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper introduces design contracts between control and embedded software engineers for building Cyber-Physical Systems (CPS). CPS design involves a variety of disciplines mastered by teams of engineers with diverse backgrounds. Many system properties influence the design in more than one discipline. The lack of clearly defined interfaces between disciplines burdens the interaction and collaboration. We show how design contracts can facilitate interaction between 2 groups: control and software engineers. A design contract is an agreement on certain properties of the system. Every party specifies requirements and assumptions on the system and the environment. This contract is the central point of interdomain communication and negotiation. Designs can evolve independently if all parties agree to a contract or designs can be modified iteratively in negotiation processes. The main challenge lies in the definition of a concise but sufficient contract. We discuss design contracts that specify timing and functionality, two important properties control and software engineers have to agree upon. Various design approaches have been established and implemented successfully to address timing and functionality. We formulate those approaches as design contracts and propose guidelines on how to choose, derive and employ them. Modeling and simulation support for the design contracts is discussed using an illustrative example.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p><ref type="foot" target="#foot_0">1</ref> Cyber-Physical Systems (CPS) design involves various dis-tinct disciplines such as control engineering, software engineering, mechanical engineers, network engineering, etc. The complexity and heterogeneity of all the different design aspects require methodologies for bridging the gaps between the disciplines involved. This is known to be challenging since the disciplines have different views, encompassing terminology, theories, techniques and design approaches.</p><p>In this paper, we focus on interactions between control and embedded software engineers. A multitude of modeling, analysis and synthesis techniques that deal with codesign of control functions and embedded software have been developed since the 1970s. We use the term codesign for approaches that provide an awareness of constraints across the disciplines such that design of different aspects can proceed in parallel.</p><p>Advances in embedded system design methods and supporting tools have led to a strong adoption of model-based design, in which systems are designed at a higher level of abstraction, followed by the generation of an implementation. This is a well-established practice in control engineering and it is also becoming more common in embedded software engineering.</p><p>Despite these advances, gaps between the control and embedded software disciplines remain. There is no clear specification of required interactions and many assumptions such as timing are still implicit. Differences in concepts and concerns between control and software engineering, some of which are mentioned in Table 1, hinder communication. For instance, performance refers to bandwidth and settling time in the control domain, and to response time and context switching time in the embedded software domain. Central concepts such as the sampling-to-actuation (StA) delay in control theory and the response time or execution time for embedded software, do not, by definition, correspond to the same time interval <ref type="bibr" target="#b33">[34]</ref>.</p><p>The interdisciplinary dependency of design aspects poses a major problem as decisions in one domain will affect the other. Dependencies are typically non-linear and, since they affect both the control and embedded software design, they are associated with trade-offs <ref type="bibr">[2]</ref>. For instance, changing the required speed of a feedence Foundation, NSF awards #0720882 (CSR-EHS: PRET) and #0931843 (ActionWebs), the Naval Research Laboratory (NRL #N0013-12-1-G015), and the following companies: Bosch, National Instruments, and Toyota). Additional support was received from the ArtistDesign network of excellence and from the Royal Institute of Technology (KTH).</p><p>The models discussed in this paper are available online and hyperlinks behind figures in this PDF link to the individual models. Ptolemy models are available in executable form using Web Start and we provide the source files for Simulink models.  <ref type="table">1</ref>: Concepts in control and embedded software design back control system will have an impact on the sampling period implemented by the computer system and may also have a significant impact on the StA delay that can be tolerated. Likewise, the partitioning of executable code into tasks will, together with a triggering and scheduling scheme, have an impact on the characteristics of time delays in the control system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concepts</head><p>As a basis for mutual understanding, it is essential to establish an explicit semantic mapping between the two domains. In this paper, we propose a framework of design contracts between control and embedded software engineers, with the goals of bridging the gap between the two worlds, making implicit assumptions explicit, and thus facilitating interaction and communication. Figure <ref type="figure" target="#fig_0">1</ref> illustrates the concept. System-level requirements and external constraints form boundary conditions for design contracts. External constraints (which could correspond to other contracts) restrict the freedom available to control and embedded software engineers. For example, the choice of processing platform bounds achievable execution speeds and thus the control performance. The closed-loop control design, including choice of control strategy and sampling periods, is ultimately constrained by the available sensing and actuation capabilities, and the characteristics of the controlled process (plant).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Application/system level requirements</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Plant constraints</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Platform constraints</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Control design</head><p>Software design A design contract, like any other contract, is an agreement, which entails rights and obligations to the agreeing parties. Design contracts apply this general concept to the engineers involved in the design of a CPS. Making rights and obligations explicit in the design contract provides a basis for proper CPS design and decision making. We focus in particular on the expected timing behavior and functionality of the embedded control subsystem of a CPS. The design contract states at what times certain functions must be computed. The control engineers provide the functions, typically as mathematical models, and guarantee correct behavior of the CPS under the assumption that the functions are computed at the right times. The embedded software engineers assume functional correctness and implement the functions such that the timing constraints can be met.</p><p>The elements of our design contract framework are the following: (a) concepts relevant to timing constraints and functionality; (b) design contracts utilizing these concepts; (c) a process and guidelines on how to choose, derive and employ design contracts. The guidelines encompass specific considerations for modeling and simulation support. In the rest of the paper, we present the above elements in detail. Section 2 reviews the state of the art and provides an overview of design approaches and supporting tools. Examples of formalized design contracts are given in Section 3. In Section 4 we describe guidelines for deriving and applying design contracts. Section 5 presents conclusions and future directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>We first provide a broad overview of research areas related to the codesign of control systems and embedded software followed by a brief survey of work related to contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Design Approaches</head><p>The research field of embedded control systems as part of a CPS was initiated already in the early 1970s, a time when computer resources were scarce and thus the problems of implementing a controller were critical. The Artist roadmaps give an overview of the evolution of the field<ref type="foot" target="#foot_1">2</ref> . A number of aspects that have to be considered in CPS design have been identified over the years. These include concepts that link control and embedded software, as well as trade-offs regarding memory, accuracy and speed. In this paper, we focus mainly on timing properties such as periods, StA delays and jitter. With respect to control and embedded software codesign, we identify the following strands in state of the art research.</p><p>Separation of concerns. The basic idea is to decouple control and embedded software design. Representative approaches include the synchronous programming languages <ref type="bibr" target="#b6">[7]</ref>, and the Logical Execution Time approach (LET) of Giotto <ref type="bibr" target="#b23">[24]</ref> and its successors <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b22">23]</ref>. This research also includes robust control design, which guarantees robust performance despite bounded timing variations. This enables partial decoupling as shown in <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b21">22]</ref>.</p><p>Optimization and synthesis of timing parameters. In this popular research strand a cost function is defined to, for example, optimize the control system performance by adequate choice of controller periods under given resource limitations. Optimization often refers to the choice of periods for controllers and processor utilization and typically only one parameter is considered. One exception is <ref type="bibr" target="#b7">[8]</ref> which considers both periods and delays. Recent efforts in task and message scheduling in a distributed system setting include for example <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b29">30]</ref>.</p><p>Run-time adaptation. This is another popular research direction encompassing the provisioning of online compensation as well as online optimization. While many (often legacy) computer systems cannot provide an easily characterized timing behavior, it might still be possible to provide run-time measurements of the actual timing behavior which can then be used in control system design to compensate for the imperfect timing. The topic has been studied both for wired and for wireless networks. Common approaches use extended estimators that address time-varying delays and dataloss <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b3">4]</ref>. Online optimization takes online measurements/estimations of actual control system performance and/or computer system performance to adjust task attributes (e.g. periods) or schedules with the goal of optimizing control performance, see e.g. <ref type="bibr" target="#b18">[19]</ref>.</p><p>A common extension of the first two categories also considers modes of operation. For each mode, a different configuration of the system (including periods and schedules) is derived during design. A range of computational models has been proposed for all three directions, including different schemes for how to map control functionalities to task and execution strategies <ref type="bibr">[2]</ref>.</p><p>A complementary and more recent strand, which has been gaining interest in the past years, is the study of a theory for eventtriggered feedback control. Promising initial results indicate that event-triggered control allows for a reduction of the required computations and actuations without reducing the performance of a regulator control system <ref type="bibr" target="#b11">[12]</ref>. Event-triggered control clearly poses challenges for scheduling, motivating the need for further work on codesign.</p><p>Regardless of the design approach, explicit timing assumptions are useful, and design contracts can help with that. For instance, the use of an optimization approach will, in itself, make some assumptions about the control design and the embedded software design, and will generate a timing behavior that can be captured as a contract. In the case of run-time approaches, constraints and boundaries for adaptation will be assumed or provided as part of the design, and can thus be made explicit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Research Related to Design Contracts</head><p>Various research ideas relate to our concept of design contract either by similarity in principle, or by similarity of name.</p><p>Contracts are an essential aspect of component-based design and interface theories <ref type="bibr" target="#b15">[16]</ref>. In these frameworks, components are captured by their interfaces, which can be seen as abstractions that maintain the relevant information while hiding irrelevant details. Interfaces can also be seen as a contract between the component and its environment: the contract specifies assumptions on the behavior of the environment (e.g., that a certain input will never exceed a certain value) as well as the guarantees on the behavior of the component (e.g., that a certain output will never exceed a certain value).</p><p>Abstracting components in a mathematical framework that offers stepwise refinement and compositionality goes back to the work of Floyd and Hoare on proving program correctness using pre-and post-conditions <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b24">25]</ref>. A pair of pre-and post-conditions can be seen as a contract for a piece of sequential code. These ideas were further developed in a number of works, including the designby-contract paradigm implemented in the Eiffel programming language <ref type="bibr" target="#b27">[28]</ref>. Although related, the term 'design contract' is not to be confused with 'design by contract'.</p><p>The above works focus mainly on standard software systems and as such use mainly discrete models. Nevertheless, contract-based design methods have also been studied in the context of CPS, and formalisms have been developed to deal with real-time and continuous dynamics <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b32">33]</ref>. Particularly relevant to our study is the work on scheduling interfaces <ref type="bibr" target="#b1">[1]</ref>, which specify the set of all admissible schedules of a control component. Scheduling interfaces assume a time-driven scheduling context, where time slots are defined and allocated to control tasks.</p><p>All the above works are compatible with the design contract framework. In particular, some of the aforementioned formalisms could be used as concrete mechanisms for describing contracts. Nevertheless, the focus of our design contract framework is how to use contracts to solve the broader-in-scope problem of designing both the control and embedded software of a CPS. In that respect, the goals here are very much aligned with the ones presented in <ref type="bibr" target="#b30">[31]</ref>. In particular, design contracts could be used as 'vertical contracts', using the terminology of <ref type="bibr" target="#b30">[31]</ref>. Whereas 'horizontal contracts' that focus on the relationships of different components at the same level of abstraction are primarily used for composition, vertical contracts focus on the relationships between components at different layers, in particular, between specifications and implementations, or between high-level design requirements and execution platform constraints.</p><formula xml:id="formula_0">k•h (k+1)•h (k+2)•h t k s t k a t k+1 t k+1 J k J k+1 h k τ k s s s τ k+1</formula><p>Finally, this work has been greatly inspired by the presentation of the evolution of real-time programming given in <ref type="bibr" target="#b25">[26]</ref>. Part of our terminology, such as the terms ZET and BET, is borrowed from there.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DESIGN CONTRACTS</head><p>We now formulate some popular design approaches as design contracts. Our goal is by no means to be exhaustive, but to illustrate the concept of a design contract concretely. The design contracts presented here focus on functional and timing aspects. Some preliminary concepts are discussed first.</p><p>We use state machines of type Mealy extended with I/O interface functions to specify the functional part of a design contract. Such a machine M is characterized by: a set of input variables (inputs), a set of output variables (outputs), a set of state variables (state), an initialization function that initializes the state, a sampling function that reads the sensors and assigns values to the inputs, an actuation function that writes the outputs to the actuators, an output function that computes the outputs from current inputs and state, and an update function that computes a new state from current inputs and state. The sampling and actuation functions are the I/O interface functions of the machines.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> presents relevant timing variables and corresponding notation. t s k and t a k refer to the k-th sampling and actuation instants, respectively, for k = 0, 1, 2, .... The sampling-to-actuation (StA) delay is τ k = t a kt s k . In periodically-sampled control systems, the nominal sampling period is h and in principle t s k = k • h. In practice, however, the k-th sampling occurs at instant</p><formula xml:id="formula_1">t s k = k • h + J s k , where J s k refers to the sampling instant jitter. We assume k • h ≤ t s k ≤ t a k ≤ (k + 1) • h. Note that τ k and J s</formula><p>k in general are non-zero and vary each period (as a convention, a symbol without subscript k refers to a constant). Finally, h k denotes the 'effective' period, i.e., the delay between the k-th and (k + 1)-th sampling instants:</p><formula xml:id="formula_2">h k = t s k+1 -t s k = h + J s k+1 -J s k .</formula><p>We use the term 'contracts' instead of 'specifications' since the latter are usually viewed as being unidirectional, e.g., in the sense of being "thrown at" a team (e.g., the software engineers) by another team (e.g., the control engineers). Design contracts emphasize the importance of interaction and negotiation between the teams, and are as such bidirectional. Contracts typically include conditional, assume, or guarantee statements, separating the rights and obligations of each party involved in the contract. In the examples of contracts that we provide below, some of these obligations are left implicit. In particular, the obligations of the software engineers include meeting the timing requirements of the contract. The main </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The ZET (Zero Execution Time) Contract</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">ZET: single-period version</head><p>In the simple case, which we call the 'single-period version' the Zero Execution Time (ZET) contract is as follows:</p><p>ZET: A ZET contract is specified as a tuple (M, h) where M is a state machine and h is a period of time. The contract states that, at every time t s k = k • h, for k = 0, 1, 2, ..., the inputs to M are sampled, the outputs are computed and written (a-priori instantaneously, i.e., τ k = J s k = 0), and the state machine performs a state update.</p><p>How control engineers can derive a ZET contract: A typical control design process naturally results in a ZET contract. Standard results from control theory can be used that assume inputs are sampled periodically and outputs are computed and written instantaneously at the beginning of each period <ref type="bibr" target="#b4">[5]</ref>.</p><p>Figure <ref type="figure">3</ref> shows a Simulink<ref type="foot" target="#foot_2">3</ref> model of a simple CPS consisting of a plant (a DC motor) and a controller. The controller computes a requested torque (abbreviated as torque in the Figure ) from the measured motor angle and angular velocity. This controller model captures a ZET contract, as it computes and writes outputs in zero time.</p><p>How software engineers can implement a ZET contract: For a control engineer, ZET is perhaps the easiest contract to produce. The opposite is true for a software engineer: it is impossible to implement a ZET contract in the strict sense. Computation always takes time, therefore, the outputs cannot be written at exactly the same time at which the inputs are read. <ref type="foot" target="#foot_3">4</ref> Moreover, some delays may be associated with the sampling, communication and actuation. Instead of trying to meet an impossible specification, software engineers typically do the next best thing: implement the functionality of the state machine M, perform worst-case execution time (WCET) analysis of the program, and make sure that the WCET obtained is at most h. In order to further minimize the StA delay, state updates and related computations can be executed after the outputs are computed and written. This practice is, however, not made part of an explicit contract.</p><p>Following the above approach, the implementation of a ZET contract results in a sequence of actions as shown here in pseudo code:</p><p>i n i t i a l i z e s t a t e ; s e t p e r i o d i c e v e n t H; w h i l e ( t r u e ) { a w a i t e v e n t H; s a m p l e i n p u t s ; compute and w r i t e o u t p u t s ; compute and u p d a t e s t a t e ; }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">ZET -multi-periodic version</head><p>A generalization of the single-period ZET contract is a multiperiodic ZET contract, where the control engineer designs a set of machines M i , for i = 1, ..., n. Each machine M i generally needs to execute at a different period h i and machines generally need to communicate. Block-diagram formalisms such as Simulink (c.f., Figure <ref type="figure">3</ref>) or synchronous languages such as Lustre <ref type="bibr" target="#b8">[9]</ref> can be used to specify the communication semantics.</p><p>Control engineers can design multi-periodic ZET contracts based on sampled data theory <ref type="bibr" target="#b4">[5]</ref>. A common approach is to identify a basic sampling period h 0 such that all other rates are multiples of it and assume that all samplings are synchronized. The complete system is then resampled with period h 0 .</p><p>Multi-periodic ZET contracts are, again, impossible to implement if taken literally. Moreover, the fact that there are multiple state machines to be executed instead of just one, and the fact that these machines communicate with each other, add complexity to the implementation problem. Some execution-platform specific approaches have been developed to deal with this complexity. A method for the single-processor platform case is described as follows. First, each state machine M i is implemented as a separate task; i.e. a sequential program. Scheduling theory can be used to order task executions using WCET information. Although naive inter-task communication schemes do not work (i.e. do not preserve the functional ZET semantics), semantics-preserving protocols that address this problem exist <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">ZET -event-triggered version</head><p>A further generalization of the ZET contract allows machines to be triggered sporadically by external triggers (i.e., events coming from the environment) or internal triggers (i.e., events sent by other machines). Assumptions on the timing of external events (e.g., how frequently they may occur) can be captured explicitly as part of the contract. Real-time scheduling theory and semantics-preserving implementation techniques can implement this type of ZET contract and in implementations constraints can be approximated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The BET and DET (Bounded Execution Time) Contracts</head><p>The Bounded Execution Time (BET) contract weakens the requirement of the ZET contract that outputs must be produced at the same time as inputs are sampled. Instead, outputs can be produced at any time until the end of the period. In its single-period version, the BET contract can be stated as follows:</p><p>BET: A BET contract is specified by a tuple (M, h) where M and h are as in a ZET contract. The contract states that the inputs are sampled at times t s k = k •h, that the outputs are computed and are written at some point t a k in the interval [t s k ,t s k+1 ), i.e., J s k = 0 and τ k &lt; h, and that the machine performs a state update at some point before t s k+1 .</p><p>How control engineers can derive a BET contract: BET contracts are harder to derive for control engineers, because the promises made by the software engineers are weaker. In particular, the timing of the outputs is non-deterministic: the output can be written at any time within the period. This results in a time-varying control system, whereas standard control design is based upon the assumption of time-invariance. Control engineers must take this into account to make sure that the controllers they design work under all possible scenarios. Simulations, tests and analytical methods can support such reasoning <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr">6]</ref>. For example, the Jitter-Margin approach can be used to assess the stability of a feedback control system with time-varying delays <ref type="bibr" target="#b13">[14]</ref>.</p><p>If the control performance degradation is deemed insignificant, control design can proceed using standard techniques. Otherwise, the contract must be modified or delay compensation and robustness mechanisms must be introduced. This may also involve changes of the sampling periods. Delay compensation can utilize an average delay estimations, or online estimation assuming more knowledge will be available at run-time. The final options are to renegotiate the setting for the control design, e.g. by reducing the controller bandwidth.</p><p>How software engineers can implement a BET contract: Strictly speaking, BET contracts are still impossible to implement, since it is impossible to sample inputs precisely at the beginning of each period. In practice, however, this is not a big concern since the sampling period is chosen with respect to the system dynamics. As long as the variations in the sampling period are small, deviations from the true values are minimal. Moreover, BET contracts are an improvement over ZET contracts from the software engineer's perspective, since the outputs have a non-zero deadline. Software engineers can use the same techniques as described above for approximating ZET contracts. BET contracts closely correspond to a scheduling scheme where a high priority task provides close to jitter-free sampling, and the scheduling guarantees that tasks complete by the end of the period.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DET -a generalization of BET with smaller deadlines</head><p>The Deadline Execution Time (DET) contract is a generalization of BET where the deadline can be smaller than the period:</p><formula xml:id="formula_3">DET: A DET contract is specified by a tuple (M, h, d)</formula><p>where M and h are as in a BET contract and d is a deadline measured in the same time unit as the period h, such that d &lt; h. The contract states that the inputs are sampled at times t s k = k • h, that the outputs are computed and written at some point t a k in the interval [t s k ,t s k + d], i.e., J s k = 0 and τ k ≤ d, and that the machine performs a state update at some point before t s k+1 .</p><p>Deriving and implementing a DET contract raises similar issues as in the case of BET. DET allows for improved control performance by reducing the delay in the control loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The LET (Logical Execution Time) Contract</head><p>ZET gives guarantees to the control engineer but is impossible to implement in the strict sense. BET is implementable but only  <ref type="figure">3</ref> provides non-deterministic guarantees, which make control design more difficult. The Logical Execution Time (LET) approach tries to reconcile both worlds. In this contract, outputs are written precisely at the end of a period. In the simple, single-period case, the LET contract can be stated as follows:</p><p>LET: A LET contract is specified by a tuple (M, h) where M and h are as in a ZET contract. The LET contract states that the inputs are sampled at times t s k = k • h, that the outputs are computed and the machine performs a state update at some point in the interval [t s k ,t s k+1 ), and that the outputs are written at t a k = t s k+1 = t s k + h, i.e., J s k = 0 and τ k = h.</p><p>How control engineers can derive a LET contract: LET makes deterministic guarantees about the I/O timing and thus conforms to standard control theory. It is easier to use for control design than BET. However, LET introduces a one period delay which degrades the performance of the control system. This performance degradation can be partly compensated for <ref type="bibr" target="#b4">[5]</ref>.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the LET version of the Simulink model of Figure <ref type="figure">3</ref>. The unit-delay block added between the controller and the plant provides a delay of one sampling period, causing the model to exhibit LET behavior.</p><p>How software engineers can implement a LET contract: Implementation of LET contracts is similar to the BET case. Using the techniques for BET, the software engineer can guarantee that output deadlines are met. It is (conceptually) easy to delay an early output until the end of the period.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The TOL (Timing Tolerances) Contract</head><p>Building upon the inherent robustness of feedback control systems, it is natural to introduce a relaxation of the tolerances associated with periods and delays. The Timing Tolerances (TOL) contract captures such relaxations. TOL can be seen as a generalization of LET with the differences that the StA delay is constant but smaller than the period, and that tolerances for allowable deviations from nominal specifications of the period and StA delay are specified: TOL: A TOL contract is specified by a tuple (M, h, τ, J h , J τ ) where M is a state machine, h and τ are the nominal period and StA delay, and J h and J τ are bounds on admissible variations of period and StA delay. All parameters are assumed to be non-negative and to satisfy the constraints J τ ≤ τ and</p><formula xml:id="formula_4">J h + τ + J τ &lt; h. The contract states that t s k ∈ [k • h, k • h + J h ], t a k ∈ [t s k + τ - J τ ,t s k + τ + J τ ],</formula><p>and that the k-th state update happens before t s k+1 , for all k. </p><formula xml:id="formula_5">∈ [t s k + τ -J τ ,t s k + τ + J τ ] is equivalent k•h (k+1)•h (k+2)•h t k s t k a t k+1 t k+1 s τ Time a J h J τ J h J τ J τ J τ τ Figure 5: Timing variables of TOL contract to |τ k -τ| ≤ J τ . However, t s k ∈ [k • h, k • h + J h ] implies, but is not equal to, |h k -h| ≤ J h (this allows unbounded drift).</formula><p>How control engineers can derive a TOL contract: From the viewpoint of control theory, TOL is similar to DET and BET in that it allows variations in the StA delay. In addition, TOL allows variations in the sampling period. Therefore, additional work is required to derive the tolerance parameters J h and J τ . This can be supported by methods such as <ref type="bibr" target="#b10">[11,</ref><ref type="bibr">6]</ref>. It is well-known that small variations in the sampling period and StA delay normally pose only small degradation in the control performance <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b2">3]</ref>. A main intention with the TOL contract is to explicitly capture this inherent robustness. By including some type of compensation (off-or online) control engineers can tailor the robustness provided according to contract negotiations. small variations in the feedback delay can be seen to correspond to small disturbances or plant uncertainties.</p><p>How software engineers can implement a TOL contract and derive TOL parameters: Relaxed time constraints on input and output events make it easier to provide a correct schedule, e.g., taking into account blocking and interrupt disabling that could cause jitter in otherwise precisely timed interrupts. The actual scheduling is similar to approaches above.</p><p>Software engineers can contribute to the derivation of TOL parameters, such as τ or J τ . For instance, a best case response time of the output function can be interpreted as τ -J τ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SUPPORT FOR CONTRACT BASED DE-SIGN</head><p>This section discusses methodological guidance for using the design contract framework. We acknowledge the individual activities of control and software designers but also the need for them to communicate, make trade-offs and agree on one or more well-defined design contracts.  <ref type="figure" target="#fig_0">1</ref>, an explicit negotiation phase is added. We assume that the system-level specifications have been developed prior to the preparatory design phase. Such specifications should provide metrics and criteria for the desired system qualities such as cost, extensibility, performance, robustness and safety. The criteria can be in form of constraints (e.g. limits on utilization and closed-loop system bandwidth) or of design goals (e.g. desire to optimize certain properties).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Process for Deriving Design Contracts</head><p>The design phases as outlined in Figure <ref type="figure" target="#fig_5">6</ref> are as follows:</p><p>Preparatory design phase: Control and software engineers analyze the problem and propose overall strategies for their designs. Control engineers select a control design approach (e.g. PID, state feedback, cascaded control etc.), derive feasible sampling periods and investigate the delay sensitivity of the closed-loop system. From the software engineering side this includes investigating platform constraints, preparing I/O and communication functions and inves- Negotiation phase: Control and software engineers meet to investigate, propose and decide on the contracts. The considerations and trade-offs are supported by heuristics/design expertise, simulation, analytic and optimization techniques. This will, for example, help to determine optimal periods. In some cases control engineers may be able to explicitly design, or redesign, a controller to become more robust to time-variations (e.g. including delay compensation). Similarly, software engineers may be able to design or change the task scheduling. Such measures are part of the negotiation stage. There may be degrees of freedom in choosing the task and scheduling model including triggering. Options for allocation of control functionalities to tasks and computing nodes may be other design options. However, it is important to realize that such choices may impact other system-level properties, such as separation of functions of different criticality. Trade-offs are likely to be involved. The negotiation phase may obviously need several iterations. Trade-offs and optimizations may also require iterations back to the system-level requirements. The negotiation phase ends with a selection of one or more contracts with fixed contract parameters (e.g., M, h, d for DET).</p><p>Detailed disciplinary design phase: Having established the contracts enables the control and software engineers to proceed individually with the detailed design of the control and embedded software design. This also facilitates the function, subsystem and system verification, since the contracts focus the work and can be used to, for instance, generate invariants and test cases. The outputs of this phase are fed into the subsequent phases of system integration and testing which are not shown in Figure <ref type="figure" target="#fig_5">6</ref> for simplicity reasons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Choosing a Design Contract</head><p>Application-specific requirements are important in determining the actual contract. A number of desired properties influence the choice, including control performance, control robustness, system extensibility, ease of control design, ease of software design, level of determinism and resource utilization. Many of these properties have inherent conflicts, for example control performance vs. level of determinism. Contracts which eliminate time-variations, such as LET, maximize the temporal determinism, facilitating verification and making LET contracts attractive for safety-critical applications. However, a LET contract is only applicable if the closed-loop system can tolerate the introduced delays, which generally deteriorate control performance and may even lead to instability. Standard control theory provides methods to partly compensate for known constant delays <ref type="bibr" target="#b4">[5]</ref>. However, the inherent response delay cannot be removed and will result in inferior responses to disturbances and unsynchronized set-point changes. Using more expensive hardware to reduce the delays is one option to pave way for a LET contract. Because a LET contract is impossible to implement in the strict   The sensitivity of a feedback control system to (time-varying) delays can vary substantially. Among other things, it depends on the bandwidth of the controlled system, the type of variation and average delay to sampling period ratio. However, control performance generally gains from reducing the delays, and even varying delays are normally better compared to longer constant delays (see for example <ref type="bibr" target="#b12">[13]</ref>). Performance-critical applications generally benefit from DET or BET contracts.</p><p>Table <ref type="table" target="#tab_1">2</ref> lists techniques and tools that support the investigation and negotiation of contracts. Industrial techniques are mainly centered on testing and simulation.</p><p>Figure <ref type="figure" target="#fig_8">7</ref> illustrates the behavior of a closed-loop system with controllers obeying different design contracts. The results have been obtained from a Simulink model, with the controllers modeled as described in Section 4.3. The same value for the period parameter is used in all the controllers: h = 0.1. The plant is the simplified DC motor model shown in Figure <ref type="figure">3</ref> with requested torque as input and angular velocity and angle as outputs. <ref type="foot" target="#foot_4">5</ref> We observe the following:</p><p>ZET: The ZET controller provides a good response to the set point change due to zero delay and sampling jitter.</p><p>BET and DET: In both cases there is a time-varying StA delay which is uniformly distributed in [0, h) for BET and in [0, h/2] for DET. The average delay thus is h/2 for BET and h/4 for DET re-  sulting in a worse response compared to the ZET controller. Given the smaller average delay, the response for DET is slightly better than that for BET.</p><p>LET with and without delay compensation: The LET controller has a StA delay of h. In the given example, this results in large oscillations and unsatisfactory performance. The LET controller can be redesigned to include compensation for the (known) constant delay. In that case, oscillations are cancelled but the inherent response delay is not removed. The response with such a controller is also shown in Figure <ref type="figure" target="#fig_8">7</ref>.</p><p>TOL without delay compensation: the StA delay and tolerance parameters are set as follows: τ = h/2, J h = 0.1h and J τ = 0.4τ. In this case, the periods and delays are defined to vary randomly with a uniform distribution, although other variations may also be relevant to investigate (further discussed below). It can be seen that the behavior is similar to that of the BET and DET simulations.</p><p>In contracts such as DET and TOL, time-variations must be investigated as a basis for choosing the contract. The actual variations could be based on knowledge of the actual scheduling scheme and/or reasoning about relevant variations. The evaluations should consider average (e.g. uniform distribution) and assumed worstcase scenarios (e.g. StA delays and sampling periods alternating between max and min values).</p><p>Figure <ref type="figure" target="#fig_10">8</ref> studies the effects of constant delay compensation in TOL, using a ZET system as a reference. For all plots J τ = J h = 0, h = 0.1 and τ = 0.07 (nominal StA delay for TOL in this case). The plot illustrates that StA delay compensation is necessary since the closed loop system is close to instability. The plot also illustrates a controller based on TOL, with compensation for τ = 0.07, but where the actual delay is much smaller (actually set to zero). In that case, the system becomes unstable, emphasizing the importance of establishing contracts (e.g. for reuse) and in complying with agreed contracts. Even small delays can thus cause problems if they deviate from what has been assumed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Modeling and Simulation Support</head><p>Modeling and simulation are important tools in designing CPS and we expect these tools to play an essential role in the design contracts framework. As a proof of concept, we experimented with two modeling and simulation environments: Simulink (and associated toolboxes) by the Mathworks, and Ptolemy <ref type="bibr" target="#b19">[20]</ref>. We investigate how easy it is to model various design contracts in these tools. In particular we focus on TOL, which is the most general among the concrete contracts described in Section 3. ZET, LET, etc., can be modeled as special cases of TOL.</p><p>A possible conceptual model of a control system that uses the  Figure <ref type="figure" target="#fig_11">9</ref> illustrates a modular style of modeling where the relative delays caused by both delay blocks can be added without changing the control system behavior. This style might be advantageous because the delays represent different phenomena, such as communication vs. processor scheduling.</p><p>Capturing a conceptual model such as the one of Figure <ref type="figure" target="#fig_11">9</ref> in a concrete tool raises the following concerns:</p><p>Heterogeneity: being able to seamlessly compose models with different syntactic or semantic domains, e.g., CT, DE and LT models. Ptolemy supports many domains and achieves interoperability via a notion of 'abstract semantics' <ref type="bibr" target="#b19">[20]</ref>. In Simulink, all blocks operate in the CT domain. Nevertheless, DE and LT signals can also be captured as piecewise-constant CT signals. A need for more explicit support was recognized by the Mathworks and various extensions to Simulink (such as SimEvents for DE) were implemented.</p><p>Mechanisms: for capturing plant behavior such as time variations or data loss. The tool must offer mechanisms for instrumenting time-variations into simulation models, as illustrated by the (time-varying) Sample and Delay blocks in Figure <ref type="figure" target="#fig_11">9</ref>. In our experiments we use common components offered by many tools such as fixed and variable delay blocks as well as random number generators. In Simulink we also used triggered subsystems and SimEvents. Care is needed in aligning the mechanisms with the operation of the simulation environment.</p><p>Level of abstraction: at which phenomena such as time delays are modeled. These can be modeled at one extreme as full-blown architecture/execution platform models, or at the other extreme as basic delay blocks with only a couple of parameters. These parameters could be derived in different ways, e.g. based on worstcase assumptions, measurements or by simulating the embedded software and platform at some suitable level of abstraction. The structure of the conceptual model of Figure <ref type="figure" target="#fig_11">9</ref> allows to tailor the level of abstraction by making the Delay and other blocks arbi- trarily complex or simple. Both simulation environments also offer rich opportunities for tailoring the level of abstraction, with for example SimEvents and Truetime <ref type="bibr" target="#b12">[13]</ref> for Simulink, and quantity managers and integration with Metropolis for Ptolemy <ref type="bibr" target="#b17">[18]</ref>. We use worst-case assumptions, random variations and more elaborate scheduling models captured with the above tools.</p><note type="other">Controller Delay Plant Sampling Trigger</note><p>In the rest of this section we address the above concerns in experiments using Ptolemy and Simulink.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Modeling and Simulating Design Contracts in Ptolemy</head><p>Figure <ref type="figure" target="#fig_12">10</ref> shows the TOL contract for the DC motor example described in Section 4.2 modeled in Ptolemy. Ptolemy allows for hierarchical composition of different models of computation (MoCs) such as DE, CT, synchronous reactive (SR), dataflow and others <ref type="bibr" target="#b19">[20]</ref>. MoCs are specified by directors, which implement the abstract semantics mentioned above. A single MoC is allowed at any given hierarchy level. In particular, the designer must choose the top-level director (and corresponding MoC). The choice is influenced by various factors. For instance, with CT as the top level, the solver might choose a small step size which leads to slow simulation speed.</p><p>The top level model of Figure <ref type="figure" target="#fig_12">10</ref> is a DE model. It contains 5 actors, 4 of which are composite actors, meaning they are refined into sub-models (potentially described in other MoCs). The composite actors are: the plant, the controller, a delay between controller and plant and a sampling trigger block. A constant actor with value 1 is used as the reference value for the controller. The plant is a CT model. Sampler and Hold actors inside the plant actor (highlighted by dotted lines) translate between DE and CT signals. In Ptolemy, these actors have to be inside the CT MoC. Sampling and actuation functions (AD/DA converters) are not explicitly modeled here.</p><p>The controller is implemented as a synchronous reactive (SR) model which roughly corresponds to the LT domain described above. The controller is embedded in the DE domain and thus computes the control output every time one or more events are received on the inputs. Absence of events is treated as value 0 which leads to incorrect control outputs. Therefore all input sources must be triggered at the same time which is achieved by the sampling trigger.</p><p>The timing described by the TOL contract is implemented in the Sampling Trigger and the Delay actor. These actors are im- actor creates a periodic signal with period h, which is delayed by a random amount of time between and J h , implemented by the Uniform and the TimeDelay actors. The Delay actor between the controller and the plant implements the delay of the control signal for τ ± J τ time units (here τ = h/2, J τ = 0.02).</p><p>TOL is a general contract, therefore, being able to model TOL implies being able to model special cases such as ZET, LET, etc. This can be done by eliminating some random actors as well as using zero or fixed instead of variable delays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Modeling and Simulating Design Contracts in Simulink</head><p>The TOL contract in Simulink is shown in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Modeling Delay Compensation in Ptolemy and Simulink</head><p>The TOL contract can be extended to provide delay compensation. If the StA delay τ is known, the state machine M can be modified in order to improve the control performance (the gains have to be recomputed to accommodate this change). For the DC motor example, the computed control signal is also an input to the controller (i.e., the controller now has state).</p><p>Figure <ref type="figure" target="#fig_1">12</ref> illustrates a Ptolemy model of the controller presented above improved with delay compensation.</p><p>Modeling delay compensation in Simulink is not as straightforward. With varying sample times (i.e. the controller is not executed periodically if J h &gt; 0 or J τ &gt; 0, or both), we also need varying sample times for the controller output. Control signal and values from plant to controller must be sampled at the same time. An implementation of the delay compensation is presented in Figure <ref type="figure" target="#fig_2">13</ref>. The output of the controller is memorized and sampled by the sampling block.The implementation of the delay compensation in Simulink involves more than just a change to the model of the controller, and is therefore less modular than that of Ptolemy. See <ref type="bibr" target="#b34">[35]</ref> for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSIONS AND FUTURE WORK</head><p>We proposed a framework of design contracts which relies on explicit negotiation and agreement of functionality and timing assumptions between the control and embedded software engineering teams. We believe it is essential to establish an explicit semantic mapping between the two domains to avoid potential misunderstandings, and this need will continue to grow along with the increasing scale and impact of CPS.</p><p>Future directions are numerous and include the investigation of further formalisms and languages to concretely capture design contracts. Potential candidates can be found in Section 2, but that list is by no means exhaustive. The formalization of existing contract frameworks needs to be further developed into complete contract 'algebras', e.g., along the lines of <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b30">31]</ref>. In particular, compositionality of contracts is a challenging problem. For instance, a compositional formal framework for ZET contracts exists albeit with a restricted form of feedback composition <ref type="bibr" target="#b35">[36]</ref>, while the compositionality of LET contracts is unclear <ref type="bibr" target="#b25">[26]</ref>. Apart from functionality and timing, contracts must be developed for other aspects, such as performance, reliability, failures and application modes.</p><p>Finally, we barely scratched the surface regarding questions such as: how to choose a type of contract for a given application? (a design-space exploration problem); given the type, how to fix the parameters of the contract? (a synthesis problem); how to verify the control design given a contract? (a verification problem); how to derive software implementations from contracts, ideally automatically? (a problem suite involving platform-space exploration, mapping, model transformations and compiler optimizations).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Design contracts are arrow between control and software design; additional arrows illustrate the context</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Timing variables in periodic control systems</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 Figure 3 :</head><label>13</label><figDesc>Figure 3: ZET model of DC motor control in Simulink</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The LET version of the model of Figure 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5</head><label>5</label><figDesc>Figure 5 illustrates the time variables and two possible sensing and actuation times. Note that ta k ∈ [t s k + τ -J τ ,t s k + τ + J τ ] is equivalent</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6</head><label>6</label><figDesc>Figure 6 outlines the overall methodology. Compared to Figure1, an explicit negotiation phase is added. We assume that the system-level specifications have been developed prior to the preparatory design phase. Such specifications should provide metrics and criteria for the desired system qualities such as cost, extensibility, performance, robustness and safety. The criteria can be in form of constraints (e.g. limits on utilization and closed-loop system bandwidth) or of design goals (e.g. desire to optimize certain properties).The design phases as outlined in Figure6are as follows:Preparatory design phase: Control and software engineers analyze the problem and propose overall strategies for their designs. Control engineers select a control design approach (e.g. PID, state feedback, cascaded control etc.), derive feasible sampling periods and investigate the delay sensitivity of the closed-loop system. From the software engineering side this includes investigating platform constraints, preparing I/O and communication functions and inves-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: A process for deriving design contracts</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Activity</head><label></label><figDesc>Techniques and Tools Simulation Simulink, Ptolemy, Truetime, SystemC , ... Static analysis Stability and performance analysis (e.g. Matlab toolboxes, Jitterbug); Schedulability/timing analysis (e.g. SymtaVision, MAST); Hybrid systems analysis (e.g. Hytech, d/dt, SpaceEx) Synthesis Code generation (e.g. Targetlink); Scheduler synthesis (e.g., TTA, Giotto, Rubus) Testing Rapid control prototyping; SW development environments; SIL and HIL (sw/hw in the loop)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Control performance of contracts on the DC motor example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Performance of the DC motor example under various contracts, including illustration of contract violation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Control system model with TOL contract</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: DC motor model with TOL contract in Ptolemy</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 11 :Figure 12 :</head><label>1112</label><figDesc>Figure 11: DC motor model with TOL contract in Simulink</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 11 .</head><label>11</label><figDesc>All signals are CT signals. Discrete-time (DT) signals are modeled as piecewise constant CT signals. The model of Figure 11 does not use such special toolboxes such as SimEvents to model events. Instead, events are encoded in the rising and/or falling edges of DT signals and is used here to capture times t s k and t a k . In the Simulink example, triggers are defined off-line in the Matlab workspace as vectors and imported in the model by the block label "From Workspace" which produces signals with rising and falling edges. By triggering subsystems with these signals timevarying samplers and StA delays are modeled.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>1 Figure 13 :</head><label>113</label><figDesc>Figure 13: Modeling delay compensation in Simulink</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Support for control and embedded system design</figDesc><table><row><cell>LET</cell></row><row><cell>BET</cell></row><row><cell>DET</cell></row><row><cell>TOL</cell></row><row><cell>ZET</cell></row><row><cell>LET with delay compensation</cell></row><row><cell>Time (seconds)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This work was supported in part by the iCyPhy Research Center (Industrial Cyber-Physical Systems, supported by IBM and United Technologies), the NSF Expeditions in Computing project ExCAPE: Expeditions in Computer Augmented Program Engineering, and the Center for Hybrid and Embedded Software Systems (CHESS) at the UC Berkeley (supported by the National Sci-</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.artist-embedded.org/artist/ -Roadmaps-.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://www.mathworks.com/products/simulink/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>This is true in the general case, where outputs instantaneously depend on the inputs, as in Figure3. If M is a machine of type Moore rather than Mealy, then outputs only depend on the state of the machine. In that case, a ZET contract is implementable.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>The plant transfer function, from requested torque to angular velocity, is given by G(s) = 11.8/(s + 1.2). The control design is based on optimal controller design (resulting in a controller using state feedback) and a discretized plant model. The controllers use gains [2.2, 0.5] and[1.6, 0.46, 0.06]. (the latter for the controller with delay compensation.)</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Regular specifications of resource requirements for embedded control software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Real-Time and Embedded Technology and Applications Symposium</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="159" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Artist2 roadmap on real-time techniques in control</title>
		<author>
			<orgName type="collaboration">Artist</orgName>
		</author>
		<ptr target="http://www.artist-embedded.org/artist/ARTIST-2-Roadmap-on-Real-Time.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the design and control of wireless networked embedded systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Årzén</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bicchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hailes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lygeros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 IEEE Computer Aided Control Systems Design Symposium</title>
		<meeting>the 2006 IEEE Computer Aided Control Systems Design Symposium</meeting>
		<imprint>
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Aström</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wittenmark</surname></persName>
		</author>
		<title level="m">Computer-Controlled Systems: Theory and Design</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Establishing timing requirements and control attributes for control loops in real-time systems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cervin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nightingale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECRTS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The synchronous languages 12 years later</title>
		<author>
			<persName><forename type="first">A</forename><surname>Benveniste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Caspi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Le</forename><surname>Guernic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>De Simone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="83" />
			<date type="published" when="2003-01">Jan. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Delay-aware period assignment in control systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cervin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RTSS&apos;08</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Lustre: a declarative language for programming synchronous systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Caspi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pilaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Plaice</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th ACM Symp. POPL. ACM</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Semantics-Preserving Multitask Implementation of Synchronous Programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Caspi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Scaife</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sofronis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tripakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Embedded Computing Systems (TECS)</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="40" />
			<date type="published" when="2008-02">Feb. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Control loop timing analysis using TrueTime and Jitterbug</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cervin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Årzén</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Henriksson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lluesma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Camps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Balbastre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ripoll</surname></persName>
		</author>
		<author>
			<persName><surname>Crespo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 IEEE Computer Aided Control Systems Design Symposium</title>
		<meeting>the 2006 IEEE Computer Aided Control Systems Design Symposium</meeting>
		<imprint>
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On limit cycles in event-based control systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cervin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Åström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">46th IEEE Conference on Decision and Control</title>
		<meeting><address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Control-scheduling codesign of real-time systems: The control server approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cervin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Eker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Embedded Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="209" to="224" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The jitter margin and its application in the design of real-time control systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cervin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Årzén</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Buttazzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RTCSA</title>
		<meeting><address><addrLine>Goeteborg, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-08">Aug. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Period optimization for hard real-time distributed automotive systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Davare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Natale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pinello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kanajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="278" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interface theories for component-based design</title>
		<author>
			<persName><forename type="first">L</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMSOFT&apos;01</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2211</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Timed interfaces</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I A</forename><surname>Stoelinga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMSOFT&apos;02: 2nd Intl. Workshop on Embedded Software</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="108" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Modeling cyber-physical systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Derler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="2012-01">January 2012</date>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="13" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A feedback scheduler for real-time controller tasks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hagander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-E</forename><surname>Årzén</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Control Engineering Practice</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Taming heterogeneity-the Ptolemy approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Janneck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ludvig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Neuendorffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="127" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Assigning meanings to programs. In In</title>
		<author>
			<persName><forename type="first">R</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Symp. on Appl. Math</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="19" to="32" />
			<date type="published" when="1967">1967</date>
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Robustness with respect to delay uncertainties of a predictor-observer based discrete-time controller</title>
		<author>
			<persName><forename type="first">P</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Castillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lozano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Albertos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 45th IEEE CDC</title>
		<meeting>the 45th IEEE CDC</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="199" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A hierarchical coordination language for interacting real-time tasks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ghosal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Iercan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMSOFT&apos;06</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="132" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">From control models to real-time code using Giotto</title>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kirsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sanvido</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pree</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Control Systems Magazine</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="50" to="64" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="576" to="580" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The evolution of real-time programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sengupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Real-Time and Embedded Systems</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Performance-aware scheduler synthesis for control systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMSOFT&apos;11</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Applying &quot;Design by Contract</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Modeling with the Timing Definition Language (TDL)</title>
		<author>
			<persName><forename type="first">W</forename><surname>Pree</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Templ</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">In Automotive Software Workshop San Diego (ASWSD 2006) on Model-Driven Development of Reliable Automotive Services</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Integrated scheduling and synthesis of control applications on distributed embedded systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Samii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cervin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Peng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation and Test in Europe</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Taming Dr. Frankenstein: Contract-Based Design for Cyber-Physical Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Passerone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Control</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>In press</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Kalman filtering with intermittent observations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sinopoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Schenato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franceschetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Poolla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Sastry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="1453" to="1464" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Contract-based system-level composition of analog circuits</title>
		<author>
			<persName><forename type="first">X</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nuzzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC&apos;09</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="605" to="610" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Fundamentals of implementing real-time control applications in distributed computer systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Törngren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Design contracts for cyber-physical systems: Making timing assumptions explicit</title>
		<author>
			<persName><forename type="first">M</forename><surname>Törngren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tripakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Derler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<idno>UCB/EECS-2012-191</idno>
		<ptr target="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-191.html" />
		<imprint>
			<date type="published" when="2012-08">Aug 2012</date>
		</imprint>
		<respStmt>
			<orgName>EECS Dept., UC Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A theory of synchronous relational interfaces</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tripakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lickly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Progr. Lang. and Sys. (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2011-07">July 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Timing problems in real-time control systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Wittenmark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Törngren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the American Control Conference</title>
		<meeting>the American Control Conference</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="2000" to="2004" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
