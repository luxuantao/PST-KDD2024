<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">GraphPi: High Performance Graph Pattern Matching through Effective Redundancy Elimination</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Tianhui</forename><surname>Shi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mingshu</forename><surname>Zhai</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yi</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Jidong</forename><surname>Zhai</surname></persName>
							<email>zhaijidong@tsinghua.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">GraphPi: High Performance Graph Pattern Matching through Effective Redundancy Elimination</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph mining</term>
					<term>pattern matching</term>
					<term>automorphisms elimination</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graph pattern matching, which aims to discover structural patterns in graphs, is considered one of the most fundamental graph mining problems in many real applications. Despite previous efforts, existing systems face two main challenges. First, inherent symmetry existing in patterns can introduce a large amount of redundant computation. Second, different matching orders for a pattern have significant performance differences and are quite hard to predict. When these factors are mixed, this problem becomes extremely complicated. High efficient pattern matching remains an open problem currently.</p><p>To address these challenges, we propose GraphPi, a high performance distributed pattern matching system. GraphPi utilizes a new algorithm based on 2-cycles in group theory to generate multiple sets of asymmetric restrictions, where each set can eliminate redundant computation completely. We further design an accurate performance model to determine the optimal matching order and asymmetric restriction set for efficient pattern matching. We evaluate GraphPi on Tianhe-2A supercomputer. Results show that GraphPi outperforms the state-ofthe-art system, by up to 105× for 6 real-world graph datasets on a single node. We also scale GraphPi to 1,024 computing nodes (24,576 cores).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Graph data and algorithms are widely used in many fields, such as social networks <ref type="bibr" target="#b0">[1]</ref>, bioinformatics <ref type="bibr" target="#b1">[2]</ref>, and fraud detection <ref type="bibr" target="#b2">[3]</ref>. With the increasing amount of graph data, processing and analyzing graphs with high performance become more and more critical. Graph analysis problems can be mainly classified into two types: graph computation and graph mining. Graph computation problems have been extensively studied, and many efficient graph processing systems have been proposed <ref type="bibr" target="#b3">[4]</ref>- <ref type="bibr" target="#b10">[11]</ref>. On the other hand, efficient and scalable graph mining algorithms, which are widely used to discover complex structural patterns in graphs, are extremely challenging to design. As the most typical and common graph mining problem, pattern matching is well known to be NP-complete. With the increase of graph data scale, the number of potential pattern instances may increase exponentially, resulting in an exponential increase in searching space, computation, and intermediate data. The state-of-the-art graph pattern matching system <ref type="bibr" target="#b11">[12]</ref> needs several hours or even several days to mine a pattern with a size of 6 on an unlabeled graph with millions of edges <ref type="bibr" target="#b12">[13]</ref>.</p><p>Recently, researchers have proposed several general-purpose graph mining systems <ref type="bibr" target="#b13">[14]</ref>- <ref type="bibr" target="#b16">[17]</ref>, such as Arabesque and RStream, which provide high-level abstractions and flexible programming models to express complex graph mining algorithms. Arabesque <ref type="bibr" target="#b13">[14]</ref> is a distributed graph mining system that uses a filter-process programming model to simplify the development of scalable graph mining algorithms. However, it suffers from large startup and communication overhead and a large amount of intermediate data. RStream <ref type="bibr" target="#b14">[15]</ref> leverages persistent storage to store intermediate data and implements relational algebra efficiently with tuple streaming and outperforms several state-of-the-art distributed mining systems. Although these general-purpose systems provide comprehensive support for the development of a series of mining algorithms, they have relatively poor performance and exponential intermediate data for storing candidates. For example, RStream generates about 1.2TB intermediate data to count 4-motif on the MiCo graph with 1 million edges <ref type="bibr" target="#b17">[18]</ref>.</p><p>Recently, specialized systems have been developed for pattern matching <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b18">[19]</ref>- <ref type="bibr" target="#b20">[21]</ref>, approximate pattern mining <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b22">[23]</ref>, and frequent subgraph mining (FSM) <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b24">[25]</ref>. ASAP <ref type="bibr" target="#b22">[23]</ref> is a distributed approximate pattern matching system for estimating the count of embeddings (instances of the input pattern). It allows users to make a trade-off between the result accuracy and latency. Although ASAP shows outstanding scalability, it is not applicable in some situations. For example, ASAP fails to generate relatively accurate estimation by sampling if there are very few embeddings in the graph, which are common for some real graph mining applications.</p><p>Algorithms in these specialized pattern matching systems can be described with nested loops, and AutoMine <ref type="bibr" target="#b17">[18]</ref> and GraphZero <ref type="bibr" target="#b11">[12]</ref> represent relatively good performance in such systems. Observing that even a single-thread program outperforms general-purpose graph mining systems like RStream in the case of triangle counting, AutoMine generates efficient C++ code for enumerating all embeddings on a graph. A pattern has a large number of orders in which each vertex of a pattern is searched in these pattern matching algorithms, which are called schedules, and the performance of different schedules varies significantly. To address this problem, AutoMine proposes a performance estimation model to select a schedule with relatively high performance. Based on AutoMine, GraphZero further generates a set of restrictions to break symmetry in a pattern.</p><p>Despite previous efforts, there are two main limitations in current specialized pattern matching systems. The first one is that embeddings are repeatedly identified many times due to arXiv:2009.10955v1 [cs.DC] 23 Sep 2020 the symmetry of a pattern, which results in a large amount of redundant computation. These embeddings, which contain the same edges and vertices, are called automorphisms. GraphZero partially solves this problem by using restrictions to eliminate automorphisms, but it does not consider the influence of different restrictions on performance. Second, the performance of using different schedules of a pattern varies significantly, and it is challenging for pattern matching systems to select the optimal one, especially when patterns are large and complex. Our results (Figure <ref type="figure">9</ref>) show that the optimal schedule is 64.5× faster than the schedule selected by GraphZero for a pattern with 6 vertices. These two problems generally exist in most of current pattern matching systems.</p><p>To address these challenges, we design GraphPi, a highperformance distributed pattern matching system with four novel components: 1) a 2-cycle based automorphism elimination algorithm to generate multiple sets of restrictions to effectively break the symmetry of patterns, 2) a 2-phase computation-avoid schedule generator to eliminate inefficient schedules, 3) an accurate performance prediction model to determine the optimal combination of schedule and restriction set, and 4) an optimization technique with the Inclusion-Exclusion Principle when only counting embeddings.</p><p>For an arbitrary pattern input by users, GraphPi can automatically generate restrictions in the preprocessing stage and apply these restrictions when running pattern matching to eliminate all redundant computation caused by automorphisms. For the same pattern, there may be many different restriction sets, and each of them is able to eliminate all redundant computation. However, the performance of the pattern matching process may differ by several times when applying different restrictions. Since schedules and restrictions both have significant impacts on system performance, we model the performance of the pattern matching algorithm with different combinations of schedules and restrictions in the preprocessing stage, and choose the best one to run.</p><p>Moreover, if an application only counts the number of embeddings instead of listing them, we use Inclusion-Exclusion Principle to count the number of embeddings efficiently. We also leverage a fine-grained task partitioning technique and a work-stealing algorithm to implement a distributed pattern matching system with an OpenMP/MPI hybrid programming model.</p><p>To summarize, we make the following contributions:</p><p>• We propose a 2-cycle based automorphism elimination algorithm to reduce the number of automorphisms to one for an arbitrary pattern (Section IV-A). To our best knowledge, it is the first algorithm that generates multiple different sets of restrictions for nested-loop-based graph mining algorithms.</p><p>• We propose a 2-phase computation-avoid schedule generator to eliminate inefficient schedules (Section IV-B).</p><p>• By building an accurate performance model, we can select the optimal combinations of schedules and restrictions from thousands of candidates to execute the pattern matching algorithm (Section IV-C).</p><p>• In the case of counting embeddings, we further propose a method based on the Inclusion-Exclusion Principle to accelerate the pattern matching algorithm (Section IV-D). Evaluation results on a large variety of real-world graph datasets and patterns show that GraphPi outperforms the state-of-the-art pattern matching system by several orders of magnitude. Specifically, GraphPi is up to 105× faster than GraphZero and 154× faster than Fractal <ref type="bibr" target="#b25">[26]</ref> running on the same single node. After using the Inclusion-Exclusion Principle (IEP) for counting the number of embeddings, GraphPis performance can be further improved by up to 1110× compared with that without using IEP. Currently, GraphPi can scale up to 1,024 computing nodes (24,576 computing cores). GraphPi is available on the website. <ref type="foot" target="#foot_0">1</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND AND MOTIVATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Problem Definition</head><formula xml:id="formula_1">A graph G is defined as (V, E) where V is the vertex set and E ⊆ (V × V ) is the edge set. A pattern G p = (V p , E p ) is isomorphic to a subgraph G s = (V s , E s ) of the data graph if and only if there is a bijective function (a one-to- one correspondence) id : V p → V s such that ∀(u i , u j ) ∈ E p , id(u i ), id(u j ) ∈ E s .</formula><p>For the convenience of discussion, all patterns and data graphs are assumed to be undirected and unlabeled graphs, although all methods proposed in this paper can be easily extended to directed and labeled graphs.</p><p>The graph pattern matching problem is to find all distinct subgraphs (called embeddings) that are isomorphic with a given pattern for a data graph. For better understanding, a pattern and an embedding can be regarded as a template and an instance, respectively. Figure <ref type="figure" target="#fig_1">1</ref> is an example of the pattern matching problem. There are 8 and 5 vertices in the data graph and the pattern respectively. We can find 4 distinct one-to-one correspondences <ref type="bibr">([4,5,6,7,3]</ref>, <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b2">3]</ref>, etc.) satisfying the definition of "isomorphic". Therefore, there are 4 embeddings of the pattern in the data graph.</p><p>One subgraph can be identified as embeddings for several times. The embeddings containing the same edges and vertices are called automorphisms. For example, although the 2 embeddings at the top left and top right corners in Figure <ref type="figure" target="#fig_1">1</ref> have different one-to-one correspondences, they are automorphisms due to the same edges and vertices they contain. Fig. <ref type="figure">2</ref>: An example of schedules and restrictions. The schedule used in (a) is A, C, B, D, E. The number behind a capital letter in (b) denotes the position of this vertex in the schedule (e.g., "C2" means the vertex C is the second searched vertex in this schedule). The greater-than sign ("&gt;") above an edge denotes the restriction between two vertices of this edge (e.g., the "&gt;" above the edge between A1 and B5 denotes id(A) &gt; id(B)). (b) is evaluated on the Patents graph <ref type="bibr" target="#b26">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Schedules and Restrictions</head><p>For the graph pattern matching algorithm, a schedule represents an order in which each vertex of a pattern is searched. For example, an order of A, C, B, D, E is used to find all embeddings of the pattern in the data graph used in Figure <ref type="figure" target="#fig_1">1</ref>. For a given pattern, there are usually a number of candidate schedules to perform the search. By regarding a pattern matching algorithm as a depth-first search (DFS) algorithm, Figure <ref type="figure">2</ref>(a) shows a part of the DFS tree for this example. The deepest leaf nodes (depth = 5) in the DFS tree represent embeddings. Note that the 2 embeddings in Figure <ref type="figure">2</ref>(a) are automorphisms.</p><p>The number of automorphisms depends on the input pattern, and it will explode with the number of vertices in the pattern. For a 7-clique pattern (a complete graph with 7 vertices), each embedding has 5,040 automorphisms. A large number of automorphisms lead to huge redundant computation. Therefore, it is a common goal to identify each embedding exactly once in all pattern matching systems to avoid redundant computation.</p><p>To deal with automorphisms, a technique named restriction is applied in the pattern matching algorithms. A restriction is a restricted condition of relative magnitudes of two vertices in a pattern (e.g., id(A) &gt; id(B), where id is the one-toone correspondence mentioned in Section II-A). By using the ordering of symmetry breaking technique <ref type="bibr" target="#b27">[28]</ref> and the concept of the neighborhood equivalence class <ref type="bibr" target="#b28">[29]</ref>, the first embedding in Figure <ref type="figure">2</ref>(a) can be eliminated with a restriction of id(A) &gt; id(B). This is because id(A) = 4 &lt; id(B) = 5 in the first embedding. From the perspective of the DFS tree, the subtree with "id(B) = 5" as a root node is pruned with this restriction. Therefore, the deepest leaf node of this embedding does not need to be searched.</p><p>For complex patterns, multiple restrictions are required to eliminate all redundant computation, that is, a set of restrictions is required. However, the method with neighborhood equivalence class is only effective for a part of patterns. Recently, GraphZero <ref type="bibr" target="#b11">[12]</ref> partially solves this problem by reducing the number of automorphisms of any pattern to 1, but it can only generate one set of restrictions and does not consider the performance difference of different sets of restrictions in pattern matching. In fact, for the same pattern, there are many different sets of restrictions that can completely eliminate redundant computation. For instance, we can use a restriction id(C) &gt; id(D) instead of id(A) &gt; id(B) to eliminate automorphisms, and the performance of a pattern matching algorithm applying the former is much higher than that applying the latter with the schedule of A, C, B, D, E in Figure <ref type="figure">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Challenges of Pattern Matching</head><p>The performance of different combinations of schedules and restrictions varies significantly. For a given pattern and data graph, different schedules correspond to different searching space, that is, different DFS trees. Although the numbers of embeddings are the same for different schedules, the sizes of different DFS trees differ greatly. Applying different sets of restrictions for the same schedule can be regarded as pruning the DFS tree at different locations, which can lead to different optimization and performance. After combining schedules and a set of constraints, the performance gap between different combinations will further widen. We evaluate the performance of different combinations shown in Figure <ref type="figure">2</ref>(b) with GraphZero on the Patents graph <ref type="bibr" target="#b26">[27]</ref>. Experimental results show that the best combination of schedules and restriction sets is up to 23.2× faster than the worst one.</p><p>However, the number of combinations is very large, and it is very hard to predict the execution time of the pattern matching algorithm. There are n! different schedules for a pattern with n vertices. After combining with different sets of restrictions, the number of possible combinations will explode. Since the distributions of data in different graphs are not similar, we cannot do some preprocessing to select the optimal schedule and restrictions of a pattern and use a combination for one pattern in all graphs. Moreover, the sizes of DFS trees of different combinations are unknown before running the pattern matching algorithm. Therefore, it is necessary but challenging to predict the performance with low overhead and high accuracy for every combination of schedules and sets of restrictions for efficient pattern matching. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. OVERVIEW OF GRAPHPI</head><p>In this work, we design GraphPi, a fast and scalable graph pattern matching system. Figure <ref type="figure" target="#fig_3">3</ref> shows the overall architecture of GraphPi. GraphPi mainly explores how to select a better schedule and a set of restrictions through the information provided by the input pattern and data graph to accelerate the pattern matching process. GraphPi consists of four main components: configuration generation, performance prediction, code generation and compilation, and distributed pattern matching.</p><p>In order to eliminate all redundant computation caused by automorphisms, different sets of restrictions of the input pattern are generated by a restriction generator. The schedule generator can generate all efficient schedules for the input pattern. A performance model predicts the relative performance of all configurations, which are combinations of restriction sets and schedules. After selecting the optimal configuration through the performance model, GraphPi uses the pattern matching algorithm and the code generation method proposed by AutoMine to generate efficient C++ code with this configuration and compiles these programs into an executable file. Then GraphPi runs the distributed pattern matching algorithm with the input graph to find all embeddings. If users only want the number of embeddings instead of listing embeddings, we propose using the Inclusion-Exclusion Principle in the pattern matching algorithm to further improve the performance in GraphPi.</p><p>The APIs provided by GraphPi are simple and easy to use. Users only need to input a pattern and a data graph in the form of adjacency lists to run GraphPi.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. METHODOLOGY OF GRAPHPI</head><p>This section provides a detailed description of approaches in GraphPi. Our goal is to reduce the count of automorphisms to one and eliminate all redundant computation. To achieve that, we first introduce a novel restriction generation algorithm based on permutation groups. To our best knowledge, this is the first algorithm that generates a complete set of restrictions, which can provide more choices and optimization opportunities for graph pattern matching algorithms. In Subsection IV-B, we elaborate the approach how we generate efficient schedules. In Subsection IV-C, we introduce a concept of configuration, which is a combination of a schedule and </p><formula xml:id="formula_2">① (A) (B) (C) (D) ② (A, D, C, B) ③ (A, B, C, D) ④ (A) (B, D) (C) ⑤ (A, C) (B) (D) ⑥ (A, C) (B, D) ⑦ (A, B) (C, D) ⑧ (A, D) (B, C) (c) Permutation group ①②③④⑤⑥⑦⑧ {𝑅 # = 𝑖𝑑 𝐵 &gt; 𝑖𝑑 𝐷 } ①⑦ ① (d) Elimination progress ①②③⑤⑦⑧ Round 1: Round 2: Round 3: Init: …… ① {𝑅 + = 𝑖𝑑 𝐴 &gt; 𝑖𝑑 𝐷 } {𝑅 -= 𝑖𝑑 𝐴 &gt; 𝑖𝑑 𝐶 , 𝑅 # } {𝑅 0 = 𝑖𝑑 𝐴 &gt; 𝑖𝑑 𝐵 , 𝑅 -, 𝑅 # } {𝑅 1 = 𝑖𝑑 𝐶 &gt; 𝑖𝑑 𝐷 , 𝑅 -, 𝑅 # }</formula><p>Fig. <ref type="figure" target="#fig_7">4</ref>: An example of Algorithm 1. (c) is the permutation group formed of all the automorphisms of (a) and each permutation is written as a product of disjoint cycles. (d) is an example of using Algorithm 1 to eliminate all permutations in (c) except the identity permutation.</p><p>a set of restrictions. To select the optimal configuration, we design an accurate performance prediction model to estimate the relative performance of the pattern matching algorithm for each configuration. Finally, we also propose an embedding counting method based on the Inclusion-Exclusion Principle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. 2-Cycle Based Automorphism Elimination</head><p>In GraphPi, we use the concept of permutation group <ref type="bibr" target="#b29">[30]</ref> to formalize our problem. Each automorphism of a pattern can be defined as a permutation function p :</p><formula xml:id="formula_3">V p → V p such that ∀(u i , u j ) ∈ E p , (p(u i ), p(u j )) ∈ E p ,</formula><p>where V p and E p are the vertex set and edge set of a pattern. All automorphisms of a pattern form a permutation group. For example, Figure <ref type="figure" target="#fig_7">4</ref>(a) is a rectangle pattern, and Figure <ref type="figure" target="#fig_7">4</ref>(b) is one of the automorphisms of this pattern. The permutation of this automorphism is A B C D A D C B , and it can be also rewritten as a product of disjoint cycles (A)(B, D)(C), where A and C are fixed (also called 1-cycle), and B and D are exchangeable (also called 2-cycle). Without loss of generality, any k-cycle (k &gt; 1) can be written as a product of 2-cycles. For example, a 4-cycle (A, B, C, D) can be decomposed into (A, D)(A, C)(A, B), which means that we first exchange A and D, then exchange A and C, and finally exchange A and B. Therefore, 2-cycle exchanges are the most essential elements in permutations. Figure <ref type="figure" target="#fig_7">4(c</ref>) is a permutation group formed by all automorphisms of this rectangle pattern. Since any k-cycle (k &gt; 1) can be decomposed into 2-cycles, any permutation in a permutation group can be rewritten as a product of 1-cycles and 2-cycles.</p><p>According to previous studies, we know that automorphisms of embeddings can be eliminated when some restrictions are applied, but the challenge is that which restrictions should be applied. On one hand, if insufficient restrictions are applied, redundant computation cannot be completely eliminated. On the other hand, if too many restrictions are applied, some embeddings will be mistakenly eliminated. In fact, the root cause of repeated embeddings is that a pattern has multiple automorphisms. In this work, we innovatively exploit the property of permutation group to effectively eliminate automorphisms of a pattern. Our core idea is to break the symmetries of permutations by applying restrictions on the essential elements of 2-cycles. We use a concrete example to illustrate the basic idea of our approach. Suppose there is an embedding e 1 (x 1 , x 2 , x 3 , x 4 ) id(A)=x 1 , id(B)=x 2 , etc. of the rectangle pattern in a given graph. Due to the existence of the permutation (A)(B, D)(C) in Figure <ref type="figure" target="#fig_7">4</ref>(c), there must be another embedding e 2 (x 1 , x 4 , x 3 , x 2 ), which is one of the automorphisms of e 1 . Since id(B) = x 2 , id(D) = x 4 for e 1 and id(B) = x 4 , id(B) = x 2 for e 2 , no matter x 2 &gt; x 4 or x 4 &gt; x 2 , one of e 1 and e 2 can be definitely eliminated when applying a restriction id(B) &gt; id(D), which inspires us to apply restrictions on 2-cycles like (B, D). From the perspective of permutation group, the elimination of e 2 can be regarded as the elimination of the permutation (A)(B, D)(C). Therefore, to eliminate all redundant computation caused by automorphisms, we need to eliminate permutations with restrictions on 2-cycles until only an identity permutation i.e., (A)(B)(C)(D) remains in a permutation group.</p><p>As shown in Figure <ref type="figure" target="#fig_7">4(d)</ref>, not all 2-cycles need to be used in one set of restrictions, and therefore the selection of different 2-cycles results in different sets of restrictions. As a restriction associated with a 2-cycle can not only influence those permutations with the same 2-cycles, it can also influence other permutations, we find that even in a permutation with no 2-cycles written as a product of disjoint cycles, it can be still eliminated by restrictions applied for other permutations, which will be discussed later.</p><p>Algorithm 1 presents our 2-cycle based automorphism elimination algorithm. It takes an arbitrary pattern as input and outputs multiple sets of restrictions, and each of them can eliminate all redundant computation. We first generate all the automorphisms and the corresponding permutation group (lines 2∼3). Then, we call a recursive function generate (line 4). If there are permutations other than an identity permutation in the group, more restrictions need to be added to eliminate them (line 7). For each permutation in the group, if we succeed in finding a 2-cycle in the permutation, we append a partial order restriction between the two vertices of the 2cycle (lines 9∼12 The function of no conf lict is used to verify whether a permutation can be eliminated by the current set of restrictions.</p><p>For each restriction in the set, we regard it as two directed edges and add them to an initially empty directed graph g. The permutation is not eliminated if and only if g is a directed acyclic graph (DAG). For example, there are two restrictions id(B) &gt; id(D) and id(A) &gt; id(C) after Round 1 in Figure <ref type="figure" target="#fig_7">4(d)</ref>. We assume that the permutation 2 is not eliminated. After applying these two restrictions, if the pattern matching algorithm can find an embedding e 1 (x 1 , x 2 , x 3 , x 4 ) id(A)=x 1 , id(B)=x 2 , etc. , then another embedding e 2 (x 4 , x 1 , x 2 , x 3 ) can also be found due to the permutation. Since e 1 meets the restrictions, there must be x 2 &gt; x 4 and x 1 &gt; x 3 . Similarly, there must be x 1 &gt; x 3 and x 4 &gt; x 2 for e 2 . Then, we have two contradictory relations x 2 &gt; x 4 and x 4 &gt; x 2 (corresponding to a ring in the directed graph g). Therefore, the assumption does not hold. That is, the permutation 2 is eliminated by these two restrictions.</p><p>In our evaluation, we will show that Algorithm 1 not only generates multiple different sets of restrictions but also has very low overhead. By contrast with the execution time of the pattern matching algorithm, which may take several minutes or even several hours, the overhead of Algorithm 1 can be ignored.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. 2-Phase Computation-Avoid Schedule Generation</head><p>In pattern matching, a schedule represents an order in which each vertex of a pattern is searched. For a pattern with n vertices, there are n! possible schedules. How to select an efficient schedule is a key challenge in pattern matching.</p><p>Typically, an efficient pattern matching algorithm is usually implemented using recursive functions or nested loops. For example, Figure <ref type="figure">5</ref> For simplicity, we temporarily ignore the statement (line 3) related to the restriction. The algorithm searches every vertex in the order specified by the schedule. In this work, we let a candidate set of a vertex be a set where the vertex traverses in a loop. A candidate set is either the neighborhood of a vertex or the intersection of neighborhoods of several vertices in the data graph. For example, the vertex E is connected to A and B in Figure <ref type="figure">5</ref>(a), so in the pseudocode, v E traverses through the intersection of neighborhoods of v A and v B in the data graph, that is, the candidate set of E is</p><formula xml:id="formula_4">N (v A ) ∩ N (v B ).</formula><p>Although there are n! possible schedules for a given pattern, some of them are inefficient. Though our performance prediction module can predict the performance of the schedules generated by the schedule generator, generating efficient schedules instead of all schedules can significantly reduce the overhead of performance prediction. Based on our observation, the overhead of intersection operations is the main cost in pattern matching. Therefore, we propose a 2-phase computationavoid schedule approach to generate efficient schedules. Our approach consists of two key phases. Phase 1 We firstly eliminate schedules which do not satisfy that the ith searched vertex is directly connected to at least one of the first i − 1 searched vertices in the pattern. That is, </p><formula xml:id="formula_5">its expected cardinality is |V G | ⇥ p 1 ⇥ p 2 .</formula><p>According to the definitions of p 1 and p 2 , we have</p><formula xml:id="formula_6">p 1 = |E G | |V G | 2 , p 2 = tri num ⇥ |V G | |E G | 2 ,</formula><p>where E G is the edge set and tri num is the number of triangles in the data graph. By predicting the cardinalities of different intersections, we can calculate the values of l i and c i . We use f i to measure the impact of different sets of restrictions on performance. For a pattern with n vertices, there are n! possible relative magnitudes of ids of n vertices in an embedding. f i is the probability that one embedding will not be filtered out by the restriction in the ith loop. For example, n! 2 possibilities can be filtered out by the restriction id(A) &gt; id(B) in Fig. <ref type="figure">5</ref>(b), thus f 1 = 1 2 . If there are restrictions in multiple loops, each restriction needs to filter the possibilities that remain after the previous restriction. We set f i = 1 if there is no restriction in the ith loop.</p><p>o i represents other overhead in the ith loop, and its value depends on the implementation of the pattern matching algorithm. In our algorithm, we set o i = 1 for all loops.</p><p>Through a large number of experiments, we find a rule that if there are at most k vertices in the pattern that any two of them are not connected, the k vertices are usually searched in the innermost k loops of the optimal configuration. For example, the vertex D is not connected to E in Fig. <ref type="figure">5</ref>(a) and therefore k = 2 in the case of the House pattern. We can times than outer loops, putting the intersection operation in outer loops has relatively less computation in total. Inspired by this rule, we preferentially select the configurations with no intersection operation in the innermost k loops.</p><p>Algorithm 2: code</p><formula xml:id="formula_7">1 for v A 2 V G do 2 for v B 2 N (v A ) {v A } do 3 if id(v A )  id(v B ) then break 4 tmp AB N (v A ) \ N (v B ) 5 for v C 2 N (v A ) {v A , v B } do 6 tmp BC N (v B ) \ N (v C ) 7 for v D 2 tmp BC {v A , v B , v C } do 8 for v E 2 tmp AB {v A , v B , v C , v D } do 9 (v A , v B , v C , v D , v E</formula><p>) is an embedding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Counting with the Inclusion-Exclusion Principle</head><p>Since there is usually no intersection operation in the innermost k loops of the optimal configuration, we can use the Inclusion-Exclusion Principle (IEP) instead of enumeration by the k loops to count the number of embeddings like Fig. <ref type="figure">6(b)</ref>.</p><p>Let S i be the candidate set of the ith vertex among the k vertices.In order to count the number of embeddings, we need to calculate the cardinality of the set S IEP , where</p><formula xml:id="formula_8">S IEP = S 1 ⇥ S 2 ⇥ • • • ⇥ S k {(e 1 , e 2 , • • • , e k )|91  i, j  k s. t. e i = e j }</formula><p>// a restriction Fig. <ref type="figure">5</ref>: For a given configuration like (a), GraphPi can generate efficient code like (b) to find all embeddings. V G is the vertex set of the input data graph. N (v) returns the neighborhood of v in the data graph.</p><p>for an efficient schedule, the subgraph formed by the first i searched vertices must be a connected graph. For example, if we first search vertex C and vertex D in Figure <ref type="figure">5</ref> Phase 2 Suppose there are at most k vertices in a pattern which satisfy that any two of them are not directly connected. We secondly eliminate the schedules which do not satisfy that any two of the last k searched vertices are not directly connected in the pattern. For example, the vertex D is not connected to E in Figure <ref type="figure">5</ref>(a) and therefore k = 2 for this pattern. We can see that D and E are searched in the innermost 2 loops in the pseudocode. This rule can be further explained. The last k searched vertices in a schedule are not directly connected in the pattern, which means that the candidate sets of the last k searched vertices are computed in the outermost n − k loops and there are no intersection operations in the innermost k loops. Since inner loops are executed more times than outer loops, putting intersection operations in outer loops achieves relatively less computation in total. By generating all n! possible schedules and filtering inefficient ones out with the above approach, we get all efficient schedules for further analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. An Accurate Performance Prediction Model</head><p>A main challenge in the graph pattern matching algorithm is that the performance of different schedules and a set of restrictions varies significantly for the same pattern. In this work, we use configuration to denote a combination of a schedule and a set of restrictions. A pattern is used to indicate what kind of subgraph structures to find, while a configuration of this pattern is used to indicate how to find these subgraphs efficiently. To achieve much higher performance, we propose an accurate performance prediction module to determine the optimal configuration. As shown in Figure <ref type="figure">5</ref>(b), the algorithm generated by GraphPi consists of nested loops. The overhead of intersection operations is the main overhead in this algorithm, and the number of intersection operations is determined by both loops and break statements. There are three factors affecting the performance of the algorithm: the cardinality of a set where a loop traverse (e.g., line 1), the probability of breaking a loop because of not satisfying a restriction (e.g., line 3), and the overhead of intersecting two sets (e.g., line 4).</p><p>Since the algorithm uses nested loops for computation, we design a nested performance model correspondingly:</p><formula xml:id="formula_9">cost i = l i × (1 − f i ) × (c i + cost i+1 ), f or 1 ≤ i ≤ n − 1 l i × (1 − f i ), f or i = n</formula><p>where n is the number of vertices of the pattern, cost i is the total cost of the ith loop, l i is the loop size (i.e., the cardinality of a candidate set), f i is the probability that one embedding is filtered out by a restriction, and c i is the computation overhead of the intersection operations. Since the value of cost i depends on cost i+1 , we need to calculate cost i recursively. Next, we describe how we calculate each factor. Measurement of c i and l i The neighborhood of a vertex in the data graph can be sorted in advance, so the time complexity of the intersection operations is O(card 1 +card 2 ), where card 1 and card 2 are the cardinalities of the two sets intersected. For example, there is an intersection operation </p><formula xml:id="formula_10">N (v A ) ∩ N (v B ) (line</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Estimation of Cardinalities</head><p>The sets whose cardinalities need to be predicted can be divided into two categories: the neighborhood of a vertex and the intersection of neighborhoods of several vertices. For the neighborhood of a vertex, its expected cardinality is</p><formula xml:id="formula_11">2×|E G | |V G |</formula><p>, where E G and V G are the edge set and the vertex set of the data graph respectively. For the intersection of two neighborhoods, we use the structural information of the data graph to predict its cardinality. Suppose x is the ith searched vertex in the pattern, and v x traverses through N (v y ) ∩ N (v z ) in the ith loop, where x, y and z are different vertices in the pattern. Based on the first phase in Section IV-B, the subgraph formed by the first i − 1 searched vertices is a connected graph. Since y and z belong to the first i − 1 searched vertices, they are connected. So that x, y and z must be in at least one ring of the subgraph formed by the first i searched vertices. For example, v E traverses through N (v A ) ∩ N (v B ), A, B, and E form a triangle in the pattern. Therefore, we can use the number of triangles in the data graph to predict |v E |, which is tri cnt 2×|E G | . We assume that the data graph is immutable so that the number of triangles (tri cnt) can be regarded as a constant value. Even if the graph is mutable, it is trivial to calculate tri cnt incrementally. For rings that are not triangles, it may take too much time to count all rings in the graph, so we uniformly use the number of triangles for prediction. Without loss of generality, for the intersection of n neighborhoods, the predicted cardinality of the intersection is</p><formula xml:id="formula_12">|V G | × p 1 × p n−1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>, where</p><formula xml:id="formula_13">p 1 = 2 × |E G | |V G | 2 , p 2 = tri cnt × |V G | (2 × |E G |) 2 .</formula><p>Semantically speaking, p 1 is the probability of any pair of vertices being neighbors i.e., P ((a, b)</p><formula xml:id="formula_14">∈ E G |a, b ∈ V G )</formula><p>, and p 2 is the probability of any pair of vertices in a neighborhood being directly connected to each other i.e., <ref type="figure">P ((a, b</ref>)</p><formula xml:id="formula_15">∈ E G |c ∈ V G , a, b ∈ N (c) ) .</formula><p>Measurement of f i We use f i to measure the impact of restrictions on performance. For a pattern with n vertices, there are n! possible relative magnitudes of n vertices in an embedding (e.g., when n = 5, they are <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b3">4]</ref>, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b4">5]</ref>, etc). f i is the probability that one embedding will be filtered out by the restriction in the ith loop. We first initialize a set of S with n! possible relative magnitudes. According to the order in which each restriction appears in the algorithm, we use each restriction in turn to filter out the elements in S that do not satisfy the restriction. If there are several restrictions in different loops, each restriction needs to filter the elements in S that are not filtered out by previous restrictions, and then we can get each value of f i by calculating the ratio of the elements filtered out. For example, since id(A) = 1 &lt; id(B) = 2 for [1,2,3,4,5], it will be filtered out by id(A) &gt; id(B). And n! 2 possibilities of relative magnitudes will be filtered out by id(A) &gt; id(B) in Figure <ref type="figure">5</ref>(b), therefore, f 1 = 1 2 . We set f i = 0 if there is no restriction in the ith loop. Through combining above estimated parameters, we can generate an accurate performance prediction for each configuration and output a configuration with the best performance for the pattern matching algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Counting with Inclusion-Exclusion Principle</head><p>There are many graph mining problems, such as Clique Counting and Motif Counting, which only need to collect the number of embeddings instead of listing all embeddings. This property provides us more optimization opportunities. According to the second phase in Section IV-B, there are usually no intersection operations in the innermost k loops of the optimal configuration. Therefore, we leverage the technique of Inclusion-Exclusion Principle (IEP) instead of enumeration in the innermost k loops to count embeddings. As shown in Figure <ref type="figure">6</ref>(b), S 1 , S 2 and S 3 are the candidate sets of D, E and F . Instead of using v D , v E and v F to traverse through S 1 , S 2 and S 3 respectively, we calculate the cardinality of S IEP in line 11 to count the number embeddings.</p><p>Without loss of generality, let S i be the candidate set of the ith vertex among the k vertices. To count the number of Let Si be the candidate set of the ith vertex among the k vertices. In order to count the number of embeddings, we need to calculate the cardinality of the set SIEP , where</p><formula xml:id="formula_16">SIEP = S1 ⇥ S2 ⇥ • • • ⇥ Sk {(e1, e2, • • • , ek)|91  i, j  k s. t. ei = ej} We define Ai,j = {(e1, e2, • • • , ek)|81  l  k, el 2 Sl, ei = ej} .</formula><p>For the convenience of description, we only consider Ai,j which satisfies 1  i &lt; j  k in this section. According i1,j1 i1⇥k+j1&lt;i2⇥k+j2</p><p>+ ( <ref type="formula">1</ref>)</p><formula xml:id="formula_17">k⇥(k 1) 2 \ i,j Ai,j ,</formula><p>where U is the universal set.  </p><formula xml:id="formula_18">T Ai 2 ,j2 T • • • T Ai m</formula><p>,jm , we use Algorithm 3, which takes (i1, j1), (i2, j2), • • • , (im, jm) as input and outputs the cardinality of the intersection. For each pair (i, j) in the input pairs, we add an undirected edge between i and j in an initially empty undirected graph g (lines 1⇠ 3). Next, we partition g into connected components (line 4). Let Si be the set corresponding to the vertex i in g. We perform intersection operations on the sets corresponding to each vertex in a connected component, and thus, there is an intersection (comp intersection) for every component (lines 6⇠9). We can get the answer by multiplying the cardinalities of the intersections (line 10). For example, in order to calculate A1,2 T A2,3 \ A4,5 when k = 6, we need to add the three edges (1, 2), (2, 3)and(4, 5) into g. After partitioning g, there are three connected components: [1,2,3] , <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> and <ref type="bibr" target="#b5">[6]</ref>. Then we have A1,2</p><formula xml:id="formula_19">T A2,3 \ A4,5 = S1 T S2 T S3 ⇥ S4 T S5 ⇥ S6 .</formula><p>Fig. <ref type="figure">6</ref>: There are at most three vertices (D,E,F) in (a) that any two of them are not connected and therefore k = 3. We use the Inclusion-Exclusion Principle to count the number of embeddings instead of searching v D ,v E and v F by three loops. embeddings, we need to calculate the cardinality of the set S IEP , where</p><formula xml:id="formula_20">S IEP = S 1 × S 2 × • • • × S k − {(e 1 , e 2 , • • • , e k )|∃1 ≤ i, j ≤ k s. t. e i = e j }</formula><p>We define</p><formula xml:id="formula_21">A i,j = {(e 1 , e 2 , • • • , e k )|∀1 ≤ l ≤ k, e l ∈ S l , e i = e j } .</formula><p>For the convenience of description, we only consider A i,j which satisfies 1 ≤ i &lt; j ≤ k in this Section. According to the Inclusion-Exclusion Principle, we have</p><formula xml:id="formula_22">S IEP = i,j A i,j = U − i,j A i,j = k i=1 S i − i,j A i,j + i1,j1 i1×k+j1&lt;i2×k+j2 A i1,j1 A i2,j2 − • • • + (−1) k×(k−1) 2 i,j A i,j ,</formula><p>where U is a universal set.</p><p>To calculate A i1,j1 A i2,j2 • • • A im,jm , we use Algorithm 2, which takes (i 1 , j 1 ), (i 2 , j 2 ), • • • , (i m , j m ) as input and outputs the cardinality of the intersection. For each (i, j) in the input pairs, we add an undirected edge between i and j in an initially empty undirected graph g (lines 1∼ 3). Next, we partition g into connected components (line 4). Let S i be the set corresponding to the vertex i in g. We perform intersection operations on the sets corresponding to each vertex in a connected component, and thus, there is an intersection (comp intersection) for every component (lines 6∼9). We then get the answer by multiplying the cardinalities of the intersections (line 10). For example, to calculate</p><formula xml:id="formula_23">Algorithm 2: Cardinality Calculation Input: k Input: i j pairs Input: S 1 ,S 2 ,• • • ,S k Output: intersection card: A i1,j1 A i2,j2 • • • A im,jm</formula><p>where (i l , j l ) is the lth pair in i j pairs and m is the number of pairs. 1 g ← an empty undirected graph with k vertices 2 for pair ∈ i j pairs do 3 g.add edge(pair.f irst,pair.second) 4 components ← partition g into connected components</p><formula xml:id="formula_24">5 intersection card ← 1 6 for comp ∈ components do 7 comp intersection ← universal set 8 for v ∈ comp do 9 comp intersection ← comp intersection S v.id 10 intersection card ← intersection card × comp intersection 11 return intersection card A 1,2 A 2,3 ∩ A 4,5 when k = 6</formula><p>, we need to add three edges (1, 2), (2, 3), and (4, 5) into g. After partitioning g, there are three connected components: [1,2,3] , <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>, and <ref type="bibr" target="#b5">[6]</ref>. Then we have A 1,2 A 2,3 ∩A 4,5 = S 1 S 2 S 3 × S 4 S 5 × S 6 .</p><p>Note that we have not considered the restrictions during calculations with the Inclusion-Exclusion Principle. The restrictions in outer loops remain, but the restrictions in the innermost k loops do not exist, which leads to overcounting of embeddings. By calling the function of no conf lict in Algorithm 1 for every permutation, we can get the number of permutations that cannot be eliminated by applying the remaining restrictions. Suppose that the number of permutations is x, then the correct number of embeddings is ans IEP x , where ans IEP is the result we calculate by counting with the Inclusion-Exclusion Principle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Distributed Implementation</head><p>To further improve the searching performance, we implement a distributed version of the pattern matching algorithm. We keep the whole data graph in the main memory and replicate it on each computing node. Although cross-node access to graph data can be avoided to reduce the overhead of network communication by keeping a complete copy of the data graph on each node, the size of a data graph that GraphPi can handle is limited by memory. To handle larger graphs, distributed pattern matching faces the challenge of memory-aware graph partitioning and network load balancing, and we will solve these challenges in our future work. In the distributed implementation of GraphPi, we mainly focus on the workload imbalance caused by task partitioning.</p><p>GraphPi stores graphs in the compressed sparse row (CSR) format, that is, the neighborhood of a vertex is sorted and continuous in memory. Therefore, the intersection operation of two sets can be efficiently implemented with the time complexity of O(n + m), where n and m are the cardinalities of the two sets respectively, and the intersection is naturally sorted.</p><p>Since the vertex degrees often follow a power-law distribution in real-world graphs, GraphPi utilizes a fine-grained task partitioning technique to deal with the workload imbalance problem. In GraphPi, there is a master thread responsible for partitioning and distributing tasks. The master thread executes the outer loops and packs the values of the outer loops into a task. Worker threads need to unpack tasks and continue executing the remaining inner loops. For example, in the case of the House pattern (Figure <ref type="figure">5</ref>), suppose the master thread is executing the outmost two loops, and the current values of v A and v B are x and y respectively. Then the master thread sends the task of (x, y) to a worker thread, and the worker thread will find all embeddings that satisfy v A = x and v B = y. The number of outer loops executed by the master thread depends on the complexity of the pattern. For relatively simple patterns like the Triangle pattern, the master thread can balance the workload by executing only one loop (i.e., the outmost loop).</p><p>GraphPi uses a work-stealing algorithm to schedule computations. There is a communication thread that maintains a task queue on each node. When the number of tasks in the task queue is less than a threshold, the communication thread uses asynchronous communication primitives of MPI to steal tasks from other nodes and add them to its queue. When a worker thread runs out of tasks, it takes one or more tasks from the task queue of its node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Methodology</head><p>Platforms Our evaluation is performed on Tianhe-2A supercomputer. Each node has 2 12-core Intel Xeon E5-2692 (v2) processors (hyper-threading disabled) and 64GB of memory. We have implemented GraphPi with an OpenMP/MPI hybrid programming model. On each node, we run 1 MPI process with 24 OpenMP threads. Tianhe-2A uses a customized highspeed interconnection network. Each node runs Kylin Linux with Linux kernel version 3.10.0 and gcc version 4.8.5. All programs are compiled with -O3 optimization option. Datasets We use 6 real-world graphs as shown in Table <ref type="table" target="#tab_5">I</ref>. These graphs are also used in GraphZero <ref type="bibr" target="#b11">[12]</ref>. The numbers of vertices and edges range from 7.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graphs</head><p>#Vertices #Edges Description Wiki-Vote <ref type="bibr" target="#b30">[31]</ref> 7.1K 100.8K Wiki Editor Voting MiCo <ref type="bibr" target="#b31">[32]</ref> 96.6K 1.1M Co-authorship Patents <ref type="bibr" target="#b26">[27]</ref> 3.8M 16.5M US Patents LiveJournal <ref type="bibr" target="#b12">[13]</ref> 4.0M 34.7M Social network Orkut <ref type="bibr" target="#b32">[33]</ref> 3.1M 117.2M Social network Twitter <ref type="bibr" target="#b33">[34]</ref> 41.7M 1.2B Social network</p><p>Patterns We use six patterns as shown in Figure <ref type="figure" target="#fig_9">7</ref>, and the first two of them are also used in GraphZero. We use four additional patterns since the patterns used in GraphZero are relatively simple, and it is trivial to predict the performance of different schedules for them.</p><p>Comparison We evaluate GraphPi's performance against GraphZero <ref type="bibr" target="#b11">[12]</ref> and Fractal <ref type="bibr" target="#b25">[26]</ref>, the state-of-the-art singlemachine pattern matching systems. GraphZero is an upgraded version of AutoMine <ref type="bibr" target="#b17">[18]</ref>, and it outperforms AutoMine by up to 40×. Fractal is a JVM-based system, and it outperforms several JVM-based specialized algorithms (MRSUB <ref type="bibr" target="#b34">[35]</ref>, SEED <ref type="bibr" target="#b35">[36]</ref> and QKCount <ref type="bibr" target="#b36">[37]</ref>) and general-purpose systems (Arabesque <ref type="bibr" target="#b13">[14]</ref> and GraphFrames <ref type="bibr" target="#b37">[38]</ref>) by orders of magnitudes. Since GraphZero is not released, we reproduce all the algorithms described in GraphZero and also compare its performance with the results reported in their paper. In the following experiments, we use "GraphZero" to denote the performance of the reproduced version of GraphZero and use "GZ Paper" to denote the performance results reported in GraphZero's paper. Since the definition of pattern matching in AutoMine and GraphZero is different from other systems, we made some minor modifications in the reproduced version to make its results consistent with those of other systems. When comparing with GraphZero and Fractal, GraphPi runs on a single node and does not use the optimization with Inclusion-Exclusion Principle (IEP). The time reported in our evaluation does not include the graph loading time or the program preprocessing and compiling time.</p><p>To guarantee the correctness of GraphPi, we compare GraphPi's results with those of Fractal and (the reproduced version of) GraphZero. The results show that the numbers of embeddings obtained by three systems are the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Overall Performance</head><p>We perform experiments with GraphPi, GraphZero, and Fractal to find all embeddings of the 6 patterns on 5 real-world graphs. Figure <ref type="figure" target="#fig_10">8</ref> compares the performance of GraphPi with GraphZero and Fractal in a log scale, and the performance results reported in GraphZero's paper are also shown on it. We only list the workloads that can be done within 48 hours. On average, GraphPi outperforms GraphZero by 9.7×, 1.4×, 26.0×, 11.7×, 42.5×, and 60.3× respectively for 6 patterns on different graphs. We get the highest speedup of 105× for P 6 on Wiki-Vote. In general, much higher speedups can be obtained on a larger graph, but GraphZero cannot finish the searching within 48 hours on large graphs. Since Fractal runs out of memory on Orkut, we only list the performance of Fractal on the other 4 graphs. On average, GraphPi outperforms Fractal by 83.6×, 64.9×, 154.3×, 35.5×, 36.5×, and 25.7× respectively for 6 patterns on different graphs. The speedup mainly comes from the optimal configuration used in the pattern matching algorithm automatically generated by GraphPi. We will show more detailed results of our systems below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Breakdown Analysis</head><p>Restriction Set Generation To eliminate redundant computation caused by automorphisms, a set of restrictions need to be applied in pattern matching. There are many different sets of restrictions for one pattern, but their performance varies significantly. For a given schedule of a pattern, GraphPi generates different sets of restrictions and selects the best one based on our performance prediction model. In contrast, GraphZero can only generate one set of restrictions, and sometimes it may achieve sub-optimal results.</p><p>We run all schedules of P 1 , P 2 , and P 4 with GraphPi and GraphZero on Wiki-Vote and Patents. The restriction sets selected by GraphPi and GraphZero are different in some schedules, which leads to varied performance. For these schedules, we compare the performance of GraphPi with that of GraphZero.  the same schedule. The speedup mainly comes from a better set of restrictions selected by GraphPi. These results also demonstrate that generating multiple sets of restrictions for a schedule in GraphPi provides more choices and optimization opportunities for the pattern matching algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Schedule Generation and Selection</head><p>The selection of schedules also has a significant influence on the performance of the pattern matching. We perform experiments with schedules generated by GraphPi and GraphZero for each pattern on Wiki-Vote and Patents. To avoid the influence of different sets of restrictions on performance, we use the same restriction generation algorithm proposed by GraphZero for both GraphPi and GraphZero in this experiment. On average, GraphPi outperforms GraphZero by 25.6× for 6 patterns on Wiki-Vote and Patents. The speedup comes from GraphPi's computationavoid schedule generator and accurate performance model. Figure <ref type="figure">9</ref> shows the performance of different schedules of P 3 on Wiki-Vote, including two final schedules selected by GraphPi (denoted by the blue star) and GraphZero (denoted by the red triangle). The "•" marker denotes the schedules generated by GraphPi's 2-phase computation-avoid schedule generator, and the "×" marker denotes the schedules eliminated by the generator. We can see that most schedules with low performance (including the one selected by GraphZero) are eliminated, which shows the benefit of our 2-phase schedule generator in accurately generating efficient schedules. Among all efficient schedules (denoted by "•"), the oracle schedule is 8.0× faster than the slowest schedule. This is because our performance prediction model can further select the optimal schedule (blue star marker) from these efficient schedules, which is only 22% slower than the oracle schedule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Accuracy of Performance Prediction Model</head><p>To further demonstrate the accuracy of GraphPi's performance prediction model, we perform experiments with all schedules generated by GraphPi for each pattern on Wiki-Vote and Patents. Figure <ref type="figure" target="#fig_12">11</ref> shows the performance of the schedules selected by GraphPi and the oracle schedules. On average, schedules selected by GraphPi are only 32% slower than the oracle schedules. There is a performance gap between the selected schedule and the oracle schedule of P 4 on Wiki-Vote, this is because the prediction of the number of rectangles (i.e., the subpattern formed by the top 4 vertices of P 4 ) on Wiki-Vote is not accurate enough due to the insufficient structural information we leverage (only the numbers of vertices, edges and triangles). To achieve more accurate prediction, we need to use more structural information of data graphs in the performance prediction model.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Counting Embeddings with IEP</head><p>We also do optimization with the Inclusion-Exclusion Principle (IEP) in GraphPi instead of enumeration to count the number of embeddings. We evaluate the performance of GraphPi when enabling IEP or not for each pattern. We use the same configuration selected by GraphPi's performance model in experiments, that is, we avoid the influence of schedules and sets of restrictions on performance. As shown in Figure <ref type="figure" target="#fig_11">10</ref>, counting with IEP outperforms that without IEP by 4.3×, 457.8×, 320.5×, 265.5×, 11.1×, and 10.1× respectively for 6 patterns on different graphs on average. We obtain the highest speedup of 1110.5× for P 2 on LiveJournal. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Scalability of Distributed Version</head><p>In this subsection, we evaluate the scalability of GraphPi system with up to 1,024 nodes (24,576 processor cores) on Tianhe-2A supercomputer. Figure <ref type="figure" target="#fig_13">12</ref> shows the speedup obtained with the increasing number of nodes on Orkut and Twitter. GraphPi obtains a near-linear speedup with 128 nodes when running P 1 , P 4 , P 5 , and P 6 on Orkut. P 2 and P 3 do not scale very well on Orkut because their execution times are very short (10.9 seconds and 8.1 seconds respectively). For the experiment on Twitter, since the execution times of other patterns with 128 nodes exceed 24 hours, we only evaluate P 2 and P 3 on 128∼1024 nodes. GraphPi does not get linear speedups for P 2 and P 3 on Twitter due to load imbalance. In the future, we plan to implement much fine-grained subtask partitioning in GraphPi to solve this problem. The time reported in previous experiments does not include the preprocessing (i.e., configuration generation and performance prediction) and code generation time. In this subsection, we evaluate the overhead of preprocessing and code generation in GraphPi. As can be seen from the preprocessing algorithm, the overhead is only related to the structure of a pattern but not to the input data graph. Table <ref type="table" target="#tab_9">III</ref> shows the overhead of preprocessing and code generation ranging from 8 milliseconds to 2.53 seconds. Compared with the execution time of the pattern matching that may take several minutes or even several hours, the overhead can be ignored.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>General-Purpose Graph Mining Systems Arabesque <ref type="bibr" target="#b13">[14]</ref> is the first distributed graph mining system that provides a highlevel abstraction and a flexible programming model. It maintains some intermediate data of subgraphs and generates all pattern instances by appending edges to candidate subgraphs and filtering the newly generated candidates using the userdefined filter and process functions. G-thinker <ref type="bibr" target="#b15">[16]</ref> provides an intuitive graph-exploration API for implementing various graph mining algorithms and an efficient runtime engine.</p><p>G-Miner <ref type="bibr" target="#b16">[17]</ref> models the processing of a graph mining job as an independent task and streamlines task processing with a novel design. RStream <ref type="bibr" target="#b14">[15]</ref> is a single-machine system which implements relational algebra efficiently with tuple streaming. To support scalable graph mining, RStream uses out-of-core processing to leverage disk support to store intermediate data.</p><p>Graph Pattern Matching Systems Although general-purpose graph mining systems provide flexible programming models to express complex graph mining algorithms, their performance is relatively poor. Specialized pattern matching systems have been proposed <ref type="bibr" target="#b18">[19]</ref>- <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b39">[40]</ref>. Automine <ref type="bibr" target="#b17">[18]</ref> is built upon a set-based representation and uses compilation techniques to generate efficient pattern matching code. However, due to the inherent symmetry in the structural patterns, Automines algorithm causes substantial computation redundancy. Based on Automine, GraphZero <ref type="bibr" target="#b11">[12]</ref> provides an algorithm based on group theory to break the inherent symmetry in patterns and eliminate redundant computation. Peregrine <ref type="bibr" target="#b40">[41]</ref> is another DFS-based system which provides a pattern-based programming model and a workflow similar to GraphZero. Peregrine also has a schedule generation module. However, the schedule generated by Peregrine is only based on the pattern, without considering the distribution of data in different data graphs. Approximate Subgraph Counting Some computation engines and systems have been designed to estimate an approximate number of embeddings <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref>. ASAP <ref type="bibr" target="#b22">[23]</ref> is the state-of-the-art one among them. ASAP is a distributed approximate computation engine for graph pattern matching. Based on the neighborhood sampling algorithm, ASAP samples embeddings from the stream of the edge set of a graph to do an approximate estimation. Although these approximate systems have good scalability, they cannot list all embeddings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>In this work, we propose GraphPi, a high-performance distributed pattern matching system. We design a 2-cycle based automorphism elimination algorithm and an accurate performance model to eliminate redundancy in pattern matching. When counting embeddings, we further propose using the Inclusion-Exclusion Principle to achieve significant improvement in performance. Results show that GraphPi outperforms the state-of-the-art pattern matching system by up to two orders of magnitude on a single node and can scale to 1,024 nodes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 :</head><label>1</label><figDesc>Fig.1: An example of pattern matching. The numeric letters denote different vertices in the input graph. The capital letters denote different vertices in the pattern. The numeric numbers in a square bracket denote a one-to-one correspondence (a bijective function). For example,<ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b2">3]</ref> denotes the function id where id(A) = 4, id(B) = 5, etc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: Overview of GraphPi.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>(b) is the pseudocode of the algorithm generated by GraphPi for the House pattern with a schedule of A → B → C → D → E and a restriction of id(A) &gt; id(B).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>4 )</head><label>4</label><figDesc>in the second loop in Figure 5(b), so c 2 = |N (v A )| + |N (v B )|. l i can be also represented by the cardinality of a set e.g., for the fourth loop in line 7, l 4 = |tmp AB | = |N (v A )∩N (v B )| . Therefore, we can get the values of c i and l i by predicting the cardinalities of different sets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>therefore k = 3 .Algorithm 2 : code 1 cnt 0 2 for vA 2 VG do 3 for vB 2 N 6 for vC 2 N</head><label>323262</label><figDesc>We can use the Inclusion-Exclusion Principle to count the number of embeddings instead of searching vD,vE and vF by three loops. (vA) {vA} do 4 if id(vA)  id(vB) then break 5 tmpAB N (vA) \ N (vB) (vA) {vA, vB} do 7 if id(vB)  id(vC) then break 8 S1 tmpAB {vA, vB, vC} // vD 9 S2 N (vA) \ N (vC) {vA, vB, vC} // vE 10 S3 N (vB) \ N (vC) {vA, vB, vC} // vF 11 SIEP {(e1, e2, e3)|ei 2 Si, e1 6 = e2, e2 6 = e3, e1 6 = e3} 12 cnt cnt + SIEP the cardinality of the set in line 11 to count the number embeddings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: Patterns used in the evaluation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Overall performance of GraphPi, GraphZero, and Fractal. "T" means the execution time exceeds 48 hours.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 :</head><label>10</label><figDesc>Fig. 10: The performance of counting the number of embeddings with and without the Inclusion-Exclusion Principle (IEP). "T" means the execution time exceeds 48 hours.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 11 :</head><label>11</label><figDesc>Fig. 11: The accuracy of GraphPi's performance prediction model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 12 :</head><label>12</label><figDesc>Fig. 12: Scalability of GraphPi.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>). Next, we use a new set of restrictions to Algorithm 1: 2-cycle based automorphism elimination Input: pattern: the pattern Output: res sets: sets of restrictions 1 Function res_set_generation(pattern):</figDesc><table><row><cell>2 3 4 5</cell><cell>auts ← all the automorphisms of pattern pg ← the permutation group formed of auts res sets ← generate(pg, ∅) return res sets</cell></row><row><cell cols="2">6 Function generate(pg, res set): 7 if pg.size &gt; 1 then</cell></row><row><cell>8 9 10 11</cell><cell>sets ← ∅ for perm ∈ pg do for vertex ∈ perm do if vertex = perm[perm[vertex]] then</cell></row><row><cell></cell><cell>// a 2-cycle is found</cell></row><row><cell>12 13 14 15</cell><cell>new set ← res set ∪ pair(vertex, p[vertex]) remaining pg ← ∅ for p ∈ pg do if no conflict(p, new set) then</cell></row><row><cell>16</cell><cell>remaining pg.add(p)</cell></row><row><cell>17 18 19 20 21 22 23</cell><cell>sets ← sets ∪ generate(remaining pg, new set) return sets else // only the identity permutation if validate(res set) then return res set else return ∅</cell></row><row><cell>29</cell><cell>return g.acyclic()</cell></row><row><cell cols="2">eliminate permutations (lines 13∼16). In order to eliminate the remaining permutations, we generate more restrictions by calling the function of generate recursively (line 17). When there is only one identity permutation in the group, we verify the current set of restrictions by calling the validate(res set) function (lines 19∼20). Assuming that the pattern has n vertices, we run a pattern matching algorithm with the input set of restrictions (i.e., res set) on an n-vertex complete graph and rerun it without restrictions. The set of restrictions is cor-rect if ans</cell></row></table><note><ref type="bibr" target="#b23">24</ref> Function no_conflict(perm, res set): 25 g ← an empty directed graph 26 for res ∈ res set do 27 g.add dir edge(res.first, res.second) 28 g.add dir edge(perm[res.first],perm[res.second]) with = ans without /automorphisms count, where ans with is the number of embeddings found during the pattern matching process with the set of restrictions and ans without is that without restrictions (i.e., including all automorphisms).</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>(a) and the third searched vertex is E, this schedule is inefficient regardless of what the search order of the remaining two vertices is, because there is no edge between E and C or E and D in the pattern. This rule can be further explained. For the third searched vertex E, since E is not connected to C or D, the candidate set of E is the entire vertex set (i.e., V</figDesc><table /><note>G ). If we use vertex A instead of E as the third searched vertex, the candidate set of A will be the intersection of neighborhoods of C and D (i.e., N (C) ∩ N (D)). Obviously, |V G | is much larger than |N (C)∩N (D)| in real-world graphs, which results in more computation in inner loops. So it is not an efficient schedule to choose E as the third searched vertex when C and D are the first two searched vertices.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>T • • • T Ai m ,jm where (il, jl) is the lth pair in i j pairs and m is the number of pairs. 1 g an empty undirected graph with k vertices 2 for pair 2 i j pairs do 3 g.add edge(pair.f irst,pair.second)</figDesc><table><row><cell cols="2">4 components</cell><cell>partition g into connected components</cell></row><row><cell cols="3">5 intersection card 6 for comp 2 components do 1 7 comp intersection universal set 8 for v 2 comp do 9 comp intersection comp intersection T Sv.id</cell></row><row><cell>10</cell><cell cols="2">intersection card</cell></row><row><cell cols="3">intersection card ⇥ comp intersection 11 return intersection card</cell></row><row><cell></cell><cell cols="2">In order to calculate Ai 1 ,j1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>1 thousand to 41.7 million, and 100.8 thousand to 1.2 billion, respectively. The largest graph (Twitter) is only used for scalability experiments.</figDesc><table><row><cell>𝑃 "</cell><cell>𝑃 '</cell><cell>𝑃 $</cell><cell>𝑃 %</cell><cell>𝑃 #</cell><cell>𝑃 &amp;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE I :</head><label>I</label><figDesc>Graph datasets.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Table II shows the average speedup and maximum speedup obtained with GraphPi over GraphZero. GraphPi achieves up to 7.8× speedup than GraphZero for</figDesc><table><row><cell></cell><cell>10 3</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Eliminated schedules</cell></row><row><cell>Execution Time(Sec)</cell><cell>10 1 10 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Generated schedules Selected by GraphZero Selected by GraphPi</cell></row><row><cell></cell><cell>10 0</cell><cell>0</cell><cell>50</cell><cell>100</cell><cell>150</cell><cell>200 Schedules 250</cell><cell>300</cell><cell>350</cell><cell>400</cell></row></table><note>Fig. 9: Performance of different schedules of P 3 on Wiki-Vote.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE II :</head><label>II</label><figDesc>Speedup obtained with the better set of restrictions selected by GraphPi.</figDesc><table><row><cell>Graph</cell><cell>Pattern</cell><cell>Average Speedup</cell><cell>Maximum Speedup</cell></row><row><cell>Wiki-Vote Patents</cell><cell>P 1 P 2 P 4 P 1 P 2 P 4</cell><cell>1.94 1.71 1.60 2.02 1.65 2.46</cell><cell>2.52 4.10 2.39 5.08 6.65 7.82</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>TABLE III :</head><label>III</label><figDesc>The overhead of preprocessing and code generation in GraphPi for each pattern.</figDesc><table><row><cell cols="2">Pattern Overhead (second)</cell></row><row><cell>P 1 P 2 P 3 P 4 P 5 P 6</cell><cell>0.008 0.07 0.04 0.07 1.88 2.53</cell></row><row><cell cols="2">F. Overhead of Preprocessing and Code Generation</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">https:// github.com/ thu-pacman/ GraphPi</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Diversified top-k graph pattern matching</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1510" to="1521" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Biomolecular network motif counting and discovery by color coding</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hajirasouliha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hormozdiari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Sahinalp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="241" to="249" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A selectivity based approach to continuous pattern detection in streaming graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Holder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feo</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1503.00849</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Gridgraph: Large-scale graph processing on a single machine using 2-level hierarchical partitioning</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 USENIX Annual Technical Conference USENIX ATC &apos;15)</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="375" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Gemini: A computationcentric distributed graph processing system</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;16)</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="301" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Powerlyra: Differentiated graph computation and partitioning on skewed graphs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Parallel Computing (TOPC)</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Powergraph: Distributed graph-parallel computation on natural graphs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presented as part of the 10th USENIX Symposium on Operating Systems Design and Implementation</title>
				<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="17" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Graphx: Graph processing in a distributed dataflow framework</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Crankshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th USENIX Symposium on Operating Systems Design and Implementation</title>
				<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="599" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Flashgraph: Processing billion-node graphs on an array of commodity ssds</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mhembere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vogelstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Priebe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Szalay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Conference on File and Storage Technologies</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="45" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">X-stream: Edge-centric graph processing using streaming partitions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mihailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles</title>
				<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="472" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Chaos: Scale-out graph processing from secondary storage</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bindschaedler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malicevic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles</title>
				<meeting>the 25th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="410" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Graphzero: Breaking symmetry for efficient graph mining</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reinehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1911.12877</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Group formation in large social networks: membership, growth, and evolution</title>
		<author>
			<persName><forename type="first">L</forename><surname>Backstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Huttenlocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM SIGKDD international conference on Knowledge discovery and data mining</title>
				<meeting>the 12th ACM SIGKDD international conference on Knowledge discovery and data mining</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="44" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Arabesque: a system for distributed graph mining</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Siganos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles</title>
				<meeting>the 25th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="425" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Rstream: Marrying relational algebra with streaming for efficient graph mining on a single machine</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Thorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;18)</title>
				<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="763" to="782" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">G-thinker: big graph mining made easier and faster</title>
		<author>
			<persName><forename type="first">D</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Özsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lui</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1709.03110</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">G-miner: an efficient task-oriented graph mining system</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth EuroSys Conference</title>
				<meeting>the Thirteenth EuroSys Conference</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automine: harmonizing high-level abstraction and high performance for graph mining</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM Symposium on Operating Systems Principles</title>
				<meeting>the 27th ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="509" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Prunejuice: pruning trillion-edge graphs to a precise pattern-matching solution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Reza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ripeanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tripoul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pearce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC18: International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="265" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Ceci: Compact embedding cluster index for scalable subgraph matching</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bhattarai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data</title>
				<meeting>the 2019 International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1447" to="1462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Qfrag: Distributed graph search via subgraph isomorphism</title>
		<author>
			<persName><forename type="first">M</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Francisci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morales</surname></persName>
		</author>
		<author>
			<persName><surname>Siganos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 Symposium on Cloud Computing</title>
				<meeting>the 2017 Symposium on Cloud Computing</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="214" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Graph sample and hold: A framework for big-graph analytics</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Duffield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Neville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kompella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining</title>
				<meeting>the 20th ACM SIGKDD international conference on Knowledge discovery and data mining</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1446" to="1455" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Asap: Fast, approximate graph pattern mining at scale</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkataraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Braverman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;18)</title>
				<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="745" to="761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Scalemine: Scalable parallel frequent subgraph mining in a single large graph</title>
		<author>
			<persName><forename type="first">E</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Abdelaziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kalnis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Khayyat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jamour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC&apos;16: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="716" to="727" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A distributed approach for graph mining in massive networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Talukder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1024" to="1052" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fractal: A general-purpose graph pattern mining system</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Guedes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data</title>
				<meeting>the 2019 International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1357" to="1374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Graphs over time: densification laws, shrinking diameters and possible explanations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eleventh ACM SIGKDD international conference on Knowledge discovery in data mining</title>
				<meeting>the eleventh ACM SIGKDD international conference on Knowledge discovery in data mining</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="177" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Network motif discovery using subgraph enumeration and symmetry-breaking</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Grochow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Conference on Research in Computational Molecular Biology</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="92" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Turboiso: towards ultrafast and robust subgraph isomorphism search in large graph databases</title>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data</title>
				<meeting>the 2013 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Wielandt</surname></persName>
		</author>
		<title level="m">Finite permutation groups</title>
				<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Predicting positive and negative links in online social networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Huttenlocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on World wide web</title>
				<meeting>the 19th international conference on World wide web</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="641" to="650" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Grami: Frequent subgraph and pattern mining in a single large graph</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elseidy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Skiadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kalnis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="517" to="528" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Defining and evaluating network communities based on ground-truth</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge and Information Systems</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="181" to="213" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">What is twitter, a social network or a news media</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on World wide web</title>
				<meeting>the 19th international conference on World wide web</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="591" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Distributed discovery of frequent subgraphs of a network using mapreduce</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shahrivari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jalili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1101" to="1120" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Scalable distributed subgraph enumeration</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="217" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Clique counting in mapreduce: Algorithms and experiments</title>
		<author>
			<persName><forename type="first">I</forename><surname>Finocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Finocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Fusco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Experimental Algorithmics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>JEA)</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Graphframes: an integrated api for mixing graph and relational queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jindal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Workshop on Graph Data Management Experiences and Systems</title>
				<meeting>the Fourth International Workshop on Graph Data Management Experiences and Systems</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A (sub) graph isomorphism algorithm for matching large graphs</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Cordella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Foggia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sansone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vento</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE transactions on pattern analysis and machine intelligence</title>
				<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1367" to="1372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Exploiting vertex relationships in speeding up subgraph isomorphism over large graphs</title>
		<author>
			<persName><forename type="first">X</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="617" to="628" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Peregrine: a pattern-aware graph mining system</title>
		<author>
			<persName><forename type="first">K</forename><surname>Jamshidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mahadasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth European Conference on Computer Systems</title>
				<meeting>the Fifteenth European Conference on Computer Systems</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Mining large networks with subgraph counting</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bordino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Donato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Leonardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2008 Eighth IEEE International Conference on Data Mining</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="737" to="742" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Counting stars and other small subgraphs in sublinear-time</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1365" to="1411" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
