<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Late-Binding: Enabling Unordered Load-Store Queues</title>
				<funder ref="#_DNHRPvp">
					<orgName type="full">Defense Advanced Research Projects Agency</orgName>
				</funder>
				<funder ref="#_wspXKgZ">
					<orgName type="full">NSF CISE Research Infrastructure</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Simha</forename><surname>Sethumadhavan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Sciences ? VSSAD</orgName>
								<orgName type="institution">Intel</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">The University of Texas</orgName>
								<address>
									<settlement>Austin Hudson</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Franziska</forename><surname>Roesner</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Sciences ? VSSAD</orgName>
								<orgName type="institution">Intel</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">The University of Texas</orgName>
								<address>
									<settlement>Austin Hudson</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Joel</forename><forename type="middle">S</forename><surname>Emer</surname></persName>
							<email>joel.emer@intel.com</email>
						</author>
						<author>
							<persName><forename type="first">Doug</forename><surname>Burger</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Sciences ? VSSAD</orgName>
								<orgName type="institution">Intel</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">The University of Texas</orgName>
								<address>
									<settlement>Austin Hudson</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Stephen</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Sciences ? VSSAD</orgName>
								<orgName type="institution">Intel</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">The University of Texas</orgName>
								<address>
									<settlement>Austin Hudson</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Late-Binding: Enabling Unordered Load-Store Queues</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C [Computer Systems Organization]</term>
					<term>C.1 [Processor Architectures]</term>
					<term>C.1.1 [Single Data Stream Architectures]: Subjects: Single-instruction-stream, single-data-stream processors (SISD)Additional Classification:</term>
					<term>C [Computer Systems Organization]</term>
					<term>C.2 [Computer-Communication Networks]</term>
					<term>C.2.1 [Network Architecture and Design]: Subjects: Packet-switching networks Design, Performance Late-binding, Memory Disambiguation, Network flow control</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conventional load/store queues (LSQs) are an impediment to both power-efficient execution in superscalar processors and scaling to large-window designs. In this paper, we propose techniques to improve the area and power efficiency of LSQs by allocating entries when instructions issue ("late binding"), rather than when they are dispatched. This approach enables lower occupancy and thus smaller LSQs. Efficient implementations of late-binding LSQs, however, require the entries in the LSQ to be unordered with respect to age. In this paper, we show how to provide full LSQ functionality in an unordered design with only small additional complexity and negligible performance losses. We show that latebinding, unordered LSQs work well for small-window superscalar processors, but can also be scaled effectively to large, kilo-window processors by breaking the LSQs into address-interleaved banks.</p><p>To handle the increased overflows, we apply classic network flow control techniques to the processor micronetworks, enabling lowoverhead recovery mechanisms from bank overflows. We evaluate three such mechanisms: instruction replay, skid buffers, and virtual-channel buffering in the on-chip memory network. We show that for an 80-instruction window, the LSQ can be reduced to 32 entries. For a 1024-instruction window, the unordered, late-binding LSQ works well with four banks of 48 entries each. By applying a Bloom filter as well, this design achieves full hardware memory disambiguation for a 1,024 instruction window while requiring low average power per load and store access of 8 and 12 CAM entries, respectively.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fetch</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>A long-standing challenge in computer architecture has been handling memory dependences in a scalable manner without sacrificing programmability or parallelism. Dataflow computers in the 1970's and 80's supported high concurrency, but required unconventional programming models (write-once memory semantics) to prevent incorrect memory behavior. Modern superscalar processors enforce memory dependences while supporting standard programming models using load/store queues (LSQs). These LSQs, however, are one of the primary structures inhibiting the scaling of superscalar processors to larger in-flight windows, since they have typically supported only a few tens of in-flight loads and stores due to power and complexity limits.</p><p>These limits have led an industry-wide shift to chip multiprocessors (CMPs). Much current research is focusing on CMPs in which the individual are processors smaller, lower power, and simpler, effectively reducing single-thread performance to support more threads. This trend is reducing the instruction-level parallelism that can be exploited, placing a higher burden on software and/or programmers to use a fine-grained chip multiprocessor effectively. An alternative to CMPs are tiled large-window microarchitectures that can scale to thousands of in-flight instructions, while potentially exploiting multiple threads in addition to providing a large window for single-threaded execution. Memory disambiguation at this scale, however, has been a key limitation for these types of architectures. This paper describes an LSQ design that both provides power and area improvements for conventional superscalar designs and which provides the ability to scale to thousands of instructions power efficiently. The two new techniques that provide this scaling are unordered late binding, in which loads and stores allocate LSQ entries after they issue, and lightweight overflow control, which enables good performance with unordered LSQs that are divided into multiple small, address-interleaved partitions.</p><p>Late binding: Traditional LSQs allocate entries at fetch or dispatch time, and deallocate them at commit. Thus, entries in a conventional LSQ physically age-ordered, a feature that LSQ designs exploit to provide the necessary functionality efficiently. When an LSQ reaches capacity, the microarchitecture typically throttles fetch until a load or store commits and is removed from the LSQ. Figure <ref type="figure" target="#fig_0">1</ref> shows a simple six-stage pipeline diagram with nine memory instructions (loads and stores labeled A through I) in different stages. As shown in Figure <ref type="figure" target="#fig_0">1a</ref>, a conventional eight-entry LSQ is full after H is dispatched, stalling the fetch of later instructions.</p><p>Unordered, late-binding LSQs (ULB-LSQs) can reduce both the average occupancy time and average number of entries in use. ULB-LSQs achieve this reduction by allocating entries only when a load or store issues, instead of when it is fetched, permitting a smaller, more efficient structure. Figure <ref type="figure" target="#fig_0">1b</ref> shows the smaller ULB-LSQ that must be sufficiently large only to capture the inflight loads and stores after they have issued. Figure <ref type="figure" target="#fig_1">2</ref> shows the potential savings of late-binding, issue-time allocation. On the Alpha 21264 microarchitecture, only 32 or fewer memory instructions must be buffered in the LSQ for 99% of the execution cycles, even though the original 21264 design had a combined LQ/SQ capacity of 64 entries.</p><p>To achieve this reduction, however, the entries in an ULB-LSQ must be unordered; loads and stores are allocated LSQ entries in their dynamic issue order as opposed to the traditional in-order fetch sequence. Maintaining age order with issue-time allocation would require a complex and power-inefficient compacting-FIFOlike circuit <ref type="bibr" target="#b7">[7]</ref>. This paper describes an ULB-LSQ design that requires only small additional complexity while performing comparably to a traditional ordered LSQ.</p><p>Low overhead overflow handling: A second advantage above and beyond the reduced size is that ULB-LSQs lend themselves naturally to address partitioning, enabling smaller banks that are indexed by address. However, smaller banks will experience more overflows. In small-window superscalar processors, flushing the pipeline on an ULB-LSQ overflow is an acceptable policy, since the ULB-LSQ can be sized to save area and power over a conventional design while overflowing infrequently. However, ULB-LSQs can also provide efficient memory disambiguation for largewindow processors, in which thousands of instructions may be in flight <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b24">24]</ref>, by exploiting the ability to address interleave LSQ banks. The late binding and unordered organization are both necessary to support an undersized, address-interleaved LSQ, since the mapping of loads and stores to LSQ banks cannot be known at fetch/dispatch time.</p><p>In large-window designs, however, the probability of overflows grows, since the global ULB-LSQ is divided into smaller interleaved partitions that are more susceptible to overflows when the distribution of loads and stores to banks is unbalanced. Figure <ref type="figure" target="#fig_0">1c</ref> shows how load imbalance for an address-interleaved ULB-LSQ increases the likelihood of overflow. In the example, each of four address-interleaved partitions holds one entry. Whereas instruction E could have been held in the centralized ULB-LSQ of Figure <ref type="figure" target="#fig_0">1b</ref>, E conflicts in the banked example with instruction B, which was mapped to the same partition.</p><p>As the banks are shrunk and the number of overflows increases, the conventional techniques of throttling fetch or flushing the pipeline become too expensive. By incorporating techniques to handle overflows with low overhead, an ULB-LSQ for a largewindow design can consist of small partitions, resulting in low energy per load or store, while still supporting high performance across a large-window processor. We observe that in a distributed, large-window processor, LSQ banks can be treated as clients on a micronetwork, with overflows handled using traditional network flow-control techniques adapted for a distributed processor microarchitecture. We evaluate three such techniques in this paper: instruction replay, skid buffers, and micronet virtual channels.</p><p>This paper shows that ULB-LSQs with appropriate overflow support work well for both small and large-window processors. For an Alpha 21264 microarchitecture with an 80-instruction window, a 32-entry ULB-LSQ using flush-on-overflow provides the same performance as a 64-entry split LQ/SQ. For the 1,024-instruction window TRIPS processor, four banks of 48 entries each-using virtual channel flow control to handle overflows-provides the same performance as an idealized 1,024-entry LSQ. By adding a Bloom Filter <ref type="bibr" target="#b22">[22]</ref>, the banked ULB-LSQ design incurs, for a kilo-instruction window, an average of only eight and twelve CAM entries searched per load and store, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRIOR LSQ INNOVATIONS</head><p>Most of the recent LSQ optimization proposals, including proposals for non-associative LQ/SQs, focus primarily on reducing the dynamic power and latency of LSQs. Typically these schemes also reduce or eliminate the power-hungry CAMs, but add numerous predictors and other significant supporting structures outside of the LSQ, effectively increasing the area of the total memory disambiguation logic.</p><p>Cain and Lipasti eliminate the associative load queue by having loads compare their speculative values to the cached values at commit time to detect mis-speculations <ref type="bibr" target="#b13">[13]</ref>. Roth proposed enhancements to Cain and Lipasti's scheme, to reduce the number of loads that have to perform commit time checking <ref type="bibr" target="#b20">[20]</ref>. These mechanisms eliminate the CAM from the LQ but require additional bits in the load queue RAM (64bits) to hold the load values. Roth's mechanism requires additional storage of 1KB (SSBF) for supporting commit-time filtering.</p><p>Sha, Martin and Roth extend Roth's scheme by using a modified dependence predictor to match loads with the precise store buffer slots from which they are likely to receive forwarded data <ref type="bibr" target="#b27">[27]</ref>. This solution, coupled with the non-associative load queue scheme proposed in Roth's earlier work, can completely eliminate all the associative structures from the LSQ. However, instead of the associative CAMs, this solution requires large multi-ported dependence/delay predictors (approximately 23.5KB, as reported in <ref type="bibr" target="#b4">[4]</ref>), effectively improving dynamic power at the expense of area.</p><p>Garg, Rashid and Huang propose another mechanism for eliminating associative LQ/SQs <ref type="bibr" target="#b6">[6]</ref>. In the first phase of two-phase processing, loads and stores speculatively obtain their value from a L0 cache. In the second phase, the memory instructions are Subramaniam and Loh <ref type="bibr" target="#b4">[4]</ref> and Sha, Martin, and Roth <ref type="bibr" target="#b28">[28]</ref> both propose methods for completely eliminating the store queue, by bypassing store values through the register file and LQ, respectively. Sha, Martin and Roth avoid speculative store buffering by executing stores in program order, while Subramaniam and Loh do so by using the ROB or the physical register file. Both proposals use sophisticated dependence predictors that are smaller than their earlier schemes but still require additional area for dependence predictors and combinational logic for renaming.</p><p>Akkary, Rajwar, and Srinivasan propose two-level store buffers, each of which are centralized, fully associative and age ordered <ref type="bibr" target="#b5">[5]</ref>. Stores first enter the L1 store buffer, and when it overflows they are moved to the L2 store buffer. Both buffers support forwarding and speculation checking, but stores always commit from the second level buffer. This scheme reduces power and delay, but still requires a worst-case sized L2 store buffer and is thus area inefficient.</p><p>Stone, Woley, and Frank suggest partitioning the LSQ into its three functions, and distributing and address interleaving all of them <ref type="bibr" target="#b3">[3]</ref>. The three structures are a set associative cache for forwarding (80-bit wide, 512 sets, 2-way), a non associative FIFO for commit, and an address-indexed timestamp table (8K entry, 8bit wide) for checking speculation. The partitioning removes the CAMs but has high area overheads.</p><p>Torres et al. propose using a distributed, address-partitioned, forwarding buffer backed up by a centralized, fully associative ageindexed LSQ <ref type="bibr" target="#b1">[1]</ref>. Baugh and Zilles use a small centralized forwarding buffer, but address-partitioned unordered structures for violation detection <ref type="bibr" target="#b10">[10]</ref>. Both these schemes increase the area required for memory disambiguation to optimize for latency and power.</p><p>Table <ref type="table" target="#tab_0">1</ref> summarizes the ROB size, the area of the LSQ before and after the optimizations, the size of the supporting structures required by these optimizations (but which may be already be present in the design for performance reasons), and finally the ratio of total area required for memory disambiguation, before and after the optimizations. We computed the area of the memory structures, in bytes of storage, assuming the CAM cell area to be three times larger than the RAM cell. We also assumed 40-bit addresses and 64-bit data, and that all the unoptimized designs had 12-bit partial addresses in CAMs and rest of the address bits in the RAMs. The depth of the queues, however, is different for each of these structures. The table shows that the proposed schemes add area overhead between factors of 1.5 to 16.5. When discounting the dependence predictor, the area overheads are between factors of 1.5 and 13.</p><p>In contrast to all of the above schemes, the design proposed in this paper uses late binding to reduce the area and latency without any additional state outside of the LSQ. Dynamic power reduction, however, requires additional state in the form of address-based Bloom filters <ref type="bibr" target="#b22">[22]</ref>. These structures take up only few hundreds of bytes and can even be further reduced by optimizations suggested by Castro et al. <ref type="bibr" target="#b2">[2]</ref>.</p><p>Other researchers have also applied issue-time binding, explicitly or implicitly, to improve the efficiency of microarchitectural structures. Monreal et al. use late allocation to reduce the number of physical registers <ref type="bibr" target="#b19">[19]</ref>. The effectiveness of some LSQ optimizations like address-based filters <ref type="bibr" target="#b22">[22]</ref> or the small associative forwarding buffers <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b1">1]</ref> can also be explained in part by late allocation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">BACKGROUND</head><p>Most LSQs designed to date have been age indexed, because age indexing supports the physical sorting of instructions in the LSQ based on their age. LSQs must support three functions: commit of stores, detection of memory ordering violations, and forwarding of earlier store values to later loads. The physical ordering makes some of these operations simpler to support, but is not fundamentally required for committing of stores and violation detection, and only provides speed benefits for store forwarding in rare cases.</p><p>In an age-indexed LSQ, the address and value of an in-flight memory instruction is stored in an LSQ slot obtained by decoding the age of the memory instruction. This organization results in a LSQ that is physically ordered; the relative ages of two instructions can be determined by examining the physical locations they occupy in the LSQ. For example, it is simple to determine that instruction at slot 5 is older than instruction at slot 8 because slot 5 is physically "before" slot 8. Additionally, this mechanism allows determining the relative order between all instructions in the LSQ that satisfy some criterion (i.e. a matching address). For example, if slots 25, 28 and 29 are occupied in the LSQ, linearly scanning the the LSQ from position 29 will reveal the most recent older instruction first <ref type="bibr" target="#b28">(28)</ref> and then then next oldest <ref type="bibr" target="#b25">(25)</ref> and so on. In some cases, circuit implementations exploit the physical ordering to accelerate LSQ operations. To understand the design changes that an unordered LSQ requires, it is instructive to examine how LSQ ordering supports the three functions that the LSQ combines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Commit:</head><p>The LSQ buffers all stores to avoid potential writeafter-write hazards between stores to the same address that execute out-of-order. Additionally, the stores cannot be written out until they are non-speculative. Once a store is determined to be nonspeculative, the store address and value are written to the cache using the age supplied from the ROB/control logic. With ordering, age-based indexed lookup is sufficient. Without ordering, a search is necessary to find the oldest store to commit. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2: Summary of LSQ operations and ordering requirements</head><p>Violation Detection: The LSQ must report a violation when it detects that a load following a store in program order, and to same address, executed before the store. To support this operation, the LSQ buffers all in-flight memory data addresses, and when a store arrives at the LSQ, checks for any issued loads younger than and to the same address as the store. If there are any matching loads, a violation is reported. For this operation, the LSQ need only determine the set of younger load instructions. It does not require sorting among the multiple matching loads based on their age. In ordered LSQ circuit implementation, the age of the incoming instruction is decoded into a bit mask and all bits "before" the decoded bit vector are set. In the case of store forwarding with multiple matches, the most recent store and successive older stores can be accomplished by linearly scanning the bit mask.</p><p>Store Forwarding: The LSQ must support forwarding from the uncommitted buffered stores in the LSQ to in-flight loads that issue after the stores. When a load arrives at the LSQ, it checks for older stores to the same address. If there are matching stores, the LSQ ensures that the load obtains its value from the most recent matching store preceding the load. To support this functionality when a load matches multiple stores, the LSQ sorts the matching stores based on their ages and processes the matching stores until all the load bytes have been obtained or until there are no matching stores.</p><p>The age-indexing policy requires an LSQ that is sized large enough to hold all in flight memory instructions (? slots), which results in a physically ordered LSQ. The ability to sort through multiple matching instructions is especially useful for forwarding values from multiple matching stores to a load, but a coarser age comparison is sufficient for implementing the other LSQ operations (Table <ref type="table">2</ref>). Additionally, the LSQ allocation policy is conservative. Even though the LSQ slots are occupied only after the instructions execute they are allocated early, during instruction dispatch. Traditional age-indexed LSQs are thus both overdesigned in terms of functionality and overprovisioned in terms of size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">AN UNORDERED, LATE-BINDING LSQ DESIGN</head><p>Late-Binding LSQs address the inefficiencies resulting from the "worst-case" design policies used in traditional LSQs. By allocating the memory instruction in the LSQ at issue, the sizes of ULB- LSQs are comparartively reduced. Allocating memory instructions at issue requires a set of mechanisms different from allocation in age-indexed LSQs. When a load or store instruction arrives at the ULB-LSQ the hardware simply allocates an entry from a pool of free LSQ slots instead of indexing by age. This allocation policy results in an LSQ that is physically unordered in which the age of the instruction has no relation to the slot occupied by the instruction.</p><p>To compensate for the lack of ordering, the ULB-LSQs take a more direct approach to determining the age by explicitly storing the age information in a separate age CAM. The age CAM is a special type of CAM that can output greater/lesser/equal results instead of just the equality matches. The LSQ functions that used the implicit age information in the age-indexed LSQ for implementing the LSQ operations now use the explicit associative age CAM to determine younger and older instructions. Figures <ref type="figure" target="#fig_2">3</ref> and<ref type="figure" target="#fig_3">4</ref> illustrates and contrasts the structures used in the ULB-LSQ and traditional LSQ implementations, where ? is the memory instruction dow size, and ? is the ULB-LSQ size.</p><p>To support commits, the small age CAM is associatively searched with the age supplied by the ROB. The address and data from the exact matching entry are read out from the CAM and RAM respectively, and sent to the caches. This extra associative search is avoidable if the baseline architecture holds the ULB-LSQ slot id allocated to the store in the ROB.</p><p>To support violation detection, when a store arrives it searches the address CAM to identify matching loads, and searches the age CAM using the greater-than operator to identify younger loads. The LSQ then performs a logical OR of the results of the two searches. If any of the resulting bits is one then a violation is flagged. Detecting violations is simpler in this LSQ compared to age-indexed LSQs, since no generation of age masks is necessary.</p><p>Supporting forwarding is more involved because the ULB-LSQ does not have the total order readily available. In the case of only one match, the loss of order does not pose a problem; however when there are multiple matches, the matches must logically be processed from most recent to the oldest. In the ULB-LSQ, on multiple store matches, the age of each match is read out from the ULB-LSQ, one per cycle, and decoded into a per-byte bit vector. Bytes to forward to the load replace bytes from other stores if the later-found store is more recent in program order. This step reconstructs the physical ordering between the matches from the ULB-LSQ, but may take multiple cycles to do so. Once the ordering is available, store forwarding proceeds exactly as in an age-indexed LSQ <ref type="bibr" target="#b23">[23]</ref>. Thus, compared to the age-indexed LSQ, which may already require multiple cycles to forward from multiple stores, the ULB-LSQ requires additional cycles for creating the decoded bitvector. However, as we will show in the next section, these additional cycles rarely affect performance because multiple store forwarding is uncommon in many benchmarks.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Performance Results</head><p>The performance of the ULB-LSQ depends on the number of entries in the LSQ, which affects the number of LSQ overflows. Performance will also be affected by the relative cost of each overflow and the additional penalty for multi-cycle store forwarding (in the case of multiple address matches). We modeled the ULB-LSQ in the sim-alpha <ref type="bibr" target="#b15">[15]</ref> simulator and simulated single Simpoint regions of 100M for the 18 SPEC benchmarks compatible with our experimental infrastructure.</p><p>In this set of experiments, ULB-LSQ overflows are handled by partially flushing the pipeline and re-starting execution from the oldest unarrived memory instruction at the time of the overflow. The penalty of an overflow is 15 cycles, which matches the cost of a branch misprediction. Table <ref type="table" target="#tab_3">3</ref> summarizes the unordered LSQ behavior and statistics. The first two columns show the number of memory instructions between the commit and execute stages for 95% and 99% of the execution cycles. The next eight columns show the number of overflows per 1000 memory instructions, and the performance normalized against the Alpha, for ULB-LSQ sizes ranging from 16 to 40 entries. The final column shows the percentage of dynamic loads that forward from more than one store. From the table, for 14 of the 18 benchmarks, for 99% of the cycle time, there are 32 or fewer uncommitted but executed memory instructions. This explains why a 32 entry ULB-LSQ does not show any performance degradation.</p><p>To isolate the performance impact of slower multiple forwarding, we increased the latency of store forwarding in the baseline simulator without changing the LQ/SQ size. In this experiment, if a load matches with N (N 1) older stores, then store forwarding takes an additional N cycles even if load does not have to get their data from all N stores. The results showed no performance degradation for any of the benchmarks because loads rarely need to get data from multiple stores. From Table <ref type="table" target="#tab_3">3</ref>, the number of loads that have to forward from two or more stores is less than 0.2% on the average.</p><p>Another interesting trend in the Table <ref type="table" target="#tab_3">3</ref> is that the performance impact of the number of overflows is different for High vs. Low IPC benchmarks. For instance, for the 16 entry LSQ, even though 179.art incurs more flushes per 1K instructions than 178.galgel (651 vs. 463), the performance degradation is higher in the case of 178.galgel (24% vs. 96%). This data indicates that unless lowoverhead overflow mechanisms are invented for machines that support high ILP, the performance impact of undersizing the LSQ can be quite high.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Power</head><p>This section examines the dynamic power consumption of an ULB-LSQ against the Alpha LQ/SQ organization. The ULB-LSQ design holds 32 memory operations, while the Alpha has a separate 32-entry LQ and SQ. Although the size of the ULB-LSQ is smaller, each memory operation has to access the same number of address CAM entries in both designs because the Alpha has a partitioned LQ/SQ. Even so, the ULB-LSQ will have higher dynamic power per access because of the additional accesses to the age CAM.</p><p>To measure the increase in power per access, we assumed that the LSQ power is approximately equal to the power consumed by the CAM and the RAM. Thus, the power-per-access of the Alpha LQ or SQ will be purely from the address CAM (? ? ) and the RAM (?? ?), while the power consumed by the ULB-LSQ will be the power from the address CAM, the age CAM (? ) and the RAM. Since the ULB-LSQ and Alpha have the same number of entries, their sizes will be the same. Thus the power increase will be ??</p><formula xml:id="formula_0">? ? ? ? ?? ?? ?? ? ? ?? ??.</formula><p>We synthesized the design using IBMs 130nm ASIC methodology with the frequency set at 450MHz, and verified that the age CAM will fit in the same cycle time as the address CAM. Even though the delay of the age CAM was approximately 20% more than the address CAM, the delay was still not long enough to be on the critical path. Thus, assuming that the LB-CAMs can be run at the same clock frequency as the traditional LQ/SQ, the power increase is simply the ratio of the capacitances. From our synthesis, the capacitance of the address CAM (32x40b, 1 search, 1 read and 1 write port) was 144.5pF (? ? ) while the capacitance of the age CAM was 12.86pF (? ). Thus the power overhead is roughly 8% even after neglecting the power due to the RAM.</p><p>However, both the ULB-LSQ and the Alpha LSQ can benefit from Bloom filters. With a 64 entry, 8-bit counting Bloom Filter <ref type="bibr" target="#b16">[16]</ref>, we observed that 88.7% of the age and address searches can be filtered. Applying this optimization, the additional power required by the unordered design can be reduced to under 1% of the power consumed by the original Alpha LSQ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Implementation Complexity</head><p>The ULB-LSQ design differs from a traditional LSQ in the following ways: (1) the entries are managed as a free-list, (2) multiple store forwarding requires additional control logic to scan through matching entries, and (3) the LSQ must detect and react to overflows. These differences are not a significant source of complexity because many existing microarchitectural structures implement similar functionality. For example, MSHRs and the physical register files are managed as free-lists. The scanning logic has been implemented in traditional LSQs which do not flush on multiple matches. Overflow is flagged when there are no free LSQ entries, and is simple to implement. Furthermore, the ULB-LSQ does not require any modifications to the load/store pipeline. The LSQ operations are pipelined in the exact same way as the age-ordered LSQ implementation in the POWER4 <ref type="bibr" target="#b26">[26]</ref>.</p><p>These results showed that for small-window processors like the Alpha 21264, even with simplistic overflow handling mechanisms, the queue sizes can be reduced by half without affecting performance. The smaller queue size directly translates to improvements in static power, dynamic power, and latency. Most important, the unordered nature of the ULB-LSQ allows it to be partitioned without introducing additional area overheads as explained next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">LARGE-WINDOW PROCESSORS</head><p>While high-performance uniprocessor design has fallen out of favor with industry due to scaling difficulties, many researchers are examining novel and scalable means for extracting more ILP by using a larger instruction window. Such designs often employ some form of partitioning to implement larger microarchitectural logical structures without sacrificing clock cycle time. In particular, the architectural trends motivating the design of a partitioned LSQs include (1) very large instruction windows with hundreds of in-flight memory instructions, and (2) partitioning of microarchitectures for scaling to higher execution and local memory bandwidth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Partitioning the LSQ</head><p>In a partitioned microarchitecture, an LSQ partition is best matched with a partition of an address-interleaved level-1 cache. Partitioning an age-ordered LSQ is not straightforward as the perinstruction age identifiers do not indicate dependence relationships between load and store instructions. Distributing age-interleaved partitions to address-interleaved caches will effectively result in significant cross-partition communication among LSQ and cache banks and between matching loads and stores to the same address. Address-interleaved LSQs are a better match for address interleaved partitioned memory systems. However, address interleaving also means that there is no guarantee that the loads and stores will be distributed evenly across the partitions. Such an LSQ must function correctly even when all in-flight memory instructions map to the same partition. Such imbalance is uncommon, but may arise when the application is loading from or storing to a sequential array of characters. A system could tolerate the imbalance by sizing each partition for the worst case, but the total LSQ size would be N times the instruction window size, for N partitions. In the remainder of this paper, we explore better solutions that instead undersizes the LSQ partitions in the same manner as Section 4 and gracefully tolerates the rare overflow conditions with minimum effect on performance.</p><p>Related Work: Research proposals for clustered architectures <ref type="bibr" target="#b30">[30,</ref><ref type="bibr">9]</ref> employ multiple partitions of an age-indexed LSQ, but instead of reserving a slot in each of the LSQ partitions, they use memory bank predictors <ref type="bibr" target="#b25">[25]</ref> to predict a target bank and reserve a slot there. If the bank prediction is low-confidence, slots are reserved in all banks. While this approach is better than conservatively reserving a slot in each partition, it still wastes space because of conservative dispatch allocation. The first memory disambiguation hardware to be address indexed was MultiScalar's Address Resolution Buffer (ARB) <ref type="bibr" target="#b17">[17]</ref>. Loads and stores would index into this structure, where age tags were stored to assist in forwarding values and detecting ordering violations. The ARB caused a high overhead pipeline flush if it overflowed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Large-window Processor Model</head><p>To examine the viability of the partitioned ULB-LSQ in a largewindow processor, we use the TRIPS processor microarchitecture as a baseline. The TRIPS processor is a partitioned microarchitecture that enables a window of up to 1024 instructions and up to 256 in flight memory instructions. All major components of the processor are partitioned and distributed including fetch, issue, and memory access. The overflow handling mechanisms described in the rest of this paper are built on top of the TRIPS microarchitecture.</p><p>The processor is composed of an array of 16 execution units connected via a routed operand network. Instructions are striped across 4 instruction cache banks which are accessed in parallel to fetch TRIPS instruction blocks. Instructions are delivered to the execution units where each instruction waits until its operands arrive. The primary memory system (level-1 data cache, LSQs, dependence predictors and miss handling units) is divided into multiple banks which are also attached to the routed operand network. Cache lines are interleaved across the banks, which enables up to 4 memory instructions per cycle to enter the level-1 cache pipelines. Figure <ref type="figure" target="#fig_4">5</ref>.2 shows an abstract view of the TRIPS microarchitecture, highlighting the parts that are relevant to memory instructions. Additional details about the TRIPS microarchitecture can be found in <ref type="bibr" target="#b21">[21]</ref>.</p><p>The features of a distributed microarchitecture most relevant to the design of LSQs can be distilled down to a few principles which are not unique to TRIPS. First is an address-interleaved distributed cache in which multiple level-1 cache banks independently preserve the proper ordering of load and store instructions to the same address. Second is the set of distributed execution units which independently decides which instructions to issue each cycle. Finally, a distributed architecture with multiple execution and memory units must include some form of interconnection network. TRIPS employs a mesh-routed operand network which can be augmented to provide multiple virtual channels. Some of the techniques for mitigating overflows rely on buffering in-flight memory instructions within the network buffers. However, other interconnection networks can could be enabled to buffer in-flight memory instructions as well. While we examine partitioned LSQ design in a TRIPS context, we believe that these concepts apply to other architectures that share these basic characteristics.</p><p>Jaleel et al. point out that blindly scaling the larger window LSQs can be detrimental to performance due to the increase in the number of replay traps <ref type="bibr" target="#b18">[18]</ref>. In their study on a scaled Alpha-21264 core, such traps can occur when load instructions violate the consistency model, when load needs to partially obtain the data from the LSQ and the cache, when a load miss cannot be serviced because of structural hazards and when a load instruction executes prematurely. TRIPS avoids these traps and does not suffer from the performance losses described in <ref type="bibr" target="#b18">[18]</ref>. In particular, TRIPS avoids load-load traps with weak memory ordering, wrong-size traps by supporting partial forwarding in LSQ, and load-miss traps by using larger MSHRs <ref type="bibr" target="#b23">[23]</ref>. Like the Alpha, TRIPS also uses a dependence predictor to reduce the number of load-store replay traps which occur when a load instruction is executed prematurely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">MITIGATING LSQ OVERFLOWS</head><p>Ideally, a distributed LSQ should be divided into equal-sized banks, where the aggregate LSQ entries equals the average number of loads and stores in flight, but which shows only minor performance losses over a maximally sized LSQ. When a bank overflows, however, if the microarchitecture does not flush the pipeline, it must find someplace to buffer the load. We examine three places to buffer these instructions: in the execution units, in extensions to the memory units, or in the network connecting the execution units to the memory units. The buffering space is much less expensive than the LSQ space since the buffered locations need not be searched for memory conflicts, which mitigates the area and energy overheads of large LSQs. The penalty associated with these schemes correspond to different "load loops" and changes as the time for load execution changes <ref type="bibr" target="#b11">[11]</ref>.</p><p>These buffering approaches effectively stall processing of certain memory instructions, which could potentially lead to deadlock. However, memory instructions can be formed into groups based on age, with all of the instructions in a group having similar ages. In a microarchitecture that is block-oriented like TRIPS, the memory instruction groups correspond to the instruction blocks. One block is non-speculative, while multiple blocks can be speculative. By choosing to prioritize the non-speculative instructions over the speculative instructions, our solutions can reduce the circumstances for deadlocks and flushing. One possible design would reserve LSQ entries for the non-speculative block, but our experiments indicated that this approach did not provide any substantive performance benefits and resulted in larger than a minimum sized LSQ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Issue Queue Buffering: Memory Instruction Retry</head><p>One common alternative to flushing the pipeline in conventional processors is to replay individual offending instructions, either by retracting the instruction back into the issue window, or by logging the instruction in a retry buffer. In TRIPS retrying means sending an offending instruction back to the ALU where it was issued and storing it back into its designated reservation station. Since the reservation station still holds the instruction and its operands, only a short negative-acknowledgement (NACK) message needs to be sent back to the execution unit. No additional storage in the system is required, as the reservation station cannot be reassigned to another instruction until the prior instruction commits. The issue logic may retry this instruction later according to a number of possible policies.</p><p>Figure <ref type="figure" target="#fig_5">6a</ref> shows the basics of this technique applied to LSQ overflows. When a speculative instruction arrives at a full LSQ, the memory unit sends the NACK back to that instructions execution unit. This policy ensures that speculative instructions will not prevent a non-speculative instruction from reaching the LSQ. If a non-speculative instruction arrives at a full LSQ, then the pipeline must be flushed.</p><p>A range of policies are possible for determining when to reissue a NACKed memory instruction. If the instruction reissues too soon (i.e. immediately upon NACK), it can degrade performance by clogging the network, possibly requiring multiple NACKs for the same instruction. Increased network from NACKs can also delay older non-speculative instructions from reaching the LSQ partition, as well as general execution and instructions headed to other LSQ partitions. Alternatively, the reservation stations can hold NACKed instructions until a fixed amount of time has elapsed. Waiting requires a counter per NACKed instruction, and may be either too long (incurring unnecessary latency) or too short (increasing network contention).</p><p>Instead, our approach triggers re-issue when the non-speculative block commits, which has the desirable property that LSQ entries in the overflowed partition are likely to have been freed. This mechanism has two minor overheads, however: an additional state bit for every reservation station, to indicate that the instruction is ready but waiting for a block to commit before reissuing; and a control path to wake up NACKed instructions when the commit signal for the non-speculative block arrives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Memory Buffering: Skid Buffers</head><p>A second overflow-handling technique is to store memory instructions waiting to access the LSQ in a skid buffer located in the memory unit. As shown in Figure <ref type="figure" target="#fig_5">6b</ref>, the skid buffer is simple priority queue into which memory instructions can be inserted and extracted. To avoid deadlock, our skid buffers only hold speculative memory instructions. If an arriving speculative memory instruction finds the LSQ full, it is inserted into the skid buffer. If the skid buffer is also full, the block is flushed. Arriving non-speculative instructions are not placed in the skid buffer. If they find the LSQ full, they trigger a flush.</p><p>When the non-speculative block commits and the next oldest block becomes non-speculative, all of its instructions that are located in the skid buffer must be extracted first and placed into the LSQ. If the LSQ fills up during this process, the pipeline must be flushed. Like retry, the key to this approach is to prioritize the nonspeculative instructions and ensure that the speculative instructions do not impede progress. Skid buffers can reduce the ALU and network contention associated with NACK and instruction replay, but may result in more flushes if the skid buffer is small. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Network Buffering: Virtual Channel-Based Flow Control</head><p>A third approach to handle overflows is to use the buffers in the network that transmits memory instructions from the execution to the memory units as temporary storage for memory instructions when the LSQ is full. In this scheme, the operand network is augmented to have two virtual channels (VCs): one for non-speculative traffic and one for speculative traffic. When a speculative instruction is issued at an ALU, its operands and memory requests are transmitted on the lower priority channel. When a speculative memory instruction reaches a full LSQ and cannot enter, it remains in the network and asserts backpressure along the speculative virtual channel. Non-speculative instructions use the higher priority virtual channel for both operands and memory requests. A nonspeculative memory instruction that finds the LSQ full triggers a flush to avoid deadlock. Figure <ref type="figure" target="#fig_5">6c</ref> shows a diagram of this approach.</p><p>This virtual channel approach has a number of benefits. First, no new structures are required so logic overhead is only minimally increased. Additional router buffers are required to implement the second virtual channel, but our experiments show that two-deep flit buffers for each virtual channel is sufficient. Second, no additional ALU or network contention is induced by NACKs or instruction replays. Third, the higher priority virtual channel allows non-speculative network traffic to bypass speculative traffic. Thus non-speculative memory instructions are likely to arrive at the LSQ before speculative memory instructions, which reduces the likelihood of flushing.</p><p>Despite its conceptual elegance, this solution requires a number changes to the baseline network and execution engine. The baseline TRIPS implementation includes a number of pertinent features. It provides a single operand network channel that uses on-off flow control to exert back-pressure. Each router contains a four-entry FIFO to implement wormhole routing and the microarchitecture can flush any in-flight instructions located in any tile or network router when the block they belong to is flushed. Finally, all of the core tiles (execution, register file, data cache) of the TRIPS processor connect to the operand network and will stall issue if they have a message to inject and the outgoing network FIFO is full.</p><p>Adjusting this network to support VCs requires several augmentations: (1) an additional virtual channel in the operand network to separate speculative from non-speculative network traffic, including the standard buffer capacity and control logic needed by virtual channels, (2) virtualization of the pipeline registers, which must stretch into the execution and register tiles to allow non-speculative instructions to proceed even if speculative instructions are stalling up the virtual network, (3) issue logic in these tiles that selects non-speculative instructions over speculative logic when the virtual network is congested, and (4) a means to promote speculative instructions from the speculative virtual channel to the non-speculative channel when its block becomes non-speculative.</p><p>The trickiest part of this design is the promotion of speculative network packets to the non-speculative virtual channel when the previous non-speculative block commits. The TRIPS microarchitecture already has a commit signal which is distributed in a pipelined fashion to all of the execution units, memory units, and routers. When the commit signal indicates that the non-speculative block has committed, each router must nullify any remaining packets in the non-speculative virtual channel and copy any packets belonging to the new non-speculative block from the speculative VC to the non-speculative VC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Flow Control Mechanisms Performance</head><p>We implemented these flow control mechanisms on a simulator that closely models the TRIPS prototype processor <ref type="bibr" target="#b21">[21]</ref> which has been validated to be within 11% of the RTL for the TRIPS prototype processor. The microarchitectural parameters most relevant to the experiments are summarized in Table <ref type="table">4</ref>.</p><p>For each benchmark, we normalize the performance (measured in cycle counts) to a configuration with maximally sized, 256-entry LSQ partitions that never overflow. For these experiments, we used skid buffer sizes that are sized slightly larger than the expected number of instructions at each partition, (72 -LSQ partition size). For the virtual channel scheme, we divided the four operand network buffers in the baseline equally between the two channels. Thus two buffers are provided for the speculative and non-speculative virtual channels for the VC scheme. We present results for 28 EEMBC benchmarks (all except cjpeg and djpeg) and 12 SPEC CPU 2000 (ammp, applu, art, bzip2, crafty, equake, gap, gzip, mesa, mgrid, swim and wupwise) benchmarks with minnespec medium sized reduced inputs. The other benchmarks are not currently supported in our infrastructure.</p><p>For four 48-entry LSQs and thus a total LSQ size of 192 entries (25% undersized), the flush scheme results in average performance loss of 6% for EEMBC benchmarks (Figure <ref type="figure">7</ref>) and 11% for SPEC benchmarks (Figure <ref type="figure" target="#fig_7">8</ref>). The worst-case slowdowns are much higher: 180% for idct and 206% for mgrid. These results support the perspective that traditional flow-control mechanisms are inadequate for distributed load-store queues. The VC mechanism is the most robust with 2% average performance degradation and less than 20% performance degradation in the worst case. As expected, the Skid buffer scheme performs better than the NACK scheme because it avoids network network congestion from the NACKed packets, at the cost of extra area.</p><p>For six of the SPEC and EEMBC benchmarks, the memory accesses are unevenly distributed and cause LSQ overflows that re- duce performance significantly. For instance, Figure <ref type="figure" target="#fig_6">9</ref> shows a frequently executed code sequence in idct in the EEMBC suite. The innermost loop contains two reads and two writes to two different arrays and the code generated by the compiler aligns both arrays to 256-byte boundaries. Since the arrays are accessed by same indices, all four accesses map to the same bank. This problem is exacerbated by the aggressive loop unrolling of the TRIPS compiler. The accesses could in theory be distributed by aligning the arrays differently, but aligning data structures to minimize bank conflicts is a difficult compiler problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Power Efficiency</head><p>Three mechanisms are necessary to achieve high power efficiency in large-window processor LSQs: address partitioning, latebinding and associative search filtering. First, partitioning the LSQ by addresses naturally divides the number of entries arriving at each memory partition. Second, late-binding reduces the number of entries in each partition by reducing occupancy. Finally, Bloom fil-tering reduces the number of memory instructions performing associative searches <ref type="bibr" target="#b22">[22]</ref>.</p><p>The Bloom filters for the TRIPS study use 8 32-bit registers, one for each in-flight block. The filters associated with each block are cleared when the block commits or is flushed (commonly called flash clearing). This clearing scheme does not require the counters often needed for Bloom filters and thus reduces the area of the filter significantly. As shown in Table <ref type="table" target="#tab_4">5</ref>, nearly 70-80% of the memory instructions (both loads and stores) can be prevented from performing associative searches in the TRIPS processor by using Bloom filtering. Using Bloom filters, however, incurs additional some additional power for reading and updating the filters for every memory instruction. Using the 130nm ASIC synthesis methodology described in the Alpha evaluation section, the capacitance of the 48-entry TRIPS LSQ was computed to be 322pF. The capacitance of the Bloom filter was 64pF. With the activity reduction of 80% the effective capacitance of the combination is 120pF which roughly is the capacitance of a 12-entry, 40-bit unfiltered CAM.</p><p>In this evaluation, we have not included the additional power expended by the network routers as it is unclear if they will be signficant. Wang et al. <ref type="bibr" target="#b29">[29]</ref> show a 20% increase in power for a four fold increase for implementing virtual channels. The power increase primarily comes from having four times as many buffers for implementing the Virtual channels. In our scheme we do not increase the number of buffers. We simply divide the number of buffers equally between the virtual channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Area</head><p>Among the three overflow handling mechanisms, the NACK mechanism is the most area efficient if the issue window is designed to hold instructions until explicit deallocation. On the TRIPS processor, the NACK scheme requires cumulative storage of 1024 bits to identify the NACK'ed instructions (one bit for every instruction in the instruction window) and changes to the issue logic to select and re-issue the NACK'ed instructions. The VC mechanism is next best in terms of area efficiency. The area overheads of the VCs are due to the additional storage required for pipeline priority registers in the execution units to avoid deadlocks and the combinational logic in routers to deal with promotion. The VC scheme does not require any additional router buffers since the speculative channels divide the number of buffers in the baseline. The skid buffer scheme require the largest amount of storage, although most of the structure can be implemented as RAMs. A 24-entry skid buffer supplementing a 40-entry LSQ, increases the size of each LSQ partition by 4%. Overall, using our best scheme to supportthe VC mechanism -a 1024 instruction window, as shown in Table 1, the area after optimizations is 80% smaller compared to the fully replicated LSQs at each LSQ partition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7">Complexity</head><p>The VC scheme requires the most changes to the baseline as it requires virtualization of not only the network routers but also the execution units that feed the router. For instance, when the low priority channel in the network is backed up, the issue logic must supply the network with a high priority instruction even though it may be in the middle of processing a low priority instruction. The NACK scheme comes second or third depending on the baseline architecture -if the baseline allows instructions to be held in the issue queues until commit, implementing NACK is as simple as setting a bit in a return packet and routing it back to the source instead of the destination. However, if instructions are immediately deallocated upon execution from the windows, NACK may be considerable more complex. The skid buffer solution is probably the simplest of all the solutions: it requires some form of priority logic for selecting the oldest instructions, mechanisms for handling invalidations in the skid buffer and arbitration for the LSQ between instructions in the skid buffer and new instructions coming into the LSQ partition. Despite the changes required for the schemes described here, the mechanisms are feasible and operations required have been implemented in other parts of the processor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>Detecting load/store data dependences has been challenging ever since designers began to implement computer systems that execute more than one instruction per cycle. As processor designers have scaled ILP and instruction window size, hardware to enforce proper memory ordering has become large and power hungry. However, today's load/store queue (LSQ) designs make inefficient use of their storage by allocating LSQ entries earlier than necessary.</p><p>By performing late binding, allocating LSQ entries only at instruction issue, designers can reduce the occupancy and resultant size of the load/store queues. This reduction requires that the queues be unordered. While the unordered property requires some extra overhead, such as saving the CAM index in the ROB or searching for the load or store age at commit, the design is not intrinsically more complex, and can achieve performance equivalent to an ordered LSQ, but with less area and power.</p><p>Many of the recent papers that propose to eliminate the CAMs do so at the expense of increased state, resulting in increased area requirements. These designs certainly have some advantages, and one or more of them may well be the solution that some implementations eventually use. However, we have shown in this paper that unordered, late-binding LSQs can be quite competitive for superscalar designs, requiring only a small number of CAM entries to be searched on average, while consuming less area than the CAMfree approaches. It is unclear which approach suffers from worse complexity, and will likely remain so until each approach is implemented in a microarchitecture.</p><p>However, the most promising aspect of the ULB-LSQ approach is its partitionability, which was the original impetus for this line of research. Address-interleaved LSQ banks should be both latebound and unordered; the ULB-LSQ design naturally permits the LSQ to be divided into banks, provided that a mechanism exists to handle the resultant increase in bank overflows. We observed that, for distributed microarchitectures that use routed micronetworks to communicate control, instructions, and data, that we could embed classic network flow-control solutions into the processor micronetworks to handle these overflows. We evaluate three such overflow control handling schemes in the context of the TRIPS microarchitecture. The best of these schemes (virtual micronet channels) enables a scalable, distributed, load/store queue, requiring four banks of only 48 entries each to support a 1024-instruction window.</p><p>When conjoined with a Bloom filter, this design greatly reduces the number of CAM accesses, resulting in an average of only eight and twelve CAM accesses per load or store, respectively.</p><p>Looking forward, this design supports a microarchitecture under design that can run a single thread across a dynamically specified collection of individual, light-weight processing cores. When combined, the LSQ banks in the individual cores become part of a single logical interleaved memory system, permitting the system to choose between ILP and TLP dynamically using a collection of composable, light-weight cores on a CMP.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: High-Level Depiction of Ordered vs. Unordered LSQs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Potential for undersizing: In an Alpha 21264, for 99% of the execution cycles across 18 SPEC2000 benchmarks, only 32 or fewer memory instructions are in flight between execute and commit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The Age-Indexed LSQ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The ULB-LSQ Microarchitecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Overview of the distributed memory system in TRIPS: Each of the memory partitions includes a portion of the address-interleaved level-1 cache, a portion of the unordered LSQ, a local dependence predictor, a miss-handling unit, and a copy of the TLB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: LSQ Flow Control Mechanisms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Code snippet from idct benchmark.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Left: Average LSQ Performance for the SPEC benchmark suite. Right: Three worst benchmarks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Area for LSQ and supporting structures for recent related work</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">Unoptimized</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Optimized</cell><cell></cell><cell></cell><cell></cell><cell>Unoptimized</cell></row><row><cell>Scheme</cell><cell>ROB Size</cell><cell cols="2">Depth</cell><cell cols="2">Storage</cell><cell cols="2">Depth</cell><cell cols="2">CAM</cell><cell cols="2">RAM</cell><cell cols="2">Storage</cell><cell>Supporting</cell><cell>:optimized</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">(KB)</cell><cell></cell><cell></cell><cell cols="2">Width</cell><cell cols="2">Width</cell><cell cols="2">(KB)</cell><cell>Structures</cell><cell>Ratio</cell></row><row><cell></cell><cell></cell><cell>LQ</cell><cell>SQ</cell><cell>LQ</cell><cell>SQ</cell><cell>LQ</cell><cell>SQ</cell><cell>LQ</cell><cell>SQ</cell><cell>LQ</cell><cell>SQ</cell><cell>LQ</cell><cell>SQ</cell><cell>(KB)</cell><cell></cell></row><row><cell>SVW -NLQ</cell><cell>512</cell><cell>128</cell><cell>64</cell><cell>1.00</cell><cell>1</cell><cell>128</cell><cell>64</cell><cell>0</cell><cell>12</cell><cell>92</cell><cell>64</cell><cell>1.44</cell><cell>0.78</cell><cell>1</cell><cell>1.61</cell></row><row><cell>SQIP</cell><cell>512</cell><cell>128</cell><cell>64</cell><cell>1.00</cell><cell>1</cell><cell>128</cell><cell>64</cell><cell>0</cell><cell>0</cell><cell>92</cell><cell>64</cell><cell>1.44</cell><cell>0.5</cell><cell>23.5</cell><cell>12.72</cell></row><row><cell>Garg et al.</cell><cell>512</cell><cell>64</cell><cell>48</cell><cell>0.50</cell><cell>0.75</cell><cell>64</cell><cell>48</cell><cell>0</cell><cell>0</cell><cell>92</cell><cell>0</cell><cell>0.72</cell><cell>0</cell><cell>16</cell><cell>13.38</cell></row><row><cell>NoSQ</cell><cell>128</cell><cell>40</cell><cell>24</cell><cell>0.31</cell><cell>0.375</cell><cell>40</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>92</cell><cell>0</cell><cell>0.45</cell><cell>0</cell><cell>11</cell><cell>16.65</cell></row><row><cell>FnF</cell><cell>512</cell><cell>128</cell><cell>64</cell><cell>1.00</cell><cell>1</cell><cell>128</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>92</cell><cell>0</cell><cell>1.44</cell><cell>0</cell><cell>23.75</cell><cell>12.59</cell></row><row><cell>Stone et al.</cell><cell>1024</cell><cell>N/A</cell><cell></cell><cell></cell><cell></cell><cell>N/A</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>18</cell><cell>N/A</cell></row><row><cell>LateBinding-Alpha</cell><cell>80</cell><cell>32</cell><cell>32</cell><cell>0.25</cell><cell>0.5</cell><cell>32</cell><cell></cell><cell>12</cell><cell></cell><cell>92</cell><cell></cell><cell>0.5</cell><cell></cell><cell>0.0625</cell><cell>0.75</cell></row><row><cell>LateBinding-TRIPS</cell><cell>1024</cell><cell cols="2">1024</cell><cell>16</cell><cell></cell><cell>192</cell><cell></cell><cell>12</cell><cell></cell><cell>92</cell><cell></cell><cell>3</cell><cell></cell><cell>0.25</cell><cell>0.20</cell></row><row><cell cols="7">re-executed in program order, without any speculation, and ac-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">cess the regular L1 cache. Any difference in the load values be-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">tween the two phases results in corrective action. This mechanism,</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">while eliminating the CAM, requires a 16KB L0 cache and an age-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">ordered queue for holding the values read during the first phase.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 : Performance of an ULB-LSQ on an 80-window ROB machine.</head><label>3</label><figDesc></figDesc><table><row><cell>Benchmark</cell><cell cols="2">Occupancy</cell><cell cols="7">Flushes per 1K mem instr Normalized IPC</cell><cell>Baseline % of LDs</cell></row><row><cell></cell><cell cols="4">%program cycles LSQ entries</cell><cell></cell><cell></cell><cell cols="2">LSQ entries</cell><cell></cell><cell>IPC</cell><cell>matching 0 or 1</cell></row><row><cell></cell><cell cols="2">95% 99%</cell><cell>16</cell><cell>24</cell><cell>32</cell><cell>40</cell><cell>16</cell><cell>24</cell><cell>32</cell><cell>40</cell><cell>STs</cell></row><row><cell>164.gzip</cell><cell>7</cell><cell>22</cell><cell>6</cell><cell>4</cell><cell>3</cell><cell>1</cell><cell cols="4">1.00 1.00 1.00 1.00 1.60</cell><cell>99.95</cell></row><row><cell>175.vpr</cell><cell>14</cell><cell>21</cell><cell>10</cell><cell>2</cell><cell>0</cell><cell>0</cell><cell cols="4">0.93 1.00 1.00 1.00 0.87</cell><cell>99.72</cell></row><row><cell>177.mesa</cell><cell>8</cell><cell>14</cell><cell>8</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">0.05 1.00 1.00 1.00 1.16</cell><cell>99.8</cell></row><row><cell>178.galgel</cell><cell>24</cell><cell>24</cell><cell cols="2">463 88</cell><cell>0</cell><cell>0</cell><cell cols="4">0.04 0.56 1.00 1.00 2.70</cell><cell>100</cell></row><row><cell>179.art</cell><cell>35</cell><cell>43</cell><cell cols="3">651 131 33</cell><cell>11</cell><cell cols="4">0.76 0.91 1.00 1.00 0.63</cell><cell>99.95</cell></row><row><cell>183.equake</cell><cell>3</cell><cell>6</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.00 1.00 1.00 1.00 0.96</cell><cell>99.91</cell></row><row><cell>188.ammp</cell><cell>11</cell><cell>15</cell><cell>4</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.01 1.00 1.00 1.00 1.31</cell><cell>99.91</cell></row><row><cell>189.lucas</cell><cell>11</cell><cell>13</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.02 1.00 1.00 1.00 0.76</cell><cell>100</cell></row><row><cell>197.parser</cell><cell>10</cell><cell>17</cell><cell>4</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.00 1.00 1.00 1.00 1.17</cell><cell>99.84</cell></row><row><cell>252.eon</cell><cell>15</cell><cell>20</cell><cell>28</cell><cell>2</cell><cell>0</cell><cell>0</cell><cell cols="4">0.94 1.00 1.00 1.00 1.17</cell><cell>98.58</cell></row><row><cell cols="2">253.perlbmk 9</cell><cell>13</cell><cell>2</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.00 1.00 1.00 1.00 0.83</cell><cell>98.91</cell></row><row><cell>254.gap</cell><cell>6</cell><cell>12</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.00 1.00 1.00 1.00 1.11</cell><cell>99.92</cell></row><row><cell>256.bzip2</cell><cell>7</cell><cell>9</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.00 1.00 1.00 1.00 1.82</cell><cell>99.9</cell></row><row><cell>173.applu</cell><cell>22</cell><cell>25</cell><cell>2</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell cols="4">0.99 1.00 1.00 1.00 0.62</cell><cell>100</cell></row><row><cell>181.mcf</cell><cell>51</cell><cell>51</cell><cell cols="4">360 251 171 98</cell><cell cols="4">1.01 1.01 1.01 1.01 0.20</cell><cell>99.92</cell></row><row><cell>176.gcc</cell><cell>31</cell><cell>32</cell><cell>28</cell><cell>22</cell><cell>2</cell><cell>1</cell><cell cols="4">0.99 1.00 1.00 1.00 1.21</cell><cell>99.88</cell></row><row><cell>171.swim</cell><cell>15</cell><cell>15</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="4">1.00 1.00 1.00 1.00 0.88</cell><cell>100</cell></row><row><cell>172.mgrid</cell><cell>19</cell><cell>35</cell><cell>23</cell><cell>10</cell><cell>4</cell><cell>2</cell><cell cols="4">1.07 1.00 0.99 1.00 0.87</cell><cell>99.98</cell></row><row><cell>Average</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">0.88 0.97 1.00 1.00 1.10</cell><cell>99.79</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 : Fraction of loads performing associative searches</head><label>5</label><figDesc></figDesc><table><row><cell>Benchmarks</cell><cell cols="5">Average LSQ Activity Factor</cell></row><row><cell></cell><cell>VC</cell><cell></cell><cell cols="2">SKID</cell><cell cols="2">NACK</cell></row><row><cell></cell><cell>40</cell><cell>48</cell><cell>40</cell><cell>48</cell><cell>40</cell><cell>48</cell></row><row><cell>SPEC</cell><cell cols="6">.21 .21 .27 .30 .30 .31</cell></row><row><cell>EEMBC</cell><cell cols="6">.26 .27 .38 .39 .38 .39</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head n="8.">ACKNOWLEDGMENTS</head><p>We thank <rs type="person">M.S. Govindan</rs> for his help with the power measurements and <rs type="person">K. Coons</rs>, <rs type="person">S. Sharif</rs> and <rs type="person">R. Nagarajan</rs> for help in preparing this document. This research is supported by the <rs type="funder">Defense Advanced Research Projects Agency</rs> under contract <rs type="grantNumber">F33615-01-C-4106</rs> and by <rs type="funder">NSF CISE Research Infrastructure</rs> grant <rs type="grantNumber">EIA-0303609</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_DNHRPvp">
					<idno type="grant-number">F33615-01-C-4106</idno>
				</org>
				<org type="funding" xml:id="_wspXKgZ">
					<idno type="grant-number">EIA-0303609</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parameter Configuration Overview</head><p>Out-of-order execution with up to 1024 instructions inflight, Up to 256 memory instructions can be simultaneously in flight. Up to 4 stores can be committed every cycle. The banks are arranged in 5x5 grid connected by mesh network. Each router uses round-robin arbitration. There are four buffers in each direction per router and 25 routers. The hop latency is 1-cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simulation</head><p>Execution-driven simulator validated to be within 11% of RTL design. 28 EEMBC benchmarks, 12 SPEC benchmarks simulated with single simpoints of 100M  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Store Buffer Design in First-Level Multibanked Data Caches</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Torres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ibanez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vinals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Llaberia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">DMDC: Delayed Memory Dependence Checking through Age-Based Filtering</title>
		<author>
			<persName><forename type="first">F</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Pinuel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prieto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tirado</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>In MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Address-indexed memory disambiguation and store-to-load forwarding</title>
		<author>
			<persName><forename type="first">Sam</forename><forename type="middle">S</forename><surname>Stone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">M</forename><surname>Woley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">I</forename><surname>Frank</surname></persName>
		</author>
		<editor>MICRO</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Fire-and-Forget: Load/Store Scheduling with No Store Queue at all</title>
		<author>
			<persName><forename type="first">Samantika</forename><surname>Subramaniam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gabriel</surname></persName>
		</author>
		<author>
			<persName><surname>Loh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>In MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Checkpoint processing and recovery: Towards scalable large instruction window processors</title>
		<author>
			<persName><forename type="first">H</forename><surname>Akkary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 36th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2003-12">December 2003</date>
			<biblScope unit="page" from="423" to="434" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Slackened Memory Dependence Enforcement: Combining Oppurtunistic Forwarding with Decoupled Verfication</title>
		<author>
			<persName><forename type="first">Alok</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Wasiur</forename><surname>Rashid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Tradeoffs in Power-Efficient Issue Queue Design</title>
		<author>
			<persName><forename type="first">Alper</forename><surname>Buyuktosunoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">H</forename><surname>Albonesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pradip</forename><surname>Bose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">W</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanley</forename><forename type="middle">E</forename><surname>Schuster</surname></persName>
		</author>
		<editor>ISPLED</editor>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">High Bandwidth Load Store Unit for Single-and Multi-Threaded Processors</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Roth</surname></persName>
		</author>
		<idno>MS-CIS-04-09</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer and Information Sciences, University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Dynamic Management of Microarchitecture Resources in Future Microprocessors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Balasubramonian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>University of Rochester</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Decomposing the load-store queue by function for power reduction and scalability</title>
		<author>
			<persName><forename type="first">L</forename><surname>Baugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zilles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">P=ac ? Conference</title>
		<imprint>
			<publisher>IBM Research</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Loose loops sink chips</title>
		<author>
			<persName><forename type="first">E</forename><surname>Borch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Manne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Symposium on High-Performance Computer Architecture</title>
		<meeting>the 8th International Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2002-02">2002 February</date>
			<biblScope unit="page" from="299" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Scaling to the End of Silicon with EDGE architectures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Burrill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yoder</surname></persName>
		</author>
		<author>
			<persName><surname>Team</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="44" to="55" />
			<date type="published" when="2004-07">July 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Memory ordering: A value-based approach</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Cain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Kilo-instruction processors: Overcoming the memory wall</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cristal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Santana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cazorla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Galluzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pericas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="48" to="57" />
			<date type="published" when="2005-06">May. June 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Measuring experimental error in microprocessor simulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Desikan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual International Symposium on Computer Architecture</title>
		<meeting>the 28th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2001-07">July 2001</date>
			<biblScope unit="page" from="266" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">L-CBF: A Low Power, Fast Counting Bloom Filter Implementation</title>
		<author>
			<persName><forename type="first">Elham</forename><surname>Safi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Moshovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Veneris</surname></persName>
		</author>
		<editor>ISPLED</editor>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">ARB: a hardware mechanism for dynamic reordering of memory references</title>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="552" to="571" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Using Virtual Load/Store Queues (VLSQs) to Reduce the Negative Effects of Reordered Memory Instructions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jacob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Delaying Physical Register Allocation Through Virtual-Physical Registers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Monreal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzlez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vinals</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Store vulnerability window (svw): Re-execution filtering for enhanced load optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Distributed microarchitectural protocols in the TRIPS prototype processor</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sankaralingam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nagarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Desikan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drolia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gratz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gulati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sethumadhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sharif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shivakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO</title>
		<imprint>
			<date type="published" when="2006-12">December 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scalable memory disambiguation for high ilp processors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Desikan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">36th International Symposium on Microarchitecture</title>
		<imprint>
			<date type="published" when="2003-12">December 2003</date>
			<biblScope unit="page" from="399" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Design and Implementation of the TRIPS Primary Memory System</title>
		<author>
			<persName><forename type="first">Simha</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajagopalan</forename><surname>Desikan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Doug</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<editor>ICCD</editor>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Continual flow pipelines</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Akkary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gandhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Upton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2004-10">October 2004</date>
			<biblScope unit="page" from="107" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Bieschewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan-Manuel</forename><surname>Parcerisa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Memory Bank Predictors. In ICCD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">POWER4 system microarchitecture</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Tendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J S</forename><surname>Fields</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sinharoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="26" />
			<date type="published" when="2001-01">January 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Scalable store-load forwarding via store queue index prediction</title>
		<author>
			<persName><forename type="first">Tingting</forename><surname>Sha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Milo</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Roth</surname></persName>
		</author>
		<editor>MICRO</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">NoSQ: Store-Load Communication without a Store Queue</title>
		<author>
			<persName><forename type="first">Tingting</forename><surname>Sha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><surname>Roth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>In MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Orion: a power-performance simulator for interconnection networks</title>
		<author>
			<persName><forename type="first">H.-S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-S</forename><surname>Peh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-12">2002 December</date>
			<biblScope unit="page" from="294" to="305" />
			<pubPlace>MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Inherently Lower-Power High-Performance Superscalar Architectures</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">V</forename><surname>Zyuban</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-03">March 2000</date>
		</imprint>
		<respStmt>
			<orgName>University of Notre Dame</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
