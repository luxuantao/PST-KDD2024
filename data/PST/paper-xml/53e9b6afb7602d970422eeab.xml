<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fault-Tolerant Clustering of Wireless Sensor Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gaurav</forename><surname>Gupta</surname></persName>
							<email>gagupta1@cs.umbc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Elec. Eng. Dept. of Computer Science and Elec. Eng</orgName>
								<orgName type="institution">University of Maryland Baltimore County University of Maryland Baltimore County</orgName>
								<address>
									<postCode>21250, 21250</postCode>
									<settlement>Baltimore, Baltimore</settlement>
									<region>MD, MD</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mohamed</forename><surname>Younis</surname></persName>
							<email>younis@cs.umbc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Elec. Eng. Dept. of Computer Science and Elec. Eng</orgName>
								<orgName type="institution">University of Maryland Baltimore County University of Maryland Baltimore County</orgName>
								<address>
									<postCode>21250, 21250</postCode>
									<settlement>Baltimore, Baltimore</settlement>
									<region>MD, MD</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fault-Tolerant Clustering of Wireless Sensor Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">019A91DC8341217CFEAC569E89AD76A7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Network clustering</term>
					<term>Fault-tolerance</term>
					<term>Energy-Aware Communication</term>
					<term>Sensor networks</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>During the past few years distributed wireless sensor networks have been the focus of considerable research for both military and civil applications. Sensors are generally constrained in on-board energy supply therefore efficient management of the network is crucial to extend the life of the system. Sensors' energy cannot support long haul communication to reach a remote command site, thus they require multi-tier architecture to forward data. An efficient way to enhance the lifetime of the system is to partition the network into distinct clusters with a high-energy node called gateway as cluster-head. Failures are inevitable in sensor networks due to the inhospitable environment and unattended deployment. However, failures in higher level of hierarchy e.g. cluster-head cause more damage to the system because they also limit accessibility to the nodes that are under their supervision. In this paper we propose an efficient mechanism to recover sensors from a failed cluster. Our approach avoids a full-scale re-clustering and does not require deployment of redundant gateways.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Recent advancements in integrated circuits have fostered the emergence of a new generation of tiny, inexpensive lowpower sensors. Due to their economic and computational feasibility, a network of hundreds and thousands of sensors has the potential for numerous applications in both military and civil applications such as combat field surveillance, security and disaster management. These sensing devices are capable to monitor a wide variety of ambient conditions such as: temperature, pressure, motion etc. The sheer number of these devices and their ad-hoc deployment in the area of interest brings numerous challenges in networking and management of these systems. Sensors are typically disposable and expected to last until their energy drains. Therefore, energy is a very scarce resource for such sensor systems and has to be managed wisely in order to extend the life of the sensors for the duration of a particular mission.</p><p>Typically sensor networks follow the model of a command node or base station, where sensors relay streams of data to a command node either periodically or based on events. The command node is located faraway from the area where the sensors are usually deployed. In order to conserve energy consumed in communication with the command node various multi-hop and energy aware routing techniques have been suggested in the literature <ref type="bibr" target="#b4">[5]</ref> <ref type="bibr" target="#b5">[6]</ref>. These techniques have overhead due to route discovery and to find optimum hops to communicate with the command node. In addition, there will be extra burden on the nodes, which are located around the command node, as most of the traffic will be routed through them.</p><p>To avoid these overheads and unbalanced consumption of energy some high-energy nodes called "Gateways" are deployed in the network. These gateways, group sensors to form distinct clusters in the system, manage the network in the cluster, perform data fusion to correlate sensor reports and organize sensors by activating a subset relevant to required missions or tasks as shown in Fig 1 . Clusters are formed based on the load on the gateways and the communication distance between sensors and the gateways <ref type="bibr" target="#b7">[8]</ref>. Each sensor belongs to only one cluster and communicates with the command node only through the gateway of the cluster.</p><p>In sensor networks the effectiveness of data fusion depends not only on the sensed data but also on the coverage of sensors. In some mission critical applications such as disaster management it is essential to ensure good coverage to increase the potential of rescuing survivals and ensure the safety of the rescue crew. Therefore, dependability of the system becomes another very important factor for the efficient operation of the system. Sensors are susceptible to device failures due to limited battery power but will also be inactive if the gateway in their cluster suffers from some faults. Reconfiguration of the system can be used to recover the sensors in a faulty cluster through re-clustering. Reclustering the system complicates the network setup and bootstrapping. Gateways have to stop data processing and communication in order to perform clustering. New communication schedules have to be set and transmitted to the sensors. Moreover, frequent faults will result in frequent re-clustering wasting precious energy and time. Redundant gateways can also be deployed in the system to replace the faulty gateways. However, pre-deployment of redundant gateways makes them unutilized resource while replacement of faulty gateway can be impractical and slow.</p><p>In this paper we investigate the dependability of sensor networks in the presence of faults in the gateways. We propose a run-time recovery mechanism based on consensus of healthy gateways to detect and handle faults in one faulty gateway. A two-phased detection and recovery mechanism is proposed to limit the performance impacts caused by a gateway failure. We use a simulation-based fault injection method, which assumes that errors occur according to a predetermined distribution. The sensors assigned to the faulty gateway are reorganized on the fly without bringing the system to a complete shutdown. The recovery information is created during clustering which facilitates the recovery process. Various communication fault scenarios are considered and handled during recovery. Our approach provided considerable improvement in the stability of the system and reduces the overhead of re-clustering and system reconfigurations.</p><p>In the next two sections we define the architectural model of sensor networks and summarize the related work. Section 4 describes the fault-detection and recovery approach. Description of the simulation environment and validation of the experiments can be found in section 5. Finally section 6 concludes the paper and discusses our future research plan.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">System Model</head><p>The system architecture for the sensor network is shown in Fig 1 . There are only two kinds of nodes in the system; sensors and less-energy-constrained gateway nodes. The sensors and gateways are assumed to be of the same kind and have same properties respectively. All communication is over wireless links. A wireless link is established between two nodes only if they are in range of each other. Gateways are capable of long-haul communication compared to the sensors and are in direct communication range with the command node. Communication between nodes is over a single shared channel. Current implementation supports TDMA <ref type="bibr" target="#b6">[7]</ref> protocol to provide MAC layer communication.</p><p>In this paper we assume that the sensor and gateway nodes are stationary. In the future we plan to incorporate mobile gateways in the system. During the bootstrapping process, all the sensors and gateways are assigned unique IDs, initial energy and TDMA schedule. All nodes are assumed to be aware of their position through some GPS system. While the GPS consumes significant energy, it has to be turned on for a very short duration during bootstrapping. Sensors inform the gateways about their location during the clustering process. It is worth noting that most of these capabilities are available on some of the advanced sensors, e.g. the Acoustic Ballistic Module from SenTech Inc. <ref type="bibr" target="#b1">[2]</ref>.</p><p>Initially all gateways are assumed to be in communication range with one another. Gateways form their own subnet to exchange status information about the clusters and to reach a consensus during recovery. The schedule of first inter-gateway communication is known to all the gateways during bootstrapping. No communication between the gateways and sensors is scheduled during inter-gateway communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Fault Model</head><p>A system failure occurs when the delivered service deviates from the specified service <ref type="bibr" target="#b16">[17]</ref>. Hardware and software faults affect the system state and the operational behavior, such as memory or register content, program control flow, and communication links etc. We assume a fail silent model where any erroneous behavior does not affect the healthy components. We assume that the communicated data is error free and semantic-related generic faults in the software are detected and removed by application-specific checks.</p><p>Communication faults can be caused due to hardware failure or energy depletion. Communication can be disrupted due to environmental conditions like wind or rain. Hardware faults can also disrupt radio communication, ending all the communication to and from the gateway. A fault in transmitter can prevent the gateway to transmit tasks to the sensors as well as relay the data to the command node. Data send by the sensors will be lost if receiver of a gateway fails. We call all such failures as complete gateway failures because the gateway can no longer serve as a liaison between the sensors and the command node. Another kind of failures is caused due to faults in range of gateway. Faults in range of the device can affect its coverage. A gateway can experience communication link failure between the sensors in its cluster or with other gateways. A communication link failure with the sensors requires the sensors to be allocated to other gateways within communicate range. Faults in inter-gateway communication are handled through forwarding approach explained later.</p><p>Based on the temporal behavior of a fault it can be considered as permanent, intermittent or transient. In our fault model we consider only permanent faults. A permanent fault once activated remains effective until it is detected and handled. We also assume that the system is not liable to Byzantine-type faults <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Related Work</head><p>Our work is motivated by a various research projects in sensor network domain. Researchers are exploring both hardware and software aspect of sensor networks. Projects like Smartdust <ref type="bibr" target="#b8">[9]</ref>, WINS <ref type="bibr" target="#b9">[10]</ref>, PicoRadio <ref type="bibr" target="#b10">[11]</ref> have given a new dimension to the size and capabilities of sensors. Since sensors are typically battery-operated with limited energy supply, many research groups have focused on issues like energy aware routing <ref type="bibr" target="#b4">[5]</ref>, sensor coordination <ref type="bibr" target="#b5">[6]</ref>, and energy saving through activation of a limited subset of nodes <ref type="bibr" target="#b3">[4]</ref> <ref type="bibr" target="#b11">[12]</ref>.</p><p>Many clustering approaches have been proposed for efficient selection of a cluster-head such as randomized <ref type="bibr" target="#b12">[13]</ref> lowest cluster-ID <ref type="bibr" target="#b14">[15]</ref>, or highest degree of connectivity <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>. However, if load is not balanced among the cluster it can lead to increased latency in communication, inadequate tracking of targets or events and finally results in failure of the gateway. In our previous work a multi-gateway architecture is presented to cluster the network around highenergy gateways while balancing load among the clusters <ref type="bibr" target="#b7">[8]</ref>.</p><p>Moreover, these approaches do not focus on dependability and fault-tolerance in the system. Upon failure of a cluster-head either the role is reassigned to another node requiring re-configuration of the whole system or redundant hardware is used as replacement. Projects like LEACH <ref type="bibr" target="#b12">[13]</ref> include redundancy in the system by periodically selecting a cluster-head from the sensors in the network but suffer from overhead of re-clustering. We believe that, significant performance gain can be achieved if efficient recovery is embedded in the system from the beginning. Faults should be detected and handled during the run-time. Analysis and modeling of faults is a well-researched field <ref type="bibr" target="#b19">[20]</ref>. In this paper we present a run-time recovery mechanism, which detects faults in gateways and recover sensors from the failed clusters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Fault-Tolerance Mechanism</head><p>The main objective of our approach is to perform run-time recovery of the sensors from the clusters in which the gateway has experienced some faults. The mechanism is divided in to two phases; detection and recovery. In order to recover the sensors from the failed cluster it is important to detect whether a fault has occurred in the system. We follow a consensus model of the gateways to agree on a particular fault in the system. A consensus is required to maintain the synchronization in the network with respect to the status and cardinality of a gateway. The cardinality of a gateway is the number of sensors that belong to the cluster of a gateway. In later sections we present scenarios where gateways can have conflicting knowledge about the status of a gateway and explain methods to avoid it. The second phase of faulttolerance identifies the type of fault and performs recovery of the sensors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Detection of gateway failure</head><p>Detection is the first phase of fault-tolerance in our system. All the gateways in a sensor network are independent identities. A gateway is responsible only for the sensors in its own cluster. We adopt a method of periodic status updates through inter-gateway communication. Status updates inform all the gateways about the whereabouts of the rest of the clusters in the system.</p><p>As mentioned in section 2, we are using TDMA MAC protocol for communication. TDMA schedules for sensors are decided by their respective gateways. Typically, gateways allocate slots for sensors to send data based in available energy, tasks, and priority <ref type="bibr" target="#b6">[7]</ref>. Fig <ref type="figure" target="#fig_0">2</ref> shows a simple slot allocation for a gateway. Sensors are informed about the schedule and routing information in a "Route Update" slot. The dark slots represent the route update slots and the white slots are reserved for sensors to send data in that cycle. Along with the sensed data, sensors also provide their energy status to the gateways. A cycle is completed when all the sensors send data and energy status to their respective gateways and wait for the next route update. At the end of every cycle each gateway constructs a "Status" containing information about the sensors in its cluster and the status of the gateways itself.</p><p>Gateway status is exchanged in a "Status Update" slot (shown as grey slots in Fig. <ref type="figure" target="#fig_0">2</ref>) whose period depends on the stability of the system. We use a Multiplicative Increase Linear Decrease (MILD) mechanism to schedule the status exchange. In the absence of faults, MILD increases the time period of the exchange by a multiplicative factor while linearly decreases the time period when a fault is detected. By this method we reduce the overhead of status exchange when the system is stable and recovers fast from the faults when the system is fragile. Status messages also act as heartbeat messages from the gateways informing about their presence. At the end of detection phase when a gateway "A" does not receives update from another gateway "B", gateway "B" is considered to be faulty by "A". Since the updates can be missed due to link failures between two nodes, a consensus has to be reached by all gateways before recovery commences. It is important to remember that a gateway should not be considered completely failed until even one of the gateways in the network is able to communicate with it.</p><p>In case of link failures multiple hops have to be used to forward updates. Efficient routing can be used to forward these updates but they require maintenance and update of routing tables. For the purpose of this paper we adopt a simple forwarding approach. Each gateway forwards (broadcasts) every "new" update it receives to all the gateways in its range. This method will add redundant messages in the network when the network is fault-free but ensures that every gateway has the same status information of the system. A consensus is reached automatically since all the gateways share the same information. If a gateway has failed none of the other gateways will receive the update and can start the recovery. We describe two scenarios to explain the forwarding approach and introduce an experience-based enhancement to avoid redundant messages in the absence of faults.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Status Update</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Route Update</head><note type="other">Sensor Data</note><p>Case 1: No Faults, fully connected network Fig <ref type="figure">3</ref> shows a fault free fully connected gateway architecture where all gateways (G1-G4) are in direct communication range with one another. During the status update phase all the gateways will broadcast their updates. Since all the gateways are in direct communication range every gateway will receive the status and will conclude that no gateway has completely failed in the system. But, the forwarding algorithm will make the gateways broadcast the redundant status information of other gateways as well.</p><p>In order to avoid such message redundancy in the absence of faults in the system we use an "experience" based model. Before forwarding updates from other gateways each gateway constructs an experience of the updates received. They first broadcast their experience about the connectivity with other gateways. After receiving the experience from other gateways, an experience table is constructed that shows the connectivity of different nodes in the system. For the case described above the experience table is shown in Table <ref type="table" target="#tab_0">1</ref>. When a gateway receive the experiences like the one shown in table below, it signifies that the network is fully connected and no forwarding of update message is required.  between gateway G1 and G3 followed by a complete failure of gateway G4. In the first status update slot no gateway will receive status from G4. Also, G1 and G3 will not receive status from each other and G2 will receive status from both G1 and G3.</p><formula xml:id="formula_0">G1 G2 G3 G4 G1 √ √ √ √ 1 1 1 G2 1 √ √ √ √ 1 1 G3 1 1 √ √ √ √ 1 G4 1 1 1 √ √ √ √</formula><formula xml:id="formula_1">G1 G2 G3 G4 G1 √ √ √ √ 1 0 0 G2 1 √ √ √ √ 1 0 G3 0 1 √ √ √ √ 0 G4 0 0 0 0 Table 2: Experience Table for Case 2</formula><p>The experience table formed at gateway G2 is shown in Table <ref type="table">2</ref>. After analyzing the experience table, gateway G2 realizes that none of the gateways has received status update from gateway G4 and G4 had not send its experience to any of the gateways. This clearly indicates that G4 is not able to transmit any data to other nodes due to transmitter fault. Therefore, G4 is tagged as completely failed and all the sensors in the cluster of G4 have to be recovered.</p><p>The zeros in the experience on G1 and G3 indicate the link failure between them. Since a consensus cannot be reached about the complete failure of Gateway G4 unless all the gateways receive the experience, G2 understand that it has to forward the update to G1 and G3. Once the gateways G1 and G3 receive all the update except from G4 they also concur to the complete failure of gateway G4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Recovery</head><p>Once the gateways reach a consensus about the presence of a fault, the next step is to identify the type of faults and allocate the sensors to new clusters. The status message is parsed to extract the identity of sensors that cannot communicate with the gateway due to range faults in the gateways. When a gateway is identified as completely failed all the sensors in its cluster are recovered.</p><p>Clustering is based on the distance between the sensors and gateways. During clustering each gateway creates a range set based on the communication range of the sensors and the gateways. A sensor 'S j ' belongs to range set 'RSet' of gateway 'G i ' if it satisfies the following criteria: </p><formula xml:id="formula_2">S j ∈ RSet Gi ⇔[( R Gi &gt; d Sj-&gt;Gi ) Λ (R Sj,max &gt; d Sj--&gt;Gi )]</formula><p>Where, R Gi is the range of gateway G i , R Sj,max is the maximum range of sensor S j and d Sj-&gt;Gi is the distance between sensor S j and Gateway G i . A final set (FSet) is constructed based on the minimum communication cost between sensors and gateways <ref type="bibr" target="#b7">[8]</ref>. For the purpose of recovery each gateway constructs another set containing nodes that do not belong to the cluster of the gateway but are included in its RSet. This set is called a Backup set (BSet). Each node only belongs to a single FSet but can be part of many BSets. The definition of BSet is defined as:</p><formula xml:id="formula_3">S j ∈ BSet Gi ⇔[( S j ∈ RSet Gi ) Λ (S j ∉ FSet Gi )]</formula><p>When a sensor has to be recovered all the gateways check their own BSets for the sensor. The sensor is recovered if it is present in the BSet of the gateway. If a sensor is present in multiple BSets, it is accommodated by the gateway, which has the minimum communication cost with the sensor other then one failed. Once the sensor is associated with the backup gateway, it is removed from the BSet of the backup gateway as well as the RSet of the faulty gateway. Due to previous schedule the receivers of the sensor are turned on during the route update slot to receive the new update from the gateway. Therefore, the backup gateway informs the sensor about the new association in the same slot. New TDMA schedules are given to the sensor according to the cardinality of the new gateway and the sensor becomes a part of the backup cluster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experimental Validation</head><p>The effectiveness of our recovery approach is validated through simulation. This section describes simulation environment, fault injection technique and validation of the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Environmental Setup</head><p>Experiments are performed on simulations with 1000 sensors and 3 gateways uniformly distributed in a 10 × 10 square kilometer area. Each sensor is assumed to have an initial energy of 5 joules. A node is considered non-functional if its energy level reaches 0 joules. The sensor energy consumption model used in our system is discussed in <ref type="bibr">[8] [13]</ref>.The maximum range of the sensors is set to 0.5 times the maximum distance between two nodes in the system. Initial range of the gateways is considered enough to cover the whole area. It is assumed that the channel is collision free and packets are not dropped in the medium. Sensors are given IDs in random fashion. Sensors are informed about the first TDMA schedules by their respective gateways. Schedule for first inter-gateway communication is decided during bootstrapping. Nodes switch on their transmitter if needed and receiver circuitry only during their allocated slots.</p><p>Fault injection is used to test the robustness and behavior of the sensor network. Fault injection allows studying the effectiveness fault detection and recovery capabilities of our system. We use a simulation-based fault injection methodology to inject communication faults in the gateways. We created a fault library of possible link, range and complete failures. We then created a timely ordered failure list using Poisson distribution for occurrence of faults. Faults are picked from the library based on a Uniform distribution for the type of failure and Normal distribution for the location of the fault.</p><p>We implement a fault-injector module to trigger the faults as events. The fault-injector keeps a check on the system time and compares it with the timestamp of the next entry in the failure list. Whenever the system time equals a fault event time, the fault-injector selects the fault from the library, reads the fault destination (gateway id) and inserts the fault in the event queue of the gateway. When a gateway encounters the fault in the event queue, it simulates the fault. The consequences of a fault experienced by the system are based on its type. It shows a link fault being injected by the fault-injector in gateway G3. Previously, gateway G2 stops all operation due to complete failure. Also, gateway G1 is suffering from a range fault. In order to measure the performance of our approach we calculate the coverage of the algorithm. Coverage is the ability of the system to detect and recover from the occurrence of a fault during normal system's operation <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Coverage = Probability [system recovers/fault occurs]</head><p>We have injected 1000 faults in order to measure the coverage of our algorithm. Since, complete failures are less common compared to other faults, we have inserted them with lower frequency than range and link failures. All complete failures are detected instantaneously during the status period. We injected faults to decrease the range of gateway G1 by 2% every 15 min of operation. On all occasion our detection mechanism detects the faults and identifies the sensors that have gone out of range from the gateways. Sensors are successfully recovered to other gateways till the range of G1 drops below a threshold and only the sensors very close to G1 are left in the cluster. After every subsequent range fault in G1 coverage decreases because the algorithm fails to find any gateway to accommodate the sensors. Link failures are injected in gateway G3 to study the impact on number of status messages in the system. Due to link failures status messages are not received by other gateways and forwarding scheme is activated. Total number of message per gateway in the forwarding scheme is N+1, where N is the total number of gateways in the system. Each gateway will transmit one status message, one experience message and forward N-1 status messages. The period of status updates is controlled by MILD algorithm until we inject a burst of faults making the recovery more frequent. The coverage of link failure has been observed to be 100% throughout the simulation until all the incoming/outgoing links from a gateway fails. After all link fails, any fault on G3 are detected as a complete failure by other gateways. Recovery of sensors in the cluster of G3 is only done on the first complete failure.</p><p>The results of the fault injection experiments clearly demonstrate that the system is resilient to communication faults and recovers efficiently without re-configurations or manual repairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and future work</head><p>High-energy gateway node acts as a centralized manager to handle the sensors and serves as a hop to relay data from sensors to a distant command node. In this paper we have introduced a two phase; detect and recover fault-tolerance approach to recover sensors from the failed gateways without shutting down or re-clustering the system. Gateways can suffer from complete, link or range failures caused due to software or hardware faults. Our approach enables faulttolerance in the system by performing periodic checks on the status of the gateways. Sensors managed by a faulty gateway are recovered by re-associating them to other clusters based on backup information created during the time of clustering.</p><p>Our future plan includes extending the clustering model to allow gateway mobility. Also, we plan to integrate bootstrapping and energy-aware routing to our approach.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Slot Allocation in Sensor Networks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Case 2 :</head><label>2</label><figDesc>Fig 4  shows the system architecture after link failures between gateway G1 and G3 followed by a complete failure of gateway G4. In the first status update slot no gateway will receive status from G4. Also, G1 and G3 will not receive status from each other and G2 will receive status from both G1 and G3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :Fig. 4 :</head><label>34</label><figDesc>Fig. 3: Fully Connected Gateway Model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig 5</head><label>5</label><figDesc>Fig 5 describes the design of the fault-injection environment.It shows a link fault being injected by the fault-injector in gateway G3. Previously, gateway G2 stops all operation due to complete failure. Also, gateway G1 is suffering from a range fault. In order to measure the performance of our approach we calculate the coverage of the algorithm. Coverage is the ability of the system to detect and recover from the occurrence of a fault during normal system's operation<ref type="bibr" target="#b16">[17]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>…Fig 5 .</head><label>5</label><figDesc>Fig 5. Design of the fault injection environment</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Experience Table for Case 1</figDesc><table><row><cell>Where:</cell></row><row><cell>√ signifies own update</cell></row><row><cell>1 signifies that the update is received</cell></row><row><cell>0 signifies that the update is missed</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Self-Organizing, Cooperative UGS Network for Target Tracking</title>
		<author>
			<persName><forename type="first">R</forename><surname>Burne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SPIE Conference on Unattended Ground Sensor Tech. and Applications II</title>
		<meeting>of SPIE Conference on Unattended Ground Sensor Tech. and Applications II<address><addrLine>Orlando</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-04">April 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Data sheet for the Acoustic Ballistic Module</title>
		<ptr target="http://www.sentech-acoustic.com/" />
	</analytic>
	<monogr>
		<title level="j">SenTech Inc</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Energy-Scalable Algorithms and Protocols for Wireless Microsensor Networks</title>
		<author>
			<persName><forename type="first">W</forename><surname>Heinzelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Acoustics, Speech and Signal Processing (ICASSP &apos;00)</title>
		<meeting>International Conference on Acoustics, Speech and Signal essing (ICASSP &apos;00)</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Span: An Energy-Efficient Coordination Algorithm for Topology Maintenance in Ad Hoc Wireless Networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MobiCom</title>
		<meeting>of MobiCom<address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-07">2001. July 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Power-Aware Routing in Mobile Ad Hoc Networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Raghavendra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM MOBICOM&apos;98</title>
		<meeting>of ACM MOBICOM&apos;98<address><addrLine>Dallas, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-10">October 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Scalable coordination in sensor networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM/IEEE MobiCom</title>
		<meeting>of ACM/IEEE MobiCom<address><addrLine>Seattle, Washington</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-08">1999. August 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Energy-Aware TDMA-Based MAC for Sensor Networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Arisha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Youssef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Younis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Workshop on Integrated Management of Power Aware Communications, Computing and Networking (IMPACCT 2002)</title>
		<imprint>
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Load-Balanced Clustering in Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Younis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Submitted to the IEEE International conference on communications (ICC 2003)</title>
		<meeting><address><addrLine>Anchorage, Alaska</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Next century challenges: Mobile networking for &apos;smart dust</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Kahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S J</forename><surname>Pister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MOBICOM</title>
		<meeting>MOBICOM<address><addrLine>Seattle</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Burnstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Bult</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wireless Integrated Microsensors</title>
		<imprint>
			<date type="published" when="1996">1996. 1996</date>
			<pubPlace>Anaheim, CA</pubPlace>
		</imprint>
	</monogr>
	<note>Proceedings Sensors EXPO</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">PicoRadio: Adhoc wireless networking of ubiquitous low-energy sensor/monitor nodes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rabaey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Da Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Society Workshop on VLSI 2000</title>
		<meeting><address><addrLine>Orlando, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-04">April 2000</date>
			<biblScope unit="page" from="9" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">ASCENT: Adaptive Self-Configuring Sensor Networks Topologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cerpa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. INFOCOM 2002</title>
		<meeting>INFOCOM 2002<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Energy-Efficient Communication Protocols for Wireless Microsensor Networks</title>
		<author>
			<persName><forename type="first">W</forename><surname>Rabiner Heinzelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chandrakasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hawaii International Conference on System Sciences (HICSS &apos;00)</title>
		<imprint>
			<date type="published" when="2000-01">January 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Distributed algorithm for Organizing Mobile Radio Telecommunication Networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ephremides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 2 nd International Conference in Distributed Computer Systems</title>
		<imprint>
			<date type="published" when="1981-04">April 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multicluster, mobile, multimedia radio network</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Tsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM/Baltzer Journal of Wireless networks</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="255" to="265" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Selecting Routers in Ad-Hoc Wireless Networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Parekh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SBT/IEEE International Telecommunications Symposium</title>
		<meeting>the SBT/IEEE International Telecommunications Symposium</meeting>
		<imprint>
			<date type="published" when="1994-08">August 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Coverage Modeling for Dependability Analysis of Fault-Tolerant Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Dugan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Trivedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="775" to="787" />
			<date type="published" when="1989-06">June 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">DOCTOR: An Integrated Software Fault Injection Environment for Distributed Real-time Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Rosenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Computer Performance and Dependability Symposium</title>
		<meeting>International Computer Performance and Dependability Symposium<address><addrLine>Erlangen, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-04">April 1995</date>
			<biblScope unit="page" from="204" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Hsueh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fault Injection Techniques and Tools</title>
		<imprint>
			<date type="published" when="1997-04">April 1997</date>
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Fault-tolerant computer system design</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pradhan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Prentice Hall Publisher</publisher>
			<pubPlace>Englewood Cliffs, New Jersey, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
