<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorithms for Technology Mapping Based on Binary Decision Diagrams and on Boolean Operations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Fridiric</forename><surname>Mailhot</surname></persName>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Giovanni</forename><surname>De Micheli</surname></persName>
						</author>
						<title level="a" type="main">Algorithms for Technology Mapping Based on Binary Decision Diagrams and on Boolean Operations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5D87126BA745EFD53BEBC82C35B9E0B4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe new algorithms and a new computeraided design tool, called Ceres, for technology mapping of both completely specified and incompletely specified logic networks. The algorithms are based on Boolean techniques for matching, i.e., for the recognition of the equivalency between a portion of a network and library cells. A novel matching algorithm, using ordered binary decision diagrams, is described. It exploits the notion of symmetry for achieving higher computational efficiency. We also describe a matching technique that takes advantage of don't-care conditions, by means of a compafibilitp graph. We then present a strategy for timing-driven technology mapping, based on iterative improvement. Experimental results indicate these techniques generate good-quality solutions, and require short run times and limited memory space.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION OGIC SYNTHESIS has been shown to be an effective</head><p>L means of designing logic circuits, especially for semicustom designs. The computer-aided synthesis of a logic circuit involves two major steps: the optimization of a technology-independent logic representation, using Boolean and/or algebraic techniques, and technology mapping. Logic optimization is used to modify the structure of a logic description, such that the final structure has a lower cost than the original [ 11, <ref type="bibr" target="#b1">[2]</ref>. Logic optimization has traditionally been done before technology-dependent operations, and is assumed to have already taken place in the following.</p><p>Technology mapping is the task of transforming an arbitrary multiple-level logic representation into an interconnection of logic elements from a given library of elements. Technology mapping is a very crucial step in the synthesis of semicustom circuits for different technologies, such as sea-of-gates, gate arrays, or standard cells. The quality of the synthesized circuits, both in terms of area and performance, depends heavily on this step.</p><p>The technology-mapping transformation implies two distinct operations: recognizing logic equivalence be- tween two logic functions, and finding the best set of logically equivalent gates whose interconnection represents the original circuit. The first operation, called matching, involves equivalence checking and input assignment. Checking for logic equivalence can be expressed as a tuu-Input assignment is also computationally complex. The second operation, called covering, involves finding an alternate representation of a Boolean network using logic elements that have been selected from a restricted set.</p><p>The two operations intrinsic to technology mapping, matching and covering, are computationally difficult. For this reason, several approaches to technology mapping have been pursued and implemented in research and commercial mapping tools. Rule-based technology mappers [4], <ref type="bibr" target="#b4">[5]</ref> and heuristic algorithms have been proposed <ref type="bibr" target="#b5">[6]</ref>- <ref type="bibr">[111.</ref> In this paper, we consider an algorithmic approach to the technology -mapping problem that extends the pioneering work of Keutzer on Dagon <ref type="bibr" target="#b7">[8]</ref> and of Detjens <ref type="bibr" target="#b6">[7]</ref> and <ref type="bibr">Rudell [12]</ref> on MIS. To put our work in perspective, we briefly summarize their approach.</p><p>Most algorithmic approaches to technology mapping attack the problem by dividing it into sub-tasks. First, Boolean networks are partitioned into an interconnection of single-output sub-networks, with the property that each internal vertex has unit outdegree (i.e., fan-out). Then, each sub-network is decomposed into an interconnection of two-input functions (e.g., AND, OR, NAND, or NOR). Each sub-network is modeled by a directed acyclic graph (DAG), called a subject graph. Finally, each subject graph is then covered by an interconnection of library cells, to produce the final circuit.</p><p>Finding a cover of a subject graph that optimizes area or timing is a difficult problem. Keutzer proposed to represent library functions by trees and to use a dynamic programming technique for optimal covering, based on fast tree matching algorithms. A similar approach was used by Rudell and Detjens <ref type="bibr" target="#b6">[7]</ref>, [ 121. Note that the overall area (and timing) of a mapped network depends on the partitioning, decomposition, and covering tasks. However, good results were achieved by this approach, and extensions based on DAG matching presented by Detjens <ref type="bibr" target="#b6">[7]</ref> did not show substantial improvements.</p><p>In this paper, we consider an approach to technology mapping that uses network partitioning and decomposition techniques similar to those used in <ref type="bibr" target="#b7">[8]</ref>, bit with dif-tology, which has been proven to be coNP-complete <ref type="bibr" target="#b2">[3]</ref>. ~~ 0278-0070/93$03.00 0 1993 IEEE I ferent matching and covering algorithms. The covering algorithm described in this paper does not use a tree-based representation. Instead, it used Boolean matching techniques based on binary decision diagrams [ 131, [ 141 to recognize whether a logic function can be implemented by a library cell. The rationale for this choice is that the representation of single-output networks by trees makes cumbersome (and in some cases impossible) the efficient mapping of logic functions that have multiple occurrences of some variables into networks of gates that also have multiple occurrences of some variables (e.g., exclusive OR'S or majority functions). Boolean techniques uniformly support the description and matching of any single-output library cell, independent of cell functionality. In addition, Boolean matching techniques can take advantage of don 't-care information.</p><p>This paper is organized as follows: We first give a brief overview of the overall approach to technology mapping. We describe partitioning, decomposition, and covering. We then present an algorithm for Boolean matching, followed by a description of the Boolean techniques used during matching. The Boolean techniques use both completely specified and incompletely specified logic functions. We then show how the don 't-care sets are derived, and their use in technology mapping. We comment on performance-oriented mapping using iterative improvement techniques. Finally, we present implementation issues and results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">TECHNOLOGY MAPPING</head><p>In this section, we present the major tasks in technology mapping. We briefly overview partitioning and decomposition, and then present our network-covering algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Partitioning</head><p>Partitioning is a heuristic step that transforms the technology-mapping problem for multiple-output networks into a sequence of sub-problems involving single-output networks. Partitioning is performed during the initial setup phase and as a part of the iterative improvement of a mapped network. We comment here briefly on the former case. The latter is described in Section IV.</p><p>The initial partitioning scheme is achieved by grouping vertices into single-output sub-networks, with the property that each outgoing edge of an internal vertex reconverges at or before the output vertex of the sub-network. Partitioning is also used to isolate the combinational portion of a network from the sequential elements and from the I/O's, where ad hoc techniques for mapping are used.</p><p>Therefore, the circuit connections to the sequential elements are removed during the partitioning step.</p><p>After the partitioning step, the circuit is represented by a set of combinational circuits that can be modeled by subject graphs <ref type="bibr" target="#b7">[8]</ref>. These graphs are single-output Boolean networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Decomposition</head><p>Decomposition is applied on each subject graph after partitioning. It yields an equivalent subject graph, where each vertex is a basefunction, e.g., a two-input AND/OR/ NAND/NOR function. Decomposition provides a mapping solution for libraries that include the base functions (i.e., almost all libraries). We assume in the sequel that the library under consideration includes the base functions. Decomposition also increases the granularity of the network, which is beneficial to the covering step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Network Covering</head><p>At this point, the logic circuit to be mapped has been partitioned into subject graphs [ rl, -* -, rk], that have been decomposed. We denote by r f a subject graph whose single-output vertex is vf We consider here the covering of a subject graph rf that optimizes some cost criteria (e.g., area or timing). For this purpose we use the notions of cluster and cluster function.</p><p>A cluster is a connected sub-graph of the subject graph rf, having only one vertex with zero out-degree vj (i.e., a single output). It is characterized by its depth (longest There are six possible cluster functions containing the vertex vj of the subject graph rf (Fig. <ref type="figure" target="#fig_2">1</ref>):</p><formula xml:id="formula_0">directed</formula><formula xml:id="formula_1">K j , I = XY K j , 2 = X(U + C) ~j , 3 = (e + Z)Y Kj.4 = (e 2 ) (a + C) K ~, ~ = (e + i ? + d ) y K j , 6 = (e + + d ) (a + c).</formula><p>The covering algorithm attempts to match each cluster function Kj,k to a library element. A cover is a set of clusters matched to library elements that cover the subject graph. A cover may optimize the overall area and/or timing. The area cost of a cover is computed by adding the cost of the clusters corresponding to the support variables in the cluster function K ~, ~ to the cost of the library  element corresponding to the cluster K ~, k under consideration. For each vertex vj in a subject graph I ' , , there is always at least one clusterfunction K j , k that matches, because the basefunctions (e.g., AND/OR) exist in the library and the network as decomposed accordingly in the initial step phase. When matches exist for multiple clusters, then for any tree-like decomposition the choice of the match of minimal area cost guarantees minimality of the total area cost of the matched sub-graph [8], [71.</p><p>The cost of the required inverters is also taken into account at this stage. Each vertex vi, when mapped, is initially annotated with two library elements: the first one, CON, gives the best cost for generating the ON set fi, and the second one, COFF, gives the best cost for generating the OFF set 5. As soon as variable j is used as an input to a gate that is being mapped, then CON or CO,, is selected according to the required polarity of j. If the same variablej is needed at a later stage with the opposite polarity, then an inverter is automatically taken into account.</p><p>The timing cost of a cover can be computed in a similar way, by considering a constant delay model. The propagation delay through a cluster is added to the maximum of the arrival times at its inputs, to compute the local time at the vertex vi <ref type="bibr">[12]</ref>. When matches exist for multiple clusters, then for any tree-like decomposition the choice of the match of minimal local time guarantees minimality of the total timing cost of the matched sub-graph.</p><p>The covering algorithm is implemented by procedure cover shown in Fig. <ref type="figure" target="#fig_3">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">BOOLEAN MATCHING</head><p>We consider now the matching step. Matching is used during the covering stage, to verify if a particular cluster is logically equivalent to an element of the library. Matching can be formulated as checking the tautology between a given Boolean function, the cluster function introduced in Section 2.3, and the set of functions representing a li-I brary element, for any permutation of its variables. We also consider the polarity problem in connection with the matching problem, because they are closely interrelated in affecting the cost of an implementation. In addition, we exploit the don 't-care conditions of the cluster function in the matching step. (2)</p><formula xml:id="formula_2">9 Y,)<label>(1)</label></formula><p>for each value of ( y , , --, y,) and each care value of -</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">I . Use of Binary Decision Diagrams</head><p>The matching algorithms presented here are all based on Boolean operations. The advantage of using Boolean operations is that logic equivalence can be established regardless of the representation. For example, fi = ab + ac + bc andf, = a(b3 + &amp;) + bc are logically equivalent, but structurally entirely different. Previous approaches used matching on trees or graphs representing the AND/OR (or equivalent) decomposition of a Boolean factored form (BFF). These algorithms could not detect logic equivalence, since no graph operation can transform the BFF of fi into f, without taking advantage of Boolean properties. It is important to note that different representations of Boolean functions arise because factoring is not unique, and therefore different forms (e.g., factored forms, sum ofproducts) can represent the same function. Therefore a covering algorithm recognizing matches independently from the representations can yield matches of better (or at worst equal) quality than those obtained by structural matching techniques.</p><p>Our alogrithms use binary decision diagrams (BDD's) as the basis for Boolean comparisons. BDD's are based on Shannon cofactors. A logic functionfis iteratively decomposed by finding the Shannon cofactors of the variables off [ 131, [ 141. We use BDD's in the form proposed by Bryant, where a fixed ordering of the variables is chosen during Shannon cofactoring [ 141. Elsewhere, these have been called ordered binary decision diagrams, or OBDD's for short [16]. Bryant also introduced procedures to reduce the size of BDD's. For the purposes of technology mapping, where a BDD representation of a portion of the circuit to map is to be used only once, the computational cost of reducing BDD's is comparable to the cost of doing one single comparison between unreduced BDD's. Therefore we exploit a simple way of comparing unreduced, ordered BDD's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">A Simple Boolean Matching Algorithm</head><p>A Boolean match can be determined by verifying the existence of an assignment of the input variables such that the clusterfunction 5 and the library element 6 are a tautology. Tautology can be checked by using recursive Shannon cofactors [ 171. The two Boolean expressions are recursively cofactored generating two decomposition trees. The two expressions are a tautology if they have the same logic value for all leaves of the recursion that are not in the don't-care set. This process is repeated for all possible ordering of the variables of 5, or until a match is found.</p><p>The matching algorithm is described by the recursive procedure simple-boolean-match shown in Fig. <ref type="figure" target="#fig_7">3</ref>, which returns TRUE when the arguments are a tautology for some variable ordering. At level n of the recursion, procedure simple-boolean-match is invoked repeatedly with arguments the cofactors of the nth variable of S and the cofactors of all the variables of 5 until a match is found, in which case the procedure returns TRUE. If no match is found, the procedure returns FALSE. The recursion stops when the arguments are constants; in the worst case, when all variables have been cofactored. The procedure returns TRUE when the corresponding values match (modulo the don't-care condition). Note that when a match is found, the sequence of the variables used to cofactor F in the recursion levels l to n represents the order in which they are to appear in the corresponding library element. The algorithm is shown in Fig. <ref type="figure" target="#fig_7">3</ref>.</p><p>Note that in the worst case all permutations and polarities of the input variables are considered. Therefore, up to n! -2" different ordered BDD's may be required for  each match. Furthermore, all library elements with n or less inputs need to be considered in turn, since don 't-care information might reduce the effective number of inputs. The worst-case computational complexity of the algorithm make it practical only for small values of n. Fortunately symmetry information can be used to reduce the search space significantly. Therefore the average computational complexity is much lower than the above bound. Experimental results have shown that Boolean matching is highly efficient, as shown in Section V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Matching Completely Specijied Functions</head><p>In this section we consider the matching problem for completely specified functions; i.e., we neglect the don 'tcare set. This simplification makes possible the use of some properties of Boolean functions that otherwise would not be usable. In particular, there are invariants in completely specified functions that are not in the presence of don 't-cares. Unateness and symmetry are two such properties. We propose to use these two properties of Boolean functions to speed up the Boolean matching operation, without hampering the accuracy or completeness of the results. In the following sections, we introduce the two properties as key elements to search-space reduction. Matching techniques with don 't-care conditions will be dealt with in Section 3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">I ) Search-Space Reduction</head><p>The simple Boolean matching algorithm presented in Section 3.2 is computationally expensive for two reasons. First n! permutations of n inputs are needed before two functions can be declared non-equivalent . Second, for each permutation, all 2" input polarities are required before logic equivalence is asserted. Since all input permu-tations and polarities must be tried before two logic functions are declared different, then for any arbitrary n-input cluster function, this implies that n! -2" comparisons are necessary in the worst case, i.e., whenever a match to a library element fails.</p><p>We now look into methods for reducing both the number of permutations and the number of polarities during the process of determining logic equivalence. The number of required polarities is reduced by taking the unateness property into account. The number of input permutations is reduced by using symmetry information. Note that the computational complexity is intrinsic to the Boolean matching problem; therefore, the worst-case number of comparisons is still n! 2" for any arbitrary cluster function. However, we will show that the upper bound on complexity is related to the functionality of the library elements, and the most commercially available libraries are constituted of elements that imply much-smaller upper bounds. Therefore, for most cluster functions, the worstcase bound is much less than n! * 2". In addition, the average cost of Boolean matching is much lower than the worst-case bound and it is shown experimentally to be competitive with other matching techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3.2) Unateness Property</head><p>To increase the efficiency of the Boolean matching process, we take advantage of the fact that the polarity information of unate variables is not needed to determine the logic equivalence. Therefore we define a transformation T that complements the input variables that are negative unate. For example, any function 5 ( y,, y2) in the yIy2 1 can be represented by the set { yI + y2, y1y2}. Note that the polarity information must be kept for binate vari-set {Yl + Y29 E + Y23 Y l + E 7 5 + E, YIY2, YIRr I ables, where both the positive and negative phases are required to express 5. By using the transformation T, we reduce the information required for the matching and therefore also reduce its computational cost.</p><p>As a result of using the unateness property, we redefine the matching problem as follows: </p><p>= T(S(Y1, * * * 7 Y,))</p><formula xml:id="formula_4">(4)</formula><p>The unateness property is also important for another aspect of search-space reduction. Since unate and binate variables clearly represent different logic operations in Boolean functions, any input permutation must associate each unate (or binate) variable in the cluster function to a unate (or binate) variable in the function of the library element. This obviously affects the number of inputvariable permutations when assigning variables of the cluster function to variables of the library element. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3.3) Logic Symmetry</head><p>One additional factor can be used to reduce the number of required input permutations. Variables or groups of variables that are interchangeable in the cluster function must be interchangeable in the function of the library element. This implies that logic symmetry can be used to simplify the search space.</p><p>Variables are symmetric if they can be interchanged without affecting the logic functionality  <ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">x,</ref><ref type="figure">,</ref><ref type="figure">x,</ref><ref type="figure">)   = %(XI,</ref><ref type="figure">* ,</ref><ref type="figure">x,</ref><ref type="figure">,</ref><ref type="figure" target="#fig_14">4 ,</ref><ref type="figure">x ,</ref><ref type="figure">)</ref> } . In the following, we write S(Rs(x,, x,) to indicate that (x,, x,} belongs to sa$.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>nary relation S a s on the set of inputs { x I , ---, x,) of of variables in logic equations implies a partition of the variables into disjoint subsets.</head><p>A symmetry set of a function 5 is a set of variables of 5 that belongs to the binary relation S@s. Two variables x, and x, <ref type="bibr">of</ref>  The symmetry properties are exploited in technology mapping as follows. Before invoking the mapping algorithm, the symmetry classes of each library element are calculated once. Symmetry classes are used in three different ways to reduce the search space during the matching phase. First, they are used as a filter to quickly find good candidates for matching. A necessary condition for matching a clusterfunction 5 by library element 6 is that both have exactly the same symmetry classes. Hence only a small fraction of the library elements need be checked by the computationally intensive Boolean comparison to see if they match the logic equation. The symmetry classes for each library element are calculated once before invoking the mapping algorithm.</p><p>Second, symmetry classes are used during the variable ordering. Once a library element S that satisfies the previous requirement is found, the symmetry sets of 5 are compared to those of 6. The only assignments of variables belonging to symmetry sets of the same size can possibly produce a match. Since all variables from a given symmetry set are equivalent, the ordering of the variables within the set is irrelevant. This implies that the permutations need only be done over symmetry sets of the same size, i.e., symmetry sets belonging to the same symmetry class C,. Thus the number of permutations required to detect a match is ny, l (S, !), where q is the cardinality of the largest symmetry set, and S, is the cardinality of a symmetry class C,.</p><p>For example, let us enumerate the permutations for matching functions 5 = y1y2( y3 + y4) + y5y6 and Er), ( <ref type="table">7 7 2 9 5 3 1 9 ( 7 7 3 9 5 2 )   ( 7 7 1 7   5 2 1 7 (772,</ref><ref type="table">E l ) ? ( 7 7 3 9 5 3 )   (171,</ref><ref type="table">5 2 1 7 (772,</ref><ref type="table">5 3 1 7 (773,</ref><ref type="table">51</ref> Although in the worst case logic equations have no symmetry at all, our experience with commercial standard cells and (programmable) gate array libraries shows that the library elements are highly symmetric. We computed the symmetry classes C, of every element of three available libraries (CMOS3, LSI Logic, and Actel), and established the cardinality S, of each symmetry class C, extracted. We found that the average cardinality s, of all the symmetry sets of the library cells in the three libraries is less than 2, as shown in Fig. <ref type="figure" target="#fig_14">4</ref>. Therefore, the number of permutations II?= I (S, !) on the average is close to 1. Procedure boolean-match, a variation on procedure simple-boolean-match, is shown in Fig. <ref type="figure" target="#fig_4">5</ref>. It incorporates the symmetry information to reduce the search space: permutations are done only over symmetry sets of the same size. In addition, symmetry sets of unate and binate variables are separated into distinct classes Cy and C!. Then only symmetry sets with the same unateness property are permuted.</p><formula xml:id="formula_5">6 = i l i2 + (i3 + i4)i5 is.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Unateness information and symmetry classes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3.4) Determination of Invariant Properties</head><p>Unateness and logic symmetry are the two invariant properties we utilize for search-space reduction during Boolean matching. Since cluster functions represent arbitrary portions of Boolean networks, we preprocess every cluster function to detect possible simplification before the unateness of symmetry properties are extracted.</p><p>In particular, the preprocessing step recognizes and eliminates vacuous variables. Recall that an equation 3 is vacuous in a variable vi if the equation can be expressed without the use of vi <ref type="bibr" target="#b22">[22]</ref>. Vacuous variables are detected by checking if 3, E 5,, for any given variable vi. When this condition is true, variable vi is vacuous, and therefore does not influence the value of 5. In that case, we arbitrarily set variable vi to 0 or to 1, to simplify the expression of function 5.</p><p>Unateness is the first property to be extracted from Boolean functions. For efficiency reasons, the unateness determination is done in two successive steps. The first step consists of considering a decomposition of the function 3 into base functions represented by a leaf-DAG and detecting the phase of each variable of 5. The phase de-  </p><formula xml:id="formula_6">+ n/2 + n/4 + * --+ 1 = n/2' -Ep",,1/2' + 1 = 2n -2 + 1 = 2n -1 vertices.</formula><p>All variables used in only one phase are necessarily unate. However, the first operation can falsely indicate binate variables, because the algorithm relies on structure, not on Boolean operations. In the second step, the unateness property of the remaining variables (those the first step labeled as binate) is detected verifying implications between cofactors <ref type="bibr" target="#b22">[22]</ref>. The unateness property of these possibly binate variables is detected by verifying if 5,, * 5 , (negative unate variable) or if Sv, * 5,, (positive unate variable). If neither implication is true, then variable vi is binate.</p><p>Once the unateness information has been determined, symmetry properties are extracted. The transformation T, presented in Section 3.3.2, is applied to ensure that symmetry will be detected between unate variables regardless of phase. We detect that two variables are symmetric simply by verifying that x J ) is true for that pair of variables. Since the symmetry property is transitive, when variable v, is symmetric to vJ, and vJ to vk, the symmetry of U , and vk is established without further verification.</p><p>Similarly, if U , is symmetric to U,, and vJ is not symmetric to vk, then vi is not symmetric to vk. As a result, when two variables are symmetric, the symmetry relations to the second variable are identical to those of the first variable, and do not need to be established through additional verification. This implies that it is not always necessary to verify all pairs of variables for symmetry. All pairs of variables must be processed (by verifying that S(Rs(xi, x j ) is true) only when there is no symmetry. This is the worst case, and n(n -1)/2 swaps must be done, where n is the number of equal inputs to the equation. When a function is completely symmetric, i.e., when all inputs to a function 5 are symmetric, then only n -1 swaps are needed.</p><p>The unateness property is used to reduce the number of swaps needed. Assuming b out of the n input variables are binate, then at worst b(b -1)/2 + (nb) (nb -1)/2 swaps are required. At best, n -2 swaps are needed, when both binate and unate variables are maximally symmetric. In order to verify that swapping two variables ( U , U,} leaves 5 unchanged, it is sufficient to verify that = Tv,,,. As in the first step, this is done using Shannon cofactors, and a single ordering (and polarity) of the variables is sufficient.</p><p>Since the polarity information is relevant to binate variables, two swaps have to be done for each pair of binate variables, one swap for each polarity of one of the two variables. Again, Shannon cofactors are used to check if the two instances of the equation are the same, and, as in the first step, only variable ordering is used.</p><p>From an implementation standpoint, symmetry classes are established once for each library element. Each library element is then inserted into a database, with its symmetry sets used as the key. Library elements with the same symmetry sets are further grouped by functionality (e.g., 61 = Y I , y2 and 6 2 = yl + y 2 are grouped together in a new entry X of the database corresponding to functions of two equivalent, unate inputs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Matching Incompletely Specijied Functions</head><p>The importance of the use of don 't-care conditions in multiple-level logic synthesis is well recognized <ref type="bibr" target="#b23">[23]</ref>. We consider here don 't-cure conditions that are specified at the network boundary and that arise from the network interconnection itself <ref type="bibr" target="#b24">[24]</ref>. Since the topology of the network changes during the covering stage, don 't-cure conditions are dynamically computed.</p><p>Therefore a technology-mapping algorithm that exploits don 't-cure sets must involve two tasks: 1) computing and updating local don't-cure sets and 2 ) using the don't-cure information to improve the equality of the mapped circuit. We present the use of don 't-care sets first and we defer their computation to Section 3.4.2.</p><p>We have considered two approaches to using don 't-care conditions in technology mapping. The former uses Boolean simplification before matching a function to a library element. The latter merges simplification and matching in a single step and it is motivated by the following rationale: don't care conditions are usually exploited to minimize the number of literals (or terms) of each expression in a Boolean network. While such a minimization leads to a smaller (and faster) implementation in the case of pluri-cell design style [25] (or PLA-based design), it may not improve the local area and timing performance in a cell-based design. For example, cell libraries exploiting pass transistors might be faster and/or smaller than other gates having fewer literals. A passtransistor-based multiplexer is such a gate. Assuming a function is defined by its ON set 5 and its don 't-cure set Doe:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">= (U + b)c</head><p>D o e = bc then (U + b)c is the representation that requires the least number of literals (3), and the corresponding logic gate is implemented in CMOS pass-transistor logic by 6 transistors. On the other hand, U&amp; + bc requires one more literal (4), but it is implemented by only 4 pass transistors, and it is likely to be faster.</p><p>A second example, taken from the MCNC benchmark majoriry, is also representative of the uses of don 't-cures during matching (Fig. <ref type="figure" target="#fig_17">6</ref>). In that example, using don'tcures yields better matches, and gives an overall lower cost for the resulting circuit: the cluster function OUT = Tu + Tc + Td has an associated don't-cure set D D e 3 Td + Tc, and can be reexpressed as OUT = (i?z(ii + T).</p><p>The two expressions have the same number of literals (4), and are therefore equally likely to be chosen by a technology-independent simplify operation (which relies on literal count). But only one of the two exists in the library, and that match is essential in finding the best overall cost.</p><p>These examples show that applying Boolean simplifi-cation before matching may lead to inferior results, as compared to merging the two steps into a single task. For this reason, we directly use don 't-care sets in the Boolean matching step to search for the best implementation in terms of area (or timing).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">I ) Compatibility Graph</head><p>Boolean matching that incorporates the don 't-care information can be done using the simple matching algorithm presented in Section 3.2. Unfortunately, when don 't care conditions are considered, the cluster jimction 5 cannot be uniquely characterized by a symmetry set. Therefore the straightforward techniques based on symmetry sets presented in the previous section no longer apply. The simple matching algorithm would require in the worst case n! -2" variable orderings, each ordering requiring up to 2" Shannon cofactorings. Therefore the algorithm is likely to be inefficient.</p><p>Another straightforward approach is considering all the completely specified functions X that can be derived from 5 and its don't cure set De, by adding to 5 all subsets of %De. In this case, the symmetry sets can be used to speed up matching. Unfortunately, there are 2N possible subsets of DDe, where N is the number of minterms in</p><p>De. Therefore this approach can be used only for small don't-cure sets. For large don't-cure sets, a pruning mechanism must be used to limit the search space. We consider in this section a formalism that allows us to efficiently use don't-cure sets in matching. We first introduce a representation of n-variable functions that exploits the notion of symmetry sets and NPN equivalence and that can be used to determine matches while exploiting the notion of don 't-cure conditions. For a given number of input variables n, let G(V, E) be a graph whose vertex set V is in one-to-one correspondence with the ensemble of all different NPN-equivalent classes of func-   of at most 4 variables. Although libraries contain cells with more than 4 inputs (see Table <ref type="table" target="#tab_0">I</ref>), we found from experimental results of mapped networks that the majority of the library elements used have 4 or less variables (see Table <ref type="table" target="#tab_0">I1</ref> for the distribution of the number of inputs of cells used for mapping 30 benchmarks). Therefore, it is a reasonable implementation decision to use don 't-cures only for cluster functions whose fan-in is less than or equal to 4.</p><p>For functions of 4 variables and less, the compatibility graph is constructed once and annotated with the library elements. Each vertex ui in the graph is also annotated with the paths pV from the vertex vi to a vertex vj corresponding to library element sc E e. The set of paths Pig = { pio, p i l , ---, pi,} represents all the paths from vertex vi to the vertices corresponding to library elements. r Each path represents the set of additional minterms differencing the function 8; corresponding to vi from the function 8, of vj, where vj corresponds to a library element. Therefore, checking if a function 5 is logically equivalent (modulo the don 't-care set De ) to a library element sk E d: is the same as verifying that vertex vi (corresponding to function 5) has some path P;k to vertex vk (corresponding to library element sk), such that the corresponding minterms are in the don 't-care set DC! .</p><p>Let us define n t ( v ; ) as the number of minterms of the representative function 8; of vertex vi in a given ndimensional Boolean space, and the distance between two vertices vi and vj as D ( v i , v i ) = Int(vi)n t ( v j ) l .</p><p>Then the number of paths from vertex vi to any other vertex (including itself) of the compatibility graph is 22" -mlE("i). For a 4-variable compatibility graph, the total number of paths for the entire network is 375 522. This is reasonable from an implementation point of view, since each path is represented by 16 bits, and thus the entire set of paths occupies approximately 750 kilobytes. Note that in general not all paths need to be stored, since the elements of the library usually represent only a subset of all possible NPN-equivalent classes.</p><p>If we consider all possible combinations of minterms, the maximum number of paths (Pik 1 between a vertex vi and a library element vk is</p><p>The first term of the expression for (P, 1 represents all the combinations of minterms that can make a function of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>%(vi) minterms into a function of ~( v , )</head><p>minterms, in an n-dimensional Boolean space. The second term of the expression represents the combinations of minterms that yield a function of 2"n t ( v k ) , i.e., the complement of the functions computed for in the first part. Although this upper bound function grows exponentially, experimental results show that the actual number of paths between any pair of vertices is much smaller. For the 4-variable compatibility graph, the maximum number of paths between any two vertices is 384, corresponding to vertices vi = abcd and vj = abcd + ii(bz + Fd). Given that %(vi) = 1 and 3Z(vj) = 5, it is clear that the actual number of paths is much smaller than the worst case of 4004 calculated with the above formula. This is due to the fact that not all combinations of added minterms will make function Oi logically equivalent to 8k. In some cases, it is even impossible to reach some library element vk from vertex vi. For example, in Fig. <ref type="figure">7</ref>, vertex v4 cannot reach vertices vll, 1113. In addition, some paths do not need to be recorded, because their head vertex does not correspond to a library cell. The matching of a clusterfunction 5 to a library element is redefined in terms of the compatibility graph as follows. For cluster functions with no applicable don 'tcare set, only procedure boolean-match is used to find the vertex v3 E G(V, E) corresponding to the NPN-equiv-alent class of clusterfunction 5 (without using De). Since the graph represents all possible functions of 4 or less variables, then there exists a vertex in the graph which is NPN-equivalent to 5. At the same time vertex vF is found, the algorithm computes the transformation 3 representing the input ordering and polarity on the inputs and output such that 3( <ref type="formula">5</ref> The algorithm for graph traversal is shown in Fig. <ref type="figure">8</ref>. It is invoked with the vertex found by algorithm boolean-matching and the image 3(3X) to the corresponding don 't-care set as parameters. When finished, the algorithm returns the list of all the matching library elements, among which the minimum-cost one is chosen to cover 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.4.2) Computation of Relevant Don ?-Care Sets</head><p>Don 't-care sets are classified into two major categories: external DC's, and internal DC's <ref type="bibr" target="#b23">[23]</ref>. External DC's are assumed to be provided by the user along the network specification. They represent conditions that never occur on the primary inputs of the circuit and conditions that are never observed on the primary outputs. Internal DC's occur because of the Boolean network structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>They are further classified into controllability don 't-cares and observability don 't-cares. Controllability don 't-cares represent impossible logic relations between internal variables. Observability don 't-cares represent conditions under which an internal vertex does not influence any primary output.</head><p>The existence of controllability and observability don 'tcare sets represent two different (but complementary) aspects of a network. Controllability don 't-care sets are related to the logic structures in the transitive fan-in of a vertex, whereas observability don 't-care sets are related to the logic structures in the transitive fan-out of a vertex in the Boolean network. The dynamic programming formulation of technology mapping implies the network to map is modified starting at the primary inputs, and is completed when all primary outputs are processed. The technology-mapping operation modifies the logic structure of the network, and potentially modifies the internal don 'tcare sets. Therefore, don 't-care sets should be calculated dynamically, as the boundary of the mapped network moves from primary inputs to primary outputs (Fig. <ref type="figure" target="#fig_20">9</ref>).</p><p>Controllability don 't-care sets are conceptually easily computed: a vertex is being mapped only when all its predecessors are mapped. Then all the logic functions expressing a vertex are known, and it is straightforward to extract the controllability don 't-care sets from them. For  The controllability don't-care sets are computed dynamically as the mapping operation proceeds through the network (Fig. <ref type="figure" target="#fig_2">10</ref>). Alternatively, the CDC can be computed using images and a range computation algorithm [26], <ref type="bibr" target="#b27">[27]</ref>, <ref type="bibr" target="#b28">[28]</ref>, <ref type="bibr" target="#b29">[29]</ref>.</p><p>Observability don 't-care sets deal with the successors of vertices. They denote conditions under which a variable does not influence any primary output. For example, in the network x = at, t = b + c, t is unobservable when a = 0 (in that case, x = 0 regardless of the value of t).</p><p>'Recall that a Boolean network is defined by a set of equations i = Si. Therefore the condition (i # 5,) = i Q 5,can never occur.</p><p>By the very nature of dynamic programming techniques, when a vertex is being processed, its successors are not yet mapped. This implies that the exact observability of a vertex is known only after the mapping is completed. Note that unless the observability don 't-cares are recomputed each time a vertex is modified, it is not possible to use the full ODC set for all the vertices <ref type="bibr" target="#b30">[30]</ref>. Therefore, compatible subsets of the ODC need be used, as described in <ref type="bibr" target="#b31">[31]</ref>. Although good algorithms have been proposed to compute compatible observability don 't-care sets [32], <ref type="bibr" target="#b33">[33]</ref>, efficient implementations are far from trivial, and - we decided not to include them at present. The results reported in Section V therefore represent only the use of controllability don 't-care sets.</p><p>Note that when (De U 5 = l), or D C U 3 = 1, then the algorithm finds a match with the constant value 1 (0 in the second case). This is always preferred to any other match, since it has a cost of 0. As a result, for every cell mapped to a library element, there exists at least two controllable input patterns (i.e., it is possible to generate these patterns from the primary inputs), such that the output of the cell is 0 for one pattern and 1 for the other. This is a necessary condition to make a network testable. Assume that the library cells consist of testable gates (i.e., such that internal nodes are controllable and observable from the cell input/output pins). Then our method guarantees that the mapped circuit is 100% testable for stuckat faults with the recently proposed ZDDQ testing method [34], <ref type="bibr" target="#b35">[35]</ref>. However, cell controllability is not sufficient for achieving 100% testability by using standard testing methods. Indeed, it is possible that the output of a cell is not observable at the primary outputs when the controllable input patterns are applied to that cell. But by using a post-processing step involving standard ATPG and redundancy removal techniques [36], the mapped network can be made 100% testable for single stuck-at faults. The post-processing step could in principle be eliminated by computing observability don 't-care conditions. In practice this goal is hard to achieve, since the network is mapped from primary inputs to primary outputs and the observability of a vertex being mapped depends on portions of the network yet to be mapped.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PERFORMANCE-DRIVEN MAPPING</head><p>We now introduce an ensemble of operations to deal specifically with the optimization of delays through the network, in conjunction with technology mapping. We consider a delay model of the network with r- In our formulation of the problem, we are given the set of arrival times {a,&gt; of the primary inputs, together with the set of required times (ro} of the primary outputs. For synchronous circuits with period T, we assume the input arrival times to be 0, and the required times at the outputs (i.e., register inputs) to be T -Isetup. We use the concept of slack [37], <ref type="bibr" target="#b38">[38]</ref>, <ref type="bibr" target="#b39">[39]</ref>, where the slack s, at a certain vertex U, corresponds to the difference between the required time at that vertex r, and the amval time a,, i.e., sJ = r,a,. Therefore, time-critical nets are those with negative slacks. We already mentioned in Section 2.3 that dynamic programming techniques can be used to optimize timing as well as area. But there is an important difference between the two optimizations: evaluating the area cost of a particular vertex mapping involves only vertices already mapped (predecessors of the vertex), whereas evaluating the timing cost involves also the successors of the vertex being mapped. Successors are needed because the capacitive load on the output of a gate influences its rise and fall times. Since the dynamic programming technique implies that the successors of a vertex being processed are not yet mapped, then the capacitive load on its output is not known. Therefore specific methods to deal with delay have to be introduced. Binning has been proposed by Rudell <ref type="bibr" target="#b40">[40]</ref>, where each vertex is (possibly) mapped for all the possible capacitive loads on its output. We propose a different heuristic solution, involving iterative mapping of the network. The first mapping of the network includes only the optimization of area. Then, the portions of the network that do not meet the timing constraints are iteratively remapped. This method has the advantage that the entire environment of a vertex is known when it is remapped. In particular, the capacitive load driven by the vertex is known exactly.</p><formula xml:id="formula_7">a w =I=aprPioa(=-) fa (V E rpppato ad in list) f O l ( V E S E p p C 4 ( ~a d M * i O b t ) if W -M V ) = -1 -= -U 4 p = -= k V i W U m</formula><p>It is important to remark that a solution under given timing constraints may not exist. Therefore our strategy is to perform a set of transformations leading to a mapped network that either satisfies the constraints or cannot be further improved by the transformations themselves.</p><p>In order to be efficient, iterative remapping has to be powerful enough to modify substantially the portions of the network that do not meet the timing constraints, i.e., the vertices with negative slack. To converge to a good solution in a finite number of steps, it must also be monotonic. We propose an ensemble of three techniques to achieve this goal:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Repartitioning modifies the original partition of</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Redecomposition changes the two-input decomposi-</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bufering adds buffer to large fan-out gates on the</head><p>The three operations are described next, and a description of their integration in the iterative process follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Repartitioning</head><p>Repartitioning takes place after a first mapping has been done, using the traditional partitioning technique outlined in Section 2.1. Repartitioning targets multiple-fan-out vertices that do not meet the timing constraints. The goal is to change partition-block boundaries, by merging subject graphs, to have other (and possibly more) choices when matching (and redecomposing) the vertices along the critical paths. Merging multiple-fan-out subject graphs multi-fan-out vertices. tion, taking into account delay information. critical paths. r means the merged portions have to be duplicated for the other fan-outs to achieve the original functionality.</p><p>Consider, for example, the subcircuit in Fig. <ref type="figure" target="#fig_22">11</ref>, where a gatej is a multiple-fan-out vertex on the critical path. The original arrival time aj at its output is ai = max (ai) + Sj + aj -Cj, where ai is the arrival time on the inputs, Sj is the intrinsic delay of gate j, aj is the fan-out-dependent delay factor, and C, is the fan-out. Assuming a/ is the latest arriving input, we can reexpress ai as ai = + a[ * C, + Sj + aj Cj. Assuming one ot the output fanouts is on the critical path, duplicating vertexj, with the new gate driving the critical path only, we get (Fig. <ref type="figure" target="#fig_24">12</ref>) This example shows some important properties for vertices with multiple fan-outs:</p><formula xml:id="formula_8">aj = SI + a[ * (C, + CO) + Sj + aj -C / k , andaj" = SI + a/ -(C, + CO) + Sj + aj (Cj -q k ) ,</formula><p>Duplicating gates per se reduces delay along the critical paths, when (aio -C,aj -C j k 5 0). This is usually the case, and it can be verified on a case-bycase basis. The fan-ins of the duplicated vertex are slowed down by the addition of one gate load (aik For a particular vertex that does not meet the timing constraints, it is therfore simple to verify how much can be gained by duplication, and whether or not the duplication affects other critical nets. In particular, if all the inputs of the vertex to duplicate have a single fan-out, then duplication is always a good solution. In addition, the duplicated vertex can now be merged forward into the next partition (it is now a single fan-out vertex). Mapping can be redone at this point on the modified partition, possibly improving delay even more.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CQ).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Redecomposition</head><p>Redecomposition is used both alone or in combination with repartitioning. The goal is to bring late-arriving signals of a partition closer to its output. Redecomposition has (like decomposition) two important side effects:</p><p>It influences the list of library elements that may</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It influences the critical path through the Boolean</head><p>The first point is related to the fact that different decom-cover a subject graph.   </p><formula xml:id="formula_9">f i = a + x 1 f 2 = x 2 + 2 2 X I = y1 + 2 1 x2 = a + y2 y1 = bF y2 = bi? = bc 22 = bc.</formula><p>-In particular, the decomposition fl allows the XOR x l = bZ + bc to be mapped, whereas in decompositionf2, the XOR gate cannot be found (because variable a appears as an input to the same gate as y 2 = bC). We address the first point by heuristically trying to keep repeated literals together during the decomposition. The second point is important because decomposition can be used to push latearriving signals closer or further from the output, possibly reducing or lengthening the critical path. This problem has been addressed by Singh [4 I] and Paulin <ref type="bibr" target="#b42">[42]</ref>. Redecomposition implies unmapping a portion of mapped network, changing its base function decomposition, and then remapping the modified block. It is a tentative process, in that mapping the redecomposed partition does not necessarily give better results. We therefore isolate subgraphs being redecomposed, and use the new decomposition only when it produces better results. The evaluation of the value of a redecomposed (and remapped) partition is fairly simple and involves two steps. First, since the subcircuit under consideration has a single output, we can just compare the arrival times of the original and redecomposed partition blocks. Second, we check if the input loads have increased, and, if so, if any other critical net was created.</p><p>The redecomposition algorithm we are using follows the same principle that Singh <ref type="bibr">[41]</ref> proposed. One significant difference is that we use BDD's instead of kernel extraction for the decomposition. After a subgraph r is isolated for redecomposition, its inputs are ordered in de- creasing order of their amval times. That input list then specifies the order in which the variables are processed during the BDD extraction. After the BDD is reduced, it is then retransfonned into a standard Boolean network, which is finally mapped. Procedure redecompose transforms a Boolean network into one where the latest aniving inputs are closer to the output (Fig. <ref type="figure" target="#fig_25">13</ref>).</p><p>For example, let us reconsider the Boolean network described in Section 2. Assume vertex vi does not meet its timing requirement, and that the amval times of the inputs to the partition blockrooted by viare {a, = 10.0, a, = 12.0, ad = 5.0, a, = 7.0). The variable ordering used for creating the BDD representing j would be {c, a, e , d ) . The resulting BDD is shown in Fig. <ref type="figure" target="#fig_27">14</ref>, together with the two-input gate decomposition derived from the BDD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Buffering/Repowering</head><p>Buffering and repowering are used as last resorts, when the two other methods failed. Repowering is used first, using gates with more drive capability for vertices with high fan-out that are on critical paths. After repowering, buffering is used to speed up nets with large fan-outs, when neither redecomposition nor repartitioning can be applied, or they would modify other critical nets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Iterative Mapping</head><p>The three techniques outlined above are integrated in an iterative procedure. After a first area-oriented mapping, arrival times and required times are computed for each gate in the network. The required times on the outputs are assumed to be given, and so are the arrival times on the inputs. The difference between amval time and required time, or slack, is computed for each gate. The gates that have negative slacks are then operated upon in reverse topological order, where primary output gates appear first, and primary input gates appear last.</p><p>Redecomposition and repartitioning are used iteratively until the constraints are satisfied (i.e., no negative slack) or no more improvement is possible. Since each step is accepted only if it speeds up the target gate without affecting negatively the slacks on surrounding gates, this process is guaranteed to complete in a finite number of V. IMPLEMENTATION AND RESULTS The algorithms presented in this paper have been implemented in a program called Ceres. Ceres consists of approximately 55 000 lines of C code, of which 30 000 lines were encapsulated as the SLIF Tools, and reused by other logic optimization programs within the Olympus synthesis system <ref type="bibr" target="#b43">[43]</ref>. Ceres can be used either interactively or in batch mode. It reads a structured, sequential logic description as its input in the SLIF format <ref type="bibr" target="#b39">[39]</ref>. The input format allows for hierarchy, combinational logic, sequential elements, and tristate buffers. Annotations can be attached to gates or signals, to specify additional information (capacitance, delay, power requirements, etc.). Various output formats are supported (such as LSI Logic's, Actel's ADL, Mentor's M, Berkeley's EQN), for compatibility with other synthesis tools. A Unix-shelllike interface handles interactive operations, with built-in the MCNC benchmarks, on a DECstation 5000. For area optimization, the technology mapper in mis2.2 was run with the default options (which allow matches across multi-fanout vertices2). For delay optimization, the technology mapper in mis2.2 was run using the m a pn 1 command, which indicates delay is to be chosen as the principal cost metric. Note that all benchmarks were first technology-decomposed in mis2.2, in order to have an identical starting point. The rationale for this style of comparison is to show the effectiveness of Boolean matching techniques compared to other matching techniques. Therefore, there was a need to establish an identical starting point. For all experiments, we used the LSI Logic lsi-lOK and Actel act1 libraries as target technologies.</p><p>Tables <ref type="table" target="#tab_3">I11</ref> and<ref type="table" target="#tab_4">IV</ref> show mapping results for area. These results reflect the use of Ceres and mis2.2 on unoptimized MCNC benchmarks. Ceres was run using various covering depths, which allow trade-offs between run times and quality of results. Table <ref type="table" target="#tab_3">I11</ref> represents circuits bound to the Actel library, which has a large number of elements alias, history, pipes, and help faciiities .</p><p>in uc Berkeley's mis2. 2. The two programs were run on 'Note that although using Boolean techniques does not preclude such matches, the current version of Ceres does not recognize them. Therefore, results could be further improved by incorporating that method.</p><p>We 'Ompared ceres to the mapper r - Tables V and VI also show mapping results for area, but taking don't-cure information into account. The results are shown both for circuits that were optimized before mapping and for circuits that were not optimized before mapping. For both the Actel and LSI Logic technologies, the results show that using don 't-cures during the technology-binding operation improves the quality of the results when operating on both optimized and unoptimized circuits. Circuits in the first category were optimized using UC Berkeley's mis2.2 with the standard script, which involves technology-independent operations. It is worth noticing that the results of operating on nonoptimized circuits using don 't-cure information some-times are better than the ones of optimized circuits mapped without using don't-cures. This indicates that the use of don 't-cure during the technology-mapping phase effectively does some limited logic synthesis, which is traditionally thought of as a technology-independent operation. Table <ref type="table">V</ref>, for which the Actel library was used, shows the use of don ?-cure information leads to area improvements of 9% and 8% on unoptimized and optimized circuits respectively. Table <ref type="table" target="#tab_6">VI</ref>, for which the LSI Logic library was used, shows area improvements of 8% and 6% in corresponding cases. Calculation of don 't-cure is computationally intensive, requiring large amounts of memory and CPU time. As a result, run times increase by a factor of 10 to 20 when using don 't-cure information. For some examples we use subsets of the full don't-cure set, to keep reasonable run times. In some cases, even the calculation of subsets of the don 't-cures involves a very large amount of memory, and the program runs out of space.</p><p>In tables V and VI, the top portion represents results using subsets of the don't-cure sets, and the bottom portion represents results using the full don 't-cure sets. Fig. <ref type="figure" target="#fig_16">15</ref> shows the arealdelay trade-off curve for different circuits. Note that all the points on these curves are obtained as successive results during the delay optimiza-     <ref type="table" target="#tab_7">VI1</ref> show that for the Actel library, the fastest implementations are 20% faster and 5 % smaller when using Ceres. Table <ref type="table" target="#tab_7">VI11</ref> shows results using the LSI Logic library, where the fastest implementations are 7 % faster and 24 % smaller when comparing Ceres to mis2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION</head><p>for technology mapping. Efficient ways of using Boolean techniques were described, among which was the extraction of symmetries as a means of reducing the number of computations during logid-equivalence recognition. Results have shown that for libraries containing many gates with repeated literals, Boolean methods are very efficient in terms of both execution time and quality of the results. For example, Ceres finds very good solutions for libraries of field-programmable gate arrays, which fall into that category.</p><p>This paper has presented an ensemble of new methods ~ 1 I The introduction of don 't-cures during the technologybinding phase allows for better logic simplification, since the cost metric can be more closely tied to the final realization of the circuit. It was shown that for both optimized and unoptimized circuits, the use of don 't-cure information leads to better results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE VI1 MAPPING RESULTS FOR DELAY (NO DON'T-CARES, ACTEL ACT1 LIBRARY). "RTIME" INDICATES THE RUN TIME IN SECONDS ON</head><p>Finally, iterative mapping was introduced as a way to improve delays that do not meet user-defined timing constraints. Various techniques are applied in sequence, which monotonically improves the critical paths. It is therefore possible to trade off between area and delay in the final implementation.</p><p>The use of don 't-cure sets during technology mapping opens new ways of conceiving logic synthesis, with less separation between technology-independent and technology-dependent transformations. Current results are positive, and indicate the usefulness of migrating traditionally technology-independent synthesis techniques into the technology-dependent domain. However, it is important to remark that the technology-mapping techniques shown here are not a substitute for technology-independent logic synthesis. Moreover, the techniques presented can be further extended by considering observability don 't cure sets and by relying on a sparse compatibility graph to detect logic equivalence of functions of more than 4 inputs in the presence of don 't-cures.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Manuscript received August 15, 1991; revised July 2, 1992. This work was supported in part by the National Science Foundation under Grant MIP-8719546; by DEC, AT&amp;T, and NSF under a PYI award; by ARPA under Grant J-FBI-88-101; by the Natural Sciences and Engineering Council of Canada; and by the Quebec Fonds F.C.A.R. This paper was recommended by Associate Editor R. K. Brayton. F. Mailhot is with Synopsys, Mountain View, CA 94043. This work was performed when the author was at Stanford University. G . De Micheli is with the Center for Integrated Systems, Stanford University, Stanford, CA 94305. IEEE Log Number 9209622.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>path to vi) and number of inputs. The associated clusterfunction is the Boolean function obtained by collapsing [ 11 the Boolean expressions associated with the vertices into a single Boolean function. We denote all possible clusters rooted at vertex vj of rf and their functions by { K ~, ~, * * * , K ~, ~] .As an example, consider the Boolean network (after an AND/OR decomposition)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Graph of all possible covers of j.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Algorithm for network covering.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>We denote the cluster function by 5 (</head><label>5</label><figDesc>xI, -* -, x, &gt;-I t has n inputs and one output. We denote the polarity of variable xi by 4i E {O,l}, where xfl = x, for 4i = 1, x t = Zi for cPi = 0. We denote the don 't-care set of the clusterfunction by DC?(xl, --, xn), We denote the library by C: {SI, * * * , S,}. Its elements 6 are multiple-input single-output functions. We define the matching problem as follows: * , x,), its don't-care set DC?(x,, * -, xn), and a library element S( yl, * --, y"), find an ordering { i , * * -, j } and a polarity {41, . . . , &amp;}, of the input variables of 5, such that either equation (1) or (2) is true: Given a clusterfunction S(xl, w?, --* 9 $9 = S(Y1, --S(xf, * * , x?) = S(y1, -* 9 Y")</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>(</head><label></label><figDesc>x f , --* , x,") # De; i.e., equation (1) or (2) holds for all minterms in the care set.If no such ordering and polarity exist, then the element S does not match the clusterfunction 5 . Furthermore, if no element in the library C: {S1, , 13, ) matches 5, then 5 cannot be covered by the library d: . Note that when the library contains the base function, then any vertex v of the Boolean network has always at least one associated clusterfunction that is covered by a library element: the base function into which v is initially decomposed. Let us define the NPN-equivalent set of a function 5 as the set of all the functions obtained by input-variable negation, input-variable permutation, and function negation [15]; we say that a function 5 matches a library element 6 when there exists an NPN-equivalent function that is tautological to 6 modulo the don 't-care set. For example, any function 5 ( a , b ) in the set {a + b, 5 + b , a + b, Zi + 6, ab, iib, a6, &amp; } can be covered by the library element S(x,, x2) = x1 + x2. Note that in this example, S(xl, x2) has n = 2 inputs, and can match n! -2" = 8 functions [ 113.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>I</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Simple algorithm for Boolean matching.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Given a clusterfunction 5 (</head><label>5</label><figDesc>xl, -* -, x,) and a library element 6 ( y I , -* * , y,), find an ordering { i , --, j } and a polarity {&amp;, * * * , of the binate variables {k, . . . , l } of 5 , such that either (3) or (4) is true: T(S(x,, * --, x p , * * * , x f ' , * * * , x , ) ) = T(S(YI9 * * 9 Y,))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>In particular, it implies that if the cluster function has b binate variables, then only b! -(nb)! permutations of the input variables are needed. Therefore, the worst-case computational cost of matching a cluster function with b binate variables is b! * (nb)! T(?F(x,, * , xP, ---, xf", * -9 x,))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>[ 181. Techniques based on using symmetry considerations to speed up algebraic matching were also presented by Morrison in [ l l], in a different context. Reeves also used partial logic symmetry, as a filter during verification [19]. His technique uses BDD's to extract the Chow parameters [20], which can be used to express partial logic symmetry. Dejnition: Logic symmetry is represented by the bi-5, where Sas = {{x,, x,} 1 5(xl</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>3 +</head><label>3</label><figDesc>5 belong to the same symmetry set if S a i s (x,, x, ) holds. Let us consider for example function 5 = x1 ~2 x x4x5 + x6x7. The input variables of 5 can be partitioned into three disjoint sets of symmetric variables: {xl , x2, x3}, {x4, x 5 } , and {x6, x7). Symmetry sets are further grouped into symmetry classes. A symmetry class C,, i E ( 1 , 2, * * * }, is an ensemble of symmetry sets with the same cardinality i and S, = I C,l is the cardinality of a symmetry class C,. In the previous example, there are two symmetry classes: Cz = S3 = 1. Note that all the other symmetry classes are empty, and therefore V i + 2, Si = 0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Function 5 2 ,</head><label>52</label><figDesc>has one non-empty symmetry class, C2(5), which contains three symmetry sets, We associate a name, 71,, with each of the symmetry sets: C&amp;3) = { { y l , y2), {y3, y 4 ) , {y5, y6}} = {vl, 712, 731; i.e., we represent the pair of symmetric variables { y l , y2} by ql, the pair { y 3 , y4) by { {x49 x5} , {x6, x-1)) and c 3 = x2, x3}, with S2 = The symmetry property of the completely specified functions is an equivalence relation (it is reflexive, symmetric, and transitive) [21], hence if {xi, xi} and {xi, xk} are two symmetry sets, then {xj, xk} is also a symmetry set. Being an equivalence relation, the symmetry property q2, etc. Similarly, function 6 has only one non-empty symmetry class, C2, with cardinality S2 = 3. We associate a name, t, with the symmetry sets of S: C 2 ( 9 = { ( i l , i 2 } , (i3, i4}, {is, i6)) = {El, t ~, t 3 } . We then use the labels 71 and t to represent the different permutations of symmetry sets. The cardinality of the symmetry class C2 is S, = 3, and therefore there are S2! = 6 possible assignments of symmetry sets of 3 and s:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Only the last assignment, where the variables of 5 and B i d } } , { { y s , y6}, { i l , i 2 } } , make functions 3 and S logically equivalent. The third use of symmetry classes is during the Boolean comparison itself. Boolean comparisons are based on iterative Shannon cofactoring. Without symmetry considerations, for an n-input function 3, up to 2" cofactors are needed. But since variables of a symmetry set are freely interchangeable, not all 2" cofactors are different. For example, given F = abc, where { a , b , c } are symmetrical, then the cofactor of { a = 0, b = 1, c = 0} is equivalent to the cofactor of { a = 1, b = 0, c = O}. In general, for a symmetry set containing m variables, only m + 1 cofactors are different (corresponding to 0, l , --, m variables set to 1). Assuming the n variables of 3 are grouped into k symmetry sets of size n,, -* * , nk (where n, = n), then the number of needed cofactors is IIf=o (n, +</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Distribution of symmetry classes C,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5 . Algorithm for fast Boolean matching.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Mapping the majority MCNC benchmark with LSI Logic library elements. (a) Mapping without DC. (b) Mapping with DC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>) = d 3 .</head><label>3</label><figDesc>The transformation 3 is applied to the don't-care set De, to generate a new expression, 3(DC!), consistent with the representative function OF of v3. There exists a match to the library cell 9 if there is a path in the graph C(V, E) from v3 to (possibly of zero length) whose edges are included in the image 3(DC!) of the don 't-care set De of 5. It is necessary that don 't care sets are transformed by the operator 3 before the path inclusion is checked, because paths in the compatibility graph are computed between representative functions 8;.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>unmapped. . c .#------S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Example of a partially mapped network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>where uj new arrival time for the critical path, aj" new arrival time for the other fan-outs of j , C, input capacitance o f j at input 1, C,, input capacitance of gate k, which is the gate corresponding to the fan-out of j on the critical path. Then, the difference in delay is Auj = a, !uj = CY[ C, + aj -(c,k -Cj), and Auj" = aj"aj = CY[ * CGaj * C j k . The arrival time of the fan-in vertices of vj are also modified by the duplication process. The difference in delay is h i = a; -a/ = aI -C,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Delays in a subcircuit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>.</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Delays in a subcircuit after gate duplication.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Algorithm for BDD-to-Boolean-network conversion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>3 :</head><label>3</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. BDD and corresponding Boolean network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>20 -Fig. 15 .</head><label>2015</label><figDesc>Fig. 15. Example of area/delay tradeoffs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I NUMBER</head><label>I</label><figDesc>OF k-INPUT CELLS INCLUDED IN THE FULL ACT1 AND THE LOGIC LIBRARIES</figDesc><table><row><cell></cell><cell></cell><cell cols="2">Number of</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">Cells in the</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>Library</cell><cell></cell><cell cols="2">Percentage of Total</cell></row><row><cell></cell><cell>Number of Inputs</cell><cell>actl</cell><cell>LSI</cell><cell>actl</cell><cell>LSI</cell></row><row><cell></cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>0.1%</cell><cell>2.5%</cell></row><row><cell></cell><cell>2</cell><cell>8</cell><cell>12</cell><cell>1.1%</cell><cell>14.8%</cell></row><row><cell></cell><cell>3</cell><cell>47</cell><cell>22</cell><cell>6.7%</cell><cell>27.2%</cell></row><row><cell></cell><cell>4</cell><cell>210</cell><cell>20</cell><cell>30 .O %</cell><cell>24.7%</cell></row><row><cell></cell><cell>5</cell><cell>285</cell><cell>6</cell><cell>40.7%</cell><cell>7.4%</cell></row><row><cell></cell><cell>6</cell><cell>128</cell><cell>8</cell><cell>18.3%</cell><cell>9.9%</cell></row><row><cell></cell><cell>7</cell><cell>21</cell><cell>0</cell><cell>3.0%</cell><cell>0.0%</cell></row><row><cell>Fig. 7. Matching compatibility graph for 3-variable Boolean space. Note</cell><cell>8</cell><cell>1</cell><cell>9</cell><cell>0.1%</cell><cell>11.1%</cell></row><row><cell>that no path exists between vertex 4 and vertices 8, 11, and 13.</cell><cell>11</cell><cell>0</cell><cell>2</cell><cell>0.0%</cell><cell>2.5%</cell></row></table><note><p>with the given function and a don't-cure set. Note that the size Of the</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 11 FULL</head><label>11</label><figDesc>ACT^ AND THE LSI LWIC LIBRARIES. A DEPTH OF 5 WAS USED</figDesc><table><row><cell>graph is</cell><cell>for functions Of</cell><cell cols="5">NUMBER OF k-INPUT CELLS USED IN MAPPING 30 BENCHMARKS WITH THE</cell></row><row><cell cols="2">and 4 variables, where there are 14 and 222 different NPN-</cell><cell></cell><cell cols="2">DURING COVERING</cell><cell></cell></row><row><cell cols="2">equivalent functions respectively [ 151, representing the 256 and 65 536 possible functions of 3 and 4 variables. Unfortunately, for functions of more than 4 variables, the</cell><cell></cell><cell cols="2">Number of Cells Used</cell><cell cols="2">Percentage of Total</cell></row><row><cell cols="3">number of NPN-equivalent functions grows very quickly Number of Inputs</cell><cell>act 1</cell><cell>LSI</cell><cell>actl</cell><cell>LSI</cell></row><row><cell cols="2">(functions of 5 and 6 variables have 616 126 and = 2 x lOI4 respectively [20]), although it is very sparse in terms of the vertices corresponding to library elements. At pres-</cell><cell>1 2 3</cell><cell>305 3176 2998</cell><cell>21 10 6816 2705</cell><cell>2.9% 30.7% 29.0%</cell><cell>12.9% 41.8% 16.6%</cell></row><row><cell cols="2">ent, we have implemented techniques for technology mapping using don 't-cure conditions for cluster functions</cell><cell>4 5 6</cell><cell>3685 182 0</cell><cell>4583 103 3</cell><cell>35.6% 1.8% 0.0%</cell><cell>28.1% 0.6% 0.0%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE I11 MAPPING</head><label>I11</label><figDesc>RESULTS FOR AREA (ACTEL ACT1 LIBRARY). "RTIME" INDICATES THE RUN TIME IN SECONDS ON A DECSTATION 5000</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Ceres</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>MIS2.2</cell><cell>Depth 3</cell><cell></cell><cell>Depth 4</cell><cell></cell><cell>Depth 5</cell><cell></cell></row><row><cell>Circuit</cell><cell>cost</cell><cell>rtime</cell><cell>cost</cell><cell>rtime</cell><cell>cost</cell><cell>rtime</cell><cell>cost</cell><cell>rtime</cell></row><row><cell>C6288 k2</cell><cell>1649 1308</cell><cell>139.0 4408.0</cell><cell>1425 1209</cell><cell>85.6 131.9</cell><cell>1425 1209</cell><cell>86.5 170.5</cell><cell>1425 1209</cell><cell>87.1 253.3</cell></row><row><cell>C7552</cell><cell>1250</cell><cell>501.3</cell><cell>1117</cell><cell>97.4</cell><cell>1100</cell><cell>123.6</cell><cell>1062</cell><cell>178.3</cell></row><row><cell>C5315</cell><cell>957</cell><cell>264.8</cell><cell>899</cell><cell>79.2</cell><cell>887</cell><cell>107.2</cell><cell>83 1</cell><cell>151.2</cell></row><row><cell>frg2</cell><cell>94 1</cell><cell>869.3</cell><cell>1049</cell><cell>103.9</cell><cell>1045</cell><cell>141.6</cell><cell>844</cell><cell>193.1</cell></row><row><cell>pair</cell><cell>823</cell><cell>179.9</cell><cell>872</cell><cell>69.2</cell><cell>813</cell><cell>90.3</cell><cell>716</cell><cell>120.7</cell></row><row><cell>xl</cell><cell>76 1</cell><cell>630.1</cell><cell>827</cell><cell>95.4</cell><cell>825</cell><cell>150.6</cell><cell>807</cell><cell>328.5</cell></row><row><cell>C3540</cell><cell>658</cell><cell>295.0</cell><cell>641</cell><cell>45.3</cell><cell>628</cell><cell>62.0</cell><cell>608</cell><cell>101.9</cell></row><row><cell>vda</cell><cell>65 1</cell><cell>3103.5</cell><cell>543</cell><cell>46.1</cell><cell>543</cell><cell>61.4</cell><cell>543</cell><cell>91.7</cell></row><row><cell>x3</cell><cell>637</cell><cell>288.1</cell><cell>639</cell><cell>54.8</cell><cell>620</cell><cell>74.9</cell><cell>527</cell><cell>108.1</cell></row><row><cell>rot</cell><cell>570</cell><cell>254.7</cell><cell>583</cell><cell>48.4</cell><cell>582</cell><cell>73.8</cell><cell>55 1</cell><cell>137.5</cell></row><row><cell>a h 4</cell><cell>52 1</cell><cell>1702.5</cell><cell>56 1</cell><cell>44.9</cell><cell>559</cell><cell>72.0</cell><cell>550</cell><cell>147.7</cell></row><row><cell>C2670</cell><cell>43 1</cell><cell>177.3</cell><cell>379</cell><cell>28.4</cell><cell>359</cell><cell>39.0</cell><cell>317</cell><cell>64.4</cell></row><row><cell>apex6</cell><cell>378</cell><cell>65.2</cell><cell>399</cell><cell>23.2</cell><cell>400</cell><cell>30.5</cell><cell>399</cell><cell>45.6</cell></row><row><cell>C1355</cell><cell>37 1</cell><cell>53.2</cell><cell>176</cell><cell>12.5</cell><cell>178</cell><cell>15.1</cell><cell>178</cell><cell>22.2</cell></row><row><cell>term 1</cell><cell>360</cell><cell>368.0</cell><cell>380</cell><cell>29.3</cell><cell>365</cell><cell>44.6</cell><cell>302</cell><cell>72.0</cell></row><row><cell>x4</cell><cell>346</cell><cell>160.9</cell><cell>433</cell><cell>32.5</cell><cell>428</cell><cell>49.0</cell><cell>368</cell><cell>79.5</cell></row><row><cell>alu2</cell><cell>297</cell><cell>623.8</cell><cell>325</cell><cell>24.3</cell><cell>329</cell><cell>41.2</cell><cell>320</cell><cell>90.1</cell></row><row><cell>frg 1</cell><cell>286</cell><cell>83.9</cell><cell>277</cell><cell>30.1</cell><cell>277</cell><cell>51.6</cell><cell>27 1</cell><cell>120.6</cell></row><row><cell>C1908</cell><cell>283</cell><cell>87.2</cell><cell>266</cell><cell>15.9</cell><cell>265</cell><cell>21.5</cell><cell>263</cell><cell>34.0</cell></row><row><cell>ttt2</cell><cell>217</cell><cell>167.9</cell><cell>283</cell><cell>23.4</cell><cell>283</cell><cell>37.5</cell><cell>249</cell><cell>69.0</cell></row><row><cell>C880</cell><cell>193</cell><cell>47.0</cell><cell>191</cell><cell>11.0</cell><cell>182</cell><cell>14.9</cell><cell>178</cell><cell>23.0</cell></row><row><cell>c499</cell><cell>178</cell><cell>51.8</cell><cell>176</cell><cell>9.9</cell><cell>176</cell><cell>14.1</cell><cell>168</cell><cell>21.1</cell></row><row><cell>example2</cell><cell>175</cell><cell>50.8</cell><cell>179</cell><cell>11.1</cell><cell>179</cell><cell>14.5</cell><cell>175</cell><cell>21.5</cell></row><row><cell>apex7</cell><cell>147</cell><cell>44.6</cell><cell>149</cell><cell>9.8</cell><cell>150</cell><cell>13.3</cell><cell>142</cell><cell>19.3</cell></row><row><cell>m y-adder</cell><cell>128</cell><cell>38.6</cell><cell>112</cell><cell>8.8</cell><cell>96</cell><cell>11.8</cell><cell>64</cell><cell>14.4</cell></row><row><cell>C432</cell><cell>125</cell><cell>35.9</cell><cell>93</cell><cell>7.5</cell><cell>93</cell><cell>10.4</cell><cell>93</cell><cell>17.2</cell></row><row><cell>f5 Im</cell><cell>124</cell><cell>120.0</cell><cell>132</cell><cell>12.2</cell><cell>131</cell><cell>21.2</cell><cell>129</cell><cell>44.7</cell></row><row><cell>z4ml</cell><cell>106</cell><cell>96.8</cell><cell>113</cell><cell>10.2</cell><cell>113</cell><cell>17.4</cell><cell>91</cell><cell>33.7</cell></row><row><cell>c8</cell><cell>103</cell><cell>45.9</cell><cell>143</cell><cell>11.1</cell><cell>136</cell><cell>15.9</cell><cell>116</cell><cell>22.7</cell></row><row><cell>Total</cell><cell>14 974 100%</cell><cell>14 955.0 1 .o</cell><cell>14 571 97.3%</cell><cell>1213.4 0.08</cell><cell>14 376 96.0%</cell><cell>1677.9 0.11</cell><cell>13 496 90.1%</cell><cell>2715.1 0.18</cell></row><row><cell cols="4">steps. If this process fails in meeting the constraints, the</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">gates with negative slacks are first repowered, and if nec-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>essary buffered.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE IV MAPPING</head><label>IV</label><figDesc>RESULTS FOR AREA (NO DON'T-CARES, LsI LOGIC ISI-IOK LIBRARY). "RTIME" INDICATES THE RUN TIME I N SECONDSON A DECSTATION 5000</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Ceres</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>MlS2.2</cell><cell></cell><cell>Depth 3</cell><cell></cell><cell>Depth 4</cell><cell></cell><cell>Depth 5</cell><cell></cell></row><row><cell>Circuit</cell><cell>cost</cell><cell>rtime</cell><cell>cost</cell><cell>rtime</cell><cell>cost</cell><cell>rtime</cell><cell>cost</cell><cell>rtime</cell></row><row><cell>C6288</cell><cell>2429</cell><cell>73.7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>k2</cell><cell>2182</cell><cell>149.0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>C7552</cell><cell>2699</cell><cell>127.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>(25315</cell><cell>1959</cell><cell>86.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>frg2</cell><cell>2045</cell><cell>122.7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>pair</cell><cell>1505</cell><cell>68.7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>xl</cell><cell>1410</cell><cell>103.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>C3540</cell><cell>1192</cell><cell>67.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>vda</cell><cell>1039</cell><cell>71.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>x3</cell><cell>1285</cell><cell>68.0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>TO1</cell><cell>1108</cell><cell>70.7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>a h 4</cell><cell>1009</cell><cell>78.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>C2670</cell><cell>862</cell><cell>45.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>apex6</cell><cell>7 14</cell><cell>33.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>C 1355</cell><cell>56 1</cell><cell>27.9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>term 1</cell><cell>72 1</cell><cell>44.9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>x4</cell><cell>690</cell><cell>43.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>alu2</cell><cell>565</cell><cell>44.3</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>frg 1</cell><cell>579</cell><cell>45.3</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>C1908</cell><cell>592</cell><cell>39.4</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ttt2</cell><cell>429</cell><cell>33.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>C880</cell><cell>342</cell><cell>22.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>c499</cell><cell>42 1</cell><cell>24.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>example2</cell><cell>354</cell><cell>23.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>apex7</cell><cell>283</cell><cell>20.0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>my-adder</cell><cell>242</cell><cell>17.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>C432</cell><cell>22 1</cell><cell>17.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>f51m</cell><cell>234</cell><cell>21.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>c8</cell><cell>237</cell><cell>19.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>cht</cell><cell>211</cell><cell>16.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Total</cell><cell>28 120 100%</cell><cell>1628.5 1 .o</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">with repeated literals. In this case, results show that using</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">Boolean operations for matching leads to both better im-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">plementation and faster run times when comparing to pat-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">tern matching based comparisons: results range from 3%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">better area for more than 12-times-faster run times, to 10%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">better area for 4-times-faster run times. Table IV shows</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">results using the LSI Logic 10K library. This table shows</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">again how Ceres can trade off quality of the results for run</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">time. In particular, results comparable to those of mis2.2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">are obtained with 30% faster run times, or 4% better re-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">sults at a cost of a doubling in run time.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE V DECSTATION 5000</head><label>V5000</label><figDesc>MAPPING RESULTS FOR AREA (USING DON'T-CARES, ACTEL ACT1 LIBRARY). "RTIME" INDICATES THE RUN TIME IN SECONDS ON A</figDesc><table><row><cell></cell><cell></cell><cell cols="2">Original circuits</cell><cell></cell><cell></cell><cell cols="2">Optimized circuits</cell><cell></cell></row><row><cell></cell><cell></cell><cell>No DC</cell><cell></cell><cell>With DC</cell><cell>No DC</cell><cell></cell><cell cols="2">With DC</cell></row><row><cell>Circuit</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell></row><row><cell>frg2</cell><cell>844</cell><cell>194.7</cell><cell>774</cell><cell>2960.7</cell><cell>369</cell><cell>33.4</cell><cell>361</cell><cell>463.3</cell></row><row><cell>xl</cell><cell>807</cell><cell>327.5</cell><cell>761</cell><cell>2979.2</cell><cell>172</cell><cell>35.3</cell><cell>166</cell><cell>171.9</cell></row><row><cell>alu4</cell><cell>550</cell><cell>147.5</cell><cell>443</cell><cell>1356.9</cell><cell>457</cell><cell>111.3</cell><cell>410</cell><cell>1151.3</cell></row><row><cell>apex6</cell><cell>399</cell><cell>45.9</cell><cell>387</cell><cell>431.8</cell><cell>45 1</cell><cell>77.0</cell><cell>420</cell><cell>682.2</cell></row><row><cell>i6</cell><cell>348</cell><cell>25.0</cell><cell>346</cell><cell>607.7</cell><cell>150</cell><cell>18.0</cell><cell>150</cell><cell>199.8</cell></row><row><cell>C1908</cell><cell>263</cell><cell>34.1</cell><cell>248</cell><cell>7687.3</cell><cell>195</cell><cell>26.2</cell><cell>193</cell><cell>7279.5</cell></row><row><cell>x4</cell><cell>368</cell><cell>79.4</cell><cell>329</cell><cell>517.4</cell><cell>182</cell><cell>13.9</cell><cell>179</cell><cell>140.1</cell></row><row><cell>terml</cell><cell>302</cell><cell>73.2</cell><cell>237</cell><cell>721.0</cell><cell>104</cell><cell>27.2</cell><cell>102</cell><cell>146.7</cell></row><row><cell>frg 1</cell><cell>27 1</cell><cell>120.0</cell><cell>249</cell><cell>715.2</cell><cell>106</cell><cell>37.4</cell><cell>106</cell><cell>181.2</cell></row><row><cell>x3</cell><cell>527</cell><cell>108.5</cell><cell>549</cell><cell>1388.4</cell><cell>426</cell><cell>64.7</cell><cell>409</cell><cell>587.6</cell></row><row><cell>Vda</cell><cell>543</cell><cell>92.5</cell><cell>542</cell><cell>1250.6</cell><cell>278</cell><cell>27.0</cell><cell>266</cell><cell>326.7</cell></row><row><cell>xl</cell><cell>807</cell><cell>327.5</cell><cell>761</cell><cell>2938.9</cell><cell>172</cell><cell>35.1</cell><cell>166</cell><cell>172.2</cell></row><row><cell>C1355</cell><cell>176</cell><cell>12.5</cell><cell>170</cell><cell>4040.4</cell><cell>172</cell><cell>9.4</cell><cell>170</cell><cell>3650.3</cell></row><row><cell>c499</cell><cell>168</cell><cell>20.6</cell><cell>170</cell><cell>3321.8</cell><cell>172</cell><cell>19.8</cell><cell>170</cell><cell>3157.1</cell></row><row><cell>C432</cell><cell>93</cell><cell>18.1</cell><cell>92</cell><cell>305.7</cell><cell>390</cell><cell>135.0</cell><cell>232</cell><cell>1481.1</cell></row><row><cell>f51m</cell><cell>128</cell><cell>47.5</cell><cell>121</cell><cell>146.9</cell><cell>71</cell><cell>21.5</cell><cell>72</cell><cell>110.8</cell></row><row><cell>alu2</cell><cell>320</cell><cell>90.1</cell><cell>254</cell><cell>369.2</cell><cell>253</cell><cell>65.0</cell><cell>212</cell><cell>303.7</cell></row><row><cell>ttt2</cell><cell>249</cell><cell>70.9</cell><cell>147</cell><cell>262.2</cell><cell>92</cell><cell>14.3</cell><cell>89</cell><cell>74.3</cell></row><row><cell>i5</cell><cell>178</cell><cell>18.7</cell><cell>178</cell><cell>67.8</cell><cell>66</cell><cell>4.1</cell><cell>66</cell><cell>9.2</cell></row><row><cell>example2</cell><cell>175</cell><cell>22.0</cell><cell>150</cell><cell>92.5</cell><cell>160</cell><cell>17.9</cell><cell>149</cell><cell>105.9</cell></row><row><cell>c8</cell><cell>116</cell><cell>10.8</cell><cell>74</cell><cell>92.5</cell><cell>66</cell><cell>5.6</cell><cell>54</cell><cell>57.2</cell></row><row><cell>apex7</cell><cell>142</cell><cell>19.4</cell><cell>122</cell><cell>105.6</cell><cell>129</cell><cell>18.9</cell><cell>102</cell><cell>166.9</cell></row><row><cell>cht</cell><cell>124</cell><cell>22.2</cell><cell>111</cell><cell>116.5</cell><cell>84</cell><cell>5.0</cell><cell>84</cell><cell>32.9</cell></row><row><cell>9symml</cell><cell>94</cell><cell>33.2</cell><cell>94</cell><cell>114.8</cell><cell>101</cell><cell>36.8</cell><cell>103</cell><cell>116.4</cell></row><row><cell>z4ml</cell><cell>91</cell><cell>34.6</cell><cell>35</cell><cell>119.5</cell><cell>33</cell><cell>8.5</cell><cell>25</cell><cell>34.5</cell></row><row><cell>SCt</cell><cell>83</cell><cell>17.2</cell><cell>80</cell><cell>53.3</cell><cell>35</cell><cell>6.1</cell><cell>33</cell><cell>65.2</cell></row><row><cell>la1</cell><cell>77</cell><cell>12.7</cell><cell>75</cell><cell>35.3</cell><cell>39</cell><cell>5.9</cell><cell>37</cell><cell>50.8</cell></row><row><cell>Total</cell><cell>8243 1 .o</cell><cell>2026.3 1 .o</cell><cell>7499 0.91</cell><cell>32 799.1 16.2</cell><cell>4925 0.60 1 .o</cell><cell>880.3 0.43 1 .o</cell><cell>4526 0.55 0.92</cell><cell>20 919.1 10.3 23.8</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE VI MAPPING</head><label>VI</label><figDesc>RESULTS FOR AREA (USING DON'T-CARES, LSI Locrc lsr-lOK LIBRARY). "RTIME" INDICATES THE RUN TIME IN SECONDS ON A DECSTATION 5000</figDesc><table><row><cell></cell><cell></cell><cell cols="2">Original circuits</cell><cell></cell><cell></cell><cell cols="2">Optimized circuits</cell><cell></cell></row><row><cell></cell><cell>No DC</cell><cell></cell><cell>With DC</cell><cell></cell><cell>No DC</cell><cell></cell><cell cols="2">With DC</cell></row><row><cell>Circuit</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell></row><row><cell>frg2</cell><cell>1754</cell><cell>229.4</cell><cell>1525</cell><cell>2928.9</cell><cell>594</cell><cell>40.9</cell><cell>578</cell><cell>408.2</cell></row><row><cell>XI</cell><cell>1695</cell><cell>382.2</cell><cell>1560</cell><cell>2939.7</cell><cell>327</cell><cell>43.8</cell><cell>317</cell><cell>169.2</cell></row><row><cell>alu4</cell><cell>999</cell><cell>174.3</cell><cell>894</cell><cell>1302.2</cell><cell>836</cell><cell>130.8</cell><cell>785</cell><cell>1060.7</cell></row><row><cell>apex6</cell><cell>680</cell><cell>52.2</cell><cell>679</cell><cell>335.8</cell><cell>803</cell><cell>93.0</cell><cell>799</cell><cell>646.3</cell></row><row><cell>i6</cell><cell>58 1</cell><cell>62.3</cell><cell>579</cell><cell>400.0</cell><cell>318</cell><cell>24.8</cell><cell>318</cell><cell>213.7</cell></row><row><cell>Cl908</cell><cell>596</cell><cell>40.7</cell><cell>588</cell><cell>7701.7</cell><cell>462</cell><cell>32.6</cell><cell>464</cell><cell>7322.0</cell></row><row><cell>x4</cell><cell>670</cell><cell>88.7</cell><cell>595</cell><cell>481.9</cell><cell>317</cell><cell>18.7</cell><cell>313</cell><cell>125.7</cell></row><row><cell>terml</cell><cell>598</cell><cell>81.7</cell><cell>450</cell><cell>651.3</cell><cell>219</cell><cell>34.0</cell><cell>217</cell><cell>138.6</cell></row><row><cell>frg 1</cell><cell>583</cell><cell>144.1</cell><cell>506</cell><cell>705.4</cell><cell>227</cell><cell>46.6</cell><cell>226</cell><cell>182.3</cell></row><row><cell>x3</cell><cell>1125</cell><cell>115.7</cell><cell>1117</cell><cell>1265.6</cell><cell>750</cell><cell>75.3</cell><cell>720</cell><cell>526.2</cell></row><row><cell>vda</cell><cell>1078</cell><cell>113.4</cell><cell>1077</cell><cell>1046.6</cell><cell>520</cell><cell>33.7</cell><cell>51 1</cell><cell>265.1</cell></row><row><cell>XI</cell><cell>1695</cell><cell>382.2</cell><cell>1560</cell><cell>2942.0</cell><cell>327</cell><cell>43.5</cell><cell>317</cell><cell>169.2</cell></row><row><cell>C1355</cell><cell>404</cell><cell>24.4</cell><cell>403</cell><cell>4025.9</cell><cell>410</cell><cell>23.4</cell><cell>410</cell><cell>3624.7</cell></row><row><cell>c499</cell><cell>406</cell><cell>23.3</cell><cell>425</cell><cell>3068.1</cell><cell>410</cell><cell>23.3</cell><cell>41 1</cell><cell>3123.2</cell></row><row><cell>C432</cell><cell>202</cell><cell>22.1</cell><cell>166</cell><cell>267.8</cell><cell>779</cell><cell>153.1</cell><cell>437</cell><cell>1381.6</cell></row><row><cell>f51m</cell><cell>244</cell><cell>52.9</cell><cell>24 1</cell><cell>172.3</cell><cell>146</cell><cell>28.1</cell><cell>147</cell><cell>100. 1</cell></row><row><cell>alu2</cell><cell>570</cell><cell>102.6</cell><cell>43 1</cell><cell>328.1</cell><cell>470</cell><cell>75.7</cell><cell>425</cell><cell>264.2</cell></row><row><cell>ttt2</cell><cell>453</cell><cell>73.7</cell><cell>302</cell><cell>188.1</cell><cell>193</cell><cell>18.5</cell><cell>186</cell><cell>63.8</cell></row><row><cell>i5</cell><cell>356</cell><cell>23.5</cell><cell>356</cell><cell>67.4</cell><cell>198</cell><cell>7.3</cell><cell>198</cell><cell>12.0</cell></row><row><cell>c8</cell><cell>249</cell><cell>27.2</cell><cell>182</cell><cell>77.9</cell><cell>128</cell><cell>14.0</cell><cell>123</cell><cell>59.5</cell></row><row><cell>apex7</cell><cell>269</cell><cell>23.4</cell><cell>244</cell><cell>192.2</cell><cell>265</cell><cell>23.2</cell><cell>227</cell><cell>139.7</cell></row><row><cell>cht</cell><cell>23 1</cell><cell>26.6</cell><cell>200</cell><cell>83.7</cell><cell>127</cell><cell>7.9</cell><cell>127</cell><cell>22.8</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE VI (Continued)</head><label>VI</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="2">Original circuits</cell><cell></cell><cell></cell><cell cols="2">Optimized circuits</cell><cell></cell></row><row><cell></cell><cell>No DC</cell><cell></cell><cell></cell><cell>With DC</cell><cell></cell><cell>No DC</cell><cell></cell><cell>With DC</cell></row><row><cell>Circuit</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell><cell>area</cell><cell>rtime</cell></row><row><cell>9symml</cell><cell>214</cell><cell>37.6</cell><cell>215</cell><cell>100.3</cell><cell>216</cell><cell>43.5</cell><cell>216</cell><cell>116.5</cell></row><row><cell>z4ml</cell><cell>181</cell><cell>42.7</cell><cell>180</cell><cell>127.6</cell><cell>68</cell><cell>12.3</cell><cell>65</cell><cell>39.6</cell></row><row><cell>SCt</cell><cell>144</cell><cell>20.3</cell><cell>142</cell><cell>47.0</cell><cell>86</cell><cell>9.6</cell><cell>83</cell><cell>61.4</cell></row><row><cell>la1</cell><cell>156</cell><cell>16.2</cell><cell>157</cell><cell>36.9</cell><cell>94</cell><cell>9 . 6</cell><cell>96</cell><cell>48.8</cell></row><row><cell>Total</cell><cell>16 133 1 .o</cell><cell>2383.4 1 .o</cell><cell>14 774 0.92</cell><cell>31 484.4 13.2</cell><cell>9290 0.58 1 .o</cell><cell>1067.2 0.45 1 .o</cell><cell>8716 0.54 0.94</cell><cell>20 285.1 8.5 19.0</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Area VS Delay</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>TABLE VI11 MAPPING RESULTS FOR DELAY (No DON'T-CARES, LSI LOGIC LSI-IOK LIBRARY). "RTIME" INDICATES THE RUN TIME IN SECONDS ON A DECSTATION 5000</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>A</cell></row><row><cell></cell><cell></cell><cell></cell><cell>MIS2.2</cell><cell></cell><cell></cell><cell cols="3">DECSTATION 5000</cell><cell></cell><cell>Ceres</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">MIS2.2</cell><cell></cell><cell cols="3">Smallest</cell><cell></cell><cell>Ceres</cell><cell>Fastest</cell></row><row><cell cols="2">Circuit</cell><cell>delay</cell><cell>area</cell><cell></cell><cell>rtime</cell><cell>delay</cell><cell cols="2">Smallest area</cell><cell></cell><cell>delay</cell><cell cols="2">Fastest area</cell><cell>rtime</cell></row><row><cell>alu2</cell><cell>Circuit</cell><cell>delay 27.5</cell><cell cols="2">area 747</cell><cell>rtime 26.4</cell><cell>delay 36.8</cell><cell></cell><cell cols="2">area 568</cell><cell>delay 22. I</cell><cell cols="2">area 1261</cell><cell>rtime 250.8</cell></row><row><cell cols="2">C6288 C7552 C5315 frg2 pair X I C3540 vda x3 rot a h 4 C2670 apex6 C1355 term1 x4 a h 2 frg 1 C1908 C1908 frg 1 ttt2 C880 c499 apex7 my -adder C432 f 5 im c8 i10 d a h i7 i6 count comp i4 cht cc</cell><cell>1365.6 192.2 222.6 164.4 169.4 51.6 306.4 75.4 82.8 205.4 246.2 182.4 107.0 220.4 83.8 59.6 208.6 71.8 207.8 9.3 20.8 7.4 17.1 13.6 9.6 21.0 20.1 7.6 6.05 40.6 36.4 20.8 17.3 18.0 11.8 7.2 6.4 4.6</cell><cell cols="2">2458 1880 1401 1243 1518 250 1022 93 1 700 504 615 567 61 I 606 333 373 355 85 429 223 1234 528 737 935 485 348 524 257 32 1 5529 3855 1742 1474 243 25 I 500 507 163</cell><cell>422.1 945.0 499.8 146.5 138.8 107.0 273.0 574.3 282.4 128.2 179.3 185.6 132.5 108.6 135.6 149.2 104.0 38.7 131.9 15.9 39.4 22.4 26.0 26.8 20.1 16.3 19.8 15.4 18.3 143.6 94.7 60.8 46.2 15.4 15.5 24.8 18.4 13.3</cell><cell cols="2">891.9 172.7 197.8 272.2 150.9 102.3 290.8 95.2 117.2 318.5 312.0 215.2 104.6 126.4 128.1 101.4 287.2 79.4 195.6 15.9 29.3 15.0 22.3 17.1 13.5 39.1 28.3 7.3 7.3 81.3 31.9 6.2 22.6 28.5 11.6 5.7 9.5 5.5</cell><cell cols="2">1425 1062 83 1 844 716 807 608 543 527 55 1 550 317 399 I76 302 368 320 27 1 263 583 596 452 309 406 270 256 202 244 249 2638 2090 762 580 112 151 208 23 1 74</cell><cell>835.7 148.8 186.3 110.9 130.2 93.0 265.8 79.4 87.0 192.9 258.9 179.8 83.7 116.4 124.8 65.1 199.8 74.4 170.6 9.0 23.9 8.2 12.7 16.4 8.1 17.8 25.6 6.5 6.1 58.4 23.8 3.9 2.7 7.6 11.3 5.0 3.8 3.4</cell><cell cols="2">2028 I567 960 918 I074 85 I 682 669 668 1133 1183 342 583 253 313 397 1214 299 457 613 1348 572 1444 884 516 682 256 248 338 273 1 3015 779 684 279 219 300 254 87</cell><cell>237.8 608.7 106.4 433. I 113.3 230.5 124.0 370.2 93.6 271.8 74.3 349.2 97.2 155.6 36.3 127.4 62.9 140.0 45.6 398.1 283.0 188.0 535.8 83.6 107.4 47.7 131.8 40.4 43.2 85.8 19.3 104.1 22.9 208.5 55.0 133.4 50.8 10.6</cell></row><row><cell cols="2">ttt2 C880 c499 Total</cell><cell>58.6 175.0 129.0 662.3 1 .o</cell><cell>52 420 1 .o</cell><cell>190 296 334</cell><cell>81.7 79.1 88.4 1580.1 1 .o</cell><cell cols="2">115.2 171.1 128.3 869.0 1.3</cell><cell>28 268 0.54</cell><cell>249 178 168</cell><cell>83.7 145.1 114.3 614.4 0.93</cell><cell>39 693 0.76</cell><cell>233 306 318</cell><cell>27.2 85.2 50.9 5723.9 3.6</cell></row><row><cell></cell><cell>example2</cell><cell>90.6</cell><cell></cell><cell>296</cell><cell>38.8</cell><cell cols="2">109.9</cell><cell></cell><cell>175</cell><cell>65.1</cell><cell></cell><cell>25 1</cell><cell>38.7</cell></row><row><cell></cell><cell>apex7</cell><cell>95.4</cell><cell></cell><cell>203</cell><cell>65.4</cell><cell cols="2">117.8</cell><cell></cell><cell>142</cell><cell>107.3</cell><cell></cell><cell>I77</cell><cell>39.3</cell></row><row><cell></cell><cell>my-adder</cell><cell>264.8</cell><cell></cell><cell>159</cell><cell>45.1</cell><cell cols="2">157.8</cell><cell></cell><cell>64</cell><cell>148.8</cell><cell></cell><cell>129</cell><cell>29.6</cell></row><row><cell></cell><cell>C432</cell><cell>199.6</cell><cell></cell><cell>23 1</cell><cell>62.5</cell><cell cols="2">200.6</cell><cell></cell><cell>93</cell><cell>182.1</cell><cell></cell><cell>168</cell><cell>56.2</cell></row><row><cell></cell><cell>f5 Im</cell><cell>68.0</cell><cell></cell><cell>105</cell><cell>52.8</cell><cell cols="2">56.5</cell><cell></cell><cell>129</cell><cell>56.5</cell><cell></cell><cell>129</cell><cell>47.9</cell></row><row><cell></cell><cell>c8</cell><cell>46.2</cell><cell></cell><cell>132</cell><cell>53.9</cell><cell cols="2">49.4</cell><cell></cell><cell>116</cell><cell>46.5</cell><cell></cell><cell>173</cell><cell>66.4</cell></row><row><cell></cell><cell>i10</cell><cell>293.8</cell><cell cols="2">2142</cell><cell>688.0</cell><cell cols="2">518.1</cell><cell cols="2">1232</cell><cell>305.2</cell><cell cols="2">2002</cell><cell>348.9</cell></row><row><cell></cell><cell>d a h</cell><cell>188.2</cell><cell cols="2">1490</cell><cell>803.7</cell><cell cols="2">213.0</cell><cell></cell><cell>909</cell><cell>169.2</cell><cell cols="2">I224</cell><cell>344.7</cell></row><row><cell></cell><cell>i7</cell><cell>62.2</cell><cell></cell><cell>637</cell><cell>620.4</cell><cell cols="2">55.8</cell><cell></cell><cell>398</cell><cell>32.9</cell><cell></cell><cell>402</cell><cell>97.1</cell></row><row><cell></cell><cell>i6</cell><cell>54.4</cell><cell></cell><cell>460</cell><cell>387.1</cell><cell cols="2">55.8</cell><cell></cell><cell>320</cell><cell>23.6</cell><cell></cell><cell>328</cell><cell>79.9</cell></row><row><cell cols="2">count</cell><cell>254.6</cell><cell></cell><cell>127</cell><cell>44.0</cell><cell cols="2">166.5</cell><cell></cell><cell>63</cell><cell>83.7</cell><cell></cell><cell>119</cell><cell>12.7</cell></row><row><cell cols="2">comp</cell><cell>116.4</cell><cell></cell><cell>121</cell><cell>41.1</cell><cell cols="2">111.4</cell><cell></cell><cell>60</cell><cell>95.7</cell><cell></cell><cell>250</cell><cell>46.6</cell></row><row><cell></cell><cell>i4</cell><cell>41.4</cell><cell></cell><cell>158</cell><cell>60.0</cell><cell cols="2">57.8</cell><cell></cell><cell>122</cell><cell>57.8</cell><cell></cell><cell>122</cell><cell>36.1</cell></row><row><cell cols="2">cht</cell><cell>50.0</cell><cell></cell><cell>160</cell><cell>62.1</cell><cell cols="2">32.9</cell><cell></cell><cell>124</cell><cell>32.9</cell><cell></cell><cell>124</cell><cell>22.5</cell></row><row><cell></cell><cell>cc</cell><cell>34.6</cell><cell></cell><cell>63</cell><cell>32.0</cell><cell cols="2">27.9</cell><cell></cell><cell>31</cell><cell>27.9</cell><cell></cell><cell>31</cell><cell>4.6</cell></row><row><cell></cell><cell>Total</cell><cell>6447.2 1 .o</cell><cell cols="2">23 185 1 .o</cell><cell>7988.6 I .o</cell><cell cols="2">6505.2 1.01</cell><cell cols="2">15 453 0.67</cell><cell>5181.8 0.80</cell><cell cols="2">22 077 0.95</cell><cell>5461.4 0.68</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">MIS2.2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Ceres</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Smallest</cell><cell></cell><cell></cell><cell cols="2">Fastest</cell></row><row><cell></cell><cell>Circuit</cell><cell>delay</cell><cell cols="2">area</cell><cell>rtime</cell><cell>delay</cell><cell></cell><cell cols="2">area</cell><cell>delay</cell><cell cols="2">area</cell><cell>rtime</cell></row><row><cell cols="2">C6288</cell><cell>84.2</cell><cell cols="2">5963</cell><cell>92.0</cell><cell>106.9</cell><cell></cell><cell cols="2">2263</cell><cell>106.9</cell><cell cols="2">2263</cell><cell>206.9</cell></row><row><cell cols="2">C1552</cell><cell>43.0</cell><cell cols="2">5210</cell><cell>133.0</cell><cell>34.1</cell><cell></cell><cell cols="2">261 1</cell><cell>25.5</cell><cell cols="2">3072</cell><cell>438.8</cell></row><row><cell cols="2">C5315</cell><cell>22.7</cell><cell cols="2">41 13</cell><cell>107.1</cell><cell>30.7</cell><cell></cell><cell cols="2">1981</cell><cell>28.6</cell><cell cols="2">2208</cell><cell>169.5</cell></row><row><cell cols="2">XI</cell><cell>7.9</cell><cell cols="2">764</cell><cell>29.0</cell><cell>11.4</cell><cell></cell><cell cols="2">1695</cell><cell>9.0</cell><cell cols="2">I709</cell><cell>462.8</cell></row><row><cell cols="2">C3540</cell><cell>32.9</cell><cell cols="2">2423</cell><cell>69.7</cell><cell>42.1</cell><cell></cell><cell cols="2">1214</cell><cell>32.3</cell><cell cols="2">295 1</cell><cell>462.5</cell></row><row><cell cols="2">vda</cell><cell>14.3</cell><cell cols="2">2260</cell><cell>141.6</cell><cell>19.9</cell><cell></cell><cell cols="2">1078</cell><cell>10.7</cell><cell cols="2">1432</cell><cell>214.7</cell></row><row><cell cols="2">x3</cell><cell>11.6</cell><cell cols="2">2013</cell><cell>56.7</cell><cell>15.8</cell><cell></cell><cell cols="2">1125</cell><cell>8.5</cell><cell cols="2">1423</cell><cell>211.9</cell></row><row><cell cols="2">rot</cell><cell>18.6</cell><cell cols="2">1345</cell><cell>39.8</cell><cell>37.4</cell><cell></cell><cell cols="2">1117</cell><cell>20.1</cell><cell cols="2">1866</cell><cell>341.6</cell></row><row><cell cols="2">a h 4</cell><cell>29.7</cell><cell cols="2">1434</cell><cell>40.5</cell><cell>45.5</cell><cell></cell><cell cols="2">993</cell><cell>27.8</cell><cell cols="2">2399</cell><cell>332.8</cell></row><row><cell cols="2">C2670</cell><cell>23.8</cell><cell cols="2">1705</cell><cell>54.7</cell><cell>32.9</cell><cell></cell><cell></cell><cell>864</cell><cell>22.6</cell><cell cols="2">1225</cell><cell>90.0</cell></row><row><cell cols="2">apex6</cell><cell>9.7</cell><cell cols="2">1339</cell><cell>38.3</cell><cell>12.7</cell><cell></cell><cell cols="2">674</cell><cell>10.8</cell><cell cols="2">72 1</cell><cell>62.8</cell></row><row><cell cols="2">C 1355</cell><cell>19.6</cell><cell cols="2">1373</cell><cell>32.0</cell><cell>15.9</cell><cell></cell><cell cols="2">404</cell><cell>15.9</cell><cell cols="2">404</cell><cell>21.8</cell></row><row><cell cols="2">term 1</cell><cell>11.0</cell><cell cols="2">86 1</cell><cell>32.0</cell><cell>15.0</cell><cell></cell><cell cols="2">598</cell><cell>12.7</cell><cell cols="2">745</cell><cell>114.4</cell></row><row><cell cols="2">x4</cell><cell>10.1</cell><cell cols="2">1014</cell><cell>34.2</cell><cell>14.0</cell><cell></cell><cell cols="2">670</cell><cell>6.7</cell><cell cols="2">765</cell><cell>142.2</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors wish to thank Jerry Yang, David Filo, Michiel Ligthart, Polly Siegel, and Hiok Nam Tay for their comments and contributions to the SLIF Tools. The contribution of Thierry Klein, David Ku, and Phil Johnson to the definition of the SLIF format is also acknowledged. The many discussions with Maurizio Damiani about the calculation of don 't cures and their usage are greatly appreciated.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mis: A multiple-level logic optimization system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rudell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1062" to="1081" />
			<date type="published" when="1987-11">Nov. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Boulder optimal logic design system</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bostick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jacoby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Lightner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Moceyunas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Momson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ravenscroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Computer-Aided Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1987-11">Nov. 1987</date>
			<biblScope unit="page" from="62" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Freeman</publisher>
			<pubPlace>San Francisco, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Lss: A system for production logic synthesis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Damnger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Brand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Joyner</surname></persName>
		</author>
		<author>
			<persName><surname>Trevillyan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. Res. Develop</title>
		<imprint>
			<date type="published" when="1984-09">Sept. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Socrates: a system for automatically synthesizing and optimizing combinational logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gregoly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>De Geus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hachtel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd Design Automation Conf., IEEE/ACM</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="79" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Technology mapping for standard-cell generators</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R C M</forename><surname>Berkelaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A G</forename><surname>Jess</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Computer-Aided Design</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Technology mapping in mis</title>
		<author>
			<persName><forename type="first">E</forename><surname>Detjens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gannot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rudell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Con$ Compurer-Aided Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1987-11">Nov. 1987</date>
			<biblScope unit="page" from="116" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Dagon: Technology binding and local optimization by dag matching</title>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th Design Automation Conf., IEEEIACM</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mapping properties of multi-level logic synthesis operations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Lega</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conj Computer Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1988-10">Oct. 1988</date>
			<biblScope unit="page" from="257" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Mcmap: A fast technology mapping procedure for multi-level logic synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lisanke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brglez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kedem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Computer Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1988-10">Oct. 1988</date>
			<biblScope unit="page" from="252" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Techmap: Technology mapping with delay and area optimization,&quot; in Logic and Architecture Synthesis for Silicon Compilers</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Morrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Jacoby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<editor>P. M. McLellan</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ieee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">NOV. 1988. 1987. 1989</date>
			<publisher>North-Holland</publisher>
			<biblScope unit="page" from="53" to="64" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Logic synthesis for VLSI design</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rudell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">U. C. Berkeley (Memorandum UCBIERL M89I49)</title>
		<imprint>
			<date type="published" when="1989-04">Apr. 1989</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Binary decision diagrams</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Akers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="509" to="516" />
			<date type="published" when="1978-06">June 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graph-based algorithms for Boolean function manipulation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="677" to="691" />
			<date type="published" when="1986-08">Aug. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Muroga</surname></persName>
		</author>
		<title level="m">Threshold Logic and its Applications</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>John Wiley</publisher>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient implementation of a bdd package</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Brace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rudell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conf</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="40" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Logic Minimization Algorithms for VLSI Synthesis</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Mcmullen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Kluwer Academic Publishers</publisher>
			<pubPlace>Nonvell, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Detection of group invariance or total symmetry of a Boolean function</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Mccluskey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eel1 Syst. Tech J</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="1445" to="1453" />
			<date type="published" when="1956-11">Nov. 1956</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Variable matching for verification</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Reeves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kedem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MCNC Tech. Rep. TR</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="issue">15</biblScope>
			<date type="published" when="1990-04">Apr. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Hurst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Muzio</surname></persName>
		</author>
		<title level="m">Spectral Techniques in Digital Logic</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Liu</surname></persName>
		</author>
		<title level="m">Elements of Discrete Mathematics</title>
		<meeting><address><addrLine>Neww York</addrLine></address></meeting>
		<imprint>
			<publisher>Mc-Graw-Hill</publisher>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Logic Design Principles with Emphasis on Testable Semicustom Circuits</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Mccluskey</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Multilevel logic minimization using implicit don&apos;t cares</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Jacoby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Momson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rudell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="723" to="740" />
			<date type="published" when="1988-06">June 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Consistency and observability invariance in multi-level logic synthesis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mcgeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf Computer-Aided Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1989-11">Nov. 1989</date>
			<biblScope unit="page" from="426" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">The Yorktown silicon compiler system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Camposano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Micheli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H J M</forename><surname>Otten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T J</forename><surname>Eijindhoven</surname></persName>
		</author>
		<editor>Silicon Compilation, D. Gajski</editor>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Ed. Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">International Workshop on Automatic Verification Methods for Finite State Systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Coudert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Berthet</surname></persName>
		</author>
		<author>
			<persName><surname>Madre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">407</biblScope>
			<biblScope unit="page" from="12" to="14" />
			<date type="published" when="1989-06">Jun. 1989. 1990</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Grenoble; New York</pubPlace>
		</imprint>
	</monogr>
	<note>Verification of sequential machines based on symbolic execution</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The use of image computation techniques in extracting local don&apos;t cares and network optimization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Savoj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Touati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf Computer-Aided Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1991-11">Nov. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Savoj</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-04">Apr. 1991</date>
		</imprint>
	</monogr>
	<note>Private communication</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Technology mapping for VLSI circuits exploiting Boolean properties and operations</title>
		<author>
			<persName><forename type="first">F</forename><surname>Mailhot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-12">Dec. 1991</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Sylon-dream: A multi-level network synthesizer</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muroga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf Computer-Aided Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1989-11">Nov. 1989</date>
			<biblScope unit="page" from="552" to="555" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The use of observability and external don&apos;t cares for the simplification of multi-level networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Savoj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conf., ACMIIEEE</title>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="297" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">by perturbation analysis of combinational multiple-level logic circuits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Damiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Micheli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Derivation of don&apos;t care conditions</title>
		<meeting><address><addrLine>San Diego, CA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1985">1985. 1986. May 1991</date>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
	<note>MCNC</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Observability don&apos;t care sets and Boolean relations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Damiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Micheli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Computer-Aided Design</title>
		<imprint>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Increased CMOS IC stuck-at fault coverage with reduced I , test sets</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Fritzemeir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Soden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Treece</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hawkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Test Conf</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1960">1960</date>
			<biblScope unit="page" from="427" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Enhanced controllability for IDW test sets using partial scan</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhawmik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conf., ACMIIEEE</title>
		<imprint>
			<date type="published" when="1991-06">June 1991</date>
			<biblScope unit="page" from="278" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Redundancy identification and removal</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brglez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lisanke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Workshop Logic Synth</title>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
			<biblScope unit="page" from="8" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Timing analysis of computer hardware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hitchcock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">/EM J. Res. Develop</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="100" to="105" />
			<date type="published" when="1982-01">Jan. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Performance-oriented synthesis in the Yorktown silicon compiler</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">De</forename><surname>Micheli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="75" to="76" />
			<date type="published" when="1987-09">Sept. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Synchronous logic synthesis</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">De</forename><surname>Micheli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Workshop Logic Synth</title>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
			<biblScope unit="page" from="5" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Technology mapping for delay</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rudell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Workshop Logic Synrh</title>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
			<biblScope unit="page" from="8" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Timing optimization of combinational logic</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">I</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Inr. Conf. Computer-Aided Design</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1988-11">Nov. 1988</date>
			<biblScope unit="page" from="282" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Logic decomposition algorithms for the timing optimization of multi-level logic</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Paulin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Poirot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th Design Automation Conf., IEEEIACM</title>
		<imprint>
			<date type="published" when="1989-06">June 1989</date>
			<biblScope unit="page" from="329" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">the Olympus synthesis system</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">De</forename><surname>Micheli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mailhot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Truong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Design and Test</title>
		<imprint>
			<biblScope unit="page" from="37" to="53" />
			<date type="published" when="1990-10">Oct. 1990. 502-505, NOV. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">He is a senior CAD engineer at Synopsys, Mountain View, CA, where he is involved in research and development of logic synthesis tools. Previously, when he was at Stanford, he was involved in the design and development of the Olympus Synthesis System</title>
		<author>
			<persName><forename type="first">Frbdbric</forename><surname>Mailhot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Canada, in 1980, the M.S.E.E. degree from the Universite de Sherbrooke, P.Q., Canada, in 1981, the D.E.A. degree in microelectronics from the Universite de Grenoble, France, in 1982, and the Ph.D. degree in electrical engineering from Stanford University</title>
		<title level="s">received the B.S. degree in physics engineering from Ecole Polytechnique de Montreal</title>
		<meeting><address><addrLine>Stanford, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
	<note>S&apos;82-M&apos;83. His research interests include logic synthesis, test, and the interaction between behavioral and logic synthesis</note>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">79-M&apos;80-SM&apos;89), for a photograph and biography please see page 46 of the January 1993 issue of this TRANSACTIONS</title>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Micheli</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
