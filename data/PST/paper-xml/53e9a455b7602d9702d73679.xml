<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TCP ex Machina: Computer-Generated Congestion Control</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Keith</forename><surname>Winstein</surname></persName>
							<email>keithw@mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Artificial Intelligence Laboratory</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<region>Mass</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">SIGCOMM&apos;13</orgName>
								<address>
									<addrLine>August 12-16</addrLine>
									<postCode>2013</postCode>
									<settlement>Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">TCP ex Machina: Computer-Generated Congestion Control</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7D80DF3650AD43754C4ED5C01ACC5579</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C</term>
					<term>2</term>
					<term>1 [Computer-Communication Networks]: Network Architecture and Design -Network communications congestion control, computer-generated algorithms Prior assumptions about network Traffic model Objective function</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes a new approach to end-to-end congestion control on a multi-user network. Rather than manually formulate each endpoint's reaction to congestion signals, as in traditional protocols, we developed a program called Remy that generates congestioncontrol algorithms to run at the endpoints.</p><p>In this approach, the protocol designer specifies their prior knowledge or assumptions about the network and an objective that the algorithm will try to achieve, e.g., high throughput and low queueing delay. Remy then produces a distributed algorithm-the control rules for the independent endpoints-that tries to achieve this objective.</p><p>In simulations with ns-2, Remy-generated algorithms outperformed human-designed end-to-end techniques, including TCP Cubic, Compound, and Vegas. In many cases, Remy's algorithms also outperformed methods that require intrusive in-network changes, including XCP and Cubic-over-sfqCoDel (stochastic fair queueing with CoDel for active queue management).</p><p>Remy can generate algorithms both for networks where some parameters are known tightly a priori, e.g. datacenters, and for networks where prior knowledge is less precise, such as cellular networks. We characterize the sensitivity of the resulting performance to the specificity of the prior knowledge, and the consequences when real-world conditions contradict the assumptions supplied at design-time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Is it possible for a computer to "discover" the right rules for congestion control in heterogeneous and dynamic networks? Should computers, rather than humans, be tasked with developing congestion control methods? And just how well can we make computers perform this task? Figure <ref type="figure">1</ref>: Remy designs congestion-control schemes automatically to achieve desired outcomes. The algorithms it produces may replace the congestion-control module of a TCP implementation, and fit into a network library or kernel module that implements congestion control (DCCP, SCTP, the congestion manager, application-layer transmission control libraries, ns-2 modules, etc.).</p><p>We investigated these questions and found that computers can design schemes that in some cases surpass the best human-designed methods to date, when supplied with the appropriate criteria by which to judge a congestion-control algorithm. We attempt to probe the limits of these machine-generated protocols, and discuss how this style of transport-layer protocol design can give more freedom to network architects and link-layer designers.</p><p>Congestion control, a fundamental problem in multi-user computer networks, addresses the question: when should an endpoint transmit each packet of data? An ideal scheme would transmit a packet whenever capacity to carry the packet was available, but because there are many concurrent senders and the network experiences variable delays, this question isn't an easy one to answer. On the Internet, the past thirty years have seen a number of innovative and influential answers to this question, with solutions embedded at the endpoints (mainly in TCP) aided occasionally by queue management and scheduling algorithms in bottleneck routers that provide signals to the endpoints.</p><p>This area has continued to draw research and engineering effort because new link technologies and subnetworks have proliferated and evolved. For example, the past few years have seen an increase in wireless networks with variable bottleneck rates; datacenter networks with high rates, short delays, and correlations in offered load; paths with excessive buffering (now called "bufferbloat"); cellular wireless networks with highly variable, self-inflicted packet delays; links with non-congestive stochastic loss; and networks with large bandwidth-delay products. In these conditions, the classical congestion-control methods embedded in TCP can perform poorly, as many papers have shown ( §2).</p><p>Without the ability to adapt its congestion-control algorithms to new scenarios, TCP's inflexibility constrains architectural evolution, as we noted in an earlier position paper <ref type="bibr" target="#b42">[43]</ref>. Subnetworks and link layers are typically evaluated based on how well TCP performs over them. This scorecard can lead to perverse behavior, because TCP's network model is limited. For example, because TCP assumes that packet losses are due to congestion and reduces its transmission rate in response, some subnetwork designers have worked hard to hide losses. This often simply adds intolerably long packet delays. One may argue that such designs are misguided, but the difficulties presented by "too-reliable" link layers have been a perennial challenge for 25 years <ref type="bibr" target="#b11">[12]</ref> and show no signs of abating. With the rise of widespread cellular connectivity, these behaviors are increasingly common and deeply embedded in deployed infrastructure.</p><p>The designers of a new subnetwork may well ask what they should do to make TCP perform well. This question is surprisingly hard to answer, because the so-called teleology of TCP is unknown: exactly what objective does TCP congestion control optimize? TCP's dynamic behavior, when competing flows enter and leave the network, remains challenging to explain <ref type="bibr" target="#b6">[7]</ref>. In practice, the need to "make TCP perform well" is given as a number of loose guidelines, such as IETF RFC 3819 <ref type="bibr" target="#b22">[23]</ref>, which contains dozens of pages of qualitative best current practice. The challenging and subtle nature of this area means that the potential of new subnetworks and network architectures is often not realized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Design overview</head><p>How should we design network protocols that free subnetworks and links to evolve freely, ensuring that the endpoints will adapt properly no matter what the lower layers do? We believe that the best way to approach this question is to take the design of specific algorithmic mechanisms out of the hands of human designers (no matter how sophisticated!), and make the end-to-end algorithm be a function of the desired overall behavior.</p><p>We start by explicitly stating an objective for congestion control; for example, given an unknown number of users, we may optimize some function of the per-user throughput and packet delay, or a summary statistic such as average flow completion time. Then, instead of writing down rules by hand for the endpoints to follow, we start from the desired objective and work backwards in three steps:</p><p>1. First, model the protocol's prior assumptions about the network; i.e., the "design range" of operation. This model may be different, and have different amounts of uncertainty, for a protocol that will be used exclusively within a data center, compared with one intended to be used over a wireless link or one for the broader Internet. A typical model specifies upper and lower limits on the bottleneck link speeds, non-queueing delays, queue sizes, and degrees of multiplexing.</p><p>2. Second, define a traffic model for the offered load given to endpoints. This may characterize typical Web traffic, video conferencing, batch processing, or some mixture of these. It may be synthetic or based on empirical measurements.</p><p>3. Third, use the modeled network scenarios and traffic to design a congestion-control algorithm that can later be executed on endpoints.</p><p>We have developed an optimization tool called Remy that takes these models as input, and designs a congestion-control algorithm that tries to maximize the total expected value of the objective function, measured over the set of network and traffic models. The resulting pre-calculated, optimized algorithm is then run on actual endpoints; no further learning happens after the offline optimization. The optimized algorithm is run as part of an existing TCP sender implementation, or within any congestion-control module. No receiver changes are necessary (as of now).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of results</head><p>We have implemented Remy. Running on a 48-core server at MIT, Remy generally takes a few hours of wall-clock time (one or two CPU-weeks) to generate congestion-control algorithms offline that work on a wide range of network conditions.</p><p>Our main results from several simulation experiments with Remy are as follows:</p><p>1. For networks broadly consistent with the assumptions provided to Remy at design time, the machine-generated algorithms dramatically outperform existing methods, including TCP Cubic, Compound TCP, and TCP Vegas.</p><p>2. Comparing Remy's algorithms with schemes that require modifications to network gateways, including Cubic-over-sfqCoDel and XCP, Remy generally matched or surpassed these schemes, despite being entirely end-to-end.</p><p>3. We measured the tradeoffs that come from specificity in the assumptions supplied to Remy at design time. As expected, more-specific prior information turned out to be helpful when it was correct, but harmful when wrong. We found that Re-myCC schemes performed well even when designed for an order-of-magnitude variation in the values of the underlying network parameters.</p><p>On a simulated 15 Mbps fixed-rate link with eight senders contending and an RTT of 150 ms, a computer-generated congestioncontrol algorithm achieved the following improvements in median throughput and reductions in median queueing delay over these existing protocols: The source code for Remy, our ns-2 models, and the algorithms that Remy designed are available from http://web.mit.edu/remy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Starting with Ramakrishnan and Jain's DECBit scheme <ref type="bibr" target="#b35">[36]</ref> and Jacobson's TCP Tahoe (and Reno) algorithms <ref type="bibr" target="#b20">[21]</ref>, congestion control over heterogeneous packet-switched networks has been an active area of research. End-to-end algorithms typically compute a congestion window (or, in some cases, a transmission rate) as well as the round-trip time (RTT) using the stream of acknowledgments (ACKs) arriving from the receiver. In response to congestion, inferred from packet loss or, in some cases, rising delays, the sender reduces its window; conversely, when no congestion is perceived, the sender increases its window.</p><p>There are many different ways to vary the window. Chiu and Jain <ref type="bibr" target="#b9">[10]</ref> showed that among linear methods, additive increase / multiplicative decrease (AIMD) converges to high utilization and a fair allocation of throughputs, under some simplifying assumptions (long-running connections with synchronized and instantaneous feedback). Our work relaxes these assumptions to handle flows that enter and leave the network, and users who care about latency as well as throughput. Remy's algorithms are not necessarily linear, and can use both a window and a rate pacer to regulate transmissions.</p><p>In this paper, we compare Remy's generated algorithms with several end-to-end schemes, including NewReno <ref type="bibr" target="#b18">[19]</ref>, Vegas <ref type="bibr" target="#b8">[9]</ref>, Compound TCP <ref type="bibr" target="#b38">[39]</ref>, Cubic <ref type="bibr" target="#b17">[18]</ref>, and DCTCP for datacenters <ref type="bibr" target="#b1">[2]</ref>. NewReno has the same congestion-control strategy as Reno-slow start at the beginning, on a timeout, or after an idle period of about one retransmission timeout (RTO), additive increase every RTT when there is no congestion, and a one-half reduction in the window on receiving three duplicate ACKs (signaling packet loss). We compare against NewReno rather than Reno because NewReno's loss recovery is better.</p><p>Brakmo and Peterson's Vegas is a delay-based algorithm, motivated by the insight from Jain's CARD scheme <ref type="bibr" target="#b21">[22]</ref> and Wang and Crowcroft's DUAL scheme <ref type="bibr" target="#b40">[41]</ref> that increasing RTTs may be a congestion signal. Vegas computes a BaseRTT, defined as the RTT in the absence of congestion, and usually estimated as the first RTT on the connection before the windows grow. The expected throughput of the connection is the ratio of the current window size and BaseRTT, if there is no congestion; Vegas compares the actual sending rate, and considers the difference, diff, between the expected and actual rates. Depending on this difference, Vegas either increases the congestion window linearly (diff &lt; α), reduces it linearly (diff &gt; β ), or leaves it unchanged.</p><p>Compound TCP <ref type="bibr" target="#b38">[39]</ref> combines ideas from Reno and Vegas: when packet losses occur, it uses Reno's adaptation, while reacting to delay variations using ideas from Vegas. Compound TCP is more complicated than a straightforward hybrid of Reno and Vegas; for example, the delay-based window adjustment uses a binomial algorithm <ref type="bibr" target="#b5">[6]</ref>. Compound TCP uses the delay-based window to identify the absence of congestion rather than its onset, which is a key difference from Vegas.</p><p>Rhee and Xu's Cubic algorithm is an improvement over their previous work on BIC <ref type="bibr" target="#b44">[45]</ref>. Cubic's growth is independent of the RTT (like H-TCP <ref type="bibr" target="#b28">[29]</ref>), and depends only on the packet loss rate, incrementing as a cubic function of "real" time. Cubic is known to achieve high throughput and fairness independent of RTT, but it also aggressively increases its window size, inflating queues and bloating RTTs (see §5).</p><p>Other schemes developed in the literature include equationbased congestion control <ref type="bibr" target="#b15">[16]</ref>, binomial control <ref type="bibr" target="#b5">[6]</ref>, FastTCP <ref type="bibr" target="#b41">[42]</ref>, HSTCP, and TCP Westwood <ref type="bibr" target="#b29">[30]</ref>.</p><p>End-to-end control may be improved with explicit router participation, as in Explicit Congestion Notification (ECN) <ref type="bibr" target="#b14">[15]</ref>, VCP <ref type="bibr" target="#b43">[44]</ref>, active queue management schemes like RED <ref type="bibr" target="#b16">[17]</ref>, BLUE <ref type="bibr" target="#b13">[14]</ref>, CHOKe <ref type="bibr" target="#b34">[35]</ref>, AVQ <ref type="bibr" target="#b26">[27]</ref>, and CoDel <ref type="bibr" target="#b32">[33]</ref> fair queueing, and explicit methods such as XCP <ref type="bibr" target="#b23">[24]</ref> and RCP <ref type="bibr" target="#b37">[38]</ref>. AQM schemes aim to prevent persistent queues, and have largely focused on reacting to growing queues by marking packets with ECN or dropping them even before the queue is full. CoDel changes the model from reacting to specific average queue lengths to reacting when the delays measured over some duration are too long, suggesting a persistent queue. Scheduling algorithms isolate flows or groups of flows from each other, and provide weighted fairness between them. In XCP and RCP, routers place information in packet headers to help the senders determine their window (or rate). One limitation of XCP is that it needs to know the bandwidth of the outgoing link, which is difficult to obtain accurately for a time-varying wireless channel.</p><p>In §5, we compare Remy's generated algorithm with XCP and with end-to-end schemes running through a gateway with the CoDel AQM and stochastic fair queueing (sfqCoDel).</p><p>TCP congestion control was not designed with an explicit optimization goal in mind, but instead allows overall network behavior to emerge from its rules. Kelly et al. present an interpretation of various TCP congestion-control variants in terms of the implicit goals they attempt to optimize <ref type="bibr" target="#b24">[25]</ref>. This line of work has become known as Network Utility Maximization (NUM); more recent work has modeled stochastic NUM problems <ref type="bibr" target="#b45">[46]</ref>, in which flows enter and leave the network. Remy may be viewed as combining the desire for practical distributed endpoint algorithms with the explicit utility-maximization ethos of stochastic NUM.</p><p>We note that TCP stacks have adapted in some respects to the changing Internet; for example, increasing bandwidth-delay products have produced efforts to increase the initial congestion window <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b10">11]</ref>, including recent proposals <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b39">40]</ref> for this quantity to automatically increase on the timescale of months or years. What we propose in this paper is an automated means by which TCP's entire congestion-control algorithm, not just its initial window, could adapt in response to empirical variations in underlying networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MODELING THE CONGESTION-CONTROL PROBLEM</head><p>We treat congestion control as a problem of distributed decisionmaking under uncertainty. Each endpoint that has pending data must decide for itself at every instant: send a packet, or don't send a packet.</p><p>If all nodes knew in advance the network topology and capacity, and the schedule of each node's present and future offered load, such decisions could in principle be made perfectly, to achieve a desired allocation of throughput on shared links.</p><p>In practice, however, endpoints receive observations that only hint at this information. These include feedback from receivers concerning the timing of packets that arrived and detection of packets that didn't, and sometimes signals, such as ECN marks, from within the network itself. Nodes then make sending decisions based on this partial information about the network.</p><p>Our approach hinges on being able to evaluate quantitatively the merit of any particular congestion control algorithm, and search for the best algorithm for a given network model and objective function. We discuss here our models of the network and cross traffic, and how we ultimately calculate a figure of merit for an arbitrary congestion control algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Expressing prior assumptions about the network</head><p>From a node's perspective, we treat the network as having been drawn from a stochastic generative process. We assume the network is Markovian, meaning that it is described by some state (e.g. the packets in each queue) and its future evolution will depend only on the current state.</p><p>Currently, we typically parametrize networks on three axes: the speed of bottleneck links, the propagation delay of the network paths, and the degree of multiplexing, i.e., the number of senders contending for each bottleneck link. We assume that senders have no control over the paths taken by their packets to the receiver.</p><p>Depending on the range of networks over which the protocol is intended to be used, a node may have more or less uncertainty about the network's key parameters. For example, in a data center, the topology, link speeds, and minimum round-trip times may be known in advance, but the degree of multiplexing could vary over a large range. A virtual private network between "clouds" may have more uncertainty about the link speed. A wireless network path may experience less multiplexing, but a large range of transmission rates and round-trip times.</p><p>As one might expect, we have observed a tradeoff between generality and performance; a protocol designed for a broad range of networks may be beaten by a protocol that has been supplied with more specific and accurate prior knowledge. Our approach allows protocol designers to measure this tradeoff and choose an appropriate design range for their applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Traffic model</head><p>Remy models the offered load as a stochastic process that switches unicast flows between sender-receivers pairs on or off. In a simple model, each endpoint has traffic independent of the other endpoints. The sender is "off" for some number of seconds, drawn from an exponential distribution. Then it switches on for some number of bytes to be transmitted, drawn from an empirical distribution of flow sizes or a closed-form distribution (e.g. heavy-tailed Pareto). While "on," we assume that the sender will not stall until it completes its transfer.</p><p>In traffic models characteristic of data center usage, the off-to-on switches of contending flows may cluster near one another in time, leading to incast. We also model the case where senders are "on" for some amount of time (as opposed to bytes) and seek maximum throughput, as in the case of videoconferences or similar real-time traffic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Objective function</head><p>Resource-allocation theories of congestion control have traditionally employed the alpha-fairness metric to evaluate allocations of throughput on shared links <ref type="bibr" target="#b36">[37]</ref>. A flow that receives steady-state throughput of x is assigned a score of U α (x) = x<ref type="foot" target="#foot_0">1</ref>-α 1-α . As α → 1, in the limit U 1 (x) becomes log x.</p><p>Because U α (x) is concave for α &gt; 0 and monotonically increasing, an allocation that maximizes the total score will prefer to divide the throughput of a bottleneck link equally between flows. When this is impossible, the parameter α sets the tradeoff between fairness and efficiency. For example, α = 0 assigns no value to fairness and simply measures total throughput. α = 1 is known as proportional fairness, because it will cut one user's allocation in half as long as another user's can be more than doubled. α = 2 corresponds to minimum potential delay fairness, where the score goes as the negative inverse of throughput; this metric seeks to minimize the total time of fixed-length file transfers. As α → ∞, maximizing the total U α (x) achieves max-min fairness, where all that matters is the minimum resource allocations in bottom-up order <ref type="bibr" target="#b36">[37]</ref>.</p><p>Because the overall score is simply a sum of monotonically increasing functions of throughput, an algorithm that maximizes this total is Pareto-efficient for any value of α; i.e., the metric will always prefer an allocation that helps one user and leaves all other users the same or better. Tan et al. <ref type="bibr" target="#b27">[28]</ref> proved that, subject to the requirement of Pareto-efficiency, alpha-fairness is the metric that places the greatest emphasis on fairness for a particular α.</p><p>Kelly et al. <ref type="bibr" target="#b24">[25]</ref> and further analyses showed that TCP approximately maximizes minimum potential delay fairness asymptotically in steady state, if all losses are congestive and link speeds are fixed.</p><p>We extend this model to cover dynamic traffic and network conditions. Given a network trace, we calculate the average throughput x of each flow, defined as the total number of bytes received divided by the time that the sender was "on." We calculate the average round-trip delay y of the connection.</p><p>The flow's score is then</p><formula xml:id="formula_0">U α (x) -δ •U β (y),<label>(1)</label></formula><p>where α and β express the fairness-vs.-efficiency tradeoffs in throughput and delay, respectively, and δ expresses the relative importance of delay vs. throughput. We emphasize that the purpose of the objective function is to supply a quantitative goal from a protocol-design perspective. It need not (indeed, does not) precisely represent users' "true" preferences or utilities. In real usage, different users may have different objectives; a videoconference may not benefit from more throughput, or some packets may be more important than others. We have not yet addressed the problem of how to accommodate diverse objectives or how endpoints might learn about the differing preferences of other endpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">HOW REMY PRODUCES A CONGESTION-CONTROL ALGORITHM</head><p>The above model may be viewed as a cooperative game that endpoints play. Given packets to transmit (offered load) at an endpoint, the endpoint must decide when to send packets in order to maximize its own objective function. With a particular congestion-control algorithm running on each endpoint, we can calculate each endpoint's expected score.</p><p>In the traditional game-theoretic framework, an endpoint's decision to send or abstain can be evaluated after fixing the behavior of all other endpoints. An endpoint makes a "rational" decision to send if doing so would improve its expected score, compared with abstaining.</p><p>Unfortunately, when greater individual throughput is the desired objective, on a best-effort packet-switched network like the Internet, it is always advantageous to send a packet. In this setting, if every endpoint acted rationally in its own self-interest, the resulting Nash equilibrium would be congestion collapse! 1 This answer is unsatisfactory from a protocol-design perspective, when endpoints have the freedom to send packets when they choose, but the designer wishes to achieve an efficient and equitable allocation of network capacity.</p><p>Instead, we believe the appropriate framework is that of superrationality <ref type="bibr" target="#b19">[20]</ref>. Instead of fixing the other endpoints' actions before deciding how to maximize one endpoint's expected score, what is fixed is the common (but as-yet unknown) algorithm run by all endpoints. As in traditional game theory, the endpoint's goal remains maximizing its own self-interest, but with the knowledge that other endpoints are reasoning the same way and will therefore arrive at the same algorithm.</p><p>Remy's job is to find what that algorithm should be. We refer to a particular Remy-designed congestion-control algorithm as a "RemyCC," which we then implant into an existing sender as part of TCP, DCCP <ref type="bibr" target="#b25">[26]</ref>, congestion manager <ref type="bibr" target="#b4">[5]</ref>, or another module running congestion control. The receiver is unchanged (as of now; this may change in the future), but is expected to send periodic ACK feedback.</p><p>Formally, we treat the problem of finding the best RemyCC under uncertain network conditions as a search for the best policy for a decentralized partially-observable Markov decision process, or Dec-POMDP <ref type="bibr" target="#b33">[34]</ref>. This model originated from operations research and artificial intelligence, in settings where independent agents work cooperatively to achieve some goal. In the case of end-to-end congestion control, endpoints are connected to a shared network that evolves in Markovian fashion. At every time step, the agents must choose between the actions of "sending" or "abstaining," using observables from their receiver or from network infrastructure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Compactly representing the sender's state</head><p>In principle, for any given network, there is an optimal congestion-control scheme that maximizes the expected total of the endpoints' objective functions. Such an algorithm would relate (1) the entire history of observations seen thus far (e.g. the contents and timing of every ACK) and ( <ref type="formula">2</ref>) the entire history of packets already sent, to the best action at any given moment between sending a new packet or abstaining. However, the search for such an algorithm is likely intractable; on a general Dec-POMDP it is NEXPcomplete <ref type="bibr" target="#b7">[8]</ref>.</p><p>Instead, we approximate the solution by greatly abridging the sender's state. A RemyCC tracks just three state variables, which it updates each time it receives a new acknowledgment:</p><p>1. An exponentially-weighted moving average (EWMA) of the interarrival time between new acknowledgments received (ack_ewma).</p><p>2. An exponentially-weighted moving average of the time between TCP sender timestamps reflected in those acknowledgments (send_ewma). A weight of 1/8 is given to the new sample in both EWMAs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>The ratio between the most recent RTT and the minimum RTT seen during the current connection (rtt_ratio).</p><p>Together, we call these three variables the RemyCC memory. It is worth reflecting on these variables, which are the "congestion signals" used by any RemyCC. We narrowed the memory to this set after examining and discarding quantities like the most-recent RTT sample, the smoothed RTT estimate, and the difference between the long-term EWMA and short-term EWMA of the observed packet rate or RTT. In our experiments, adding extra state variables didn't improve the performance of the resulting protocol, and each additional dimension slows down the design procedure considerably. But we don't claim that Remy's three state variables are the only set that works, or that they are necessarily optimal for all situations a protocol might encounter. We expect that any group of estimates that roughly summarizes the recent history could form the basis of a workable congestion-control scheme.</p><p>We note that a RemyCC's memory does not include the two factors that traditional TCP congestion-control schemes use: packet loss and RTT. This omission is intentional: a RemyCC that functions well will see few congestive losses, because its objective function will discourage building up queues (bloating buffers will decrease a flow's score). Moreover, avoiding packet loss as a congestion signal allows the protocol to robustly handle stochastic (noncongestive) packet losses without adversely reducing performance. We avoid giving the sender access to the RTT (as opposed to the RTT ratio), because we do not want it to learn different behaviors for different RTTs. At the start of each flow, before any ACKs have been received, the memory starts in a well-known all-zeroes initial state. Remy-CCs do not keep state from one "on" period to the next, mimicking TCP's behavior in beginning with slow start every time a new connection is established (it is possible that caching congestion state is a good idea on some paths, but we don't consider this here). Although RemyCCs do not depend on loss as a congestion signal, they do inherit the loss-recovery behavior of whatever TCP sender they are added to.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">RemyCC: Mapping the memory to an action</head><p>A RemyCC is defined by how it maps values of the memory to output actions. Operationally, a RemyCC runs as a sequence of lookups triggered by incoming ACKs. (The triggering by ACKs is inspired by TCP's ACK clocking.) Each time a RemyCC sender receives an ACK, it updates its memory and then looks up the corresponding action. It is Remy's job to pre-compute this lookup table during the design phase, by finding the mapping that maximizes the expected value of the objective function, with the expectation taken over the network model.</p><p>Currently, a Remy action has three components:</p><p>1. A multiple m ≥ 0 to the current congestion window (cwnd).</p><p>2. An increment b to the congestion window (b could be negative).</p><p>3. A lower bound r &gt; 0 milliseconds on the time between successive sends.</p><p>If the number of outstanding packets is greater than cwnd, the sender will transmit segments to close the window, but no faster than one segment every r milliseconds.</p><p>A RemyCC is defined by a set of piecewise-constant rules, each one mapping a three-dimensional rectangular region of the threedimensional memory space to a three-dimensional action: ack_ewma, send_ewma, rtt_ratio → m, b, r .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Remy's automated design procedure</head><p>The design phase of Remy is an optimization procedure to efficiently construct this state-to-action mapping, or rule table. Remy uses simulation of the senders on various sample networks drawn from the network model, with parameters drawn within the ranges of the supplied prior assumptions. These parameters include the link rates, delays, the number of sources, and the on-off distributions of the sources. Offline, Remy evaluates candidate algorithms on millions of randomly generated network configurations. Because of the high speed of current computers and the "embarrassingly parallel" nature of the task, Remy is able to generate congestion-control algorithms within a few hours.</p><p>A single evaluation step, the innermost loop of Remy's design process, consists of drawing 16 or more network specimens from the network model, then simulating the RemyCC algorithm at each sender for 100 seconds on each network specimen. At the end of the simulation, the objective function for each sender, given by Equation 1, is totaled to produce an overall figure of merit for the Re-myCC. We explore two cases, α = β = 1 and α = 2, δ = 0. The first case corresponds to proportional throughput and delay fairness, maximizing</p><formula xml:id="formula_1">U = log(throughput) -δ • log(delay),</formula><p>with δ specifying the importance placed on delay vs. throughput. The second case corresponds to minimizing the potential delay of a fixed-length transfer, by maximizing</p><formula xml:id="formula_2">U = - 1 throughput</formula><p>.</p><p>Remy initializes a RemyCC with only a single rule. Any values of the three state variables (between 0 and 16,384) are mapped to a default action where m = 1, b = 1, r = 0.01.</p><p>Each entry in the rule table has an "epoch." Remy maintains a global epoch number, initialized to 0. Remy's search for the "best" RemyCC given a network model is a series of greedy steps to build and improve the rule table : 

1. Set all rules to the current epoch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Find the most-used rule in this epoch. Simulate the current</head><p>RemyCC and see which rule in the current epoch receives the most use. If no such rules were used, go to step 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>Improve that action until we can't anymore. Focus on this rule and find the best action for it. Draw at least 16 network specimens from the model, and then evaluate roughly 100 candidate increments to the current action, increasing geometrically in granularity as they get further from the current value. For example, evaluate r ± 0.01, r ± 0.08, r ± 0.64, . . . , taking the Cartesian product with the alternatives for m and b.</p><p>The modified action is evaluated by substituting it into all senders and repeating the simulation in parallel. We use the same random seed and the same set of specimen networks in the simulation of each candidate action to reduce the effects of random variation. If any of the candidates is an improvement, replace the action with the best new action and repeat the search, still with the same specimen networks and random seed. Otherwise, increment the epoch number of the current rule and go back to step 2. 5. Subdivide the most-used rule. Recall that each rule represents a mapping from a three-dimensional rectangular region of memory space to a single action. In this step, find the most-used rule, and the median memory value that triggers it. Split the rule at this point, producing eight new rules (one per dimension of the memory-space), each with the same action as before. Then return to step 1.</p><p>By repeating this procedure, the structure of a RemyCC's rule table becomes an octree <ref type="bibr" target="#b31">[32]</ref> of memory regions. Areas of the memory space more likely to occur receive correspondingly more attention from the optimizer, and are subdivided into smaller bins that yield a more granular function relating memory to action. Which rules are more often triggered depends on every endpoint's behavior as well as the network's parameters, so the task of finding the right structure for the rule table is best run alongside the process of optimizing existing rules.</p><p>To the best of our knowledge, this dynamic partitioning approach is novel in the context of multi-agent optimization. The "greedy" approach in step 2 is key to the computational tractability and efficiency of the search because it allows us to prune the search space. Dividing the memory space into cells of different size proportional to their activity produces a rule table whose granularity is finer in regions of higher use. An improvement to consider in the future is to divide a cell only if the actions at its boundaries markedly disagree. <ref type="foot" target="#foot_1">2</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>We used ns-2 to evaluate the algorithms generated by Remy and compare them with several other congestion-control methods, including both end-to-end schemes and schemes with router assistance. This section describes the network and workload scenarios and our findings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Simulation setup and metrics</head><p>Congestion-control protocols. The end-to-end schemes we compared with are NewReno, Vegas, Cubic, and Compound. In addition, we compared against two schemes that depend on router assistance: XCP, and Cubic over stochastic fair queueing <ref type="bibr" target="#b30">[31]</ref> with each queue running CoDel <ref type="bibr" target="#b32">[33]</ref>. We use Nichols's published sfqCoDel implementation (version released in March 2013) for ns-2. <ref type="foot" target="#foot_2">3</ref> The Cubic, Compound, and Vegas codes are from the Linux implementations ported to ns-2 and available in ns-2.35. For the datacenter simulation, we also compare with the DCTCP ns-2.35 patch. <ref type="foot" target="#foot_3">4</ref>RemyCCs. We used Remy to construct three general-purpose RemyCCs. Each one was designed for an uncertain network model with the dumbbell topology of Figure <ref type="figure" target="#fig_0">2</ref> The model captures a 64-fold range of bandwidth-delay product per user. Each RemyCC took about 3-5 CPU-days to optimize. Calculations were run on Amazon EC2 and on an 80-core and 48core server at MIT. In wall-clock time, each RemyCC took a few hours to be constructed. The RemyCCs contain between 162 and 204 rules each.</p><p>We also used Remy to assess how performance varies based on the specificity of the assumptions used at design time, by building one RemyCC for a link speed known exactly a priori, and one that assumes only that the link speed will lie within a tenfold range:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quantity</head><p>Design range Distribution n max senders 2 uniform "on" process mean 5 sec exponential "off" process mean 5 sec exponential link speed 15 Mbps ("1×") exact link speed 4.7-47 Mbps ("10×") uniform round-trip time 150 ms exact queue capacity unlimited</p><p>In most experiments, all the sources run the same protocol; in some, we pick different protocols for different sources to investigate how well they co-exist. Each simulation run is generally 100 seconds long, with each scenario run at least 128 times to collect summary statistics.</p><p>Workloads. Each source is either "on" or "off" at any point in time. In the evaluation, we modeled the "off" times as exponentially distributed, and the "on" distribution in one of three different ways:</p><p>• by time, where the source sends as many bytes as the congestion-control protocol allows, for a duration of time picked from an exponential distribution,</p><p>• by bytes, where the connection sends as many bytes as given by an exponential distribution of a given average and shape, and</p><p>• by empirical distribution, using the flow-length CDF from a large trace captured in March 2012 and published recently <ref type="bibr" target="#b3">[4]</ref>. The flow-length CDF matches a Pareto distribution with the parameters given in Figure <ref type="figure" target="#fig_4">3</ref>, suggesting that the underlying distribution does not have finite mean. In our evaluation, we add 16 kilobytes to each sampled value to ensure that the network is loaded.</p><p>Topologies. We used these topologies in our experiments:</p><p>1. Single bottleneck ("dumbbell"): The situation in Figure <ref type="figure" target="#fig_0">2</ref>, with a 1,000-packet buffer, as might be seen in a shared cablemodem uplink. We tested a configuration whose link speed and delay were within the RemyCC design ranges: In addition, we investigate:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Competing protocols:</head><p>We assessed how a RemyCC "played with" existing congestion-control schemes (Cubic and Compound) when contending for the same bottleneck link.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Sensitivity of design range:</head><p>We investigated how helpful prior knowledge of the network is to the performance of Remy's generated algorithms.</p><p>Metrics. We measure the throughput and average queueing delay observed for each source-destination pair. With an on-off source, measuring throughput takes some care. We define the throughput of a pair as follows. Suppose the pair is active during (nonoverlapping) time intervals of length t 1 ,t 2 , . . . during the entire simulation run of T seconds. If in each interval the protocol successfully receives s i bytes, we define the throughput for this connection as ∑ s i / ∑ti. We are interested in the end-to-end delay as well; the reasoning behind Remy's objective function and the δ parameter is that protocols that fill up buffers to maximize throughput are not as desirable as ones that achieve high throughput and low delay -both for their effect on the user, who may prefer to get his packets to the receiver sooner, as well as any other users who share the same FIFO queue. We present the results for the different protocols as throughputdelay plots, where the log-scale x-axis is the queueing delay (average per-packet delay in excess of minimum RTT). Lower, better, delays are to the right. The y-axis is the throughput. Protocols on the "top right" are the best on such plots. We take each individual 100second run from a simulation as one point, and then compute the 1-σ elliptic contour of the maximum-likelihood 2D Gaussian distribution that explains the points. To summarize the whole scheme, we plot the median per-sender throughput and queueing delay as a circle.</p><p>Ellipses that are narrower in the throughput or delay axis correspond to protocols that are fairer and more consistent in allocating those quantities. Protocols with large ellipses -where identicallypositioned users differ widely in experience based on the luck of the draw or the timing of their entry to the network -are less fair. The orientation of an ellipse represents the covariance between the throughput and delay measured for the protocol; if the throughput were uncorrelated with the queueing delay (note that we show the queueing delay, not the RTT), the ellipse's axes would be parallel to the graph's. Because of the variability and correlations between these quantities in practice, we believe that such throughput-delay plots are an instructive way to evaluate congestion-control protocols; they provide more information than simply reporting mean throughput and delay values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Single Bottleneck Results</head><p>We start by investigating performance over the simple, classic single-bottleneck "dumbbell" topology. Although it does not model the richness of real-world network paths, the dumbbell is a valuable topology to investigate because in practice there are many singlebottleneck paths experienced by Internet flows.</p><p>Recall that this particular dumbbell link had most of its parameters found inside the limits of the design range of the RemyCCs tested. As desired, this test demonstrates that Remy was successful </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B e t t e r</head><p>Figure <ref type="figure">5</ref>: Results for the dumbbell topology with n = 12 senders, each alternating between flows whose length is drawn from the ICSI trace (Fig. <ref type="figure" target="#fig_4">3</ref>) and exponentially-distributed off time (mean = 0.2 s). Because of the high variance of the sending distribution, 1  2 -σ ellipses are down. The RemyCCs again mark the efficient frontier.</p><p>in producing a family of congestion-control algorithms for this type of network.</p><p>Results from the 8-sender and 12-sender cases are shown in Figures 4 and 5. RemyCCs are shown in light blue; the results demonstrate the effect of the δ parameter in weighting the cost of delay. When δ = 0.1, RemyCC senders achieve greater median throughput than those of any other scheme, and the lowest delay (other than the two other RemyCCs). As δ increases, the RemyCCs trace out an achievability frontier of the compromise between throughput and delay. In this experiment, the computer-generated algorithms outperformed all the human-designed ones.</p><p>From right to left and bottom to top, the end-to-end TCP congestion-control schemes trace out a path from most delayconscious (Vegas) to most throughput-conscious (Cubic), with NewReno and Compound falling in between.</p><p>The schemes that require in-network assistance (XCP and Cubicover-sfqCoDel, shown in green) achieve higher throughput than the TCPs, but less than the two more throughput-conscious Remy-CCs. <ref type="foot" target="#foot_4">5</ref> This result is encouraging, because it suggests that even a purely end-to-end scheme can outperform well-designed algorithms that involve active router participation. This demonstrates that distributed congestion-control algorithms that explicitly maximize well-chosen objective functions can achieve gains over existing schemes. As we will see later, however, this substantially better performance will not hold when the design assumptions of a RemyCC are contradicted at runtime. ...about one RTT later, RemyCC begins sending at full link speed.</p><p>Competing flow stops, and... In Figures <ref type="figure" target="#fig_5">4</ref> and<ref type="figure">5</ref>, the RemyCCs do not simply have better median performance -they are also more fair to individual flows, in that the performance of an individual sender (indicated by the size of the ellipses) is more consistent in both throughput and delay.</p><p>To explain this result, we investigated how multiple RemyCC flows share the network. We found that when a new flow starts, the system converges to an equitable allocation quickly, generally after little more than one RTT. Figure <ref type="figure" target="#fig_8">6</ref> shows the sequence of transmissions of a new RemyCC flow that begins while sharing the link. Midway through the flow, the competing traffic departs, allowing the flow to start consuming the whole bottleneck rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Cellular Wireless Links</head><p>Cellular wireless links are tricky for congestion-control algorithms because their link rates vary with time. 6  By running a program that attempts to keep a cellular link backlogged but without causing buffer overflows, we measured the variation in download speed on Verizon's and AT&amp;T's LTE service while mobile. We then ran simulations over these pre-recorded traces, with the assumption that packets are enqueued by the network until they can be dequeued and delivered at the same instants seen in the trace.</p><p>As discussed above, we did not design the RemyCCs to accommodate such a wide variety of throughputs. Running the algorithm over this link illustrated some of the limits of a RemyCC's generalizability beyond situations encountered during the design phase.</p><p>Somewhat to our surprise, for moderate numbers of concurrent flows, n ≤ 8, the RemyCCs continued to surpass (albeit narrowly) the best human-designed algorithms, even ones benefiting from innetwork assistance. See Figures <ref type="figure" target="#fig_10">7</ref> and<ref type="figure" target="#fig_12">8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Differing RTTs</head><p>We investigated how the RemyCCs allocate throughput on a contested bottleneck link when the competing flows have different RTTs. At the design stage, all contending flows had the same RTT (which was drawn randomly for each network specimen from between 100 ms and 200 ms), so the RemyCCs were not designed to exhibit RTT fairness explicitly.</p><p>We compared the RemyCCs with Cubic-over-sfqCoDel by running 128 realizations of a four-sender simulation where one senderreceiver pair had RTT of 50 ms, one had 100 ms, one 150 ms, and 6 XCP, in particular, depends on knowing the speed of the link exactly; in our tests on cellular traces we supplied XCP with the longterm average link speed for this value.       one 200 ms. The RemyCCs did exhibit RTT unfairness, but more modestly than Cubic-over-sfqCoDel (Fig. <ref type="figure" target="#fig_15">10</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Datacenter-like topology</head><p>We simulated 64 connections sharing a 10 Gbps datacenter link, and compared DCTCP <ref type="bibr" target="#b1">[2]</ref> (using AQM inside the network) against a RemyCC with a 1000-packet tail-drop queue. The RTT of the path in the absence of queueing was 4 ms. Each sender sent 20 megabytes on average (exponentially distributed) with an "off" time between its connections exponentially distributed with mean 100 milliseconds.</p><p>We used Remy to design a congestion-control algorithm to maximize -1/throughput (minimum potential delay) over these network parameters, with the degree of multiplexing assumed to have been drawn uniformly between 1 and 64.</p><p>The results for the mean and median throughput (tput) for the 20 megabyte transfers are shown in the following These results show that a RemyCC trained for the datacenternetwork parameter range achieves comparable throughput at lower variance than DCTCP, a published and deployed protocol for similar scenarios. The per-packet latencies (and loss rates, not shown) are higher, because in this experiment RemyCC operates over a DropTail bottleneck router, whereas DCTCP runs over an ECNenabled RED gateway that marks packets when the instantaneous queue exceeds a certain threshold. Developing RemyCC schemes for networks with ECN and AQM is an area for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Competing protocols</head><p>We investigated the possibility of incremental deployment of a RemyCC, by simulating a single bottleneck link with one RemyCC flow contending with one flow from either Compound or Cubic, with no active queue management. The RemyCC was designed for round-trip-times between 100 ms and 10 s, in order to accommodate a "buffer-filling" competitor on the same bottleneck link. We used the same observed traffic distribution from Figure <ref type="figure" target="#fig_4">3</ref> and varied the mean "off" time (exponentially distributed) of the senders. The bottleneck link speed was 15 Mbps and baseline RTT was 150 ms. We also experimented with flows of mean sizes 100 kilobytes and 1 megabyte, with an exponentially distributed mean "off" time of 0.5 seconds between successive flows.</p><p>The results, shown in the two tables below, depended on the duty cycle of the senders dictated by the mean off time (numbers in parentheses are standard deviations). We observe that this RemyCC does well at low duty cycles because it is able to grab spare bandwidth more quickly. At higher duty cycles (with low mean off time), Cubic and Compound tend to grab a higher share of the bandwidth. The results, however, are close enough that we believe a RemyCC designed for competing with more aggressive protocols may close the gap, while retaining high performance when competing only with like-minded Remy-CCs. Figure <ref type="figure">11</ref>: Performance of two end-to-end RemyCCs that were designed with different prior information about the network, compared with Cubic-over-sfqCoDel as the link speed varies. Despite running only at the sender, the RemyCCs each outperform Cubic-over-sfqCoDel over almost their entire design ranges. But when a RemyCC's assumptions aren't met, performance deteriorates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mean off time</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">How helpful is prior knowledge about the network?</head><p>We investigated the performance benefit conferred by having more-specific prior information about the network, and what happens when that prior information is incorrect.</p><p>We used Remy to construct two additional RemyCCs, each for a network with a known minimum RTT of 150 ms. For one Re-myCC, the link speed was assumed to be 15 Mbps exactly. A second RemyCC was designed to span a 10× range of link speeds, from 4.7 Mbps to 47 Mbps. We also compared against Cubic-over-sfqCoDel over this range.</p><p>The results are shown in Figure <ref type="figure">11</ref>. On the particular link for which the "1×" RemyCC was designed, it performs the best, but its performance trails off quickly around that value. Within the range of the "10×" RemyCC, it beats Cubic-over-sfqCoDel, but again deteriorates when the true network violates its design assumptions. The results show that more-specific prior knowledge is helpful and improves performance -when it happens to be correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.8">Summary of results</head><p>Using a few CPU-weeks of computation, Remy produced several computer-generated congestion-control algorithms, which we then evaluated on a variety of simulated network conditions of varying similarity to the prior assumptions supplied at design-time.</p><p>On networks whose parameters mostly obeyed the prior knowledge supplied at design range -such as the dumbbell network with the 15 Mbps link -Remy's end-to-end algorithms outperformed all of the human-generated congestion-control algorithms, even algorithms that receive help from network infrastructure.</p><p>RemyCC (δ = 0.1) achieved &gt; 1.7× gains in median throughput and &gt; 2.7× reductions in median queueing delay against Cubic and Compound, generally thought to be excellent general-purpose congestion-control algorithms. Against Cubic-over-sfqCoDel, which has the benefit of code running on network infrastructure, RemyCC achieved a 40% increase in median throughput and a 7.8× decrease in median queueing delay.</p><p>On the cellular link traces, which are variable and were not designed for, Remy's schemes outperformed the existing congestioncontrol algorithms (end-to-end or otherwise) when the maximum degree of multiplexing was 4 or less, and outperformed the end-toend schemes and sfqCoDel when it was 8 or less. However, as the network conditions grew farther afield from the supplied prior assumptions, Remy's performance declined, although the algorithms were still competitive with traditional TCP congestion control on the networks we examined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION</head><p>Much remains unknown about the capabilities and limits of computer-generated algorithms, much less decentralized algorithms that cooperate indirectly across a network to achieve a common goal. Although the RemyCCs appear to work well on networks whose parameters fall within or near the limits of what they were prepared for -even beating in-network schemes at their own game and even when the design range spans an order of magnitude variation in network parameters -we do not yet understand clearly why they work, other than the observation that they seem to optimize their intended objective well.</p><p>We have attempted to make algorithms ourselves that surpass the generated RemyCCs, without success. That suggests to us that Remy may have accomplished something substantive. But digging through the dozens of rules in a RemyCC and figuring out their purpose and function is a challenging job in reverse-engineering. RemyCCs designed for broader classes of networks will likely be even more complex, compounding the problem.</p><p>Our approach increases endpoint complexity in order to reduce the complexity of overall network behavior. Traditional TCP congestion control specifies simpler behavior for each endpoint, but the resulting emergent behavior of a multiuser network is not easily specified and is often suboptimal and variable, and even unstable.</p><p>By contrast, our approach focuses on maximizing a wellspecified overall objective at the cost of complex endpoint algorithms. We think this tradeoff is advisable: today's endpoints can execute complex algorithms almost as easily as simple ones (and with Remy, the bulk of the intelligence is computed offline). What users and system designers ultimately care about, we believe, is the quality and consistency of overall behavior.</p><p>Our synthesis-by-simulation approach also makes it easier to discuss competing proposals for congestion control. Today, it is not easy to say why one flavor of TCP or tweak may be preferred over another. But if two computer-generated algorithms differ, there is a reason: either they make different assumptions about the expected networks they will encounter, or they have different goals in mind, or one is better optimized than the other. This formulation allows the implementer to choose rationally among competing options.</p><p>All that said, we have much to learn before computer-generated algorithms will have proven themselves trustworthy:</p><p>• Other than by exhaustive testing, we don't know how to predict the robustness of RemyCCs to unexpected inputs. Do they break catastrophically in such situations?</p><p>• How would a RemyCC designed for a 10,000-fold range of throughputs and RTTs perform?</p><p>• Although we are somewhat robust against a RemyCC's latching on to the peculiarities of a simulator implementation (because RemyCCs are designed within Remy but then evaluated within ns-2), we can't be certain how well RemyCCs will perform on real networks without trying them.</p><p>We believe that making congestion control a function of the desired ends, and the assumptions we make about the network, is the solution to allow the Internet and its subnetworks to evolve without tiptoeing around TCP's assumptions about how networks behave. But many dots need to be connected before the the Internet at large -as opposed to internal networks -might agree on a model that could be used to prepare a "one-size-fits-all" RemyCC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>This paper asks whether the design of distributed congestioncontrol algorithms for heterogeneous and dynamic networks can be done by specifying the assumptions that such algorithms are entitled to have and the policy they ought to achieve, and letting computers work out the details of the per-endpoint mechanisms.</p><p>Much future work remains before this question can be answered for the real-world Internet, but our findings suggest that this approach has considerable potential.</p><p>We developed and evaluated Remy, a program that designs endto-end congestion-control algorithms to human-supplied specifications. Remy's outputs handily outperform the best-known techniques, including ones that require intrusive in-network changes, in scenarios where network parameters varied over one or two orders of magnitude.</p><p>Our results, and many others in the literature, indicate that there is no existing single congestion-control method that is the best in all situations. Moreover, the set of "all situations" is rapidly growing as new subnetworks and link technologies proliferate. A computer-generated approach that maximizes an explicit function of the throughput and delay to generate algorithms may be the right way forward for the networking community. Today's informal approach of hampering lower layers or providing vague advice on how best to accommodate TCP should be replaced by end-to-end algorithms (in TCP and elsewhere) that adapt to whatever the lower layers are doing. Remy provides a way to achieve this goal.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Dumbbell network with uncertainty.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>4 .</head><label>4</label><figDesc>If we run out of rules in this epoch. Increment the global epoch. If the new epoch is a multiple of a parameter, K, continue to step 5. Otherwise go back to step 1. We use K = 4 to balance structural improvements vs. honing the existing structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>, but with three different values of δ (the relative importance of delay): 0.1, 1, and 10. The parameters of the network and traffic model used at design time were:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(Allman 2013; ICSI) Pareto(x+40) [ Xm = 147, alpha = 0.5 ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Observed Internet flow length distribution matches a Pareto (α = 0.5) distribution, suggesting mean is not welldefined.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Results for each of the schemes over a 15 Mbps dumbbell topology with n = 8 senders, each alternating between flows of exponentially-distributed byte length (mean 100 kilobytes) and exponentially-distributed off time (mean 0.5 s). Medians and 1-σ ellipses are shown. The blue line represents the efficient frontier, which here is defined entirely by the RemyCCs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Sequence plot of a RemyCC flow in contention with varying cross traffic. The flow responds quickly to the departure of a competing flow by doubling its sending rate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Verizon LTE downlink trace, n = 4. 1-σ ellipses are shown. The RemyCCs define the efficient frontier. Senders alternated between exponentially-distributed file transfers (mean 100 kilobytes) and exponentially-distributed pause times (mean 0.5 s).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Verizon LTE downlink trace, n = 8. 1-σ ellipses are shown. As the degree of multiplexing increases, the schemes move closer together in performance and routerassisted schemes begin to perform better. Two of the three Re-myCCs are on the efficient frontier.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: AT&amp;T LTE downlink trace, n = 4. Two of the Remy-CCs are on the efficient frontier.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Remy's RTT unfairness compares favorably to Cubic-over-sfqCoDel. Error bar represents standard error of the mean over 128 100-second simulations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Cellular wireless: We measured the downlink capacity of the Verizon and AT&amp;T LTE cellular services while mobile, by carefully saturating the downlink (without causing buffer overflow) and recording when packets made it to the user device. We recreate this link within ns-2, queueing packets until they are released to the receiver at the same time they were released in the trace. This setup probes the RemyCC's resilience to "model mismatch" -in both the Verizon and AT&amp;T traces, throughput and round-trip time were outside the limits of the RemyCC design range.</figDesc><table><row><cell>Quantity</cell><cell>Range</cell><cell>Distribution</cell></row><row><cell>link speed</cell><cell>15 Mbps</cell><cell>exact</cell></row><row><cell cols="2">round-trip time 150 ms</cell><cell>exact</cell></row><row><cell cols="2">queue capacity 1000 pkts (tail drop)</cell><cell></cell></row><row><cell>2. Quantity</cell><cell>Range</cell><cell>Distribution</cell></row><row><cell>link speed</cell><cell>varied 0-50 Mbps</cell><cell>empirical</cell></row><row><cell cols="2">round-trip time 50 ms</cell><cell>exact</cell></row><row><cell cols="2">queue capacity 1000 pkts (tail drop)</cell><cell></cell></row><row><cell cols="3">3. Differing RTTs: Cases where different RemyCCs, contend-</cell></row><row><cell cols="3">ing for the same link, had different RTTs to their correspond-</cell></row><row><cell cols="3">ing receiver. We analyzed these cases for throughput and de-</cell></row><row><cell cols="3">lay fairness and compared with existing congestion-control</cell></row><row><cell>schemes.</cell><cell></cell><cell></cell></row><row><cell>Quantity</cell><cell>Range</cell><cell>Distribution</cell></row><row><cell cols="2">n max senders 4</cell><cell></cell></row><row><cell>"on" process</cell><cell cols="2">16 × 10 3 -3.3 × 10 9 bytes Fig. 3</cell></row><row><cell>"off" process</cell><cell>mean 0.2 sec</cell><cell>exponential</cell></row><row><cell>link speed</cell><cell>10 Mbps</cell><cell>exact</cell></row><row><cell cols="2">queue capacity 1000 pkts (tail drop)</cell><cell></cell></row><row><cell cols="3">4. Datacenter: We compared a RemyCC against DCTCP in a</cell></row><row><cell cols="2">simulated datacenter topology.</cell><cell></cell></row><row><cell>Quantity</cell><cell>Range</cell><cell>Distribution</cell></row><row><cell>n max senders</cell><cell>64</cell><cell>exact</cell></row><row><cell>"on" process</cell><cell cols="2">mean 20 megabytes exponential</cell></row><row><cell>"off" process</cell><cell>mean 0.1 sec</cell><cell>exponential</cell></row><row><cell>link speed</cell><cell>10 Gbps</cell><cell>exact</cell></row><row><cell cols="2">round-trip time 4 ms</cell><cell>exact</cell></row><row><cell cols="3">queue capacity 1000 pkts (tail drop) (for RemyCC)</cell></row><row><cell cols="2">queue capacity modified RED</cell><cell>(for DCTCP)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>table :</head><label>:</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">tput: mean, med rtt: mean, med</cell></row><row><cell>DCTCP (ECN)</cell><cell>179, 144 Mbps</cell><cell>7.5, 6.4 ms</cell></row><row><cell cols="2">RemyCC (DropTail) 175, 158 Mbps</cell><cell>34, 39 ms</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Other researchers have grappled with this problem; for example, Akella et al.<ref type="bibr" target="#b0">[1]</ref> studied a restricted game, in which players are forced to obey the same particular flavor of TCP, but with the freedom to choose their additive-increase and multiplicative-decrease coefficients. Even with this constraint, the authors found that the Nash equilibrium is inefficient, unless the endpoints are restricted to run TCP Reno over a drop-tail buffer, in which case the equilibrium is unfair but not inefficient.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>We thank Leslie Kaelbling for this suggestion.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://www.pollere.net/Txtdocs/sfqcodel.cc</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>http://www.stanford.edu/~alizade/Site/DCTCP.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>It may seem surprising that sfqCoDel, compared with DropTail, increased the median RTT of TCP Cubic. CoDel drops a packet at the front of the queue if all packets in the past 100 ms experienced a queueing delay (sojourn time) of at least 5 ms. For this experiment, the transfer lengths are only 100 kilobytes; with a 500 ms "off" time, such a persistent queue is less common even though the mean queueing delay is a lot more than 5 ms. DropTail experiences more losses, so has lower delays (the maximum queue size is ≈ 4× the bandwidth-delay product), but also lower throughput than CoDel. In other experiments with longer transfers, Cubic did experience lower delays when run over sfqCoDel instead of DropTail.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We are grateful to Anirudh Sivaraman for several contributions to the simulator and for helpful discussions. We thank Leslie Kaelbling, Christopher Amato, Scott Shenker, and our shepherd, Ranjita Bhagwan. We thank Frans Kaashoek and Nickolai Zeldovich for the use of multicore machines at MIT. KW was supported by the Claude E. Shannon Research Assistantship. We thank the members of the MIT Center for Wireless Networks and Mobile Computing (Wireless@MIT), including Amazon.com, Cisco, Google, Intel, Mediatek, Microsoft, ST Microelectronics, and Telefonica, for their support. This work was also supported in part by NSF grant CNS-1040072.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Selfish Behavior and Stability of the Internet: A Game-Theoretic Analysis of TCP</title>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Alizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Maltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sridharan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Data Center TCP (DCTCP). In SIGCOMM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Allman</surname></persName>
		</author>
		<ptr target="http://tools.ietf.org/html/draft-allman-tcpm-bump-initcwnd-00" />
		<title level="m">Initial Congestion Window Specification</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Allman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comments on Bufferbloat. ACM SIGCOMM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2013-01">Jan. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Integrated Congestion Management Architecture for Internet Hosts</title>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Binomial Congestion Control Algorithms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dynamic Behavior of Slowly-Responsive Congestion Control Algorithms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Complexity of Decentralized Control of Markov Decision Processes</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Givan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zilberstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Operations Research</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="819" to="840" />
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Brakmo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>O'malley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Peterson</surname></persName>
		</author>
		<title level="m">TCP Vegas: New Techniques for Congestion Detection and Avoidance</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
	<note>SIGCOMM</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Analysis of the Increase and Decrease Algorithms for Congestion Avoidance in Computer Networks</title>
		<author>
			<persName><forename type="first">D.-M</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks and ISDN Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Increasing TCP&apos;s Initial Window</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dukkipati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mathis</surname></persName>
		</author>
		<ptr target="http://tools.ietf.org/html/draft-ietf-tcpm-initcwnd-08" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Design Philosophy of the DARPA Internet Protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An Argument for Increasing TCP&apos;s Initial Congestion Window</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dukkipati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Refice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Herbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sutin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="27" to="33" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The BLUE Active Queue Management Algorithms</title>
		<author>
			<persName><forename type="first">W</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kandlur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Saha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. on Networking</title>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">TCP and Explicit Congestion Notification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CCR</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="1994-10">Oct. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Equation-Based Congestion Control for Unicast Applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Random Early Detection Gateways for Congestion Avoidance</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. on Networking</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1993-08">Aug. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">CUBIC: A New TCP-Friendly High-Speed TCP Variant</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating System Review</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="64" to="74" />
			<date type="published" when="2008-07">July 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Improving the Start-up Behavior of a Congestion Control Scheme for TCP</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Hoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Hofstadter</surname></persName>
		</author>
		<title level="m">Metamagical Themas: Questing for the Essence of Mind and Pattern. Basic books</title>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Congestion Avoidance and Control</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Delay-based Approach for Congestion Avoidance in Interconnected Heterogeneous Computer Networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Advice for Internet Subnetwork Designers</title>
		<author>
			<persName><forename type="first">P</forename><surname>Karn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bormann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fairhurst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ludwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mahdavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Montenegro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Touch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IETF</title>
		<imprint>
			<biblScope unit="volume">3819</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>RFC</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Congestion Control for High Bandwidth-Delay Product Networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rohrs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Rate Control in Communication Networks: Shadow Prices, Proportional Fairness and Stability</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maulloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Operational Research Society</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="237" to="252" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Designing DCCP: Congestion control Without Reliability</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Analysis and Design of an Adaptive Virtual Queue (AVQ) Algorithm for Active Queue Management</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kunniyur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An Axiomatic Theory of Fairness</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabharwal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">H-TCP Protocol for High-Speed Long Distance Networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Leith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shorten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PFLDNet</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Mascolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Casetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sanadidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Wang</forename><surname>Westwood</surname></persName>
		</author>
		<title level="m">Bandwidth Estimation for Enhanced Transport over Wireless Links. In MobiCom</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Stochastic Fairness Queueing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Mckenney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Geometric Modeling Using Octree Encoding</title>
		<author>
			<persName><forename type="first">D</forename><surname>Meagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Image Processing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="129" to="147" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">K</forename><surname>Nichols</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Controlling Queue Delay. ACM Queue</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2012-05">May 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Decentralized POMDPs</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Oliehoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reinforcement Learning: State of the Art, Adaptation, Learning, and Optimization</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="471" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">CHOKe-A Stateless Active Queue Management Scheme for Approximating Fair Bandwidth Allocation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Psounis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A Binary Feedback Scheme for Congestion Avoidance in Computer Networks</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Comp. Sys</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="181" />
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">The Mathematics of Internet Congestion Control</title>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Birkhauser</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Making Large Scale Deployment of RCP Practical for Real Networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dukkipati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A Compound TCP Approach for High-speed and Long Distance Networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sridharan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Automating the Initial Window in TCP</title>
		<author>
			<persName><forename type="first">J</forename><surname>Touch</surname></persName>
		</author>
		<ptr target="http://tools.ietf.org/html/draft-touch-tcpm-automatic-iw-03" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A New Congestion Control Scheme: Slow Start and Search (Tri-S)</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">FAST TCP: Motivation, Architecture, Algorithms, Performance</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hegde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. on Networking</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1246" to="1259" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">End-to-End Transmission Control by Modeling Uncertainty about the Network State</title>
		<author>
			<persName><forename type="first">K</forename><surname>Winstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotNets-X</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">One More Bit is Enough</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kalyanaraman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. on Networking</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1281" to="1294" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Binary Increase Congestion Control (BIC) for Fast Long-Distance Networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Harfoush</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Rhee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Stochastic Network Utility Maximisation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Transactions on Telecommunications</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="421" to="442" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
