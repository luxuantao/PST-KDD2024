<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SPARQL Basic Graph Pattern Optimization Using Selectivity Estimation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Markus</forename><surname>Stocker</surname></persName>
							<email>markus.stocker@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratories Bristol United Kingdom</orgName>
								<orgName type="institution">HP</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andy</forename><surname>Seaborne</surname></persName>
							<email>andy.seaborne@hp.com</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Laboratories Bristol United Kingdom</orgName>
								<orgName type="institution">HP</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Abraham</forename><surname>Bernstein</surname></persName>
							<email>bernstein@ifi.uzh.ch</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">University of Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christoph</forename><surname>Kiefer</surname></persName>
							<email>kiefer@ifi.uzh.ch</email>
							<affiliation key="aff3">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">University of Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dave</forename><surname>Reynolds</surname></persName>
							<email>dave.reynolds@hp.com</email>
							<affiliation key="aff4">
								<orgName type="laboratory">Laboratories Bristol United Kingdom</orgName>
								<orgName type="institution">HP</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">SPARQL Basic Graph Pattern Optimization Using Selectivity Estimation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8707A924FBE0F179838FA9CDEF409092</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.4 [Database Management]: Systems-query processing Algorithms</term>
					<term>Performance SPARQL</term>
					<term>query optimization</term>
					<term>selectivity estimation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we formalize the problem of Basic Graph Pattern (BGP) optimization for SPARQL queries and main memory graph implementations of RDF data. We define and analyze the characteristics of heuristics for selectivitybased static BGP optimization. The heuristics range from simple triple pattern variable counting to more sophisticated selectivity estimation techniques. Customized summary statistics for RDF data enable the selectivity estimation of joined triple patterns and the development of efficient heuristics. Using the Lehigh University Benchmark (LUBM), we evaluate the performance of the heuristics for the queries provided by the LUBM and discuss some of them in more details.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>In this paper, we focus on selectivity-based static Basic Graph Pattern (BGP) optimization for SPARQL queries <ref type="bibr" target="#b14">[14]</ref> and main memory graph implementations of RDF <ref type="bibr">[9]</ref> data. In SPARQL, a BGP is a set of triple patterns where a triple pattern is a structure of three components which may be concrete (i.e. bound) or variable (i.e. unbound). The three components which form a triple pattern are respectively called the subject, the predicate and the object of a triple pattern. Sets of triple patterns, i.e. Basic Graph Patterns, are fundamental to SPARQL queries as they specify the access to the RDF data.</p><p>Query optimization is a fundamental and crucial subtask of query execution in database management systems. We focus on static query optimization, i.e. a join order optimization of triple patterns performed before query evaluation. The optimization goal is to find the execution plan which is expected to return the result set fastest without actually executing the query or subparts. This is typically solved by means of heuristics and summaries for statistics about the data.</p><p>The problem we are going to tackle in this paper is best explained by a simple example. Consider the BGP displayed in Listing 1 which represents a BGP of a SPARQL query executed over RDF data describing the university domain. Typically, there are a number of different subjects working, teaching, and studying at a university (e.g. staff members, professors, graduate, and undergraduate students). They are all of type Person in our RDF dataset. We know that the dataset contains a huge number of RDF resources of type Person among others of type Publication, Course, Room.</p><p>The OWL <ref type="bibr" target="#b1">[1]</ref> schema ontology used to describe the vocabulary for the RDF dataset states that the property for the social security number is inverse functional. Therefore, the object of the property uniquely determines the subject. Hence, the second triple pattern in our BGP of Listing 1 matches only one subject with the social security number "555-05-7880". Our schema ontology specifies further that the domain of the social security number property is a class of type Person. Therefore, we can state that the subject with social security number "555-05-7880" is of type Person (or our data is inconsistent).</p><p>The question is in which order a query engine should execute the two triple patterns. Given the research on join order strategies that has been pursued for relational database systems, we can safely state that a query engine should execute first the second triple pattern as its result set is considerably smaller compared to the result set of the first triple pattern. Therefore, a static optimizer should reverse the triple patterns. The join over the subject variable will be less expensive and the optimization eventually lead to better query performance. Note that, as the ontology schema specifies that the domain of the property for the social security number is a class Person, and provided that the data is Listing 1: Example BGP ?x r d f : type uv : Person . ?x uv : h a s S o c i a l S e c u r i t y N u m b e r "555 -05 -7880" consistent, a static optimizer may even drop the first triple pattern as, in our example, a subject with a social security number has to be of type Person.</p><p>The main contributions of this paper are (1) a framework for static optimization of Basic Graph Patterns, (2) a set of heuristics for the selectivity estimation of joined triple patterns, (3) a proposal for summary statistics of RDF data to support heuristics in their selectivity estimation, and (4), a query performance evaluation for the heuristics that underlines the importance of query optimization for RDF query engines.</p><p>The focus in our work is on main memory graph implementations of RDF data (i.e. in-memory models). Currently most RDF toolkits support both in-memory and on-disk models. Relational database management systems (RDBMS) are commonly used as persistent triple stores for on-disk models. Because of the fundamentally different architectures of in-memory and on-disk models, the considerations regarding query optimization are very different. Whereas query engines for in-memory models are native and, thus, require native optimization techniques, for triple stores with RDBMS back-end, SPARQL queries are translated into SQL queries which are optimized by the RDBMS. It is not our goal in this paper to analyze optimization techniques for on-disk models and, hence, we are not going to compare inmemory and on-disk models. Furthermore, we focus on the evaluation of the presented optimization techniques without comparing the figures with the performance of alternative implementations. A comparison of implementations requires a comprehensive study that goes beyond the scope of this paper. In fact, the query performance of query engines is not just affected by static query optimization techniques but, for instance, also by the design of index structures or the accuracy of statistical information. Finally, our focus is on static query optimization techniques. Hence, we do not discuss optimal index structures for RDF triple stores, neither in-memory nor on-disk, as this too is a research topic that goes beyond the scope of this paper.</p><p>Our focus on main memory graph implementations, i.e. inmemory models, has an important limitation: scaling. Indeed, the few gigabytes of main memory clearly limit the size of RDF data which may be processed in main memory. Therefore, we might question the relevance of studying optimization techniques for RDF in-memory models. We argue, that in-memory models are important for a number of reasons. First, optimized queries on in-memory models run much faster than on-disk. Second, 64-bit architectures pose virtually no more limits to the theoretical amount of main memory in computers. Third, in a cluster, distributed in-memory models could be used for parallel query evaluation. Finally, optimization techniques and customized summary statistics of RDF data are important for native RDF persistent stores as they do not rely on relational database technology and, hence, require a native optimizer.</p><p>We believe, native optimization techniques and optimized summary statistics of RDF data are a key requirement for efficient SPARQL query evaluation on the Semantic Web.</p><p>The paper is organized as follows. In Section 2, we succinctly discuss related work and set our work in context. In Section 3, we present the theoretical background, the architecture, and the proposed heuristics implemented for the Jena ARQ <ref type="bibr" target="#b5">[5]</ref> optimizer. In Section 4, we discuss our approach for summary statistics of RDF data, i.e. meta information about RDF data used for selectivity estimation of joined triple patterns. Section 5 describes our approach for selectivity estimation of (joined) triple patterns. Finally, in Section 6, we present the query performance evaluation we conducted for the optimizer and the proposed heuristics. We close the paper with future work and limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>The execution time of queries is heavily influenced by the number of joins necessary to find the results of the query. Therefore, the goal of query optimization is (among other things) to reduce the number of joins required to evaluate a query. Such optimizations typically focus on histogrambased selectivity estimation of query conditions.</p><p>Piatetsky et al. introduce in <ref type="bibr" target="#b12">[12]</ref> the concept of selectivity estimation of a condition. In <ref type="bibr" target="#b15">[15]</ref> Selinger et al. present the System R optimizer, a dynamic programming algorithm for the optimization of joins. Likewise, POSTGRES <ref type="bibr" target="#b17">[17]</ref> implements an exhaustive search optimization algorithm. In contrast, INGRES <ref type="bibr" target="#b18">[18]</ref> introduced an optimization technique based on query decomposition. Estimation of conditions are often supported by histogram distributions of attribute values <ref type="bibr" target="#b10">[10]</ref>. More recently, developments in deductive and object oriented database technology showed the need for more cost-effective optimization techniques <ref type="bibr" target="#b16">[16]</ref> as the traditional techniques work well for queries with only a few relations to join. Steinbrunn et al. summarizes and analyzes in <ref type="bibr" target="#b16">[16]</ref> randomized algorithms for the problem of query optimization where the overall goal is to search the solution space for the global minima moving randomly between connected solutions according to certain rules. Further, the authors describe deterministic, genetic and hybrid algorithms as techniques for the problem of cost-effective query optimization. PostgreSQL is and example of an open source databases system experimenting with genetic algorithms for query optimization. <ref type="foot" target="#foot_0">1</ref>Related to the Semantic Web, <ref type="bibr">Pérez et al.</ref> analyze in <ref type="bibr" target="#b11">[11]</ref> the semantics and complexity of SPARQL. Harth et al. <ref type="bibr" target="#b7">[7]</ref> investigate the usage of optimized index structures for RDF. The authors argue that common RDF infrastructures do not support specialized RDF index structures. The index proposed by the authors supports partial keys and allows selectivity computation for single triple patterns. Hartig et al. <ref type="bibr" target="#b8">[8]</ref> present a SPARQL query graph model (SQGM) which supports all phases of query processing, especially query optimization. The authors refer to a discussion on the Jena mailing list which showed that a simple rearrangement of a SPARQL query leads to an improvement of factor 220. <ref type="foot" target="#foot_1">2</ref>The concepts and ideas presented in this paper are inspired by and rely on some previous, unpublished, own work.  In <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b3">3]</ref> the authors describe the fundamental techniques which are further extended in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE OPTIMIZER</head><p>In this section, we first discuss the preliminaries and formalize the theory underlying the optimizer and the heuristics. Second, we present the architecture of the optimizer and we describe its components. Finally, we discuss the heuristics used for selectivity estimation of graph patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preliminaries</head><p>For a better understanding, we develop the theory by means of the example BGP displayed in Listing 2 (i.e. the WHERE clause of the Lehigh University Benchmark (LUBM) <ref type="bibr" target="#b6">[6]</ref> Query 2).</p><p>Given a BGP, B, we define B to be a graph G as a set G of undirected connected graphs. The elements g ∈ G are the components of G. For each pair (gi, gj) ∈ G, gi and gj are disconnected. Note that the elements g ∈ G have different semantics than RDF graphs, i.e. the nodes of g ∈ G are triple patterns.</p><p>A graph g ∈ G is represented as an ordered pair g := (N , E), where N is an unordered set of distinct triple patterns (i.e. the nodes of g) and E is an unordered set of distinct triple pattern pairs (i.e. the edges of g).</p><p>A triple pattern pair shares at least one bound or unbound component. The subject, predicate, and object are the components of a triple (pattern) <ref type="bibr">[9]</ref>. In this paper, we refer to triple pattern pairs as joined triple patterns. Hence, two triple patterns with a shared variable are joined as well as two triple pattern with, for instance, the same subject URI.</p><p>In Figure <ref type="figure" target="#fig_1">1</ref>, we display the undirected connected graph g1 ∈ G for the BGP in Listing 2. As the BGP triple patterns in Listing 2 are (transitively) joined, the graph G has only one component, thus G contains only the connected graph g1. Note, that the numbers used for the nodes of g1 in Figure <ref type="figure" target="#fig_1">1</ref> correspond to the numbers of the triple patterns of the BGP in Listing 2. Further, note that, for the sake of simplicity, in Figure <ref type="figure" target="#fig_1">1</ref> (and generally in our working example) we consider only joins defined by unbound components (i.e. variables). This is a specialization of the more general case described For a BGP B the execution order of pairwise disconnected graphs (gi, gj) ∈ G does not affect query performance as the overall result set corresponds to the Cartesian product of the result sets for gi and gj. Therefore, we can reduce the optimization problem for B to the optimization of each g ∈ G. In the following, we focus on the optimization of connected graphs g ∈ G.</p><p>Definition 1. The size N of g ∈ G is the number of nodes of g, i.e. the number of triple patterns in g. Definition 2. An execution plan pg for g ∈ G is a well defined order for the nodes of g. Definition 3. The set Pg is the execution plan space of g ∈ G. An execution plan pg ∈ Pg is an element of the space. The size of Pg is the total number of execution plans for g ∈ G.</p><p>Given the size N of g ∈ G, the size of Pg is N ! (on single processor machines). <ref type="foot" target="#foot_2">3</ref> Therefore, the expanded execution plan space Pg is potentially huge even for a simple BGP with only a few triple patterns.</p><p>An execution plan pB for a BGP B is an unordered set, Q, whose elements are execution plans pg. The size of Q equals the size of G, i.e. every connected graph g ∈ G has an associated execution plan pg ∈ Pg which is an element of Q.</p><p>An execution plan pg ∈ Pg can be represented as a directed acyclic graph (DAG). We define Dg as the set of directed acyclic graphs for the execution plans in Pg. Each DAG dg ∈ Dg represents one or more execution plans pg of an undirected connected graph g ∈ G. In Figure <ref type="figure" target="#fig_0">2</ref> we show the DAG corresponding to the execution plan pg which executes the BGP of Listing 2 top-down, i.e. the triple patterns are evaluated in the same order as they are listed in Listing 2. For any two nodes (i, j) ∈ dg, there is a directed path between i and j, if (1) the triple patterns corresponding to i and j are (transitively) joined and (2) i is executed first in the execution plan. There is a clear relationship between the set Pg of execution plans pg and the set Dg of directed acyclic graphs dg. More formally, we can state the following function f : pg → dg that is injective and not surjective. Thus, an execution plan pg can be mapped uniquely to a DAG dg, whereas a DAG dg is an abstraction for one or more execution plans pg. For instance, the execution plan which executes the triple patterns of the BGP in Listing 2 top-down, i.e. the sequence <ref type="bibr" target="#b1">(1,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b6">6)</ref> of triple patterns, is uniquely mapped to the DAG displayed in Figure <ref type="figure" target="#fig_0">2</ref>. However, the DAG in Figure <ref type="figure" target="#fig_0">2</ref> is also an abstraction for the execution plan expressed by the sequence (2, 3, 1, 4, 5, 6) of triple patterns. The size of Dg is, hence, generally not equal to the size of Pg.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Architecture</head><p>In this section, we present the architecture of the optimizer implemented in ARQ. The optimizer consists of three main components: (1) the BGP abstraction, (2) the core optimization algorithm, and (3) the extensible pool of selectivity estimation heuristics.</p><p>The selectivity estimation of graph patterns is fundamental for the optimization of basic graph patterns. According to <ref type="bibr" target="#b12">[12]</ref>, the selectivity of a condition is the fraction of tuples satisfying the condition. In our domain, the selectivity of a (joined) triple pattern is the fraction of triples matching the pattern. For a typical dice, the selectivity of even numbers is 0.5. Refer to Section 5 for a detailed discussion about RDF selectivity estimation for our purpose of BGP optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>BGP Abstraction.</head><p>As discussed in Section 3.1, we abstract a BGP as an undirected graph B which is characterized by the connected components g ∈ G, where each g is an ordered pair g = (N , E) consisting of a set N of triple patterns (i.e. the nodes of g) and a set E of triple pattern pairs (i.e. joined triple patterns/edges of g). The connected graph g ∈ G represents a subset of (transitively) joined triple patterns of B. In the following we describe the algorithm for the optimization of g = (N , E).</p><p>Based on the BGP abstraction for g ∈ G, we perform a variation of the deterministic minimum selectivity approach <ref type="bibr" target="#b16">[16]</ref> to identify the execution plan pg which is optimal according to the algorithm and the selectivity estimations. The optimization algorithm constructs a solution in a deterministic manner applying a heuristic search. Eventually, the algorithm identifies an order for the elements of the set N (i.e. triple patterns). Note that this is not a total order on N . The triple patterns in the resulting execution plan are not necessarily ranked by estimated selectivity.</p><p>Optimization Algorithm. In Algorithm 1, we provide the pseudo-code for the core optimization algorithm. The algorithm first selects the edge with minimum estimated selectivity from g = (N , E). The corresponding nodes are marked as visited and added to the final execution plan pg ordered by estimated selectivity, i.e. the more selective node is added first to the execution plan. After selecting the first edge e ∈ E, the core optimization algorithm iteratively selects the edge which satisfies the two properties (1) minimum estimated selectivity and (2) visited node. With each iteration a new node is added to the final execution plan.</p><p>The property of minimum estimated selectivity is motivated in the deterministic minimum selectivity optimization approach according to which good solutions are generally characterized by selective intermediate results <ref type="bibr" target="#b16">[16]</ref>. The second property, i.e. visited node, ensures the iterative selection of a triple pattern, i.e. a node n ∈ N , which joins with the previous partial execution plan. This is an important characteristic of good execution plans as result sets will never  The algorithm terminates when all nodes n ∈ N have been visited and the optimal execution plan pg, i.e. a well defined order for the elements of N , is returned as a result.</p><p>Directed acyclic graphs of execution plans which satisfy the second property, i.e. visited node, of the edge selection process for BGP abstractions described above, feature a common characteristic: there is only one node that has only outgoing directed edges, i.e. the node which is executed first in the execution plan. Nodes with only outgoing directed edges do not join with the previous partial execution plan and, hence, result in a Cartesian product of two intermediate result sets. For instance, the execution plan which executes the triple patterns of Listing 2 top-down, abstracted as DAG in Figure <ref type="figure" target="#fig_0">2</ref>, creates two Cartesian products for the intermediate result sets of the first three triple patterns (highlighted in Figure <ref type="figure" target="#fig_0">2</ref> by the three nodes labeled 1, 2, and 3 which are nodes with only outgoing directed edges). In contrast, the optimized execution plan, abstracted as DAG in Figure <ref type="figure" target="#fig_3">3</ref>, does never create Cartesian products of intermediate result sets. This is highlighted by the DAG in Figure <ref type="figure" target="#fig_3">3</ref> with one node with only outgoing directed edges (i.e. node 5). This node represents the first triple pattern in the optimized execution plan for the BGP in Listing 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Selectivity Estimation Heuristics.</head><p>In order to decide the selection of edges during the optimization process, the core optimization algorithm requires figures about the selectivity <ref type="bibr" target="#b12">[12]</ref> of graph patterns. The extensible pool of selectivity estimation heuristics is the component intended to provide the required selectivity figures to the core optimizer.</p><p>Heuristics are used to weight the nodes and edges of a BGP abstraction. Given a weighted connected graph g ∈ G the core optimization algorithm is able to proceed with the iterative selection of nodes based on the deterministic minimum selectivity optimization approach described above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Heuristics</head><p>In this section, we present the heuristics implemented and used by the optimizer for the selectivity estimation of graph patterns. We categorize the heuristics according to whether or not they require pre-computed statistics about the RDF data.</p><p>Heuristics Without Pre-computed Statistics. The simplest heuristic, ARQ/VC, is called variable counting. For this heuristics, the selectivity of a triple pattern is computed according to the type and number of unbound components and is characterized by the ranking sel(S) &lt; sel(O) &lt; sel(P ), i.e. subjects are more selective than objects and objects more selective than predicates. Whether subjects are more selective than objects (or predicates) effectively depends on the RDF data. In typical RDF datasets, there are more triples matching a predicate than a subject or an object. The distinction between subject and object is more difficult. The ranking we have chosen is clearly a pragmatic choice. The selectivity of a joined triple pattern is computed according to the type and number of joins (either bound or unbound). Bound joins are considered more selective than unbound joins and subject-subject joins are more selective than subject-object or object-object joins. Unusual joins (e.g. subject-predicate) are considered the most selective. Note that the specific choice on how to estimate the selectivity of (joined) triple patterns without any statistics is certainly arguable.</p><p>The variable counting predicates heuristic, ARQ/VCP, is very close to ARQ/VC. In fact, the only difference is a default selectivity of 1.0 for triple patterns joined by bound predicates. For certain queries, estimating patterns joined by bound predicates as selective can be a bad choice. For instance, consider the two patterns [?x rdf:type C] and [?y rdf:type D]. Typically, both patterns return a considerable result set and it is generally a bad choice to estimate the pattern as selective. Refer to our evaluation in Section 6 for a practical example where this heuristic has a high impact on query performance (LUBM Query 2).</p><p>The graph statistics handler, ARQ/GSH, is the heuristic with the most accurate estimation for the selectivity of triple patterns. However, the selectivity estimation of joined triple patterns is not supported (instead we use ARQ/VC). The high accuracy of this heuristic is enabled by the underlying Jena <ref type="bibr" target="#b5">[5]</ref> in-memory graph which enables for certain graph implementations to look-up for exact size information of any triple pattern component. We use such information to compute selectivities. The Jena graph implementation for non-inference in-memory models supports the look-up for the number of triples matching either a subject, a predicate or an object of a triple pattern. Note that, combinations (e.g. subject-predicate) are not supported by the graph implementation. Moreover, Jena graph implementations for inference models currently do not support graph statistics. In absence of a graph statistics handler for the graph the optimizer chooses the default heuristic, ARQ/VC. Heuristics With Pre-computed Statistics. The probabilistic framework (PF) is a standalone framework for the selectivity estimation of RDF graph patterns (Section 5). It implements selectivity estimation techniques based on statistics about RDF data (Section 4). A wrapper around the PF implements the ARQ/PF heuristic for the optimizer en-abling the selectivity estimation of triple patterns and joined triple patterns. Although, the heuristic requires statistics about the RDF data which have to be previously computed, heuristics based on the PF are, in average, the most accurate. Whereas ARQ/GSH only supports non-inference graph models, we can build the statistics required for the PF by computing the summary statistics of an inference model. Moreover, heuristics based on the PF are the most accurate for the selectivity estimation of joined triple patterns as the PF creates customized statistics about joined RDF graph patterns.</p><p>Based on the probabilistic framework, we implement another heuristic, called ARQ/PFJ. There are two differences to ARQ/PF. First, the estimated selectivity for joined triple patterns is a function of the estimated join selectivity and the selectivity of the more selective triple pattern involved in the join. This is slightly different to ARQ/PF where the selectivity for joined triple patterns is a function only of the estimated join selectivity. Second, ARQ/PFJ does not consider bound predicates, similar to ARQ/VCP.</p><p>The last presented heuristic is called ARQ/PFN and is a variation of ARQ/PF, hence, it is also based on the PF. The primary goal of the PF is to estimate as accurate as possible the selectivity of graph patterns (with one or two triple patterns). Since the estimated selectivity might be lower than the minimum meaningful selectivity for some RDF data (i.e. the selectivity of matching one triple) the probabilistic framework limits the estimated selectivity to this minimum. As limiting the lower bound for the estimated selectivity has a positive effect for the accuracy of the framework, it might have a negative effect for our purpose of optimization. In fact, the estimation error does not affect the performance of the optimizer as long as the order of triple patterns is correct. Hence, although the estimation might be off the boundaries, the performance of the optimizer in ordering triple patterns might be higher. Based on this observation, ARQ/PFN does not limit the lower bound of selectivity estimation (whereas ARQ/PF does). LUBM Query 12 in our evaluation in Section 6 is an example where limiting forces the optimizer to select a wrong order for the triple patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SUMMARY STATISTICS FOR RDF</head><p>Maintaining summaries for the statistics about the data stored in databases has a long tradition in database technology. Such meta information on the distribution of data is used as an efficient way to estimate cardinalities during query processing for a number of tasks (e.g. static query optimization, result set size estimation). Histograms are typically used to represent the distribution of data <ref type="bibr" target="#b13">[13]</ref>. In this section, we describe in detail the statistics required by the probabilistic framework (PF) to estimate the selectivity of (joined) triple patterns.</p><p>The need for customized summary statistics of RDF data for the purpose of BGP optimization is motivated by at least the following two arguments. First, our architecture discussed in Section 3 requires selectivity information to weight the nodes n ∈ N (i.e. triple patterns) and edges e ∈ E (i.e. joined triple patterns) for every connected component g ∈ G of the graph G, the abstraction of the BGP B. Second, RDF graph patterns are typically characterized by a large number of joins. The attribute value independence assumption discussed in database literature <ref type="bibr" target="#b13">[13]</ref> is perhaps the most difficult challenge also for the cardinality estimation of RDF graph patterns. Therefore, tailored summaries for the statistics of RDF data are required to accurately estimate the selectivity of graph patterns.</p><p>We have chosen a pragmatic solution which is shown to be a reasonable compromise between statistical expressivity, achieved optimizations, and the size of the summary. In the following, we first discuss the required statistics for the selectivity estimation of triple patterns. Afterwards, we focus on the statistics for joined triple patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Triple Pattern Statistics</head><p>Triple pattern components may be bound (i.e. concrete) or unbound (i.e. variable). Thus, we have to consider two dimensions: the first dimension includes the subject, the predicate, and the object of a triple pattern, whereas the second dimension differentiates between bound and unbound components.</p><p>The case of unbound components is trivial as they do not affect the required statistics. However, we need to differentiate the case of bound components as they require different statistics. Note that in the following we refer to the number of triples matching a pattern as the size of the pattern. As discussed in Section 5, the size is strongly related to the selectivity. Hence, given an approximation for the size, it will be straightforward to compute the selectivity.</p><p>The size of a bound subject is approximated as the average number of triples matching a subject, i.e. the average number of triples for an RDF resource. Thus, the total number of triples and the total number of distinct subjects are the statistics required to estimate the size of a bound subject. The size of a bound predicate is the number of triples matching the predicate. We compute the exact statistics for each distinct predicate contained in the summarized RDF data, i.e. the exact number of triples matching a predicate. Finally, the size of a bound object is approximated by means of classical equal-width histograms <ref type="bibr" target="#b12">[12]</ref>. For each distinct predicate we compute a histogram to represent the corresponding object-value distribution. <ref type="foot" target="#foot_4">4</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Joined Triple Pattern Statistics</head><p>Schema ontologies provide useful information about the relations of classes and properties of vocabularies used in RDF data.</p><p>For our purpose, we especially look at rdf:Property instances which are related together because of a matching rdfs:Class instance for their domain or range. For instance, a property p1 with domain C and a property p2 with domain C are related because they both define the same class C as domain. We take into account not only matching domains but also domain and range or only ranges.</p><p>Given two related properties p1, p2 and their join relation (relation type), i.e. whether they define the same class C for their domains, domain/range, range/domain or both ranges, we compute the size of the corresponding BGP as the result set size of a SPARQL query. For instance, for p1 and p2 with a relation type SS (i.e. the two properties define the same class C for their domains), the corresponding BGP might be described by the two triple patterns [?x p 1 ?y] and [?x p2 ?z]. The returned size is used as an upper bound for the size of any BGP involving the two properties p1 and p2 with join relationship SS.</p><p>In real world queries, joined triple patterns do not always have unbound subjects and objects. For instance, the BGP B with the two triple patterns [?x p1 C] and [?x p2 ?y] (where C is a bound object) is potentially more selective than the BGP B with the patterns [?x p1 ?y] and [?x p2 ?z]. Though, the summary supports accurate size information only for the BGP B . In order to consider the object restriction for B, the size of B is a function of the upper bound size (i.e. the size of B ) and the size of the restricted object (which is a look-up in the histogram of p1 for C).</p><p>Often the schema of an ontology is not available, which makes it impossible to get the required insights on related properties. For this reason, we create a full summary of all combinations of distinct predicates defined in the summarized RDF data. Certainly, a schema would greatly reduce the summary size because related predicates are explicitly defined. However, in absence of the schema, it would not be possible to create the summary.<ref type="foot" target="#foot_5">5</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Summary Features</head><p>Summarizing statistics for RDF data is a process which is performed separately from and prior to query execution. Thus, statistics are, generally, not computed during query evaluation. The size of the summary, i.e. the required memory space, is most influenced by the number of distinct predicates as they characterize the number of histograms and joined patterns indexed in the summary. As long as the number of distinct predicates is constant, a growing RDF dataset does not affect the size of the summary. A growing RDF dataset does, however, affect the figures representing the statistics in the summary. The size of the summary is typically of multiple orders of magnitude smaller than the size of the RDF dataset. We represent the summary in RDF and typically serialize it as RDF/XML <ref type="bibr" target="#b2">[2]</ref>.</p><p>Gathering the statistics on joined triple patterns (Section 4.2) is the most expensive task in the process of summary computation. The number of entries in the summary is a quadratic function of the number of distinct predicates, more precisely f (n) = 4n 2 , where n is the number of distinct predicates. For instance, for an ontology with 14 distinct predicates, the summary for joined triple patterns is of size 784.</p><p>In real world settings, ontologies often have more than just 10 or 20 distinct predicates. For this reason, we allow specific configurations (i.e. manual intervention) to potentially improve the performance. The summary can be computed either with full support for both triple pattern and joined triple pattern selectivity estimation or with partial support for selectivity estimation of triple patterns only. Building the statistics to support triple pattern selectivity estimation is, compared to the full summary, much faster. However, it is a trade-off between time and accuracy as the accuracy of joined triple pattern selectivity estimation will be lower with a partial summary. Further, the summary supports a property exclusion list. Thus, we can specify a set of properties which are ignored during the process. This is useful especially in environments where the query patterns are known. The technique may potentially significantly reduce the time required to built the summary without loss of accuracy for the specific queries. Finally, we support random sampling of RDF data. Given a set of triple statements T and a sampling percentage, the sampling technique randomly selects triple statements from T to create a new set of statements of the size according to the given sampling percentage. This new set will be used to compute the statistics. Sampling is potentially useful for large RDF datasets at the cost, however, of a loss of accuracy. Note that it is not our intention to comprehensively analyze sampling techniques for RDF data in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RDF SELECTIVITY ESTIMATION</head><p>In this section we describe the framework for RDF selectivity estimation. The probabilistic framework (PF) is intended to provide selectivity information for (joined) triple patterns of basic graph patterns.</p><p>The framework builds on top of the summary statistics for RDF data discussed in Section 4 and implements a simple interface that provides two methods: one for the selectivity estimation of triple patterns and one for the selectivity estimation of joined triple patterns. Heuristics based on the probabilistic framework (Section 3.3) implement wrappers around these two methods and, hence, provide selectivity information for the optimization of basic graph patterns.</p><p>The selectivity of a pattern is strongly related to its probability. Both the selectivity and the probability accept real values of the interval [0, 1]. Selective patterns, e.g. [ex:s ex:p ex:o], have a selectivity value that approaches the lower bound of the interval, i.e. 0. Selective patterns have a low probability to match triples in some RDF dataset. On the contrary, unselective patterns, e.g. [?s ?p ?o], have a selectivity value that approaches the upper bound of the interval, i.e. 1. Unselective patterns have a high probability to match triples in some RDF dataset. This definition is valid for both triple patterns and joined triple patterns. Note that this might be in contrast with the definition for selectivity in other parts of the literature, in which the selectivity is the inverse of the probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Triple Pattern Selectivity</head><p>The selectivity of a triple pattern is estimated by the formula sel(t) = sel(s) × sel(p) × sel(o) where sel(t) denotes the selectivity for the triple pattern t, sel(s) the selectivity for the subject s, sel(p) the selectivity for the predicate p, and sel(o) the selectivity for the object o. The (estimated) selectivity is a real value in the interval [0, 1] and corresponds to the (estimated) number of triples matching a pattern, i.e. the size (Section 4), normalized by the total number of triples in the RDF dataset. Note that this formulation only approximates sel(t) as it implicitly assumes that sel(s), sel(p), and sel(o) are statistically independent, which they will not be in most cases.</p><p>The selectivity of unbound triple pattern components, i.e. the selectivity of a variable subject, predicate, or object, is generally 1.0 as an unbound component essentially matches every triple in the dataset.</p><p>In the following, we discuss the selectivity of bound components. The selectivity of a bound subject is estimated by the formula sel(s) = 1 R where R denotes the total number of resources in the RDF dataset. 6 Note that the estimated selectivity for a bound subject is constant in our model. The selectivity of a bound predicate is computed by the formula sel(p) = Tp T where Tp is the number of triples matching predicate p and T is the total number of triples in the RDF dataset. Note that, as discussed in Section 4, the summary provides exact figures for Tp and T . Therefore, the selectivity of p is exact and not an estimation.</p><p>The selectivity of a bound object is estimated by the formula</p><formula xml:id="formula_0">sel(o) = sel(p, oc), if p is bound; È p i ∈P sel(pi, oc), otherwise.<label>(1)</label></formula><p>where the pair (p, oc) represents the class of the histogram for predicate p in which object o falls, and sel(p, oc) = hc(p,oc) Tp denotes the frequency of class (p, oc) normalized by the number of triples matching predicate p. If the predicate is unbound, the histogram of each predicate is considered for the object selectivity estimation, i.e. the selectivity of the object is the sum of sel(pi, oc) for each predicate pi ∈ P in the summary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Joined Triple Pattern Selectivity</head><p>The selectivity estimation of joined triple patterns is supported by the summary described in Section 4.2. The summary provides upper bound sizes for related predicates with unbound subjects and objects, where size denotes the result set size of a joined triple pattern. Given the upper bound size SP for a joined triple pattern P , the selectivity of P is estimated as</p><formula xml:id="formula_1">sel(P ) = SP T 2<label>(2)</label></formula><p>where T 2 denotes the square of the total number of triples in the RDF dataset. The square of the total number of triples equals the size of the Cartesian product of two triple patterns with pairwise distinct unbound components.</p><p>The selectivity computed by Equation 2 is corrected by a specific factor for joined triple patterns with bound subjects or objects. This factor is a function of the selectivities for the bound components (subject and object) of the triple patterns. For instance, if the pattern P is joined over the subjects by a variable and the first triple pattern has a bound object O, i.e. P contains the triple pattern [?x p1 O] and [?x p2 ?y], the selectivity of P is estimated as</p><formula xml:id="formula_2">sel(P ) = SP T 2 × sel(p1, oc)<label>( 3 )</label></formula><p>where sel(p1, oc) is the object selectivity of the first triple pattern in P (Equation <ref type="formula" target="#formula_0">1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EVALUATION</head><p>In this section, we present the results of our evaluation based on the Lehigh University Benchmark (LUBM) <ref type="bibr" target="#b6">[6]</ref>. The LUBM features an OWL ontology for the university domain, enables scaling of datasets to an arbitrary size, and 6 Note that this is in accordance with the description in Section 4.1. In fact, sel(s)</p><formula xml:id="formula_3">= T R T = T R × 1 T = 1 R</formula><p>, where T denotes the total number of triples. provides 14 extensional queries. Our evaluations are performed on a dataset containing the description of a single university (the LUBM University0) and the OWL-DL entailed statements. The total number of triples on which we perform the evaluations is 156,407. First, we evaluate the query performance for the 14 LUBM queries using ARQ and the optimizer with the heuristics discussed in this paper (Section 3.3). Second, we evaluate the performance of the optimizer using summaries for the statistics of sampled LUBM datasets where samples are created by randomly selecting statements from the full dataset. Finally, in our third evaluation we explore the execution plan space of the 14 queries and identify the position that ARQ and the optimization heuristics occupy within this space. This allows us to investigate whether or not our heuristics are able to find the best execution plan for the queries. Moreover, we can compute an average distance (in execution plans) from the best performing plan for each heuristic and the 14 LUBM queries.</p><p>We align the performance of ARQ with disabled optimizer (ARQ/OFF) as a reference for the performance of the heuristics implemented by the ARQ optimizer. All evaluations are performed on a Red Hat Linux empowered AMD Opteron TM dual core machine with 8GB main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Query Performance</head><p>The query performance evaluation for the LUBM is summarized in Figure <ref type="figure" target="#fig_4">4</ref>. The LUBM specifies some queries that are more interesting for the purpose of BGP optimization than others. Some queries define a BGP with a substantial number of triple patterns and joins between them, e.g. Queries 2 and 9. Others are more simple and contain just one triple pattern, e.g. Queries 6 and 14, or two triple patterns, e.g. Queries 1, 3, 5, 10, 11, and 13. Hence, it is not surprising that for certain queries no optimization is achieved at all. Figure <ref type="figure" target="#fig_4">4</ref> summarizes the query performance for 4 queries of the LUBM. On one dimension we show the LUBM queries. The second dimension shows the absolute values for the query performance in milliseconds on a logarithmic scale. The figure compares the performance for ARQ with disabled optimizer (ARQ/OFF) and ARQ with the heuristics discussed in Section 3.3, i.e. the variable counting (AR-Q/VC), the variable counting (no) predicates (ARQ/VCP), the graph statistics handler (ARQ/GSH), the probabilistic framework (ARQ/PF), the probabilistic framework without limit for the lower bound of selectivity estimation (AR-Q/PFN) and, finally, the heuristic based on the probabilistic framework with a different selectivity estimation for joined triple patterns (ARQ/PFJ).</p><p>Query 1 is similar to our example query in Listing 1 as it defines a BGP with two triple patterns. A simple rearrangement for the two triple patterns leads to a performance improvement of one order of magnitude.</p><p>Query 2 is interesting for multiple reasons. First, the achieved optimization is of four orders of magnitude for the heuristics based on the probabilistic framework. Second, the explicit low selectivity (1.0, i.e. unselective) of triple patterns joined by bound predicates used for ARQ/VCP avoids to first execute the three triple patterns with bound rdf:type predicates. In fact, the three triple patterns create a huge intermediate result set which is only subsequently constrained. In contrast, ARQ/GSH does estimate the first three triple patterns of the BGP as selective and, hence, executes them first in query evaluation. This results in a poor query performance although ARQ/GSH has precise selectivity information for the components of triple patterns. Of course, we can think of a heuristic that combines ARQ/GSH and ARQ/VCP which would most likely perform better than ARQ/VCP. Note that the fact that ARQ/GSH and AR-Q/VC build Cartesian products for intermediate result sets is not in contrast with the discussion in Section 3.1. If the BGP graph abstraction would not define a join for bound predicates, the algorithm would guarantee to not choose execution plans with Cartesian products as intermediate result sets. It was a design choice to define a join for every bound or unbound pair of triple pattern components to be as general as possible. In future, we might choose to ignore bound predicate joins directly in the BGP abstraction process. Finally, some words about ARQ/PF and ARQ/PFJ: the former executes the two triple patterns with empty joined result set first in the query (triple pattern 5 and 6 of LUBM Query 2). The problem is that the computation of this join is more expensive than the overall join computations for the execution plan selected by ARQ/PFJ. In fact, the first triple pattern executed by ARQ/PF matches 2414 triples, whereas the second triple pattern matches 463 triples. Although combined the result set is empty and, hence, the final result set is identified after executing the second triple pattern, the cost of executing the first join is more expensive than the total cost of three joins required to evaluate the execution plan selected by ARQ/PFJ. Note that the first triple pattern executed by ARQ/PFJ matches only 15 triples. Although, this small result set is joined another two times to get the final empty result set, it is, overall, less expensive.</p><p>The considerations for Query 9 are similar to Query 2. The achieved optimizations are of five orders of magnitude for the best performing heuristics. Again, we note that AR-Q/VCP performs optimally without requiring any statistics. Clearly, it is crucial to avoid the execution of the three triple patterns with bound rdf:type predicates first in query evaluation. The rationale is the same as for Query 2.</p><p>Query 12 is also worth a couple of words. Whereas for all other queries ARQ/PF shows a similar performance as the other heuristics based on the probabilistic framework, for Query 12 ARQ/PF clearly selects a wrong ordering of the triple patterns. This is caused by the explicit limit of the lower bound for selectivity estimation in ARQ/PF. In fact, two triple patterns of the BGP in Query 12 are estimated with the same (lowest) selectivity by ARQ/PF. By not limiting the estimation to the lowest meaningful selectiv- Whereas the accuracy of the estimation is higher for AR-Q/PF compared to ARQ/PFN, for the purpose of ordering triple patterns the limitation to the lowest meaningful selectivity is, in this case, better avoided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Sampling Performance</head><p>The sampling performance evaluation for the LUBM is summarized in Figure <ref type="figure">5</ref>. We use a random selection of statements from the original dataset to create three subsets containing respectively 0.1%, 1%, and 10% of the triples contained in the original dataset. We create the summary statistics for each sample and use them for query evaluation with the ARQ/PF heuristic. Generally, we can state that the summaries for the 0.1% sample are accurate enough to significantly improve query performance. Being more accurate, summaries of larger samples further improve the query performance, however, in most cases this improvement is not as significant as the improvement achieved by the 0.1% summary. Note that the LUBM is a synthetic RDF dataset which may bias the evaluation based on samples.</p><p>The main advantage of summaries for samples is the time required to create them. The time required to create the summary for the 0.1% sample is approximately 13 seconds while the time required to create the summary for the entire dataset is approximately 1,764 seconds (∼30 minutes).</p><p>Figure <ref type="figure">5</ref> summarizes the query performance for a subset of interesting LUBM queries. For Query 1, the summary of the 0.1% sample is clearly enough accurate to correctly reorder the simple BGP consisting of two triple patterns. Query 2 is an example where more accurate information is required to capture the peculiarity of the enough to optimize the query. Query 4 is an example where sampling worsens the performance compared to the original BGP, for the 0.1% sample. As we select the statements randomly, the resulting inaccurate statistics entice the optimizer to select a bad execution plan for the BGP. Finally, Query 9 is similar to Query 2 with the difference that the summary of the 0.1% sample is already enough accurate to optimize the query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Exploring the Execution Plan Space</head><p>In this section, we evaluate the query performance for each execution plan in the plan space of each of the 14 LUBM queries. The evaluation allows us to identify the position of the execution plans selected by the different heuristics in the plan space of each query. Moreover, it enables to identify the best and worst execution plan, and to compute the performance interval between the two boundaries. Further, we can calculate the average distance from the best performing execution plan for each heuristic.</p><p>Following the discussion in Section 3.1, the BGP of the LUBM Query 2 is abstracted as a set G = {g1} with a single connected graph g1. The size of g1 is the number of triple patterns, i.e. 6. The size of the execution plan space is, therefore, 6! = 720. Figure <ref type="figure" target="#fig_5">6</ref> shows the query execution performance for a subset of the 720 queries (execution plans) in the execution plan space of the LUBM Query 2. We highlight the execution plans which reflect the plans selected by ARQ and the optimization heuristics.</p><p>In Table <ref type="table" target="#tab_1">1</ref>, we list the query performance of the best and worst execution plan and the performance of ARQ/PFJ for the LUBM queries with at least three triple patterns. The table shows that our best performing heuristic is very close to the best performing execution plan in the space of the listed LUBM queries. Note that the plan space evaluation for the LUBM Query 9 had to be terminated after over two weeks and could not be completed.</p><p>Finally, Figure <ref type="figure" target="#fig_6">7</ref> shows the distance of ARQ with disabled optimizer (ARQ/OFF) and each optimization heuristic to the best performing execution plan normalized by the size of the plan space, averaged over the 14 LUBM queries. While ARQ with disabled optimizer (ARQ/OFF) has a normalized average distance of 0.68 from the best plan, the best performing heuristic (ARQ/PFJ) has a normalized average distance of 0.023 from the best execution plan and is, hence, very close to the best performing execution plans.</p><p>The evaluation shows that although the best performing heuristic is not always able to find the best performing execution plan, it is, however, able to identify an execution plan that, essentially, performs in average equally to the optimal execution plan. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">LIMITATIONS AND FUTURE WORK</head><p>As we argued in Section 1, scaling is one of the major limitations of the presented work. Clearly, main memory graph implementations do not scale. However, we believe that the optimization of native SPARQL query engines is, nevertheless, an important issue for an efficient query evaluation on the Semantic Web.</p><p>Basic graph patterns are fundamental to SPARQL as they define the access to the RDF graph. However, they are not the only part of the SPARQL syntax interesting for static optimizations. SPARQL includes a number of operators which are modifiers for the result sets of basic graph patterns, e.g. OPTIONAL, UNION, and FILTER. For instance, filtered variables may be rewritten in basic graph patterns. By means of typed histograms for the distribution of object values, variables filtered by inequality operators could be considered during (joined) triple pattern selectivity estimation. A filtered variable defining the age of a person to be ≤ 10 could, for example, influence the selectivity of the (joined) triple pattern, which introduces the filtered variable. As our equal-width histograms are untyped, the optimizer is currently not able to estimate the selectivity of value ranges.</p><p>One shortcoming of the evaluation is that the underlying data is artificial. We, therefore, ran two queries which are similar to the ones used in <ref type="bibr" target="#b3">[3]</ref> against the SwetoDBLP dataset. 7 Preliminary findings indicate that the relative performance of the different heuristics is analogous to the ones observed in the LUBM dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>The paper summarizes the research we have been doing on static Basic Graph Pattern (BGP) optimization based on selectivity estimation for main memory graph implementations of RDF data.</p><p>We formalized the problem of BGP optimization (Section 3.1) and we presented the architecture for the optimizer (Section 3.2) that has been implemented for ARQ. Further, we discussed a number of heuristics (Section 3.3) for the selectivity estimation of joined triple patterns. The heuristics range from simple variable counting techniques to more sophisticated selectivity estimations based on the probabilistic framework (Section 5) that builds on top of tailored summary statistics for RDF data (Section 4).</p><p>As the evaluation clearly showed, the characteristics of the heuristics greatly influence the selected ordering of the triple 7 http://lsdis.cs.uga.edu/projects/semdis/swetodblp/ patterns of a BGP and, hence, the query execution performance. In our experience, we found the following properties of heuristics to be important for the problem of BGP optimization. First, the optimizer should avoid Cartesian products as intermediate result sets. Second, the selectivity should not be limited in lower bound estimation. Third, the selectivity of joined triple patterns should be a function of the estimated selectivity of the join (i.e. the size of the result set) and the selectivity of the more selective triple pattern involved in the join. Finally, as we noticed multiple times, bound predicates should not be considered as joins.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Listing 2 :</head><label>2</label><figDesc>BGP of the LUBM Query 2 ?X r d f : type ub : GraduateStudent . ?Y r d f : type ub : U n i v e r s i t y . ?Z r d f : type ub : Department . ?X ub : memberOf ?Z . ?Z ub : subOrganizationOf ?Y . ?X ub : undergraduateDegreeFrom ?Y .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Undirected connected graph g1 ∈ G</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: DAG dg for Listing 2 with highlighted nodes with only outgoing directed edges</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Optimized DAG d1 ∈ D with highlighted node with only outgoing directed edges</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: LUBM Query Performance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 5: LUBM Sampling Performance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The normalized average distance from the best execution plan for each heuristic</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : The best, the worst, and the ARQ/PFJ execution plan performance for the LUBM queries with at least three triple patterns (in milliseconds)</head><label>1</label><figDesc>BGP, i.e. that the two last triple patterns together have an empty intermediate result set. A summary of 10% of the original dataset is accurate</figDesc><table><row><cell>Query</cell><cell>Min</cell><cell cols="2">Max ARQ/PFJ</cell></row><row><cell>2</cell><cell cols="2">1.88 1,532,992.17</cell><cell>1.95</cell></row><row><cell>4</cell><cell>1.59</cell><cell>218.59</cell><cell>1.61</cell></row><row><cell>7</cell><cell>1.36</cell><cell>98,474.56</cell><cell>1.36</cell></row><row><cell cols="2">8 115.56</cell><cell>30,382.56</cell><cell>116.09</cell></row><row><cell>12</cell><cell>2.74</cell><cell>61.84</cell><cell>10.66</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.postgresql.org/docs/8.2/static/geqo.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://tech.groups.yahoo.com/group/jenadev/message/21436</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>There are N ! plans for N triple patterns when considered to be executed linearly. On truly parallel systems, we have the option to execute patterns in parallel and so there are at least N ! plans.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>WWW 2008 / Refereed Track: Semantic / Data Web -Semantic Web II April 21-25, 2008 • Beijing, China</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>For practical reasons, we use the hash code of the lexical form of objects. Hence, we create histograms of integer values which allow comfortable computation of histogram class sizes as well as upper and lower bound of histograms and histogram classes. Certainly, a data type specific implementation would support selectivity estimation for ranges which is particularly interesting for the selectivity estimation of SPARQL variables constrained by the FILTER operator.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>A trivial optimization would be to consider the schema if it is available and consider all predicate combinations if the schema is unavailable.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">OWL Web Ontology Language Reference</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bechhofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Stein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>W3C</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">RDF/XML Syntax Specification</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beckett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mcbride</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>W3C</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">OptARQ: A SPARQL Optimization Approach based on Triple Pattern Selectivity Estimation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kiefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stocker</surname></persName>
		</author>
		<idno>ifi-2007.03</idno>
		<imprint>
			<date type="published" when="2007-03">March 2007</date>
			<biblScope unit="volume">190</biblScope>
			<pubPlace>Zurich, Switzerland</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Zurich, Department of Informatics</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">SPARQL Query Optimization Using Selectivity Estimation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stocker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kiefer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Poster Proceedings of the 6th International Semantic Web Conference (ISWC)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Implementing the Semantic Web Recommendations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Carroll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dickinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Reynolds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seaborne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Wilkinson</forename><surname>Jena</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>HP Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">LUBM: A Benchmark for OWL Knowledge Base Systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heflin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Web Semantics: Science, Services and Agents on the World Wide Web</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="158" to="182" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimized Index Structures for Querying RDF from the Web</title>
		<author>
			<persName><forename type="first">A</forename><surname>Harth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Decker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd Latin American Web Congress</title>
		<meeting>of the 3rd Latin American Web Congress</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page">71</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The SPARQL Query Graph Model for Query Optimization</title>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4th European Semantic Web Conf</title>
		<meeting>of the 4th European Semantic Web Conf</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Resource Description Framework (RDF): Concepts and Abstract Syntax</title>
		<author>
			<persName><forename type="first">G</forename><surname>Klyne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Carroll</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>W3C</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Efficiency of Modern-Day Histogram-Like Techniques for Query Optimization</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Oommen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rueda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="494" to="510" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Semantics and Complexity of SPARQL</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gutierrez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Int. Semantic Web Conf</title>
		<meeting>of the 5th Int. Semantic Web Conf</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="30" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Accurate Estimation of the Number of Tuples Satisfying a Condition</title>
		<author>
			<persName><forename type="first">G</forename><surname>Piatetsky-Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Connell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGMOD Int. Conf. on Management of Data</title>
		<meeting>of the ACM SIGMOD Int. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="256" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Selectivity Estimation Without the Attribute Value Independence Assumption</title>
		<author>
			<persName><forename type="first">V</forename><surname>Poosala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">E</forename><surname>Ioannidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The VLDB Journal</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="486" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">SPARQL Query Language for RDF</title>
		<author>
			<persName><forename type="first">E</forename><surname>Prud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seaborne</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>W3C</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Access Path Selection in a Relational Database Management System</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Selinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGMOD Int. Conf. on Management of Data</title>
		<meeting>of the ACM SIGMOD Int. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Heuristic and Randomized Optimization for the Join Ordering Problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Steinbrunn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Moerkotte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kemper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal: Very Large Data Bases</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="191" to="208" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The Design of POSTGRES</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Rowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="340" to="355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Decomposition: A Strategy for Query Processing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Youssefi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="223" to="241" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
