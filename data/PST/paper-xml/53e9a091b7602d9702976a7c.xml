<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An End-to-End Domain-Driven Software Development Framework</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aditya</forename><surname>Agrawal</surname></persName>
							<email>aditya.agrawal@vanderbilt.edu</email>
						</author>
						<author>
							<persName><forename type="first">Gabor</forename><surname>Karsai</surname></persName>
							<email>gabor.karsai@vanderbilt.edu</email>
						</author>
						<author>
							<persName><forename type="first">Akos</forename><surname>Ledeczi</surname></persName>
							<email>akos.ledeczi@vanderbilt.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institute for Software Integrated Systems</orgName>
								<orgName type="institution">Vanderbilt University Nashville</orgName>
								<address>
									<postCode>37235</postCode>
									<region>TN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Anaheim</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An End-to-End Domain-Driven Software Development Framework</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">07F6B010D6D91D74719B15B93A3B971E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.2 [Design Tools and Techniques] Design</term>
					<term>Algorithms and Languages Software Development</term>
					<term>Model-Driven Architecture</term>
					<term>Model-Integrated Computing</term>
					<term>Graph Transformations</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a comprehensive, domain-driven framework for software development. It consists of a meta-programmable domainspecific modeling environment and a model transformation generator toolset based on graph transformations. The framework allows the creation of custom, domain-oriented programming environments that support end-user programmability. In addition, the framework could be considered an early, end-to-end implementation of the concepts advocated by the OMG's Model Driven Architecture initiative.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION 1.1 Classifying Programming Languages</head><p>Programming languages can be broadly divided into two categories: (1) General-purpose languages (GPLs), such as assembly, C, C++, Java and (2) Domain-specific languages (DSLs), such as Matlab/Simulink <ref type="bibr" target="#b24">[24]</ref>. Tools for general-purpose languages are generally less expensive as a larger community absorbs the cost, whereas DSLs are more expensive, though they can increase productivity by bringing power programming to domain users via familiar specialized notations and languages. It is well know that GPLs have been more prevalent and successful compared to DSLs, even though claims about DSLs' capabilities to increase productivity are widely accepted <ref type="bibr" target="#b26">[26]</ref>. The primary reasons behind the limited success of DSLs have historically been the following:</p><p>• DSLs are more expensive to create as the development cost and time is borne by a small user community</p><formula xml:id="formula_0">•</formula><p>Since there is a small user base, tools and support for a DSL is not at par with GPLs and •</p><p>The wide user base and longer life of GPLs helps make the language implementations robust and reliable. Another view of languages divides them into textual and graphical categories. Graphical languages are usually impractical for generalpurpose programming but can be useful in a limited context, in specific domains. One of the most successful recent examples of graphical, domain-specific languages is Matlab/Simulink <ref type="bibr" target="#b24">[24]</ref> for simulation and control engineering. We believe that a mixed textual and graphical notation can be helpful in limited domains. For example, in the software development domain, the UML <ref type="bibr" target="#b3">[3]</ref> specification has both textual (Object Constraint Language) and graphical (Use-Case Diagram, Class Diagram, etc.) notations. In hardware development domain, tool vendors <ref type="bibr" target="#b27">[27]</ref> are now providing a graphical notation for the structural description of hardware while the behavioral description is still textual. For DSLs to become more popular the three hurdles mentioned above must be addressed. A key limitation is the cost of development (in terms of time and effort), which we conjecture can be reduced by creating a framework for developing DSLs. This approach has several advantages. First, the framework can be used to develop many languages, and thus the cost and time of development is reduced and can be absorbed by a larger community. Second, the framework can be the focal point for a wider user base, thus making it profitable for industries to provide support and tools. Within the framework there will be a development cost for a given DSL that needs to be minimized for the framework to be effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Requirements of a Domain-Driven Software Development Framework</head><p>A useful framework for developing domain-specific graphical languages should have a basic set of features. The features can be divided into the following two categories:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>•</head><p>Meta framework tools that will be used to describe the syntax, semantics and visualization of DSLs. The meta framework must provide support for the specification of a language defined by its abstract syntax, concrete syntax, static semantics, dynamic semantics, and visualization. The syntax of a programming language describes the structure of programs without consideration of their meaning. The abstract syntax of the language captures the abstract concepts and their relationships used in the language. Issues such as typecompatibility are captured in the static semantics of the language. Dynamic semantics is defined as the relation of the abstract syntax to a model of computation. In other words, it can be considered as a mapping from one language to another (provided the model of computation is captured in a linguistic framework).</p><p>• Language framework tools that will be used for the creation, visualization and verification of sentences in a domain-specific language. The language framework should allow the use of the language in an integrated environment that includes creating, editing, and deleting sentences of the language; visualization of the sentences; etc. Apart from editing of the sentences, the framework needs to enforce the concrete syntax and static semantics of the language using some mechanisms. The final requirement of the framework is to be able to use transformation tools that map sentences of the language into sentences of some model of computation <ref type="bibr" target="#b20">[20]</ref>. Examples of such models of computation are stack machines, process networks, finite state machines, etc. Often, although not always, sentences expressed in target the model of computation are executable, hence they are called "executable models".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">A Domain-Driven Development Framework</head><p>The key components of the framework are the following:</p><formula xml:id="formula_1">Generic Modeling Environment (GME) [2],</formula><p>GME's metamodeling language <ref type="bibr" target="#b2">[2]</ref>,</p><p>Graph Rewriting and Transformation (GReAT): a model transformation specification language and</p><p>GReAT Execution Engine (GReAT-E): an execution framework for GReAT specifications.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows how these different technologies fit together to form an end-to-end framework for domain-driven software development.</p><p>The metamodeling language is used for the specification of syntax static semantics and visualization of a DSL. The metamodel transformer can convert this specification (a metamodel) into an internal representation. This internal representation is then used to configure GME to support the specified domain-specific language.</p><p>GReAT is a graphical language used to specify the semantics for the DSL. GReAT-E can execute GReAT specifications on sentences of the DSL to produce executable models. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Paper Organization</head><p>This paper showcases a domain-driven software development framework and demonstrates how it achieves the goals outlined in Section 1.2. The remainder of this paper is organized as follows: Section 2 describes the meta framework and how GME itself was used to develop the meta framework; Section 3 describes the language framework; Section 4 presents an example that illustrates the specification of a simple language; Section 5 presents some preliminary results; Section 6 discusses the conclusions and proposals for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">THE META FRAMEWORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Infrastructure: The Generic Modeling Environment (GME)</head><p>The domain-driven development framework has been developed around GME, a meta-programmable tool that can be customized to support various visual domain-specific modeling languages. GME uses direct manipulation techniques for editing complex models. The direct manipulation front-end is comprised of the "editing engine" that operates on data structures representing the domainspecific models. How these data structures are organized, what objects and relationships are allowed, what attributes objects have, etc. are captured in an internal metamodel. The internal metamodel is a read-only, static data structure that GME uses at run-time to connect the model data structures to the visualization and direct manipulation tools. It connects to a database backend to provide persistence services and to validate the editing operations. This internal metamodel is created from an external metamodel, which is built by the designer of the domain-specific modeling language <ref type="bibr" target="#b2">[2]</ref>.</p><p>The external metamodel is a sentence in a visual metamodeling language. GME was used to create this metamodeling language. Sentences of this language (metamodels) can be created and edited in GME. The metamodeling language is described in Section 2.2. GME also provides a special model transformation tool called metamodel transformer that transforms an external metamodel into an internal metamodel <ref type="bibr" target="#b2">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Abstract and Concrete Syntax</head><p>The external metamodel captures the abstract and concrete syntax of the modeling language supported by the GME. The abstract syntax is expressed in the form of UML class diagrams <ref type="bibr" target="#b3">[3]</ref> that introduce domain concepts (classes), their attributes, and their relationships. These UML class diagrams describe all the possible models that can be built via the modeling language, similar to how Extended Backus-Naur Form (EBNF) describes all the possible sentences in a textual language. In other words, we use UML class diagrams to represent generative grammars for models.</p><p>The concrete syntax is expressed by coupling the domain modeling entities (classes and associations) to specific visualization features available in GME. This coupling happens in two ways:</p><p>• Using specific stereotypes for classes. GME defines a set of stereotypes, and when these are assigned to classes in the metamodel they determine how the visualization should happen. For example, &lt;&lt;Model&gt;&gt;-s are visualized as containers shown as icons with connection ports, &lt;&lt;Atom&gt;&gt;-s as (user-defined) icons, &lt;&lt;Connection&gt;&gt;-s as lines, etc.</p><p>• Using specific idioms in the metamodel. GME's metamodeling tool uses a number of predefined idioms: patterns over classes that carry special meaning. For example, a &lt;&lt;Reference&gt;&gt; class associated with an &lt;&lt;Atom&gt;&gt; class via an association labeled as "refersTo" means that (in a context) one can use reference objects that point to atomic objects of the selected kind.</p><p>The GME has a number of visualization techniques (e.g., container objects), and there is a set of well-defined stereotypes that allow relating the domain entities to GME visualization concepts. Some visualization techniques require multiple, cooperating domain classes, and in this case specific idioms are used in the GME. For details, please see the GME documentation <ref type="bibr" target="#b2">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Static Semantics</head><p>The GME metamodels discussed above only allow specification of the abstract syntax, i.e., they do not support semantic constraints on the models. These constraints define the well-formedness rules for the models, i.e., the static semantics. We use OCL <ref type="bibr" target="#b19">[19]</ref> to express these rules in the GME metamodels. One can couple OCL expressions to model elements, and the GME editing engine evaluates these expressions at run-time. If constraint violations are found, the user is warned about the specific rule that has been violated. Notification of constraint violation during model editing can be annoying, thus there exists a fine-grain control over the evaluation time of constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Semantics via Transformation Specification</head><p>Most textual languages have either (1) a direct one-to-one mapping from the source to the target model of computation or (2) have no formal specification for the transformation. The transformation specification is buried in the code generator. The process of writing generators is time consuming and costly and therefore, a better approach is necessary to support a domain-driven software development framework. If a higher-level specification for the model transformations is available, it can presumably be used to generate the code for the model translator. From a mathematical viewpoint, one can recognize that domain-specific models are graphs or to be more precise: vertex and edge labeled multi-graphs, where the labels are denoting the corresponding entities (i.e., types) in the metamodel. Thus, the model transformation problem can be converted into a graph transformation problem. We can then use the mathematical concepts of graph transformations to formally specify the intended behavior of model transformers. Graph grammars and graph transformations (GGT) have been recognized <ref type="bibr" target="#b11">[11]</ref>[12] <ref type="bibr" target="#b13">[13]</ref>[14] as a powerful technique for specifying complex transformations that can be used in different places in a software development process. Many tasks in software development can be formulated using this approach, including weaving of aspectoriented programs <ref type="bibr" target="#b23">[23]</ref>, application of design patterns <ref type="bibr" target="#b13">[13]</ref>, and the transformation of platform-independent models into platform specific models <ref type="bibr" target="#b4">[4]</ref>.</p><p>A variety of graph transformation techniques are described in <ref type="bibr" target="#b5">[5]</ref> <ref type="bibr" target="#b17">[17]</ref>. These techniques include node replacement grammars, hyperedge replacement grammars, algebraic approaches, and programmed graph replacement systems. Most of these techniques have been developed for specifying and recognizing graph languages and performing transformations within the same "domain" (i.e., graph) however, while we need a graph transformer that works on two different kinds of graphs. Moreover, these transformation techniques rarely use a well-defined language for the specification structural constraints on the graphs. In summary, the following features are required in the transformation language:</p><formula xml:id="formula_2">[6][7][8][9][10]</formula><p>The language should provide the user with a way to specify the different graph domains being used. This helps to ensure that graphs/models of a particular domain do not violate the syntax and static semantics of the domain.</p><p>There should be support for transformations that create independent models/graphs conforming to different domains than the input models/graphs. In the more general case there can be n input model/domain pairs and m output model/domain pairs. The language should have efficient implementations of its programming constructs. The generated implementation should be comparable to its equivalent hand written code.</p><p>All the previous points aim to increase productivity and achieve speed up in the time required for writing model interpreters. This is the primary goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Language for Graph Rewriting and Transformations</head><p>The transformation language we have developed to address the needs discussed above is called the Graph Rewriting and Transformation (GReAT) language. This language can be divided into 3 distinct parts: (1) Pattern specification language, (2) Graph transformation language, and (3) Control flow language, which we discuss below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">The Pattern Specification Language</head><p>The heart of a graph transformation language is the pattern specification language and the related pattern matching algorithms. The pattern specifications found in graph grammars and transformation languages <ref type="bibr" target="#b5">[5]</ref> <ref type="bibr" target="#b18">[18]</ref> are not sufficient for our purposes, as they do not follow UML concepts. This paper briefly introduces an expressive -yet easy to usepattern specification language that is tightly coupled to the UML class diagrams. String matching will be used to illustrate representative analogies.</p><formula xml:id="formula_3">[6][7][8][15][16][17]</formula><p>Patterns in most graph transformation languages have a one-to-one correspondence with the host graph.. Consider an example from the domain of textual languages where a string to match starts with an 's' and is followed by 5 'o's. To specify such a pattern string we could enumerate the 'o's and write "sooooo". Since this is not a scalable solution, a representation format is required to specify such strings in a concise and scalable manner. One can use regular expressions: for strings we could write it as "s5o" and use the semantic meaning that o needs to be enumerated 5 times. The same argument holds for graphs, and a similar technique can be used. Cardinality can be specified for each pattern vertex with the semantic meaning that a pattern vertex must match n host graph vertices, where n is its cardinality. However, it is not obvious how the notion of cardinality truly extends to graphs. In text, we have the advantage of a strict ordering from left to right, whereas graphs do not possess this property.</p><p>In Figure <ref type="figure" target="#fig_1">2</ref> (a) we see a pattern having three vertices. One possible meaning could be tree semantics, i.e., if a pattern vertex pv1 with cardinality c1 is adjacent to pattern vertex pv2 with cardinality c2, then the semantics are that each vertex bound to v1 will be adjacent to c2 vertices bound to v2. These semantics when applied to the pattern gives Figure <ref type="figure" target="#fig_1">2 (b)</ref>. The tree semantic is weak in the sense that it will yield different results for different traversals of the pattern vertices and edges and hence, it is not suitable for our purpose. Due to these reasons, we use set semantics in GReAT and have developed pattern-matching algorithms for both single cardinality and fixed cardinality of vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.2">Graph Rewriting Transformation Language</head><p>Pattern specification is just one important part of any graph transformation language. Other important concerns are the specification of static structural constraint in graphs and ensuring that these are maintained throughout the transformations <ref type="bibr" target="#b6">[6]</ref>. These problems have been addressed in a number of other approaches, such as <ref type="bibr">[15][16]</ref>.</p><p>In model-transformers, structural integrity is a primary concern.</p><p>Model-to-model transformations usually transform models from one domain to models that conform to another domain making the problem two-fold. The first problem is to specify and maintain two different models conforming to two different metamodels (in MIC metamodels are used to specify structural integrity constraints). An even more important problem to address involves maintaining references between the two models. For example, it is important to maintain some sort of references, links, and other intermediate values required to correlate graph objects across the two domains.</p><p>Our solution to these problems is to use the source and destination metamodels to explicitly specify the temporary vertices and edges. This approach creates a unified metamodel along with the temporary objects. The advantage of this approach is that we can then treat the source model, destination model, and temporary objects as a single graph. Standard graph grammar and transformation techniques can then be used to specify the transformation. The rewriting language uses the pattern language described above. Each pattern object's type conforms to the unified metamodel and only transformations that do not violate the metamodel are allowed. At the end of the transformation, the temporary objects are removed and the two models conform exactly to their respective metamodels. Our transformation language is inspired by many previous efforts, such as <ref type="bibr" target="#b7">[7]</ref>[8][9][17] <ref type="bibr" target="#b18">[18]</ref>.</p><p>The graph transformation language of GReAT defines a production (also referred to as rule) as the basic transformation entity. A production contains a pattern graph that consists of pattern vertices and edges. These pattern objects conform to a type from the metamodel. Each pattern has another attribute that specifies the role it plays in the transformation. A pattern can play the following three different roles:</p><p>1. Bind -used to match objects in the graph.</p><p>2. Delete -also used to match objects in the graph, but after these objects are matched they are deleted from the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">New -used to create objects after the pattern is matched</head><p>The execution of a rule involves matching every pattern object marked either bind or delete. If the pattern matcher is successful in finding matches for the pattern, then for each match the pattern objects marked delete are deleted from the match and objects marked new are created.</p><p>Sometimes the patterns by themselves are not enough to specify the exact graph parts to match and we need other, non-structural constraints on the pattern. An example for such a constraint is: "the value of an attribute of a particular vertex should be within some limits." These constraints or pre-conditions are expressed in a guard and are described using Object Constraint Language (OCL) <ref type="bibr" target="#b19">[19]</ref>.</p><p>There is also a need to provide values to attributes of newly created objects and/or modify attributes of existing object. Attribute Mapping is another ingredient of the production: it describes how the attributes of the "new" objects should be computed from the attributes of the objects participating in the match. Attribute mapping is applied to each match after the structural changes are completed.</p><p>A production is thus a 4-tuple, containing a pattern graph, mapping function that maps pattern objects to actions, a guard expression (in OCL), and an attribute mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.3">Controlled Graph Rewriting and Transformation</head><p>To increase the efficiency and effectiveness of GReAT, it is essential to have efficient implementations for the productions.</p><p>Since the pattern matcher is the most time consuming operation, it needs to be optimized. One solution is to reduce the search space (and thus time) by starting the pattern-matching algorithm with an initial context. An initial context is a partial binding of pattern objects to input (host) graph objects. This approach significantly reduces the time complexity of the search by limiting the search space. In order to provide initial bindings, the production definition is expanded to include the concept of ports. Ports are elements of a production that are visible at a higher-level and can then be used to supply initial bindings. Ports are also used to retrieve output objects from the production.</p><p>The next concern is the application order of the productions. In graph grammars there is no ordering imposed on productions. If the pattern to be matched exists in the host graph and if the precondition is met then the production will be executed. Although this technique is useful for generating and matching languages, they are unsuitable for model-to-model transformations that are algorithmic in nature and require strict control over the execution sequence. Moreover, a well-defined execution sequence can be used to make the implementation more efficient.</p><p>There is a need for a high-level control flow language that can control the application of the productions and allow the user to manage the complexity of the transformation. The control flow language of GReAT supports the following features:</p><p>Sequencing -rules (in GReAT the productions are called rules) can be sequenced to fire one after another. This is achieved by attaching the output port of the first rule to the input port of the next rule. Non-Determinism -when required parallel execution of a set of rules can be specified. The order of execution of these rules is non-deterministic. This construct is achieved in GReAT by attaching the output of one rule to the input of more than one rule.</p><p>Hierarchy -High-level rules have been introduced in the language. These are used for encapsulation and data abstraction. Compound rules can contain other compound rules or primitive transformation rules.</p><p>Recursion -A high level rule can "call" itself. Test/Case -A conditional branching construct that can be use to choose between different control flow paths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE LANGUAGE FRAMEWORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Infrastructure: The Generic Modeling Environment (GME)</head><p>As noted above, the same GME is used to support domain modeling. However, this GME instance is configured by the internal metamodel to support and enforce the specific features of the domain-specific modeling language. A domain-specific instance of GME provides a tool with domain-oriented features and symbols for model editing and manipulation. Its capabilities have been discussed in detail elsewhere <ref type="bibr" target="#b2">[2]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Run-time support for model transformations</head><p>The model transformation language described above is supported through a Graph Rewiring and Transformation Execution Engine (GReAT-E). Figure <ref type="figure" target="#fig_2">3</ref> shows its architecture. The engine works as an interpreter: it takes the model transformation "program" in the form of a data structure, and it "executes" it on an input graph to produce an output graph. The engine uses generic API-s (using our model-driven reflection package called UDM <ref type="bibr" target="#b21">[21]</ref>), and is thus suitable for executing any model transformation. Work is currently underway to translate the model transformation specifications into code that can be executed directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DEVELOPING A SIMPLE LANGUAGE</head><p>This section develops an example language to demonstrate the capabilities of our end-to-end framework. We will call the language being developed Modeling Language for Embedded Systems (MOLES). The embedded system community develops a large class of applications that are event driven and use the data flow semantics. To create these applications, developers must first build the basic data flow components and then connect them together in different configurations to achieve the desired application. The requirements of the MOLES language therefore involves the following capabilities:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Design of component interface and behavior</head><p>Creating data flow graphs using the components Facility to have timer interrupts, queues and delay elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Language Specification</head><p>The first step in the development of a new language in the GME is to specify the syntax and the visualization using the metamodeling environment. The metamodel for MOLES is divided into two parts; the first describes the internals of a component, while the second deals with developing packages or applications based on the components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 4 Definition of a component</head><p>Figure <ref type="figure">4</ref> shows the metamodel for components. Here, we can see that a Component can contain Ports, Behaviors, and Attributes. Based upon whether they receive or send data the Ports are specialized to be either Input or Output. Behavior can be specified in two different ways: the first is to specify a piece of code that implements the behavior, whereas the second is to describe the behavior using a simple state machine. Attributes capture data storage elements of the Component. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5 Package definition and dataflow</head><p>After defining the syntax, we can define static semantics using OCL constraints. For example, a timer component cannot be the destination of a data flow component. Such a constraint can be specified in OCL and attached to the timer (as shown in Figure <ref type="figure" target="#fig_4">6</ref>). These constraints are checked by GME when the user is creating domain models. This guarantees that the models will not violate the static semantics. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Transformation Specification</head><p>After the abstract syntax, concrete syntax, and static semantics have been defined, the next step is to define the semantics of the language using GReAT. To define a transformation, we first identify a mapping from the language to the appropriate model of computation. We have chosen synchronous data flow <ref type="bibr" target="#b25">[25]</ref>. In synchronous data flow the number of tokens consumed and produced on each port of a component is fixed and predefined. For the sake of brevity we have fixed the token size on each Port to be one. Synchronous data flow is a simple and efficient model of computation, and an algorithm exists that can compute the static schedule for node invocations for any synchronous dataflow network <ref type="bibr" target="#b25">[25]</ref>. If there is a cyclic dependency in the data flow, the algorithm can also report such problem. A cycle in MOLES that contains a delay doesn't represent a cyclic data dependency assuming the delay component is initialized with a token. A delay with a dataflow connection to an input port of a component signifies that the input port has an initial token and thus can run once without requiring another token on that port. Since every dataflow path will have one token each after one cycle, the component will never be short of tokens on the delay edge. Thus the delay edge can be ignored for solving the scheduling problem. In order to find a static schedule for the dataflow components a topological sort needs to be performed. The topological sort will produce a scheduling order and if a cycle exists it will fail and report that a cycle was found. The target model of computation can be considered a line graph that represents one periodic admissible sequential schedule (PASS) <ref type="bibr" target="#b25">[25]</ref>.</p><p>The transformation rules are shown in Figure <ref type="figure">7</ref>. At the top level, we have the TopologicalSort and Success? Rules. TopologicalSort encapsulates the sorting algorithm while Success? Is used to check if the sort was successful or if it detected a cycle. TopologicalSort consists of series of simple transformation rules. The component with no incoming dataflow connections is chosen; this component is added to the PASS and deleted from the input (deletion can be performed on a local copy of the input model). This process is continued until we have exhausted all the components in the input or we find a cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 7 Snapshot of the rules for performing the topological sort</head><p>The transformation specification can then be executed using GReAT-E on any MOLES model to generate a PASS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Using the language</head><p>We have seen in previous sections that GME can be used as the editor of different domain-specific languages. It can be used to specify the syntax and semantics of the language using the metamodeling language, as well as used to create sentences of a domain-specified language. The user can use GME to create and edit models that belong to MOLES, where MOLES is the language we just developed. Data flow graphs created in MOLES can then be used to generate a static schedule or find out if there are cycles in the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 8 Example models in the MOLES Language</head><p>Figure <ref type="figure">8</ref> shows an example dataflow graph developed in the MOLES language using GME. GME provides editing, visualization, syntax and static semantic checking, and safety of the language. For example, the constraint specified in the metamodel of MOLES about timer being only source is enforced by GME in Figure <ref type="figure" target="#fig_5">9</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PRELIMINARY RESULTS</head><p>The goal of using a domain-specific development process is to increase the domain programmer's productivity. The goal of using a metamodel driven development process to create domain-specific development tools is to increase the productivity of the tool developer. Table <ref type="table" target="#tab_0">1</ref> shows some preliminary results by comparing the size of and time taken to develop GReAT specifications for model transformation problems to estimated equivalent lines of procedural code. The primitive rules are rules that contain graph transformation specification while compound rules are higher-level control flow constructs. Some preliminary tests have shown that each primitive rule corresponds to approximately 30 lines of hand code. The corresponding hand code is fairly complex and not very natural to write. This makes us believe that the language can actually provide increase in productivity. However, better tests need to be designed and performed using more subjects to provide more precise results. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS AND FUTURE WORK</head><p>This paper has identified three historical limitations of domainspecific languages (DSLs) and proposed a framework-based solution to counter then. The dominant reasons for the limitations of previous generations of DSLs are development cost and lack of tool support. Using a framework approach to domain-driven development, we can push the development cost to a one-time investment in a framework and allow independent vendors to provide greater support for the framework. Such a framework needs to satisfy different criteria (such as low cost of development of endto-end domain languages and good tool support) at both the metamodel and language level. The framework presented in the paper that comprises of Generic Modeling Environment (GME), the metamodeling language, Graph Rewriting and Transformation (GReAT) and GReAT Execution Engine (GReAT-E) has the required capabilities.</p><p>In the framework, the abstract and concrete syntax of a language is captured using a UML-based approach called metamodeling. Likewise, static semantics are captured with the help of OCL expressions and the semantics of the language are captured with the help of a transformation specification in GReAT. The syntax, semantics, and transformations are converted to an executable form using the metamodeling transformer, OCL expression checker, and the GReAT interpreter. At the language level, GME provides the user with editing, visualization, and consistency checking and</p><p>GReAT is used to convert models to executable models of an appropriate model of computation.</p><p>This paper illustrated the capabilities of the GME based framework using a simplified example. We have developed and tested a variety of small-to-medium-sized languages using this approach.</p><p>Preliminary results demonstrate a speedup in the development time.</p><p>There are a number of open questions that we plan to address in our ongoing research. Although we have successfully tackled two problems plaguing the domain-driven development community, we still must address the issue concerning language robustness. This issue can be approached if we can reason about the languages built in the framework and guarantee soundness properties. We envision that we can construct languages that are correct by construction, thereby ensuring robustness and correctness.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 A</head><label>1</label><figDesc>Figure 1 A Domain-Driven Development Framework</figDesc><graphic coords="2,54.12,406.68,239.52,180.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2</head><label>2</label><figDesc>Figure 2 Pattern with different semantic meaningsAnother possible unambiguous meaning could use set semantics: consider each pattern vertex pv to match a set of host vertices equal to the cardinality of the vertex. Then an edge between two pattern vertices pv1 &amp; pv2 implies that in a match each v1, v2 pair should be adjacent, where v1 is bound to pv1 and v2 is bound to pv2. This semantic when applied to the pattern in Figure2(a) gives the graph in Figure2 (c). The set semantics will always return a match of the structure shown in Figure2(c), and it does not depend upon factors such as the starting point of the search and how the search is conducted.</figDesc><graphic coords="4,54.72,131.16,117.00,110.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3</head><label>3</label><figDesc>Figure 3 The GReAT Interpreter</figDesc><graphic coords="5,55.68,465.84,236.40,144.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5</head><label>5</label><figDesc>Figure 5 shows how these components can be put together in a package. A package can contain components and component references; they also contain ports and intermediate delay elements. An important thing to note is that the Component and Port are the same as in Figure 4. Package and Component have the same kind of ports and hence the connection between ConnectionBase elements defines all the possible dataflow connections. Package can contain other Packages; this can be used for hierarchical decomposition of the dataflow. Ports can not only connect to other Ports but also connect to Delays and Timers. A Delay element in a dataflow path introduces a delay of one time step. This means that the data passing through a delay will be held for one time step before to moves forward. Timers generate data at periodic intervals.</figDesc><graphic coords="6,86.28,249.60,175.20,185.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6</head><label>6</label><figDesc>Figure 6 OCL constraint</figDesc><graphic coords="6,54.00,544.20,239.76,113.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9</head><label>9</label><figDesc>Figure 9 An OCL constraint violation message box</figDesc><graphic coords="7,54.00,425.04,239.76,202.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Comparison of GReAT specification VS hand code</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">GReAT</cell><cell>Hand</cell></row><row><cell>Problem</cell><cell>Primitive/Com</cell><cell>Time (man-</cell><cell>code Est.</cell></row><row><cell></cell><cell>pound Rules</cell><cell>hours)</cell><cell>LOC</cell></row><row><cell>Mark and sweep</cell><cell></cell><cell></cell><cell></cell></row><row><cell>algorithm on Finite State Machine</cell><cell>7/2</cell><cell>~2</cell><cell>100</cell></row><row><cell>(FSM)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Hierarchical Data</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Flow (HDF) to Flat</cell><cell>11/3</cell><cell>~3</cell><cell>200</cell></row><row><cell>Data Flow (FDF)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Hierarchical</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Concurrent State</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Machine (HCSM)</cell><cell>21/5</cell><cell>~8</cell><cell>500</cell></row><row><cell>to Finite State</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Machine (FSM)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Matlab Simulink/</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Stateflow to Hybrid</cell><cell>66/43</cell><cell>~20</cell><cell>3000</cell></row><row><cell>System</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Acknowledgements</head><p>The DARPA/IXO MOBIES program, Air Force Research Laboratory under agreement number F30602-00-1-0580 and NSF ITR on "Foundations of Hybrid and Embedded Software Systems" programs have supported, in part, the activities described in this paper. Tihamer Levendovszky and Jonathan Sprinkle have contributed to the discussions and work that lead to GreAT, and Feng Shi has written the first implementation of GreAT-E. The authors would like to thank the reviewer for their valuable comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Model-Integrated Computing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sztipanovits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="page" from="110" to="112" />
			<date type="published" when="1997-04">Apr. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Composing Domain-Specific Design Environments</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ledeczi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="page" from="44" to="51" />
			<date type="published" when="2001-11">Nov. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
		<title level="m">The Unified Modeling Language Reference Manual</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Generative Programming via Graph Transformations in the Model-Driven Architecture</title>
		<author>
			<persName><forename type="first">A</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Levendovszky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sprinkle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Generative Techniques in the Context of Model Driven Architecture</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-11-05">Nov. 5, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Rozenberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>World Scientific Publishing Co. Pte. Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Computing with Graphs and Graph Rewriting</title>
		<author>
			<persName><forename type="first">D</forename><surname>Blostein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<idno>AIB 97-8</idno>
		<imprint>
			<pubPlace>Fachgruppe Informatik, RWTH Aachen, Germany</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Attributed graph grammars for graphics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gottler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Grammars and their Application lo Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Ehrig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Nagl</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rosenberg</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">153</biblScope>
			<biblScope unit="page" from="130" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Diagram Editors = Graphs + Attributes + Graph Grammars</title>
		<author>
			<persName><forename type="first">H</forename><surname>Göttler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Man-Machine Studies</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="481" to="502" />
			<date type="published" when="1992-10">Oct. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Visual Concurrent Programming with Delta-Grammars</title>
		<author>
			<persName><forename type="first">J</forename><surname>Loyall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kaplan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="107" to="133" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">5th Workshop on Graph Grammars and Their Application To Computer Science</title>
		<author>
			<persName><forename type="first">D</forename><surname>Blostein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fahmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Grbavec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
	<note>Practical Use of Graph Rewriting</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">How to Uniformly specify Program Analysis and Transformation</title>
		<author>
			<persName><forename type="first">U</forename><surname>Assmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6 International Conference on Compiler Construction (CC) &apos;96</title>
		<meeting>the 6 International Conference on Compiler Construction (CC) &apos;96</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1060</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Graph Rewriting Framework for Statecharts Semantics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Maggiolo-Schettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Peron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc.\ 5th Int.\ Workshop on Graph Grammars and their Application to Computer Science</title>
		<meeting>.\ 5th Int.\ Workshop on Graph Grammars and their Application to Computer Science</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Support for Design Patterns through Graph Transformation Tools&apos;&apos;, Applications of Graph Transformation with Industrial Relevance, Monastery Rolduc</title>
		<author>
			<persName><forename type="first">A</forename><surname>Radermacher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-09">Sep. 1999</date>
			<pubPlace>Kerkrade, The Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Tool integration and construction using generated graph-based design representations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bredenfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Camposano</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">June 12-16, 1995</date>
			<biblScope unit="page" from="94" to="99" />
			<pubPlace>San Francisco, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Graph Grammar for Recognition of Music Notation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Fahmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Blostein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Vision and Applications</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="83" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Special Issue on Graph Transformation Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Ehrig</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3/4</biblScope>
			<date type="published" when="1995">1996. 1995</date>
			<publisher>IOS Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Workshop on Graph-Theoritic Concepts in Computer Science&quot;, (WG &apos;91)</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Schmidt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Berghammer</surname></persName>
		</editor>
		<meeting>Int. Workshop on Graph-Theoritic Concepts in Computer Science&quot;, (WG &apos;91)</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">570</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Graph-grammars: an algebraic approach</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pfender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Conference on Automata and Switching Theory</title>
		<meeting>IEEE Conference on Automata and Switching Theory</meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="167" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Object Constraint Language Specification</title>
		<idno>OMG Document formal/01-9-77</idno>
		<imprint>
			<date type="published" when="2001-09">September 2001</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Embedded Software</title>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Computers</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Zelkowitz</surname></persName>
		</editor>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">56</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The UDM Framework</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bakay</surname></persName>
		</author>
		<ptr target="http://www.isis.vanderbilt.edu/Projects/mobies/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Recursive functions of symbolic expressions and their computation by machine -I</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="184" to="195" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Aspect Weaving by Graph Rewriting</title>
		<author>
			<persName><forename type="first">Uwe</forename><surname>Assmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Generative Component-based Software Engineering (GCSE)</title>
		<imprint>
			<date type="published" when="1999-10">Oct 1999</date>
			<biblScope unit="page" from="24" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m">Simulink Reference</title>
		<imprint>
			<publisher>The Mathworks, Inc</publisher>
			<date type="published" when="2002-07">July 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Static Scheduling of Synchronous Dataflow programs for Digital Signal Processing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Messerschmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="35" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An Examination of DSLs for Concisely Representing Model Traversals and Transformations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">36th Annual Hawaii International Conference on System Sciences (HICSS&apos;03) -Track 9</title>
		<imprint>
			<date type="published" when="2003">January 06 -09, 2003</date>
			<biblScope unit="page">325</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<ptr target="http://www.aldec.com/ActiveHDL/" />
		<title level="m">ActiveHDL</title>
		<meeting><address><addrLine>Henderson, NV 89074</addrLine></address></meeting>
		<imprint>
			<publisher>Aldec Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
