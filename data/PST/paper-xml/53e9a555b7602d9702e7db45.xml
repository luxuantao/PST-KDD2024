<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fixed-Parameter Tractability, Definability, and Model Checking</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-10-16">October 16, 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jörg</forename><surname>Flum</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
						</author>
						<title level="a" type="main">Fixed-Parameter Tractability, Definability, and Model Checking</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-10-16">October 16, 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">32C91AA8F5C505967FCBB7DE1901033C</idno>
					<idno type="arXiv">arXiv:cs/9910001v2[cs.CC]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this article, we study parameterized complexity theory from the perspective of logic, or more specifically, descriptive complexity theory.</p><p>We propose to consider parameterized model-checking problems for various fragments of first-order logic as generic parameterized problems and show how this approach can be useful in studying both fixed-parameter tractability and intractability. For example, we establish the equivalence between the model-checking for existential first-order logic, the homomorphism problem for relational structures, and the substructure isomorphism problem. Our main tractability result shows that model-checking for first-order formulas is fixed-parameter tractable when restricted to a class of input structures with an excluded minor. On the intractability side, for every t 0 we prove an equivalence between model-checking for first-order formulas with t quantifier alternations and the parameterized halting problem for alternating Turing machines with t alternations. We discuss the close connection between this alternation hierarchy and Downey and Fellows' W-hierarchy.</p><p>On a more abstract level, we consider two forms of definability, called Fagin definability and slicewise definability, that are appropriate for describing parameterized problems. We give a characterization of the class FPT of all fixedparameter tractable problems in terms of slicewise definability in finite variable least fixed-point logic, which is reminiscent of the Immerman-Vardi Theorem characterizing the class PTIME in terms of definability in least fixedpoint logic.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Parameterized complexity is a branch of complexity theory which has matured in the last 10 years, as witnessed in the culminating monograph <ref type="bibr" target="#b9">[10]</ref>. It gives a framework for a refined complexity analysis of hard algorithmic problems. The basic idea can best be explained by an example: Consider the problem of evaluating a query in a relational database. This problem usually has a high complexity (depending on the query language, of course, but the problem is NP-complete even for the very basic conjunctive queries <ref type="bibr" target="#b4">[5]</ref>). The main factor contributing to this complexity is the length of the query. In practice, however, queries are usually short, certainly much shorter than the size of the database. Thus when analyzing the complexity of the problem we should put much more emphasis on the size of the database than on the length of the query. An algorithm evaluating a query of length k in a database of size m in time O(2 k m) is therefore much better than one performing the same task in time O(m k=2 ), although both are exponential.</p><p>Parameterized complexity theory studies problems whose instances are parameterized by some function of the input, such as the length of the query in our example. The idea is to choose the parameterization in such a way that it can be assumed to take small values for the instances one is interested in. Then the complexity of an algorithm is measured not only in the size of the input, but also in terms of the parameter. A parameterized problem is fixedparameter tractable if there is an algorithm solving it in time f (k) n c , where n denotes the size of the input, k the parameter, and f : N ! N is a computable function and c &gt; 0 a constant.</p><p>Parameterized complexity theory provides methods for proving problems to be fixed-parameter tractable, but also gives a framework for dealing with apparently intractable problems in a similar way that the theory of NP-completeness does in classical complexity theory.</p><p>The purpose of this article is to establish a very fruitful connection between parameterized complexity theory and logic. Our approach is that of descriptive complexity theory. We study the definability of parameterized problems and Institut für Mathematische Logik, Eckerstr. 1, 79104 Freiburg, Germany. Email: flum@sun2.ruf.uni-freiburg.de y Department of Mathematics, Statistics, and Computer Science, University of Illinois at Chicago, 851 S. Morgan St. (M/C 249), Chicago, IL 60607-7045, USA. Email: grohe@uic.edu try to obtain information about the parameterized complexity of the problems through the syntactical structure of the defining sentences. On the one hand, we use this approach to prove that certain problems are tractable because they can be defined by syntactically simple formulas. On the other hand, we characterize classes of intractable problems by syntactical means.</p><p>Central to our approach are parameterized model-checking problems of the following form. For a class of formulas, we let MC( ) be the problem</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MC( )</head><p>Input: A finite structure A. Parameter: A sentence ' 2 .</p><p>Question: Does A satisfy '?</p><p>In most cases, will be a fragment of first-order logic.</p><p>After a preliminary section, we discuss some basic facts about parameterized model-checking problems in Section 3. In Section 4 we introduce two notions of definability of parameterized problems, which we call slicewise definability and Fagin definability, and relate them to model-checking. We then show how Fagin definability can be used to establish the fixed-parameter tractability of various problems.</p><p>In Section 5 we study the parameterized complexity of the model-checking problem for 1 -formulas (that is, existential first-order formulas in prenex normal form). We associate a graph with each such formula and use it to establish a surprisingly close connection between this model-checking problem, the homomorphism problem, and the subgraph isomorphism problem. As an application of our result we show that for 1 -sentences whose graph has bounded tree-width the model-checking problem is fixed-parameter tractable, even if inequalities are disregarded in the graph of the formula. Model-checking for formulas with a tree-like graph or hypergraph has recently received much attention (see <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b15">16]</ref>).</p><p>So far we have only looked for tractable cases of the model-checking problem MC( ) that are obtained by restricting the class of formulas . A different approach is to restrict the class of structures where the input structure A is taken from (see, for example, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b16">17]</ref>). We prove a far reaching result: For any class C of graphs with an excluded minor, the model-checking problem for first-order logic is fixed-parameter tractable if the inputs are taken from C. This implies, for example, that parameterized versions of the dominating set problem or the (induced) subgraph isomorphism problem are fixed-parameter tractable when restricted to such classes of graphs.</p><p>Our last result on fixed-parameter tractability is a descriptive characterization of the complexity class FPT of all fixed-parameter tractable problems in terms of slicewise definability in finite variable fragments of least-fixed point logic. This simple result can be seen as a parameterized analogue of the well-known Immerman-Vardi Theorem <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b29">30]</ref> characterizing the class PTIME in terms of definability in least-fixed-point logic.</p><p>The final section is devoted to fixed-parameter intractability. We define a hierarchy A[t] of parameterized complexity classes in terms of alternating Turing machine acceptance (t is the number of alternations). This hierarchy can be seen as a parameterized analogue of the polynomial hierarchy. We prove that for all t 1, the model-checking problem for t -formulas is complete for the tth level of this hierarchy. Then we study the relation between our Ahierarchy and Downey and Fellows' W-hierarchy. It is known that the first levels of the respective hierarchies, A <ref type="bibr" target="#b0">[1]</ref> and W <ref type="bibr" target="#b0">[1]</ref> coincide <ref type="bibr" target="#b3">[4]</ref>. We slightly improve a result of Downey, Fellows, and Regan <ref type="bibr" target="#b10">[11]</ref> relating W[t], the tth level of the W-hierarchy, to the model-checking problems for a certain fragment of t . However, the questions whether A[t] and W[t] coincide for t 2 remains open.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Logic</head><p>We assume that the reader is familiar with first-order logic; we just recall a few basic notions to fix our notation (compare <ref type="bibr" target="#b12">[13]</ref> for a more detailed introduction of these notions).</p><p>In this article, a vocabulary is a finite set of relation symbols. Associated with every relation symbol is a natural number, its arity. The arity of a vocabulary is the maximal arity of the relation symbols it contains. Usually, vocabularies are also permitted to contain function and constant symbols. All results of this article, with the single exception of Theorem 33, would remain true if function and constant symbols were allowed, but adding them would not give us any new insights. So, for convenience, we restrict our attention to relational vocabularies. In the following, always denotes a vocabulary.</p><p>A -structure A consists of a set A, called the universe of A, and a relation R A A r for each r-ary relation symbol R 2 . We synonymously write a 2 R A or R A a to denote that the tuple a 2 A r belongs to the relation R A . For 0 , a -structure A is the -reduct of a 0 -structure</p><formula xml:id="formula_0">A 0 if A = A 0 and R A = R A 0 for all R 2 . A 0 -structure A 0 is a 0 -expansion of a -structure A if A is the -reduct of A 0 .</formula><p>We only consider finite structures. When we consider classes of structures, they are always assumed to be closed under isomorphism. STR denotes the class of all (finite) structures. If C is a class of structures, C[ ] denotes the subclass of all -structures in C. Furthermore, C[s] denotes the class of all structures in C whose vocabulary is at most s-ary. We consider graphs as fEg-structures G = (G; E G ), where E G is an irreflexive and symmetric binary relation (i.e. graphs are loop-free and undirected). GRAPH denotes the class of all graphs.</p><p>The class of all first-order formulas is denoted by FO. Recall that atomic formulas are formulas of the form x = y or Rx 1 : : : x r , where x; y; x 1 ; : : : ; x r are variables and R is a r-ary relation symbol. where Q = 8 if t is even and Q = 9 otherwise and is quantifier-free. t -formulas are defined analogously starting with a block of universal quantifiers.</p><p>If is a class of formulas of some logic, then [ ] denotes the class of all formulas of vocabulary in L, and</p><p>[s] denotes the class of all formulas in whose vocabulary is at most s-ary. We write</p><formula xml:id="formula_1">A j= ' if, for some , A is a -structure, ' is in L[ ],</formula><p>and A is a model of '.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Coding issues</head><p>We use random access machines (RAMs) with the uniform cost measure as our underlying model of computation (cf. <ref type="bibr" target="#b0">[1]</ref>). Very often, the objects of our computations are structures. Therefore, we have to fix a way of representing structures on a RAM. The two most common ways of doing this are the array representation and the list representation. For both representations we assume that the universes of our structures are initial segments of the natural numbers; of course this is no real restriction because every structure is isomorphic to one with such a universe.</p><p>Both representations start with an encoding of the vocabulary and a natural number representing the size of the universe of the structure. The difference between the two representations is in how relations are stored. In the array representation, a k-ary relation is stored as a k-dimensional array with 0; 1-entries. For graphs, this is just the adjacency matrix. The advantage of this representation is that for each tuple it can be checked in constant time whether it belongs to the relation or not. However, for sparse relations this representation wastes a lot of space.</p><p>In the more concise list representation, a relation is represented as a list of all tuples it contains. Clearly, the list representation of a structure can be computed from the array representation in linear time, but not vice versa. For graphs G, it is easy to construct the common adjacency list representation from the list representation (in time linear in jGj + (size of the representation), where jGj denotes the number of elements in G). In this article, we always assume that structures are given in the list representation, but all results also hold for the array representation. The size of a structure A, denoted by jjAjj, is defined to be jAj+(size of the list representation of A). The complexity of algorithms on structures is measured in this size. Remark 10 shows that this can be relevant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Parameterized problems</head><p>We only recall those notions of the theory needed in this article. For a comprehensive treatment we refer the reader to Downey and Fellow's recent monograph <ref type="bibr" target="#b9">[10]</ref>. A parameterized problem is a set</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P</head><p>, where and are finite alphabets. Following <ref type="bibr" target="#b9">[10]</ref>, we usually represent a parameterized problem P in the following form:</p><formula xml:id="formula_2">P Input: x 2 . Parameter: y 2 .</formula><p>Question: Is (x; y) 2 P ?</p><p>In most cases, we have = f0; 1g and consider the parameters y 2 as natural numbers (in binary). A natural example is the parameterized version of the well-known VERTEX COVER problem:</p><formula xml:id="formula_3">VC Input: Graph G. Parameter: k 2 N.</formula><p>Question: Does G have a vertex cover of size k?</p><p>Recall that a vertex cover of a graph is a set X of vertices such that every edge is incident to one of the vertices in </p><formula xml:id="formula_4">f (jyj) jxj c . 1</formula><p>We denote the class of all fixed-parameter tractable problems by FPT.</p><p>Of course we can always consider parameterized problems as classical problems and determine their complexity in the classical sense. Clearly, every parameterized problem in PTIME is also in FPT.</p><p>The best currently known algorithm for vertex cover VC has running time O(k n + maxf1:255 k k<ref type="foot" target="#foot_1">2</ref> ; 1:291 k kg) <ref type="bibr" target="#b14">[15]</ref>, where n denotes the size of the input graph. Thus VC 2 FPT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Reductions between parameterized problems</head><p>It is conjectured that none of the problems DS, CLIQUE, SI is in FPT. As it is often the case in complexity theory, we can not actually prove this, but only prove that the problems are hard for certain complexity classes that are conjectured to contain FPT strictly. To do this we need a suitable concept of reduction. We actually introduce three different types of reduction: Definition 2 Let P and P 0 ( 0 ) ( 0 ) be parameterized problems. (1) A parameterized T-reduction from P to P 0 is an algorithm with an oracle for P 0 that solves any instance (x; y) of P in time f (jyj) jxj c in such a way that for all questions (x 0 ; y 0 ) 2 P 0 ? to the oracle we have jy 0 j g(jyj) (for computable functions f; g : N ! N and a constant c 2 N).</p><p>P is fixed-parameter T-reducible to P 0 (we write P fp T P 0 ), if there is a parameterized T-reduction from P to P 0 .</p><p>(2) A parameterized m-reduction from P to P 0 is an algorithm that computes for every instance (x; y) of P an instance (x 0 ; y 0 ) of P 0 in time f (jyj) jxj c such that jy 0 j g(jyj) and (x; y) 2 P () (x 0 ; y 0 ) 2 P 0 (for computable functions f; g : N ! N and a constant c 2 N).</p><p>P is fixed-parameter m-reducible to P 0 (we write P fp m P 0 ), if there is a parameterized m-reduction from P to P 0 . Whereas every parameterized problem that is in PTIME (when considered as a classical problem) is in FPT, it is not the case that every PTIME many-one reduction between two parameterized problems is also a parameterized m-reduction. To capture both concepts we occasionally use the following third kind of reduction: Definition 3 Let P and P 0 ( 0 ) ( 0 ) be parameterized problems. A pp m-reduction from P to P 0 is a parameterized m-reduction from P to P 0 that is also a polynomial time many-one reduction from P to P 0 in the classical sense, i.e. the function f in Definition 2(2) is a polynomial.</p><p>P is pp m-reducible to P 0 (we write P fpp m P 0 ), if there is a pp m-reduction from P to P 0 .</p><p>For example, CLIQUE fp m SI by the simple parameterized m-reduction that reduces the instance (G; k) of CLIQUE to the instance (G; K k ) of SI. Here K k denotes the complete graph with k vertices. Note that if we represent integers in binary, this reduction is not a pp m-reduction.</p><p>Observe that fp T , fp m , and fpp m are transitive and that for all P; P 0 we have = NP. To classify such problems, Downey and Fellows (cf. <ref type="bibr" target="#b9">[10]</ref>) introduced a hierarchy W[1] W <ref type="bibr" target="#b1">[2]</ref> of classes above FPT. These classes can best be defined in terms of the satisfiability problem for formulas of propositional logic. Formulas of propositional logic are build up from propositional variables X 1 ; X 2 ; : : : by taking conjunctions, disjunctions, and negations. The negation of a formula ' is denoted by :'. We distinguish between small conjunctions, denoted by ^, which are just conjunctions of two formulas, and big conjunctions, denoted by V , which are conjunctions over arbitrary finite sets of formulas. Analogously, we distinguish between small disjunctions, denoted by _, and big disjunctions, denoted by W . Every formula ' corresponds to a labeled tree T ' in a natural way. The size of ' is defined to be the number of vertices of T ' . The depth of ' is defined to be the maximum number of nodes labeled ^; V ; _; W on a path from the root to a leaf of T ' . Thus when computing the depth, we do not count negations.</p><formula xml:id="formula_5">P</formula><p>A formula is small if it only contains small conjunctions and small disjunction. We define C 0 = D 0 to be the class of all small formulas. For an i 1, we define C i to be the class of all big conjunctions of formulas in D i 1 , and we define D i to be the class of all big disjunctions of formulas in C i 1 . Note that these definitions are purely syntactical; every formula formula in a C i or D i is equivalent to a formula in C 0 . But of course the translation from a formula in C i to an equivalent formula in C 0 usually increases the depth of a formula. For all i; d 0 we let C i;d denote the class of all formulas in C i whose small subformulas have depth at most d (equivalently, we may say that the whole formula has depth at most d + i). We define D i;d analogously.</p><p>The weight of an assignment for the variables of a propositional formula is the number of variables set to TRUE by . For any class P of propositional formulas, let weighted satisfiability for P be the following parameterized problem:</p><formula xml:id="formula_6">WSAT(P ) Input: ' 2 P . Parameter: k 2 N.</formula><p>Question: Does ' have a satisfying assignment of weight k?</p><p>Now we are ready to define the W-hierarchy: For every t 1, we let</p><formula xml:id="formula_7">W[t] := [ d 0 [WSAT(C t;d )] fp m :</formula><p>In other words, a parameterized problem is in W[t] if there is a d 0 such that the problem is fixed-parameter m-reducible to the weighted satisfiability problem for C t;d . It is an immediate consequence of the definition of parameterized m-reductions that FPT W <ref type="bibr" target="#b0">[1]</ref>. Actually, it is conjectured that this inclusion is strict and that W[t] is strictly contained in W[t + 1] for every t 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5</head><p>The parameterized CLIQUE-problem is in W <ref type="bibr" target="#b0">[1]</ref>. To see this, for every graph G we describe a propositional formula ' := '(G) 2 C 1;1 such that G has a clique of size k if, and only if, ' has a satisfying assignment of weight k. It will be obvious from the construction that ' can be computed from G in polynomial time.</p><p>So let G be a graph. For all a 2 G let X a be a propositional variable. Let</p><formula xml:id="formula_8">' := â;b2G;a6 =b ab6 2E G (:X a _ :X b )</formula><p>Then every satisfying assignment of ' corresponds to a clique of G.</p><p>Actually, Downey and Fellows proved the following non-trivial result: (2) DS is W[2]-complete under parameterized m-reductions.</p><p>Remark 7 Downey and Fellows phrase their definition of the W-hierarchy in terms of Boolean circuits rather than propositional formulas. But since the classes of the hierarchy only involve circuits/formulas of bounded depth, this does not really make a difference (cf. <ref type="bibr" target="#b9">[10]</ref>). In their definition of W[t], Downey and Fellows admit more complicated formulas than those in C t . But they prove that our definition is equivalent. A surprising by-product of their results is that for every t 1 and every d 0, the problem</p><formula xml:id="formula_9">WSAT[D t+1;d ] is contained in W[t].</formula><p>It is not hard to prove this result directly, and even easier to prove that WSAT[D 1;d ] is in FPT. (This explains why we only defined a hierarchy using the</p><formula xml:id="formula_10">C t s).</formula><p>There is another, more serious source of confusion in the various definitions of the W-hierarchy: Downey and Fellows are never really clear about what kind of reductions they are using to define the classes. We decided, more or less in accordance with <ref type="bibr" target="#b9">[10]</ref>, that parameterized m-reductions are most natural.</p><p>We will further discuss the W-hierarchy and other seemingly intractable classes in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Model-checking</head><p>In this article we are mainly concerned with the complexity of various parameterized model-checking problems. For a set of formulas, we let</p><formula xml:id="formula_11">MC( ) := (A; ') A 2 STR; ' sentence in ; A j= ' ;</formula><p>or more intuitively,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MC( )</head><p>Input: A 2 STR. Parameter: ' 2 .</p><p>Question: Does A j= '?</p><p>In this section we collect a few basic facts about parameterized model-checking problems. For every we consider, we assume that we have fixed an encoding : ! f0; 1g , and we let jj'jj be the length of (').</p><p>Taking sentences as parameters seems a little unusual. The following parameterization of the model checking problem looks more natural:</p><formula xml:id="formula_12">MC 0 ( ) Input: A 2 STR, ' 2 . Parameter: jj'jj.</formula><p>Question: Does A j= '?</p><p>However, it is easy to see that MC( ) fp m MC 0 ( ). It is well-known that various problems of model theory or complexity theory can be reduced from structures to graphs. The following two lemmas contain such reductions. Although their proofs only use standard techniques, they are subtle and require some care. Therefore we decided to give the proofs in some detail. We will apply these lemmas several times later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 8</head><p>There are polynomial time transformations that associate with every structure A 2 STR a graph H(A) and with every sentence ' 2 FO a sentence ' GRAPH 2 FO, respectively, such that</p><formula xml:id="formula_13">A j= ' () H(A) j= ' GRAPH : Furthermore for every t 1, if ' 2 t then ' GRAPH 2 t+1 and if ' 2 t then ' GRAPH 2 t+1 . Proof: Let A 2 STR[ ] and ' 2 FO[ ].</formula><p>Without loss of generality we can assume that ' is in prenex and in negation normal form.</p><p>Step 1. In the first step we translate A to a structure B(A) of a vocabulary ( ) that only consists of unary and binary relation symbols. ' is translated to a corresponding sentence ' B of vocabulary ( ).</p><p>( ) contains unary relation symbols U and U R for each symbol R 2 and binary relation symbols E 1 ; : : : ; E s , where s is the arity of .</p><p>The universe of B(A) is</p><formula xml:id="formula_14">B(A) := A [ fb(R; a) j R 2 ; a 2 R A g:</formula><p>We assume that the elements b(R; a) are all pairwise distinct and distinct from those in A. Note that the cardinality of B(A) is essentially jjAjj, up to an additive term depending on . The unary relations are defined in the obvious way:</p><p>We let U B(A) := A and U B(A) R := fb(R; a) j a 2 R A g for every R 2 . The binary relations E 1 ; : : : ; E s are defined by</p><formula xml:id="formula_15">E B(A) i := f(a i ; b(R; a)); (b(R; a); a i ) j R 2 ; a = (a 1 ; : : : ; a r ) 2 R A ; 1 i rg: Note that E B(A) i</formula><p>is symmetric, this will be useful later. To define ' B , we first relativize all quantifiers to U , i.e. we inductively replace all subformulas 9x by 9x(U x^ ) and all subformulas 8x by 8x(U x ! ). We obtain a formula ' 0 . ' B is obtained from ' 0 by replacing every atomic subformula R x, for r-ary R 2 , by</p><formula xml:id="formula_16">9z(U R z ^r î=1 E i x i z)<label>(1)</label></formula><p>where z is a new variable. Then we have</p><formula xml:id="formula_17">A j= ' () B(A) j= ' B :<label>(2)</label></formula><p>Furthermore, B(A) can be computed from A in time O(jj jj jjAjj), where jj jj denotes the length of the encoding of , and ' B can be computed from ' in linear time.</p><p>Step 2. In this step we replace the binary relations E 1 ; : : : ; E s by a single new binary relation E. We let Step 3. The restriction of C(A) to E is already a graph, i.e. E C(A) is symmetric and irreflexive, so all we have to do is to eliminate the unary relations U; (U R ) R2 ; (P i ) 1 i s . Say, Q 1 ; : : : ; Q l is an enumeration of all these relations. Note that every a 2 C(A) is either isolated or of valence two or adjacent to a vertex of valence two. We use this to define certain trees T 1 ; : : : ; T l and corresponding existential first-order formulas 1 (x); : : : ; l (x) and attach a copy of T i to each vertex in Q</p><formula xml:id="formula_18">C(A) i</formula><p>in such a way that in the resulting graph H(A) we have for all vertices a:</p><formula xml:id="formula_19">H(A) j= i (a) () a 2 Q C(A) i :</formula><p>Furthermore, the T i and thus the i can be chosen of size polynomial in l. We omit the details.</p><p>Then we let ' GRAPH be the formula obtained from ' C by replacing every subformula of the form Q i x by i (x), for 1 i l, and transforming the resulting formula into prenex normal form in the usual manner.</p><p>Clearly the transformations A 7 ! H(A) and ' 7 ! ' GRAPH are polynomial, and we have</p><formula xml:id="formula_20">A j= ' () H(A) j= ' GRAPH :</formula><p>It remains to prove that if ' 2 t (' 2 t ) then ' GRAPH 2 t+1 (' GRAPH 2 t+1 , respectively). This follows easily from the way we defined the sentences ' B , ' C , and ' GRAPH in Steps 1-3, noting that each positive (negative) occurrence of a relation symbol R 2 only gives rise to positive (negative, respectively) occurrences of U R , the E i , and the P i . Thus for the positive occurrences of the R 2 we get a new block of existential quantifiers and for the negative occurrences a new block of universal quantifiers. This increases the alternation depth by at most one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Recall that for a class C of structures and an s 0, by C[s] we denote the class of all structures in C whose vocabulary is at most s-ary. Similarly, for a class of formulas, by [s] we denote the class of all formulas in whose vocabulary is at most s-ary. We first transform A to an A 0 and ' to a ' 0 in the same prefix class such that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 9 Let</head><formula xml:id="formula_21">A j= ' () A 0 j= ' 0 ;</formula><p>and either all relation symbols in ' 0 occur positively or negatively, whichever we need to apply the previous remark. For this purpose, let be an at most s-ary vocabulary. We let 0 := [ fR j R 2 g, where R is a new relation symbol that has the same arity as R. For every A 2 STR[ ], we let A 0 be the 0 -expansion of A with R A 0 = A r n R A for r-ary R 2 . Note that A 0 can be computed from A in time O(jjAjj s ). To define ' 0 we either replace each negative literal :R x by R x or each positive literal R x by :R x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Remark 10 Note that if we represent structures by the array representation, then the transformation of Lemma 9 is actually polynomial even if we do not fix the arity of the vocabulary in advance. This follows from the fact that the array representation of the structure A 0 (in the proof of the lemma) can be computed from the array representation of A in linear time, uniformly over all vocabularies.</p><p>For a parameterized problem P STR and a class C of structures we let P j C denote the restriction of P to C. In particular, MC( )j GRAPH = f(G; ') j G 2 GRAPH; ' 2 ; G j= 'g:</p><p>Note that for every class of formulas and vocabulary the two problems MC( [ ]) and MC( )j STR[ ] , though formally different, are essentially the same. Therefore we do not distinguish between them. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 11 (1) MC(FO)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Defining parameterized problems</head><p>Definability is the connection between arbitrary parameterized problems and our logical analysis that focuses on model-checking problems. In <ref type="bibr" target="#b10">[11]</ref> We often consider X as a relation variable and thus write '(X) 2 [ ] instead of ' 2 [ [ fXg] and A j= '(B) instead of (A; B) j= '.</p><p>For example, parameterized vertex cover VC is Fagin-defined by the formula</p><formula xml:id="formula_22">' VC := 8y8z Eyz ! (Xy _ Xz) : It is easy to see that every problem that is FO-Fagin-definable is also FO-slicewise definable. Indeed, if P STR[ ] N is Fagin-defined by a formula '(X) 2 FO[ ],</formula><p>where X is r-ary, then it is slicewise FO-defined via the function</p><formula xml:id="formula_23">: N ! FO[ ] with (k) = 9 x 1 : : : 9 x k ( V 1 i&lt;j k x i 6 = x j ^'k )</formula><p>, where x 1 ; : : : ; x k are r-tuples of distinct variables not occurring in ' and ' k is the sentence obtained from ' by replacing each subformula of the form X y by W k i=1 x i = y. Fagin-definability implies slicewise definability also for other reasonable classes of formulas, e.g., for the class 1  1 of formulas of second-order logic of the form 9X 1 : : : 9X l , where X 1 ; : : : X l are relation variables and is first-order.</p><p>The converse is certainly not true, not even for problems of the specific form P STR[ ] N: It is obvious that there are slicewise FO-definable problems of arbitrarily high classical complexity (choose in Definition 12 arbitrarily complex). On the other hand we have the following characterization of 1  1 -Fagin-definable problems. Proposition 14 Let P STR[ ] N. Then, ( <ref type="formula" target="#formula_16">1</ref>) and ( <ref type="formula" target="#formula_17">2</ref>) are equivalent, where (1) P is 1  1 -Fagin-definable. (2) P is in NP (when considered as a classical problem) and for some r 1, (A; k) 2 P implies k jAj r .</p><p>Proof: The implication of ( <ref type="formula" target="#formula_16">1</ref>) ) (2) being clear, we turn to a proof of ( <ref type="formula" target="#formula_17">2</ref>) ) (1). Choose r according to <ref type="bibr" target="#b1">(2)</ref>. Then, f(A; B) j B A r and (A; jBj) 2 P g is a class of [ fXg-structures in NP, where X is r-ary. By Fagin's Theorem <ref type="bibr" target="#b13">[14]</ref>, there is a 1 1 -formula '(X) of vocabulary [ fXg axiomatizing this class. Then, '(X) 1  1 -Fagin-defines P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Thus, slicewise definability is the more general notion. Nevertheless, Fagin definability can be very useful. We illustrate this by the following generalization of a result due to Cai and Chen, namely Theorem 3.5 of <ref type="bibr" target="#b2">[3]</ref>, which is based on a result due to Kolaitis and Thakur <ref type="bibr" target="#b23">[24]</ref> that syntactically characterizes certain minimization problems. It is motivated by comparing the formula ' VC defining the fixed-parameter tractable problem VC with the following formulas ' DS and ' CLIQUE defining the W[1]-hard problems DS and CLIQUE, respectively:</p><formula xml:id="formula_24">' DS := 8y9x(Xx ^(x = y _ Exy) ; ' CLIQUE := 8y8z (Xy ^Xz) ! (y = z _ Eyz) :</formula><p>Observe that in ' DS the relation variable X is in the scope of an existential quantifier and in ' CLIQUE it occurs negatively.</p><p>Theorem 15 Let be a vocabulary and P STR[ ] N a parameterized problem that is Fagin-defined by a FO[ ]formula '(X) in which X does not occur in the scope of an existential quantifier or negation symbol. Then P is in FPT.</p><p>Proof: For simplicity, let us assume that X is unary. Without loss of generality we can assume that ' = 8y 1 : : :</p><formula xml:id="formula_25">8y l m _ i=1 p ĵ=1 ij ;</formula><p>where each ij either is Xy q for some q 2 f1; : : : ; lg, or a first-order formula with free variables in fy 1 ; : : : ; y l g in which X does not occur. In a preprocessing phase we replace the latter ones by atomic formulas: For each such ij we introduce a new relation symbol R ij whose arity matches the number of free variables of ij and let be the set of all these relation symbols. We let ' be the formula obtained from ' by replacing each subformula ij ( z) by R ij z. Then ' = 8y 1 : : : 8y l W m i=1 i , where each i is a conjunction of atomic formulas. For a structure A 2 STR[ ] we let A be the -structure with universe A and with</p><formula xml:id="formula_26">R A ij := f a j A j= ij ( a)g: Then we have for B A, A j= '(B) () A j= ' (B): Given A, each R A ij can be computed in time O(jAj jj ij jj</formula><p>), thus A can certainly be computed in time O(jAj jj'jj ). For 1 i m, a = a 1 : : : a l 2 A l , and B A we let (B; a; i) := B [ fa j j Xy j is a conjunct of i g: Since i (X; y) is positive in X, the following two statements are equivalent for every B 0 with B B 0 A:</p><formula xml:id="formula_27">A j= i (B 0 ; a).</formula><p>(B; a; i) B 0 and A j= i ( (B; a; i); a). This equivalence is used by Algorithm 1 to decide P .</p><p>Recall that, given a -structure A and a parameter k 2 N, the algorithm is supposed to decide whether there is a B A with jBj = k such that for all a 2 A l there is an i such that A j= i (B; a). The crucial observation to see that the algorithm is correct is that whenever the main loop in Lines 3-10 is entered, S is a set of subsets B A such that jBj k and for all a considered so far (in earlier runs through the loop) we have A j= W m i=1 i (B; a). To get a bound on the running time, we note that whenever a new set is added to S (in Line 10) then it is an extension of a strictly smaller set that has just been removed from S (in Line 6). Furthermore, for each set removed (in Line 6) at most m such extensions can be added. Thus an upper bound for the number of sets that can be in S at any time is m k . The main loop (in Lines 3-10) is called n l times, where n := jAj. This gives an overall bound on the running time of O(m k n l ) plus the time needed to compute A .</p><p>Since l does not depend on the instance, but just on the formula ', this yields the fixed-parameter tractability of P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Besides VC, many other parameterized problems can be shown to be fixed-parameter tractable by a simple application of this theorem. Let us consider one example in detail: The valence of a graph is the maximal number of neighbors a vertex in the graph has. This problem is Fagin-defined by the following first-order formula:</p><p>8x9 l z Exz ^8y 0 8y 1 : : :</p><formula xml:id="formula_28">8y l 8z(Ey 0 z ! l _ i=1 z = y i ) ! l _ i=0</formula><p>Xy i :</p><p>(9 m x (x) abbreviates 9y 1 : : :</p><formula xml:id="formula_29">9y m 8x( (x) ! W m i=1 x = y i ).</formula><p>) Other examples of problems that can be shown to be in FPT by Theorem 14 are HITTING SET FOR SIZE THREE SETS, MATRIX DOMINATION, or SHORT 3DIMENSIONAL MATCHING of <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Homomorphisms, embeddings, and model-checking</head><p>In this section we analyze the close relationship between the homomorphism problem, the embedding problem, and model-checking problems for 1 -formulas from the point of view of parameterized complexity (compare <ref type="bibr" target="#b24">[25]</ref> for a further analysis of this relationship).</p><p>A homomorphism from a -structure B into a -structure A is a mapping h : B ! A such that for all R 2 and tuples b 2 R B we have h( b) 2 R A . The parameterized HOMOMORPHISM PROBLEM (HOM) is defined as follows:  With each first-order formula ' we associate a graph G('). Its universe is var('), the set of all variables in ', and there is an edge between distinct x; y 2 var(') in G(') if ' has an atomic subformula in which both x; y occur.</p><p>Let ' 6 = be the formula obtained from ' by deleting all inequalities, i.e. all atomic subformulas of the form x = y that occur in the scope of an odd number of negation symbols. We are also interested in G(' 6 = ). Let us see an example:</p><formula xml:id="formula_30">' := 9x 1 : : : 9x k 1 i&lt;j k :x i = x j ^k 1 î=1 Ex i x i+1 :</formula><p>G(') is the complete graph with vertex set fx 1 ; : : : ; x k g, whereas G(' 6 = ) is the path x 1 : : : x k . Note that ' says that a graph has a subgraph isomorphic to a path of length k, whereas ' 6 = says that a graph contains a homomorphic image of a path of length k. This generalizes to the following simple lemma, whose proof we omit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 17</head><p>For every structure B 2 STR there is a 1 -sentence ' B (whose quantifier-free part is a conjunction of literals) such that G(' 6 = B ) = G(B), and for every structure A we have:</p><p>A j= ' B () There is an embedding of B into A.</p><p>A j= ' 6 = B () There is a homomorphism from B to A. Furthermore, the mapping B 7 ! ' B is computable in linear time.</p><p>For s 2 N and a class C of graphs we let Let S be a binary relation symbol not contained in and 0 := [ fSg. Furthermore, let A 0 be the 0 -expansion of A with S A 0 = ;. Our algorithm first computes a sentence ' 0 := W m i=1 9 x i i of vocabulary 0 such that (1) A j= ' if, and only if, A 0 j= ' 0 .</p><p>(2) For 1 i m, the formula i is a conjunction of literals, and we have</p><formula xml:id="formula_31">G( i ) = G(').</formula><p>This can be achieved by first translating ' to a sentence whose quantifier-free part is in disjunctive normal form, then swapping existential quantifiers and the disjunction, and then adding dummy literals of the form :Sxy until</p><formula xml:id="formula_32">G( i ) = G(').</formula><p>Let 00 := 0 [ fR j R 2 0 g [ fE; Eg, where for all R 2 0 the symbol R is a new relation symbol of the same arity as R and E; E are new binary relation symbols. Let A 00 be the 00 expansion of A 0 in which R is interpreted as the complement of R A 00 and E; E are interpreted as equality and inequality, respectively. For 1 i m, we define a 00 -structure B i with G(B i ) = G(') such that A 0 j= 9 x i i if, and only if, there is a homomorphism from B i into A 00 . We let B i be the 00 -structure with universe var( i ) and R Bi := fy j Ry is a literal of i g (for R 2 0 ); R Bi := fy j :Ry is a literal of i g (for R 2 0 );</p><formula xml:id="formula_33">E Bi := fyz j y = z is a literal of i g; E Bi := fyz j :y = z is a literal of i g:</formula><p>It is obvious that B i does indeed have the desired property. Altogether, our construction yields a parameterized Treduction.</p><p>It remains to prove that MC(</p><formula xml:id="formula_34">6 = 1 [s; C]) fp T MC( 1 [s; C]).</formula><p>We use the so called color coding technique of Alon, Yuster, and Zwick <ref type="bibr" target="#b1">[2]</ref>.</p><p>Let l 1 and X a set. An l-perfect family of hash functions on X is a family F of functions f : X ! f1; : : : ; lg such that for all subsets Y X of size l there is an f 2 F such that f (Y ) = f1; : : : ; lg (i.e. on Y , f is one-to-one). Alon, Yuster, and Zwick <ref type="bibr" target="#b1">[2]</ref> show that given n; l 1, an l-perfect family of hash functions on f1; : : : ; ng of size 2 O(l) log n can be computed in time 2 O(l) n log n.</p><p>For a similar reason as outlined above, without loss of generality we can restrict our attention to sentences ' 2 MC( 6 = 1 [s; C]) whose quantifier-free part is a conjunction of literals. Given such a sentence ' = 9x 1 : : : 9x k , say of vocabulary , and a -structure A, we define a family of sentences ' 2 MC( 1 [s; C]) and a family of structures A f such that A j= ' if, and only if, there is a and f such that A f j= ' .</p><p>A coloring of ' is a function : f1; : : : ; kg ! f1; : : : ; kg such that (i) 6 = (j) if :x i = x j occurs in '. For a coloring we let be the formula obtained from by replacing all literals :x i = x j by C (i) x i ^C (j) x j (here, C 1 ; : : : ; C k are new unary "color" relation symbols) and let ' := 9x 1 : : :</p><formula xml:id="formula_35">9x k . Note that G(' ) = G(' 6 = ). Thus ' 2 MC( 1 [s; C]).</formula><p>With every f : A ! f1; : : : ; kg, which we call a coloring of A, we let A f be the [ fC 1 ; : : : ; C k g-expansion of</p><formula xml:id="formula_36">A with C A f i := f 1 (i) for 1 i k. Observe that</formula><p>A j= ' () there is a coloring of ' and a coloring f of A such that A f j= ' .</p><p>(</p><formula xml:id="formula_37">)<label>3</label></formula><p>The problem is that there are k jAj colorings of A, so <ref type="bibr" target="#b2">(3)</ref> does not yet give rise to a parameterized reduction. The crucial trick is that to achieve this equivalence we do not have to consider all possible colorings f of A. For 1 l k, let F l be an l-perfect family of hash-function on A and F := S k l=1 F l . We claim that A j= ' () there is a coloring of ' and an f 2 F such that A f j= ' .</p><p>(4)</p><p>The backward direction follows immediately from (3). For the forward direction, suppose that A j= '. Let a 2 A k such that A j= ( a). There is a function f 2 F whose restriction to fa 1 ; : : : ; a k g is one-to-one. Define by</p><formula xml:id="formula_38">(i) := f (a i ).</formula><p>Then, is a coloring of ', A f j= ( a) and hence, A f j= ' . Since the family F can be chosen sufficiently small and computed sufficiently fast, the equivalence (4) gives rise to a parameterized reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Remark 19</head><p>We do not know if the parameterized T-reductions in Theorem 18 can be replaced by parameterized mreductions. However, for many interesting classes C they can be replaced. One such example is the class of all graphs. Similar techniques work for all classes C of graphs for which there exists an algorithm that, given a graph H 2 C, computes a connected H 0 2 C such that H is a subgraph of H 0 . For all such classes C we can show that</p><formula xml:id="formula_39">HOM[s; C] fp m EMB[s; C] fp m MC( 6 = 1 [s; C]) fp m MC( 1 [s; C]</formula><p>): (for all s 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Sentences of bounded tree-width</head><p>Our main application of Theorem 18 is to sentences whose underlying graphs have bounded tree-width. In the time since we submitted this article, considerable progress has been made in this area. For an extensive discussion of model-checking algorithms based on tree-decompositions of the sentences, we refer the reader to <ref type="bibr" target="#b15">[16]</ref>.</p><p>We think of a tree T as directed from its root, which we denote by r T , to the leaves and thus can speak of a child and of the parent of a vertex.</p><p>A tree-decomposition of a -structure A is a pair (T ; (A t ) t2T ), where T is a tree and (A t ) t2T a family of subsets of A such that (1) For every a 2 A, the set ft 2 T j a 2 A t g is non-empty and induces a subtree of T (that is, is connected).</p><p>(2) For every k-ary relation symbol R 2 and all a 1 ; : : : ; a k 2 A such that R A a 1 ; : : : ; a k there exists a t 2 T such that a 1 ; : : : ; a k 2 A t .</p><p>The width of a tree-decomposition (T ; (A t ) t2T ) is maxfjA t j j t 2 T g 1. The tree-width tw(A) of A is the minimal width of a tree-decomposition of A.</p><p>For s 1, let W s denote the class of all structures of tree-width at most s and GW s := GRAPH \ W s . Note that</p><formula xml:id="formula_40">W s STR[s + 1]</formula><p>, because a graph of tree-width s has clique number at most s + 1.<ref type="foot" target="#foot_2">2</ref> (The clique number of a graph G is the maximal cardinality of a set of pairwise adjacent vertices of G.) Plehn and Voigt <ref type="bibr" target="#b26">[27]</ref> were the first to realize that tree-width is a relevant parameter for the problems considered in the previous section. They proved that the parameterized embedding problem restricted to (parameter) graphs of bounded tree-width is fixed parameter tractable. Chekuri and Rajaraman <ref type="bibr" target="#b5">[6]</ref> proved that for every s 1 the problem HOM[GW s ] is in PTIME (when considered as an unparameterized problem) and therefore fixed-parameter tractable. They phrased their result in terms of the equivalent conjunctive query containment problem (also see <ref type="bibr" target="#b24">[25]</ref>).</p><p>Thus as a corollary of Theorem 18 we obtain:</p><formula xml:id="formula_41">Corollary 20 Let s 1. Then the problems EMB[GW s ], MC( 1 [GW s ]</formula><p>), and MC( 6 = 1 [GW s ]) are in FPT. Papadimitriou and Yannakakis <ref type="bibr" target="#b25">[26]</ref> proved the model-checking results of this corollary for the related case of acyclic conjunctive queries.</p><p>Unfortunately, it turns out that Corollary 20 is the only real application of Theorem 18. Very recently, Schwentick, Segoufin, and the second author <ref type="bibr" target="#b19">[20]</ref> have proved that for every class C of graphs of unbounded tree-width and every s 2, the problem HOM[C; s] is W <ref type="bibr" target="#b0">[1]</ref>-complete under parameterized T-reductions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">FO-model-checking on graphs with excluded minors</head><p>The fixed-parameter tractability results of the previous section were obtained by putting syntactical restrictions on the sentences, i.e. the parameter of the model-checking problem. In this section we put restrictions on the structures, i.e. the input of the model-checking problem.</p><p>Recall the definition of the parameterized problem MC( )j D , for a class of formulas and a class D of structures:</p><formula xml:id="formula_42">MC( )j D Input: A 2 STR. Parameter: ' 2 .</formula><p>Question: Is A 2 D and A j= '?</p><p>Our starting point is the following theorem due to Courcelle. Remember that monadic second-order logic is the extension of first-order logic where one is allowed to quantify not only over individual elements of a structure but also over sets of elements. MSO denotes the class of all formulas of monadic second-order logic. Remember that W s denotes the class of all structures of tree-width at most s (for s 0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 21 ([7]</head><p>) Let s 0. Then MC(MSO)j Ws is in FPT.</p><p>A graph H is a minor of a graph G (we write H G) if H is can be obtained from a subgraph of G by contracting edges. H is an excluded minor for a class D if H is not a minor of any graph in D. Note that a class D of graphs has an excluded minor if, and only if, there is an n 2 N such that K n is an excluded minor for D.</p><p>Examples of classes of graphs with an excluded minor are classes of graphs of bounded tree-width or classes of graphs embeddable in a fixed surface.</p><p>Recall that for a class D of graphs, STR <ref type="bibr">[D]</ref> denotes the class of all structures whose Gaifman graph is in C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 22</head><p>Let D be a PTIME-decidable class of graphs with an excluded minor. Then MC(FO)j STR <ref type="bibr">[D]</ref> is in FPT.</p><p>The rest of this section is devoted to the proof of this theorem, which needs some preparation. A class D of graphs is called minor closed if for all G 2 D and H G we have H 2 D. Robertson and Seymour proved:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 23 ([28]) Every minor-closed class of graphs is PTIME-decidable.</head><p>This, together with Theorem 22, immediately yields:</p><formula xml:id="formula_43">Corollary 24 Let D &amp; GRAP H be minor closed. Then MC(FO)j STR[D] is in FPT.</formula><p>Recall the definition of the Gaifman graph G(A) of a structure A (cf. Page 13). The distance d A (a; b) between a; b 2 A is the length of the shortest path from a to b in G(A). For r 2 N and a 2 A, the r-ball around a is the set B A r (a) := fb 2 A j d A (a; b) rg. For an X A, hXi A denotes the substructure induced by A on X, i.e. the structure with universe X and R hXi A = R A \ X r for all r-ary relation symbols R in the vocabulary of A. Furthermore, we let A n X := hA n Xi A .</p><p>The local tree-width of A is the function ltw(A) : N ! N defined by ltw(A)(r) := max tw(hB A r (a)i A ) a 2 A :</p><p>For functions f; g : N ! N we write f g if f (n) g(n) for all n 2 N. A class D of structures has bounded local tree-width if there is a function : N ! N such that for all A 2 D we have ltw(A) . The "local" character of first-order formulas allows to generalize Theorem 21 for first-order logic from classes of structures of bounded tree-width to classes of structures of bounded local tree-width:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 25 ([17]) Let D be a PTIME-decidable class of structures of bounded local tree-width. Then MC(FO)j</head><formula xml:id="formula_44">D is in FPT. For : N ! N we let GL( ) := G 2 GRAPH 8H G : ltw(H) ;</formula><p>and, for 2 N, B( ;</p><formula xml:id="formula_45">) := A 2 STR 9X A (jXj ^G(A n X) 2 GL( )) :</formula><p>Note that the clique-number of a graph in GL( ) is at most (1) + 1, thus the clique-number of a graph in B( ; ) is at most + (1) + 1. This implies that B( ;</p><formula xml:id="formula_46">) STR[ + (1) + 1]. 3</formula><p>Lemma 26 Let : N ! N and 2 N. Then MC(FO)j B( ; ) is in FPT.</p><p>Proof: The class GL( ) of graphs is minor closed and hence PTIME-decidable by Theorem 23. This implies that</p><formula xml:id="formula_47">B( ; ) is PTIME-decidable.</formula><p>Then for = 0 the statement follows from Theorem 25. The case &gt; 0 can be reduced to the case = 0 as follows: For every A 2 B( ; ) and sentence ' 2 FO, we define a structure A 2 B( ; 0) and a sentence ' 2 FO in such a way that A j= ' if, and only if, A j= ' , and the mappings A 7 ! A and ' 7 ! ' are computable in polynomial time.</p><p>So suppose we are given A 2 B( ; ) and ' 2 FO. For simplicity, we assume that their vocabulary consists of a single binary relation symbol E.</p><p>Let X A such that jXj and A n X 2 B( ; 0). Such an X can be computed in polynomial time because the class B( ; 0) is PTIME-decidable. Say, X = fa 1 ; : : : ; a g. Let := fE; P 1 ; : : : ; P ; Q 1 ; : : : ; Q ; R 1 ; : : : ; R g, where the P i , Q i , and R i are unary. We let A := A, E A := E A \ (A n X) 2 , and, for 1 i</p><formula xml:id="formula_48">P A i := fa i g; Q A i := fb 2 A j E A a i bg; R A i := fb 2 A j E A ba i g:</formula><p>Furthermore, we let ' be the sentence obtained from ' by replacing each subformula Exy by</p><formula xml:id="formula_49">Exy _ _ i=1 ((P i x ^Qi y) _ (P i y ^Ri x)):</formula><p>Clearly, these definitions lead to the desired result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>To complete the proof of Theorem 22 we use a decomposition theorem for non-trivial minor-closed classes of graphs that roughly says that all graphs in such a class are built up in a tree-like manner from graphs in a B( ; ). It is based on Robertson and Seymour's deep structure theory for graphs without K n -minors. The precise statement requires some new notation. Let (T ; (A t ) t2T ) be a tree-decomposition of a structure A. The torso of this decomposition at t 2 T , denoted by [A t ], is the graph with universe A t and an edge between two distinct vertices a; b 2 A t if either there is an edge between a and b in the Gaifman graph G(A) or there exists an s 2 T n ftg such that a; b 2 A s .</p><p>(T ; (A t ) t2T ) is a tree-decomposition over a class D of graphs if all its torsos belong to D. of the universe. ORD denotes the class of all ordered structures. In this section, always denotes a vocabulary that contains .</p><p>One of the most important results in descriptive complexity theory is the Immerman-Vardi Theorem <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b29">30]</ref> saying that a class of ordered structures is in PTIME if, and only if, it is definable in least-fixed point logic FO(LFP). More concisely, PTIME = FO(LFP):</p><p>We prove a similar result characterizing the class FPT in terms of the finite variable least fixed-point logics LFP s , for s 1, which were introduced by Kolaitis and Vardi <ref type="bibr" target="#b22">[23]</ref>. Analogously to the classical setting we model parameterized problems by subsets of ORD[ ] N, for some .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 29 A parameterized problem P</head><p>ORD[ ] N is in FPT if, and only if, there is an s 1 such that P is slicewise LFP s -definable. More concisely, we may write</p><formula xml:id="formula_50">FPT = [ s 1 slicewise-LFP s :</formula><p>In the proof of this result we assume that the reader is familiar with descriptive complexity theory, in particular with least fixed-point logic and the proof of the Immerman-Vardi Theorem. Those who are not may safely skip the rest of this section.</p><p>We first recall the definition of LFP s : In the terminology of <ref type="bibr" target="#b12">[13]</ref>  We use the following two facts, the first implicit in <ref type="bibr" target="#b30">[31]</ref> and the second in the proof of the Immerman-Vardi Theorem (cf. <ref type="bibr" target="#b12">[13]</ref>). Fix and s 2 N and let n always denote the size of the input structure.</p><p>(1) There is a computable function that associates an O(n 2s )-algorithm A ' with each ' 2 LFP s [ ] such that A ' accepts a structure A 2 ORD[ ] if, and only if, A satisfies '.</p><p>(2) There is a t 2 N and a computable function that associates with every O(n s )-algorithm A accepting a class</p><formula xml:id="formula_51">C ORD[ ] a sentence ' A 2 LFP t [</formula><p>] such that a -structure A satisfies ' A if, and only if, A 2 C. There is a slight twist in <ref type="bibr" target="#b1">(2)</ref>. When proving it one usually assumes that all structures are sufficiently large, in particular larger than the constant hidden in O(n s ). This way it can be assumed that the algorithm is actually an n s+1 -algorithm (without any hidden constants.) Then one argues that small structures are no problem because they can be described up to isomorphism in first-order logic. When restricting the number of variables, one has to be careful with such an argument. Luckily, we are safe here because we only consider ordered structures, and there is a t 2 N (depending on ) such that every structure A 2 ORD[ ] can be characterized up to isomorphism by an FO t -sentence.  Question: Does M accept the empty word in at most k steps with at most t alternations?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (of</head><p>Note that NM = AM 1 , thus W[1] = A <ref type="bibr" target="#b0">[1]</ref>. Our following theorem can be seen as a natural generalization of Theorem 30.</p><p>Theorem 32 For all t 1, the problem MC( t )j GRAPH is A[t]-complete under parameterized m-reductions. Thus</p><formula xml:id="formula_52">A[t] = [MC( t )j GRAPH ] fp m = [ s 1 [MC( t [s])] fp m :</formula><p>Proof: The second equality follows from Corollary 11(3).</p><p>To prove that MC( t )j GRAPH fp m AM t , we first observe that, for every graph G and every quantifier-free formula (x 1 ; : : : ; x m ), in time p(jj jj) jGj 2 , for a suitable polynomial p, we can construct a deterministic Turing machine M (G; ) with input alphabet G that accepts an input word a 1 : : : a m over G if, and only if, G j= (a 1 ; : : : ; a m ) and that performs at most f (jj jj) steps for some computable function f : N ! N. Just to give an example, to check whether Ex k x l holds, say with k &lt; l, we need states s(i) for 1 i k and s(i; a) for k &lt; i l; a 2 G. The machine starts in state s(1) with head in position 1 in state s(1). It moves its head right until it reaches position k in state s(k), reads a k and goes to position (k + 1) in state s(k + 1; a k ). Then it moves right again until it reaches position l in state s(l; a k ). From this state it can reach an accepting state if, and only if, E G a k a l . Now suppose we are given an instance of MC( t )j GRAPH , i.e. a graph G and a sentence ' = 9x 11 : : : 9x 1k1 8x 21 : : : 8x 2k2 : : : Qx t1 : : : Qx tkt ;</p><p>where is quantifier-free. Then the following alternating Turing machine M (G; ') accepts the empty word if, and only if, G j= ': It first writes a sequence of elements of G on the tape using existential and universal states appropriately and then simulates M (G; ) on this input. Again g(jj jj), for some computable function g, is an upper bound for the number of steps M (G; ') has to perform.</p><p>To finish the proof, by Corollary 11(3) it suffices to show that AM t fp m MC( t [ ]) for a suitable vocabulary . To illustrate the idea, we first consider the case t = 1. Suppose we are given a nondeterministic Turing machine M with alphabet , set Q of states, initial state q 0 , accepting state q acc and transition relation . Let H := fa H j a 2 g, a H coding the information that the head of M scans a cell containing a. Let := fST; AL; H; IN; ACC; R; L; Sg with unary ST; AL; H; IN; ACC and 4-ary R; L; S and let A M be the -structure given by</p><formula xml:id="formula_53">A M := Q _ [ _ [ H ; ST AM := Q; AL AM := ;</formula><p>H AM := H ; IN AM := fq 0 g; ACC AM := fq acc g; R AM := f(q; a H ; b; q 0 ) j (q; a; 1; b; q 0 ) 2 g; L AM := f(q; a H ; b; q 0 ) j (q; a; 1; b; q 0 ) 2 g; S AM := f(q; a H ; b H ; q 0 ) j (q; a; 0; b; q 0 ) 2 g [ f(q acc ; a H ; a H ; q acc ) j a 2 g; where (q; a; h; b; q 0 ) 2 means: if M is in state q and its head scans a 2 , then M replaces a by b, moves its head one cell to the right (h = 1), to the left (h = 1), or does not move its head (h = 0); finally, it changes to state q 0 . Let k be given as parameter for AM 1 . In k steps, M scans at most the first k cells. The quantifier-free formula (note that the following formulas only depend on k and not on M ) ' config (x; y 1 ; : : : ; y k ) := STx ^k _ i=1 (Hy i ^ĵ6 =i ALy j ) states that (x; y 1 ; : : : ; y k ) is a configuration with state x, with the head facing y i , and with y j being the content of the jth cell (j 6 = i). Let ' start (x; y 1 ; : : : ; y k ) be a quantifier-free formula stating that (x; y 1 ; : : : ; y k ) is the starting configuration. Similarly, we define a quantifier-free formula ' step (x; y 1 ; : : : ; y k ; x 0 ; y 0 1 ; : : : ; y 0 k ) stating that the configuration (x 0 ; y 0 1 ; : : : ; y 0 k ) is the successor configuration of (x; y 1 ; : : : ; y k ) (we agree that each accepting configuration is its own successor). Now, the equivalence M stops in k steps () A M j= ' k holds for the existential sentence ' k : 9x 1 9y 11 : : : 9y 1k : : : 9x k 9y k1 : : : 9y kk (' start (x; y 11 ; : : : ; y 1k ) ^Vk 1 i=1 ' step (x i ; y i1 ; : : : ; y ik ; x i+1 ; y i+11 ; : : : ; y i+1k ) ^ACCx k ): For t 1, we can proceed similarly, with the addition that universal quantifiers are needed to take care of universal states of the input machine. Now, also contains two further unary symbols F (for the existential states) and U (for the universal states) which get the corresponding interpretations in A M . For example, for t = 2, we can take a t -sentence7 equivalent to: _ l k 9x 1 9y 11 : : : 9y 1k : : : 9x k 9y l1 : : : 9y lk ' start (x; y 11 ; : : : ; y 1k ) ^Vl 1 i=1 ' step (x i ; y i1 ; : : : ; y ik ; x i+1 ; y i+1 1 ; : : : ; y i+1 k ) ^F x 1 ^: : : ^F x l 1 ^U x l ^8x l+1 8y l+1 1 : : : 8y l+1 k : : : 8x k 8y k1 : : : 8y kk U x l+1 ^: : : ^U x k 1 ^Vk 1 i=l ' step (x i ; y i1 ; : : : ; y ik ; x i+1 ; y i+1 1 ; : : : ; y i+1 k ) ! ACCx k ) : (Without loss of generality we assume that the accepting state is both existential and universal and that at least one transition is always possible in a universal state).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>The following result due to Downey, Fellows, and Regan allows to compare the W-and the A-hierarchy. Let t; u 1. A formula ' is t;u , if it is t and all quantifier blocks after the leading existential block have length u.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 33 ([11]</head><p>) For all t 1,</p><formula xml:id="formula_54">W[t] = [ vocabulary u 1 [MC( t;u [ ])] fp m = [ u 1 [MC( t;u )j GRAPH ] fp m :</formula><p>Note that for t = 1, this is just Theorem 30. The crucial step in proving the theorem for t 2 is to establish the W[t]-completeness of the problems WEIGHTED MONOTONE t-NORMALIZED SATISFIABILITY (for even t) and WEIGHTED ANTIMONOTONE t-NORMALIZED SATISFIABILITY (for odd t 3). We refer the reader to <ref type="bibr" target="#b9">[10]</ref> for the (difficult) proofs of these results. Once these basic completeness results are established, it is relatively easy to derive Theorem 33 (also cf. our proof of Theorem 36). We encourage the reader to give a purely "logical" proof of the second equality in the theorem.  Proof: The inclusion being trivial we turn to a proof of : Fix and u 1. We show that MC(</p><formula xml:id="formula_55">1;u = 1 , we get W[1] = [ vocabulary [MC( 1 [ ])] fp m = [MC( 1 )j GRAPH ] fp m = A[</formula><formula xml:id="formula_56">t;u [ ]) fp m MC( t;1 [ 0 ]</formula><p>) for suitable 0 . The idea is to replace the blocks of at most u quantifiers by a single quantifier ranging over the set of u-tuples of a structure. To explain this idea we first use a vocabulary containing function symbols (and sketch afterwards how one can do without). Let 0 := [ fT; p 1 ; : : : ; p u g, where T is a unary relation symbol (for ordered u-tuples) and p 1 ; : : : ; p u are unary function symbols (the projection functions). Given a -structure A let A 0 be a 0 -structure with</p><formula xml:id="formula_57">A 0 := A _ [A u ; T A 0 := A u ;</formula><p>where for (a 1 ; : : : ; a u ) 2 A u , p i (a 1 ; : : : ; a u ) = a i and where the relation symbols of are interpreted as in A. Now, e.g. for ' = 9x 1 : : : 9x k 8y 1 : : : 8y u ( x; y) with quantifier-free , let ' 0 = 9x 1 : : : 9x k 8y(:T x 1 ^: : : ^:T x k ^(T y ! ( x; p 1 (y) : : : p u (y))):</p><formula xml:id="formula_58">Then, A j= ' () A 0 j= ' 0 ;</formula><p>which gives the desired parameterized m-reduction. Let us explain, for the case t = 2, how to proceed to avoid function symbols. One has to add to , besides T as above, for every relation symbol R 2 , say r-ary, every subset M f1; : : : ; rg, and every function : M ! f1; : : : ; ug a new relation symbol R M; ; e.g., if M = fs; : : : ; rg then R A 0 M; a 1 : : : a s 1 b if, and only if, a 1 : : : a s 1 2 A, b = (b 1 ; : : : ; b u ) 2 A u , and R A a 1 : : : a s 1 b (s) : : : b (r) ; and a subformula Rx i1 : : : x is 1 y (s) : : : y (r) of ' is replaced by R M; x i1 : : : x is 1 y. 2 Downey, Fellows, and Regan <ref type="bibr" target="#b10">[11]</ref> also gave a (much simpler) characterization of the W-hierarchy in terms of Fagin-definability. We find it worthwhile to sketch a short proof of this result. For a class of formulas we let FD( ) be the class of all problems that are -Fagin-definable. Let t [s] denote the class of all t -formulas whose vocabulary is at most s-ary. </p><p>where the ' i1:::it are small formulas of depth at most d.</p><p>To prove that W[t] [FD( t <ref type="bibr" target="#b1">[2]</ref>)] fp m , we first transform a propositional formula ' of the form (6) into a propositional formula ' 0 of essentially the same form, but with all the ' i1:::it being disjunctions (if t is even) or conjunctions (if t is odd) of exactly d 0 literals, for some constant d 0 only depending on d. This can be done by first transforming the small formulas into equivalent formulas in conjunctive normal form or disjunctive normal form, respectively, and then repeatedly replacing disjunctions (conjunctions, respectively) with less than the maximum number of literals by the two clauses _ X and _ :X ( ^X and ^:X, respectively), for some variable X not appearing in .</p><p>We associate with ' 0 an fE; P; N; T; Lg-structure C which is obtained from the tree corresponding to ' 0 as follows: We first remove the root. Then we identify all leaves corresponding to the same propositional variable. To indicate whether a variable occurs positively or negatively in a clause, we use the binary relations P and N . The unary relation T contains all the top level nodes, and the unary relation L contains all the (former) leaves. It is easy to write a t -formula 0 (X) such that ' 0 has a satisfying assignment of weight k if, and only if, there exists a k-element subset B C such that C j= 0 (B).</p><p>This can best be illustrated with a simple example: Let The corresponding structure C is displayed in Figure <ref type="figure">1</ref>. To prove [FD( t )] fp m W[t], we just note that for every formula (X) 2 t and every structure A, there is a C t;d -formula ' with the property that every assignment for ' corresponds to a set B, whose size is the weight of the assignment, such that satisfies ' if, and only if A j= (B). Here d is a constant that just depends on . Furthermore, the transformation (A; ) 7 ! ' is computable in time polynomial in A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>We do not know of any simple proof of the equivalence between the two characterizations of the W-hierarchy in terms of slicewise t;u -definability (cf. Theorem 33) and t -Fagin definability. While the proof of the previous theorem shows that t -Fagin definability is actually quite close to the definition of W[t] in terms of the weighted satisfiability problem for C t -formulas, it seems that it is a significant step to get from there to slicewise t;u -definability.</p><p>Our last result is another characterization of the W-hierarchy in terms of Fagin definability that is much closer to the slicewise characterization. A first-order formula '(X) is bounded to the r-ary relation variable X, if in '(X) quantifiers appear only in the form 9x 1 : : : 9x r (Xx 1 : : : x r ^ ) or 8x 1 : : : 8x r (Xx 1 : : : x r ! ), which we abbreviate by 9 x 2 X and 8 x 2 X , respectively. For t 1 we let b t be the class of all formulas '(X) of the form 8 x 1 9 x 2 : : : Q x t where Q = 8 if t is odd and Q = 9 otherwise and where is bounded to X. where only contains bounded quantifiers. Let l be the maximum of the lengths of the tuples y i , for 1 i t. For simplicity, let us assume that X is unary. Since Xy is equivalent to 9z 2 X z = y, we can assume that in , the variable X only occurs in quantifier bounds. We show that P 2 W[t]. Given a parameter k set (with new variables</p><p>x 1 ; : : : ; x k )</p><p>' k := 9x 1 : : : 9x k 8 y 1 9 y 2 8 y 3 : : : Q y t (</p><formula xml:id="formula_60">1 i&lt;j k x i 6 = x j ^ );</formula><p>where is obtained from by inductively replacing 8u 2 X (u) and 9u 2 X (u) by V k i=1 (x i ) and W k i=1 (x i ), respectively. Note that ' k is a t;l -formula and that for every structure A, (A; k) 2 P () A j= ' k : Thus, P is slicewise t;l -definable and hence in W[t].</p><p>For the converse direction, we prove that for all t; u 1 the problem MC( t;u )j GRAPH is in FD( b t 1 ). The idea of this reduction is to associate with every graph G and t;u -formula 9x 1 : : : 9x k ' a structure C which essentially is a Boolean circuit whose satisfying assignments of size k correspond to assignments to the variables x 1 ; : : : ; x k such that G satisfies '. We can Fagin-define the weighted satisfiability problem for this circuit by a b t 1 -formula. We leave the details to the reader.</p><p>For readers familiar with <ref type="bibr" target="#b9">[10]</ref> (Theorem 12.6 on page 299 is the relevant result), we state another proof. For t = 1, the result follows from the fact the W[1]-complete problem CLIQUE is b 0 -Fagin definable. For odd t 2, the problem WEIGHTED ANTIMONOTONE t-NORMALIZED SATISFIABILITY is W[t]-complete. It is parameterized m-reducible to the problem Fagin-defined by the b t 1 -formula '(X) :=8y 0 8y 1 9y 2 8y 3 : : : 9y t 1 ((Ey 0 y 1 ^Ey 1 y 2 ^: : : ^Ey t 2 y t 1 ) ! 8x 2 X:Ey t 1 x):</p><p>For even t we use the completeness of WEIGHTED MONOTONE t-NORMALIZED SATISFIABILITY and argue similarly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Remark 37 Downey, Fellows and Taylor <ref type="bibr" target="#b11">[12]</ref> proved that the parameterized model-checking problem for full firstorder logic is complete for the class AW[ ], a parameterized complexity class above the W-hierarchy that is defined in terms of the satisfiability problem for quantified Boolean formulas.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 6 (</head><label>6</label><figDesc>Downey and Fellows [8, 9]) (1) CLIQUE is W[1]-complete under parameterized m-reductions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>) := ( ( ) n fE 1 ; : : : ; E s g) [ fE; P 1 ; : : : ; P s g; where P 1 ; : : : ; P s are new unary relation symbols.We transform B(A) to a ( )-structure C(A) as follows: For 1 i s and for all a; b 2 B(A) such that E B(A) i ab we introduce a new element c(i; a; b), add the pairs (a; c(i; a; b)), (c(i; a; b); a), (c(i; a; b); b), (b; c(i; a; b)) to E C(A) and add c(i; a; b) to P C(A) i . We define a sentence ' C by replacing each subformula of ' B of the form E i xy by 9z(Exz ^Ezy ^Pi z). Then we have the analogue of (2) and the subsequent remarks for C(A); ' C instead of B(A); ' B .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>For an l 1 , 4 for all B 2 S do 5 if A 6 j= W m i=1 i (B; a) then 6 S := S n fBg 7 for i = 1 to m do 8 compute 9 if</head><label>14256789</label><figDesc>we consider the restriction of DOMINATING SET to graphs of valence at most l, i.e. the problem CHECK-'(A 2 STR[ ], k 2 N) 1 compute A 2 initialize set S Pow(A) by S := f;g 3 for all a 2 A l do B 0 := (B; a; i) jB 0 j k and A j= i (B 0 ; a) 10 then S := S [ fB 0 g 11 if S 6 = ; Input: Graph G. Parameter: k 2 N. Question: Is the valence of G at most l and does G have a dominating set of size at most k?</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>HOM Input: A 2 Lemma 16</head><label>216</label><figDesc>STR. Parameter: B 2 STR. Question: Is there a homomorphism from B to A? A (weak) embedding of B into A is an injective homomorphism from B to A. Note that a graph H is isomorphic to a subgraph of a graph G in the usual graph theoretic sense, if there is an embedding of H into G. Thus the following parameterized EMBEDDING PROBLEM (EMB) is a generalization of the subgraph isomorphism problem SI: EMB Input: A 2 STR. Parameter: B 2 STR.Question: Is there an embedding of B into A?The Gaifman graph of a -structure A is the graph G(A) with universe A in which two elements a 6 = b are adjacent if there is an R 2 and a tuple a 2 R A such that both a and b occur in the tuple a. For a class C of graphs we let STR[C] denote the class of all structures whose Gaifman graph is in C. Note that STR[GRAPH ] = STR. Furthermore, we let STR[ ; C] := STR[ ] \ STR[C] for every vocabulary and STR[s; C] := STR[s] \ STR[C] for every s 1. We define restrictions HOM[: : : ] and EMB[: : : ] of the respective problems, where for every possible restriction ': : : ' in the square brackets we require the parameter B to belong to the class STR[: : : ]. For example, we let EMB[s; C] := EMB \ (STR STR[s; C]): For all classes C of graphs and s 1 we have HOM[C] fpp m EMB[C] and HOM[s; C] fpp m EMB[s; C]. Proof: Suppose we are given an instance (A; B) of HOM[C]. Let be the vocabulary of A. Let A B be the -structure which for every element of A contains jBj duplicates, i.e. A B := A B and, for every r-ary R 2 , R AB := ((a 1 ; b 1 ); : : : ; (a r ; b r )) R A a 1 : : : a r g: Then, every homomorphism h : B ! A gives rise to an embedding f : B ! A B defined by f (b) = (h(b); b) and every embedding f : B ! A B induces a homomorphism h : B ! A defined by letting h(b) be the projection on the first component of f (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>2</head><label></label><figDesc>Note that, unless PTIME = NP, there is no polynomial-time reduction from EMB[C] to HOM[C] for the class C of all paths, because HOM[C] can easily be seen to be in PTIME by a dynamic programming algorithm, whereas EMB[2; C] is NP-complete by a reduction from HAMILTONIAN PATH. Thus EMB[s; C] fpp m HOM[s; C] does not hold for any s 2. However, we will see that for all s 2 and C we actually have HOM[s; C] fp T EMB[s; C]. Before we show this, we introduce two related model-checking problems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>3</head><label></label><figDesc>Cf. Footnote 2 on Page 15.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(p. 174), LFP s -sentences are FO(LFP)-sentences in the form 9 y[S-LFP x1;X1;::: ; xm;Xm ' 1 ; : : : ; ' m ] y; where ' 1 ; : : : ; ' m are first-order formulas with at most s individual variables. (That is, LFP s -sentences are existential closures of simultaneous fixed-points over FO s -formulas.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Theorem 29): For the backward direction, suppose that P ORD[ ] N is slicewise LFP s -definable via : N ! LFP s . Then Algorithm 3 shows that P is in FPT. The crucial fact is that Lines 1 and 2 do not depend on the input structure A and Line 3 requires time O(n 2s ).For the forward direction, suppose that PORD[ ] N is in FPT. Choose f : N ! N, c2N and an algorithm A deciding P in time f (k) n c . The algorithm A gives rise to a sequence A k (k 1) of algorithms, where A k decides the class fA j (A; k) 2 P g ORD[ ] in time O(n c ). Then (2) yields the desired slicewise definition of P .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>2 8</head><label>8</label><figDesc>Beyond FPTIn this last section we discuss how logical definability is related to the classes of the W-hierarchy. We introduce another hierarchy of parameterized problems, which we call the A-hierarchy, in terms of model-checking problems NM Input: A non-deterministic Turing machine M . Parameter: k 2 N. Question: Does M accept the empty word in at most k steps? Downey and Fellows call Theorem 31 a parameterized "analog of Cook's Theorem". In our notation, we may write [NM] fp m = W[1]. It is now very natural to define a "parameterized analogue of the polynomial hierarchy", which we call the A-hierarchy, by letting A[t] := [AM t ] fp m for all t 1, where AM t Input: An alternating Turing machine M whose initial state is existential. Parameter: k 2 N.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Since</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>' 0 :</head><label>0</label><figDesc>= (X _ Y _ Z) ^(X _ :Y _ Z) ^(X _ :Y _ :Z) ^(:X _ Y _ :Z):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>^1 i&lt;j 3 y i 6 = y j ! 3 _ i=1 (</head><label>3i=1</label><figDesc>Figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>-formula 8x 2</head><label>2</label><figDesc>For example, CLIQUE is Fagin-defined by the b 0 X8y 2 X(x 6 = y ! Exy) and DOMINATING SET by the b 1 -formula 8x9y 2 X(x = y _ Exy):Theorem 36 For t 1, W[t] = [FD( b t 1 )] fp m .Proof: First, assume that the problem P STR[ ] N is Fagin-defined by '(X) 2 b t 1 , say '(X) := 8 y 1 9 y 2 8 y 3 : : : Q y t ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Literals are atomic or negated atomic formulas. A first-order formula ' is in negation normal form if negation symbols only occur directly in front of atomic subformulas. ' is existential (universal) if it is in negation normal form and contains no universal quantifiers (no existential quantifiers, respectively). ' is in prenex normal form if it is of the form Q 1 x 1 : : : Q k x k , where Q 1 ; : : : ; Q k 2 f9; 8g and is quantifier-free.EFO (AFO) denotes the class of all existential (universal, respectively) first-order formulas. For t 1, t denotes the class of all FO-formulas of the form 9x 11 : : : 9x 1k1 8x 21 : : : 8x 2k2 : : : Qx t1 : : : Qx tkt ;</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>X. Similarly, we can define parameterized versions of DOMINATING SET (DS) and CLIQUE. (A dominating set of a graph is a set X of vertices such that every vertex not contained in X is adjacent to a vertex in X. A clique is a set of pairwise adjacent vertices.)An example where the set of parameters is not N, but the class GRAPH of all finite graphs is the following parameterized SUBGRAPH ISOMORPHISM problem:Similarly, we can define parameterized versions of the INDUCED SUBGRAPH ISOMORPHISM problem and the GRAPH HOMOMORPHISM problem.</figDesc><table><row><cell>Definition 1 A parameterized problem P f : ! N, a constant c 2 N, and an algorithm that, given a pair (x; y) 2 is fixed-parameter tractable if there is a computable function , decides if (x; y) 2 P in time</cell></row></table><note><p><p><p>SI</p>Input: Graph G. Parameter: Graph H.</p>Question: Is H isomorphic to a subgraph of G?</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>s 1 .</head><label>1</label><figDesc>There is a polynomial time transformation that associates with every structure A 2 STR[s] a graph H 0 (A) and a linear time function that associates with every sentence ' 2 FO a sentence ' 0 GRAPH 2 FO, such that A j= ' () H 0 (A) j= ' 0 GRAPH : Furthermore, for all t 1, if ' 2 t then ' 0 GRAPH 2 t and if ' 2 t then ' 0 GRAPH 2 t . Let us first look back at the proof of the last lemma and note that if all relation symbols only occur positively in ' then the transformation ' 7 ! ' GRAPH only generates a new block of existential quantifiers. If all relation symbols only occur negatively then we only get a new block of universal quantifiers. Thus if ' 2 2t 1 (' 2 2t ) and all relation symbols only occur positively in ' then also ' GRAPH 2 2t 1 (' GRAPH 2 2t , respectively). Similarly, if ' 2 2t (' 2 2t 1 ) and all relation symbols only occur negatively in ' then also ' GRAPH 2 2t (' GRAPH 2 2t 1 , respectively).</figDesc><table /><note><p>Proof:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>STRbe a parameterized problem and a class of formulas. P is slicewise -definable if there is a computable function :! such that for all A 2 STR and y 2 we have (A; y) 2 P () A j= (y).For example, the parameterized subgraph isomorphism problem SI is slicewise 1 -definable via the function : GRAPH ! 1 defined as follows: For a graph H with vertex set H = fh 1 ; : : : ; h n g of cardinality n, (H) is the sentence On the other hand, if is a decidable set of formulas, then the problem MC( ) is slicewise -definable for trivial reasons. Definition 13 Let be a vocabulary, P STR[ ] N a parameterized problem, and a class of formulas. P is -Fagin-definable if there is a relation symbol X 6 2 (say, r-ary) and a sentence ' 2 [ [ fXg] such that for all A 2 STR[ ] and k 2 N we have (A; k) 2 P if and only if there is a B A r such that jBj = k and (A; B) j= '. (Here (A; B) denotes the [ fXg-expansion of A that interprets X by B.) Then ' Fagin-defines P .</figDesc><table><row><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell></row><row><cell>9x 1 : : : 9x n</cell><cell>i&lt;j n</cell><cell>x i 6 = x j</cell><cell>^1 i;j n</cell><cell>Ex i x j :</cell></row><row><cell></cell><cell></cell><cell></cell><cell>E H hihj</cell><cell></cell></row><row><cell cols="5">Slicewise -definability is closely related to the model-checking problem for : If P definable, then P fp m MC( ).</cell><cell>STR</cell><cell>is slicewise -</cell></row></table><note><p><p><p>, Downey, Fellows, and Regan consider two forms of definability: Their exposition motivates two general notions of definability, which we call slicewise definability and Fagin definability.</p>For a parameterized problem P and y 2 , we call P \ ( fyg) the yth slice of P .</p>Definition 12 Let P</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Lemma 17 implies that for every s 1 and for every class C of graphs we have HOM[s; C] fpp m MC( 1 [s; C]) and EMB[s; C] fpp m MC( 6 = 1 [s; C]). Unless PTIME = NP, the converse of these statements is wrong. To see this, let C be the class of all graphs that only consist of isolated vertices, i.e. all graphs G with E G = ;. Then clearly HOM[C] and EMB[C] are in PTIME, but we can reduce the satisfiability problem for propositional formulas to MC( 1 [1; C]) Let ' 2 1 [s; C], say, of vocabulary , and A a -structure. We shall describe an algorithm that decides whether A j= ' using HOM[s; C] as an oracle.</figDesc><table><row><cell>Furthermore, we let 1 [C] :=</cell><cell>S</cell><cell cols="3">s 1 1 [s; C] and 6 = 1 [C] :=</cell><cell>S</cell><cell>s 1</cell><cell>6 = 1 [s; C].</cell></row><row><cell>and MC( 6 = 1 [1; C]).</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Theorem 18 Let C be a class of graphs and s 2. Then</cell><cell></cell></row><row><cell cols="3">HOM[s; C]</cell><cell>fp T EMB[s; C]</cell><cell cols="3">fp T MC( 6 = 1 [s; C])</cell><cell>fp T MC( 1 [s; C]):</cell></row><row><cell cols="7">Proof: We have already seen that HOM[s; C] fp T EMB[s; C] (Lemma 16) and that EMB[s; C] fp T MC( 6 = 1 [s; C]) (Lemma 17). To complete the cycle we shall prove that MC( 6 = 1 [s; C]) fp T MC( 1 [s; C]) and that MC( 1 [s; C]) fp T HOM[s; C].</cell></row><row><cell cols="4">We first prove that MC( 1 [s; C]) fp T HOM[s; C].</cell><cell></cell><cell></cell></row></table><note><p>1 [s; C] := ' 2 1 [ ] s-ary vocabulary; G(') 2 C ; 6 = 1 [s; C] := ' 2 1 [ ] s-ary vocabulary; G(' 6 = ) 2 C :</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>The question whether W[t] = A[t] for all t remains open; in view of Theorem 32 this question is equivalent to W[t] = [MC( t )j GRAPH ] fp m for all t 1. In this form it is stated as an open problem in<ref type="bibr" target="#b10">[11]</ref>. Consider, for example, the following parameterized problem Are there a 1 ; : : : ; a k 2 G such that every clique of size l contains an a i ?Since P 0 is slicewise 2 -definable, we haveP 0 2 A[2]. But is P 0 in W[2]?In the definition of the W-hierarchy we can restrict the length of the non-leading quantifier-blocks to one:</figDesc><table><row><cell></cell><cell>1]:</cell></row><row><cell cols="2">By Theorem 32, W[t] Question: Proposition 34 For all t 1, A[t] for all t 2. P 0 Input: Graph G. Parameter: (k; l) 2 N 2 .</cell></row><row><cell>W[t] =</cell><cell>[</cell></row></table><note><p>vocabulary [MC( t;1 [ ])] fp m :</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Theorem 35 ([11])</head><label></label><figDesc>For all t 1 we have W[t] = [FD( t [2])] fp m = [FD( t )] fp m . Proof: Recall that W[t] = S d 1 [WSAT(C t;d )] fp m , where C t;d is the class of all propositional formulas of the form</figDesc><table><row><cell>î1</cell><cell>_</cell><cell>^= _</cell></row><row><cell></cell><cell>: : : (</cell><cell>)</cell></row><row><cell></cell><cell>i2</cell><cell></cell></row></table><note><p>it ' i1:::it</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This is what Downey and Fellows call strongly uniformly fixed-parameter tractable. For variants of this definition, and also of Definition</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>and the definition of the W-hierarchy, the reader should consult<ref type="bibr" target="#b9">[10]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>This is slightly imprecise, because a structure A 2 Ws might have a vocabulary of arbitrarily high arity, as long as no tuple contained in a relation of A consists of more than s + 1 distinct elements. But since any structure with this property can easily be transformed to an (s + 1)-ary structure that is essentially the same, we decided to accept this imprecision in exchange for a simpler notation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>NM stands for nondeterministic Turing machine. This notation should be seen in connection with the AMt below, which refers to alternating Turing machines.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 27 ([19]</head><p>) Let D be a class of graphs with an excluded minor. Then there exist : N ! N and 2 N such that every G 2 D has a tree-decomposition over B( ; ).</p><p>Furthermore, given G such a decomposition can be computed in PTIME.</p><p>Clearly, this theorem implies the analogous statement for all structures in STR <ref type="bibr">[D]</ref>.</p><p>The adhesion of a tree-decomposition (T ; (A t ) t2T ) is maxfjA s \ A t j j E T stg. The clique number of a class of structures is the maximum of the clique numbers of the Gaifman graphs of structures in D, if this maximum exists, or 1 otherwise. Note that if (T ; (A t ) t2T ) is a decomposition over a class D then the clique-number of D is an upper bound for the adhesion of (T ; (A t ) t2T ). Remembering that the clique-number of B( ; ) is (1) + + 1, we see that the adhesion of a tree-decomposition over B( ; ) is at most (1) + + 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (of Theorem 22):</head><p>Let D be a PTIME-decidable class of graphs with an excluded minor and ; such that every G 2 D has a tree-decomposition over B( ; ). Let := (1) + + 1.</p><p>We shall describe an algorithm that, given A 2 </p><p>there is a path from t to u in the (directed) tree T ). In particular, A r = A for the root r := r T of T .</p><p>Furthermore, we let B r := ; and B t := A t \ A s for t 2 T n frg with parent s. Recall that the adhesion of</p><p>) is at most . Thus jB t j for t 2 T . The quantifier rank of a first-order formula is the maximal depth of nested quantifiers in this formula. Let q be the quantifier rank of '. Simple techniques from logic show that there is an algorithm that, given a vocabulary and q; m 2 N, computes a finite set ;q;m of first-order formulas of vocabulary of quantifier rank q with free variables among v 1 ; : : : ; v m such that every such formula is equivalent to a formula in ;q;m . Without loss of generality we can assume that ' 2 ;q;m (otherwise we can compute a ' 0 2 ;q;m equivalent to ' and work with ' 0 ).</p><p>A ( ; q; m)-type is a subset of ;q;m . Given a -structure A 0 and B = fb 1 ; : : : ; b m g A 0 let tp A 0 q (B) -more precisely, tp A 0 q (b 1 ; : : : ; b m ) -be the ( ; q; m)-type tp A 0 q (B) := f (v 1 ; : : : ; v m ) 2 ;q;m j A 0 j= (b 1 ; : : : ; b m )g: We come back to our structure A and the tree-decomposition (T ; (A t ) t2T ). By induction from the leaves to the root, for every t 2 T we compute tp hA t i A q (B t ), which for brevity we denote by tp t q (B t ). Since B r = ;, tp r q (B r ) is a set of sentences, and we have A j= ' if, and only if, ' 2 tp r q (B r ). So let t be a vertex of T and assume that we have already computed tp u q (B u ) for all children u of t (if there are any). (Actually, the case that t has no children is much simpler than the following general case, because it is a direct application of <ref type="bibr">Lemma 26.)</ref> For every ( ; q; m)-type we introduce a new (m + 1)-ary relation symbol R . Furthermore, we let P 1 ; : : : ; P be new unary relation symbols and 0 := [ fR j m ; a ( ; q; m)-typeg [ fP 1 ; : : : ; P g. In four steps, we define a 0 -structure e A t that contains all the relevant information to compute tp t q (B t ). In the first three steps we define "intermediate" structures Standard Ehrenfeucht-Fraïssé type methods show that there is a computable function that associates with every formula 2 ;q;m a sentence e 2 FO[ 0 ] such that 2 tp t q (B t ) if, and only if, e A t j= e . We claim that e A t 2 B( + 1; ). To see this, observe that the Gaifman graph G( e A t ) is the graph obtained from the torso [A t ] by adding the vertices c u and edges between c u and every element of B u . Recall that, by the definition of the torso, each B u is a clique in [A t ]. It is easy to see that adding vertices and connecting them with cliques can increase the tree-width of a graph by at most one. This implies the claim.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now we can put everything together and obtain an algorithm deciding MC(FO) STR[D]</head><p>, a high-level description of which is given as Algorithm 2. Its correctness is straightforward. Let us just have a look at the running time: Let n be the size of the input structure. Then Lines 1 and 2 require time polynomial in n (indendently of '). The time required in Lines 3-5 only depends on '. The main loop in Lines 6-13 is called jT j times, which is polynomial in n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computing e</head><p>A t is polynomial in jA t j and the number of children of t since we have already computed tp u q (B u ) for all children u of t (with constants heavily depending on jj'jj). The main task is to decide whether e A t j= e in Line 12; by Lemma 26 this is fixed-parameter tractable because e A t 2 B( + 1; ). The time required in Lines 14-16 again only depends on '.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>A consequence of our results is that slicewise first-order definable parameterized problems are fixed-parameter tractable when restricted to classes of structures whose underlying class of graphs has an excluded minor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 28</head><p>Let D be a PTIME-decidable class of graphs with an excluded minor and P STR a parameterized problem that is slicewise FO-definable. Then P j STR <ref type="bibr">[D]</ref> is in FPT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">A logical characterization of fixed-parameter tractability</head><p>In this section we give a characterization of FPT in the spirit of descriptive complexity theory.</p><p>We briefly review some facts from this area (see <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b21">22]</ref> for details). It is common in descriptive complexity theory to identify decision problems, usually modeled by languages L for a finite alphabet , with classes of finite structures. More precisely, one identifies problems with classes of ordered finite structures. An ordered structure is a structure whose vocabulary contains the binary relation symbol , and this symbol is interpreted as a linear order DECIDE-P(A 2 ORD, k 2 N) for first-order logic and show that the A-hierarchy can be seen as a parametric analogue of the polynomial hierarchy. We then discuss the relation between the A-hierarchy and the W-hierarchy.</p><p>Our treatment is motivated by the following two results. They relate the class W <ref type="bibr" target="#b0">[1]</ref> to model-checking and computations of non-deterministic Turing machines, respectively. Recall that MC( 1 [s]) denotes the parameterized modelchecking problem for existential formulas in prenex normal form whose vocabulary contains at most s-ary relation symbols.</p><p>Theorem 30 (Downey, Fellows, Regan <ref type="bibr" target="#b10">[11]</ref>) MC( 1 )j GRAPH is W[1]-complete under parameterized m-reductions.</p><p>Proof: We prove that CLIQUE fp m MC( 1 )j GRAPH . CLIQUE fp m MC( 1 )j GRAPH follows from the fact that CLIQUE is slicewise 1 -definable, so we only have to prove the converse.</p><p>An atomic k-type (in the theory of graphs) is a sentence (x 1 ; : : : ; x k ) of the form V 1 i&lt;j k ij (x i ; x j ), where ij (x i ; x j ) is either x i = x j or Ex i x j or (:Ex i x j ^:x i = x j ) (for 1 i &lt; j k).</p><p>It is easy to see that there is a computable mapping f that associates with every EFO-sentence ' a sentence ' of the form l _ i=1 9x 1 : : : 9x k i (x 1 ; : : : ; x k );</p><p>where each i is an atomic k-type, such that for all graphs G we have G j= ' () G j= '.</p><p>For each graph G and each atomic k-type ( x) = V 1 i&lt;j k ij (x i ; x j ) we define a graph h(G; ) as follows: The universe of h(G; ) is f1; : : : ; kg G.</p><p>There is an edge between (i; v) and (j; w), for 1 i &lt; j k and v; w 2 G, if G j= ij (v; w). Then h(G; ) contains a k-clique if, and only if, G j= 9 x ( x). Now we are ready to define the reduction from MC( 1 )j GRAPH to CLIQUE. Given an instance (G; ') of MC( 1 )j GRAPH , we first compute the sentence ' = l _ i=1 9x 1 : : : 9x k i :</p><p>We let G 0 be the disjoint union of the graphs h(G; i ) for 1 i l. Then G 0 has a k-clique if, and only if, G j= '. 2</p><p>Theorem 31 (Cai, Chen, Downey, and Fellows <ref type="bibr" target="#b3">[4]</ref>) The parameterized problem SHORT TURING MACHINE AC-CEPTANCE (NM) 4 is W[1]-complete, where</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Color-coding</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Yuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Zwick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="844" to="856" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On fixed-parameter tractability and approximability of NP optimization problems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="465" to="474" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the parameterized complexity of short computation and factorization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Archive for Mathematical Logic</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="321" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Optimal implementation of conjunctive queries in relational data bases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Merlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM Symposium on Theory of Computing</title>
		<meeting>the 9th ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="77" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Conjunctive query containment revisited</title>
		<author>
			<persName><surname>Ch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chekuri</surname></persName>
		</author>
		<author>
			<persName><surname>Rajaraman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Database Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><surname>Ph</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Kolaitis</surname></persName>
		</editor>
		<editor>
			<persName><surname>Afrati</surname></persName>
		</editor>
		<meeting>the 5th International Conference on Database Theory</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1186</biblScope>
			<biblScope unit="page" from="56" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Graph rewriting: An algebraic and logic approach</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="194" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fixed-parameter tractability and completeness I: Basic results</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="873" to="921" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fixed-parameter tractability and completeness II: On completeness for W [1]</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">141</biblScope>
			<biblScope unit="page" from="109" to="131" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<title level="m">Parameterized Complexity</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Descriptive complexity and the W -hierarchy</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Regan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proof Complexity and Feasible Arithmetic</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Beame</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Buss</surname></persName>
		</editor>
		<imprint>
			<publisher>AMS</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="119" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The parameterized complexity of relational database queries and an improved characterization of W [1]</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorics, Complexity, and Logic -Proceedings of DMTCS &apos;96</title>
		<meeting><address><addrLine>In Bridges, Calude, Gibbons, Reeves, and Witten</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="194" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">H.-D</forename><surname>Ebbinghaus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Flum</surname></persName>
		</author>
		<title level="m">Finite Model Theory</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Generalized first-order spectra and polynomial-time recognizable sets</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Complexity of Computation</title>
		<title level="s">SIAM-AMS Proceedings</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="43" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">An improved fixed-parameter-tractable algorithm for vertex cover</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Stege</surname></persName>
		</author>
		<idno>318</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, ETH Zurich</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Query evaluation via tree-decompositions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Flum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Frick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Database Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Den Bussche</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</editor>
		<meeting>the 8th International Conference on Database Theory</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1973</biblScope>
			<biblScope unit="page" from="22" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Deciding first-order properties of locally tree-decomposable graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Frick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Colloquium on Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Wiedermann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Van Emde</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Boas</surname></persName>
		</editor>
		<editor>
			<persName><surname>Nielsen</surname></persName>
		</editor>
		<meeting>the 26th International Colloquium on Automata, Languages and Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1644</biblScope>
			<biblScope unit="page" from="331" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Hypertree decompositions and tractable queries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Scarcello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Symposium on Principles of Database Systems</title>
		<meeting>the 18th ACM Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="21" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Local tree-width, excluded minors, and approximation algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>To appear in Combinatorica</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">When is the evaluation of conjunctive queries tractable</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schwentick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM Symposium on Theory of Computing</title>
		<meeting>the 33rd ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Relational queries computable in polynomial time</title>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="86" to="104" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Descriptive Complexity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the expressive power of variable-confined logics</title>
		<author>
			<persName><forename type="middle">G</forename><surname>Ph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th IEEE Symposium on Logic in Computer Science</title>
		<meeting>the 11th IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Approximation properties of NP minimization classes</title>
		<author>
			<persName><forename type="middle">G</forename><surname>Ph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><surname>Thakur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="391" to="411" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Conjunctive-query containment and constraint satisfaction</title>
		<author>
			<persName><forename type="middle">G</forename><surname>Ph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM Symposium on Principles of Database Systems</title>
		<meeting>the 17th ACM Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="205" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the complexity of database queries</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM Symposium on Principles of Database Systems</title>
		<meeting>the 17th ACM Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="12" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Graph-Theoretic Concepts in Computer Science, WG &apos;90</title>
		<author>
			<persName><forename type="first">J</forename><surname>Plehn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Voigt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Möhring</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">484</biblScope>
			<biblScope unit="page" from="18" to="29" />
			<date type="published" when="1990">1990</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Finding minimally weighted subgraphs</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Graph minors XIII. The disjoint paths problem</title>
		<author>
			<persName><forename type="first">N</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Seymour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Combinatorial Theory, Series B</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="65" to="110" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Linear time computable problems and first-order descriptions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Seese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="505" to="526" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The complexity of relational query languages</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Symposium on Theory of Computing</title>
		<meeting>the 14th ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the complexity of bounded-variable queries</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Symposium on Principles of Database Systems</title>
		<meeting>the 14th ACM Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="266" to="276" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
