<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Cycle Time Prediction: When Will This Case Finally Be Finished?</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Van Dongen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science Technische</orgName>
								<orgName type="institution">Universiteit Eindhoven</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Crooy</surname></persName>
							<email>r.a.crooy@student.tue.nl</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science Technische</orgName>
								<orgName type="institution">Universiteit Eindhoven</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science Technische</orgName>
								<orgName type="institution">Universiteit Eindhoven</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Cycle Time Prediction: When Will This Case Finally Be Finished?</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">66EC9FB1481D1A94EE0B759C4B5CDA53</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A typical question for people dealing with administrative processes is: "When will my case be finished?". In this paper, we show how this question can be answered, using historic information in the form of event logs of the systems supporting these administrative processes. Many information systems record information about activities performed for past cases in logs. Hence, to provide insights into the remaining cycle time of a case, the current case can be compared to all past ones.</p><p>The most trivial way of estimating the remaining cycle time of a case is by looking at the average cycle time and deducting the already past time of the case under consideration. However, in this paper we show how to compute the remaining cycle time using non-parametric regression on the data recorded in event logs. An experiment is presented that demonstrates that our techniques perform well on logs taken from practice.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>An often heard complaint about administrative processes is that no insights are given in the time needed to handle a case. A customer filing a claim with an insurance company will probably hear in the beginning that the claim will be handled in approximately 4 to 6 weeks. When s/he calls to ask about the status after a couple of weeks, the answer is usually still that the handling will take 4 to 6 weeks in total, i.e. the average cycle time is 5 weeks.</p><p>The estimate given to the customer over the phone is not just an arbitrary number. Instead, this is usually the average cycle time of a case, combined with a certain margin of error. Obviously, at the time when a new claim (or case in a more general setting) is entered into the system of the insurance company, the best estimate of the remaining cycle time is indeed the average cycle time. However, as soon as the case has been entered into the system, it is annotated with all kinds of information that might influence the remaining cycle time. For example, claims filed by customers filing claims more often, are more likely to be checked for fraud, whereas claims that do not exceed a certain amount are never checked for fraud. Since such a check costs time, knowing whether it will or will not be performed obviously has an influence on the cycle time.</p><p>As a case progresses in the process, i.e. as more and more activities are performed, the amount of information relating to the remaining cycle time of the case is increasing. If, for example, fraud is expected, a case might be deferred to a different part of the organization, which significantly delays the handling. Such delays heavily influence the cycle time of a single case, but they also influence the average cycle time of all cases. Therefore, especially for cases in the middle of their handling, the quality of the average cycle time as an estimator is poor.</p><p>Rules such as the one stating that claims under a certain amount are never checked for fraud, are not likely to be made public. People working with a system handling a case generally do not have to know that such rules exist. Hence these people may not be able to give a better estimate of the remaining cycle time than the average cycle time.</p><p>Fortunately, information systems used in the handling of large administrative processes, store all kinds of information related to current and past cases in event logs. These event logs are typically annotated with information relevant to the remaining cycle time of a case.</p><p>In this paper, we focus on the issue of remaining cycle time. We consider event logs as a basis on which we predict, what the remaining cycle time of a specific partial case is, e.g. we accurately answer the question of the customer about the time needed to handle his/her claim. We use non-parametric regression <ref type="bibr" target="#b5">[6]</ref> as opposed to other methods for prediction, mainly because non-parametric regression is most suitable in situations with little or no precedents are available.</p><p>The paper is organized as follows. First, in Section 2, we introduce some notations and we formally define the regression techniques used. In Section 3, we present five different predictors for the remaining cycle time and in Section 4 we present a case study where these predictors were put to the test on a real-life dataset. We conclude the paper with a section on the implementation (Section 5) and some conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>In this section, we introduce some basic concepts needed for prediction. We introduce logs, as well as the ideas behind non-parametric regression.</p><p>Let S be a set. The powerset of S is denoted by</p><formula xml:id="formula_0">P(S) = {S |S ⊆ S}. A bag (multiset) m over S is a function S → IN, where IN = {0, 1, 2, . . .} denotes the set of natural numbers.</formula><p>The set of all bags over S is denoted by IN S . We identify a bag with all elements occurring only once with the set containing these elements, and vice versa. We use + andfor the sum and difference of two bags, and =, &lt;, &gt;, ≤, ≥ for the comparison of two bags, which are defined in a standard way. We use ∅ for the empty bag, and ∈ for the element inclusion. We write e.g. m = [p 2 , q] for a bag m with m(p) = 2, m(q) = 1 and m(x) = 0, for all x ∈ {p, q}. We use the standard notation |m| and |S| to denote the number of elements in bags and sets.</p><p>A sequence over S of length n is a function σ : {0, . . . , n -1} → S. If σ(0) = a 0 , . . . , σ(n -1) = a n-1 , we write σ = a 0 , . . . , a n-1 , and σ i for σ(i). The length of a sequence is denoted by |σ|. The sequence of length 0 is called the empty sequence, and is denoted by . The set of finite sequences over S is denoted by S * . Let υ, τ ∈ S * be two sequences. Concatenation, denoted by σ = υ • τ is defined as σ : {0, . . . , |υ|</p><formula xml:id="formula_1">+ |τ | -1} → S, such that for 0 ≤ i &lt; |υ|, σ(i) = υ(i), and for |υ| ≤ i &lt; |σ|, σ(i) = τ (i -|υ|).</formula><p>Furthermore, we define the prefix from index i to j on sequences by τ =↓ i,j (τ ), such that if i ≥ j, then τ = , otherwise τ = τ i , . . . , τ j-1 , i.e. for all sequences τ holds that ↓ 0,|τ | (τ ) = τ .</p><p>We use P(x) to denote column vectors and for a sequence σ ∈ S * , the Parikh vector σ : S → IN defines the number of occurrences of each element of S in the sequence, i.e. σ(s) = |{i|0 ≤ i &lt; |σ| ∧ σ(i) = s}|, for all s ∈ S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Logs</head><p>Information systems typically log all kinds of events. Unfortunately, most systems use their own specific format. Therefore, we formalize the concept of a log. The basic assumption is that the log contains information about activities executed for specific cases, as well as their durations. Extensive practical experiences in the context of the process mining framework ProM <ref type="bibr" target="#b0">[1]</ref> show that this assumption is valid in many applications <ref type="bibr" target="#b1">[2]</ref>. Note that τ s , τ c , and δ are not functions, as similar sequences might have different times attached to them. However, they are total, i.e. they do provide start, completion times and durations for all sequences.</p><p>Finally, if W ⊆ A * is a log, then we assume that all σ ∈ W and 0 ≤ i ≤ |σ| holds that τ s|c (↓ 0,i (σ)) ≤ τ s|c (σ), i.e. the activities within each case are ordered in time.</p><p>Besides the minimal information of activity/duration pairs, logs often carry caserelated information, such as the amount of money involved in a claim, or the data entered in an application form. As the nature of this information is not known up front, we leave that abstract for now and we define the case data as a map of key/value pairs. Definition 2.3. (Sequence data) Let A be a set of activities, σ ∈ A * a sequence over A, K a set of attribute keys and V a set of attribute values. We denote sequence data by Δ(σ) : K → V , as a function from the keys in K to their corresponding value in V . The exact nature of these domains is left abstract for now. Again, Δ is not a function, but it is total.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Regression</head><p>Regression is a technique to fit a function to a set of measurements, i.e. to abstract from these measurements. Basically, there are two types of regression, namely parametric, where the function is assumed to be of a certain form (e.g. linear, exponential, quadratic, etc.) and non-parametric, where no assumptions are made about the function that should fit the measurements <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>In this paper we use non-parametric regression because, in order to predict cycle times in any unspecified business process, we cannot assume the cycle time to have a specific form or distribution, which is needed for parametric regression. The non-parametric approach only assumes there is some relationship between the predictor variables and the target variable, the form of this relationship need not be specified. A method called smoothing or "local averaging" is used in nonparametric regression to make estimations based the observed data, without a parameterized model.</p><p>At the basis of non-parametric regression lies a list of measurements m = m 0 , m 1 , . . . , m n , such that each measurement m i = ( x i , y i ) ∈ (X ×IR) consists of a vector of k so-called predictor variables x i ∈ X and a target variable (y i ∈ IR). The domain X = X 0 × X 1 × . . . × X k-1 are kept abstract for now.</p><p>The goal of regression is that, based on the measurements stored in m, the value of any new vector of predictor variables x is estimated by a function γ : X → IR. This function is such that it estimates the corresponding target value y , i.e. y ≈ γ( x ). The estimate is such that the values of the target variables of measurements in m closest to the new vector x have more influence than those measurements farther from x , i.e. γ( x ) is interpolated from measurements in the larger vicinity of x .</p><p>The way the function γ computes the estimated target value is by taking the weighted average of the target values of the measurements, where the weight of the k components of the vector x i is determined by a parameterized so-called kernel function φ : (X × X × IR k ) → IR + , assigning an inverted weight to each of the k components representing the distance between x and x i . The relative importance of each component of the vectors x and x i is denoted by the bandwidth variable λ ∈ IR k . As a result, the function γ, denoted by γ λ to show the dependency on the bandwidth, looks as follows:</p><formula xml:id="formula_2">γ λ ( x ) = n i=0 φ( x i , x , λ). y i n i=0 φ( x i , x , λ) , for m = ( x 0 , y 0 ), ( x 1 , y 1 ), . . . , ( x n , y n )<label>(1)</label></formula><p>In Section 3, we elaborate on how to select the right kernel function φ, taking into account the (so-far abstract) domains of each of the predictor variables. However, the process of finding the optimal values for the bandwidth variables, is similar for any particular kernel function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Bandwidth Variable Optimization</head><p>In order to find the optimum bandwidth, we first define what optimality is. The goal of regression is to estimate y = γ λ ( x )+ such that (the error) is minimal.</p><p>As this error depends on the bandwidth variables, the value of each component of the bandwidth variable λ is computed by minimizing n -1 n i=0 (γ λ ( x i )y i ) 2 using only the measurements m. To minimize bias standard cross-validation techniques are used <ref type="bibr" target="#b5">[6]</ref>.</p><p>In this paper we do not elaborate further on how to find the optimal bandwidth. Instead, we refer to <ref type="bibr" target="#b5">[6]</ref> for various techniques to find an the optimum bandwidth efficiently and to <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref> for details about the implementation used in our case-study.</p><p>So far, we imposed the restriction that the target variable has a continuous domain. In the remainder of this paper, we use the remaining cycle time of a case as the target variable, which indeed has a continuous domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Cycle Time Prediction</head><p>Before presenting the results of our case study in Section 4, we first introduce several methods for estimating the remaining cycle time. First, we show a naive approach using only the average cycle time over a log. Then, we show three types of regression-based techniques, using the occurrences of activities, the durations of activities and the case data to base the prediction on. We conclude this section by showing how to combine the different regression-based techniques. The regression kernel functions presented in this section were inspired by <ref type="bibr" target="#b8">[9]</ref>, which proposes a method for non-parametric regression with both continuous and (un)ordered categorical variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Average Cycle Time Estimator</head><p>As mentioned in the introduction, the average cycle time is often used as an estimator for the remaining cycle time. Using the start and completion of a sequence, it is trivial to define the average cycle time of a log, which is just the sum of the durations of all cases divided by the number of cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.1. (Average Cycle Time) Let W be a log. The average cycle time</head><formula xml:id="formula_3">A W of W is defined as A W = σ∈W δ(σ) |W |</formula><p>, where |W | denotes the number of cases in W .</p><p>The remaining duration of a partial case under consideration is deducted from the average cycle time of a log to predict the remaining cycle time of the case. Since the result might be negative, the estimate is rounded to 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.2. (Average Cycle Time Predictor)</head><p>Let A be a set of activities and W be a log over A. Let A W be the average cycle time over W . Let σ ∈ A * be a partial case (i.e. a case that has not been completed yet). The average cycle time predictor of this partial case is defined as ρ AV G (σ ) = max(0, A Wδ(σ )).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Activity Occurrence Estimator</head><p>The first regression-based estimator we present in this paper considers only the frequencies of activities within each case. As we have shown in Section 2.2, regression is based on measurements, which we have to define for logs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.3. (Activity Occurrence Measurement)</head><p>Let A be a set of activities, let W be a log over A and let σ ∈ W be a case. We define the list of case measurements as M AO σ = m 1 , . . . , m |σ| , where for all 0 &lt; i ≤ |σ| holds that m i = ( P(↓ 0,i (σ)), τ c (σ)τ c ↓ 0,i (σ)).</p><p>We define the list of activity occurrence measurements M AO W over W as the concatenation of the case measurements.</p><p>In words, the list of activity occurrence measurements is such that for each (nonempty) prefix of a case, one measurement is taken, consisting of the number of occurrences of the elements of A in that prefix (the predictor variables P(σ)) and the remaining cycle time of that prefix (the target variable τ c (σ)τ c ↓ 0,i (σ)), which is defined as the difference between the latest time in the prefix and the latest time in the entire case. Note that, since the activities within each case are ordered in time, the remaining cycle time is a continuous variable greater or equal to 0, i.e.</p><formula xml:id="formula_4">τ c (σ) -τ c ↓ 0,i (σ) ∈ IR + .</formula><p>For a log W , the total number of measurements equals the sum of the lengths of all cases in the log.</p><p>So far, the domains of the measurement variables (denoted by X i in Section 2.2) were kept abstract. For the activity occurrence measurement defined in Definition 3.3, we can make these domains concrete, since each variable represents the number of times an activity occurred, we know that all domains equal IN, which implies that we can define a concrete kernel function for these variables.</p><p>For this purpose, we use a variation of the Aitchison and Aitken's <ref type="bibr" target="#b2">[3]</ref> kernel which was defined by Jeff Racine and Qi Li <ref type="bibr" target="#b8">[9]</ref>. This function is parameterized by the bandwidth parameters λ ∈ [0..1] ⊂ IR + . If a bandwidth parameter is 0 for a certain activity, then this activity has maximum influence on the remaining cycle time, whereas a value of 1 implies minimal influence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.4. (Activity Occurrence Kernel Function)</head><p>Let A be a set of activities. We define the activity occurrence kernel function</p><formula xml:id="formula_5">φ AO : IN |A| × A * × [0..1] |A| → [0..1], such that φ AO ( x, σ, λ AO ) = a∈A ( λ AO (a)) | x(a)-P(σ)(a)| with 0 0 := 1 (2)</formula><p>Using the activity occurrence kernel function, we now complete our activity occurrence predictor by substituting it in Equation 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.5. (Activity Occurrence Predictor)</head><p>Let A be a set of activities, let W be a log over A and let M AO W be the activity occurrence measurements over W . Furthermore, let σ ∈ A * be a partial case. The expected remaining cycle time, given the bandwidth parameters λ AO , of this case is estimated by ρ AO : A * → IR, as:</p><formula xml:id="formula_6">ρ AO (σ) = ( x,y)∈M AO W φ AO ( x, σ, λ AO ). y ( x,y)∈M AO W φ AO ( x, σ, λ AO )<label>(3)</label></formula><p>With Definition 3.5, we have defined a prediction function that estimates the remaining cycle time of any given sequence, based on the occurrences of activities recorded in cases in the log. The quality of this prediction function depends on the bandwidth variable λ, which is determined using the procedure described in Section 2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Activity Duration Estimator</head><p>The second regression-based estimator we present in this paper considers the duration of each of the activities within cases. As we have shown in Section 2.2, regression is based on measurements, which we therefore define for our logs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.6. (Activity Duration Measurement)</head><p>Let A be a set of activities, let W be a log over A and let σ ∈ W be a case. We define the list of case measurements as M AD σ = m 1 , . . . , m |σ| , where for all 0 &lt; i ≤ |σ| holds that m i = ( x i , τ c (σ)τ c (↓ 0,i (σ))), with x i a vector such that for all a ∈ A holds that</p><formula xml:id="formula_7">x i (a) = 0&lt;j&lt;i σj-1=a δ(↓ j-1,j (σ)) P(↓ 0,i (σ))(a) with 0 0 := 0. (<label>4</label></formula><formula xml:id="formula_8">)</formula><p>We define the list of activity duration measurements M AD W over W as the concatenation of the case measurements. Definition 3.6 defines the activity duration measurements, such that for each (non-empty) prefix of a case, the measurement consists of (i) the average duration of each activity a ∈ A within this case (the sum of the durations of each occurrence of a divided by the number of occurrences) and (ii) the remaining cycle time of this case (the target variable).</p><p>In contrast to the activity occurrence measurements presented in Section 3.2, the domains of the measurement variables (denoted by X i in Section 2.2) are not the natural numbers, but real numbers, i.e. each measurement is a vector of semi-positive real numbers, which implies that we can define a concrete kernel function for these variables.</p><p>For this purpose, we use a Gaussian kernel function <ref type="bibr" target="#b5">[6]</ref>, which is parameterized by the bandwidth parameters λ ∈ IR + for all activities <ref type="foot" target="#foot_1">1</ref> . A value close to 0 of the bandwidth parameter means that the influence of this parameter to the remaining cycle time is maximal. A value of ∞ represents the case where the duration of an activity has no influence on the remaining cycle time.</p><p>We choose to use the Gaussian kernel, as it is the only kernel with infinite support, other kernels will assign a weight of 0 to cases if their difference is greater than a certain number, the Gaussian however will assign a calculated weight to all cases although it might go to 0. In this way a prediction for a partial case that has few to no precedents will be based on larger set. Definition 3.7. (Activity Duration Kernel Function) Let A be a set of activities. We define the activity duration kernel function φ AD :</p><formula xml:id="formula_9">IR |A| × A * × IR |A| → IR + , such that φ AD ( x, σ, λ AD ) = a∈A κ x(a)-P(σ)(a) λ AD (a) λ AD (a)</formula><p>, where</p><formula xml:id="formula_10">κ(u) = e -u 2 /2 √ 2π<label>(5)</label></formula><p>Using the activity duration kernel function, we now complete our activity duration predictor by substituting it in Equation <ref type="formula" target="#formula_2">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.8. (Activity Duration Predictor)</head><p>Let A be a set of activities, let W be a log over A and let M AD W be the activity duration measurements over W . Furthermore, let σ ∈ A * be a partial case. The expected remaining cycle time, given the bandwidth parameters λ AD , of this case is estimated by ρ AD : A * → IR, as:</p><formula xml:id="formula_11">ρ AD (σ) = ( x,y)∈M AD W φ AD ( x, σ, λ AD ). y ( x,y)∈M AD W φ AD ( x, σ, λ AD ) (6)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Case Attribute Estimator</head><p>The activity occurrence estimator of Section 3.2 considers the activity occurrences as measurements, which are variables from an ordered, ordinal domain (IN). The duration estimator however uses activity durations as measurements which are positive continuous variables (IR + ). In this subsection, we present the third type of variables, namely unordered ordinal variables.</p><p>Recall that Definition 2.3 presented a way to define arbitrary data attributes on each case in a log. As we do not assume any knowledge about this data in the log, we can only consider these data attributes to be unordered ordinal variables. However, they might still be of influence for the prediction of the remaining cycle time. Definition 3.9. (Case Data Measurement) Let A be a set of activities, let W be a log over A, let K be a set of attribute keys and let σ ∈ W be a case. We define the list of case data measurements as M CD σ = m 1 , . . . , m |σ| , where for all 0 &lt; i ≤ |σ| holds that m i = ( x i , τ c (σ)τ c (σ p )), with x i a vector, such that for all k ∈ K holds that</p><formula xml:id="formula_12">x i (k) = Δ(↓ 0,i (σ))(k).</formula><p>We define the list of activity occurrence measurements M CD W over W as the concatenation of the case measurements.</p><p>In other words, for each non-empty prefix of a case, a measurement is taken consisting of a vector representing the value of each attribute key for that prefix. Note that this allows for case data to change during execution, i.e. attributed might change value after certain activities have been performed.</p><p>If unordered ordinal variables are used for measuring, not much can be said about the distance between two measurements. In fact, only when two variables take the same value, they can be assumed to be close. Therefore, the kernel function is a modified version of Definition 3.4. Definition 3.10. (Case Data Kernel Function) Let A be a set of activities, K a set of attribute keys and V the set of attribute values. We define the case data kernel function φ CD :</p><formula xml:id="formula_13">V |K| × A * × [0..1] |K| → [0..1], such that φ CD ( x, σ, λ CD ) = k∈K 1, if x(k) = Δ(σ)(k) λ(k), if x(k) = Δ(σ)(k) (7)</formula><p>When comparing Definition 3.10 to Definition 3.4, it becomes clear that the only difference is in the "distance" of two variables, i.e. when assuming that for all unordered nominal variables (case data) the distance between different values equals 1 (i.e. | x(a)x p (b)| := 1), then these definitions are the same. Finally, for case data, we define the predictor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.11. (Case Data Predictor)</head><p>Let A be a set of activities, let W be a log over A, let K be a set of attribute keys, V the set of attribute values and let M CD W be the case data measurements over W . Furthermore, let σ ∈ A * be a partial case. The expected remaining cycle time, given the bandwidth parameters λ CD , of this case is estimated by ρ CD : A * → IR, as:</p><formula xml:id="formula_14">ρ CD (σ) = ( x,y)∈M CD W φ CD ( x, σ, λ CD ). y ( x,y)∈M CD W φ CD ( x, σ, λ CD )<label>(8)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Combining Regression Estimators</head><p>In the previous subsection, we have presented three regression-based estimators. The first estimator is based on the occurrences of activities within cases, which is an ordered ordinal variable. The second is based on activity durations, a continuous variable and the last on case data, which we considered to be unordered ordinal variables. All three estimators had the same structure, i.e. they consisted of a set of measurements, a kernel function and a predictor. In this subsection we show how to do regression on a mix of different variable types. In definitions 3.3, 3.6 and 3.9, we presented the measurements for the different types of variables. These measurements consisted of two parts, namely the measurement variables and the target variable. This target variable is defined the same for all measurements. Furthermore, all lists of measurements have the same size, i.e. one measurement is taken per non-empty prefix of a case in the log. This allows us to easily combine these measurements into one vector containing the activity occurrences, the activity duration and the case data for each prefix.</p><p>For the combined measurements, the kernel function used in the regression is simply the product of all individual kernel functions, applies to the relevant measurement variables, i.e., the kernel function of Definition 3.4 is multiplied with the kernel functions of definitions 3.7 and 3.10, where each of these functions is applied to the relevant part of the vector of measurement variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Case Study</head><p>We tested our prediction approach on a dataset taken from real-life. In this section, we present and discuss the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Case Description</head><p>For the verification of our approach, we used a dataset called "bezwaar WOZ" from a Dutch municipality <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b10">11]</ref>. The process described in the log is the process of handling objections filed against real estate taxes.</p><p>From the log that originally contains 1982 cases, we only kept those cases that were fully contained in the measurement period, i.e. both their first and last activity were performed in the measurement period. Furthermore, after consulting the process owner, we removed those activities not relating to the main procedure. This resulted in a log containing 706 cases, which were handled by the municipality between February 28 th 2005 and November 8 th 2005 (a period of 252 days). In total, 9218 events were recorded, relating to the start and completion of 12 activities. Note that the start events were only used to obtain the durations of each activity. The complete events were used in the measurements. Furthermore, all cases and all events were annotated with data attributes, which we all used in the analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Experiment Setup</head><p>We conducted experiments using five different estimators. The experiments were set up as 10-fold cross validation experiments, meaning that each time, the original log was split into 10 partitions. Then, 9 partitions were used as measurements and using these measurements, the optimal values of the bandwidth parameters were computed. For all cases in the remaining partition, estimates of the remaining cycle time were computed using the optimal bandwidth parameters. These estimates were computed after the occurrence of each activity, except the last. <ref type="foot" target="#foot_2">2</ref> By repeating this procedure 10 times, the remaining cycle time is estimated, exactly once after completing each activity in the log (except for the last activity in each case).</p><p>The five estimators we used were:</p><p>1. The naive approach of Section 3.1, i.e. the average cycle time over the 9 measurement parts minus the already passed time maximized with 0, 2. The estimator of Section 3.2, where only activity occurrences were taken into account as measurements for the non-parametric regression, 3. The estimator of Section 3.3, where only activity durations were taken into account as measurements, 4. The estimator of Section 3.4, where only case attributes were taken into account as measurements, 5. The estimator of Section 3.5, taking into account attributes, as well as activity occurrences and durations, For each of the regression experiments, optimal values for the bandwidth parameters were calculated using R <ref type="bibr" target="#b7">[8]</ref>, which uses an internal cross-validation method for finding the optimal values of the bandwidth parameters. Bandwidth selection and the computation of the predictions for each partial prefix, were done using the software package R, running on four dual quad-core 2.66GHz Intel Xeon CPUs with 16 GB of memory each. This setup allowed us to run the 10 experiments of the 10-fold cross validation in parallel, as each experiment uses a single thread. The longest experiment, using the activity durations as measurements took 5 hours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Discussion</head><p>Figures 1 to 5 show the results of our analysis. Each figure contains 3 lines, representing the actual remaining cycle time (in read, with square markers), the estimated remaining cycle time (in blue, with triangular markers) and the mean square error of the estimate (in pink, using circular markers), which uses a different scale. For sake of readability, the last part of each graph is zoomed out and those points that did not fit on the scale are annotated with their exact values.</p><p>On the x-axis, the time in days since the beginning of each case is depicted, i.e. the longest case took 252 days to complete, which spans the whole measuring period. On average, cases completed in 175 days. To get the points depicted in each graph, measurements were averaged over 7 day periods, i.e. the average time at which activities are performed within the first week of starting a case is 2.35 days, whereas the average remaining cycle time of those events is 173 days, thus the first point (2.35, 173) in the actual remaining cycle time graph.</p><p>All figures 1 to 5 show the same graph for the actual remaining cycle time. Interestingly, after approximately 180 days, the actual remaining cycle time stays constant at an average of 5 days.</p><p>Average Estimator: Figure <ref type="figure">1</ref> shows the performance of the average estimator.</p><p>As expected, this estimate is an almost straight line from an estimate of 175 days at time 0 to an estimate of 0 at 175 days and more. The deviations from the straight line are caused by the nature of the 10-fold cross validation experiment, i.e. the average cycle time over 9 partitions deviates from the average cycle time over the log. Note that the scale of the mean-square error, shown on the right-hand side, is different from the scale on the left-hand side.</p><p>The MSEs of all estimators are collected in Figure <ref type="figure">6</ref> and discussed in more detail in Subsection 4.4. Duration Estimator: Figure <ref type="figure">2</ref> shows the result of a 10-fold cross validation experiment using only activity durations as measurements. The estimated remaining cycle time follows the actual remaining cycle time more closely than in Figure <ref type="figure">1</ref>. However, the MSE of this estimator is far bigger. From 98 days after the start of a case, the duration estimator performs slightly  better than the average estimator, which can also be observed in Figure <ref type="figure">6</ref>. Nonetheless, it seems that using the durations as measurements does not provide much insights into the remaining cycle time.</p><p>Occurrences Estimator: Figure <ref type="figure">3</ref> shows the results when using activity occurrences as measurements. Here, the estimator follows the actual remaining time very closely, with a low value for the MSE. This indicates that using the activity occurrences as measurements is a good idea when trying to accurately predict the remaining cycle time of a case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attribute Estimator:</head><p>As shown in Figure <ref type="figure">4</ref>, using only the attribute values provides an even better estimate. The blue line with triangles in Figure <ref type="figure">4</ref>, showing the estimator base on attributed follows the actual remaining cycle time very closely, with an even lower MSE than the occurrences-based estimator, as shown in Figure <ref type="figure">6</ref>.</p><p>The bandwidth values indicate that the attributes "new queue", "id", and "priority" are the most influential attributes. The "priority" attribute is a boolean and the name suggests that this attribute indeed should have big influence on the cycle time of a case.</p><p>The attribute "new queue" indicates the next activity to be performed for a case, therefore this attribute changes as time passes and provides information about the future which makes it a good attribute to base predictions on. A fourth attribute that is relatively important is "queue", which indicates the activity that was just completed. As the non-parametric regression uses all variables to compare and select the most relevant cases, the combination of "queue" and "new queue" provide a good basis for selecting the most relevant cases from the measurements.</p><p>The attribute "id", indicates the case-identifier. As the cross-validation splits up the log, it ensures that the measurement of a case is never used to make a prediction for that same case. Therefore, the weight of this attribute is irrelevant to the prediction. This shows that it is very difficult to derive information from the values in the bandwidth.</p><p>Combined Estimator: Figure <ref type="figure">5</ref> shows the results of the prediction when using all available information, i.e. attribute values, activity occurrences and activity durations. As shown in Figure <ref type="figure">6</ref>, the combined estimator outperforms all estimators except the attribute-based one. Especially in the beginning and end of a case, the combined estimator performs worse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Error Analysis</head><p>In Figure <ref type="figure">6</ref>, the mean square errors of all four estimators are combined. The figure shows that overall, the durations-based estimator performs worst, whereas the attribute-base estimator performs best. This is backed up by Table <ref type="table" target="#tab_0">1</ref>, which shows the mean square error of all estimates made for each estimator (i.e. not averaged per week as in Figure <ref type="figure">6</ref>). It shows what we already concluded from the figures, i.e. that the durations estimator performs worst, but that the occurrences, attribute and combined estimators outperform the average estimator.</p><p>The best estimates are provided by attribute-based estimator and the combined estimator, which is not surprising as the attributes contain data relating to the difficulty of the case. What is interesting however, is that the estimator based on the occurrences of activities performs so well. This indicates that insights can be gained into the remaining cycle time, without having to consider privacy sensitive data. Especially in administrative processes, this can be valuable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation</head><p>The approach presented in this paper was implemented using the process mining framework ProM <ref type="bibr" target="#b0">[1]</ref>. Figure <ref type="figure" target="#fig_2">7</ref> shows a screenshot of ProM showing the opened log we used in our case study on the top-right, together with two plugins we developed, namely the "Prediction Miner" and the "Event Data Attribute Visualizer". ProM can be downloaded from www.processmining.org and the plugins mentioned in this paper are available in the nightly builds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Prediction Miner</head><p>The "Prediction Miner", shown on the left-hand side of Figure <ref type="figure" target="#fig_2">7</ref>, provides a simple interface to the user for the analysis presented in this paper. It can be used to connect to our machines running R <ref type="bibr" target="#b7">[8]</ref> via TCP/IP <ref type="bibr" target="#b9">[10]</ref>, but it also allows users to run R locally. Furthermore, it allows users to select the kernel functions to be used for different types of variables, as well as to set parameters not mentioned in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Event Data Attribute Visualizer</head><p>The prediction miner annotates each "complete" event in the log with attributes relating to the remaining cycle time. In fact, it always stores (i) the actual remaining cycle time for each event, (ii) the non-parametric estimate of the remaining cycle time and (iii) the average estimator of the remaining cycle time. These attributes can be visualized using the "Event Data Attribute Visualizer", which in Figure <ref type="figure" target="#fig_2">7</ref> shows these estimators on the bottom-right. Also settings are provided for selecting the histogram size, in our case 7 days, i.e. the points in the graph are averaged over 7 day periods. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Future Work</head><p>In this paper, we presented a regression-based method for predicting the remaining cycle time of cases in a process. As input, we used an event log of the process under consideration, where we explicitly used information about the durations of all activities, the occurrence of all activities and other case-related data. Using an example of a real-life process taken from practice, we have shown that our approach outperforms the naive approach of average cycle time minus the already spent time.</p><p>As a regression technique, we used non-parametric regression, where we assumed that activity durations are continuous variables, activity occurrences are ordered ordinal variables and that all other case-data variables are unordered ordinal variables.</p><p>Although our results show that the predictions made under these assumptions are accurate, we expect that improvements can be made when case-data variables are not assumed to be unordered ordinal. However, deciding about the type of variable for each data attribute is a human job, which can typically only be performed by the process owner, since it requires insights into the process at hand and the semantics of the data attributes. To gain a deeper understanding of the situations in which the regression-based predictions perform well, conducted simulation experiments <ref type="bibr" target="#b3">[4]</ref>.</p><p>The approach presented in this paper has been implemented in the process mining framework ProM and is available via www.processmining.org.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 2 . 1 .Definition 2 . 2 .</head><label>2122</label><figDesc>(Case, Log) Let A be a set of activities. σ ∈ A * is a case, consisting of activities. A log W over A is defined as a bag of cases, i.e. W ⊆ IN A * . (Sequence start, completion, duration) Let A be a set of activities and σ ∈ A * a sequence of activities. We define τ s (σ) ∈ IR + and τ c (σ) ∈ IR + to represent the start and completion times of the sequence σ. By definition, we say that τ s ( ) = τ c ( ) = 0 and we denote the duration of a sequence by δ(σ) = τ c (σ)τ s (σ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .Fig. 2 .Fig. 3 .Fig. 4 .Fig. 5 .Fig. 6 .</head><label>123456</label><figDesc>Fig. 1. Estimated values using average estimator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. ProM showing the opened log (top-right), the settings of the prediction miner (left) and the result as a graph (bottom-right)</figDesc><graphic coords="17,41.84,55.07,345.80,207.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Mean Square Error of all estimators, with 5% confidence interval</figDesc><table><row><cell>Estimator</cell><cell>Mean Square Error</cell></row><row><cell>Average Estimator</cell><cell>2687.47 ± 133.69</cell></row><row><cell>Durations Estimator</cell><cell>5134.12 ± 320.02</cell></row><row><cell cols="2">Occurrences Estimator 1754.61 ± 115.38</cell></row><row><cell>Attribute Estimator</cell><cell>1532.85 ± 103.25</cell></row><row><cell>Combined Estimator</cell><cell>1537.42 ± 106.44</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>R. Meersman and Z. Tari (Eds.): OTM 2008, Part I, LNCS 5331, pp. 319-336, 2008. c Springer-Verlag Berlin Heidelberg 2008</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>For continuous variables, the bandwidth is often denoted by h instead of λ to show the difference in domains. However, for consistency, we use λ.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>The last activity is not considered, as the case is than finished and therefore the remaining cycle time is known.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">ProM 4.0: Comprehensive Supports for Real Process Analysis</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Van Dongen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Günther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICATPN 2007</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kleijn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Yakovlev</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4546</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Reijers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J M M</forename><surname>Weijters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Van Dongen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Alves De Medeiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M W</forename><surname>Verbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Business Process Mining: An Industrial Application</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page">713</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multivariate binary discrimination by the kernel method</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aitchison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aitken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrika</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="413" to="420" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Predictions in Information Systems, a process mining perspective</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Crooy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-11">2008. November 2008</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology ; via Digital Library of Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master Thesis</note>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A statistical approach to case based reasoning, with application to breast cancer data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dippon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Statistics and Data Analysis</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="579" to="602" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Applied Nonparametric Regression</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hardle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K A</forename><surname>De Medeiros</surname></persName>
		</author>
		<title level="m">Genetic Process Mining</title>
		<meeting><address><addrLine>Eindhoven</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<orgName type="collaboration">R Development Core Team</orgName>
		</author>
		<title level="m">R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Nonparametric estimation of regression functions with both categorical and continuous data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Racine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Econometrics</title>
		<imprint>
			<biblScope unit="volume">119</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="99" to="130" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Rserve -A Fast Way to Provide R Functionality to Applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Urbanek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Workshop on Distributed Statistical Computing</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Hornik</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Leisch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Zeileis</surname></persName>
		</editor>
		<meeting>the 3rd International Workshop on Distributed Statistical Computing</meeting>
		<imprint>
			<publisher>DSC</publisher>
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Conformance checking of service behavior</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ouyang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rozinat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Verbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Interet Technol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
