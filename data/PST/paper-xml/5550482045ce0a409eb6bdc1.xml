<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">HideM: Protecting the Contents of Userspace Memory in the Face of Disclosure Vulnerabilities *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jason</forename><surname>Gionta</surname></persName>
							<email>jjgionta@ncsu.edu</email>
						</author>
						<author>
							<persName><forename type="first">William</forename><surname>Enck</surname></persName>
							<email>enck@cs.ncsu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Peng</forename><surname>Ning</surname></persName>
							<email>pning@ncsu.edu</email>
						</author>
						<author>
							<persName><forename type="first">[</forename><surname>Management</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">North Carolina State University Raleigh</orgName>
								<address>
									<region>NC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<addrLine>San Antonio</addrLine>
									<postCode>2015</postCode>
									<region>Texas</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">HideM: Protecting the Contents of Userspace Memory in the Face of Disclosure Vulnerabilities *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">42D23D40F8AD69A43A324DD24966EDA7</idno>
					<idno type="DOI">10.1145/2699026.2699107</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>return-oriented programming</term>
					<term>information leaks</term>
					<term>memory disclosure exploits</term>
					<term>code reuse attacks</term>
					<term>memory protection</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Memory disclosure vulnerabilities have become a common component for enabling reliable exploitation of systems by leaking the contents of executable data. Previous research towards protecting executable data from disclosure has failed to gain popularity due to large performance penalties and required architectural changes. Other research has focused on protecting application data but fails to consider a vulnerable application that leaks its own executable data.</p><p>In this paper we present HideM, a practical system for protecting against memory disclosures in contemporary commodity systems. HideM addresses limitations in existing advanced security protections (e.g., fine-grained ASLR, CFI) wherein an adversary discloses executable data from memory, reasons about protection weaknesses, and builds corresponding exploits. HideM uses the split-TLB architecture, commonly found in CPUs, to enable fine-grained execute and read permission on memory. HideM enforces finegrained permission based on policy generated from binary structure thus enabling protection of Commercial-Off-The-Shelf (COTS) binaries. In our evaluation of HideM, we find application overhead ranges from a 6.5% increase to a 2% reduction in runtime and observe runtime memory overhead ranging from 0.04% to 25%. HideM requires adversaries to guess ROP gadget locations making exploitation unreliable. We find adversaries have less than a 16% chance of correctly guessing a single gadget across all 28 evaluated applications. Thus, HideM is a practical system for protecting vulnerable applications which leak executable data.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Protecting memory is a critical component to ensuring the security of a system. Process memory contains many types of sensitive information including code, keys, and other secrets. Contemporary computer hardware contains page level memory protections preventing reads and writes. These protections provide isolation between address spaces (e.g. user and kernel-space).</p><p>Recent processor extensions seek to protect memory within an address space. For example, the no-execute (NX) protection bit prevents execution of specific memory pages (e.g., stacks). Unfortunately, techniques such as Return Oriented Programming (ROP) allow successful exploitation without executing these memory pages <ref type="bibr" target="#b21">[23]</ref>.</p><p>A common requirement for modern exploits to bypass system protections (e.g., ASLR, DEP) is reading memory. Specifically, a memory disclosure vulnerability is used to disclose code locations and values to ensure exploit reliability and correctness <ref type="bibr" target="#b15">[17]</ref>. Memory disclosure vulnerabilities that leak code instructions are fundamentally possible because execute permission always implies read permission on commodity hardware. As a result, advanced protections such as fine-grained ASLR <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b32">34]</ref> and Control Flow Integrity <ref type="bibr" target="#b0">[2,</ref><ref type="bibr" target="#b35">37]</ref> can be bypassed leading to exploitation <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b8">10]</ref>.</p><p>Execute-only memory is a well defined and understood technique for protecting the contents of memory. Multics, a classical secure system design and architecture, included an execute-only bit for memory pages <ref type="bibr" target="#b5">[7]</ref>. XoM implemented execute-only memory by encrypting executable data and only decrypting on instruction loads. XoM required a custom processor architecture and suffered from poor performance making adoption difficult. Regardless, both approaches are too coarse grained in their protections.</p><p>We seek to broadly protect critical contents of userspace memory by leveraging a concept we call code hiding. Code hiding is inspired by PaX <ref type="bibr" target="#b26">[28]</ref> for enabling no-execute memory without hardware extensions, as well as by advanced rootkit hiding that prevents forensic analysis <ref type="bibr" target="#b23">[25]</ref>. We propose code hiding to protect userspace memory from being read by a malicious or vulnerable process. Code hiding is enabled using the unique features of the split Translation Lookaside Buffer (TLB) architecture to configure reads of executable pages on contemporary commodity hardware.</p><p>In this paper we propose HideM, a system that disallows userspace code from arbitrarily reading critical data in its own memory address space. HideM is built on code hiding to prevent reading executable data of existing legacy and COTS binaries. We observe the majority of code does not need to be read but only executed. We propose code reading policy as an approach to enforce fine grained read access on executable pages. Applications can also leverage HideM to protect sensitive data by encoding critical data in executable pages. The design of HideM allows integration with existing advanced security techniques (e.g., fine-grained ASLR <ref type="bibr" target="#b32">[34,</ref><ref type="bibr" target="#b12">14]</ref> and CFI approaches <ref type="bibr" target="#b35">[37]</ref>). HideM ensures memory disclosure vulnerabilities cannot be used to find ROP gadgets to enable reliable exploitation, discover vulnerabilities in memory, and enable some forms of data leakage. Furthermore, HideM is generic and can be enabled on existing commercial hardware with minimal performance overhead to protect memory against disclosures.</p><p>Code reading policies are created based on data that may be legitimately read by code. For example, the GNU GCC compiler will embed exception handling data in code pages as an .eh frame section. Policies are generated based on binary structure (e.g., read-only data in executable pages) and code/function symbols. To identify what code needs to be read as data, we perform binary analysis to recover code symbols from executable sections and identify data in code. We perform minimal manual analysis to verify the identification of data in code as correctly identifying all data in code is provably undecidable <ref type="bibr" target="#b33">[35]</ref> HideM uses code reading policies to divide read data from executable data (e.g., machine code) on executable pages. Shadow memory pages are created containing only required readable data or executable data. The OS kernel configures the hardware split-TLB to hide executable data from userspace read access. As a result, HideM can transparently apply code reading policies to commercial off-the-shelf (COTS) binaries.</p><p>In this paper, we make the following contributions:</p><p>â€¢ We design and implement HideM for protecting against the broader threat of information disclosure of process memory. HideM leverages code hiding as a new security mechanism to provide fine-grained userspace read access without changing current commodity hardware. â€¢ We propose code reading policy to automatically configure userspace reads of binary executable pages. Policy is enforced at runtime and protects executable data vulnerable to memory disclosure. â€¢ We evaluate compatibility, performance, and security impact of HideM. We find that HideM has limited impact on performance. The runtime increase ranges from 6.5% to a 2% reduction. We observe working memory increases ranging from 0.04% to 25%. Furthermore, HideM raises the level of security for protected binaries by reducing the probability of reliable exploit. We find an adversary has a less than 16% chance of guessing a single valid ROP gadget.</p><p>The remainder of this paper is as follows. Section 2 has a background on memory access and memory disclosures. Section 3 provides an overview, Section 4 discusses design, and Section 5 provides implementation details. Section 6 evaluates HideM. Section 7 discusses limitations and future work. Section 8 has related work. Section 9 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND AND MOTIVATION</head><p>We briefly provide background and motivation for HideM. First, we discuss memory accesses using hardware caching of virtual to physical mappings. Then, we motivate HideM looking at the threat of memory disclosure on existing security protections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Memory Access via TLB</head><p>The Translation Lookaside Buffer (TLB) is a cache used by processors to reduce the cost of continuous memory accesses. The TLB stores mappings from page numbers (i.e., upper bits of a linear/virtual address) to physical frame (i.e., upper bits of physical address) along with page status and permissions. The TLB obviates the need for the system Memory Management Unit to walk page-tables for each memory access. The TLB also assists in MMU translations (i.e., walking pages-tables) by adding entries for intermediate page-table values (i.e., top level page directories).</p><p>Operations of TLB: TLB operations for managing entries are architecture specific. For example, SPARC implements TLB in software and thus the OS manages the TLB by adding and evicting entries <ref type="bibr" target="#b34">[36]</ref>. On the other hand, x86 and ARM architectures use both hardware and software for TLB management <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b11">13]</ref>. Specifically, entries are only added by hardware after the MMU walks page-tables. Entries are flushed (i.e., evicted) by both hardware events such as task-switch or using privileged CPU instructions.</p><p>Split-TLB Architecture: Processors commonly contain two TLBs, a DTLB to handle data accesses and an ITLB to handle instruction fetches. This split architecture allows for better locality of accessed memory <ref type="bibr" target="#b16">[18]</ref>. In normal execution, the DTLB and ITLB are synchronized and contain the same values for a given address. TLB flushes of a specific address will remove associated entries from both the ITLB and DTLB. However, entries are added based on the type of CPU access. If an instruction is executed on a page, an ITLB entry is added. If memory is read, for example via a mov instruction, a DTLB entry is added.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Memory Disclosure</head><p>Memory disclosures are a subset of information leakage vulnerabilities in which an adversary gains unauthorized access to read raw memory. An adversary can then leak sensitive information such as encryption keys, passwords, or executable data. Using leaked executable code and associated addresses, an adversary can build reliable ROP based exploits in an automatic and just-in-time fashion <ref type="bibr" target="#b22">[24]</ref>. Memory disclosures have also been used in bypassing CFI enforcement. Goktas et al. showed relaxed CFI code transfer enforcement can lead to ROP based exploitation <ref type="bibr" target="#b8">[10]</ref>. The authors' exploit relied on a memory disclosure vulnerability to find function call and return stubs for trampolines.</p><p>There is a growing need to protect systems against memory disclosures; however existing research is limited. In independent work, Backes et al. <ref type="bibr" target="#b2">[4]</ref> seek to provide "Execute Not Read" (XnR) permissions on code pages. Unfortunately, the proposed approach allows reading of the currently executing code page (and optionally surrounding pages within a window). These pages can be identified by return addresses on the stack and therefore can used in a JITROP attack <ref type="bibr" target="#b22">[24]</ref>. Furthermore, their approach does not address allowing legitimate code reads present in PIE and C++ binaries. Our proposed approach provides finer-grained protection to allow legitimate reads of code page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Process Memory</head><note type="other">Code</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">OVERVIEW</head><p>The goal of HideM is to protect binaries from leaking executable data from arbitrary reads by userspace code. In turn, HideM thwarts memory disclosure vulnerabilities and JIT-ROP style attacks described in previous work <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b8">10]</ref>. At a high level, HideM simply displays different contents of memory for different CPU operations. Figure <ref type="figure" target="#fig_0">1</ref> depicts the basic protection of HideM wherein a single memory address provides different content based on read or execute operations. Specifically, read operations will access read pages and instruction fetches will access code pages. As a result, memory containing executable data that is hidden cannot be read by processes or other traditional memory reading operations. Similarly, hidden read-only data (e.g., jump tables, binary headers) on executable pages can no longer be used for execution.</p><p>The properties of HideM harden the security of existing systems and provide new opportunities to protect data in memory. However, enabling seamless memory protections provided by HideM faces challenges:</p><p>C-1: Ability to execute memory implicitly allows read access.</p><p>Existing commodity hardware architectures such as x86 and ARM do not provide distinctions between read and execute permission. Executable memory implicitly contains read permissions in these architectures. As a result, all code can be read as data. Memory hiding must differentiate memory accesses into read and execute operations. C-2: Executable pages of binaries often contain read-only data that is read during execution. For example, GNU GCC references immediate values in code as memory addresses of functions. We must ensure that we allow legitimate reads of such data for correct execution. This requires fine-grained read-access at subpage granularity. C-3: Support for legacy and commercial-off-the-self binaries without code symbols. We must determine what data needs to be read by code to build code reading policies. Symbols can be added at compile time with access to source code but often removed in final binaries.</p><p>To overcome the above challenges, we use a combination of binary analysis (C-3), OS kernel memory management (C-2), and hardware memory features (C-1). Specifically, Hi-deM performs lightweight data analysis to identify read data (e.g. jump-tables, or embedded data) and symbols for data residing in executable pages (C-3). At binary load time, HideM generates a read policy based on identified symbols and in-memory binary layout to allow code to read legitimate data from memory (C-2). The policy is then enforced on memory access through OS kernel hardware configuration using the memory address caching of TLBs (C-1).</p><p>We identify that code pages often contain read-only data and function symbols that are read during legitimate execution (C-2). Thus, memory hiding must allow for selective reads of data on code pages. HideM generates a read policy that allows for such data to be legitimately read by code. The policy is generated using binary and symbol information to create a shadow page that contains necessary data for correct execution. The policy is enforced by adding a page of read-only data to the DTLB and a page of instructions to the ITLB. When the DTLB or ITLB is not configured, all page accesses are trapped allowing TLB reconfiguration.</p><p>The read policy is generated based on binary section information along with symbols and read-only data in executable sections. Symbols are often found as part of relocation information. Unfortunately, many compilers such as GNU GCC and LLVM remove relocation information by default and thus COTS binary will not have symbols for code sections (C-3). We reconstruct partial relocation information to identify symbols in code sections using static binary data analysis. Specifically, we log the locations of all possible immediate values in code sections that may point to code addresses. These symbols represent the expected data that may be read by code during execution. In a small number of cases, read-only data such as jump-tables are embedded in executable data. We adapt algorithms and heuristics based on previous research <ref type="bibr" target="#b35">[37]</ref> to identify subject data in code. After which, we manually verify data identified as ambiguous because distinguishing data from code is a proven undecidable problem <ref type="bibr" target="#b33">[35]</ref>. Fortunately, our experience using HideM indicated that ambiguous data only occurred in a few libraries. We also use binary layout information to identify compiler marked read-only data in code pages.</p><p>The general flow of HideM is shown in Figure <ref type="figure" target="#fig_1">2</ref>. Prior to execution, binaries are analyzed and data locations in executable sections are added to the binary as non-loaded data. Upon loading of the binary, the OS will identify the binary as protected by HideM, extract the data locations, and identify load information (i.e., segment permissions, section permission, offsets). Using this information, HideM builds a read policy containing executable data regions and data required to be read. On first load of a protected page into memory (e.g., on page-fault), the policy is applied to the faulting page by identifying the locations of read-only data, executable data, and data locations on the page. The policy is then enforced through hardware configurations set by the OS. Specifically, we leverage the concepts of desynchronizing the split ITLB/DTLB to seamlessly enforce different memory permissions for different CPU operations (i.e., instruction loads and memory reads) (C-1).</p><p>Assumptions: We assume that the system has a Memory Management Unit (MMU) configured with virtual addressing and page-tables.  TLB caching and virtual address permissions (e.g., supervisory, non-writable, non-execute, non-present). We assume that all code pages for hiding are non-writable. Our approach assumes the target hardware has a split-TLB architecture and does not have a unified TLB cache. We discuss implications of unified TLB caches in Section 7.</p><p>Threat Model: We trust that the operating system kernel is not modified or compromised. Attackers have access to memory disclosure vulnerabilities that can read arbitrary userspace virtual memory of a vulnerable process. However, the attackers do not have prior knowledge about known locations of ROP gadgets in memory. Specifically, the attacker cannot assume ROP gadget locations based on binary load location.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">HIDEM</head><p>Next, we discuss the details of HideM. In Section 4.1, we discuss enforcing memory permissions based on memory access types using TLB de-synchronization and OS kernel page table management. In Section 4.2, we discuss generating and enforcing a code reading policy. Section 4.3 discusses HideM support for protecting userspace executable memory allocations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Memory Permissions Enforcement</head><p>HideM provides separate enforcement for reading and executing data in memory for commodity systems. Memory permissions are enforced by (1) trapping all accesses to hidden memory (i.e., protected executable pages) by default, and (2) configuring the ITLB and DTLB to allow access to distinct physical pages for code and data respectively. Once the TLB is configured, future memory accesses of the page will not trap, allowing execution to continue. The TLB needs reconfiguration after the TLB is cleared. Figure <ref type="figure" target="#fig_2">3</ref> shows an overview of enforcing memory protections. The hardware traps hidden memory access based on virtual memory page permissions. The page-fault handler is then responsible for priming the TLB with correct virtual to physical page mappings and permissions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Permissions Management</head><p>By default, all accesses to hidden memory must be trapped when the TLB is not configured. This ensures that the OS kernel can configure memory permissions for hidden memory prior to access. This is similar to standard page-faults whereby the OS kernel is responsible for correctly configuring page-table entries. However, the lack of distinction between execute and read permissions in page-table structures limits the ability to handle hidden memory in hard-ware. Instead, the OS must intervene on access to configure permissions accordingly.</p><p>HideM uses page-faults as a gate to mediate all accesses to hidden memory. To enable page-faults by default, the user bit is cleared for page-table entries of protected memory effectively marking the memory for supervisor access only. This bit is commonly cleared for kernel pages and is supported on all contemporary processors. As a result, all accesses from userspace to the protected page will cause a page-fault. Note that all HideM page-table entries by default have a physical address of a shared zero page. This prevents any userspace controlled memory from being used for privilege escalation.</p><p>Blocking all userspace accesses to hidden memory will not allow for useful execution. To allow execution to continue, the page-tables are temporarily configured with permissions that allow memory access based on CPU operation of the fault. For example, on an instruction fetch fault, HideM temporarily maps the page-table entry to the physical address of the code page and sets permission for userspace access. Next, the TLBs are de-synchronized to allow execution, but block future reads. After de-synchronization, the page-table entry that blocks access by default is restored.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">TLB Priming and De-synchronization</head><p>The split-TLB architecture stores separate virtual address to physical address mappings along with permissions for instruction loads and data reads. In traditional system operations, page-table configurations are added to TLB caches upon memory access and instruction fetches. As a result, when data from a code page is both read and executed, the ITLB and DTLB values will be identical and thus synchronized.</p><p>TLB de-synchronization occurs when the ITLB and DTLB contain different entries for the same virtual address. The implication of de-synchronization allows a single virtual address access to result in disparate physical page accesses. For example, Figure <ref type="figure" target="#fig_2">3</ref> depicts a de-synchronization where an ITLB entry for virtual address 0x40000 maps to physical address 0x1000 and the DTLB has a mapping for virtual address 0x40000 to physical address 0x4000. Unfortunately, TLB operations for adding entries to the ITLB and DTLB are limited to specific architectures as discussed in Section 2.1. As a result, we must provide a way to add entries to the ITLB and DTLB thereby enabling TLB desynchronization.</p><p>TLB priming is the process of configuring hardware to add entries to either the ITLB or DTLB. The idea of TLB priming uses the knowledge of how hardware adds entries to respective caches. In the case of the ITLB, an entry is added after the page-table is successfully walked by the configured MMU to fetch an instruction. Similarly, a DTLB entry is added upon walking the page-table for a read operation. A successful page-table walk occurs when the physical page for a page-table entry is present and contains the correct permissions for the operation.</p><p>Priming of the TLB begins when a page-fault occurs on access to hidden memory. The TLB entry for the address is flushed for the virtual address accessed by the operation. This is required to ensure there are no existing entries that may contain wrong permissions (e.g., supervisory). Two page-table entries are generated to allow userspace access. One entry pertains to a read operation and the other to an execute operation and thus the corresponding entries are configured with the physical page addresses accordingly.</p><p>The page-tables of the faulted process are briefly updated with the read page entry and the code page entry. When the page-table is set with the read entry, the DTLB can be primed by reading one byte from the page using the faulted virtual address. Similarly, the ITLB is primed after the code page is mapped in the page-tables and then executing an instruction in the page. On the first page-fault for a hidden page, the executable data page is mapped to kernel space and the page is searched to find a return gadget or similar instruction (e.g., ret, jmp %reg). Searching for the gadget using kernelspace addressing prevents priming the DTLB with a userspace address to code page entry. HideM then calls into the page at the gadget location using the userspace virtual address of the return gadget. After priming, the page-table is updated to the original faulting value. For processors that support SMEP and SMAP, protections are disabled immediately before priming and enabled after priming.</p><p>HideM primes both the ITLB and DTLB on each pagefault. This prevents multiple page-faults from occurring by code that reads data on the executable pages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Non-Execute Optimization</head><p>For processors supporting non-execute (NX) page permissions, HideM can use the NX bit to trap access instead of the user bit. By default, HideM protected pages will all be nonexecute and mapped to the read page allowing applications to read the data but not execute. Page-faults for priming only occur on execution. This is beneficial in applications containing large amounts of read-only data on executable pages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Code Reading Policy</head><p>De-synchronized TLBs allow page-level read and execute policies to be set on memory. For example, HideM can enforce execute-only memory wherein executable pages cannot be read. Unfortunately, executable pages of existing binaries often contain data that is read during execution. As a result, execute-only pages are too broad for applying permissions to binaries. Thus, HideM must allow selective reads of executable pages to enable correct execution.</p><p>Code reading policy identifies the bytes on an executable page that may be read as data. Executable pages read as data will only contain required data for execution and not the majority of code.</p><p>Data required to be read on executable pages can be categorized into two types:</p><p>DT-1 read-only data on executable pages (e.g., jump tables, exception handler data, binary headers) DT-2 immediate values used for pointer arithmetic and function calls (e.g., symbol addresses, call offsets).</p><p>HideM instances of DT-1 and DT-2 data are represented as byte ranges and offsets in executable pages. After all of the data embed in executable pages is identified, the offsets and ranges of identified data are added to the binary in a new section which is processed during binary load time. Next, we provide details for identifying DT-1 and DT-2 data using binary structure and binary analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Identifying DT-1 Data</head><p>DT-1 data can (1) reside outside executable data (e.g., binary headers) or (2) be embedded with executable data (e.g., jump-tables). This data is never executed by a process and thus can be removed from code pages used for execution.</p><p>Read-only DT-1 data outside of executable sections can be identified using binary structure and metadata. For example, ELF <ref type="bibr" target="#b4">[6]</ref> binaries contain sections which identifies contents and permissions. Sections are associated with segments which defines in-memory binary locations and permissions. Section permissions are disjoint from segments allowing read-only sections to be part of an executable segment. GNU GCC default linker scripts combine read-only sections (e.g., .rodata, .eh frame hdr, .eh frame, .rela.dyn) with executable sections (e.g., .init, .plt, .text, .fini) into one segment and thus the same physical pages of memory. PE/COFF <ref type="bibr" target="#b29">[31]</ref> read-only data is by default configured in different pages simplifying policy generation on Windows.</p><p>Read-only DT-1 data embedded within executable sections is identified using binary analysis. We apply a modified algorithm and heuristic presented by Zhang and Sekar <ref type="bibr" target="#b35">[37]</ref> to discover jump-tables and other non-standard data in code. Specifically, we run the algorithm to first identify all control flow locations and build a control flow graph. The algorithm identifies jump-tables to determine all indirect control flow locations required for enforcing control flow integrity. To identify data that is not noted as jump tables, regions of the binary not belonging to the generated call graph are marked as unknown. These regions map to gaps and errors in disassembly. Complete and correct identification of data in code requires correct disassembly, which is a known undecidable problem <ref type="bibr" target="#b33">[35]</ref>. Thus, we perform minimal manual analysis of unknown regions to verify contents as data. Due to space constraints, we only briefly describe the algorithm for disassembly and analysis. We encourage the reader to read previous work <ref type="bibr" target="#b35">[37]</ref> for a more detailed discussion of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Identifying DT-2 Data</head><p>DT-2 data is often encoded by linkers as relocation information. Relocation data is commonly found in PE/COFF binaries and used for enabling binary relocation and ASLR. Thus, Windows binaries with ASLR enabled do not require analysis to identify DT-2 data. However, ELF binaries often have relocation information stripped which makes generating a code reading policy from COTS binaries less feasible.</p><p>We look to recover relocation information by analyzing binaries to identify potential symbol references. Unfortunately, complete reconstruction of relocation information from binaries is an unsolved problem <ref type="bibr" target="#b18">[20]</ref>. However, we identify that reconstructing DT-2 data is a confined prob- lem with a number of assumptions and restrictions. As a result, DT-2 data can be reconstructed from static binary analysis.</p><note type="other">Userspace Kernel Hardware Process Code</note><p>DT-2 data assumes that memory being read as data will reside in executable sections. This data is categorized into two groups: (1) immediate values that represent addresses located within an executable section, and (2) instruction pointer relative offsets resolving to an executable section.</p><p>Prior to execution, DT-2 data is identified using binary headers and analysis of the disassembled binary. Executable sections and their ranges in virtual memory are found using binary headers and the base load address. The binary is disassembled and searched for operations containing immediate values and instruction relative pointer operations that resolve to addresses located in code sections. For example, a x86 call instruction will specify a relative address to execute. The offsets used as part of the instruction must be readable. Identifying DT-2 data is performed during analysis to identify DT-1 data embeded in code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Applying the Policy</head><p>HideM uses DT-1 and DT-2 data to divide executable pages into read pages (i.e., containing only DT-1 and DT-2 data) and code pages (i.e., executable data which includes DT-2 data). Once divided, these pages are used in TLB priming and de-synchronization. TLB hardware then enforces the read and execute policies on these pages as described in Section 4.1.2.</p><p>At binary load time, DT-1 and DT-2 data locations are recorded and associated with virtual memory address allocations (e.g., Virtual Memory Areas for Linux, Virtual Address Descriptors for Windows). The associated values are then used to generate separate code-only and read-only pages when an executable page is mapped into memory.</p><p>On a page-fault of a non-present executable page, DT-1 and DT-2 ranges are checked to determine if the executable page has data that can be read by code. If the faulting page does not have DT-1 and DT-2 ranges, the code page should never be read as code and thus the DTLB is only primed with a shared zeroed page. If the executable page contains DT-1 or DT-2 ranges, then a read page is created and the code page is modified with respect to DT-1 and DT-2 ranges. Specifically, the DT-1 and DT-2 ranges from the code page are copied to the read page. The code page has DT-1 ranges filled with halt instructions. If the page contains only DT-1 data, then the page is not modified and a shared code-page filled with halt instructions is used to prime the ITLB. By isolating DT-1 data and executable data into separate pages, the policy prevents read-only data on executable pages from being used as ROP gadgets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Hardening HideM against ROP Exploits</head><p>DT-2 data must be both readable and executable. Therefore, the same DT-2 data values will appear in both the read and the code shadow pages. This property allows an adversary to potentially build ROP gadgets from DT-2 data. Since DT-2 data is limited in size (4 bytes) and is noncontiguous, the complexity of potential ROP gadgets is limited. However, HideM strives to make the discovery of DT-2 ROP gadgets as difficult as possible.</p><p>As depicted in Figure <ref type="figure" target="#fig_2">3</ref>, discovering DT-2 data in read pages is trivial: all non-DT-2 data is zero. We harden Hi-deM by replacing the zero data with random data. The random data is created to match the form of DT-2 data. Therefore the adversary must guess if a memory location value is DT-2 data (i.e., executable) or not. An incorrect guess will cause the program to crash.</p><p>HideM generates random, fake DT-2 data based on the types of values that are stored in DT-2 data. Specifically, DT-2 data is instruction pointer relative addresses or values. We fill read pages with false data that is relative to both the location being filed and the executable sections for the binary loaded at this location. We also randomly align this data in the page to prevent guessing DT-2 data locations based on alignment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Protecting Userspace Allocated Executable Memory</head><p>HideM generates code reading policy based on DT-1 and DT-2 ranges from the kernel at process load time. However, many applications load shared libraries from userspace (i.e., dynamic linking) or dynamically allocate executable memory at runtime (e.g., scripting). This presents a challenge, since HideM does not have the context required generate code reading policy for these executable pages.</p><p>To address this challenge, HideM provides an interface for userspace applications to provide context required for protecting runtime allocated memory. Memory may be flagged as HideM protected at allocation time or by changing protections. In effect, this makes protected memory execute-only. The userspace application can then provide DT-1 and DT-2 ranges to generate the shadow pages for priming. Note that, HideM only enforces protection after the memory has been made non-writable. As a result, HideM can protect dynamically loaded libraries and other dynamically allocated memory at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION</head><p>Our HideM implementation uses a modified tool from previous research <ref type="bibr" target="#b35">[37]</ref> to disassemble and parse binaries to identify DT-1 and DT-2 data. Specifically, we added support for 64-bit binaries. DT-1 and DT-2 data locations are then written back into the binary as a separate non-loaded section. HideM protected binaries have their in-memory permissions of executable data modified with a new protection flag. Note that HideM converted binaries also work on legacy systems.</p><p>We implemented HideM for Linux Kernel 3.10.12 with 64bit ELF support. Currently, we do not have 32-bit support, however this is an engineering issue. We augment ELF binary loading in the kernel to extract DT-1 and DT-2 ranges from the HideM enabled binaries. We also modify interpreter loading to protect HideM enabled dynamic loaders or interpreters as discussed in Section 4.3. Code reading policy is associated with binary load addresses and the provided DT-1 and DT-2 ranges. False executable data used for hardening against ROP exploits is generated using a hardware random number generator.</p><p>To test support for shared libraries, we modified the LDloader for GLIB 2.18. The LD-loader tells the kernel which binary and data locations to protect. In total we added 53 lines to enable HideM support of GLIB. We believe minimal effort would be required for porting other dynamic loaders such as Apache's mod so for Dynamic Shared Objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EMPIRICAL EVALUATION</head><p>We look to evaluate the practicality of adopting HideM to existing platforms by evaluating three different aspects of HideM. First, we evaluate HideM's impact on system performance and resources. Next, we evaluate HideM's compatibility with COTS applications. Finally, we provide a security evaluation to investigate the reduction of valid gadgets and the probability that an adversary can build a valid ROP exploit for a HideM protected binary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental Setup</head><p>We performed our evaluation on an IBM LS22 blade server with two Quad-Core AMD Opteron 2384 processors with 32GB of RAM running 64-bit Ubuntu 12.04.4 LTS. Each core can store 1024 4KB page entries. This processor does not support SMEP or SMAP and thus are not considered in the performance evaluation. However, disabling and enabling SMEP and SMAP consists of twelve instructions in total.</p><p>We acquired 28 different applications for evaluating Hi-deM. These applications were chosen based on the dataset provided in previous work <ref type="bibr" target="#b35">[37]</ref>. 19 applications are part of SpecCPU2006 and 9 applications are non-trivial common Linux user applications. We built the SpecCPU2006 benchmark applications with a modified base AMD64 configuration adding only "check md5=0" to prevent rebuilding applications that were converted to HideM. The complete list of applications can be viewed in Figure <ref type="figure" target="#fig_4">5</ref>.</p><p>We converted the 28 applications along with all required shared libraries to enable HideM protection. In total, we converted 442 binaries totaling 441MB. We identified that 3% (13 binaries) of 442 binaries contained data embedded in code of which only libcrypto.so required manual analysis for unknown data regions containing cryptographic algorithm data.</p><p>Each binary is converted by identifying DT-1 and DT-2 ranges in executable pages and writing the information back into the binary as a separate ELF section. We first converted the HideM supported GLIB ld-loader and shared libraries.</p><p>We then converted all binaries required for running the 28 applications. To identify all required shared libraries, we ran all 28 applications with LD DEBUG enabled for printing all files opened by the loader. This provided a list of all loaded binaries along with respective locations. We found that ldd did not provide a list of all binaries loaded into memory. The 28 application binaries had their ELF interpreter modified to load the HideM enabled GLIB ld-loader.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Performance Evaluation</head><p>HideM augments execution to enforce code reading policy. In turn, HideM may impact the performance of a running application when enforcing a de-synchronized TLB configuration. HideM also requires additional runtime memory for generated shadow pages. Finally, converting binaries to HideM support requires additional diskspace. Next, we evaluate HideM's impact of each of these categories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Runtime Overhead</head><p>To investigate HideM's impact on runtime performance, we observed the runtime overhead of the 19 converted Spec-CPU2006 applications. The benchmark was run with the command line options "-size=ref -noreportable -action=run -nobuild". This configuration constitutes a reportable run with the number of run iterations set to three for each application. However, we are required to set the "-noreportable" switch to force execution of the benchmark when "-nobuild" and "check md5=0" are set.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the percent overhead for each application as reported by SpecCPU2006. The percent overhead observed ranged from a 6.5% increase in runtime to a 2% decrease in runtime with an average increase of 1.49% and the median increase of 0.51%.</p><p>Many applications have minimal runtime overhead and even a performance increase. For example, h264ref has a 2% reduction in runtime. Low performance overhead and increases can occur for three reasons. First, read policy generation is lazy only occurring on first access to a protected page. Thus, the cost of generating a shadow page is only incurred after a page is accessed. The TLBs are then primed on first page-fault. Second, TLB priming opportunistically caches page mappings for both data and instructions on a single fault. Intermediate page level entries are cached preventing the need to walk the entire page-table. Standard hardware page-table walks may require caching all intermediate values. Finally, execution paths that do not cross many pages may never fill the TLB cache and thus may never be re-primed. Applications exhibiting noticeable overhead such as perlbench, soplex, and hmmer have TLB entries evicted requiring re-priming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Runtime Memory Overhead</head><p>HideM requires extra runtime memory for storing code reading policy and generated shadow pages. Shadow pages are generated under two conditions: (1) DT-1 data and executable instructions reside on the same page or (2) DT-2 data resides on an executable page. In the worst case, HideM will consume approximately twice the amount of executable pages allocated for a given binary.</p><p>We recorded the maximum Resident Set Size (RSS) for each tested application during our compatibility testing discussed in Section 6.3. We then ran each application without HideM protections under the same conditions (i.e., same kernel and modified GLIB) and workload recording the maximum observed RSS. Figure <ref type="figure" target="#fig_4">5</ref> shows the percent maximum RSS memory overhead for each of the 28 applications. The observed percent overhead increase ranges from 0.04% to 25% with an average of 4%. Applications exhibiting small amounts of overhead allocate significant amounts of data and or have tight execution flows which does not generate a significant number of shadow pages. We looked at the amount of memory increase in MBs for the five applications with the largest percent increase: smplayer/24.41MB, dumpcap/2.89MB, lyx/24.03MB, povray/3MB, lynx/4.09MB. The large memory footprint of smplayer and lyx occurs because execution covered a significant number of code pages across the loaded binaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3">Disk Overhead</head><p>To enable HideM support, binaries must provide DT-1 and DT-2 ranges residing in executable pages. This data is added to binaries during the conversion process and thus requires extra disk storage. We report the disk storage costs for enabling HideM support of the converted binaries.</p><p>We calculated the percent difference in on-disk binary sizes for all 443 converted binaries. We observed the average amount of data required to enable HideM support was 4.9% and medium of 4.2%. The overhead of the 28 application range 1% to 11.8%. Figure <ref type="figure" target="#fig_4">5</ref> shows the disk storage overhead for each of the 28 application binaries. HideM has the potential to leverage relocation information when available thereby reducing this cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Compatibility</head><p>HideM makes modest changes to binary loading and execution but should not interfere with correct execution. To evaluate HideM's correctness and compatibility with existing COTS applications, we ran the 9 non-trivial applications under application specific workloads. The list of applications tested along with workloads can be found in Table <ref type="table" target="#tab_1">1</ref>.</p><p>We also ran the 19 SpecCPU2006 benchmark applications with the same configuration discussed in Section 6.2.1. Spec-CPU2006 verified the expected output of each benchmark run and did not report any errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Security Evaluation</head><p>Our goal is to determine the security advantage of protecting binaries using HideM. The main way to exploit HideM is to build ROP exploits using only gadgets found in DT-2 data. These gadgets reside on both read pages and code pages. Gadgets found completely within DT-2 rages are valid and can be used in an ROP exploit. In an unprotected binary, all identified gadgets are valid. HideM obfuscates DT-2 data by randomizing readable data not part of DT-1 or DT-2 ranges with values that mimic DT-2 data. Gadgets identified as part of this data are non-valid.</p><p>HideM provides security advantages in two ways. First, HideM reduces the number of valid gadgets that can be used to build exploits; thus, making exploit synthesis more difficult. Second, HideM introduces non-valid gadgets into readable pages. As a result, an adversary must guess valid unique gadgets and locations within DT-2 to enable successful exploit generation.</p><p>First, we identified all valid and non-valid gadgets in memory for both HideM protected binaries and non-protected binaries for all 28 tested applications. To identify gadgets we used two open source ROP gadget finder tools: ROP-Gadget v4.0.4 <ref type="bibr" target="#b17">[19]</ref> and RP++ v0. <ref type="bibr">4 [1]</ref>. We chose these utilities for their flexibility, support of 64-bit architectures, and their difference in types of gadgets reported. ROPGadget reports a limited set of expressive gadgets (e.g., pop %reg ret) while RP++ is more aggressive providing many more less expressive gadgets. These tools do not enable synthesizing available gadgets to build exploits. Tools such as Q <ref type="bibr" target="#b19">[21]</ref> do synthesize gadgets to build exploits but do not support 64bit architectures. We dumped all reported gadgets from the two utilities and identified valid and unique sets of gadgets. Table <ref type="table">2</ref> contains the raw gadget data for all 28 application binaries, which will be used for calculating the probability of exploitation. Gadget sizes searched for HideM protected binaries were limited to a length of 4-bytes or less. This insight comes from the observation that symbols composing DT-2 data are likely 4-bytes for 64-bit binaries and are never contiguous. We use this data going forward to assess the security advantages of HideM.</p><p>Reduction in Valid Gadgets: Without hardening Hi-deM, DT-2 data stands out in memory. For example, Figure <ref type="figure" target="#fig_2">3</ref> shows a read page with a single valid DT-2 value. HideM reduces the set of valid gadgets available for exploitation. The set of valid unique gadgets in a HideM protected binary is a subset of all valid unique gadgets for a nonprotected binary. Thus an adversary is more restricted when synthesizing gadgets to build an exploit.</p><p>The total reduction in valid gadgets can be seen in Table 2 by comparing the "Orig." unique gadgets to "Valid HideM" unique gadgets. We found HideM reduces the number of valid unique gadgets identified by ROPGadget ranging from 38.24-100% and for RP++ ranging from 99.3-99.92%. The average reduction for ROPGadget is 77.33%. In general, the reduction is lower for applications with a larger number of DT-2 ranges, which leads to more potential gadgets.</p><p>Probability of Exploitation: Hardening HideM adds false data to read pages and forces an adversary to guess the locations of valid gadgets. As a result, an adversary cannot simply identify DT-2 data to build an exploit. Thus, adversarial exploitation of HideM protected binaries is based on the probability of correctly choosing a series of valid gadgets.</p><p>We can reduce the problem of building a successful exploit to modeling as "ordered sampling without replacement". The adversary chooses N different gadgets from a set of unique gadgets (Ug) at different address locations to build an exploit. There is a set of unique valid gadgets (Uvg), which is the subset of unique gadgets Ug containing at least one valid gadget. Choosing N unique valid gadgets from Uvg given the set of all unique gadgets Ug constitutes a successful exploit and takes the standard form</p><formula xml:id="formula_0">Uvg PN Ug PN = N n=1 Uvg -n -1 Ug -n -1</formula><p>where xPN = x! (x-N )! is permutation notation. In many cases, the same gadget is often found in multiple locations of the binary. Thus, an adversary must also choose a valid location residing in DT-2 ranges. Sg is the number of different address locations where a chosen unique gadget exists, and Svg is the number of valid locations for the specific gadget. Thus, we modify the standard form to account for Svg and Sg. The probability of successful exploitation against HideM is</p><formula xml:id="formula_1">N n=1 Uvg -n -1 Ug -n -1 Svg Sg</formula><p>Svg and Sg are gadget specific and are dependent on the frequency of duplicates.</p><p>We calculated the probability of exploitation for each of the 28 application binaries protected by HideM. Svg and Sg are gadget specific; thus, we substituted Svg Sg with an observed average for the distribution of valid gadgets to duplicate gadgets for each observed unique valid gadget. The right column of Table <ref type="table">2</ref> contains the probability when only one valid gadget is required for exploitation (e.g., N=1). In reality, exploits will require more than one gadget. Further- more, the expressiveness of gadgets size 4 or less bytes is limited and thus it is likely that more gadgets are required for exploitation <ref type="bibr" target="#b10">[12]</ref>. All binaries have a probability of less than 16% for an adversary to correctly choose only one valid gadget. Figure <ref type="figure" target="#fig_5">6</ref> plots the probability of exploit (y-axis) for the 10 most vulnerable binaries over the number of gadgets in an exploit(x-axis). When the exploit requires 5 gadgets (N=5), the probability of exploit approaches zero for all binaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">DISCUSSION</head><p>HideM does not support writable pages and thus does not support self-modifying programs. Previous work has argued that it is difficult to support self-modifying code in split memory architectures <ref type="bibr" target="#b7">[9]</ref>. However, we believe that applying HideM with self-modifying code is possible by providing updates to code reading policy after writing to a page.</p><p>HideM uses the split-TLB architecture to differentiate memory reads from instruction fetches. Unfortunately, modern processor architectures have begun to implement a unified L2 TLB cache<ref type="foot" target="#foot_0">1</ref> which does not differentiate TLB entries based on the type of access. As a result, any research or technical approaches that rely on a split-TLB to differentiate memory access will not function on these processors.</p><p>Table <ref type="table">2</ref>: ROP gadgets statistics for ROPGadget v4.0.4 and RP++ v0.4 utilities. "Orig." contains the gadgets for the original unprotected HideM binary, "Exec" contains the gadgets in the executable region of a HideM protected binary, and "Valid" contains the gadgets that can be used for exploitation. "(A/U)" or "All/Unique" represents the number of all gadgets and unique gadgets. Probability of exploit assumes only one specific gadget is necessary for exploitation (N=1). In reality, successful exploitation will require N &gt; 1. That said, our use of a split-TLB is primarily an implementation decision that demonstrates how HideM can enforce fine-grained code reading policies to prevent memory disclosures. Future work will consider how to realize HideM without a split-TLB. For example, virtualization is a promising approach to enforce read policy <ref type="bibr" target="#b27">[29]</ref>. Furthermore, HideM is similar to PAX in that we seek an implementation without CPU changes. We believe that HideM's fine-grained code reading policies are a powerful primitive that warrants investigation for inclusion into future CPU hardware designs (i.e., similar to the NX bit). Finally, HideM assumes that adversaries have no prior knowledge of code protected in memory. This can be achieved through fine-grained binary randomization techniques better known as code diversity <ref type="bibr" target="#b13">[15]</ref>. Fine-grained randomization can be achieved in numerous ways through both binary rewriting <ref type="bibr" target="#b32">[34]</ref> or compiler based approaches <ref type="bibr" target="#b9">[11]</ref>. The most efficient approaches show minimal overhead as small as 1-2% <ref type="bibr" target="#b13">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>PaX <ref type="bibr" target="#b26">[28]</ref> introduced non-executable page support in software using split-TLB architecture to enforce no-execute permissions on memory without support hardware. Modern hardware can enforce non-executable permissions on pages.</p><p>Van Oorschot et al. introduced bypassing self-hashing software checks via TLB de-synchronization <ref type="bibr" target="#b28">[30]</ref>. Checksum software would read valid pages instead of modified executable pages thereby passing checks for modification. Similarly, Shadow Walker introduced stealthy hiding of rootkits through TLB de-synchronization <ref type="bibr" target="#b23">[25]</ref>. These techniques prevent analysis of specific executable data but cannot protect the mechanism performing the de-synchronization.</p><p>Riley et al. used the split-TLB architecture to prevent code injection attacks <ref type="bibr" target="#b16">[18]</ref>. The authors used the split-TLB to only allow memory writes to data pages. Injected code would never fill a page added to the ITLB.</p><p>HideM has similarities to a Harvard architecture where code and data are stored separately <ref type="bibr" target="#b1">[3]</ref>. However, contemporary commodity hardware platforms implement a von Neumann memory architecture <ref type="bibr" target="#b30">[32]</ref> where code and data are accessible in the same address-space. HideM accesses code and data in the same address-space only different data is provided for different operations.</p><p>Multics introduced execute-only memory permissions <ref type="bibr" target="#b5">[7]</ref>. Execute-only memory could not be read by users programs. Modern binaries contain data on executable memory that make execute-only memory difficult to adopt in existing system. HideM uses both execute and read permissions for a given memory address to allow for seamless execution.</p><p>XoM encrypted executable memory which was only decrypted prior to instruction loads by a special hardware processor <ref type="bibr" target="#b14">[16]</ref>. Unfortunately, XoM suffers from poor performance and requires significant architectural changes. Suh et al. introduced modification to the XoM architecture to address performance issues but requires hardware architectural changes <ref type="bibr" target="#b24">[26]</ref>. HideM is targeted at commodity systems to protect vulnerable applications from leaking data.</p><p>Research has also focused on protecting the contents of application data. Overshadow protected application data from a malicious kernel using virtualization techniques to encrypt userspace pages during kernel execution <ref type="bibr" target="#b3">[5]</ref>. CleanOS used taint-tracking of sensitive application data in mobile devices to encrypt data that is not active <ref type="bibr" target="#b25">[27]</ref>. VirtualGhost uses SFI <ref type="bibr" target="#b31">[33]</ref> and CFI <ref type="bibr" target="#b0">[2]</ref> techniques to prevent a kernel from reading application data <ref type="bibr" target="#b6">[8]</ref>. All of these approaches do not address applications which leak their own data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>In this paper we presented HideM, a practical system to protect memory from leakage vulnerabilities on contemporary commodity hardware. HideM uses the split-TLB architecture to enforce fine-grained execute and read permission on memory by applying a code reading policy on memory reads and execution. The policy is generated from binary structure. HideM protects COTS and legacy binaries from disclosing critical information about memory contents. Our evaluation showed that HideM incurs limited overhead averaging 1.49% increase in runtime and 4.47% increase in memory. Furthermore, HideM significantly reduces to probability of exploitation. HideM is a practical system for enhancing the security of non-trivial applications with limited impact to performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: High level view of memory hiding shows different memory values based on memory access type (i.e., read or execute).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: HideM overview: Prior to execution, binaries are analyzed to identify data read by code. Locations are used to create code reading policy. Access is enforced through page permissions and de-synchronized TLB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Enforcing HideM protections: Page-faults trap all accesses to hidden pages. Then HideM configures hardware to differentiate reads and fetches. Access is allowed while TLB entries are not evicted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Percent execution overhead for Spec-Cpu2006 benchmarked applications.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Percent memory and disk overhead observed for each application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Probability of exploit for 10 binaries with highest probability using ROPGadget.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>This requirement effectively enables</figDesc><table><row><cell cols="2">Pre-execution</cell><cell></cell><cell></cell><cell></cell><cell>Execution</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Legacy/COTS Binary</cell><cell>Symbol + Data Analysis</cell><cell>Legacy/COTS Binary Data Locations +</cell><cell>Load Binary Data Locations</cell><cell>Load Information</cell><cell>Page Fault Policy Generation</cell><cell>Is Hidden Page? Read Policy</cell><cell>yes</cell><cell>no Apply Policy</cell><cell>Continue execution</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Non-trivial applications evaluated with specific workloads to test compatibility with HideM. Name # Experiment wireshark v1.6.7 Captured packets for 10 minutes, filtered TCP on port 80 dumpcap v1.6.7 Captured packets for 10 minutes gimp v2.6.12 Open JPEG, blur, enhanced, cropped gedit v3.4.1 Opened 189KB file, copied, pasted, saved lynx v2.8.8 Opened ncsu.edu website, navigated, posted forms in search python v2.7 Ran Volatility 2.3.1 pslist command on 1.0GB memory dump emacs v23.3.1 Opened, edited, saved text files of size 200KB and 1MB lyx v2.0.2 Opened classic thesis template, made modifications, compiled smplayer v0.7.0 Played 10 minute 720p video</figDesc><table><row><cell>Binary</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Unified L2 caches are standard beginning with</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2008" xml:id="foot_1"><p>Intel Nehalem architectures, ARM Cortex-A series, and AMD Phenom II.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>of Computing and Information Systems]: Security and Protection-Unauthorized access; D.4.6 [Operating System]: Security and Protection-Information Flow Controls; Access Controls * This work is supported by U.S. National Science Foundation (NSF) under grant CNS-1330553.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Control-flow integrity</title>
		<author>
			<persName><forename type="first">MartÃ­n</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihai</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulfar</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jay</forename><surname>Ligatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM conference on Computer and communications security</title>
		<meeting>the 12th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="340" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Proposed automatic calculating machine</title>
		<author>
			<persName><forename type="first">Howard</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Oettinger</surname></persName>
		</author>
		<author>
			<persName><surname>Bartee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Spectrum, IEEE</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="62" to="69" />
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">You can run but you can&apos;t read: Preventing disclosure exploits in executable code</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Kollenda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Koppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>NÃ¼rnberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jannik</forename><surname>Pewny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2014 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1342" to="1353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Overshadow: a virtualization-based approach to retrofitting protection in commodity operating systems</title>
		<author>
			<persName><forename type="first">Xiaoxin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pratap</forename><surname>Subrahmanyam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><forename type="middle">A</forename><surname>Waldspurger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dwoskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><forename type="middle">Rk</forename><surname>Ports</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="2" to="13" />
			<date type="published" when="2008">2008</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Tool Interface Standards Committee et al. Executable and linkable format (ELF). Specification, Unix System Laboratories</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Introduction and overview of the multics system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><forename type="middle">A</forename><surname>CorbatÃ³</surname></persName>
		</author>
		<author>
			<persName><surname>Vyssotsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the November 30-December 1, 1965, fall joint computer conference, part I</title>
		<meeting>the November 30-December 1, 1965, fall joint computer conference, part I</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1965">1965</date>
			<biblScope unit="page" from="185" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Virtual Ghost: Protecting applications from hostile operating systems</title>
		<author>
			<persName><forename type="first">John</forename><surname>Criswell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Dautenhahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vikram</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth international conference on Architectural support for programming languages and operating systems</title>
		<meeting>the nineteenth international conference on Architectural support for programming languages and operating systems</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Strengthening software self-checksumming via self-modifying code</title>
		<author>
			<persName><forename type="first">Jonathon</forename><forename type="middle">T</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihai</forename><surname>Christodorescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Kruger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Security Applications Conference, 21st Annual</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Out of control: Overcoming control-flow integrity</title>
		<author>
			<persName><forename type="first">Enes</forename><surname>GÃ¶ktas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elias</forename><surname>Athanasopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Herbert</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerogios</forename><surname>Portokalidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (SP), 2014 IEEE Symposium on</title>
		<meeting><address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014-05">May 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Profile-guided automated software diversity</title>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Homescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Neisius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Per</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Brunthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO), CGO &apos;13</title>
		<meeting>the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO), CGO &apos;13<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Microgadgets: Size does matter in turing-complete return-oriented programming</title>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Homescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stewart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Per</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Brunthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WOOT</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="64" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A: System Programming Guide</title>
		<author>
			<persName><surname>Intel</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">64</biblScope>
			<pubPlace>Part, 1</pubPlace>
		</imprint>
	</monogr>
	<note>Intel architectures manual</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Address space layout permutation (ASLP): Towards fine-grained randomization of commodity software</title>
		<author>
			<persName><forename type="first">Chongkyung</forename><surname>Kil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinsuk</forename><surname>Jim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Bookholt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peng</forename><surname>Ning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Security Applications Conference, 2006. ACSAC&apos;06. 22nd Annual</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="339" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SoK: Automated software diversity</title>
		<author>
			<persName><forename type="first">Per</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Homescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Brunthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 IEEE Symposium on Security and Privacy, SP &apos;14</title>
		<meeting>the 2014 IEEE Symposium on Security and Privacy, SP &apos;14<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="276" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Architectural support for copy and tamper resistant software</title>
		<author>
			<persName><forename type="first">David</forename><surname>Lie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chandramohan</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="168" to="177" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="https://labs.mwrinfosecurity.com/blog/2013/04/19/mwr-labs-pwn2own-2013-write-up---webkit-exploit/" />
		<title level="m">MWR labs pwn2own 2013 write-up. MWR Labs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An architectural approach to preventing code injection attacks. Dependable and Secure Computing</title>
		<author>
			<persName><forename type="first">Ryan</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuxian</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongyan</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="351" to="365" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Salwan</surname></persName>
		</author>
		<ptr target="http://shell-storm.org/project/ROPgadget/" />
		<imprint/>
	</monogr>
	<note>Ropgadget tool</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient fine-grained binary instrumentationwith applications to taint-tracking</title>
		<author>
			<persName><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Varun</forename><surname>Puranik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th annual IEEE/ACM international symposium on Code generation and optimization</title>
		<meeting>the 6th annual IEEE/ACM international symposium on Code generation and optimization</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="74" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Q: Exploit hardening made easy</title>
		<author>
			<persName><forename type="first">J</forename><surname>Edward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thanassis</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">ARM architecture reference manual</title>
		<author>
			<persName><forename type="first">David</forename><surname>Seal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Pearson Education</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The geometry of innocent flesh on the bone: Return-into-libc without function calls (on the x86)</title>
		<author>
			<persName><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM conference on Computer and communications security</title>
		<meeting>the 14th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="552" to="561" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Just-in-time code reuse: On the effectiveness of fine-grained address space layout randomization</title>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">Z</forename><surname>Snow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Monrose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucas</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Liebchen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 IEEE Symposium on Security and Privacy, SP &apos;13</title>
		<meeting>the 2013 IEEE Symposium on Security and Privacy, SP &apos;13<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="574" to="588" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Shadow walker: Raising the bar for rootkit detection. Black Hat Japan</title>
		<author>
			<persName><forename type="first">Sherri</forename><surname>Sparks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jamie</forename><surname>Butler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="504" to="533" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient memory integrity verification and encryption for secure processors</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">Edward</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dwaine</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Blaise</forename><surname>Gassend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marten</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 36th annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page">339</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Cleanos: Limiting mobile data exposure with idle eviction</title>
		<author>
			<persName><forename type="first">Yang</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phillip</forename><surname>Ames</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sravan</forename><surname>Bhamidipati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Bijlani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roxana</forename><surname>Geambasu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikhil</forename><surname>Sarda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>the 10th USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Non executable data pages</title>
		<author>
			<orgName type="collaboration">PaX Team</orgName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">More: measurement of running executables</title>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Torrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual Cyber and Information Security Research Conference</title>
		<meeting>the 9th Annual Cyber and Information Security Research Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="117" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Hardware-assisted circumvention of self-hashing software tamper resistance. Dependable and Secure Computing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anil</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Glenn</forename><surname>Somayaji</surname></persName>
		</author>
		<author>
			<persName><surname>Wurster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="82" to="92" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Microsoft portable executable and common object file format specification</title>
	</analytic>
	<monogr>
		<title level="m">C+ Visual and Business Unit</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">John</forename><surname>Von</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neumann</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Annals of the History of Computing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="27" to="75" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
	<note>First draft of a report on the edvac</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient software-based fault isolation</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Wahbe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Lucco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="203" to="216" />
			<date type="published" when="1994">1994</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Binary stirring: Self-randomizing instruction addresses of legacy x86 binary code</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Wartell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vishwath</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">W</forename><surname>Hamlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiqiang</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM conference on Computer and communications security</title>
		<meeting>the 2012 ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="157" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Differentiating code from data in x86 binaries</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Wartell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">W</forename><surname>Hamlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murat</forename><surname>Kantarcioglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bhavani</forename><surname>Thuraisingham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning and Knowledge Discovery in Databases</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="522" to="536" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The SPARC architecture manual</title>
		<author>
			<persName><forename type="first">L</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><surname>Gremond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NJ</title>
		<imprint>
			<biblScope unit="volume">07632</biblScope>
			<date type="published" when="1994">1994</date>
			<publisher>PTR Prentice Hall Englewood Cliffs</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Control flow integrity for COTS binaries</title>
		<author>
			<persName><forename type="first">Mingwei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
